digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 167879"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 167880"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 167881"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 167882"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 167883"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 167884"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 167885"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 167886"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 167887"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 167888"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 167889"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 167890"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 167891"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 167892"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 167893"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 167894"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 167895"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 167896"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 167897"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 167898"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 167899"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 167900"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 167901"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 167902"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 167903"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 167904"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 167905"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 167906"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 167907"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 167908"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 167909"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 167910"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 167911"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 167912"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 167913"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 167914"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 167915"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 167916"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 167917"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 167918"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 167919"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 167920"];
43 [label="LazyThreadSafetyMode.PublicationOnly 167921"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 167922"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 167923"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 167924"];
47 [label="LazyThreadSafetyMode.PublicationOnly 167925"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 167926"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 167927"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 167928"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 167929"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 167930"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 167931"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 167932"];
55 [label="LazyThreadSafetyMode.PublicationOnly 167933"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 167934"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 167935"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 167936"];
59 [label="LazyThreadSafetyMode.PublicationOnly 167937"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 167938"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 167939"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 167940"];
63 [label="LazyThreadSafetyMode.PublicationOnly 167941"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 167942"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 167943"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 167944"];
67 [label="LazyThreadSafetyMode.PublicationOnly 167945"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167946"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167947"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 167948"];
71 [label="LazyThreadSafetyMode.PublicationOnly 167949"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167950"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167951"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 167952"];
75 [label="LazyThreadSafetyMode.PublicationOnly 167953"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167954"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167955"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 167956"];
79 [label="LazyThreadSafetyMode.PublicationOnly 167957"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167958"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167959"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 167960"];
83 [label="LazyThreadSafetyMode.PublicationOnly 167961"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167962"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167963"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 167964"];
87 [label="LazyThreadSafetyMode.PublicationOnly 167965"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167966"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167967"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 167968"];
91 [label="LazyThreadSafetyMode.PublicationOnly 167969"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167970"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167971"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 167972"];
95 [label="LazyThreadSafetyMode.PublicationOnly 167973"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 167974"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 167975"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 167976"];
99 [label="LazyThreadSafetyMode.PublicationOnly 167977"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 167978"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 167979"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 167980"];
103 [label="LazyThreadSafetyMode.PublicationOnly 167981"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167982"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167983"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 167984"];
107 [label="LazyThreadSafetyMode.PublicationOnly 167985"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167986"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167987"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 167988"];
111 [label="LazyThreadSafetyMode.PublicationOnly 167989"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167990"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167991"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 167992"];
115 [label="LazyThreadSafetyMode.PublicationOnly 167993"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167994"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 167995"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 167996"];
119 [label="LazyThreadSafetyMode.PublicationOnly 167997"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 167998"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 167999"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 168000"];
123 [label="LazyThreadSafetyMode.PublicationOnly 168001"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168002"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168003"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 168004"];
127 [label="LazyThreadSafetyMode.PublicationOnly 168005"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168006"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168007"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 168008"];
131 [label="LazyThreadSafetyMode.PublicationOnly 168009"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168010"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168011"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 168012"];
135 [label="LazyThreadSafetyMode.PublicationOnly 168013"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168014"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168015"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 168016"];
139 [label="LazyThreadSafetyMode.PublicationOnly 168017"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168018"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168019"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 168020"];
143 [label="LazyThreadSafetyMode.PublicationOnly 168021"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168022"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168023"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 168024"];
147 [label="LazyThreadSafetyMode.PublicationOnly 168025"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168026"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168027"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 168028"];
151 [label="LazyThreadSafetyMode.PublicationOnly 168029"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168030"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168031"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 168032"];
155 [label="LazyThreadSafetyMode.PublicationOnly 168033"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168034"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168035"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 168036"];
159 [label="LazyThreadSafetyMode.PublicationOnly 168037"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168038"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168039"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 168040"];
163 [label="LazyThreadSafetyMode.PublicationOnly 168041"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168042"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168043"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 168044"];
167 [label="LazyThreadSafetyMode.PublicationOnly 168045"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168046"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168047"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 168048"];
171 [label="LazyThreadSafetyMode.PublicationOnly 168049"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168050"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 168051"];
174 [label="@'R:\\Invalid.dll' 168052"];
175 [label="fullPath: @'R:\\Invalid.dll' 168053"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 168054"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 168055"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 168056"];
179 [label="MscorlibRef_v4_0_30316_17626 168057"];
180 [label="Net451.mscorlib 168058"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 168059"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 168060"];
183 [label="'/*<bind>*/' 168061"];
184 [label="StartString = '/*<bind>*/' 168062"];
185 [label="'/*</bind>*/' 168063"];
186 [label="EndString = '/*</bind>*/' 168064"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 168065"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 168066"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 168067"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 168068"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 168069"];
192 [label="param StatementParsingTests(this) 168070"];
193 [label="output 168071"];
194 [label="param ParsingTests(ITestOutputHelper output) 168072"];
195 [label="param ParsingTests(this) 168073"];
196 [label="param CSharpTestBase(this) 168074"];
197 [label="param CommonTestBase(this) 168075"];
198 [label="param TestBase(this) 168076"];
199 [label="_temp 168077"];
200 [label="_node 168078"];
201 [label="_treeEnumerator 168079"];
202 [label="_output 168080"];
203 [label="this._output 168081"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 168082"];
205 [label="param TestSwitchWithMultipleStatementsOnOneCase(this) 168083"];
206 [label="var text = 'switch (a) { case b: s1(); s2(); }'; 168084"];
207 [label="var statement = this.ParseStatement(text); 168085"];
208 [label="var statement = this.ParseStatement(text); 168086"];
209 [label="this.ParseStatement(text) 168087"];
210 [label="param ParseStatement(string text) 168088"];
211 [label="param ParseStatement(int offset = 0) 168089"];
212 [label="param ParseStatement(ParseOptions options = null) 168090"];
213 [label="param ParseStatement(this) 168091"];
214 [label="'\\r\\n' 168092"];
215 [label="CrLf = '\\r\\n' 168093"];
216 [label="CrLf 168094"];
217 [label="EndOfLine(CrLf) 168095"];
218 [label="param EndOfLine(string text) 168096"];
219 [label="param EndOfLine(bool elastic = false) 168097"];
220 [label="SyntaxTrivia trivia = null; 168098"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168099"];
222 [label="elastic 168100"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 168101"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168102"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168103"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 168104"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168105"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168106"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168107"];
230 [label="param Create(SyntaxKind kind) 168108"];
231 [label="param Create(string text) 168109"];
232 [label="return new SyntaxTrivia(kind, text); 168110"];
233 [label="return new SyntaxTrivia(kind, text); 168111"];
234 [label="return new SyntaxTrivia(kind, text); 168112"];
235 [label="new SyntaxTrivia(kind, text) 168113"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 168114"];
237 [label="param SyntaxTrivia(string text) 168115"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168116"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168117"];
240 [label="param SyntaxTrivia(this) 168118"];
241 [label="kind 168119"];
242 [label="diagnostics 168120"];
243 [label="annotations 168121"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 168122"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 168123"];
246 [label="text 168124"];
247 [label="param SyntaxTrivia(this) 168125"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 168126"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168127"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168128"];
251 [label="param CSharpSyntaxNode(int fullWidth) 168129"];
252 [label="param CSharpSyntaxNode(this) 168130"];
253 [label="kind 168131"];
254 [label="diagnostics 168132"];
255 [label="annotations 168133"];
256 [label="fullWidth 168134"];
257 [label="param CSharpSyntaxNode(this) 168135"];
258 [label="param CSharpSyntaxNode(this) 168136"];
259 [label="GreenStats.NoteGreen(this); 168137"];
260 [label="GreenStats.NoteGreen(this); 168138"];
261 [label="Text 168139"];
262 [label="this.Text 168140"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168141"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168142"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 168143"];
266 [label="return trivia; 168144"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 168145"];
268 [label="'\\n' 168146"];
269 [label="EndOfLine('\\n') 168147"];
270 [label="param EndOfLine(string text) 168148"];
271 [label="param EndOfLine(bool elastic = false) 168149"];
272 [label="SyntaxTrivia trivia = null; 168150"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168151"];
274 [label="elastic 168152"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 168153"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168154"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168155"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168156"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168157"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168158"];
281 [label="param Create(SyntaxKind kind) 168159"];
282 [label="param Create(string text) 168160"];
283 [label="return new SyntaxTrivia(kind, text); 168161"];
284 [label="return new SyntaxTrivia(kind, text); 168162"];
285 [label="return new SyntaxTrivia(kind, text); 168163"];
286 [label="new SyntaxTrivia(kind, text) 168164"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 168165"];
288 [label="param SyntaxTrivia(string text) 168166"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168167"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168168"];
291 [label="param SyntaxTrivia(this) 168169"];
292 [label="kind 168170"];
293 [label="diagnostics 168171"];
294 [label="annotations 168172"];
295 [label="text 168173"];
296 [label="param SyntaxTrivia(this) 168174"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 168175"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168176"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168177"];
300 [label="param CSharpSyntaxNode(int fullWidth) 168178"];
301 [label="param CSharpSyntaxNode(this) 168179"];
302 [label="kind 168180"];
303 [label="diagnostics 168181"];
304 [label="annotations 168182"];
305 [label="fullWidth 168183"];
306 [label="param CSharpSyntaxNode(this) 168184"];
307 [label="param CSharpSyntaxNode(this) 168185"];
308 [label="GreenStats.NoteGreen(this); 168186"];
309 [label="GreenStats.NoteGreen(this); 168187"];
310 [label="Text 168188"];
311 [label="this.Text 168189"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168190"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168191"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 168192"];
315 [label="return trivia; 168193"];
316 [label="LineFeed = EndOfLine('\\n') 168194"];
317 [label="'\\r' 168195"];
318 [label="EndOfLine('\\r') 168196"];
319 [label="param EndOfLine(string text) 168197"];
320 [label="param EndOfLine(bool elastic = false) 168198"];
321 [label="SyntaxTrivia trivia = null; 168199"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168200"];
323 [label="elastic 168201"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 168202"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168203"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168204"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168205"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168206"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168207"];
330 [label="param Create(SyntaxKind kind) 168208"];
331 [label="param Create(string text) 168209"];
332 [label="return new SyntaxTrivia(kind, text); 168210"];
333 [label="return new SyntaxTrivia(kind, text); 168211"];
334 [label="return new SyntaxTrivia(kind, text); 168212"];
335 [label="new SyntaxTrivia(kind, text) 168213"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 168214"];
337 [label="param SyntaxTrivia(string text) 168215"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168216"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168217"];
340 [label="param SyntaxTrivia(this) 168218"];
341 [label="kind 168219"];
342 [label="diagnostics 168220"];
343 [label="annotations 168221"];
344 [label="text 168222"];
345 [label="param SyntaxTrivia(this) 168223"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 168224"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168225"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168226"];
349 [label="param CSharpSyntaxNode(int fullWidth) 168227"];
350 [label="param CSharpSyntaxNode(this) 168228"];
351 [label="kind 168229"];
352 [label="diagnostics 168230"];
353 [label="annotations 168231"];
354 [label="fullWidth 168232"];
355 [label="param CSharpSyntaxNode(this) 168233"];
356 [label="param CSharpSyntaxNode(this) 168234"];
357 [label="GreenStats.NoteGreen(this); 168235"];
358 [label="GreenStats.NoteGreen(this); 168236"];
359 [label="Text 168237"];
360 [label="this.Text 168238"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168239"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168240"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 168241"];
364 [label="return trivia; 168242"];
365 [label="CarriageReturn = EndOfLine('\\r') 168243"];
366 [label="' ' 168244"];
367 [label="Whitespace(' ') 168245"];
368 [label="param Whitespace(string text) 168246"];
369 [label="param Whitespace(bool elastic = false) 168247"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168248"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168249"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 168250"];
373 [label="param Create(SyntaxKind kind) 168251"];
374 [label="param Create(string text) 168252"];
375 [label="return new SyntaxTrivia(kind, text); 168253"];
376 [label="return new SyntaxTrivia(kind, text); 168254"];
377 [label="return new SyntaxTrivia(kind, text); 168255"];
378 [label="new SyntaxTrivia(kind, text) 168256"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 168257"];
380 [label="param SyntaxTrivia(string text) 168258"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168259"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168260"];
383 [label="param SyntaxTrivia(this) 168261"];
384 [label="kind 168262"];
385 [label="diagnostics 168263"];
386 [label="annotations 168264"];
387 [label="text 168265"];
388 [label="param SyntaxTrivia(this) 168266"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 168267"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168268"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168269"];
392 [label="param CSharpSyntaxNode(int fullWidth) 168270"];
393 [label="param CSharpSyntaxNode(this) 168271"];
394 [label="kind 168272"];
395 [label="diagnostics 168273"];
396 [label="annotations 168274"];
397 [label="fullWidth 168275"];
398 [label="param CSharpSyntaxNode(this) 168276"];
399 [label="param CSharpSyntaxNode(this) 168277"];
400 [label="GreenStats.NoteGreen(this); 168278"];
401 [label="GreenStats.NoteGreen(this); 168279"];
402 [label="Text 168280"];
403 [label="this.Text 168281"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168282"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168283"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 168284"];
407 [label="return trivia; 168285"];
408 [label="Space = Whitespace(' ') 168286"];
409 [label="'\\t' 168287"];
410 [label="Whitespace('\\t') 168288"];
411 [label="param Whitespace(string text) 168289"];
412 [label="param Whitespace(bool elastic = false) 168290"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168291"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168292"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 168293"];
416 [label="param Create(SyntaxKind kind) 168294"];
417 [label="param Create(string text) 168295"];
418 [label="return new SyntaxTrivia(kind, text); 168296"];
419 [label="return new SyntaxTrivia(kind, text); 168297"];
420 [label="return new SyntaxTrivia(kind, text); 168298"];
421 [label="new SyntaxTrivia(kind, text) 168299"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 168300"];
423 [label="param SyntaxTrivia(string text) 168301"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168302"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168303"];
426 [label="param SyntaxTrivia(this) 168304"];
427 [label="kind 168305"];
428 [label="diagnostics 168306"];
429 [label="annotations 168307"];
430 [label="text 168308"];
431 [label="param SyntaxTrivia(this) 168309"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 168310"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168311"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168312"];
435 [label="param CSharpSyntaxNode(int fullWidth) 168313"];
436 [label="param CSharpSyntaxNode(this) 168314"];
437 [label="kind 168315"];
438 [label="diagnostics 168316"];
439 [label="annotations 168317"];
440 [label="fullWidth 168318"];
441 [label="param CSharpSyntaxNode(this) 168319"];
442 [label="param CSharpSyntaxNode(this) 168320"];
443 [label="GreenStats.NoteGreen(this); 168321"];
444 [label="GreenStats.NoteGreen(this); 168322"];
445 [label="Text 168323"];
446 [label="this.Text 168324"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168325"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168326"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 168327"];
450 [label="return trivia; 168328"];
451 [label="Tab = Whitespace('\\t') 168329"];
452 [label="CrLf 168330"];
453 [label="true 168331"];
454 [label="elastic: true 168332"];
455 [label="EndOfLine(CrLf, elastic: true) 168333"];
456 [label="param EndOfLine(string text) 168334"];
457 [label="param EndOfLine(bool elastic = false) 168335"];
458 [label="SyntaxTrivia trivia = null; 168336"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168337"];
460 [label="elastic 168338"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 168339"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168340"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168341"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168342"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168343"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168344"];
467 [label="param Create(SyntaxKind kind) 168345"];
468 [label="param Create(string text) 168346"];
469 [label="return new SyntaxTrivia(kind, text); 168347"];
470 [label="return new SyntaxTrivia(kind, text); 168348"];
471 [label="return new SyntaxTrivia(kind, text); 168349"];
472 [label="new SyntaxTrivia(kind, text) 168350"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 168351"];
474 [label="param SyntaxTrivia(string text) 168352"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168353"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168354"];
477 [label="param SyntaxTrivia(this) 168355"];
478 [label="kind 168356"];
479 [label="diagnostics 168357"];
480 [label="annotations 168358"];
481 [label="text 168359"];
482 [label="param SyntaxTrivia(this) 168360"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 168361"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168362"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168363"];
486 [label="param CSharpSyntaxNode(int fullWidth) 168364"];
487 [label="param CSharpSyntaxNode(this) 168365"];
488 [label="kind 168366"];
489 [label="diagnostics 168367"];
490 [label="annotations 168368"];
491 [label="fullWidth 168369"];
492 [label="param CSharpSyntaxNode(this) 168370"];
493 [label="param CSharpSyntaxNode(this) 168371"];
494 [label="GreenStats.NoteGreen(this); 168372"];
495 [label="GreenStats.NoteGreen(this); 168373"];
496 [label="Text 168374"];
497 [label="this.Text 168375"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168376"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168377"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 168378"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168379"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168380"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168381"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168382"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 168383"];
506 [label="param SetAnnotations(this) 168384"];
507 [label="this.Kind 168385"];
508 [label="get { return (SyntaxKind)this.RawKind; } 168386"];
509 [label="return (SyntaxKind)this.RawKind; 168387"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168388"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168389"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168390"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168391"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168392"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 168393"];
516 [label="param SyntaxTrivia(string text) 168394"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168395"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168396"];
519 [label="param SyntaxTrivia(this) 168397"];
520 [label="param SyntaxTrivia(this) 168398"];
521 [label="param CSharpSyntaxNode(this) 168399"];
522 [label="param CSharpSyntaxNode(this) 168400"];
523 [label="param CSharpSyntaxNode(this) 168401"];
524 [label="GreenStats.NoteGreen(this); 168402"];
525 [label="Text 168403"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168404"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 168405"];
528 [label="'\\n' 168406"];
529 [label="true 168407"];
530 [label="elastic: true 168408"];
531 [label="EndOfLine('\\n', elastic: true) 168409"];
532 [label="param EndOfLine(string text) 168410"];
533 [label="param EndOfLine(bool elastic = false) 168411"];
534 [label="SyntaxTrivia trivia = null; 168412"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168413"];
536 [label="elastic 168414"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 168415"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168416"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168417"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168418"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168419"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168420"];
543 [label="param Create(SyntaxKind kind) 168421"];
544 [label="param Create(string text) 168422"];
545 [label="return new SyntaxTrivia(kind, text); 168423"];
546 [label="return new SyntaxTrivia(kind, text); 168424"];
547 [label="return new SyntaxTrivia(kind, text); 168425"];
548 [label="new SyntaxTrivia(kind, text) 168426"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 168427"];
550 [label="param SyntaxTrivia(string text) 168428"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168429"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168430"];
553 [label="param SyntaxTrivia(this) 168431"];
554 [label="kind 168432"];
555 [label="diagnostics 168433"];
556 [label="annotations 168434"];
557 [label="text 168435"];
558 [label="param SyntaxTrivia(this) 168436"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 168437"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168438"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168439"];
562 [label="param CSharpSyntaxNode(int fullWidth) 168440"];
563 [label="param CSharpSyntaxNode(this) 168441"];
564 [label="kind 168442"];
565 [label="diagnostics 168443"];
566 [label="annotations 168444"];
567 [label="fullWidth 168445"];
568 [label="param CSharpSyntaxNode(this) 168446"];
569 [label="param CSharpSyntaxNode(this) 168447"];
570 [label="GreenStats.NoteGreen(this); 168448"];
571 [label="GreenStats.NoteGreen(this); 168449"];
572 [label="Text 168450"];
573 [label="this.Text 168451"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168452"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168453"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 168454"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168455"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168456"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168457"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168458"];
581 [label="this.Kind 168459"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168460"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168461"];
584 [label="param SyntaxTrivia(this) 168462"];
585 [label="param SyntaxTrivia(this) 168463"];
586 [label="param CSharpSyntaxNode(this) 168464"];
587 [label="param CSharpSyntaxNode(this) 168465"];
588 [label="GreenStats.NoteGreen(this); 168466"];
589 [label="Text 168467"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168468"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 168469"];
592 [label="'\\r' 168470"];
593 [label="true 168471"];
594 [label="elastic: true 168472"];
595 [label="EndOfLine('\\r', elastic: true) 168473"];
596 [label="param EndOfLine(string text) 168474"];
597 [label="param EndOfLine(bool elastic = false) 168475"];
598 [label="SyntaxTrivia trivia = null; 168476"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 168477"];
600 [label="elastic 168478"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 168479"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168480"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 168481"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168482"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168483"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 168484"];
607 [label="param Create(SyntaxKind kind) 168485"];
608 [label="param Create(string text) 168486"];
609 [label="return new SyntaxTrivia(kind, text); 168487"];
610 [label="return new SyntaxTrivia(kind, text); 168488"];
611 [label="return new SyntaxTrivia(kind, text); 168489"];
612 [label="new SyntaxTrivia(kind, text) 168490"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 168491"];
614 [label="param SyntaxTrivia(string text) 168492"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168493"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168494"];
617 [label="param SyntaxTrivia(this) 168495"];
618 [label="kind 168496"];
619 [label="diagnostics 168497"];
620 [label="annotations 168498"];
621 [label="text 168499"];
622 [label="param SyntaxTrivia(this) 168500"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 168501"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168502"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168503"];
626 [label="param CSharpSyntaxNode(int fullWidth) 168504"];
627 [label="param CSharpSyntaxNode(this) 168505"];
628 [label="kind 168506"];
629 [label="diagnostics 168507"];
630 [label="annotations 168508"];
631 [label="fullWidth 168509"];
632 [label="param CSharpSyntaxNode(this) 168510"];
633 [label="param CSharpSyntaxNode(this) 168511"];
634 [label="GreenStats.NoteGreen(this); 168512"];
635 [label="GreenStats.NoteGreen(this); 168513"];
636 [label="Text 168514"];
637 [label="this.Text 168515"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168516"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 168517"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 168518"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168519"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168520"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168521"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168522"];
645 [label="this.Kind 168523"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168524"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168525"];
648 [label="param SyntaxTrivia(this) 168526"];
649 [label="param SyntaxTrivia(this) 168527"];
650 [label="param CSharpSyntaxNode(this) 168528"];
651 [label="param CSharpSyntaxNode(this) 168529"];
652 [label="GreenStats.NoteGreen(this); 168530"];
653 [label="Text 168531"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168532"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 168533"];
656 [label="' ' 168534"];
657 [label="true 168535"];
658 [label="elastic: true 168536"];
659 [label="Whitespace(' ', elastic: true) 168537"];
660 [label="param Whitespace(string text) 168538"];
661 [label="param Whitespace(bool elastic = false) 168539"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168540"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168541"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 168542"];
665 [label="param Create(SyntaxKind kind) 168543"];
666 [label="param Create(string text) 168544"];
667 [label="return new SyntaxTrivia(kind, text); 168545"];
668 [label="return new SyntaxTrivia(kind, text); 168546"];
669 [label="return new SyntaxTrivia(kind, text); 168547"];
670 [label="new SyntaxTrivia(kind, text) 168548"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 168549"];
672 [label="param SyntaxTrivia(string text) 168550"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168551"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168552"];
675 [label="param SyntaxTrivia(this) 168553"];
676 [label="kind 168554"];
677 [label="diagnostics 168555"];
678 [label="annotations 168556"];
679 [label="text 168557"];
680 [label="param SyntaxTrivia(this) 168558"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 168559"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168560"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168561"];
684 [label="param CSharpSyntaxNode(int fullWidth) 168562"];
685 [label="param CSharpSyntaxNode(this) 168563"];
686 [label="kind 168564"];
687 [label="diagnostics 168565"];
688 [label="annotations 168566"];
689 [label="fullWidth 168567"];
690 [label="param CSharpSyntaxNode(this) 168568"];
691 [label="param CSharpSyntaxNode(this) 168569"];
692 [label="GreenStats.NoteGreen(this); 168570"];
693 [label="GreenStats.NoteGreen(this); 168571"];
694 [label="Text 168572"];
695 [label="this.Text 168573"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168574"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168575"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 168576"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168577"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168578"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168579"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168580"];
703 [label="this.Kind 168581"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168582"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168583"];
706 [label="param SyntaxTrivia(this) 168584"];
707 [label="param SyntaxTrivia(this) 168585"];
708 [label="param CSharpSyntaxNode(this) 168586"];
709 [label="param CSharpSyntaxNode(this) 168587"];
710 [label="GreenStats.NoteGreen(this); 168588"];
711 [label="Text 168589"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168590"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 168591"];
714 [label="'\\t' 168592"];
715 [label="true 168593"];
716 [label="elastic: true 168594"];
717 [label="Whitespace('\\t', elastic: true) 168595"];
718 [label="param Whitespace(string text) 168596"];
719 [label="param Whitespace(bool elastic = false) 168597"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168598"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168599"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 168600"];
723 [label="param Create(SyntaxKind kind) 168601"];
724 [label="param Create(string text) 168602"];
725 [label="return new SyntaxTrivia(kind, text); 168603"];
726 [label="return new SyntaxTrivia(kind, text); 168604"];
727 [label="return new SyntaxTrivia(kind, text); 168605"];
728 [label="new SyntaxTrivia(kind, text) 168606"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 168607"];
730 [label="param SyntaxTrivia(string text) 168608"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168609"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168610"];
733 [label="param SyntaxTrivia(this) 168611"];
734 [label="kind 168612"];
735 [label="diagnostics 168613"];
736 [label="annotations 168614"];
737 [label="text 168615"];
738 [label="param SyntaxTrivia(this) 168616"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 168617"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168618"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168619"];
742 [label="param CSharpSyntaxNode(int fullWidth) 168620"];
743 [label="param CSharpSyntaxNode(this) 168621"];
744 [label="kind 168622"];
745 [label="diagnostics 168623"];
746 [label="annotations 168624"];
747 [label="fullWidth 168625"];
748 [label="param CSharpSyntaxNode(this) 168626"];
749 [label="param CSharpSyntaxNode(this) 168627"];
750 [label="GreenStats.NoteGreen(this); 168628"];
751 [label="GreenStats.NoteGreen(this); 168629"];
752 [label="Text 168630"];
753 [label="this.Text 168631"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168632"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168633"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 168634"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168635"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168636"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168637"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168638"];
761 [label="this.Kind 168639"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168640"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168641"];
764 [label="param SyntaxTrivia(this) 168642"];
765 [label="param SyntaxTrivia(this) 168643"];
766 [label="param CSharpSyntaxNode(this) 168644"];
767 [label="param CSharpSyntaxNode(this) 168645"];
768 [label="GreenStats.NoteGreen(this); 168646"];
769 [label="Text 168647"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168648"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 168649"];
772 [label="string.Empty 168650"];
773 [label="true 168651"];
774 [label="elastic: true 168652"];
775 [label="Whitespace(string.Empty, elastic: true) 168653"];
776 [label="param Whitespace(string text) 168654"];
777 [label="param Whitespace(bool elastic = false) 168655"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168656"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168657"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 168658"];
781 [label="param Create(SyntaxKind kind) 168659"];
782 [label="param Create(string text) 168660"];
783 [label="return new SyntaxTrivia(kind, text); 168661"];
784 [label="return new SyntaxTrivia(kind, text); 168662"];
785 [label="return new SyntaxTrivia(kind, text); 168663"];
786 [label="new SyntaxTrivia(kind, text) 168664"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 168665"];
788 [label="param SyntaxTrivia(string text) 168666"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 168667"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 168668"];
791 [label="param SyntaxTrivia(this) 168669"];
792 [label="kind 168670"];
793 [label="diagnostics 168671"];
794 [label="annotations 168672"];
795 [label="text 168673"];
796 [label="param SyntaxTrivia(this) 168674"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 168675"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 168676"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 168677"];
800 [label="param CSharpSyntaxNode(int fullWidth) 168678"];
801 [label="param CSharpSyntaxNode(this) 168679"];
802 [label="kind 168680"];
803 [label="diagnostics 168681"];
804 [label="annotations 168682"];
805 [label="fullWidth 168683"];
806 [label="param CSharpSyntaxNode(this) 168684"];
807 [label="param CSharpSyntaxNode(this) 168685"];
808 [label="GreenStats.NoteGreen(this); 168686"];
809 [label="GreenStats.NoteGreen(this); 168687"];
810 [label="Text 168688"];
811 [label="this.Text 168689"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168690"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 168691"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 168692"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168693"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168694"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 168695"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 168696"];
819 [label="this.Kind 168697"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 168698"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 168699"];
822 [label="param SyntaxTrivia(this) 168700"];
823 [label="param SyntaxTrivia(this) 168701"];
824 [label="param CSharpSyntaxNode(this) 168702"];
825 [label="param CSharpSyntaxNode(this) 168703"];
826 [label="GreenStats.NoteGreen(this); 168704"];
827 [label="Text 168705"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 168706"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 168707"];
830 [label="s_xmlCarriageReturnLineFeed 168708"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 168709"];
832 [label="param operator(SyntaxTrivia trivia) 168710"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168711"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168712"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168713"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 168714"];
837 [label="param operator(SyntaxTrivia trivia) 168715"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168716"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168717"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168718"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 168719"];
842 [label="param operator(SyntaxTrivia trivia) 168720"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168721"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168722"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168723"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 168724"];
847 [label="param operator(SyntaxTrivia trivia) 168725"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168726"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168727"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168728"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 168729"];
852 [label="param operator(SyntaxTrivia trivia) 168730"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168731"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168732"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168733"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 168734"];
857 [label="param operator(SyntaxTrivia trivia) 168735"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168736"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168737"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168738"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 168739"];
862 [label="param operator(SyntaxTrivia trivia) 168740"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168741"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168742"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168743"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 168744"];
867 [label="param operator(SyntaxTrivia trivia) 168745"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168746"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168747"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168748"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 168749"];
872 [label="param operator(SyntaxTrivia trivia) 168750"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168751"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168752"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168753"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 168754"];
877 [label="param operator(SyntaxTrivia trivia) 168755"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168756"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168757"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168758"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 168759"];
882 [label="param operator(SyntaxTrivia trivia) 168760"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168761"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168762"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 168763"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 168764"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 168765"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 168766"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 168767"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 168768"];
891 [label="param ParseStatement(string text) 168769"];
892 [label="param ParseStatement(int offset = 0) 168770"];
893 [label="param ParseStatement(ParseOptions? options = null) 168771"];
894 [label="param ParseStatement(bool consumeFullText = true) 168772"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 168773"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 168774"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 168775"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 168776"];
899 [label="param MakeLexer(string text) 168777"];
900 [label="param MakeLexer(int offset) 168778"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 168779"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 168780"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 168781"];
904 [label="MakeSourceText(text, offset) 168782"];
905 [label="param MakeSourceText(string text) 168783"];
906 [label="param MakeSourceText(int offset) 168784"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 168785"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 168786"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 168787"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 168788"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 168789"];
912 [label="new CSharpParseOptions() 168790"];
913 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 168791"];
914 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 168792"];
915 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 168793"];
916 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 168794"];
917 [label="param CSharpParseOptions(this) 168795"];
918 [label="languageVersion 168796"];
919 [label="documentationMode 168797"];
920 [label="kind 168798"];
921 [label="preprocessorSymbols 168799"];
922 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 168800"];
923 [label="ImmutableDictionary<string, string>.Empty 168801"];
924 [label="param CSharpParseOptions(LanguageVersion languageVersion) 168802"];
925 [label="param CSharpParseOptions(DocumentationMode documentationMode) 168803"];
926 [label="param CSharpParseOptions(SourceCodeKind kind) 168804"];
927 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 168805"];
928 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 168806"];
929 [label="param CSharpParseOptions(this) 168807"];
930 [label="kind 168808"];
931 [label="documentationMode 168809"];
932 [label="param CSharpParseOptions(this) 168810"];
933 [label="_features 168811"];
934 [label="public LanguageVersion LanguageVersion { get; private set; } 168812"];
935 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 168813"];
936 [label="this.SpecifiedLanguageVersion 168814"];
937 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 168815"];
938 [label="languageVersion.MapSpecifiedToEffectiveVersion() 168816"];
939 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 168817"];
940 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 168818"];
941 [label="return LanguageVersion.CSharp9; 168819"];
942 [label="this.LanguageVersion 168820"];
943 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 168821"];
944 [label="this.PreprocessorSymbols 168822"];
945 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 168823"];
946 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 168824"];
947 [label="_features 168825"];
948 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 168826"];
949 [label="8 168827"];
950 [label="TriviaListInitialCapacity = 8 168828"];
951 [label="TokensLexed 168829"];
952 [label="'<<<<<<<' 168830"];
953 [label="s_conflictMarkerLength = '<<<<<<<'.Length 168831"];
954 [label="42 168832"];
955 [label="MaxCachedTokenSize = 42 168833"];
956 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168834"];
957 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 168835"];
958 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168836"];
959 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168837"];
960 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168838"];
961 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168839"];
962 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168840"];
963 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168841"];
964 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168842"];
965 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 168843"];
966 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168844"];
967 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168845"];
968 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168846"];
969 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168847"];
970 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168848"];
971 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168849"];
972 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168850"];
973 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168851"];
974 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168852"];
975 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 168853"];
976 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 168854"];
977 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 168855"];
978 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 168856"];
979 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 168857"];
980 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 168858"];
981 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 168859"];
982 [label="param Lexer(SourceText text) 168860"];
983 [label="param Lexer(CSharpParseOptions options) 168861"];
984 [label="param Lexer(bool allowPreprocessorDirectives = true) 168862"];
985 [label="param Lexer(bool interpolationFollowedByColon = false) 168863"];
986 [label="param Lexer(this) 168864"];
987 [label="text 168865"];
988 [label="param Lexer(this) 168866"];
989 [label="param AbstractLexer(SourceText text) 168867"];
990 [label="param AbstractLexer(this) 168868"];
991 [label="TextWindow 168869"];
992 [label="_errors 168870"];
993 [label="InvalidCharacter = char.MaxValue 168871"];
994 [label="2048 168872"];
995 [label="DefaultWindowLength = 2048 168873"];
996 [label="() => new char[DefaultWindowLength] 168874"];
997 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 168875"];
998 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 168876"];
999 [label="this.TextWindow = new SlidingTextWindow(text); 168877"];
1000 [label="this.TextWindow = new SlidingTextWindow(text); 168878"];
1001 [label="new SlidingTextWindow(text) 168879"];
1002 [label="param SlidingTextWindow(SourceText text) 168880"];
1003 [label="param SlidingTextWindow(this) 168881"];
1004 [label="_text 168882"];
1005 [label="_basis 168883"];
1006 [label="_offset 168884"];
1007 [label="_textEnd 168885"];
1008 [label="_characterWindow 168886"];
1009 [label="_characterWindowCount 168887"];
1010 [label="_lexemeStart 168888"];
1011 [label="_strings 168889"];
1012 [label="_text 168890"];
1013 [label="_basis = 0; 168891"];
1014 [label="_basis 168892"];
1015 [label="_offset = 0; 168893"];
1016 [label="_offset 168894"];
1017 [label="_textEnd 168895"];
1018 [label="_strings = StringTable.GetInstance(); 168896"];
1019 [label="_strings 168897"];
1020 [label="_characterWindow = s_windowPool.Allocate(); 168898"];
1021 [label="_characterWindow 168899"];
1022 [label="_lexemeStart = 0; 168900"];
1023 [label="_lexemeStart 168901"];
1024 [label="this.TextWindow 168902"];
1025 [label="_options 168903"];
1026 [label="_mode 168904"];
1027 [label="_builder 168905"];
1028 [label="_identBuffer 168906"];
1029 [label="_identLen 168907"];
1030 [label="_cache 168908"];
1031 [label="_allowPreprocessorDirectives 168909"];
1032 [label="_interpolationFollowedByColon 168910"];
1033 [label="_xmlParser 168911"];
1034 [label="_badTokenCount 168912"];
1035 [label="10 168913"];
1036 [label="new SyntaxListBuilder(10) 168914"];
1037 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 168915"];
1038 [label="10 168916"];
1039 [label="new SyntaxListBuilder(10) 168917"];
1040 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 168918"];
1041 [label="_createWhitespaceTriviaFunction 168919"];
1042 [label="_createQuickTokenFunction 168920"];
1043 [label="Debug.Assert(options != null); 168921"];
1044 [label="Debug.Assert(options != null); 168922"];
1045 [label="_options 168923"];
1046 [label="_builder = new StringBuilder(); 168924"];
1047 [label="_builder 168925"];
1048 [label="_identBuffer = new char[32]; 168926"];
1049 [label="_identBuffer 168927"];
1050 [label="512 168928"];
1051 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 168929"];
1052 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 168930"];
1053 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 168931"];
1054 [label="10 168932"];
1055 [label="MaxKeywordLength = 10 168933"];
1056 [label="_cache = new LexerCache(); 168934"];
1057 [label="new LexerCache() 168935"];
1058 [label="param LexerCache(this) 168936"];
1059 [label="_triviaMap 168937"];
1060 [label="_tokenMap 168938"];
1061 [label="_keywordKindMap 168939"];
1062 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 168940"];
1063 [label="_triviaMap 168941"];
1064 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 168942"];
1065 [label="_tokenMap 168943"];
1066 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 168944"];
1067 [label="_keywordKindMap 168945"];
1068 [label="_cache 168946"];
1069 [label="_createQuickTokenFunction 168947"];
1070 [label="_allowPreprocessorDirectives 168948"];
1071 [label="_interpolationFollowedByColon 168949"];
1072 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 168950"];
1073 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 168951"];
1074 [label="MakeParser(lexer) 168952"];
1075 [label="param MakeParser(InternalSyntax.Lexer lexer) 168953"];
1076 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 168954"];
1077 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 168955"];
1078 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 168956"];
1079 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 168957"];
1080 [label="param LanguageParser(Lexer lexer) 168958"];
1081 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 168959"];
1082 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 168960"];
1083 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 168961"];
1084 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 168962"];
1085 [label="param LanguageParser(this) 168963"];
1086 [label="() => new BlendedNode[32] 168964"];
1087 [label="2 168965"];
1088 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 168966"];
1089 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 168967"];
1090 [label="lexer 168968"];
1091 [label="lexerMode 168969"];
1092 [label="oldTree 168970"];
1093 [label="changes 168971"];
1094 [label="false 168972"];
1095 [label="true 168973"];
1096 [label="cancellationToken 168974"];
1097 [label="param LanguageParser(this) 168975"];
1098 [label="param SyntaxParser(Lexer lexer) 168976"];
1099 [label="param SyntaxParser(LexerMode mode) 168977"];
1100 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 168978"];
1101 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 168979"];
1102 [label="param SyntaxParser(bool allowModeReset) 168980"];
1103 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 168981"];
1104 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 168982"];
1105 [label="param SyntaxParser(this) 168983"];
1106 [label="lexer 168984"];
1107 [label="_isIncremental 168985"];
1108 [label="_allowModeReset 168986"];
1109 [label="_mode 168987"];
1110 [label="_currentToken 168988"];
1111 [label="_lexedTokens 168989"];
1112 [label="_prevTokenTrailingTrivia 168990"];
1113 [label="_firstToken 168991"];
1114 [label="_tokenOffset 168992"];
1115 [label="_tokenCount 168993"];
1116 [label="_resetCount 168994"];
1117 [label="_resetStart 168995"];
1118 [label="_blendedTokens 168996"];
1119 [label="this.lexer 168997"];
1120 [label="_mode 168998"];
1121 [label="_allowModeReset 168999"];
1122 [label="this.cancellationToken 169000"];
1123 [label="_currentNode = default(BlendedNode); 169001"];
1124 [label="_currentNode 169002"];
1125 [label="_isIncremental = oldTree != null; 169003"];
1126 [label="_isIncremental = oldTree != null; 169004"];
1127 [label="_isIncremental 169005"];
1128 [label="this.IsIncremental 169006"];
1129 [label="get\n            {\n                return _isIncremental;\n            } 169007"];
1130 [label="return _isIncremental; 169008"];
1131 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 169009"];
1132 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 169010"];
1133 [label="_firstBlender = default(Blender); 169011"];
1134 [label="_firstBlender 169012"];
1135 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 169013"];
1136 [label="_lexedTokens 169014"];
1137 [label="this.IsIncremental 169015"];
1138 [label="get\n            {\n                return _isIncremental;\n            } 169016"];
1139 [label="return _isIncremental; 169017"];
1140 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 169018"];
1141 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 169019"];
1142 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 169020"];
1143 [label="this.PreLex() 169021"];
1144 [label="param PreLex(this) 169022"];
1145 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 169023"];
1146 [label="this.lexer.TextWindow.Text 169024"];
1147 [label="=> _text 169025"];
1148 [label="_text 169026"];
1149 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 169027"];
1150 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 169028"];
1151 [label="_lexedTokens 169029"];
1152 [label="var lexer = this.lexer; 169030"];
1153 [label="var mode = _mode; 169031"];
1154 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 169032"];
1155 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 169033"];
1156 [label="var token = lexer.Lex(mode); 169034"];
1157 [label="lexer.Lex(mode) 169035"];
1158 [label="param Lex(LexerMode mode) 169036"];
1159 [label="param Lex(this) 169037"];
1160 [label="TokensLexed++; 169038"];
1161 [label="_mode 169039"];
1162 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 169040"];
1163 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 169041"];
1164 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 169042"];
1165 [label="param Start(this) 169043"];
1166 [label="TextWindow.Start() 169044"];
1167 [label="param Start(this) 169045"];
1168 [label="_lexemeStart 169046"];
1169 [label="TextWindow.Start(); 169047"];
1170 [label="_errors = null; 169048"];
1171 [label="_errors 169049"];
1172 [label="get\n            {\n                return _offset;\n            } 169050"];
1173 [label="return _offset; 169051"];
1174 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 169052"];
1175 [label="get\n            {\n                return _characterWindowCount;\n            } 169053"];
1176 [label="return _characterWindowCount; 169054"];
1177 [label="get\n            {\n                return _characterWindow;\n            } 169055"];
1178 [label="return _characterWindow; 169056"];
1179 [label="param AdvanceChar(int n) 169057"];
1180 [label="param AdvanceChar(this) 169058"];
1181 [label="_offset += n; 169059"];
1182 [label="_offset 169060"];
1183 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 169061"];
1184 [label="return _basis + _lexemeStart; 169062"];
1185 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 169063"];
1186 [label="param Reset(int position) 169064"];
1187 [label="param Reset(this) 169065"];
1188 [label="int relative = position - _basis; 169066"];
1189 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 169067"];
1190 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 169068"];
1191 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 169069"];
1192 [label="_offset 169070"];
1193 [label="this.LexSyntaxToken() 169071"];
1194 [label="param LexSyntaxToken(this) 169072"];
1195 [label="_leadingTriviaCache.Clear(); 169073"];
1196 [label="TextWindow.Position 169074"];
1197 [label="get\n            {\n                return _basis + _offset;\n            } 169075"];
1198 [label="return _basis + _offset; 169076"];
1199 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 169077"];
1200 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 169078"];
1201 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 169079"];
1202 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 169080"];
1203 [label="param LexSyntaxTrivia(bool afterFirstToken) 169081"];
1204 [label="param LexSyntaxTrivia(bool isTrailing) 169082"];
1205 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 169083"];
1206 [label="param LexSyntaxTrivia(this) 169084"];
1207 [label="bool onlyWhitespaceOnLine = !isTrailing; 169085"];
1208 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 169086"];
1209 [label="this.Start() 169087"];
1210 [label="param Start(this) 169088"];
1211 [label="TextWindow.Start() 169089"];
1212 [label="param Start(this) 169090"];
1213 [label="TextWindow.Start(); 169091"];
1214 [label="_errors = null; 169092"];
1215 [label="_errors 169093"];
1216 [label="this.Start(); 169094"];
1217 [label="TextWindow.PeekChar() 169095"];
1218 [label="param PeekChar(this) 169096"];
1219 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169097"];
1220 [label="MoreChars() 169098"];
1221 [label="param MoreChars(this) 169099"];
1222 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 169100"];
1223 [label="this.Position 169101"];
1224 [label="get\n            {\n                return _basis + _offset;\n            } 169102"];
1225 [label="return _basis + _offset; 169103"];
1226 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 169104"];
1227 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 169105"];
1228 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 169106"];
1229 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 169107"];
1230 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 169108"];
1231 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 169109"];
1232 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 169110"];
1233 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 169111"];
1234 [label="_characterWindowCount += amountToRead; 169112"];
1235 [label="_characterWindowCount 169113"];
1236 [label="return amountToRead > 0; 169114"];
1237 [label="return amountToRead > 0; 169115"];
1238 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169116"];
1239 [label="return _characterWindow[_offset]; 169117"];
1240 [label="char ch = TextWindow.PeekChar(); 169118"];
1241 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169119"];
1242 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169120"];
1243 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169121"];
1244 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 169122"];
1245 [label="return; 169123"];
1246 [label="var leading = _leadingTriviaCache; 169124"];
1247 [label="var tokenInfo = default(TokenInfo); 169125"];
1248 [label="this.Start() 169126"];
1249 [label="param Start(this) 169127"];
1250 [label="TextWindow.Start() 169128"];
1251 [label="param Start(this) 169129"];
1252 [label="TextWindow.Start(); 169130"];
1253 [label="_errors = null; 169131"];
1254 [label="_errors 169132"];
1255 [label="this.Start(); 169133"];
1256 [label="this.ScanSyntaxToken(ref tokenInfo); 169134"];
1257 [label="this.ScanSyntaxToken(ref tokenInfo); 169135"];
1258 [label="this.ScanSyntaxToken(ref tokenInfo); 169136"];
1259 [label="get\n            {\n                return _basis + _offset;\n            } 169137"];
1260 [label="return _basis + _offset; 169138"];
1261 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169139"];
1262 [label="return _characterWindow[_offset]; 169140"];
1263 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 169141"];
1264 [label="param ScanIdentifierOrKeyword(this) 169142"];
1265 [label="info.ContextualKind 169143"];
1266 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 169144"];
1267 [label="this.ScanIdentifier(ref info) 169145"];
1268 [label="param ScanIdentifier(ref TokenInfo info) 169146"];
1269 [label="param ScanIdentifier(this) 169147"];
1270 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 169148"];
1271 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 169149"];
1272 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 169150"];
1273 [label="param Intern(char[] array) 169151"];
1274 [label="param Intern(int start) 169152"];
1275 [label="param Intern(int length) 169153"];
1276 [label="param Intern(this) 169154"];
1277 [label="return _strings.Add(array, start, length); 169155"];
1278 [label="return _strings.Add(array, start, length); 169156"];
1279 [label="return _strings.Add(array, start, length); 169157"];
1280 [label="return _strings.Add(array, start, length); 169158"];
1281 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 169159"];
1282 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 169160"];
1283 [label="this.ModeIs(LexerMode.Directive) 169161"];
1284 [label="param ModeIs(LexerMode mode) 169162"];
1285 [label="param ModeIs(this) 169163"];
1286 [label="return ModeOf(_mode) == mode; 169164"];
1287 [label="ModeOf(_mode) 169165"];
1288 [label="param ModeOf(LexerMode mode) 169166"];
1289 [label="return mode & LexerMode.MaskLexMode; 169167"];
1290 [label="return ModeOf(_mode) == mode; 169168"];
1291 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 169169"];
1292 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 169170"];
1293 [label="param TryGetKeywordKind(string key) 169171"];
1294 [label="param TryGetKeywordKind(out SyntaxKind kind) 169172"];
1295 [label="param TryGetKeywordKind(this) 169173"];
1296 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 169174"];
1297 [label="new SyntaxKindEqualityComparer() 169175"];
1298 [label="param SyntaxKindEqualityComparer(this) 169176"];
1299 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 169177"];
1300 [label="kind = _keywordKindMap.GetOrMakeValue(key); 169178"];
1301 [label="kind = _keywordKindMap.GetOrMakeValue(key); 169179"];
1302 [label="kind = _keywordKindMap.GetOrMakeValue(key); 169180"];
1303 [label="param GetKeywordKind(string text) 169181"];
1304 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 169182"];
1305 [label="return SyntaxKind.SwitchKeyword; 169183"];
1306 [label="return kind != SyntaxKind.None; 169184"];
1307 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 169185"];
1308 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 169186"];
1309 [label="param IsContextualKeyword(SyntaxKind kind) 169187"];
1310 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 169188"];
1311 [label="return false; 169189"];
1312 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 169190"];
1313 [label="return true; 169191"];
1314 [label="this.ScanSyntaxToken(ref tokenInfo); 169192"];
1315 [label="var errors = this.GetErrors(GetFullWidth(leading)); 169193"];
1316 [label="GetFullWidth(leading) 169194"];
1317 [label="param GetFullWidth(SyntaxListBuilder builder) 169195"];
1318 [label="int width = 0; 169196"];
1319 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 169197"];
1320 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 169198"];
1321 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 169199"];
1322 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 169200"];
1323 [label="return width; 169201"];
1324 [label="var errors = this.GetErrors(GetFullWidth(leading)); 169202"];
1325 [label="this.GetErrors(GetFullWidth(leading)) 169203"];
1326 [label="param GetErrors(int leadingTriviaWidth) 169204"];
1327 [label="param GetErrors(this) 169205"];
1328 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 169206"];
1329 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 169207"];
1330 [label="return null; 169208"];
1331 [label="var errors = this.GetErrors(GetFullWidth(leading)); 169209"];
1332 [label="_trailingTriviaCache.Clear(); 169210"];
1333 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 169211"];
1334 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 169212"];
1335 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 169213"];
1336 [label="param LexSyntaxTrivia(bool afterFirstToken) 169214"];
1337 [label="param LexSyntaxTrivia(bool isTrailing) 169215"];
1338 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 169216"];
1339 [label="param LexSyntaxTrivia(this) 169217"];
1340 [label="bool onlyWhitespaceOnLine = !isTrailing; 169218"];
1341 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 169219"];
1342 [label="this.Start() 169220"];
1343 [label="param Start(this) 169221"];
1344 [label="TextWindow.Start() 169222"];
1345 [label="param Start(this) 169223"];
1346 [label="TextWindow.Start(); 169224"];
1347 [label="_errors = null; 169225"];
1348 [label="_errors 169226"];
1349 [label="this.Start(); 169227"];
1350 [label="TextWindow.PeekChar() 169228"];
1351 [label="param PeekChar(this) 169229"];
1352 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169230"];
1353 [label="char ch = TextWindow.PeekChar(); 169231"];
1354 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169232"];
1355 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169233"];
1356 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 169234"];
1357 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 169235"];
1358 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169236"];
1359 [label="param AdvanceChar(this) 169237"];
1360 [label="_offset 169238"];
1361 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169239"];
1362 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 169240"];
1363 [label="return _offset - _lexemeStart; 169241"];
1364 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 169242"];
1365 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 169243"];
1366 [label="param AddTrivia(CSharpSyntaxNode trivia) 169244"];
1367 [label="param AddTrivia(ref SyntaxListBuilder list) 169245"];
1368 [label="param AddTrivia(this) 169246"];
1369 [label="this.HasErrors 169247"];
1370 [label="get { return _errors != null; } 169248"];
1371 [label="return _errors != null; 169249"];
1372 [label="return _errors != null; 169250"];
1373 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 169251"];
1374 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 169252"];
1375 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 169253"];
1376 [label="list.Add(trivia); 169254"];
1377 [label="list.Add(trivia); 169255"];
1378 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 169256"];
1379 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 169257"];
1380 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 169258"];
1381 [label="return; 169259"];
1382 [label="var trailing = _trailingTriviaCache; 169260"];
1383 [label="return Create(ref tokenInfo, leading, trailing, errors); 169261"];
1384 [label="return Create(ref tokenInfo, leading, trailing, errors); 169262"];
1385 [label="return Create(ref tokenInfo, leading, trailing, errors); 169263"];
1386 [label="return Create(ref tokenInfo, leading, trailing, errors); 169264"];
1387 [label="Create(ref tokenInfo, leading, trailing, errors) 169265"];
1388 [label="param Create(ref TokenInfo info) 169266"];
1389 [label="param Create(SyntaxListBuilder leading) 169267"];
1390 [label="param Create(SyntaxListBuilder trailing) 169268"];
1391 [label="param Create(SyntaxDiagnosticInfo[] errors) 169269"];
1392 [label="param Create(this) 169270"];
1393 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 169271"];
1394 [label="var leadingNode = leading?.ToListNode(); 169272"];
1395 [label="var trailingNode = trailing?.ToListNode(); 169273"];
1396 [label="SyntaxToken token; 169274"];
1397 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 169275"];
1398 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 169276"];
1399 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 169277"];
1400 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 169278"];
1401 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 169279"];
1402 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 169280"];
1403 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 169281"];
1404 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 169282"];
1405 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 169283"];
1406 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 169284"];
1407 [label="param Token(GreenNode leading) 169285"];
1408 [label="param Token(SyntaxKind kind) 169286"];
1409 [label="param Token(GreenNode trailing) 169287"];
1410 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 169288"];
1411 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 169289"];
1412 [label="1 169290"];
1413 [label="(int)LastTokenWithWellKnownText + 1 169291"];
1414 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169292"];
1415 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169293"];
1416 [label="1 169294"];
1417 [label="(int)LastTokenWithWellKnownText + 1 169295"];
1418 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169296"];
1419 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169297"];
1420 [label="1 169298"];
1421 [label="(int)LastTokenWithWellKnownText + 1 169299"];
1422 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169300"];
1423 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169301"];
1424 [label="1 169302"];
1425 [label="(int)LastTokenWithWellKnownText + 1 169303"];
1426 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169304"];
1427 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 169305"];
1428 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 169306"];
1429 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 169307"];
1430 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 169308"];
1431 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 169309"];
1432 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 169310"];
1433 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 169311"];
1434 [label="new SyntaxToken(kind) 169312"];
1435 [label="param SyntaxToken(SyntaxKind kind) 169313"];
1436 [label="param SyntaxToken(this) 169314"];
1437 [label="kind 169315"];
1438 [label="param SyntaxToken(this) 169316"];
1439 [label="param CSharpSyntaxNode(SyntaxKind kind) 169317"];
1440 [label="param CSharpSyntaxNode(this) 169318"];
1441 [label="kind 169319"];
1442 [label="param CSharpSyntaxNode(this) 169320"];
1443 [label="param CSharpSyntaxNode(this) 169321"];
1444 [label="GreenStats.NoteGreen(this); 169322"];
1445 [label="GreenStats.NoteGreen(this); 169323"];
1446 [label="this.Text 169324"];
1447 [label="get { return SyntaxFacts.GetText(this.Kind); } 169325"];
1448 [label="this.Kind 169326"];
1449 [label="get { return (SyntaxKind)this.RawKind; } 169327"];
1450 [label="return (SyntaxKind)this.RawKind; 169328"];
1451 [label="return SyntaxFacts.GetText(this.Kind); 169329"];
1452 [label="SyntaxFacts.GetText(this.Kind) 169330"];
1453 [label="param GetText(SyntaxKind kind) 169331"];
1454 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169332"];
1455 [label="return '~'; 169333"];
1456 [label="FullWidth = this.Text.Length; 169334"];
1457 [label="FullWidth 169335"];
1458 [label="this.flags |= NodeFlags.IsNotMissing; 169336"];
1459 [label="this.flags 169337"];
1460 [label="s_tokensWithNoTrivia[(int)kind].Value 169338"];
1461 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 169339"];
1462 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 169340"];
1463 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 169341"];
1464 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 169342"];
1465 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 169343"];
1466 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 169344"];
1467 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169345"];
1468 [label="param SyntaxTokenWithTrivia(GreenNode leading) 169346"];
1469 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 169347"];
1470 [label="param SyntaxTokenWithTrivia(this) 169348"];
1471 [label="kind 169349"];
1472 [label="param SyntaxTokenWithTrivia(this) 169350"];
1473 [label="param SyntaxToken(SyntaxKind kind) 169351"];
1474 [label="param SyntaxToken(this) 169352"];
1475 [label="kind 169353"];
1476 [label="param SyntaxToken(this) 169354"];
1477 [label="param CSharpSyntaxNode(SyntaxKind kind) 169355"];
1478 [label="param CSharpSyntaxNode(this) 169356"];
1479 [label="kind 169357"];
1480 [label="param CSharpSyntaxNode(this) 169358"];
1481 [label="param CSharpSyntaxNode(this) 169359"];
1482 [label="GreenStats.NoteGreen(this); 169360"];
1483 [label="GreenStats.NoteGreen(this); 169361"];
1484 [label="this.Text 169362"];
1485 [label="get { return SyntaxFacts.GetText(this.Kind); } 169363"];
1486 [label="this.Kind 169364"];
1487 [label="get { return (SyntaxKind)this.RawKind; } 169365"];
1488 [label="return (SyntaxKind)this.RawKind; 169366"];
1489 [label="return SyntaxFacts.GetText(this.Kind); 169367"];
1490 [label="SyntaxFacts.GetText(this.Kind) 169368"];
1491 [label="param GetText(SyntaxKind kind) 169369"];
1492 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169370"];
1493 [label="return '~'; 169371"];
1494 [label="FullWidth = this.Text.Length; 169372"];
1495 [label="FullWidth 169373"];
1496 [label="this.flags |= NodeFlags.IsNotMissing; 169374"];
1497 [label="this.flags 169375"];
1498 [label="LeadingField 169376"];
1499 [label="TrailingField 169377"];
1500 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169378"];
1501 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169379"];
1502 [label="this.AdjustFlagsAndWidth(leading); 169380"];
1503 [label="this.AdjustFlagsAndWidth(leading); 169381"];
1504 [label="this.LeadingField 169382"];
1505 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169383"];
1506 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169384"];
1507 [label="this.AdjustFlagsAndWidth(trailing); 169385"];
1508 [label="this.AdjustFlagsAndWidth(trailing); 169386"];
1509 [label="this.TrailingField 169387"];
1510 [label="s_tokensWithElasticTrivia[(int)kind].Value 169388"];
1511 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 169389"];
1512 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 169390"];
1513 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 169391"];
1514 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 169392"];
1515 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 169393"];
1516 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169394"];
1517 [label="param SyntaxTokenWithTrivia(GreenNode leading) 169395"];
1518 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 169396"];
1519 [label="param SyntaxTokenWithTrivia(this) 169397"];
1520 [label="kind 169398"];
1521 [label="param SyntaxTokenWithTrivia(this) 169399"];
1522 [label="param SyntaxToken(SyntaxKind kind) 169400"];
1523 [label="param SyntaxToken(this) 169401"];
1524 [label="kind 169402"];
1525 [label="param SyntaxToken(this) 169403"];
1526 [label="param CSharpSyntaxNode(SyntaxKind kind) 169404"];
1527 [label="param CSharpSyntaxNode(this) 169405"];
1528 [label="kind 169406"];
1529 [label="param CSharpSyntaxNode(this) 169407"];
1530 [label="param CSharpSyntaxNode(this) 169408"];
1531 [label="GreenStats.NoteGreen(this); 169409"];
1532 [label="GreenStats.NoteGreen(this); 169410"];
1533 [label="this.Text 169411"];
1534 [label="get { return SyntaxFacts.GetText(this.Kind); } 169412"];
1535 [label="this.Kind 169413"];
1536 [label="get { return (SyntaxKind)this.RawKind; } 169414"];
1537 [label="return (SyntaxKind)this.RawKind; 169415"];
1538 [label="return SyntaxFacts.GetText(this.Kind); 169416"];
1539 [label="SyntaxFacts.GetText(this.Kind) 169417"];
1540 [label="param GetText(SyntaxKind kind) 169418"];
1541 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169419"];
1542 [label="return '~'; 169420"];
1543 [label="FullWidth = this.Text.Length; 169421"];
1544 [label="FullWidth 169422"];
1545 [label="this.flags |= NodeFlags.IsNotMissing; 169423"];
1546 [label="this.flags 169424"];
1547 [label="LeadingField 169425"];
1548 [label="TrailingField 169426"];
1549 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169427"];
1550 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169428"];
1551 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169429"];
1552 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169430"];
1553 [label="this.AdjustFlagsAndWidth(trailing); 169431"];
1554 [label="this.AdjustFlagsAndWidth(trailing); 169432"];
1555 [label="this.TrailingField 169433"];
1556 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 169434"];
1557 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 169435"];
1558 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 169436"];
1559 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 169437"];
1560 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 169438"];
1561 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 169439"];
1562 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169440"];
1563 [label="param SyntaxTokenWithTrivia(GreenNode leading) 169441"];
1564 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 169442"];
1565 [label="param SyntaxTokenWithTrivia(this) 169443"];
1566 [label="kind 169444"];
1567 [label="param SyntaxTokenWithTrivia(this) 169445"];
1568 [label="param SyntaxToken(SyntaxKind kind) 169446"];
1569 [label="param SyntaxToken(this) 169447"];
1570 [label="kind 169448"];
1571 [label="param SyntaxToken(this) 169449"];
1572 [label="param CSharpSyntaxNode(SyntaxKind kind) 169450"];
1573 [label="param CSharpSyntaxNode(this) 169451"];
1574 [label="kind 169452"];
1575 [label="param CSharpSyntaxNode(this) 169453"];
1576 [label="param CSharpSyntaxNode(this) 169454"];
1577 [label="GreenStats.NoteGreen(this); 169455"];
1578 [label="GreenStats.NoteGreen(this); 169456"];
1579 [label="this.Text 169457"];
1580 [label="get { return SyntaxFacts.GetText(this.Kind); } 169458"];
1581 [label="this.Kind 169459"];
1582 [label="get { return (SyntaxKind)this.RawKind; } 169460"];
1583 [label="return (SyntaxKind)this.RawKind; 169461"];
1584 [label="return SyntaxFacts.GetText(this.Kind); 169462"];
1585 [label="SyntaxFacts.GetText(this.Kind) 169463"];
1586 [label="param GetText(SyntaxKind kind) 169464"];
1587 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169465"];
1588 [label="return '~'; 169466"];
1589 [label="FullWidth = this.Text.Length; 169467"];
1590 [label="FullWidth 169468"];
1591 [label="this.flags |= NodeFlags.IsNotMissing; 169469"];
1592 [label="this.flags 169470"];
1593 [label="LeadingField 169471"];
1594 [label="TrailingField 169472"];
1595 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169473"];
1596 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 169474"];
1597 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169475"];
1598 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 169476"];
1599 [label="this.AdjustFlagsAndWidth(trailing); 169477"];
1600 [label="this.AdjustFlagsAndWidth(trailing); 169478"];
1601 [label="this.TrailingField 169479"];
1602 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 169480"];
1603 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 169481"];
1604 [label="param SyntaxToken(SyntaxKind kind) 169482"];
1605 [label="kind 169483"];
1606 [label="param CSharpSyntaxNode(SyntaxKind kind) 169484"];
1607 [label="kind 169485"];
1608 [label="param CSharpSyntaxNode(this) 169486"];
1609 [label="GreenStats.NoteGreen(this); 169487"];
1610 [label="return (SyntaxKind)this.RawKind; 169488"];
1611 [label="return SyntaxFacts.GetText(this.Kind); 169489"];
1612 [label="param GetText(SyntaxKind kind) 169490"];
1613 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169491"];
1614 [label="return '!'; 169492"];
1615 [label="FullWidth = this.Text.Length; 169493"];
1616 [label="FullWidth 169494"];
1617 [label="this.flags |= NodeFlags.IsNotMissing; 169495"];
1618 [label="this.flags 169496"];
1619 [label="s_tokensWithNoTrivia[(int)kind].Value 169497"];
1620 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 169498"];
1621 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169499"];
1622 [label="kind 169500"];
1623 [label="param SyntaxToken(SyntaxKind kind) 169501"];
1624 [label="kind 169502"];
1625 [label="param CSharpSyntaxNode(SyntaxKind kind) 169503"];
1626 [label="kind 169504"];
1627 [label="param CSharpSyntaxNode(this) 169505"];
1628 [label="GreenStats.NoteGreen(this); 169506"];
1629 [label="return (SyntaxKind)this.RawKind; 169507"];
1630 [label="return SyntaxFacts.GetText(this.Kind); 169508"];
1631 [label="param GetText(SyntaxKind kind) 169509"];
1632 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169510"];
1633 [label="return '!'; 169511"];
1634 [label="FullWidth = this.Text.Length; 169512"];
1635 [label="FullWidth 169513"];
1636 [label="this.flags |= NodeFlags.IsNotMissing; 169514"];
1637 [label="this.flags 169515"];
1638 [label="this.AdjustFlagsAndWidth(leading); 169516"];
1639 [label="s_tokensWithElasticTrivia[(int)kind].Value 169517"];
1640 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 169518"];
1641 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169519"];
1642 [label="kind 169520"];
1643 [label="param SyntaxToken(SyntaxKind kind) 169521"];
1644 [label="kind 169522"];
1645 [label="param CSharpSyntaxNode(SyntaxKind kind) 169523"];
1646 [label="kind 169524"];
1647 [label="param CSharpSyntaxNode(this) 169525"];
1648 [label="GreenStats.NoteGreen(this); 169526"];
1649 [label="return (SyntaxKind)this.RawKind; 169527"];
1650 [label="return SyntaxFacts.GetText(this.Kind); 169528"];
1651 [label="param GetText(SyntaxKind kind) 169529"];
1652 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169530"];
1653 [label="return '!'; 169531"];
1654 [label="FullWidth = this.Text.Length; 169532"];
1655 [label="FullWidth 169533"];
1656 [label="this.flags |= NodeFlags.IsNotMissing; 169534"];
1657 [label="this.flags 169535"];
1658 [label="this.AdjustFlagsAndWidth(trailing); 169536"];
1659 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 169537"];
1660 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 169538"];
1661 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 169539"];
1662 [label="kind 169540"];
1663 [label="param SyntaxToken(SyntaxKind kind) 169541"];
1664 [label="kind 169542"];
1665 [label="param CSharpSyntaxNode(SyntaxKind kind) 169543"];
1666 [label="kind 169544"];
1667 [label="param CSharpSyntaxNode(this) 169545"];
1668 [label="GreenStats.NoteGreen(this); 169546"];
1669 [label="return (SyntaxKind)this.RawKind; 169547"];
1670 [label="return SyntaxFacts.GetText(this.Kind); 169548"];
1671 [label="param GetText(SyntaxKind kind) 169549"];
1672 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 169550"];
1673 [label="return '!'; 169551"];
1674 [label="FullWidth = this.Text.Length; 169552"];
1675 [label="FullWidth 169553"];
1676 [label="this.flags |= NodeFlags.IsNotMissing; 169554"];
1677 [label="this.flags 169555"];
1678 [label="this.AdjustFlagsAndWidth(trailing); 169556"];
1679 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 169557"];
1680 [label="return '$'; 169558"];
1681 [label="FullWidth = this.Text.Length; 169559"];
1682 [label="FullWidth 169560"];
1683 [label="return '$'; 169561"];
1684 [label="FullWidth = this.Text.Length; 169562"];
1685 [label="FullWidth 169563"];
1686 [label="this.AdjustFlagsAndWidth(leading); 169564"];
1687 [label="return '$'; 169565"];
1688 [label="FullWidth = this.Text.Length; 169566"];
1689 [label="FullWidth 169567"];
1690 [label="this.AdjustFlagsAndWidth(trailing); 169568"];
1691 [label="return '$'; 169569"];
1692 [label="FullWidth = this.Text.Length; 169570"];
1693 [label="FullWidth 169571"];
1694 [label="this.AdjustFlagsAndWidth(trailing); 169572"];
1695 [label="return '%'; 169573"];
1696 [label="FullWidth = this.Text.Length; 169574"];
1697 [label="FullWidth 169575"];
1698 [label="return '%'; 169576"];
1699 [label="FullWidth = this.Text.Length; 169577"];
1700 [label="FullWidth 169578"];
1701 [label="this.AdjustFlagsAndWidth(leading); 169579"];
1702 [label="return '%'; 169580"];
1703 [label="FullWidth = this.Text.Length; 169581"];
1704 [label="FullWidth 169582"];
1705 [label="this.AdjustFlagsAndWidth(trailing); 169583"];
1706 [label="return '%'; 169584"];
1707 [label="FullWidth = this.Text.Length; 169585"];
1708 [label="FullWidth 169586"];
1709 [label="this.AdjustFlagsAndWidth(trailing); 169587"];
1710 [label="return '^'; 169588"];
1711 [label="FullWidth = this.Text.Length; 169589"];
1712 [label="FullWidth 169590"];
1713 [label="return '^'; 169591"];
1714 [label="FullWidth = this.Text.Length; 169592"];
1715 [label="FullWidth 169593"];
1716 [label="this.AdjustFlagsAndWidth(leading); 169594"];
1717 [label="return '^'; 169595"];
1718 [label="FullWidth = this.Text.Length; 169596"];
1719 [label="FullWidth 169597"];
1720 [label="this.AdjustFlagsAndWidth(trailing); 169598"];
1721 [label="return '^'; 169599"];
1722 [label="FullWidth = this.Text.Length; 169600"];
1723 [label="FullWidth 169601"];
1724 [label="this.AdjustFlagsAndWidth(trailing); 169602"];
1725 [label="return '&'; 169603"];
1726 [label="FullWidth = this.Text.Length; 169604"];
1727 [label="FullWidth 169605"];
1728 [label="return '&'; 169606"];
1729 [label="FullWidth = this.Text.Length; 169607"];
1730 [label="FullWidth 169608"];
1731 [label="this.AdjustFlagsAndWidth(leading); 169609"];
1732 [label="return '&'; 169610"];
1733 [label="FullWidth = this.Text.Length; 169611"];
1734 [label="FullWidth 169612"];
1735 [label="this.AdjustFlagsAndWidth(trailing); 169613"];
1736 [label="return '&'; 169614"];
1737 [label="FullWidth = this.Text.Length; 169615"];
1738 [label="FullWidth 169616"];
1739 [label="this.AdjustFlagsAndWidth(trailing); 169617"];
1740 [label="return '*'; 169618"];
1741 [label="FullWidth = this.Text.Length; 169619"];
1742 [label="FullWidth 169620"];
1743 [label="return '*'; 169621"];
1744 [label="FullWidth = this.Text.Length; 169622"];
1745 [label="FullWidth 169623"];
1746 [label="this.AdjustFlagsAndWidth(leading); 169624"];
1747 [label="return '*'; 169625"];
1748 [label="FullWidth = this.Text.Length; 169626"];
1749 [label="FullWidth 169627"];
1750 [label="this.AdjustFlagsAndWidth(trailing); 169628"];
1751 [label="return '*'; 169629"];
1752 [label="FullWidth = this.Text.Length; 169630"];
1753 [label="FullWidth 169631"];
1754 [label="this.AdjustFlagsAndWidth(trailing); 169632"];
1755 [label="return '('; 169633"];
1756 [label="FullWidth = this.Text.Length; 169634"];
1757 [label="FullWidth 169635"];
1758 [label="return '('; 169636"];
1759 [label="FullWidth = this.Text.Length; 169637"];
1760 [label="FullWidth 169638"];
1761 [label="this.AdjustFlagsAndWidth(leading); 169639"];
1762 [label="return '('; 169640"];
1763 [label="FullWidth = this.Text.Length; 169641"];
1764 [label="FullWidth 169642"];
1765 [label="this.AdjustFlagsAndWidth(trailing); 169643"];
1766 [label="return '('; 169644"];
1767 [label="FullWidth = this.Text.Length; 169645"];
1768 [label="FullWidth 169646"];
1769 [label="this.AdjustFlagsAndWidth(trailing); 169647"];
1770 [label="return ')'; 169648"];
1771 [label="FullWidth = this.Text.Length; 169649"];
1772 [label="FullWidth 169650"];
1773 [label="return ')'; 169651"];
1774 [label="FullWidth = this.Text.Length; 169652"];
1775 [label="FullWidth 169653"];
1776 [label="this.AdjustFlagsAndWidth(leading); 169654"];
1777 [label="return ')'; 169655"];
1778 [label="FullWidth = this.Text.Length; 169656"];
1779 [label="FullWidth 169657"];
1780 [label="this.AdjustFlagsAndWidth(trailing); 169658"];
1781 [label="return ')'; 169659"];
1782 [label="FullWidth = this.Text.Length; 169660"];
1783 [label="FullWidth 169661"];
1784 [label="this.AdjustFlagsAndWidth(trailing); 169662"];
1785 [label="return '-'; 169663"];
1786 [label="FullWidth = this.Text.Length; 169664"];
1787 [label="FullWidth 169665"];
1788 [label="return '-'; 169666"];
1789 [label="FullWidth = this.Text.Length; 169667"];
1790 [label="FullWidth 169668"];
1791 [label="this.AdjustFlagsAndWidth(leading); 169669"];
1792 [label="return '-'; 169670"];
1793 [label="FullWidth = this.Text.Length; 169671"];
1794 [label="FullWidth 169672"];
1795 [label="this.AdjustFlagsAndWidth(trailing); 169673"];
1796 [label="return '-'; 169674"];
1797 [label="FullWidth = this.Text.Length; 169675"];
1798 [label="FullWidth 169676"];
1799 [label="this.AdjustFlagsAndWidth(trailing); 169677"];
1800 [label="return '+'; 169678"];
1801 [label="FullWidth = this.Text.Length; 169679"];
1802 [label="FullWidth 169680"];
1803 [label="return '+'; 169681"];
1804 [label="FullWidth = this.Text.Length; 169682"];
1805 [label="FullWidth 169683"];
1806 [label="this.AdjustFlagsAndWidth(leading); 169684"];
1807 [label="return '+'; 169685"];
1808 [label="FullWidth = this.Text.Length; 169686"];
1809 [label="FullWidth 169687"];
1810 [label="this.AdjustFlagsAndWidth(trailing); 169688"];
1811 [label="return '+'; 169689"];
1812 [label="FullWidth = this.Text.Length; 169690"];
1813 [label="FullWidth 169691"];
1814 [label="this.AdjustFlagsAndWidth(trailing); 169692"];
1815 [label="return '='; 169693"];
1816 [label="FullWidth = this.Text.Length; 169694"];
1817 [label="FullWidth 169695"];
1818 [label="return '='; 169696"];
1819 [label="FullWidth = this.Text.Length; 169697"];
1820 [label="FullWidth 169698"];
1821 [label="this.AdjustFlagsAndWidth(leading); 169699"];
1822 [label="return '='; 169700"];
1823 [label="FullWidth = this.Text.Length; 169701"];
1824 [label="FullWidth 169702"];
1825 [label="this.AdjustFlagsAndWidth(trailing); 169703"];
1826 [label="return '='; 169704"];
1827 [label="FullWidth = this.Text.Length; 169705"];
1828 [label="FullWidth 169706"];
1829 [label="this.AdjustFlagsAndWidth(trailing); 169707"];
1830 [label="return '{'; 169708"];
1831 [label="FullWidth = this.Text.Length; 169709"];
1832 [label="FullWidth 169710"];
1833 [label="return '{'; 169711"];
1834 [label="FullWidth = this.Text.Length; 169712"];
1835 [label="FullWidth 169713"];
1836 [label="this.AdjustFlagsAndWidth(leading); 169714"];
1837 [label="return '{'; 169715"];
1838 [label="FullWidth = this.Text.Length; 169716"];
1839 [label="FullWidth 169717"];
1840 [label="this.AdjustFlagsAndWidth(trailing); 169718"];
1841 [label="return '{'; 169719"];
1842 [label="FullWidth = this.Text.Length; 169720"];
1843 [label="FullWidth 169721"];
1844 [label="this.AdjustFlagsAndWidth(trailing); 169722"];
1845 [label="return '}'; 169723"];
1846 [label="FullWidth = this.Text.Length; 169724"];
1847 [label="FullWidth 169725"];
1848 [label="return '}'; 169726"];
1849 [label="FullWidth = this.Text.Length; 169727"];
1850 [label="FullWidth 169728"];
1851 [label="this.AdjustFlagsAndWidth(leading); 169729"];
1852 [label="return '}'; 169730"];
1853 [label="FullWidth = this.Text.Length; 169731"];
1854 [label="FullWidth 169732"];
1855 [label="this.AdjustFlagsAndWidth(trailing); 169733"];
1856 [label="return '}'; 169734"];
1857 [label="FullWidth = this.Text.Length; 169735"];
1858 [label="FullWidth 169736"];
1859 [label="this.AdjustFlagsAndWidth(trailing); 169737"];
1860 [label="return '['; 169738"];
1861 [label="FullWidth = this.Text.Length; 169739"];
1862 [label="FullWidth 169740"];
1863 [label="return '['; 169741"];
1864 [label="FullWidth = this.Text.Length; 169742"];
1865 [label="FullWidth 169743"];
1866 [label="this.AdjustFlagsAndWidth(leading); 169744"];
1867 [label="return '['; 169745"];
1868 [label="FullWidth = this.Text.Length; 169746"];
1869 [label="FullWidth 169747"];
1870 [label="this.AdjustFlagsAndWidth(trailing); 169748"];
1871 [label="return '['; 169749"];
1872 [label="FullWidth = this.Text.Length; 169750"];
1873 [label="FullWidth 169751"];
1874 [label="this.AdjustFlagsAndWidth(trailing); 169752"];
1875 [label="return ']'; 169753"];
1876 [label="FullWidth = this.Text.Length; 169754"];
1877 [label="FullWidth 169755"];
1878 [label="return ']'; 169756"];
1879 [label="FullWidth = this.Text.Length; 169757"];
1880 [label="FullWidth 169758"];
1881 [label="this.AdjustFlagsAndWidth(leading); 169759"];
1882 [label="return ']'; 169760"];
1883 [label="FullWidth = this.Text.Length; 169761"];
1884 [label="FullWidth 169762"];
1885 [label="this.AdjustFlagsAndWidth(trailing); 169763"];
1886 [label="return ']'; 169764"];
1887 [label="FullWidth = this.Text.Length; 169765"];
1888 [label="FullWidth 169766"];
1889 [label="this.AdjustFlagsAndWidth(trailing); 169767"];
1890 [label="return '|'; 169768"];
1891 [label="FullWidth = this.Text.Length; 169769"];
1892 [label="FullWidth 169770"];
1893 [label="return '|'; 169771"];
1894 [label="FullWidth = this.Text.Length; 169772"];
1895 [label="FullWidth 169773"];
1896 [label="this.AdjustFlagsAndWidth(leading); 169774"];
1897 [label="return '|'; 169775"];
1898 [label="FullWidth = this.Text.Length; 169776"];
1899 [label="FullWidth 169777"];
1900 [label="this.AdjustFlagsAndWidth(trailing); 169778"];
1901 [label="return '|'; 169779"];
1902 [label="FullWidth = this.Text.Length; 169780"];
1903 [label="FullWidth 169781"];
1904 [label="this.AdjustFlagsAndWidth(trailing); 169782"];
1905 [label="return '\\\\'; 169783"];
1906 [label="FullWidth = this.Text.Length; 169784"];
1907 [label="FullWidth 169785"];
1908 [label="return '\\\\'; 169786"];
1909 [label="FullWidth = this.Text.Length; 169787"];
1910 [label="FullWidth 169788"];
1911 [label="this.AdjustFlagsAndWidth(leading); 169789"];
1912 [label="return '\\\\'; 169790"];
1913 [label="FullWidth = this.Text.Length; 169791"];
1914 [label="FullWidth 169792"];
1915 [label="this.AdjustFlagsAndWidth(trailing); 169793"];
1916 [label="return '\\\\'; 169794"];
1917 [label="FullWidth = this.Text.Length; 169795"];
1918 [label="FullWidth 169796"];
1919 [label="this.AdjustFlagsAndWidth(trailing); 169797"];
1920 [label="return ':'; 169798"];
1921 [label="FullWidth = this.Text.Length; 169799"];
1922 [label="FullWidth 169800"];
1923 [label="return ':'; 169801"];
1924 [label="FullWidth = this.Text.Length; 169802"];
1925 [label="FullWidth 169803"];
1926 [label="this.AdjustFlagsAndWidth(leading); 169804"];
1927 [label="return ':'; 169805"];
1928 [label="FullWidth = this.Text.Length; 169806"];
1929 [label="FullWidth 169807"];
1930 [label="this.AdjustFlagsAndWidth(trailing); 169808"];
1931 [label="return ':'; 169809"];
1932 [label="FullWidth = this.Text.Length; 169810"];
1933 [label="FullWidth 169811"];
1934 [label="this.AdjustFlagsAndWidth(trailing); 169812"];
1935 [label="return ';'; 169813"];
1936 [label="FullWidth = this.Text.Length; 169814"];
1937 [label="FullWidth 169815"];
1938 [label="return ';'; 169816"];
1939 [label="FullWidth = this.Text.Length; 169817"];
1940 [label="FullWidth 169818"];
1941 [label="this.AdjustFlagsAndWidth(leading); 169819"];
1942 [label="return ';'; 169820"];
1943 [label="FullWidth = this.Text.Length; 169821"];
1944 [label="FullWidth 169822"];
1945 [label="this.AdjustFlagsAndWidth(trailing); 169823"];
1946 [label="return ';'; 169824"];
1947 [label="FullWidth = this.Text.Length; 169825"];
1948 [label="FullWidth 169826"];
1949 [label="this.AdjustFlagsAndWidth(trailing); 169827"];
1950 [label="return '\\''; 169828"];
1951 [label="FullWidth = this.Text.Length; 169829"];
1952 [label="FullWidth 169830"];
1953 [label="return '\\''; 169831"];
1954 [label="FullWidth = this.Text.Length; 169832"];
1955 [label="FullWidth 169833"];
1956 [label="this.AdjustFlagsAndWidth(leading); 169834"];
1957 [label="return '\\''; 169835"];
1958 [label="FullWidth = this.Text.Length; 169836"];
1959 [label="FullWidth 169837"];
1960 [label="this.AdjustFlagsAndWidth(trailing); 169838"];
1961 [label="return '\\''; 169839"];
1962 [label="FullWidth = this.Text.Length; 169840"];
1963 [label="FullWidth 169841"];
1964 [label="this.AdjustFlagsAndWidth(trailing); 169842"];
1965 [label="return '''; 169843"];
1966 [label="FullWidth = this.Text.Length; 169844"];
1967 [label="FullWidth 169845"];
1968 [label="return '''; 169846"];
1969 [label="FullWidth = this.Text.Length; 169847"];
1970 [label="FullWidth 169848"];
1971 [label="this.AdjustFlagsAndWidth(leading); 169849"];
1972 [label="return '''; 169850"];
1973 [label="FullWidth = this.Text.Length; 169851"];
1974 [label="FullWidth 169852"];
1975 [label="this.AdjustFlagsAndWidth(trailing); 169853"];
1976 [label="return '''; 169854"];
1977 [label="FullWidth = this.Text.Length; 169855"];
1978 [label="FullWidth 169856"];
1979 [label="this.AdjustFlagsAndWidth(trailing); 169857"];
1980 [label="return '<'; 169858"];
1981 [label="FullWidth = this.Text.Length; 169859"];
1982 [label="FullWidth 169860"];
1983 [label="return '<'; 169861"];
1984 [label="FullWidth = this.Text.Length; 169862"];
1985 [label="FullWidth 169863"];
1986 [label="this.AdjustFlagsAndWidth(leading); 169864"];
1987 [label="return '<'; 169865"];
1988 [label="FullWidth = this.Text.Length; 169866"];
1989 [label="FullWidth 169867"];
1990 [label="this.AdjustFlagsAndWidth(trailing); 169868"];
1991 [label="return '<'; 169869"];
1992 [label="FullWidth = this.Text.Length; 169870"];
1993 [label="FullWidth 169871"];
1994 [label="this.AdjustFlagsAndWidth(trailing); 169872"];
1995 [label="return ','; 169873"];
1996 [label="FullWidth = this.Text.Length; 169874"];
1997 [label="FullWidth 169875"];
1998 [label="return ','; 169876"];
1999 [label="FullWidth = this.Text.Length; 169877"];
2000 [label="FullWidth 169878"];
2001 [label="this.AdjustFlagsAndWidth(leading); 169879"];
2002 [label="return ','; 169880"];
2003 [label="FullWidth = this.Text.Length; 169881"];
2004 [label="FullWidth 169882"];
2005 [label="this.AdjustFlagsAndWidth(trailing); 169883"];
2006 [label="return ','; 169884"];
2007 [label="FullWidth = this.Text.Length; 169885"];
2008 [label="FullWidth 169886"];
2009 [label="this.AdjustFlagsAndWidth(trailing); 169887"];
2010 [label="return '>'; 169888"];
2011 [label="FullWidth = this.Text.Length; 169889"];
2012 [label="FullWidth 169890"];
2013 [label="return '>'; 169891"];
2014 [label="FullWidth = this.Text.Length; 169892"];
2015 [label="FullWidth 169893"];
2016 [label="this.AdjustFlagsAndWidth(leading); 169894"];
2017 [label="return '>'; 169895"];
2018 [label="FullWidth = this.Text.Length; 169896"];
2019 [label="FullWidth 169897"];
2020 [label="this.AdjustFlagsAndWidth(trailing); 169898"];
2021 [label="return '>'; 169899"];
2022 [label="FullWidth = this.Text.Length; 169900"];
2023 [label="FullWidth 169901"];
2024 [label="this.AdjustFlagsAndWidth(trailing); 169902"];
2025 [label="return '.'; 169903"];
2026 [label="FullWidth = this.Text.Length; 169904"];
2027 [label="FullWidth 169905"];
2028 [label="return '.'; 169906"];
2029 [label="FullWidth = this.Text.Length; 169907"];
2030 [label="FullWidth 169908"];
2031 [label="this.AdjustFlagsAndWidth(leading); 169909"];
2032 [label="return '.'; 169910"];
2033 [label="FullWidth = this.Text.Length; 169911"];
2034 [label="FullWidth 169912"];
2035 [label="this.AdjustFlagsAndWidth(trailing); 169913"];
2036 [label="return '.'; 169914"];
2037 [label="FullWidth = this.Text.Length; 169915"];
2038 [label="FullWidth 169916"];
2039 [label="this.AdjustFlagsAndWidth(trailing); 169917"];
2040 [label="return '?'; 169918"];
2041 [label="FullWidth = this.Text.Length; 169919"];
2042 [label="FullWidth 169920"];
2043 [label="return '?'; 169921"];
2044 [label="FullWidth = this.Text.Length; 169922"];
2045 [label="FullWidth 169923"];
2046 [label="this.AdjustFlagsAndWidth(leading); 169924"];
2047 [label="return '?'; 169925"];
2048 [label="FullWidth = this.Text.Length; 169926"];
2049 [label="FullWidth 169927"];
2050 [label="this.AdjustFlagsAndWidth(trailing); 169928"];
2051 [label="return '?'; 169929"];
2052 [label="FullWidth = this.Text.Length; 169930"];
2053 [label="FullWidth 169931"];
2054 [label="this.AdjustFlagsAndWidth(trailing); 169932"];
2055 [label="return '#'; 169933"];
2056 [label="FullWidth = this.Text.Length; 169934"];
2057 [label="FullWidth 169935"];
2058 [label="return '#'; 169936"];
2059 [label="FullWidth = this.Text.Length; 169937"];
2060 [label="FullWidth 169938"];
2061 [label="this.AdjustFlagsAndWidth(leading); 169939"];
2062 [label="return '#'; 169940"];
2063 [label="FullWidth = this.Text.Length; 169941"];
2064 [label="FullWidth 169942"];
2065 [label="this.AdjustFlagsAndWidth(trailing); 169943"];
2066 [label="return '#'; 169944"];
2067 [label="FullWidth = this.Text.Length; 169945"];
2068 [label="FullWidth 169946"];
2069 [label="this.AdjustFlagsAndWidth(trailing); 169947"];
2070 [label="return '/'; 169948"];
2071 [label="FullWidth = this.Text.Length; 169949"];
2072 [label="FullWidth 169950"];
2073 [label="return '/'; 169951"];
2074 [label="FullWidth = this.Text.Length; 169952"];
2075 [label="FullWidth 169953"];
2076 [label="this.AdjustFlagsAndWidth(leading); 169954"];
2077 [label="return '/'; 169955"];
2078 [label="FullWidth = this.Text.Length; 169956"];
2079 [label="FullWidth 169957"];
2080 [label="this.AdjustFlagsAndWidth(trailing); 169958"];
2081 [label="return '/'; 169959"];
2082 [label="FullWidth = this.Text.Length; 169960"];
2083 [label="FullWidth 169961"];
2084 [label="this.AdjustFlagsAndWidth(trailing); 169962"];
2085 [label="return '..'; 169963"];
2086 [label="FullWidth = this.Text.Length; 169964"];
2087 [label="FullWidth 169965"];
2088 [label="return '..'; 169966"];
2089 [label="FullWidth = this.Text.Length; 169967"];
2090 [label="FullWidth 169968"];
2091 [label="this.AdjustFlagsAndWidth(leading); 169969"];
2092 [label="return '..'; 169970"];
2093 [label="FullWidth = this.Text.Length; 169971"];
2094 [label="FullWidth 169972"];
2095 [label="this.AdjustFlagsAndWidth(trailing); 169973"];
2096 [label="return '..'; 169974"];
2097 [label="FullWidth = this.Text.Length; 169975"];
2098 [label="FullWidth 169976"];
2099 [label="this.AdjustFlagsAndWidth(trailing); 169977"];
2100 [label="return string.Empty; 169978"];
2101 [label="FullWidth = this.Text.Length; 169979"];
2102 [label="FullWidth 169980"];
2103 [label="return string.Empty; 169981"];
2104 [label="FullWidth = this.Text.Length; 169982"];
2105 [label="FullWidth 169983"];
2106 [label="this.AdjustFlagsAndWidth(leading); 169984"];
2107 [label="return string.Empty; 169985"];
2108 [label="FullWidth = this.Text.Length; 169986"];
2109 [label="FullWidth 169987"];
2110 [label="this.AdjustFlagsAndWidth(trailing); 169988"];
2111 [label="return string.Empty; 169989"];
2112 [label="FullWidth = this.Text.Length; 169990"];
2113 [label="FullWidth 169991"];
2114 [label="this.AdjustFlagsAndWidth(trailing); 169992"];
2115 [label="return '/>'; 169993"];
2116 [label="FullWidth = this.Text.Length; 169994"];
2117 [label="FullWidth 169995"];
2118 [label="return '/>'; 169996"];
2119 [label="FullWidth = this.Text.Length; 169997"];
2120 [label="FullWidth 169998"];
2121 [label="this.AdjustFlagsAndWidth(leading); 169999"];
2122 [label="return '/>'; 170000"];
2123 [label="FullWidth = this.Text.Length; 170001"];
2124 [label="FullWidth 170002"];
2125 [label="this.AdjustFlagsAndWidth(trailing); 170003"];
2126 [label="return '/>'; 170004"];
2127 [label="FullWidth = this.Text.Length; 170005"];
2128 [label="FullWidth 170006"];
2129 [label="this.AdjustFlagsAndWidth(trailing); 170007"];
2130 [label="return '</'; 170008"];
2131 [label="FullWidth = this.Text.Length; 170009"];
2132 [label="FullWidth 170010"];
2133 [label="return '</'; 170011"];
2134 [label="FullWidth = this.Text.Length; 170012"];
2135 [label="FullWidth 170013"];
2136 [label="this.AdjustFlagsAndWidth(leading); 170014"];
2137 [label="return '</'; 170015"];
2138 [label="FullWidth = this.Text.Length; 170016"];
2139 [label="FullWidth 170017"];
2140 [label="this.AdjustFlagsAndWidth(trailing); 170018"];
2141 [label="return '</'; 170019"];
2142 [label="FullWidth = this.Text.Length; 170020"];
2143 [label="FullWidth 170021"];
2144 [label="this.AdjustFlagsAndWidth(trailing); 170022"];
2145 [label="return '<!--'; 170023"];
2146 [label="FullWidth = this.Text.Length; 170024"];
2147 [label="FullWidth 170025"];
2148 [label="return '<!--'; 170026"];
2149 [label="FullWidth = this.Text.Length; 170027"];
2150 [label="FullWidth 170028"];
2151 [label="this.AdjustFlagsAndWidth(leading); 170029"];
2152 [label="return '<!--'; 170030"];
2153 [label="FullWidth = this.Text.Length; 170031"];
2154 [label="FullWidth 170032"];
2155 [label="this.AdjustFlagsAndWidth(trailing); 170033"];
2156 [label="return '<!--'; 170034"];
2157 [label="FullWidth = this.Text.Length; 170035"];
2158 [label="FullWidth 170036"];
2159 [label="this.AdjustFlagsAndWidth(trailing); 170037"];
2160 [label="return '-->'; 170038"];
2161 [label="FullWidth = this.Text.Length; 170039"];
2162 [label="FullWidth 170040"];
2163 [label="return '-->'; 170041"];
2164 [label="FullWidth = this.Text.Length; 170042"];
2165 [label="FullWidth 170043"];
2166 [label="this.AdjustFlagsAndWidth(leading); 170044"];
2167 [label="return '-->'; 170045"];
2168 [label="FullWidth = this.Text.Length; 170046"];
2169 [label="FullWidth 170047"];
2170 [label="this.AdjustFlagsAndWidth(trailing); 170048"];
2171 [label="return '-->'; 170049"];
2172 [label="FullWidth = this.Text.Length; 170050"];
2173 [label="FullWidth 170051"];
2174 [label="this.AdjustFlagsAndWidth(trailing); 170052"];
2175 [label="return '<![CDATA['; 170053"];
2176 [label="FullWidth = this.Text.Length; 170054"];
2177 [label="FullWidth 170055"];
2178 [label="return '<![CDATA['; 170056"];
2179 [label="FullWidth = this.Text.Length; 170057"];
2180 [label="FullWidth 170058"];
2181 [label="this.AdjustFlagsAndWidth(leading); 170059"];
2182 [label="return '<![CDATA['; 170060"];
2183 [label="FullWidth = this.Text.Length; 170061"];
2184 [label="FullWidth 170062"];
2185 [label="this.AdjustFlagsAndWidth(trailing); 170063"];
2186 [label="return '<![CDATA['; 170064"];
2187 [label="FullWidth = this.Text.Length; 170065"];
2188 [label="FullWidth 170066"];
2189 [label="this.AdjustFlagsAndWidth(trailing); 170067"];
2190 [label="return ']]>'; 170068"];
2191 [label="FullWidth = this.Text.Length; 170069"];
2192 [label="FullWidth 170070"];
2193 [label="return ']]>'; 170071"];
2194 [label="FullWidth = this.Text.Length; 170072"];
2195 [label="FullWidth 170073"];
2196 [label="this.AdjustFlagsAndWidth(leading); 170074"];
2197 [label="return ']]>'; 170075"];
2198 [label="FullWidth = this.Text.Length; 170076"];
2199 [label="FullWidth 170077"];
2200 [label="this.AdjustFlagsAndWidth(trailing); 170078"];
2201 [label="return ']]>'; 170079"];
2202 [label="FullWidth = this.Text.Length; 170080"];
2203 [label="FullWidth 170081"];
2204 [label="this.AdjustFlagsAndWidth(trailing); 170082"];
2205 [label="return '<?'; 170083"];
2206 [label="FullWidth = this.Text.Length; 170084"];
2207 [label="FullWidth 170085"];
2208 [label="return '<?'; 170086"];
2209 [label="FullWidth = this.Text.Length; 170087"];
2210 [label="FullWidth 170088"];
2211 [label="this.AdjustFlagsAndWidth(leading); 170089"];
2212 [label="return '<?'; 170090"];
2213 [label="FullWidth = this.Text.Length; 170091"];
2214 [label="FullWidth 170092"];
2215 [label="this.AdjustFlagsAndWidth(trailing); 170093"];
2216 [label="return '<?'; 170094"];
2217 [label="FullWidth = this.Text.Length; 170095"];
2218 [label="FullWidth 170096"];
2219 [label="this.AdjustFlagsAndWidth(trailing); 170097"];
2220 [label="return '?>'; 170098"];
2221 [label="FullWidth = this.Text.Length; 170099"];
2222 [label="FullWidth 170100"];
2223 [label="return '?>'; 170101"];
2224 [label="FullWidth = this.Text.Length; 170102"];
2225 [label="FullWidth 170103"];
2226 [label="this.AdjustFlagsAndWidth(leading); 170104"];
2227 [label="return '?>'; 170105"];
2228 [label="FullWidth = this.Text.Length; 170106"];
2229 [label="FullWidth 170107"];
2230 [label="this.AdjustFlagsAndWidth(trailing); 170108"];
2231 [label="return '?>'; 170109"];
2232 [label="FullWidth = this.Text.Length; 170110"];
2233 [label="FullWidth 170111"];
2234 [label="this.AdjustFlagsAndWidth(trailing); 170112"];
2235 [label="return '||'; 170113"];
2236 [label="FullWidth = this.Text.Length; 170114"];
2237 [label="FullWidth 170115"];
2238 [label="return '||'; 170116"];
2239 [label="FullWidth = this.Text.Length; 170117"];
2240 [label="FullWidth 170118"];
2241 [label="this.AdjustFlagsAndWidth(leading); 170119"];
2242 [label="return '||'; 170120"];
2243 [label="FullWidth = this.Text.Length; 170121"];
2244 [label="FullWidth 170122"];
2245 [label="this.AdjustFlagsAndWidth(trailing); 170123"];
2246 [label="return '||'; 170124"];
2247 [label="FullWidth = this.Text.Length; 170125"];
2248 [label="FullWidth 170126"];
2249 [label="this.AdjustFlagsAndWidth(trailing); 170127"];
2250 [label="return '&&'; 170128"];
2251 [label="FullWidth = this.Text.Length; 170129"];
2252 [label="FullWidth 170130"];
2253 [label="return '&&'; 170131"];
2254 [label="FullWidth = this.Text.Length; 170132"];
2255 [label="FullWidth 170133"];
2256 [label="this.AdjustFlagsAndWidth(leading); 170134"];
2257 [label="return '&&'; 170135"];
2258 [label="FullWidth = this.Text.Length; 170136"];
2259 [label="FullWidth 170137"];
2260 [label="this.AdjustFlagsAndWidth(trailing); 170138"];
2261 [label="return '&&'; 170139"];
2262 [label="FullWidth = this.Text.Length; 170140"];
2263 [label="FullWidth 170141"];
2264 [label="this.AdjustFlagsAndWidth(trailing); 170142"];
2265 [label="return '--'; 170143"];
2266 [label="FullWidth = this.Text.Length; 170144"];
2267 [label="FullWidth 170145"];
2268 [label="return '--'; 170146"];
2269 [label="FullWidth = this.Text.Length; 170147"];
2270 [label="FullWidth 170148"];
2271 [label="this.AdjustFlagsAndWidth(leading); 170149"];
2272 [label="return '--'; 170150"];
2273 [label="FullWidth = this.Text.Length; 170151"];
2274 [label="FullWidth 170152"];
2275 [label="this.AdjustFlagsAndWidth(trailing); 170153"];
2276 [label="return '--'; 170154"];
2277 [label="FullWidth = this.Text.Length; 170155"];
2278 [label="FullWidth 170156"];
2279 [label="this.AdjustFlagsAndWidth(trailing); 170157"];
2280 [label="return '++'; 170158"];
2281 [label="FullWidth = this.Text.Length; 170159"];
2282 [label="FullWidth 170160"];
2283 [label="return '++'; 170161"];
2284 [label="FullWidth = this.Text.Length; 170162"];
2285 [label="FullWidth 170163"];
2286 [label="this.AdjustFlagsAndWidth(leading); 170164"];
2287 [label="return '++'; 170165"];
2288 [label="FullWidth = this.Text.Length; 170166"];
2289 [label="FullWidth 170167"];
2290 [label="this.AdjustFlagsAndWidth(trailing); 170168"];
2291 [label="return '++'; 170169"];
2292 [label="FullWidth = this.Text.Length; 170170"];
2293 [label="FullWidth 170171"];
2294 [label="this.AdjustFlagsAndWidth(trailing); 170172"];
2295 [label="return '::'; 170173"];
2296 [label="FullWidth = this.Text.Length; 170174"];
2297 [label="FullWidth 170175"];
2298 [label="return '::'; 170176"];
2299 [label="FullWidth = this.Text.Length; 170177"];
2300 [label="FullWidth 170178"];
2301 [label="this.AdjustFlagsAndWidth(leading); 170179"];
2302 [label="return '::'; 170180"];
2303 [label="FullWidth = this.Text.Length; 170181"];
2304 [label="FullWidth 170182"];
2305 [label="this.AdjustFlagsAndWidth(trailing); 170183"];
2306 [label="return '::'; 170184"];
2307 [label="FullWidth = this.Text.Length; 170185"];
2308 [label="FullWidth 170186"];
2309 [label="this.AdjustFlagsAndWidth(trailing); 170187"];
2310 [label="return '??'; 170188"];
2311 [label="FullWidth = this.Text.Length; 170189"];
2312 [label="FullWidth 170190"];
2313 [label="return '??'; 170191"];
2314 [label="FullWidth = this.Text.Length; 170192"];
2315 [label="FullWidth 170193"];
2316 [label="this.AdjustFlagsAndWidth(leading); 170194"];
2317 [label="return '??'; 170195"];
2318 [label="FullWidth = this.Text.Length; 170196"];
2319 [label="FullWidth 170197"];
2320 [label="this.AdjustFlagsAndWidth(trailing); 170198"];
2321 [label="return '??'; 170199"];
2322 [label="FullWidth = this.Text.Length; 170200"];
2323 [label="FullWidth 170201"];
2324 [label="this.AdjustFlagsAndWidth(trailing); 170202"];
2325 [label="return '->'; 170203"];
2326 [label="FullWidth = this.Text.Length; 170204"];
2327 [label="FullWidth 170205"];
2328 [label="return '->'; 170206"];
2329 [label="FullWidth = this.Text.Length; 170207"];
2330 [label="FullWidth 170208"];
2331 [label="this.AdjustFlagsAndWidth(leading); 170209"];
2332 [label="return '->'; 170210"];
2333 [label="FullWidth = this.Text.Length; 170211"];
2334 [label="FullWidth 170212"];
2335 [label="this.AdjustFlagsAndWidth(trailing); 170213"];
2336 [label="return '->'; 170214"];
2337 [label="FullWidth = this.Text.Length; 170215"];
2338 [label="FullWidth 170216"];
2339 [label="this.AdjustFlagsAndWidth(trailing); 170217"];
2340 [label="return '!='; 170218"];
2341 [label="FullWidth = this.Text.Length; 170219"];
2342 [label="FullWidth 170220"];
2343 [label="return '!='; 170221"];
2344 [label="FullWidth = this.Text.Length; 170222"];
2345 [label="FullWidth 170223"];
2346 [label="this.AdjustFlagsAndWidth(leading); 170224"];
2347 [label="return '!='; 170225"];
2348 [label="FullWidth = this.Text.Length; 170226"];
2349 [label="FullWidth 170227"];
2350 [label="this.AdjustFlagsAndWidth(trailing); 170228"];
2351 [label="return '!='; 170229"];
2352 [label="FullWidth = this.Text.Length; 170230"];
2353 [label="FullWidth 170231"];
2354 [label="this.AdjustFlagsAndWidth(trailing); 170232"];
2355 [label="return '=='; 170233"];
2356 [label="FullWidth = this.Text.Length; 170234"];
2357 [label="FullWidth 170235"];
2358 [label="return '=='; 170236"];
2359 [label="FullWidth = this.Text.Length; 170237"];
2360 [label="FullWidth 170238"];
2361 [label="this.AdjustFlagsAndWidth(leading); 170239"];
2362 [label="return '=='; 170240"];
2363 [label="FullWidth = this.Text.Length; 170241"];
2364 [label="FullWidth 170242"];
2365 [label="this.AdjustFlagsAndWidth(trailing); 170243"];
2366 [label="return '=='; 170244"];
2367 [label="FullWidth = this.Text.Length; 170245"];
2368 [label="FullWidth 170246"];
2369 [label="this.AdjustFlagsAndWidth(trailing); 170247"];
2370 [label="return '=>'; 170248"];
2371 [label="FullWidth = this.Text.Length; 170249"];
2372 [label="FullWidth 170250"];
2373 [label="return '=>'; 170251"];
2374 [label="FullWidth = this.Text.Length; 170252"];
2375 [label="FullWidth 170253"];
2376 [label="this.AdjustFlagsAndWidth(leading); 170254"];
2377 [label="return '=>'; 170255"];
2378 [label="FullWidth = this.Text.Length; 170256"];
2379 [label="FullWidth 170257"];
2380 [label="this.AdjustFlagsAndWidth(trailing); 170258"];
2381 [label="return '=>'; 170259"];
2382 [label="FullWidth = this.Text.Length; 170260"];
2383 [label="FullWidth 170261"];
2384 [label="this.AdjustFlagsAndWidth(trailing); 170262"];
2385 [label="return '<='; 170263"];
2386 [label="FullWidth = this.Text.Length; 170264"];
2387 [label="FullWidth 170265"];
2388 [label="return '<='; 170266"];
2389 [label="FullWidth = this.Text.Length; 170267"];
2390 [label="FullWidth 170268"];
2391 [label="this.AdjustFlagsAndWidth(leading); 170269"];
2392 [label="return '<='; 170270"];
2393 [label="FullWidth = this.Text.Length; 170271"];
2394 [label="FullWidth 170272"];
2395 [label="this.AdjustFlagsAndWidth(trailing); 170273"];
2396 [label="return '<='; 170274"];
2397 [label="FullWidth = this.Text.Length; 170275"];
2398 [label="FullWidth 170276"];
2399 [label="this.AdjustFlagsAndWidth(trailing); 170277"];
2400 [label="return '<<'; 170278"];
2401 [label="FullWidth = this.Text.Length; 170279"];
2402 [label="FullWidth 170280"];
2403 [label="return '<<'; 170281"];
2404 [label="FullWidth = this.Text.Length; 170282"];
2405 [label="FullWidth 170283"];
2406 [label="this.AdjustFlagsAndWidth(leading); 170284"];
2407 [label="return '<<'; 170285"];
2408 [label="FullWidth = this.Text.Length; 170286"];
2409 [label="FullWidth 170287"];
2410 [label="this.AdjustFlagsAndWidth(trailing); 170288"];
2411 [label="return '<<'; 170289"];
2412 [label="FullWidth = this.Text.Length; 170290"];
2413 [label="FullWidth 170291"];
2414 [label="this.AdjustFlagsAndWidth(trailing); 170292"];
2415 [label="return '<<='; 170293"];
2416 [label="FullWidth = this.Text.Length; 170294"];
2417 [label="FullWidth 170295"];
2418 [label="return '<<='; 170296"];
2419 [label="FullWidth = this.Text.Length; 170297"];
2420 [label="FullWidth 170298"];
2421 [label="this.AdjustFlagsAndWidth(leading); 170299"];
2422 [label="return '<<='; 170300"];
2423 [label="FullWidth = this.Text.Length; 170301"];
2424 [label="FullWidth 170302"];
2425 [label="this.AdjustFlagsAndWidth(trailing); 170303"];
2426 [label="return '<<='; 170304"];
2427 [label="FullWidth = this.Text.Length; 170305"];
2428 [label="FullWidth 170306"];
2429 [label="this.AdjustFlagsAndWidth(trailing); 170307"];
2430 [label="return '>='; 170308"];
2431 [label="FullWidth = this.Text.Length; 170309"];
2432 [label="FullWidth 170310"];
2433 [label="return '>='; 170311"];
2434 [label="FullWidth = this.Text.Length; 170312"];
2435 [label="FullWidth 170313"];
2436 [label="this.AdjustFlagsAndWidth(leading); 170314"];
2437 [label="return '>='; 170315"];
2438 [label="FullWidth = this.Text.Length; 170316"];
2439 [label="FullWidth 170317"];
2440 [label="this.AdjustFlagsAndWidth(trailing); 170318"];
2441 [label="return '>='; 170319"];
2442 [label="FullWidth = this.Text.Length; 170320"];
2443 [label="FullWidth 170321"];
2444 [label="this.AdjustFlagsAndWidth(trailing); 170322"];
2445 [label="return '>>'; 170323"];
2446 [label="FullWidth = this.Text.Length; 170324"];
2447 [label="FullWidth 170325"];
2448 [label="return '>>'; 170326"];
2449 [label="FullWidth = this.Text.Length; 170327"];
2450 [label="FullWidth 170328"];
2451 [label="this.AdjustFlagsAndWidth(leading); 170329"];
2452 [label="return '>>'; 170330"];
2453 [label="FullWidth = this.Text.Length; 170331"];
2454 [label="FullWidth 170332"];
2455 [label="this.AdjustFlagsAndWidth(trailing); 170333"];
2456 [label="return '>>'; 170334"];
2457 [label="FullWidth = this.Text.Length; 170335"];
2458 [label="FullWidth 170336"];
2459 [label="this.AdjustFlagsAndWidth(trailing); 170337"];
2460 [label="return '>>='; 170338"];
2461 [label="FullWidth = this.Text.Length; 170339"];
2462 [label="FullWidth 170340"];
2463 [label="return '>>='; 170341"];
2464 [label="FullWidth = this.Text.Length; 170342"];
2465 [label="FullWidth 170343"];
2466 [label="this.AdjustFlagsAndWidth(leading); 170344"];
2467 [label="return '>>='; 170345"];
2468 [label="FullWidth = this.Text.Length; 170346"];
2469 [label="FullWidth 170347"];
2470 [label="this.AdjustFlagsAndWidth(trailing); 170348"];
2471 [label="return '>>='; 170349"];
2472 [label="FullWidth = this.Text.Length; 170350"];
2473 [label="FullWidth 170351"];
2474 [label="this.AdjustFlagsAndWidth(trailing); 170352"];
2475 [label="return '/='; 170353"];
2476 [label="FullWidth = this.Text.Length; 170354"];
2477 [label="FullWidth 170355"];
2478 [label="return '/='; 170356"];
2479 [label="FullWidth = this.Text.Length; 170357"];
2480 [label="FullWidth 170358"];
2481 [label="this.AdjustFlagsAndWidth(leading); 170359"];
2482 [label="return '/='; 170360"];
2483 [label="FullWidth = this.Text.Length; 170361"];
2484 [label="FullWidth 170362"];
2485 [label="this.AdjustFlagsAndWidth(trailing); 170363"];
2486 [label="return '/='; 170364"];
2487 [label="FullWidth = this.Text.Length; 170365"];
2488 [label="FullWidth 170366"];
2489 [label="this.AdjustFlagsAndWidth(trailing); 170367"];
2490 [label="return '*='; 170368"];
2491 [label="FullWidth = this.Text.Length; 170369"];
2492 [label="FullWidth 170370"];
2493 [label="return '*='; 170371"];
2494 [label="FullWidth = this.Text.Length; 170372"];
2495 [label="FullWidth 170373"];
2496 [label="this.AdjustFlagsAndWidth(leading); 170374"];
2497 [label="return '*='; 170375"];
2498 [label="FullWidth = this.Text.Length; 170376"];
2499 [label="FullWidth 170377"];
2500 [label="this.AdjustFlagsAndWidth(trailing); 170378"];
2501 [label="return '*='; 170379"];
2502 [label="FullWidth = this.Text.Length; 170380"];
2503 [label="FullWidth 170381"];
2504 [label="this.AdjustFlagsAndWidth(trailing); 170382"];
2505 [label="return '|='; 170383"];
2506 [label="FullWidth = this.Text.Length; 170384"];
2507 [label="FullWidth 170385"];
2508 [label="return '|='; 170386"];
2509 [label="FullWidth = this.Text.Length; 170387"];
2510 [label="FullWidth 170388"];
2511 [label="this.AdjustFlagsAndWidth(leading); 170389"];
2512 [label="return '|='; 170390"];
2513 [label="FullWidth = this.Text.Length; 170391"];
2514 [label="FullWidth 170392"];
2515 [label="this.AdjustFlagsAndWidth(trailing); 170393"];
2516 [label="return '|='; 170394"];
2517 [label="FullWidth = this.Text.Length; 170395"];
2518 [label="FullWidth 170396"];
2519 [label="this.AdjustFlagsAndWidth(trailing); 170397"];
2520 [label="return '&='; 170398"];
2521 [label="FullWidth = this.Text.Length; 170399"];
2522 [label="FullWidth 170400"];
2523 [label="return '&='; 170401"];
2524 [label="FullWidth = this.Text.Length; 170402"];
2525 [label="FullWidth 170403"];
2526 [label="this.AdjustFlagsAndWidth(leading); 170404"];
2527 [label="return '&='; 170405"];
2528 [label="FullWidth = this.Text.Length; 170406"];
2529 [label="FullWidth 170407"];
2530 [label="this.AdjustFlagsAndWidth(trailing); 170408"];
2531 [label="return '&='; 170409"];
2532 [label="FullWidth = this.Text.Length; 170410"];
2533 [label="FullWidth 170411"];
2534 [label="this.AdjustFlagsAndWidth(trailing); 170412"];
2535 [label="return '+='; 170413"];
2536 [label="FullWidth = this.Text.Length; 170414"];
2537 [label="FullWidth 170415"];
2538 [label="return '+='; 170416"];
2539 [label="FullWidth = this.Text.Length; 170417"];
2540 [label="FullWidth 170418"];
2541 [label="this.AdjustFlagsAndWidth(leading); 170419"];
2542 [label="return '+='; 170420"];
2543 [label="FullWidth = this.Text.Length; 170421"];
2544 [label="FullWidth 170422"];
2545 [label="this.AdjustFlagsAndWidth(trailing); 170423"];
2546 [label="return '+='; 170424"];
2547 [label="FullWidth = this.Text.Length; 170425"];
2548 [label="FullWidth 170426"];
2549 [label="this.AdjustFlagsAndWidth(trailing); 170427"];
2550 [label="return '-='; 170428"];
2551 [label="FullWidth = this.Text.Length; 170429"];
2552 [label="FullWidth 170430"];
2553 [label="return '-='; 170431"];
2554 [label="FullWidth = this.Text.Length; 170432"];
2555 [label="FullWidth 170433"];
2556 [label="this.AdjustFlagsAndWidth(leading); 170434"];
2557 [label="return '-='; 170435"];
2558 [label="FullWidth = this.Text.Length; 170436"];
2559 [label="FullWidth 170437"];
2560 [label="this.AdjustFlagsAndWidth(trailing); 170438"];
2561 [label="return '-='; 170439"];
2562 [label="FullWidth = this.Text.Length; 170440"];
2563 [label="FullWidth 170441"];
2564 [label="this.AdjustFlagsAndWidth(trailing); 170442"];
2565 [label="return '^='; 170443"];
2566 [label="FullWidth = this.Text.Length; 170444"];
2567 [label="FullWidth 170445"];
2568 [label="return '^='; 170446"];
2569 [label="FullWidth = this.Text.Length; 170447"];
2570 [label="FullWidth 170448"];
2571 [label="this.AdjustFlagsAndWidth(leading); 170449"];
2572 [label="return '^='; 170450"];
2573 [label="FullWidth = this.Text.Length; 170451"];
2574 [label="FullWidth 170452"];
2575 [label="this.AdjustFlagsAndWidth(trailing); 170453"];
2576 [label="return '^='; 170454"];
2577 [label="FullWidth = this.Text.Length; 170455"];
2578 [label="FullWidth 170456"];
2579 [label="this.AdjustFlagsAndWidth(trailing); 170457"];
2580 [label="return '%='; 170458"];
2581 [label="FullWidth = this.Text.Length; 170459"];
2582 [label="FullWidth 170460"];
2583 [label="return '%='; 170461"];
2584 [label="FullWidth = this.Text.Length; 170462"];
2585 [label="FullWidth 170463"];
2586 [label="this.AdjustFlagsAndWidth(leading); 170464"];
2587 [label="return '%='; 170465"];
2588 [label="FullWidth = this.Text.Length; 170466"];
2589 [label="FullWidth 170467"];
2590 [label="this.AdjustFlagsAndWidth(trailing); 170468"];
2591 [label="return '%='; 170469"];
2592 [label="FullWidth = this.Text.Length; 170470"];
2593 [label="FullWidth 170471"];
2594 [label="this.AdjustFlagsAndWidth(trailing); 170472"];
2595 [label="return '??='; 170473"];
2596 [label="FullWidth = this.Text.Length; 170474"];
2597 [label="FullWidth 170475"];
2598 [label="return '??='; 170476"];
2599 [label="FullWidth = this.Text.Length; 170477"];
2600 [label="FullWidth 170478"];
2601 [label="this.AdjustFlagsAndWidth(leading); 170479"];
2602 [label="return '??='; 170480"];
2603 [label="FullWidth = this.Text.Length; 170481"];
2604 [label="FullWidth 170482"];
2605 [label="this.AdjustFlagsAndWidth(trailing); 170483"];
2606 [label="return '??='; 170484"];
2607 [label="FullWidth = this.Text.Length; 170485"];
2608 [label="FullWidth 170486"];
2609 [label="this.AdjustFlagsAndWidth(trailing); 170487"];
2610 [label="return 'bool'; 170488"];
2611 [label="FullWidth = this.Text.Length; 170489"];
2612 [label="FullWidth 170490"];
2613 [label="return 'bool'; 170491"];
2614 [label="FullWidth = this.Text.Length; 170492"];
2615 [label="FullWidth 170493"];
2616 [label="this.AdjustFlagsAndWidth(leading); 170494"];
2617 [label="return 'bool'; 170495"];
2618 [label="FullWidth = this.Text.Length; 170496"];
2619 [label="FullWidth 170497"];
2620 [label="this.AdjustFlagsAndWidth(trailing); 170498"];
2621 [label="return 'bool'; 170499"];
2622 [label="FullWidth = this.Text.Length; 170500"];
2623 [label="FullWidth 170501"];
2624 [label="this.AdjustFlagsAndWidth(trailing); 170502"];
2625 [label="return 'byte'; 170503"];
2626 [label="FullWidth = this.Text.Length; 170504"];
2627 [label="FullWidth 170505"];
2628 [label="return 'byte'; 170506"];
2629 [label="FullWidth = this.Text.Length; 170507"];
2630 [label="FullWidth 170508"];
2631 [label="this.AdjustFlagsAndWidth(leading); 170509"];
2632 [label="return 'byte'; 170510"];
2633 [label="FullWidth = this.Text.Length; 170511"];
2634 [label="FullWidth 170512"];
2635 [label="this.AdjustFlagsAndWidth(trailing); 170513"];
2636 [label="return 'byte'; 170514"];
2637 [label="FullWidth = this.Text.Length; 170515"];
2638 [label="FullWidth 170516"];
2639 [label="this.AdjustFlagsAndWidth(trailing); 170517"];
2640 [label="return 'sbyte'; 170518"];
2641 [label="FullWidth = this.Text.Length; 170519"];
2642 [label="FullWidth 170520"];
2643 [label="return 'sbyte'; 170521"];
2644 [label="FullWidth = this.Text.Length; 170522"];
2645 [label="FullWidth 170523"];
2646 [label="this.AdjustFlagsAndWidth(leading); 170524"];
2647 [label="return 'sbyte'; 170525"];
2648 [label="FullWidth = this.Text.Length; 170526"];
2649 [label="FullWidth 170527"];
2650 [label="this.AdjustFlagsAndWidth(trailing); 170528"];
2651 [label="return 'sbyte'; 170529"];
2652 [label="FullWidth = this.Text.Length; 170530"];
2653 [label="FullWidth 170531"];
2654 [label="this.AdjustFlagsAndWidth(trailing); 170532"];
2655 [label="return 'short'; 170533"];
2656 [label="FullWidth = this.Text.Length; 170534"];
2657 [label="FullWidth 170535"];
2658 [label="return 'short'; 170536"];
2659 [label="FullWidth = this.Text.Length; 170537"];
2660 [label="FullWidth 170538"];
2661 [label="this.AdjustFlagsAndWidth(leading); 170539"];
2662 [label="return 'short'; 170540"];
2663 [label="FullWidth = this.Text.Length; 170541"];
2664 [label="FullWidth 170542"];
2665 [label="this.AdjustFlagsAndWidth(trailing); 170543"];
2666 [label="return 'short'; 170544"];
2667 [label="FullWidth = this.Text.Length; 170545"];
2668 [label="FullWidth 170546"];
2669 [label="this.AdjustFlagsAndWidth(trailing); 170547"];
2670 [label="return 'ushort'; 170548"];
2671 [label="FullWidth = this.Text.Length; 170549"];
2672 [label="FullWidth 170550"];
2673 [label="return 'ushort'; 170551"];
2674 [label="FullWidth = this.Text.Length; 170552"];
2675 [label="FullWidth 170553"];
2676 [label="this.AdjustFlagsAndWidth(leading); 170554"];
2677 [label="return 'ushort'; 170555"];
2678 [label="FullWidth = this.Text.Length; 170556"];
2679 [label="FullWidth 170557"];
2680 [label="this.AdjustFlagsAndWidth(trailing); 170558"];
2681 [label="return 'ushort'; 170559"];
2682 [label="FullWidth = this.Text.Length; 170560"];
2683 [label="FullWidth 170561"];
2684 [label="this.AdjustFlagsAndWidth(trailing); 170562"];
2685 [label="return 'int'; 170563"];
2686 [label="FullWidth = this.Text.Length; 170564"];
2687 [label="FullWidth 170565"];
2688 [label="return 'int'; 170566"];
2689 [label="FullWidth = this.Text.Length; 170567"];
2690 [label="FullWidth 170568"];
2691 [label="this.AdjustFlagsAndWidth(leading); 170569"];
2692 [label="return 'int'; 170570"];
2693 [label="FullWidth = this.Text.Length; 170571"];
2694 [label="FullWidth 170572"];
2695 [label="this.AdjustFlagsAndWidth(trailing); 170573"];
2696 [label="return 'int'; 170574"];
2697 [label="FullWidth = this.Text.Length; 170575"];
2698 [label="FullWidth 170576"];
2699 [label="this.AdjustFlagsAndWidth(trailing); 170577"];
2700 [label="return 'uint'; 170578"];
2701 [label="FullWidth = this.Text.Length; 170579"];
2702 [label="FullWidth 170580"];
2703 [label="return 'uint'; 170581"];
2704 [label="FullWidth = this.Text.Length; 170582"];
2705 [label="FullWidth 170583"];
2706 [label="this.AdjustFlagsAndWidth(leading); 170584"];
2707 [label="return 'uint'; 170585"];
2708 [label="FullWidth = this.Text.Length; 170586"];
2709 [label="FullWidth 170587"];
2710 [label="this.AdjustFlagsAndWidth(trailing); 170588"];
2711 [label="return 'uint'; 170589"];
2712 [label="FullWidth = this.Text.Length; 170590"];
2713 [label="FullWidth 170591"];
2714 [label="this.AdjustFlagsAndWidth(trailing); 170592"];
2715 [label="return 'long'; 170593"];
2716 [label="FullWidth = this.Text.Length; 170594"];
2717 [label="FullWidth 170595"];
2718 [label="return 'long'; 170596"];
2719 [label="FullWidth = this.Text.Length; 170597"];
2720 [label="FullWidth 170598"];
2721 [label="this.AdjustFlagsAndWidth(leading); 170599"];
2722 [label="return 'long'; 170600"];
2723 [label="FullWidth = this.Text.Length; 170601"];
2724 [label="FullWidth 170602"];
2725 [label="this.AdjustFlagsAndWidth(trailing); 170603"];
2726 [label="return 'long'; 170604"];
2727 [label="FullWidth = this.Text.Length; 170605"];
2728 [label="FullWidth 170606"];
2729 [label="this.AdjustFlagsAndWidth(trailing); 170607"];
2730 [label="return 'ulong'; 170608"];
2731 [label="FullWidth = this.Text.Length; 170609"];
2732 [label="FullWidth 170610"];
2733 [label="return 'ulong'; 170611"];
2734 [label="FullWidth = this.Text.Length; 170612"];
2735 [label="FullWidth 170613"];
2736 [label="this.AdjustFlagsAndWidth(leading); 170614"];
2737 [label="return 'ulong'; 170615"];
2738 [label="FullWidth = this.Text.Length; 170616"];
2739 [label="FullWidth 170617"];
2740 [label="this.AdjustFlagsAndWidth(trailing); 170618"];
2741 [label="return 'ulong'; 170619"];
2742 [label="FullWidth = this.Text.Length; 170620"];
2743 [label="FullWidth 170621"];
2744 [label="this.AdjustFlagsAndWidth(trailing); 170622"];
2745 [label="return 'double'; 170623"];
2746 [label="FullWidth = this.Text.Length; 170624"];
2747 [label="FullWidth 170625"];
2748 [label="return 'double'; 170626"];
2749 [label="FullWidth = this.Text.Length; 170627"];
2750 [label="FullWidth 170628"];
2751 [label="this.AdjustFlagsAndWidth(leading); 170629"];
2752 [label="return 'double'; 170630"];
2753 [label="FullWidth = this.Text.Length; 170631"];
2754 [label="FullWidth 170632"];
2755 [label="this.AdjustFlagsAndWidth(trailing); 170633"];
2756 [label="return 'double'; 170634"];
2757 [label="FullWidth = this.Text.Length; 170635"];
2758 [label="FullWidth 170636"];
2759 [label="this.AdjustFlagsAndWidth(trailing); 170637"];
2760 [label="return 'float'; 170638"];
2761 [label="FullWidth = this.Text.Length; 170639"];
2762 [label="FullWidth 170640"];
2763 [label="return 'float'; 170641"];
2764 [label="FullWidth = this.Text.Length; 170642"];
2765 [label="FullWidth 170643"];
2766 [label="this.AdjustFlagsAndWidth(leading); 170644"];
2767 [label="return 'float'; 170645"];
2768 [label="FullWidth = this.Text.Length; 170646"];
2769 [label="FullWidth 170647"];
2770 [label="this.AdjustFlagsAndWidth(trailing); 170648"];
2771 [label="return 'float'; 170649"];
2772 [label="FullWidth = this.Text.Length; 170650"];
2773 [label="FullWidth 170651"];
2774 [label="this.AdjustFlagsAndWidth(trailing); 170652"];
2775 [label="return 'decimal'; 170653"];
2776 [label="FullWidth = this.Text.Length; 170654"];
2777 [label="FullWidth 170655"];
2778 [label="return 'decimal'; 170656"];
2779 [label="FullWidth = this.Text.Length; 170657"];
2780 [label="FullWidth 170658"];
2781 [label="this.AdjustFlagsAndWidth(leading); 170659"];
2782 [label="return 'decimal'; 170660"];
2783 [label="FullWidth = this.Text.Length; 170661"];
2784 [label="FullWidth 170662"];
2785 [label="this.AdjustFlagsAndWidth(trailing); 170663"];
2786 [label="return 'decimal'; 170664"];
2787 [label="FullWidth = this.Text.Length; 170665"];
2788 [label="FullWidth 170666"];
2789 [label="this.AdjustFlagsAndWidth(trailing); 170667"];
2790 [label="return 'string'; 170668"];
2791 [label="FullWidth = this.Text.Length; 170669"];
2792 [label="FullWidth 170670"];
2793 [label="return 'string'; 170671"];
2794 [label="FullWidth = this.Text.Length; 170672"];
2795 [label="FullWidth 170673"];
2796 [label="this.AdjustFlagsAndWidth(leading); 170674"];
2797 [label="return 'string'; 170675"];
2798 [label="FullWidth = this.Text.Length; 170676"];
2799 [label="FullWidth 170677"];
2800 [label="this.AdjustFlagsAndWidth(trailing); 170678"];
2801 [label="return 'string'; 170679"];
2802 [label="FullWidth = this.Text.Length; 170680"];
2803 [label="FullWidth 170681"];
2804 [label="this.AdjustFlagsAndWidth(trailing); 170682"];
2805 [label="return 'char'; 170683"];
2806 [label="FullWidth = this.Text.Length; 170684"];
2807 [label="FullWidth 170685"];
2808 [label="return 'char'; 170686"];
2809 [label="FullWidth = this.Text.Length; 170687"];
2810 [label="FullWidth 170688"];
2811 [label="this.AdjustFlagsAndWidth(leading); 170689"];
2812 [label="return 'char'; 170690"];
2813 [label="FullWidth = this.Text.Length; 170691"];
2814 [label="FullWidth 170692"];
2815 [label="this.AdjustFlagsAndWidth(trailing); 170693"];
2816 [label="return 'char'; 170694"];
2817 [label="FullWidth = this.Text.Length; 170695"];
2818 [label="FullWidth 170696"];
2819 [label="this.AdjustFlagsAndWidth(trailing); 170697"];
2820 [label="return 'void'; 170698"];
2821 [label="FullWidth = this.Text.Length; 170699"];
2822 [label="FullWidth 170700"];
2823 [label="return 'void'; 170701"];
2824 [label="FullWidth = this.Text.Length; 170702"];
2825 [label="FullWidth 170703"];
2826 [label="this.AdjustFlagsAndWidth(leading); 170704"];
2827 [label="return 'void'; 170705"];
2828 [label="FullWidth = this.Text.Length; 170706"];
2829 [label="FullWidth 170707"];
2830 [label="this.AdjustFlagsAndWidth(trailing); 170708"];
2831 [label="return 'void'; 170709"];
2832 [label="FullWidth = this.Text.Length; 170710"];
2833 [label="FullWidth 170711"];
2834 [label="this.AdjustFlagsAndWidth(trailing); 170712"];
2835 [label="return 'object'; 170713"];
2836 [label="FullWidth = this.Text.Length; 170714"];
2837 [label="FullWidth 170715"];
2838 [label="return 'object'; 170716"];
2839 [label="FullWidth = this.Text.Length; 170717"];
2840 [label="FullWidth 170718"];
2841 [label="this.AdjustFlagsAndWidth(leading); 170719"];
2842 [label="return 'object'; 170720"];
2843 [label="FullWidth = this.Text.Length; 170721"];
2844 [label="FullWidth 170722"];
2845 [label="this.AdjustFlagsAndWidth(trailing); 170723"];
2846 [label="return 'object'; 170724"];
2847 [label="FullWidth = this.Text.Length; 170725"];
2848 [label="FullWidth 170726"];
2849 [label="this.AdjustFlagsAndWidth(trailing); 170727"];
2850 [label="return 'typeof'; 170728"];
2851 [label="FullWidth = this.Text.Length; 170729"];
2852 [label="FullWidth 170730"];
2853 [label="return 'typeof'; 170731"];
2854 [label="FullWidth = this.Text.Length; 170732"];
2855 [label="FullWidth 170733"];
2856 [label="this.AdjustFlagsAndWidth(leading); 170734"];
2857 [label="return 'typeof'; 170735"];
2858 [label="FullWidth = this.Text.Length; 170736"];
2859 [label="FullWidth 170737"];
2860 [label="this.AdjustFlagsAndWidth(trailing); 170738"];
2861 [label="return 'typeof'; 170739"];
2862 [label="FullWidth = this.Text.Length; 170740"];
2863 [label="FullWidth 170741"];
2864 [label="this.AdjustFlagsAndWidth(trailing); 170742"];
2865 [label="return 'sizeof'; 170743"];
2866 [label="FullWidth = this.Text.Length; 170744"];
2867 [label="FullWidth 170745"];
2868 [label="return 'sizeof'; 170746"];
2869 [label="FullWidth = this.Text.Length; 170747"];
2870 [label="FullWidth 170748"];
2871 [label="this.AdjustFlagsAndWidth(leading); 170749"];
2872 [label="return 'sizeof'; 170750"];
2873 [label="FullWidth = this.Text.Length; 170751"];
2874 [label="FullWidth 170752"];
2875 [label="this.AdjustFlagsAndWidth(trailing); 170753"];
2876 [label="return 'sizeof'; 170754"];
2877 [label="FullWidth = this.Text.Length; 170755"];
2878 [label="FullWidth 170756"];
2879 [label="this.AdjustFlagsAndWidth(trailing); 170757"];
2880 [label="return 'null'; 170758"];
2881 [label="FullWidth = this.Text.Length; 170759"];
2882 [label="FullWidth 170760"];
2883 [label="return 'null'; 170761"];
2884 [label="FullWidth = this.Text.Length; 170762"];
2885 [label="FullWidth 170763"];
2886 [label="this.AdjustFlagsAndWidth(leading); 170764"];
2887 [label="return 'null'; 170765"];
2888 [label="FullWidth = this.Text.Length; 170766"];
2889 [label="FullWidth 170767"];
2890 [label="this.AdjustFlagsAndWidth(trailing); 170768"];
2891 [label="return 'null'; 170769"];
2892 [label="FullWidth = this.Text.Length; 170770"];
2893 [label="FullWidth 170771"];
2894 [label="this.AdjustFlagsAndWidth(trailing); 170772"];
2895 [label="return 'true'; 170773"];
2896 [label="FullWidth = this.Text.Length; 170774"];
2897 [label="FullWidth 170775"];
2898 [label="return 'true'; 170776"];
2899 [label="FullWidth = this.Text.Length; 170777"];
2900 [label="FullWidth 170778"];
2901 [label="this.AdjustFlagsAndWidth(leading); 170779"];
2902 [label="return 'true'; 170780"];
2903 [label="FullWidth = this.Text.Length; 170781"];
2904 [label="FullWidth 170782"];
2905 [label="this.AdjustFlagsAndWidth(trailing); 170783"];
2906 [label="return 'true'; 170784"];
2907 [label="FullWidth = this.Text.Length; 170785"];
2908 [label="FullWidth 170786"];
2909 [label="this.AdjustFlagsAndWidth(trailing); 170787"];
2910 [label="return 'false'; 170788"];
2911 [label="FullWidth = this.Text.Length; 170789"];
2912 [label="FullWidth 170790"];
2913 [label="return 'false'; 170791"];
2914 [label="FullWidth = this.Text.Length; 170792"];
2915 [label="FullWidth 170793"];
2916 [label="this.AdjustFlagsAndWidth(leading); 170794"];
2917 [label="return 'false'; 170795"];
2918 [label="FullWidth = this.Text.Length; 170796"];
2919 [label="FullWidth 170797"];
2920 [label="this.AdjustFlagsAndWidth(trailing); 170798"];
2921 [label="return 'false'; 170799"];
2922 [label="FullWidth = this.Text.Length; 170800"];
2923 [label="FullWidth 170801"];
2924 [label="this.AdjustFlagsAndWidth(trailing); 170802"];
2925 [label="return 'if'; 170803"];
2926 [label="FullWidth = this.Text.Length; 170804"];
2927 [label="FullWidth 170805"];
2928 [label="return 'if'; 170806"];
2929 [label="FullWidth = this.Text.Length; 170807"];
2930 [label="FullWidth 170808"];
2931 [label="this.AdjustFlagsAndWidth(leading); 170809"];
2932 [label="return 'if'; 170810"];
2933 [label="FullWidth = this.Text.Length; 170811"];
2934 [label="FullWidth 170812"];
2935 [label="this.AdjustFlagsAndWidth(trailing); 170813"];
2936 [label="return 'if'; 170814"];
2937 [label="FullWidth = this.Text.Length; 170815"];
2938 [label="FullWidth 170816"];
2939 [label="this.AdjustFlagsAndWidth(trailing); 170817"];
2940 [label="return 'else'; 170818"];
2941 [label="FullWidth = this.Text.Length; 170819"];
2942 [label="FullWidth 170820"];
2943 [label="return 'else'; 170821"];
2944 [label="FullWidth = this.Text.Length; 170822"];
2945 [label="FullWidth 170823"];
2946 [label="this.AdjustFlagsAndWidth(leading); 170824"];
2947 [label="return 'else'; 170825"];
2948 [label="FullWidth = this.Text.Length; 170826"];
2949 [label="FullWidth 170827"];
2950 [label="this.AdjustFlagsAndWidth(trailing); 170828"];
2951 [label="return 'else'; 170829"];
2952 [label="FullWidth = this.Text.Length; 170830"];
2953 [label="FullWidth 170831"];
2954 [label="this.AdjustFlagsAndWidth(trailing); 170832"];
2955 [label="return 'while'; 170833"];
2956 [label="FullWidth = this.Text.Length; 170834"];
2957 [label="FullWidth 170835"];
2958 [label="return 'while'; 170836"];
2959 [label="FullWidth = this.Text.Length; 170837"];
2960 [label="FullWidth 170838"];
2961 [label="this.AdjustFlagsAndWidth(leading); 170839"];
2962 [label="return 'while'; 170840"];
2963 [label="FullWidth = this.Text.Length; 170841"];
2964 [label="FullWidth 170842"];
2965 [label="this.AdjustFlagsAndWidth(trailing); 170843"];
2966 [label="return 'while'; 170844"];
2967 [label="FullWidth = this.Text.Length; 170845"];
2968 [label="FullWidth 170846"];
2969 [label="this.AdjustFlagsAndWidth(trailing); 170847"];
2970 [label="return 'for'; 170848"];
2971 [label="FullWidth = this.Text.Length; 170849"];
2972 [label="FullWidth 170850"];
2973 [label="return 'for'; 170851"];
2974 [label="FullWidth = this.Text.Length; 170852"];
2975 [label="FullWidth 170853"];
2976 [label="this.AdjustFlagsAndWidth(leading); 170854"];
2977 [label="return 'for'; 170855"];
2978 [label="FullWidth = this.Text.Length; 170856"];
2979 [label="FullWidth 170857"];
2980 [label="this.AdjustFlagsAndWidth(trailing); 170858"];
2981 [label="return 'for'; 170859"];
2982 [label="FullWidth = this.Text.Length; 170860"];
2983 [label="FullWidth 170861"];
2984 [label="this.AdjustFlagsAndWidth(trailing); 170862"];
2985 [label="return 'foreach'; 170863"];
2986 [label="FullWidth = this.Text.Length; 170864"];
2987 [label="FullWidth 170865"];
2988 [label="return 'foreach'; 170866"];
2989 [label="FullWidth = this.Text.Length; 170867"];
2990 [label="FullWidth 170868"];
2991 [label="this.AdjustFlagsAndWidth(leading); 170869"];
2992 [label="return 'foreach'; 170870"];
2993 [label="FullWidth = this.Text.Length; 170871"];
2994 [label="FullWidth 170872"];
2995 [label="this.AdjustFlagsAndWidth(trailing); 170873"];
2996 [label="return 'foreach'; 170874"];
2997 [label="FullWidth = this.Text.Length; 170875"];
2998 [label="FullWidth 170876"];
2999 [label="this.AdjustFlagsAndWidth(trailing); 170877"];
3000 [label="return 'do'; 170878"];
3001 [label="FullWidth = this.Text.Length; 170879"];
3002 [label="FullWidth 170880"];
3003 [label="return 'do'; 170881"];
3004 [label="FullWidth = this.Text.Length; 170882"];
3005 [label="FullWidth 170883"];
3006 [label="this.AdjustFlagsAndWidth(leading); 170884"];
3007 [label="return 'do'; 170885"];
3008 [label="FullWidth = this.Text.Length; 170886"];
3009 [label="FullWidth 170887"];
3010 [label="this.AdjustFlagsAndWidth(trailing); 170888"];
3011 [label="return 'do'; 170889"];
3012 [label="FullWidth = this.Text.Length; 170890"];
3013 [label="FullWidth 170891"];
3014 [label="this.AdjustFlagsAndWidth(trailing); 170892"];
3015 [label="return 'switch'; 170893"];
3016 [label="FullWidth = this.Text.Length; 170894"];
3017 [label="FullWidth 170895"];
3018 [label="return 'switch'; 170896"];
3019 [label="FullWidth = this.Text.Length; 170897"];
3020 [label="FullWidth 170898"];
3021 [label="this.AdjustFlagsAndWidth(leading); 170899"];
3022 [label="return 'switch'; 170900"];
3023 [label="FullWidth = this.Text.Length; 170901"];
3024 [label="FullWidth 170902"];
3025 [label="this.AdjustFlagsAndWidth(trailing); 170903"];
3026 [label="return 'switch'; 170904"];
3027 [label="FullWidth = this.Text.Length; 170905"];
3028 [label="FullWidth 170906"];
3029 [label="this.AdjustFlagsAndWidth(trailing); 170907"];
3030 [label="return 'case'; 170908"];
3031 [label="FullWidth = this.Text.Length; 170909"];
3032 [label="FullWidth 170910"];
3033 [label="return 'case'; 170911"];
3034 [label="FullWidth = this.Text.Length; 170912"];
3035 [label="FullWidth 170913"];
3036 [label="this.AdjustFlagsAndWidth(leading); 170914"];
3037 [label="return 'case'; 170915"];
3038 [label="FullWidth = this.Text.Length; 170916"];
3039 [label="FullWidth 170917"];
3040 [label="this.AdjustFlagsAndWidth(trailing); 170918"];
3041 [label="return 'case'; 170919"];
3042 [label="FullWidth = this.Text.Length; 170920"];
3043 [label="FullWidth 170921"];
3044 [label="this.AdjustFlagsAndWidth(trailing); 170922"];
3045 [label="return 'default'; 170923"];
3046 [label="FullWidth = this.Text.Length; 170924"];
3047 [label="FullWidth 170925"];
3048 [label="return 'default'; 170926"];
3049 [label="FullWidth = this.Text.Length; 170927"];
3050 [label="FullWidth 170928"];
3051 [label="this.AdjustFlagsAndWidth(leading); 170929"];
3052 [label="return 'default'; 170930"];
3053 [label="FullWidth = this.Text.Length; 170931"];
3054 [label="FullWidth 170932"];
3055 [label="this.AdjustFlagsAndWidth(trailing); 170933"];
3056 [label="return 'default'; 170934"];
3057 [label="FullWidth = this.Text.Length; 170935"];
3058 [label="FullWidth 170936"];
3059 [label="this.AdjustFlagsAndWidth(trailing); 170937"];
3060 [label="return 'try'; 170938"];
3061 [label="FullWidth = this.Text.Length; 170939"];
3062 [label="FullWidth 170940"];
3063 [label="return 'try'; 170941"];
3064 [label="FullWidth = this.Text.Length; 170942"];
3065 [label="FullWidth 170943"];
3066 [label="this.AdjustFlagsAndWidth(leading); 170944"];
3067 [label="return 'try'; 170945"];
3068 [label="FullWidth = this.Text.Length; 170946"];
3069 [label="FullWidth 170947"];
3070 [label="this.AdjustFlagsAndWidth(trailing); 170948"];
3071 [label="return 'try'; 170949"];
3072 [label="FullWidth = this.Text.Length; 170950"];
3073 [label="FullWidth 170951"];
3074 [label="this.AdjustFlagsAndWidth(trailing); 170952"];
3075 [label="return 'catch'; 170953"];
3076 [label="FullWidth = this.Text.Length; 170954"];
3077 [label="FullWidth 170955"];
3078 [label="return 'catch'; 170956"];
3079 [label="FullWidth = this.Text.Length; 170957"];
3080 [label="FullWidth 170958"];
3081 [label="this.AdjustFlagsAndWidth(leading); 170959"];
3082 [label="return 'catch'; 170960"];
3083 [label="FullWidth = this.Text.Length; 170961"];
3084 [label="FullWidth 170962"];
3085 [label="this.AdjustFlagsAndWidth(trailing); 170963"];
3086 [label="return 'catch'; 170964"];
3087 [label="FullWidth = this.Text.Length; 170965"];
3088 [label="FullWidth 170966"];
3089 [label="this.AdjustFlagsAndWidth(trailing); 170967"];
3090 [label="return 'finally'; 170968"];
3091 [label="FullWidth = this.Text.Length; 170969"];
3092 [label="FullWidth 170970"];
3093 [label="return 'finally'; 170971"];
3094 [label="FullWidth = this.Text.Length; 170972"];
3095 [label="FullWidth 170973"];
3096 [label="this.AdjustFlagsAndWidth(leading); 170974"];
3097 [label="return 'finally'; 170975"];
3098 [label="FullWidth = this.Text.Length; 170976"];
3099 [label="FullWidth 170977"];
3100 [label="this.AdjustFlagsAndWidth(trailing); 170978"];
3101 [label="return 'finally'; 170979"];
3102 [label="FullWidth = this.Text.Length; 170980"];
3103 [label="FullWidth 170981"];
3104 [label="this.AdjustFlagsAndWidth(trailing); 170982"];
3105 [label="return 'lock'; 170983"];
3106 [label="FullWidth = this.Text.Length; 170984"];
3107 [label="FullWidth 170985"];
3108 [label="return 'lock'; 170986"];
3109 [label="FullWidth = this.Text.Length; 170987"];
3110 [label="FullWidth 170988"];
3111 [label="this.AdjustFlagsAndWidth(leading); 170989"];
3112 [label="return 'lock'; 170990"];
3113 [label="FullWidth = this.Text.Length; 170991"];
3114 [label="FullWidth 170992"];
3115 [label="this.AdjustFlagsAndWidth(trailing); 170993"];
3116 [label="return 'lock'; 170994"];
3117 [label="FullWidth = this.Text.Length; 170995"];
3118 [label="FullWidth 170996"];
3119 [label="this.AdjustFlagsAndWidth(trailing); 170997"];
3120 [label="return 'goto'; 170998"];
3121 [label="FullWidth = this.Text.Length; 170999"];
3122 [label="FullWidth 171000"];
3123 [label="return 'goto'; 171001"];
3124 [label="FullWidth = this.Text.Length; 171002"];
3125 [label="FullWidth 171003"];
3126 [label="this.AdjustFlagsAndWidth(leading); 171004"];
3127 [label="return 'goto'; 171005"];
3128 [label="FullWidth = this.Text.Length; 171006"];
3129 [label="FullWidth 171007"];
3130 [label="this.AdjustFlagsAndWidth(trailing); 171008"];
3131 [label="return 'goto'; 171009"];
3132 [label="FullWidth = this.Text.Length; 171010"];
3133 [label="FullWidth 171011"];
3134 [label="this.AdjustFlagsAndWidth(trailing); 171012"];
3135 [label="return 'break'; 171013"];
3136 [label="FullWidth = this.Text.Length; 171014"];
3137 [label="FullWidth 171015"];
3138 [label="return 'break'; 171016"];
3139 [label="FullWidth = this.Text.Length; 171017"];
3140 [label="FullWidth 171018"];
3141 [label="this.AdjustFlagsAndWidth(leading); 171019"];
3142 [label="return 'break'; 171020"];
3143 [label="FullWidth = this.Text.Length; 171021"];
3144 [label="FullWidth 171022"];
3145 [label="this.AdjustFlagsAndWidth(trailing); 171023"];
3146 [label="return 'break'; 171024"];
3147 [label="FullWidth = this.Text.Length; 171025"];
3148 [label="FullWidth 171026"];
3149 [label="this.AdjustFlagsAndWidth(trailing); 171027"];
3150 [label="return 'continue'; 171028"];
3151 [label="FullWidth = this.Text.Length; 171029"];
3152 [label="FullWidth 171030"];
3153 [label="return 'continue'; 171031"];
3154 [label="FullWidth = this.Text.Length; 171032"];
3155 [label="FullWidth 171033"];
3156 [label="this.AdjustFlagsAndWidth(leading); 171034"];
3157 [label="return 'continue'; 171035"];
3158 [label="FullWidth = this.Text.Length; 171036"];
3159 [label="FullWidth 171037"];
3160 [label="this.AdjustFlagsAndWidth(trailing); 171038"];
3161 [label="return 'continue'; 171039"];
3162 [label="FullWidth = this.Text.Length; 171040"];
3163 [label="FullWidth 171041"];
3164 [label="this.AdjustFlagsAndWidth(trailing); 171042"];
3165 [label="return 'return'; 171043"];
3166 [label="FullWidth = this.Text.Length; 171044"];
3167 [label="FullWidth 171045"];
3168 [label="return 'return'; 171046"];
3169 [label="FullWidth = this.Text.Length; 171047"];
3170 [label="FullWidth 171048"];
3171 [label="this.AdjustFlagsAndWidth(leading); 171049"];
3172 [label="return 'return'; 171050"];
3173 [label="FullWidth = this.Text.Length; 171051"];
3174 [label="FullWidth 171052"];
3175 [label="this.AdjustFlagsAndWidth(trailing); 171053"];
3176 [label="return 'return'; 171054"];
3177 [label="FullWidth = this.Text.Length; 171055"];
3178 [label="FullWidth 171056"];
3179 [label="this.AdjustFlagsAndWidth(trailing); 171057"];
3180 [label="return 'throw'; 171058"];
3181 [label="FullWidth = this.Text.Length; 171059"];
3182 [label="FullWidth 171060"];
3183 [label="return 'throw'; 171061"];
3184 [label="FullWidth = this.Text.Length; 171062"];
3185 [label="FullWidth 171063"];
3186 [label="this.AdjustFlagsAndWidth(leading); 171064"];
3187 [label="return 'throw'; 171065"];
3188 [label="FullWidth = this.Text.Length; 171066"];
3189 [label="FullWidth 171067"];
3190 [label="this.AdjustFlagsAndWidth(trailing); 171068"];
3191 [label="return 'throw'; 171069"];
3192 [label="FullWidth = this.Text.Length; 171070"];
3193 [label="FullWidth 171071"];
3194 [label="this.AdjustFlagsAndWidth(trailing); 171072"];
3195 [label="return 'public'; 171073"];
3196 [label="FullWidth = this.Text.Length; 171074"];
3197 [label="FullWidth 171075"];
3198 [label="return 'public'; 171076"];
3199 [label="FullWidth = this.Text.Length; 171077"];
3200 [label="FullWidth 171078"];
3201 [label="this.AdjustFlagsAndWidth(leading); 171079"];
3202 [label="return 'public'; 171080"];
3203 [label="FullWidth = this.Text.Length; 171081"];
3204 [label="FullWidth 171082"];
3205 [label="this.AdjustFlagsAndWidth(trailing); 171083"];
3206 [label="return 'public'; 171084"];
3207 [label="FullWidth = this.Text.Length; 171085"];
3208 [label="FullWidth 171086"];
3209 [label="this.AdjustFlagsAndWidth(trailing); 171087"];
3210 [label="return 'private'; 171088"];
3211 [label="FullWidth = this.Text.Length; 171089"];
3212 [label="FullWidth 171090"];
3213 [label="return 'private'; 171091"];
3214 [label="FullWidth = this.Text.Length; 171092"];
3215 [label="FullWidth 171093"];
3216 [label="this.AdjustFlagsAndWidth(leading); 171094"];
3217 [label="return 'private'; 171095"];
3218 [label="FullWidth = this.Text.Length; 171096"];
3219 [label="FullWidth 171097"];
3220 [label="this.AdjustFlagsAndWidth(trailing); 171098"];
3221 [label="return 'private'; 171099"];
3222 [label="FullWidth = this.Text.Length; 171100"];
3223 [label="FullWidth 171101"];
3224 [label="this.AdjustFlagsAndWidth(trailing); 171102"];
3225 [label="return 'internal'; 171103"];
3226 [label="FullWidth = this.Text.Length; 171104"];
3227 [label="FullWidth 171105"];
3228 [label="return 'internal'; 171106"];
3229 [label="FullWidth = this.Text.Length; 171107"];
3230 [label="FullWidth 171108"];
3231 [label="this.AdjustFlagsAndWidth(leading); 171109"];
3232 [label="return 'internal'; 171110"];
3233 [label="FullWidth = this.Text.Length; 171111"];
3234 [label="FullWidth 171112"];
3235 [label="this.AdjustFlagsAndWidth(trailing); 171113"];
3236 [label="return 'internal'; 171114"];
3237 [label="FullWidth = this.Text.Length; 171115"];
3238 [label="FullWidth 171116"];
3239 [label="this.AdjustFlagsAndWidth(trailing); 171117"];
3240 [label="return 'protected'; 171118"];
3241 [label="FullWidth = this.Text.Length; 171119"];
3242 [label="FullWidth 171120"];
3243 [label="return 'protected'; 171121"];
3244 [label="FullWidth = this.Text.Length; 171122"];
3245 [label="FullWidth 171123"];
3246 [label="this.AdjustFlagsAndWidth(leading); 171124"];
3247 [label="return 'protected'; 171125"];
3248 [label="FullWidth = this.Text.Length; 171126"];
3249 [label="FullWidth 171127"];
3250 [label="this.AdjustFlagsAndWidth(trailing); 171128"];
3251 [label="return 'protected'; 171129"];
3252 [label="FullWidth = this.Text.Length; 171130"];
3253 [label="FullWidth 171131"];
3254 [label="this.AdjustFlagsAndWidth(trailing); 171132"];
3255 [label="return 'static'; 171133"];
3256 [label="FullWidth = this.Text.Length; 171134"];
3257 [label="FullWidth 171135"];
3258 [label="return 'static'; 171136"];
3259 [label="FullWidth = this.Text.Length; 171137"];
3260 [label="FullWidth 171138"];
3261 [label="this.AdjustFlagsAndWidth(leading); 171139"];
3262 [label="return 'static'; 171140"];
3263 [label="FullWidth = this.Text.Length; 171141"];
3264 [label="FullWidth 171142"];
3265 [label="this.AdjustFlagsAndWidth(trailing); 171143"];
3266 [label="return 'static'; 171144"];
3267 [label="FullWidth = this.Text.Length; 171145"];
3268 [label="FullWidth 171146"];
3269 [label="this.AdjustFlagsAndWidth(trailing); 171147"];
3270 [label="return 'readonly'; 171148"];
3271 [label="FullWidth = this.Text.Length; 171149"];
3272 [label="FullWidth 171150"];
3273 [label="return 'readonly'; 171151"];
3274 [label="FullWidth = this.Text.Length; 171152"];
3275 [label="FullWidth 171153"];
3276 [label="this.AdjustFlagsAndWidth(leading); 171154"];
3277 [label="return 'readonly'; 171155"];
3278 [label="FullWidth = this.Text.Length; 171156"];
3279 [label="FullWidth 171157"];
3280 [label="this.AdjustFlagsAndWidth(trailing); 171158"];
3281 [label="return 'readonly'; 171159"];
3282 [label="FullWidth = this.Text.Length; 171160"];
3283 [label="FullWidth 171161"];
3284 [label="this.AdjustFlagsAndWidth(trailing); 171162"];
3285 [label="return 'sealed'; 171163"];
3286 [label="FullWidth = this.Text.Length; 171164"];
3287 [label="FullWidth 171165"];
3288 [label="return 'sealed'; 171166"];
3289 [label="FullWidth = this.Text.Length; 171167"];
3290 [label="FullWidth 171168"];
3291 [label="this.AdjustFlagsAndWidth(leading); 171169"];
3292 [label="return 'sealed'; 171170"];
3293 [label="FullWidth = this.Text.Length; 171171"];
3294 [label="FullWidth 171172"];
3295 [label="this.AdjustFlagsAndWidth(trailing); 171173"];
3296 [label="return 'sealed'; 171174"];
3297 [label="FullWidth = this.Text.Length; 171175"];
3298 [label="FullWidth 171176"];
3299 [label="this.AdjustFlagsAndWidth(trailing); 171177"];
3300 [label="return 'const'; 171178"];
3301 [label="FullWidth = this.Text.Length; 171179"];
3302 [label="FullWidth 171180"];
3303 [label="return 'const'; 171181"];
3304 [label="FullWidth = this.Text.Length; 171182"];
3305 [label="FullWidth 171183"];
3306 [label="this.AdjustFlagsAndWidth(leading); 171184"];
3307 [label="return 'const'; 171185"];
3308 [label="FullWidth = this.Text.Length; 171186"];
3309 [label="FullWidth 171187"];
3310 [label="this.AdjustFlagsAndWidth(trailing); 171188"];
3311 [label="return 'const'; 171189"];
3312 [label="FullWidth = this.Text.Length; 171190"];
3313 [label="FullWidth 171191"];
3314 [label="this.AdjustFlagsAndWidth(trailing); 171192"];
3315 [label="return 'fixed'; 171193"];
3316 [label="FullWidth = this.Text.Length; 171194"];
3317 [label="FullWidth 171195"];
3318 [label="return 'fixed'; 171196"];
3319 [label="FullWidth = this.Text.Length; 171197"];
3320 [label="FullWidth 171198"];
3321 [label="this.AdjustFlagsAndWidth(leading); 171199"];
3322 [label="return 'fixed'; 171200"];
3323 [label="FullWidth = this.Text.Length; 171201"];
3324 [label="FullWidth 171202"];
3325 [label="this.AdjustFlagsAndWidth(trailing); 171203"];
3326 [label="return 'fixed'; 171204"];
3327 [label="FullWidth = this.Text.Length; 171205"];
3328 [label="FullWidth 171206"];
3329 [label="this.AdjustFlagsAndWidth(trailing); 171207"];
3330 [label="return 'stackalloc'; 171208"];
3331 [label="FullWidth = this.Text.Length; 171209"];
3332 [label="FullWidth 171210"];
3333 [label="return 'stackalloc'; 171211"];
3334 [label="FullWidth = this.Text.Length; 171212"];
3335 [label="FullWidth 171213"];
3336 [label="this.AdjustFlagsAndWidth(leading); 171214"];
3337 [label="return 'stackalloc'; 171215"];
3338 [label="FullWidth = this.Text.Length; 171216"];
3339 [label="FullWidth 171217"];
3340 [label="this.AdjustFlagsAndWidth(trailing); 171218"];
3341 [label="return 'stackalloc'; 171219"];
3342 [label="FullWidth = this.Text.Length; 171220"];
3343 [label="FullWidth 171221"];
3344 [label="this.AdjustFlagsAndWidth(trailing); 171222"];
3345 [label="return 'volatile'; 171223"];
3346 [label="FullWidth = this.Text.Length; 171224"];
3347 [label="FullWidth 171225"];
3348 [label="return 'volatile'; 171226"];
3349 [label="FullWidth = this.Text.Length; 171227"];
3350 [label="FullWidth 171228"];
3351 [label="this.AdjustFlagsAndWidth(leading); 171229"];
3352 [label="return 'volatile'; 171230"];
3353 [label="FullWidth = this.Text.Length; 171231"];
3354 [label="FullWidth 171232"];
3355 [label="this.AdjustFlagsAndWidth(trailing); 171233"];
3356 [label="return 'volatile'; 171234"];
3357 [label="FullWidth = this.Text.Length; 171235"];
3358 [label="FullWidth 171236"];
3359 [label="this.AdjustFlagsAndWidth(trailing); 171237"];
3360 [label="return 'new'; 171238"];
3361 [label="FullWidth = this.Text.Length; 171239"];
3362 [label="FullWidth 171240"];
3363 [label="return 'new'; 171241"];
3364 [label="FullWidth = this.Text.Length; 171242"];
3365 [label="FullWidth 171243"];
3366 [label="this.AdjustFlagsAndWidth(leading); 171244"];
3367 [label="return 'new'; 171245"];
3368 [label="FullWidth = this.Text.Length; 171246"];
3369 [label="FullWidth 171247"];
3370 [label="this.AdjustFlagsAndWidth(trailing); 171248"];
3371 [label="return 'new'; 171249"];
3372 [label="FullWidth = this.Text.Length; 171250"];
3373 [label="FullWidth 171251"];
3374 [label="this.AdjustFlagsAndWidth(trailing); 171252"];
3375 [label="return 'override'; 171253"];
3376 [label="FullWidth = this.Text.Length; 171254"];
3377 [label="FullWidth 171255"];
3378 [label="return 'override'; 171256"];
3379 [label="FullWidth = this.Text.Length; 171257"];
3380 [label="FullWidth 171258"];
3381 [label="this.AdjustFlagsAndWidth(leading); 171259"];
3382 [label="return 'override'; 171260"];
3383 [label="FullWidth = this.Text.Length; 171261"];
3384 [label="FullWidth 171262"];
3385 [label="this.AdjustFlagsAndWidth(trailing); 171263"];
3386 [label="return 'override'; 171264"];
3387 [label="FullWidth = this.Text.Length; 171265"];
3388 [label="FullWidth 171266"];
3389 [label="this.AdjustFlagsAndWidth(trailing); 171267"];
3390 [label="return 'abstract'; 171268"];
3391 [label="FullWidth = this.Text.Length; 171269"];
3392 [label="FullWidth 171270"];
3393 [label="return 'abstract'; 171271"];
3394 [label="FullWidth = this.Text.Length; 171272"];
3395 [label="FullWidth 171273"];
3396 [label="this.AdjustFlagsAndWidth(leading); 171274"];
3397 [label="return 'abstract'; 171275"];
3398 [label="FullWidth = this.Text.Length; 171276"];
3399 [label="FullWidth 171277"];
3400 [label="this.AdjustFlagsAndWidth(trailing); 171278"];
3401 [label="return 'abstract'; 171279"];
3402 [label="FullWidth = this.Text.Length; 171280"];
3403 [label="FullWidth 171281"];
3404 [label="this.AdjustFlagsAndWidth(trailing); 171282"];
3405 [label="return 'virtual'; 171283"];
3406 [label="FullWidth = this.Text.Length; 171284"];
3407 [label="FullWidth 171285"];
3408 [label="return 'virtual'; 171286"];
3409 [label="FullWidth = this.Text.Length; 171287"];
3410 [label="FullWidth 171288"];
3411 [label="this.AdjustFlagsAndWidth(leading); 171289"];
3412 [label="return 'virtual'; 171290"];
3413 [label="FullWidth = this.Text.Length; 171291"];
3414 [label="FullWidth 171292"];
3415 [label="this.AdjustFlagsAndWidth(trailing); 171293"];
3416 [label="return 'virtual'; 171294"];
3417 [label="FullWidth = this.Text.Length; 171295"];
3418 [label="FullWidth 171296"];
3419 [label="this.AdjustFlagsAndWidth(trailing); 171297"];
3420 [label="return 'event'; 171298"];
3421 [label="FullWidth = this.Text.Length; 171299"];
3422 [label="FullWidth 171300"];
3423 [label="return 'event'; 171301"];
3424 [label="FullWidth = this.Text.Length; 171302"];
3425 [label="FullWidth 171303"];
3426 [label="this.AdjustFlagsAndWidth(leading); 171304"];
3427 [label="return 'event'; 171305"];
3428 [label="FullWidth = this.Text.Length; 171306"];
3429 [label="FullWidth 171307"];
3430 [label="this.AdjustFlagsAndWidth(trailing); 171308"];
3431 [label="return 'event'; 171309"];
3432 [label="FullWidth = this.Text.Length; 171310"];
3433 [label="FullWidth 171311"];
3434 [label="this.AdjustFlagsAndWidth(trailing); 171312"];
3435 [label="return 'extern'; 171313"];
3436 [label="FullWidth = this.Text.Length; 171314"];
3437 [label="FullWidth 171315"];
3438 [label="return 'extern'; 171316"];
3439 [label="FullWidth = this.Text.Length; 171317"];
3440 [label="FullWidth 171318"];
3441 [label="this.AdjustFlagsAndWidth(leading); 171319"];
3442 [label="return 'extern'; 171320"];
3443 [label="FullWidth = this.Text.Length; 171321"];
3444 [label="FullWidth 171322"];
3445 [label="this.AdjustFlagsAndWidth(trailing); 171323"];
3446 [label="return 'extern'; 171324"];
3447 [label="FullWidth = this.Text.Length; 171325"];
3448 [label="FullWidth 171326"];
3449 [label="this.AdjustFlagsAndWidth(trailing); 171327"];
3450 [label="return 'ref'; 171328"];
3451 [label="FullWidth = this.Text.Length; 171329"];
3452 [label="FullWidth 171330"];
3453 [label="return 'ref'; 171331"];
3454 [label="FullWidth = this.Text.Length; 171332"];
3455 [label="FullWidth 171333"];
3456 [label="this.AdjustFlagsAndWidth(leading); 171334"];
3457 [label="return 'ref'; 171335"];
3458 [label="FullWidth = this.Text.Length; 171336"];
3459 [label="FullWidth 171337"];
3460 [label="this.AdjustFlagsAndWidth(trailing); 171338"];
3461 [label="return 'ref'; 171339"];
3462 [label="FullWidth = this.Text.Length; 171340"];
3463 [label="FullWidth 171341"];
3464 [label="this.AdjustFlagsAndWidth(trailing); 171342"];
3465 [label="return 'out'; 171343"];
3466 [label="FullWidth = this.Text.Length; 171344"];
3467 [label="FullWidth 171345"];
3468 [label="return 'out'; 171346"];
3469 [label="FullWidth = this.Text.Length; 171347"];
3470 [label="FullWidth 171348"];
3471 [label="this.AdjustFlagsAndWidth(leading); 171349"];
3472 [label="return 'out'; 171350"];
3473 [label="FullWidth = this.Text.Length; 171351"];
3474 [label="FullWidth 171352"];
3475 [label="this.AdjustFlagsAndWidth(trailing); 171353"];
3476 [label="return 'out'; 171354"];
3477 [label="FullWidth = this.Text.Length; 171355"];
3478 [label="FullWidth 171356"];
3479 [label="this.AdjustFlagsAndWidth(trailing); 171357"];
3480 [label="return 'in'; 171358"];
3481 [label="FullWidth = this.Text.Length; 171359"];
3482 [label="FullWidth 171360"];
3483 [label="return 'in'; 171361"];
3484 [label="FullWidth = this.Text.Length; 171362"];
3485 [label="FullWidth 171363"];
3486 [label="this.AdjustFlagsAndWidth(leading); 171364"];
3487 [label="return 'in'; 171365"];
3488 [label="FullWidth = this.Text.Length; 171366"];
3489 [label="FullWidth 171367"];
3490 [label="this.AdjustFlagsAndWidth(trailing); 171368"];
3491 [label="return 'in'; 171369"];
3492 [label="FullWidth = this.Text.Length; 171370"];
3493 [label="FullWidth 171371"];
3494 [label="this.AdjustFlagsAndWidth(trailing); 171372"];
3495 [label="return 'is'; 171373"];
3496 [label="FullWidth = this.Text.Length; 171374"];
3497 [label="FullWidth 171375"];
3498 [label="return 'is'; 171376"];
3499 [label="FullWidth = this.Text.Length; 171377"];
3500 [label="FullWidth 171378"];
3501 [label="this.AdjustFlagsAndWidth(leading); 171379"];
3502 [label="return 'is'; 171380"];
3503 [label="FullWidth = this.Text.Length; 171381"];
3504 [label="FullWidth 171382"];
3505 [label="this.AdjustFlagsAndWidth(trailing); 171383"];
3506 [label="return 'is'; 171384"];
3507 [label="FullWidth = this.Text.Length; 171385"];
3508 [label="FullWidth 171386"];
3509 [label="this.AdjustFlagsAndWidth(trailing); 171387"];
3510 [label="return 'as'; 171388"];
3511 [label="FullWidth = this.Text.Length; 171389"];
3512 [label="FullWidth 171390"];
3513 [label="return 'as'; 171391"];
3514 [label="FullWidth = this.Text.Length; 171392"];
3515 [label="FullWidth 171393"];
3516 [label="this.AdjustFlagsAndWidth(leading); 171394"];
3517 [label="return 'as'; 171395"];
3518 [label="FullWidth = this.Text.Length; 171396"];
3519 [label="FullWidth 171397"];
3520 [label="this.AdjustFlagsAndWidth(trailing); 171398"];
3521 [label="return 'as'; 171399"];
3522 [label="FullWidth = this.Text.Length; 171400"];
3523 [label="FullWidth 171401"];
3524 [label="this.AdjustFlagsAndWidth(trailing); 171402"];
3525 [label="return 'params'; 171403"];
3526 [label="FullWidth = this.Text.Length; 171404"];
3527 [label="FullWidth 171405"];
3528 [label="return 'params'; 171406"];
3529 [label="FullWidth = this.Text.Length; 171407"];
3530 [label="FullWidth 171408"];
3531 [label="this.AdjustFlagsAndWidth(leading); 171409"];
3532 [label="return 'params'; 171410"];
3533 [label="FullWidth = this.Text.Length; 171411"];
3534 [label="FullWidth 171412"];
3535 [label="this.AdjustFlagsAndWidth(trailing); 171413"];
3536 [label="return 'params'; 171414"];
3537 [label="FullWidth = this.Text.Length; 171415"];
3538 [label="FullWidth 171416"];
3539 [label="this.AdjustFlagsAndWidth(trailing); 171417"];
3540 [label="return '__arglist'; 171418"];
3541 [label="FullWidth = this.Text.Length; 171419"];
3542 [label="FullWidth 171420"];
3543 [label="return '__arglist'; 171421"];
3544 [label="FullWidth = this.Text.Length; 171422"];
3545 [label="FullWidth 171423"];
3546 [label="this.AdjustFlagsAndWidth(leading); 171424"];
3547 [label="return '__arglist'; 171425"];
3548 [label="FullWidth = this.Text.Length; 171426"];
3549 [label="FullWidth 171427"];
3550 [label="this.AdjustFlagsAndWidth(trailing); 171428"];
3551 [label="return '__arglist'; 171429"];
3552 [label="FullWidth = this.Text.Length; 171430"];
3553 [label="FullWidth 171431"];
3554 [label="this.AdjustFlagsAndWidth(trailing); 171432"];
3555 [label="return '__makeref'; 171433"];
3556 [label="FullWidth = this.Text.Length; 171434"];
3557 [label="FullWidth 171435"];
3558 [label="return '__makeref'; 171436"];
3559 [label="FullWidth = this.Text.Length; 171437"];
3560 [label="FullWidth 171438"];
3561 [label="this.AdjustFlagsAndWidth(leading); 171439"];
3562 [label="return '__makeref'; 171440"];
3563 [label="FullWidth = this.Text.Length; 171441"];
3564 [label="FullWidth 171442"];
3565 [label="this.AdjustFlagsAndWidth(trailing); 171443"];
3566 [label="return '__makeref'; 171444"];
3567 [label="FullWidth = this.Text.Length; 171445"];
3568 [label="FullWidth 171446"];
3569 [label="this.AdjustFlagsAndWidth(trailing); 171447"];
3570 [label="return '__reftype'; 171448"];
3571 [label="FullWidth = this.Text.Length; 171449"];
3572 [label="FullWidth 171450"];
3573 [label="return '__reftype'; 171451"];
3574 [label="FullWidth = this.Text.Length; 171452"];
3575 [label="FullWidth 171453"];
3576 [label="this.AdjustFlagsAndWidth(leading); 171454"];
3577 [label="return '__reftype'; 171455"];
3578 [label="FullWidth = this.Text.Length; 171456"];
3579 [label="FullWidth 171457"];
3580 [label="this.AdjustFlagsAndWidth(trailing); 171458"];
3581 [label="return '__reftype'; 171459"];
3582 [label="FullWidth = this.Text.Length; 171460"];
3583 [label="FullWidth 171461"];
3584 [label="this.AdjustFlagsAndWidth(trailing); 171462"];
3585 [label="return '__refvalue'; 171463"];
3586 [label="FullWidth = this.Text.Length; 171464"];
3587 [label="FullWidth 171465"];
3588 [label="return '__refvalue'; 171466"];
3589 [label="FullWidth = this.Text.Length; 171467"];
3590 [label="FullWidth 171468"];
3591 [label="this.AdjustFlagsAndWidth(leading); 171469"];
3592 [label="return '__refvalue'; 171470"];
3593 [label="FullWidth = this.Text.Length; 171471"];
3594 [label="FullWidth 171472"];
3595 [label="this.AdjustFlagsAndWidth(trailing); 171473"];
3596 [label="return '__refvalue'; 171474"];
3597 [label="FullWidth = this.Text.Length; 171475"];
3598 [label="FullWidth 171476"];
3599 [label="this.AdjustFlagsAndWidth(trailing); 171477"];
3600 [label="return 'this'; 171478"];
3601 [label="FullWidth = this.Text.Length; 171479"];
3602 [label="FullWidth 171480"];
3603 [label="return 'this'; 171481"];
3604 [label="FullWidth = this.Text.Length; 171482"];
3605 [label="FullWidth 171483"];
3606 [label="this.AdjustFlagsAndWidth(leading); 171484"];
3607 [label="return 'this'; 171485"];
3608 [label="FullWidth = this.Text.Length; 171486"];
3609 [label="FullWidth 171487"];
3610 [label="this.AdjustFlagsAndWidth(trailing); 171488"];
3611 [label="return 'this'; 171489"];
3612 [label="FullWidth = this.Text.Length; 171490"];
3613 [label="FullWidth 171491"];
3614 [label="this.AdjustFlagsAndWidth(trailing); 171492"];
3615 [label="return 'base'; 171493"];
3616 [label="FullWidth = this.Text.Length; 171494"];
3617 [label="FullWidth 171495"];
3618 [label="return 'base'; 171496"];
3619 [label="FullWidth = this.Text.Length; 171497"];
3620 [label="FullWidth 171498"];
3621 [label="this.AdjustFlagsAndWidth(leading); 171499"];
3622 [label="return 'base'; 171500"];
3623 [label="FullWidth = this.Text.Length; 171501"];
3624 [label="FullWidth 171502"];
3625 [label="this.AdjustFlagsAndWidth(trailing); 171503"];
3626 [label="return 'base'; 171504"];
3627 [label="FullWidth = this.Text.Length; 171505"];
3628 [label="FullWidth 171506"];
3629 [label="this.AdjustFlagsAndWidth(trailing); 171507"];
3630 [label="return 'namespace'; 171508"];
3631 [label="FullWidth = this.Text.Length; 171509"];
3632 [label="FullWidth 171510"];
3633 [label="return 'namespace'; 171511"];
3634 [label="FullWidth = this.Text.Length; 171512"];
3635 [label="FullWidth 171513"];
3636 [label="this.AdjustFlagsAndWidth(leading); 171514"];
3637 [label="return 'namespace'; 171515"];
3638 [label="FullWidth = this.Text.Length; 171516"];
3639 [label="FullWidth 171517"];
3640 [label="this.AdjustFlagsAndWidth(trailing); 171518"];
3641 [label="return 'namespace'; 171519"];
3642 [label="FullWidth = this.Text.Length; 171520"];
3643 [label="FullWidth 171521"];
3644 [label="this.AdjustFlagsAndWidth(trailing); 171522"];
3645 [label="return 'using'; 171523"];
3646 [label="FullWidth = this.Text.Length; 171524"];
3647 [label="FullWidth 171525"];
3648 [label="return 'using'; 171526"];
3649 [label="FullWidth = this.Text.Length; 171527"];
3650 [label="FullWidth 171528"];
3651 [label="this.AdjustFlagsAndWidth(leading); 171529"];
3652 [label="return 'using'; 171530"];
3653 [label="FullWidth = this.Text.Length; 171531"];
3654 [label="FullWidth 171532"];
3655 [label="this.AdjustFlagsAndWidth(trailing); 171533"];
3656 [label="return 'using'; 171534"];
3657 [label="FullWidth = this.Text.Length; 171535"];
3658 [label="FullWidth 171536"];
3659 [label="this.AdjustFlagsAndWidth(trailing); 171537"];
3660 [label="return 'class'; 171538"];
3661 [label="FullWidth = this.Text.Length; 171539"];
3662 [label="FullWidth 171540"];
3663 [label="return 'class'; 171541"];
3664 [label="FullWidth = this.Text.Length; 171542"];
3665 [label="FullWidth 171543"];
3666 [label="this.AdjustFlagsAndWidth(leading); 171544"];
3667 [label="return 'class'; 171545"];
3668 [label="FullWidth = this.Text.Length; 171546"];
3669 [label="FullWidth 171547"];
3670 [label="this.AdjustFlagsAndWidth(trailing); 171548"];
3671 [label="return 'class'; 171549"];
3672 [label="FullWidth = this.Text.Length; 171550"];
3673 [label="FullWidth 171551"];
3674 [label="this.AdjustFlagsAndWidth(trailing); 171552"];
3675 [label="return 'struct'; 171553"];
3676 [label="FullWidth = this.Text.Length; 171554"];
3677 [label="FullWidth 171555"];
3678 [label="return 'struct'; 171556"];
3679 [label="FullWidth = this.Text.Length; 171557"];
3680 [label="FullWidth 171558"];
3681 [label="this.AdjustFlagsAndWidth(leading); 171559"];
3682 [label="return 'struct'; 171560"];
3683 [label="FullWidth = this.Text.Length; 171561"];
3684 [label="FullWidth 171562"];
3685 [label="this.AdjustFlagsAndWidth(trailing); 171563"];
3686 [label="return 'struct'; 171564"];
3687 [label="FullWidth = this.Text.Length; 171565"];
3688 [label="FullWidth 171566"];
3689 [label="this.AdjustFlagsAndWidth(trailing); 171567"];
3690 [label="return 'interface'; 171568"];
3691 [label="FullWidth = this.Text.Length; 171569"];
3692 [label="FullWidth 171570"];
3693 [label="return 'interface'; 171571"];
3694 [label="FullWidth = this.Text.Length; 171572"];
3695 [label="FullWidth 171573"];
3696 [label="this.AdjustFlagsAndWidth(leading); 171574"];
3697 [label="return 'interface'; 171575"];
3698 [label="FullWidth = this.Text.Length; 171576"];
3699 [label="FullWidth 171577"];
3700 [label="this.AdjustFlagsAndWidth(trailing); 171578"];
3701 [label="return 'interface'; 171579"];
3702 [label="FullWidth = this.Text.Length; 171580"];
3703 [label="FullWidth 171581"];
3704 [label="this.AdjustFlagsAndWidth(trailing); 171582"];
3705 [label="return 'enum'; 171583"];
3706 [label="FullWidth = this.Text.Length; 171584"];
3707 [label="FullWidth 171585"];
3708 [label="return 'enum'; 171586"];
3709 [label="FullWidth = this.Text.Length; 171587"];
3710 [label="FullWidth 171588"];
3711 [label="this.AdjustFlagsAndWidth(leading); 171589"];
3712 [label="return 'enum'; 171590"];
3713 [label="FullWidth = this.Text.Length; 171591"];
3714 [label="FullWidth 171592"];
3715 [label="this.AdjustFlagsAndWidth(trailing); 171593"];
3716 [label="return 'enum'; 171594"];
3717 [label="FullWidth = this.Text.Length; 171595"];
3718 [label="FullWidth 171596"];
3719 [label="this.AdjustFlagsAndWidth(trailing); 171597"];
3720 [label="return 'delegate'; 171598"];
3721 [label="FullWidth = this.Text.Length; 171599"];
3722 [label="FullWidth 171600"];
3723 [label="return 'delegate'; 171601"];
3724 [label="FullWidth = this.Text.Length; 171602"];
3725 [label="FullWidth 171603"];
3726 [label="this.AdjustFlagsAndWidth(leading); 171604"];
3727 [label="return 'delegate'; 171605"];
3728 [label="FullWidth = this.Text.Length; 171606"];
3729 [label="FullWidth 171607"];
3730 [label="this.AdjustFlagsAndWidth(trailing); 171608"];
3731 [label="return 'delegate'; 171609"];
3732 [label="FullWidth = this.Text.Length; 171610"];
3733 [label="FullWidth 171611"];
3734 [label="this.AdjustFlagsAndWidth(trailing); 171612"];
3735 [label="return 'checked'; 171613"];
3736 [label="FullWidth = this.Text.Length; 171614"];
3737 [label="FullWidth 171615"];
3738 [label="return 'checked'; 171616"];
3739 [label="FullWidth = this.Text.Length; 171617"];
3740 [label="FullWidth 171618"];
3741 [label="this.AdjustFlagsAndWidth(leading); 171619"];
3742 [label="return 'checked'; 171620"];
3743 [label="FullWidth = this.Text.Length; 171621"];
3744 [label="FullWidth 171622"];
3745 [label="this.AdjustFlagsAndWidth(trailing); 171623"];
3746 [label="return 'checked'; 171624"];
3747 [label="FullWidth = this.Text.Length; 171625"];
3748 [label="FullWidth 171626"];
3749 [label="this.AdjustFlagsAndWidth(trailing); 171627"];
3750 [label="return 'unchecked'; 171628"];
3751 [label="FullWidth = this.Text.Length; 171629"];
3752 [label="FullWidth 171630"];
3753 [label="return 'unchecked'; 171631"];
3754 [label="FullWidth = this.Text.Length; 171632"];
3755 [label="FullWidth 171633"];
3756 [label="this.AdjustFlagsAndWidth(leading); 171634"];
3757 [label="return 'unchecked'; 171635"];
3758 [label="FullWidth = this.Text.Length; 171636"];
3759 [label="FullWidth 171637"];
3760 [label="this.AdjustFlagsAndWidth(trailing); 171638"];
3761 [label="return 'unchecked'; 171639"];
3762 [label="FullWidth = this.Text.Length; 171640"];
3763 [label="FullWidth 171641"];
3764 [label="this.AdjustFlagsAndWidth(trailing); 171642"];
3765 [label="return 'unsafe'; 171643"];
3766 [label="FullWidth = this.Text.Length; 171644"];
3767 [label="FullWidth 171645"];
3768 [label="return 'unsafe'; 171646"];
3769 [label="FullWidth = this.Text.Length; 171647"];
3770 [label="FullWidth 171648"];
3771 [label="this.AdjustFlagsAndWidth(leading); 171649"];
3772 [label="return 'unsafe'; 171650"];
3773 [label="FullWidth = this.Text.Length; 171651"];
3774 [label="FullWidth 171652"];
3775 [label="this.AdjustFlagsAndWidth(trailing); 171653"];
3776 [label="return 'unsafe'; 171654"];
3777 [label="FullWidth = this.Text.Length; 171655"];
3778 [label="FullWidth 171656"];
3779 [label="this.AdjustFlagsAndWidth(trailing); 171657"];
3780 [label="return 'operator'; 171658"];
3781 [label="FullWidth = this.Text.Length; 171659"];
3782 [label="FullWidth 171660"];
3783 [label="return 'operator'; 171661"];
3784 [label="FullWidth = this.Text.Length; 171662"];
3785 [label="FullWidth 171663"];
3786 [label="this.AdjustFlagsAndWidth(leading); 171664"];
3787 [label="return 'operator'; 171665"];
3788 [label="FullWidth = this.Text.Length; 171666"];
3789 [label="FullWidth 171667"];
3790 [label="this.AdjustFlagsAndWidth(trailing); 171668"];
3791 [label="return 'operator'; 171669"];
3792 [label="FullWidth = this.Text.Length; 171670"];
3793 [label="FullWidth 171671"];
3794 [label="this.AdjustFlagsAndWidth(trailing); 171672"];
3795 [label="return 'explicit'; 171673"];
3796 [label="FullWidth = this.Text.Length; 171674"];
3797 [label="FullWidth 171675"];
3798 [label="return 'explicit'; 171676"];
3799 [label="FullWidth = this.Text.Length; 171677"];
3800 [label="FullWidth 171678"];
3801 [label="this.AdjustFlagsAndWidth(leading); 171679"];
3802 [label="return 'explicit'; 171680"];
3803 [label="FullWidth = this.Text.Length; 171681"];
3804 [label="FullWidth 171682"];
3805 [label="this.AdjustFlagsAndWidth(trailing); 171683"];
3806 [label="return 'explicit'; 171684"];
3807 [label="FullWidth = this.Text.Length; 171685"];
3808 [label="FullWidth 171686"];
3809 [label="this.AdjustFlagsAndWidth(trailing); 171687"];
3810 [label="return 'implicit'; 171688"];
3811 [label="FullWidth = this.Text.Length; 171689"];
3812 [label="FullWidth 171690"];
3813 [label="return 'implicit'; 171691"];
3814 [label="FullWidth = this.Text.Length; 171692"];
3815 [label="FullWidth 171693"];
3816 [label="this.AdjustFlagsAndWidth(leading); 171694"];
3817 [label="return 'implicit'; 171695"];
3818 [label="FullWidth = this.Text.Length; 171696"];
3819 [label="FullWidth 171697"];
3820 [label="this.AdjustFlagsAndWidth(trailing); 171698"];
3821 [label="return 'implicit'; 171699"];
3822 [label="FullWidth = this.Text.Length; 171700"];
3823 [label="FullWidth 171701"];
3824 [label="this.AdjustFlagsAndWidth(trailing); 171702"];
3825 [label="return 'yield'; 171703"];
3826 [label="FullWidth = this.Text.Length; 171704"];
3827 [label="FullWidth 171705"];
3828 [label="return 'yield'; 171706"];
3829 [label="FullWidth = this.Text.Length; 171707"];
3830 [label="FullWidth 171708"];
3831 [label="this.AdjustFlagsAndWidth(leading); 171709"];
3832 [label="return 'yield'; 171710"];
3833 [label="FullWidth = this.Text.Length; 171711"];
3834 [label="FullWidth 171712"];
3835 [label="this.AdjustFlagsAndWidth(trailing); 171713"];
3836 [label="return 'yield'; 171714"];
3837 [label="FullWidth = this.Text.Length; 171715"];
3838 [label="FullWidth 171716"];
3839 [label="this.AdjustFlagsAndWidth(trailing); 171717"];
3840 [label="return 'partial'; 171718"];
3841 [label="FullWidth = this.Text.Length; 171719"];
3842 [label="FullWidth 171720"];
3843 [label="return 'partial'; 171721"];
3844 [label="FullWidth = this.Text.Length; 171722"];
3845 [label="FullWidth 171723"];
3846 [label="this.AdjustFlagsAndWidth(leading); 171724"];
3847 [label="return 'partial'; 171725"];
3848 [label="FullWidth = this.Text.Length; 171726"];
3849 [label="FullWidth 171727"];
3850 [label="this.AdjustFlagsAndWidth(trailing); 171728"];
3851 [label="return 'partial'; 171729"];
3852 [label="FullWidth = this.Text.Length; 171730"];
3853 [label="FullWidth 171731"];
3854 [label="this.AdjustFlagsAndWidth(trailing); 171732"];
3855 [label="return 'alias'; 171733"];
3856 [label="FullWidth = this.Text.Length; 171734"];
3857 [label="FullWidth 171735"];
3858 [label="return 'alias'; 171736"];
3859 [label="FullWidth = this.Text.Length; 171737"];
3860 [label="FullWidth 171738"];
3861 [label="this.AdjustFlagsAndWidth(leading); 171739"];
3862 [label="return 'alias'; 171740"];
3863 [label="FullWidth = this.Text.Length; 171741"];
3864 [label="FullWidth 171742"];
3865 [label="this.AdjustFlagsAndWidth(trailing); 171743"];
3866 [label="return 'alias'; 171744"];
3867 [label="FullWidth = this.Text.Length; 171745"];
3868 [label="FullWidth 171746"];
3869 [label="this.AdjustFlagsAndWidth(trailing); 171747"];
3870 [label="return 'global'; 171748"];
3871 [label="FullWidth = this.Text.Length; 171749"];
3872 [label="FullWidth 171750"];
3873 [label="return 'global'; 171751"];
3874 [label="FullWidth = this.Text.Length; 171752"];
3875 [label="FullWidth 171753"];
3876 [label="this.AdjustFlagsAndWidth(leading); 171754"];
3877 [label="return 'global'; 171755"];
3878 [label="FullWidth = this.Text.Length; 171756"];
3879 [label="FullWidth 171757"];
3880 [label="this.AdjustFlagsAndWidth(trailing); 171758"];
3881 [label="return 'global'; 171759"];
3882 [label="FullWidth = this.Text.Length; 171760"];
3883 [label="FullWidth 171761"];
3884 [label="this.AdjustFlagsAndWidth(trailing); 171762"];
3885 [label="return 'assembly'; 171763"];
3886 [label="FullWidth = this.Text.Length; 171764"];
3887 [label="FullWidth 171765"];
3888 [label="return 'assembly'; 171766"];
3889 [label="FullWidth = this.Text.Length; 171767"];
3890 [label="FullWidth 171768"];
3891 [label="this.AdjustFlagsAndWidth(leading); 171769"];
3892 [label="return 'assembly'; 171770"];
3893 [label="FullWidth = this.Text.Length; 171771"];
3894 [label="FullWidth 171772"];
3895 [label="this.AdjustFlagsAndWidth(trailing); 171773"];
3896 [label="return 'assembly'; 171774"];
3897 [label="FullWidth = this.Text.Length; 171775"];
3898 [label="FullWidth 171776"];
3899 [label="this.AdjustFlagsAndWidth(trailing); 171777"];
3900 [label="return 'module'; 171778"];
3901 [label="FullWidth = this.Text.Length; 171779"];
3902 [label="FullWidth 171780"];
3903 [label="return 'module'; 171781"];
3904 [label="FullWidth = this.Text.Length; 171782"];
3905 [label="FullWidth 171783"];
3906 [label="this.AdjustFlagsAndWidth(leading); 171784"];
3907 [label="return 'module'; 171785"];
3908 [label="FullWidth = this.Text.Length; 171786"];
3909 [label="FullWidth 171787"];
3910 [label="this.AdjustFlagsAndWidth(trailing); 171788"];
3911 [label="return 'module'; 171789"];
3912 [label="FullWidth = this.Text.Length; 171790"];
3913 [label="FullWidth 171791"];
3914 [label="this.AdjustFlagsAndWidth(trailing); 171792"];
3915 [label="return 'type'; 171793"];
3916 [label="FullWidth = this.Text.Length; 171794"];
3917 [label="FullWidth 171795"];
3918 [label="return 'type'; 171796"];
3919 [label="FullWidth = this.Text.Length; 171797"];
3920 [label="FullWidth 171798"];
3921 [label="this.AdjustFlagsAndWidth(leading); 171799"];
3922 [label="return 'type'; 171800"];
3923 [label="FullWidth = this.Text.Length; 171801"];
3924 [label="FullWidth 171802"];
3925 [label="this.AdjustFlagsAndWidth(trailing); 171803"];
3926 [label="return 'type'; 171804"];
3927 [label="FullWidth = this.Text.Length; 171805"];
3928 [label="FullWidth 171806"];
3929 [label="this.AdjustFlagsAndWidth(trailing); 171807"];
3930 [label="return 'field'; 171808"];
3931 [label="FullWidth = this.Text.Length; 171809"];
3932 [label="FullWidth 171810"];
3933 [label="return 'field'; 171811"];
3934 [label="FullWidth = this.Text.Length; 171812"];
3935 [label="FullWidth 171813"];
3936 [label="this.AdjustFlagsAndWidth(leading); 171814"];
3937 [label="return 'field'; 171815"];
3938 [label="FullWidth = this.Text.Length; 171816"];
3939 [label="FullWidth 171817"];
3940 [label="this.AdjustFlagsAndWidth(trailing); 171818"];
3941 [label="return 'field'; 171819"];
3942 [label="FullWidth = this.Text.Length; 171820"];
3943 [label="FullWidth 171821"];
3944 [label="this.AdjustFlagsAndWidth(trailing); 171822"];
3945 [label="return 'method'; 171823"];
3946 [label="FullWidth = this.Text.Length; 171824"];
3947 [label="FullWidth 171825"];
3948 [label="return 'method'; 171826"];
3949 [label="FullWidth = this.Text.Length; 171827"];
3950 [label="FullWidth 171828"];
3951 [label="this.AdjustFlagsAndWidth(leading); 171829"];
3952 [label="return 'method'; 171830"];
3953 [label="FullWidth = this.Text.Length; 171831"];
3954 [label="FullWidth 171832"];
3955 [label="this.AdjustFlagsAndWidth(trailing); 171833"];
3956 [label="return 'method'; 171834"];
3957 [label="FullWidth = this.Text.Length; 171835"];
3958 [label="FullWidth 171836"];
3959 [label="this.AdjustFlagsAndWidth(trailing); 171837"];
3960 [label="return 'param'; 171838"];
3961 [label="FullWidth = this.Text.Length; 171839"];
3962 [label="FullWidth 171840"];
3963 [label="return 'param'; 171841"];
3964 [label="FullWidth = this.Text.Length; 171842"];
3965 [label="FullWidth 171843"];
3966 [label="this.AdjustFlagsAndWidth(leading); 171844"];
3967 [label="return 'param'; 171845"];
3968 [label="FullWidth = this.Text.Length; 171846"];
3969 [label="FullWidth 171847"];
3970 [label="this.AdjustFlagsAndWidth(trailing); 171848"];
3971 [label="return 'param'; 171849"];
3972 [label="FullWidth = this.Text.Length; 171850"];
3973 [label="FullWidth 171851"];
3974 [label="this.AdjustFlagsAndWidth(trailing); 171852"];
3975 [label="return 'property'; 171853"];
3976 [label="FullWidth = this.Text.Length; 171854"];
3977 [label="FullWidth 171855"];
3978 [label="return 'property'; 171856"];
3979 [label="FullWidth = this.Text.Length; 171857"];
3980 [label="FullWidth 171858"];
3981 [label="this.AdjustFlagsAndWidth(leading); 171859"];
3982 [label="return 'property'; 171860"];
3983 [label="FullWidth = this.Text.Length; 171861"];
3984 [label="FullWidth 171862"];
3985 [label="this.AdjustFlagsAndWidth(trailing); 171863"];
3986 [label="return 'property'; 171864"];
3987 [label="FullWidth = this.Text.Length; 171865"];
3988 [label="FullWidth 171866"];
3989 [label="this.AdjustFlagsAndWidth(trailing); 171867"];
3990 [label="return 'typevar'; 171868"];
3991 [label="FullWidth = this.Text.Length; 171869"];
3992 [label="FullWidth 171870"];
3993 [label="return 'typevar'; 171871"];
3994 [label="FullWidth = this.Text.Length; 171872"];
3995 [label="FullWidth 171873"];
3996 [label="this.AdjustFlagsAndWidth(leading); 171874"];
3997 [label="return 'typevar'; 171875"];
3998 [label="FullWidth = this.Text.Length; 171876"];
3999 [label="FullWidth 171877"];
4000 [label="this.AdjustFlagsAndWidth(trailing); 171878"];
4001 [label="return 'typevar'; 171879"];
4002 [label="FullWidth = this.Text.Length; 171880"];
4003 [label="FullWidth 171881"];
4004 [label="this.AdjustFlagsAndWidth(trailing); 171882"];
4005 [label="return 'get'; 171883"];
4006 [label="FullWidth = this.Text.Length; 171884"];
4007 [label="FullWidth 171885"];
4008 [label="return 'get'; 171886"];
4009 [label="FullWidth = this.Text.Length; 171887"];
4010 [label="FullWidth 171888"];
4011 [label="this.AdjustFlagsAndWidth(leading); 171889"];
4012 [label="return 'get'; 171890"];
4013 [label="FullWidth = this.Text.Length; 171891"];
4014 [label="FullWidth 171892"];
4015 [label="this.AdjustFlagsAndWidth(trailing); 171893"];
4016 [label="return 'get'; 171894"];
4017 [label="FullWidth = this.Text.Length; 171895"];
4018 [label="FullWidth 171896"];
4019 [label="this.AdjustFlagsAndWidth(trailing); 171897"];
4020 [label="return 'set'; 171898"];
4021 [label="FullWidth = this.Text.Length; 171899"];
4022 [label="FullWidth 171900"];
4023 [label="return 'set'; 171901"];
4024 [label="FullWidth = this.Text.Length; 171902"];
4025 [label="FullWidth 171903"];
4026 [label="this.AdjustFlagsAndWidth(leading); 171904"];
4027 [label="return 'set'; 171905"];
4028 [label="FullWidth = this.Text.Length; 171906"];
4029 [label="FullWidth 171907"];
4030 [label="this.AdjustFlagsAndWidth(trailing); 171908"];
4031 [label="return 'set'; 171909"];
4032 [label="FullWidth = this.Text.Length; 171910"];
4033 [label="FullWidth 171911"];
4034 [label="this.AdjustFlagsAndWidth(trailing); 171912"];
4035 [label="return 'add'; 171913"];
4036 [label="FullWidth = this.Text.Length; 171914"];
4037 [label="FullWidth 171915"];
4038 [label="return 'add'; 171916"];
4039 [label="FullWidth = this.Text.Length; 171917"];
4040 [label="FullWidth 171918"];
4041 [label="this.AdjustFlagsAndWidth(leading); 171919"];
4042 [label="return 'add'; 171920"];
4043 [label="FullWidth = this.Text.Length; 171921"];
4044 [label="FullWidth 171922"];
4045 [label="this.AdjustFlagsAndWidth(trailing); 171923"];
4046 [label="return 'add'; 171924"];
4047 [label="FullWidth = this.Text.Length; 171925"];
4048 [label="FullWidth 171926"];
4049 [label="this.AdjustFlagsAndWidth(trailing); 171927"];
4050 [label="return 'remove'; 171928"];
4051 [label="FullWidth = this.Text.Length; 171929"];
4052 [label="FullWidth 171930"];
4053 [label="return 'remove'; 171931"];
4054 [label="FullWidth = this.Text.Length; 171932"];
4055 [label="FullWidth 171933"];
4056 [label="this.AdjustFlagsAndWidth(leading); 171934"];
4057 [label="return 'remove'; 171935"];
4058 [label="FullWidth = this.Text.Length; 171936"];
4059 [label="FullWidth 171937"];
4060 [label="this.AdjustFlagsAndWidth(trailing); 171938"];
4061 [label="return 'remove'; 171939"];
4062 [label="FullWidth = this.Text.Length; 171940"];
4063 [label="FullWidth 171941"];
4064 [label="this.AdjustFlagsAndWidth(trailing); 171942"];
4065 [label="return 'where'; 171943"];
4066 [label="FullWidth = this.Text.Length; 171944"];
4067 [label="FullWidth 171945"];
4068 [label="return 'where'; 171946"];
4069 [label="FullWidth = this.Text.Length; 171947"];
4070 [label="FullWidth 171948"];
4071 [label="this.AdjustFlagsAndWidth(leading); 171949"];
4072 [label="return 'where'; 171950"];
4073 [label="FullWidth = this.Text.Length; 171951"];
4074 [label="FullWidth 171952"];
4075 [label="this.AdjustFlagsAndWidth(trailing); 171953"];
4076 [label="return 'where'; 171954"];
4077 [label="FullWidth = this.Text.Length; 171955"];
4078 [label="FullWidth 171956"];
4079 [label="this.AdjustFlagsAndWidth(trailing); 171957"];
4080 [label="return 'from'; 171958"];
4081 [label="FullWidth = this.Text.Length; 171959"];
4082 [label="FullWidth 171960"];
4083 [label="return 'from'; 171961"];
4084 [label="FullWidth = this.Text.Length; 171962"];
4085 [label="FullWidth 171963"];
4086 [label="this.AdjustFlagsAndWidth(leading); 171964"];
4087 [label="return 'from'; 171965"];
4088 [label="FullWidth = this.Text.Length; 171966"];
4089 [label="FullWidth 171967"];
4090 [label="this.AdjustFlagsAndWidth(trailing); 171968"];
4091 [label="return 'from'; 171969"];
4092 [label="FullWidth = this.Text.Length; 171970"];
4093 [label="FullWidth 171971"];
4094 [label="this.AdjustFlagsAndWidth(trailing); 171972"];
4095 [label="return 'group'; 171973"];
4096 [label="FullWidth = this.Text.Length; 171974"];
4097 [label="FullWidth 171975"];
4098 [label="return 'group'; 171976"];
4099 [label="FullWidth = this.Text.Length; 171977"];
4100 [label="FullWidth 171978"];
4101 [label="this.AdjustFlagsAndWidth(leading); 171979"];
4102 [label="return 'group'; 171980"];
4103 [label="FullWidth = this.Text.Length; 171981"];
4104 [label="FullWidth 171982"];
4105 [label="this.AdjustFlagsAndWidth(trailing); 171983"];
4106 [label="return 'group'; 171984"];
4107 [label="FullWidth = this.Text.Length; 171985"];
4108 [label="FullWidth 171986"];
4109 [label="this.AdjustFlagsAndWidth(trailing); 171987"];
4110 [label="return 'join'; 171988"];
4111 [label="FullWidth = this.Text.Length; 171989"];
4112 [label="FullWidth 171990"];
4113 [label="return 'join'; 171991"];
4114 [label="FullWidth = this.Text.Length; 171992"];
4115 [label="FullWidth 171993"];
4116 [label="this.AdjustFlagsAndWidth(leading); 171994"];
4117 [label="return 'join'; 171995"];
4118 [label="FullWidth = this.Text.Length; 171996"];
4119 [label="FullWidth 171997"];
4120 [label="this.AdjustFlagsAndWidth(trailing); 171998"];
4121 [label="return 'join'; 171999"];
4122 [label="FullWidth = this.Text.Length; 172000"];
4123 [label="FullWidth 172001"];
4124 [label="this.AdjustFlagsAndWidth(trailing); 172002"];
4125 [label="return 'into'; 172003"];
4126 [label="FullWidth = this.Text.Length; 172004"];
4127 [label="FullWidth 172005"];
4128 [label="return 'into'; 172006"];
4129 [label="FullWidth = this.Text.Length; 172007"];
4130 [label="FullWidth 172008"];
4131 [label="this.AdjustFlagsAndWidth(leading); 172009"];
4132 [label="return 'into'; 172010"];
4133 [label="FullWidth = this.Text.Length; 172011"];
4134 [label="FullWidth 172012"];
4135 [label="this.AdjustFlagsAndWidth(trailing); 172013"];
4136 [label="return 'into'; 172014"];
4137 [label="FullWidth = this.Text.Length; 172015"];
4138 [label="FullWidth 172016"];
4139 [label="this.AdjustFlagsAndWidth(trailing); 172017"];
4140 [label="return 'let'; 172018"];
4141 [label="FullWidth = this.Text.Length; 172019"];
4142 [label="FullWidth 172020"];
4143 [label="return 'let'; 172021"];
4144 [label="FullWidth = this.Text.Length; 172022"];
4145 [label="FullWidth 172023"];
4146 [label="this.AdjustFlagsAndWidth(leading); 172024"];
4147 [label="return 'let'; 172025"];
4148 [label="FullWidth = this.Text.Length; 172026"];
4149 [label="FullWidth 172027"];
4150 [label="this.AdjustFlagsAndWidth(trailing); 172028"];
4151 [label="return 'let'; 172029"];
4152 [label="FullWidth = this.Text.Length; 172030"];
4153 [label="FullWidth 172031"];
4154 [label="this.AdjustFlagsAndWidth(trailing); 172032"];
4155 [label="return 'by'; 172033"];
4156 [label="FullWidth = this.Text.Length; 172034"];
4157 [label="FullWidth 172035"];
4158 [label="return 'by'; 172036"];
4159 [label="FullWidth = this.Text.Length; 172037"];
4160 [label="FullWidth 172038"];
4161 [label="this.AdjustFlagsAndWidth(leading); 172039"];
4162 [label="return 'by'; 172040"];
4163 [label="FullWidth = this.Text.Length; 172041"];
4164 [label="FullWidth 172042"];
4165 [label="this.AdjustFlagsAndWidth(trailing); 172043"];
4166 [label="return 'by'; 172044"];
4167 [label="FullWidth = this.Text.Length; 172045"];
4168 [label="FullWidth 172046"];
4169 [label="this.AdjustFlagsAndWidth(trailing); 172047"];
4170 [label="return 'select'; 172048"];
4171 [label="FullWidth = this.Text.Length; 172049"];
4172 [label="FullWidth 172050"];
4173 [label="return 'select'; 172051"];
4174 [label="FullWidth = this.Text.Length; 172052"];
4175 [label="FullWidth 172053"];
4176 [label="this.AdjustFlagsAndWidth(leading); 172054"];
4177 [label="return 'select'; 172055"];
4178 [label="FullWidth = this.Text.Length; 172056"];
4179 [label="FullWidth 172057"];
4180 [label="this.AdjustFlagsAndWidth(trailing); 172058"];
4181 [label="return 'select'; 172059"];
4182 [label="FullWidth = this.Text.Length; 172060"];
4183 [label="FullWidth 172061"];
4184 [label="this.AdjustFlagsAndWidth(trailing); 172062"];
4185 [label="return 'orderby'; 172063"];
4186 [label="FullWidth = this.Text.Length; 172064"];
4187 [label="FullWidth 172065"];
4188 [label="return 'orderby'; 172066"];
4189 [label="FullWidth = this.Text.Length; 172067"];
4190 [label="FullWidth 172068"];
4191 [label="this.AdjustFlagsAndWidth(leading); 172069"];
4192 [label="return 'orderby'; 172070"];
4193 [label="FullWidth = this.Text.Length; 172071"];
4194 [label="FullWidth 172072"];
4195 [label="this.AdjustFlagsAndWidth(trailing); 172073"];
4196 [label="return 'orderby'; 172074"];
4197 [label="FullWidth = this.Text.Length; 172075"];
4198 [label="FullWidth 172076"];
4199 [label="this.AdjustFlagsAndWidth(trailing); 172077"];
4200 [label="return 'on'; 172078"];
4201 [label="FullWidth = this.Text.Length; 172079"];
4202 [label="FullWidth 172080"];
4203 [label="return 'on'; 172081"];
4204 [label="FullWidth = this.Text.Length; 172082"];
4205 [label="FullWidth 172083"];
4206 [label="this.AdjustFlagsAndWidth(leading); 172084"];
4207 [label="return 'on'; 172085"];
4208 [label="FullWidth = this.Text.Length; 172086"];
4209 [label="FullWidth 172087"];
4210 [label="this.AdjustFlagsAndWidth(trailing); 172088"];
4211 [label="return 'on'; 172089"];
4212 [label="FullWidth = this.Text.Length; 172090"];
4213 [label="FullWidth 172091"];
4214 [label="this.AdjustFlagsAndWidth(trailing); 172092"];
4215 [label="return 'equals'; 172093"];
4216 [label="FullWidth = this.Text.Length; 172094"];
4217 [label="FullWidth 172095"];
4218 [label="return 'equals'; 172096"];
4219 [label="FullWidth = this.Text.Length; 172097"];
4220 [label="FullWidth 172098"];
4221 [label="this.AdjustFlagsAndWidth(leading); 172099"];
4222 [label="return 'equals'; 172100"];
4223 [label="FullWidth = this.Text.Length; 172101"];
4224 [label="FullWidth 172102"];
4225 [label="this.AdjustFlagsAndWidth(trailing); 172103"];
4226 [label="return 'equals'; 172104"];
4227 [label="FullWidth = this.Text.Length; 172105"];
4228 [label="FullWidth 172106"];
4229 [label="this.AdjustFlagsAndWidth(trailing); 172107"];
4230 [label="return 'ascending'; 172108"];
4231 [label="FullWidth = this.Text.Length; 172109"];
4232 [label="FullWidth 172110"];
4233 [label="return 'ascending'; 172111"];
4234 [label="FullWidth = this.Text.Length; 172112"];
4235 [label="FullWidth 172113"];
4236 [label="this.AdjustFlagsAndWidth(leading); 172114"];
4237 [label="return 'ascending'; 172115"];
4238 [label="FullWidth = this.Text.Length; 172116"];
4239 [label="FullWidth 172117"];
4240 [label="this.AdjustFlagsAndWidth(trailing); 172118"];
4241 [label="return 'ascending'; 172119"];
4242 [label="FullWidth = this.Text.Length; 172120"];
4243 [label="FullWidth 172121"];
4244 [label="this.AdjustFlagsAndWidth(trailing); 172122"];
4245 [label="return 'descending'; 172123"];
4246 [label="FullWidth = this.Text.Length; 172124"];
4247 [label="FullWidth 172125"];
4248 [label="return 'descending'; 172126"];
4249 [label="FullWidth = this.Text.Length; 172127"];
4250 [label="FullWidth 172128"];
4251 [label="this.AdjustFlagsAndWidth(leading); 172129"];
4252 [label="return 'descending'; 172130"];
4253 [label="FullWidth = this.Text.Length; 172131"];
4254 [label="FullWidth 172132"];
4255 [label="this.AdjustFlagsAndWidth(trailing); 172133"];
4256 [label="return 'descending'; 172134"];
4257 [label="FullWidth = this.Text.Length; 172135"];
4258 [label="FullWidth 172136"];
4259 [label="this.AdjustFlagsAndWidth(trailing); 172137"];
4260 [label="return 'nameof'; 172138"];
4261 [label="FullWidth = this.Text.Length; 172139"];
4262 [label="FullWidth 172140"];
4263 [label="return 'nameof'; 172141"];
4264 [label="FullWidth = this.Text.Length; 172142"];
4265 [label="FullWidth 172143"];
4266 [label="this.AdjustFlagsAndWidth(leading); 172144"];
4267 [label="return 'nameof'; 172145"];
4268 [label="FullWidth = this.Text.Length; 172146"];
4269 [label="FullWidth 172147"];
4270 [label="this.AdjustFlagsAndWidth(trailing); 172148"];
4271 [label="return 'nameof'; 172149"];
4272 [label="FullWidth = this.Text.Length; 172150"];
4273 [label="FullWidth 172151"];
4274 [label="this.AdjustFlagsAndWidth(trailing); 172152"];
4275 [label="return 'async'; 172153"];
4276 [label="FullWidth = this.Text.Length; 172154"];
4277 [label="FullWidth 172155"];
4278 [label="return 'async'; 172156"];
4279 [label="FullWidth = this.Text.Length; 172157"];
4280 [label="FullWidth 172158"];
4281 [label="this.AdjustFlagsAndWidth(leading); 172159"];
4282 [label="return 'async'; 172160"];
4283 [label="FullWidth = this.Text.Length; 172161"];
4284 [label="FullWidth 172162"];
4285 [label="this.AdjustFlagsAndWidth(trailing); 172163"];
4286 [label="return 'async'; 172164"];
4287 [label="FullWidth = this.Text.Length; 172165"];
4288 [label="FullWidth 172166"];
4289 [label="this.AdjustFlagsAndWidth(trailing); 172167"];
4290 [label="return 'await'; 172168"];
4291 [label="FullWidth = this.Text.Length; 172169"];
4292 [label="FullWidth 172170"];
4293 [label="return 'await'; 172171"];
4294 [label="FullWidth = this.Text.Length; 172172"];
4295 [label="FullWidth 172173"];
4296 [label="this.AdjustFlagsAndWidth(leading); 172174"];
4297 [label="return 'await'; 172175"];
4298 [label="FullWidth = this.Text.Length; 172176"];
4299 [label="FullWidth 172177"];
4300 [label="this.AdjustFlagsAndWidth(trailing); 172178"];
4301 [label="return 'await'; 172179"];
4302 [label="FullWidth = this.Text.Length; 172180"];
4303 [label="FullWidth 172181"];
4304 [label="this.AdjustFlagsAndWidth(trailing); 172182"];
4305 [label="return 'when'; 172183"];
4306 [label="FullWidth = this.Text.Length; 172184"];
4307 [label="FullWidth 172185"];
4308 [label="return 'when'; 172186"];
4309 [label="FullWidth = this.Text.Length; 172187"];
4310 [label="FullWidth 172188"];
4311 [label="this.AdjustFlagsAndWidth(leading); 172189"];
4312 [label="return 'when'; 172190"];
4313 [label="FullWidth = this.Text.Length; 172191"];
4314 [label="FullWidth 172192"];
4315 [label="this.AdjustFlagsAndWidth(trailing); 172193"];
4316 [label="return 'when'; 172194"];
4317 [label="FullWidth = this.Text.Length; 172195"];
4318 [label="FullWidth 172196"];
4319 [label="this.AdjustFlagsAndWidth(trailing); 172197"];
4320 [label="return 'or'; 172198"];
4321 [label="FullWidth = this.Text.Length; 172199"];
4322 [label="FullWidth 172200"];
4323 [label="return 'or'; 172201"];
4324 [label="FullWidth = this.Text.Length; 172202"];
4325 [label="FullWidth 172203"];
4326 [label="this.AdjustFlagsAndWidth(leading); 172204"];
4327 [label="return 'or'; 172205"];
4328 [label="FullWidth = this.Text.Length; 172206"];
4329 [label="FullWidth 172207"];
4330 [label="this.AdjustFlagsAndWidth(trailing); 172208"];
4331 [label="return 'or'; 172209"];
4332 [label="FullWidth = this.Text.Length; 172210"];
4333 [label="FullWidth 172211"];
4334 [label="this.AdjustFlagsAndWidth(trailing); 172212"];
4335 [label="return 'and'; 172213"];
4336 [label="FullWidth = this.Text.Length; 172214"];
4337 [label="FullWidth 172215"];
4338 [label="return 'and'; 172216"];
4339 [label="FullWidth = this.Text.Length; 172217"];
4340 [label="FullWidth 172218"];
4341 [label="this.AdjustFlagsAndWidth(leading); 172219"];
4342 [label="return 'and'; 172220"];
4343 [label="FullWidth = this.Text.Length; 172221"];
4344 [label="FullWidth 172222"];
4345 [label="this.AdjustFlagsAndWidth(trailing); 172223"];
4346 [label="return 'and'; 172224"];
4347 [label="FullWidth = this.Text.Length; 172225"];
4348 [label="FullWidth 172226"];
4349 [label="this.AdjustFlagsAndWidth(trailing); 172227"];
4350 [label="return 'not'; 172228"];
4351 [label="FullWidth = this.Text.Length; 172229"];
4352 [label="FullWidth 172230"];
4353 [label="return 'not'; 172231"];
4354 [label="FullWidth = this.Text.Length; 172232"];
4355 [label="FullWidth 172233"];
4356 [label="this.AdjustFlagsAndWidth(leading); 172234"];
4357 [label="return 'not'; 172235"];
4358 [label="FullWidth = this.Text.Length; 172236"];
4359 [label="FullWidth 172237"];
4360 [label="this.AdjustFlagsAndWidth(trailing); 172238"];
4361 [label="return 'not'; 172239"];
4362 [label="FullWidth = this.Text.Length; 172240"];
4363 [label="FullWidth 172241"];
4364 [label="this.AdjustFlagsAndWidth(trailing); 172242"];
4365 [label="return 'data'; 172243"];
4366 [label="FullWidth = this.Text.Length; 172244"];
4367 [label="FullWidth 172245"];
4368 [label="return 'data'; 172246"];
4369 [label="FullWidth = this.Text.Length; 172247"];
4370 [label="FullWidth 172248"];
4371 [label="this.AdjustFlagsAndWidth(leading); 172249"];
4372 [label="return 'data'; 172250"];
4373 [label="FullWidth = this.Text.Length; 172251"];
4374 [label="FullWidth 172252"];
4375 [label="this.AdjustFlagsAndWidth(trailing); 172253"];
4376 [label="return 'data'; 172254"];
4377 [label="FullWidth = this.Text.Length; 172255"];
4378 [label="FullWidth 172256"];
4379 [label="this.AdjustFlagsAndWidth(trailing); 172257"];
4380 [label="return 'with'; 172258"];
4381 [label="FullWidth = this.Text.Length; 172259"];
4382 [label="FullWidth 172260"];
4383 [label="return 'with'; 172261"];
4384 [label="FullWidth = this.Text.Length; 172262"];
4385 [label="FullWidth 172263"];
4386 [label="this.AdjustFlagsAndWidth(leading); 172264"];
4387 [label="return 'with'; 172265"];
4388 [label="FullWidth = this.Text.Length; 172266"];
4389 [label="FullWidth 172267"];
4390 [label="this.AdjustFlagsAndWidth(trailing); 172268"];
4391 [label="return 'with'; 172269"];
4392 [label="FullWidth = this.Text.Length; 172270"];
4393 [label="FullWidth 172271"];
4394 [label="this.AdjustFlagsAndWidth(trailing); 172272"];
4395 [label="return 'init'; 172273"];
4396 [label="FullWidth = this.Text.Length; 172274"];
4397 [label="FullWidth 172275"];
4398 [label="return 'init'; 172276"];
4399 [label="FullWidth = this.Text.Length; 172277"];
4400 [label="FullWidth 172278"];
4401 [label="this.AdjustFlagsAndWidth(leading); 172279"];
4402 [label="return 'init'; 172280"];
4403 [label="FullWidth = this.Text.Length; 172281"];
4404 [label="FullWidth 172282"];
4405 [label="this.AdjustFlagsAndWidth(trailing); 172283"];
4406 [label="return 'init'; 172284"];
4407 [label="FullWidth = this.Text.Length; 172285"];
4408 [label="FullWidth 172286"];
4409 [label="this.AdjustFlagsAndWidth(trailing); 172287"];
4410 [label="return 'record'; 172288"];
4411 [label="FullWidth = this.Text.Length; 172289"];
4412 [label="FullWidth 172290"];
4413 [label="return 'record'; 172291"];
4414 [label="FullWidth = this.Text.Length; 172292"];
4415 [label="FullWidth 172293"];
4416 [label="this.AdjustFlagsAndWidth(leading); 172294"];
4417 [label="return 'record'; 172295"];
4418 [label="FullWidth = this.Text.Length; 172296"];
4419 [label="FullWidth 172297"];
4420 [label="this.AdjustFlagsAndWidth(trailing); 172298"];
4421 [label="return 'record'; 172299"];
4422 [label="FullWidth = this.Text.Length; 172300"];
4423 [label="FullWidth 172301"];
4424 [label="this.AdjustFlagsAndWidth(trailing); 172302"];
4425 [label="return 'managed'; 172303"];
4426 [label="FullWidth = this.Text.Length; 172304"];
4427 [label="FullWidth 172305"];
4428 [label="return 'managed'; 172306"];
4429 [label="FullWidth = this.Text.Length; 172307"];
4430 [label="FullWidth 172308"];
4431 [label="this.AdjustFlagsAndWidth(leading); 172309"];
4432 [label="return 'managed'; 172310"];
4433 [label="FullWidth = this.Text.Length; 172311"];
4434 [label="FullWidth 172312"];
4435 [label="this.AdjustFlagsAndWidth(trailing); 172313"];
4436 [label="return 'managed'; 172314"];
4437 [label="FullWidth = this.Text.Length; 172315"];
4438 [label="FullWidth 172316"];
4439 [label="this.AdjustFlagsAndWidth(trailing); 172317"];
4440 [label="return 'unmanaged'; 172318"];
4441 [label="FullWidth = this.Text.Length; 172319"];
4442 [label="FullWidth 172320"];
4443 [label="return 'unmanaged'; 172321"];
4444 [label="FullWidth = this.Text.Length; 172322"];
4445 [label="FullWidth 172323"];
4446 [label="this.AdjustFlagsAndWidth(leading); 172324"];
4447 [label="return 'unmanaged'; 172325"];
4448 [label="FullWidth = this.Text.Length; 172326"];
4449 [label="FullWidth 172327"];
4450 [label="this.AdjustFlagsAndWidth(trailing); 172328"];
4451 [label="return 'unmanaged'; 172329"];
4452 [label="FullWidth = this.Text.Length; 172330"];
4453 [label="FullWidth 172331"];
4454 [label="this.AdjustFlagsAndWidth(trailing); 172332"];
4455 [label="return 'elif'; 172333"];
4456 [label="FullWidth = this.Text.Length; 172334"];
4457 [label="FullWidth 172335"];
4458 [label="return 'elif'; 172336"];
4459 [label="FullWidth = this.Text.Length; 172337"];
4460 [label="FullWidth 172338"];
4461 [label="this.AdjustFlagsAndWidth(leading); 172339"];
4462 [label="return 'elif'; 172340"];
4463 [label="FullWidth = this.Text.Length; 172341"];
4464 [label="FullWidth 172342"];
4465 [label="this.AdjustFlagsAndWidth(trailing); 172343"];
4466 [label="return 'elif'; 172344"];
4467 [label="FullWidth = this.Text.Length; 172345"];
4468 [label="FullWidth 172346"];
4469 [label="this.AdjustFlagsAndWidth(trailing); 172347"];
4470 [label="return 'endif'; 172348"];
4471 [label="FullWidth = this.Text.Length; 172349"];
4472 [label="FullWidth 172350"];
4473 [label="return 'endif'; 172351"];
4474 [label="FullWidth = this.Text.Length; 172352"];
4475 [label="FullWidth 172353"];
4476 [label="this.AdjustFlagsAndWidth(leading); 172354"];
4477 [label="return 'endif'; 172355"];
4478 [label="FullWidth = this.Text.Length; 172356"];
4479 [label="FullWidth 172357"];
4480 [label="this.AdjustFlagsAndWidth(trailing); 172358"];
4481 [label="return 'endif'; 172359"];
4482 [label="FullWidth = this.Text.Length; 172360"];
4483 [label="FullWidth 172361"];
4484 [label="this.AdjustFlagsAndWidth(trailing); 172362"];
4485 [label="return 'region'; 172363"];
4486 [label="FullWidth = this.Text.Length; 172364"];
4487 [label="FullWidth 172365"];
4488 [label="return 'region'; 172366"];
4489 [label="FullWidth = this.Text.Length; 172367"];
4490 [label="FullWidth 172368"];
4491 [label="this.AdjustFlagsAndWidth(leading); 172369"];
4492 [label="return 'region'; 172370"];
4493 [label="FullWidth = this.Text.Length; 172371"];
4494 [label="FullWidth 172372"];
4495 [label="this.AdjustFlagsAndWidth(trailing); 172373"];
4496 [label="return 'region'; 172374"];
4497 [label="FullWidth = this.Text.Length; 172375"];
4498 [label="FullWidth 172376"];
4499 [label="this.AdjustFlagsAndWidth(trailing); 172377"];
4500 [label="return 'endregion'; 172378"];
4501 [label="FullWidth = this.Text.Length; 172379"];
4502 [label="FullWidth 172380"];
4503 [label="return 'endregion'; 172381"];
4504 [label="FullWidth = this.Text.Length; 172382"];
4505 [label="FullWidth 172383"];
4506 [label="this.AdjustFlagsAndWidth(leading); 172384"];
4507 [label="return 'endregion'; 172385"];
4508 [label="FullWidth = this.Text.Length; 172386"];
4509 [label="FullWidth 172387"];
4510 [label="this.AdjustFlagsAndWidth(trailing); 172388"];
4511 [label="return 'endregion'; 172389"];
4512 [label="FullWidth = this.Text.Length; 172390"];
4513 [label="FullWidth 172391"];
4514 [label="this.AdjustFlagsAndWidth(trailing); 172392"];
4515 [label="return 'define'; 172393"];
4516 [label="FullWidth = this.Text.Length; 172394"];
4517 [label="FullWidth 172395"];
4518 [label="return 'define'; 172396"];
4519 [label="FullWidth = this.Text.Length; 172397"];
4520 [label="FullWidth 172398"];
4521 [label="this.AdjustFlagsAndWidth(leading); 172399"];
4522 [label="return 'define'; 172400"];
4523 [label="FullWidth = this.Text.Length; 172401"];
4524 [label="FullWidth 172402"];
4525 [label="this.AdjustFlagsAndWidth(trailing); 172403"];
4526 [label="return 'define'; 172404"];
4527 [label="FullWidth = this.Text.Length; 172405"];
4528 [label="FullWidth 172406"];
4529 [label="this.AdjustFlagsAndWidth(trailing); 172407"];
4530 [label="return 'undef'; 172408"];
4531 [label="FullWidth = this.Text.Length; 172409"];
4532 [label="FullWidth 172410"];
4533 [label="return 'undef'; 172411"];
4534 [label="FullWidth = this.Text.Length; 172412"];
4535 [label="FullWidth 172413"];
4536 [label="this.AdjustFlagsAndWidth(leading); 172414"];
4537 [label="return 'undef'; 172415"];
4538 [label="FullWidth = this.Text.Length; 172416"];
4539 [label="FullWidth 172417"];
4540 [label="this.AdjustFlagsAndWidth(trailing); 172418"];
4541 [label="return 'undef'; 172419"];
4542 [label="FullWidth = this.Text.Length; 172420"];
4543 [label="FullWidth 172421"];
4544 [label="this.AdjustFlagsAndWidth(trailing); 172422"];
4545 [label="return 'warning'; 172423"];
4546 [label="FullWidth = this.Text.Length; 172424"];
4547 [label="FullWidth 172425"];
4548 [label="return 'warning'; 172426"];
4549 [label="FullWidth = this.Text.Length; 172427"];
4550 [label="FullWidth 172428"];
4551 [label="this.AdjustFlagsAndWidth(leading); 172429"];
4552 [label="return 'warning'; 172430"];
4553 [label="FullWidth = this.Text.Length; 172431"];
4554 [label="FullWidth 172432"];
4555 [label="this.AdjustFlagsAndWidth(trailing); 172433"];
4556 [label="return 'warning'; 172434"];
4557 [label="FullWidth = this.Text.Length; 172435"];
4558 [label="FullWidth 172436"];
4559 [label="this.AdjustFlagsAndWidth(trailing); 172437"];
4560 [label="return 'error'; 172438"];
4561 [label="FullWidth = this.Text.Length; 172439"];
4562 [label="FullWidth 172440"];
4563 [label="return 'error'; 172441"];
4564 [label="FullWidth = this.Text.Length; 172442"];
4565 [label="FullWidth 172443"];
4566 [label="this.AdjustFlagsAndWidth(leading); 172444"];
4567 [label="return 'error'; 172445"];
4568 [label="FullWidth = this.Text.Length; 172446"];
4569 [label="FullWidth 172447"];
4570 [label="this.AdjustFlagsAndWidth(trailing); 172448"];
4571 [label="return 'error'; 172449"];
4572 [label="FullWidth = this.Text.Length; 172450"];
4573 [label="FullWidth 172451"];
4574 [label="this.AdjustFlagsAndWidth(trailing); 172452"];
4575 [label="return 'line'; 172453"];
4576 [label="FullWidth = this.Text.Length; 172454"];
4577 [label="FullWidth 172455"];
4578 [label="return 'line'; 172456"];
4579 [label="FullWidth = this.Text.Length; 172457"];
4580 [label="FullWidth 172458"];
4581 [label="this.AdjustFlagsAndWidth(leading); 172459"];
4582 [label="return 'line'; 172460"];
4583 [label="FullWidth = this.Text.Length; 172461"];
4584 [label="FullWidth 172462"];
4585 [label="this.AdjustFlagsAndWidth(trailing); 172463"];
4586 [label="return 'line'; 172464"];
4587 [label="FullWidth = this.Text.Length; 172465"];
4588 [label="FullWidth 172466"];
4589 [label="this.AdjustFlagsAndWidth(trailing); 172467"];
4590 [label="return 'pragma'; 172468"];
4591 [label="FullWidth = this.Text.Length; 172469"];
4592 [label="FullWidth 172470"];
4593 [label="return 'pragma'; 172471"];
4594 [label="FullWidth = this.Text.Length; 172472"];
4595 [label="FullWidth 172473"];
4596 [label="this.AdjustFlagsAndWidth(leading); 172474"];
4597 [label="return 'pragma'; 172475"];
4598 [label="FullWidth = this.Text.Length; 172476"];
4599 [label="FullWidth 172477"];
4600 [label="this.AdjustFlagsAndWidth(trailing); 172478"];
4601 [label="return 'pragma'; 172479"];
4602 [label="FullWidth = this.Text.Length; 172480"];
4603 [label="FullWidth 172481"];
4604 [label="this.AdjustFlagsAndWidth(trailing); 172482"];
4605 [label="return 'hidden'; 172483"];
4606 [label="FullWidth = this.Text.Length; 172484"];
4607 [label="FullWidth 172485"];
4608 [label="return 'hidden'; 172486"];
4609 [label="FullWidth = this.Text.Length; 172487"];
4610 [label="FullWidth 172488"];
4611 [label="this.AdjustFlagsAndWidth(leading); 172489"];
4612 [label="return 'hidden'; 172490"];
4613 [label="FullWidth = this.Text.Length; 172491"];
4614 [label="FullWidth 172492"];
4615 [label="this.AdjustFlagsAndWidth(trailing); 172493"];
4616 [label="return 'hidden'; 172494"];
4617 [label="FullWidth = this.Text.Length; 172495"];
4618 [label="FullWidth 172496"];
4619 [label="this.AdjustFlagsAndWidth(trailing); 172497"];
4620 [label="return 'checksum'; 172498"];
4621 [label="FullWidth = this.Text.Length; 172499"];
4622 [label="FullWidth 172500"];
4623 [label="return 'checksum'; 172501"];
4624 [label="FullWidth = this.Text.Length; 172502"];
4625 [label="FullWidth 172503"];
4626 [label="this.AdjustFlagsAndWidth(leading); 172504"];
4627 [label="return 'checksum'; 172505"];
4628 [label="FullWidth = this.Text.Length; 172506"];
4629 [label="FullWidth 172507"];
4630 [label="this.AdjustFlagsAndWidth(trailing); 172508"];
4631 [label="return 'checksum'; 172509"];
4632 [label="FullWidth = this.Text.Length; 172510"];
4633 [label="FullWidth 172511"];
4634 [label="this.AdjustFlagsAndWidth(trailing); 172512"];
4635 [label="return 'disable'; 172513"];
4636 [label="FullWidth = this.Text.Length; 172514"];
4637 [label="FullWidth 172515"];
4638 [label="return 'disable'; 172516"];
4639 [label="FullWidth = this.Text.Length; 172517"];
4640 [label="FullWidth 172518"];
4641 [label="this.AdjustFlagsAndWidth(leading); 172519"];
4642 [label="return 'disable'; 172520"];
4643 [label="FullWidth = this.Text.Length; 172521"];
4644 [label="FullWidth 172522"];
4645 [label="this.AdjustFlagsAndWidth(trailing); 172523"];
4646 [label="return 'disable'; 172524"];
4647 [label="FullWidth = this.Text.Length; 172525"];
4648 [label="FullWidth 172526"];
4649 [label="this.AdjustFlagsAndWidth(trailing); 172527"];
4650 [label="return 'restore'; 172528"];
4651 [label="FullWidth = this.Text.Length; 172529"];
4652 [label="FullWidth 172530"];
4653 [label="return 'restore'; 172531"];
4654 [label="FullWidth = this.Text.Length; 172532"];
4655 [label="FullWidth 172533"];
4656 [label="this.AdjustFlagsAndWidth(leading); 172534"];
4657 [label="return 'restore'; 172535"];
4658 [label="FullWidth = this.Text.Length; 172536"];
4659 [label="FullWidth 172537"];
4660 [label="this.AdjustFlagsAndWidth(trailing); 172538"];
4661 [label="return 'restore'; 172539"];
4662 [label="FullWidth = this.Text.Length; 172540"];
4663 [label="FullWidth 172541"];
4664 [label="this.AdjustFlagsAndWidth(trailing); 172542"];
4665 [label="return 'r'; 172543"];
4666 [label="FullWidth = this.Text.Length; 172544"];
4667 [label="FullWidth 172545"];
4668 [label="return 'r'; 172546"];
4669 [label="FullWidth = this.Text.Length; 172547"];
4670 [label="FullWidth 172548"];
4671 [label="this.AdjustFlagsAndWidth(leading); 172549"];
4672 [label="return 'r'; 172550"];
4673 [label="FullWidth = this.Text.Length; 172551"];
4674 [label="FullWidth 172552"];
4675 [label="this.AdjustFlagsAndWidth(trailing); 172553"];
4676 [label="return 'r'; 172554"];
4677 [label="FullWidth = this.Text.Length; 172555"];
4678 [label="FullWidth 172556"];
4679 [label="this.AdjustFlagsAndWidth(trailing); 172557"];
4680 [label="return '$\\''; 172558"];
4681 [label="FullWidth = this.Text.Length; 172559"];
4682 [label="FullWidth 172560"];
4683 [label="return '$\\''; 172561"];
4684 [label="FullWidth = this.Text.Length; 172562"];
4685 [label="FullWidth 172563"];
4686 [label="this.AdjustFlagsAndWidth(leading); 172564"];
4687 [label="return '$\\''; 172565"];
4688 [label="FullWidth = this.Text.Length; 172566"];
4689 [label="FullWidth 172567"];
4690 [label="this.AdjustFlagsAndWidth(trailing); 172568"];
4691 [label="return '$\\''; 172569"];
4692 [label="FullWidth = this.Text.Length; 172570"];
4693 [label="FullWidth 172571"];
4694 [label="this.AdjustFlagsAndWidth(trailing); 172572"];
4695 [label="return '\\''; 172573"];
4696 [label="FullWidth = this.Text.Length; 172574"];
4697 [label="FullWidth 172575"];
4698 [label="return '\\''; 172576"];
4699 [label="FullWidth = this.Text.Length; 172577"];
4700 [label="FullWidth 172578"];
4701 [label="this.AdjustFlagsAndWidth(leading); 172579"];
4702 [label="return '\\''; 172580"];
4703 [label="FullWidth = this.Text.Length; 172581"];
4704 [label="FullWidth 172582"];
4705 [label="this.AdjustFlagsAndWidth(trailing); 172583"];
4706 [label="return '\\''; 172584"];
4707 [label="FullWidth = this.Text.Length; 172585"];
4708 [label="FullWidth 172586"];
4709 [label="this.AdjustFlagsAndWidth(trailing); 172587"];
4710 [label="return '$@\\''; 172588"];
4711 [label="FullWidth = this.Text.Length; 172589"];
4712 [label="FullWidth 172590"];
4713 [label="return '$@\\''; 172591"];
4714 [label="FullWidth = this.Text.Length; 172592"];
4715 [label="FullWidth 172593"];
4716 [label="this.AdjustFlagsAndWidth(leading); 172594"];
4717 [label="return '$@\\''; 172595"];
4718 [label="FullWidth = this.Text.Length; 172596"];
4719 [label="FullWidth 172597"];
4720 [label="this.AdjustFlagsAndWidth(trailing); 172598"];
4721 [label="return '$@\\''; 172599"];
4722 [label="FullWidth = this.Text.Length; 172600"];
4723 [label="FullWidth 172601"];
4724 [label="this.AdjustFlagsAndWidth(trailing); 172602"];
4725 [label="return 'load'; 172603"];
4726 [label="FullWidth = this.Text.Length; 172604"];
4727 [label="FullWidth 172605"];
4728 [label="return 'load'; 172606"];
4729 [label="FullWidth = this.Text.Length; 172607"];
4730 [label="FullWidth 172608"];
4731 [label="this.AdjustFlagsAndWidth(leading); 172609"];
4732 [label="return 'load'; 172610"];
4733 [label="FullWidth = this.Text.Length; 172611"];
4734 [label="FullWidth 172612"];
4735 [label="this.AdjustFlagsAndWidth(trailing); 172613"];
4736 [label="return 'load'; 172614"];
4737 [label="FullWidth = this.Text.Length; 172615"];
4738 [label="FullWidth 172616"];
4739 [label="this.AdjustFlagsAndWidth(trailing); 172617"];
4740 [label="return 'nullable'; 172618"];
4741 [label="FullWidth = this.Text.Length; 172619"];
4742 [label="FullWidth 172620"];
4743 [label="return 'nullable'; 172621"];
4744 [label="FullWidth = this.Text.Length; 172622"];
4745 [label="FullWidth 172623"];
4746 [label="this.AdjustFlagsAndWidth(leading); 172624"];
4747 [label="return 'nullable'; 172625"];
4748 [label="FullWidth = this.Text.Length; 172626"];
4749 [label="FullWidth 172627"];
4750 [label="this.AdjustFlagsAndWidth(trailing); 172628"];
4751 [label="return 'nullable'; 172629"];
4752 [label="FullWidth = this.Text.Length; 172630"];
4753 [label="FullWidth 172631"];
4754 [label="this.AdjustFlagsAndWidth(trailing); 172632"];
4755 [label="return 'enable'; 172633"];
4756 [label="FullWidth = this.Text.Length; 172634"];
4757 [label="FullWidth 172635"];
4758 [label="return 'enable'; 172636"];
4759 [label="FullWidth = this.Text.Length; 172637"];
4760 [label="FullWidth 172638"];
4761 [label="this.AdjustFlagsAndWidth(leading); 172639"];
4762 [label="return 'enable'; 172640"];
4763 [label="FullWidth = this.Text.Length; 172641"];
4764 [label="FullWidth 172642"];
4765 [label="this.AdjustFlagsAndWidth(trailing); 172643"];
4766 [label="return 'enable'; 172644"];
4767 [label="FullWidth = this.Text.Length; 172645"];
4768 [label="FullWidth 172646"];
4769 [label="this.AdjustFlagsAndWidth(trailing); 172647"];
4770 [label="return 'warnings'; 172648"];
4771 [label="FullWidth = this.Text.Length; 172649"];
4772 [label="FullWidth 172650"];
4773 [label="return 'warnings'; 172651"];
4774 [label="FullWidth = this.Text.Length; 172652"];
4775 [label="FullWidth 172653"];
4776 [label="this.AdjustFlagsAndWidth(leading); 172654"];
4777 [label="return 'warnings'; 172655"];
4778 [label="FullWidth = this.Text.Length; 172656"];
4779 [label="FullWidth 172657"];
4780 [label="this.AdjustFlagsAndWidth(trailing); 172658"];
4781 [label="return 'warnings'; 172659"];
4782 [label="FullWidth = this.Text.Length; 172660"];
4783 [label="FullWidth 172661"];
4784 [label="this.AdjustFlagsAndWidth(trailing); 172662"];
4785 [label="return 'annotations'; 172663"];
4786 [label="FullWidth = this.Text.Length; 172664"];
4787 [label="FullWidth 172665"];
4788 [label="return 'annotations'; 172666"];
4789 [label="FullWidth = this.Text.Length; 172667"];
4790 [label="FullWidth 172668"];
4791 [label="this.AdjustFlagsAndWidth(leading); 172669"];
4792 [label="return 'annotations'; 172670"];
4793 [label="FullWidth = this.Text.Length; 172671"];
4794 [label="FullWidth 172672"];
4795 [label="this.AdjustFlagsAndWidth(trailing); 172673"];
4796 [label="return 'annotations'; 172674"];
4797 [label="FullWidth = this.Text.Length; 172675"];
4798 [label="FullWidth 172676"];
4799 [label="this.AdjustFlagsAndWidth(trailing); 172677"];
4800 [label="return 'var'; 172678"];
4801 [label="FullWidth = this.Text.Length; 172679"];
4802 [label="FullWidth 172680"];
4803 [label="return 'var'; 172681"];
4804 [label="FullWidth = this.Text.Length; 172682"];
4805 [label="FullWidth 172683"];
4806 [label="this.AdjustFlagsAndWidth(leading); 172684"];
4807 [label="return 'var'; 172685"];
4808 [label="FullWidth = this.Text.Length; 172686"];
4809 [label="FullWidth 172687"];
4810 [label="this.AdjustFlagsAndWidth(trailing); 172688"];
4811 [label="return 'var'; 172689"];
4812 [label="FullWidth = this.Text.Length; 172690"];
4813 [label="FullWidth 172691"];
4814 [label="this.AdjustFlagsAndWidth(trailing); 172692"];
4815 [label="return '_'; 172693"];
4816 [label="FullWidth = this.Text.Length; 172694"];
4817 [label="FullWidth 172695"];
4818 [label="return '_'; 172696"];
4819 [label="FullWidth = this.Text.Length; 172697"];
4820 [label="FullWidth 172698"];
4821 [label="this.AdjustFlagsAndWidth(leading); 172699"];
4822 [label="return '_'; 172700"];
4823 [label="FullWidth = this.Text.Length; 172701"];
4824 [label="FullWidth 172702"];
4825 [label="this.AdjustFlagsAndWidth(trailing); 172703"];
4826 [label="return '_'; 172704"];
4827 [label="FullWidth = this.Text.Length; 172705"];
4828 [label="FullWidth 172706"];
4829 [label="this.AdjustFlagsAndWidth(trailing); 172707"];
4830 [label="return SyntaxToken.Create(kind, leading, trailing); 172708"];
4831 [label="return SyntaxToken.Create(kind, leading, trailing); 172709"];
4832 [label="return SyntaxToken.Create(kind, leading, trailing); 172710"];
4833 [label="SyntaxToken.Create(kind, leading, trailing) 172711"];
4834 [label="param Create(SyntaxKind kind) 172712"];
4835 [label="param Create(GreenNode leading) 172713"];
4836 [label="param Create(GreenNode trailing) 172714"];
4837 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 172715"];
4838 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 172716"];
4839 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 172717"];
4840 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 172718"];
4841 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 172719"];
4842 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 172720"];
4843 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 172721"];
4844 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172722"];
4845 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172723"];
4846 [label="return token; 172724"];
4847 [label="this.AddLexedToken(token); 172725"];
4848 [label="this.AddLexedToken(token) 172726"];
4849 [label="param AddLexedToken(SyntaxToken token) 172727"];
4850 [label="param AddLexedToken(this) 172728"];
4851 [label="Debug.Assert(token != null); 172729"];
4852 [label="Debug.Assert(token != null); 172730"];
4853 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 172731"];
4854 [label="_lexedTokens[_tokenCount].Value = token; 172732"];
4855 [label="_lexedTokens[_tokenCount].Value 172733"];
4856 [label="_tokenCount 172734"];
4857 [label="this.AddLexedToken(token); 172735"];
4858 [label="token.Kind 172736"];
4859 [label="get { return (SyntaxKind)this.RawKind; } 172737"];
4860 [label="return (SyntaxKind)this.RawKind; 172738"];
4861 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 172739"];
4862 [label="TextWindow.Start(); 172740"];
4863 [label="get\n            {\n                return _lexemeStart;\n            } 172741"];
4864 [label="return _lexemeStart; 172742"];
4865 [label="param LookupToken(char[] textBuffer) 172743"];
4866 [label="param LookupToken(int keyStart) 172744"];
4867 [label="param LookupToken(int keyLength) 172745"];
4868 [label="param LookupToken(int hashCode) 172746"];
4869 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 172747"];
4870 [label="param LookupToken(this) 172748"];
4871 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 172749"];
4872 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 172750"];
4873 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 172751"];
4874 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 172752"];
4875 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 172753"];
4876 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 172754"];
4877 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 172755"];
4878 [label="value = createTokenFunction(); 172756"];
4879 [label="value = createTokenFunction(); 172757"];
4880 [label="param CreateQuickToken(this) 172758"];
4881 [label="TextWindow.Width 172759"];
4882 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 172760"];
4883 [label="var quickWidth = TextWindow.Width; 172761"];
4884 [label="TextWindow.LexemeStartPosition 172762"];
4885 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 172763"];
4886 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 172764"];
4887 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 172765"];
4888 [label="param Reset(int position) 172766"];
4889 [label="param Reset(this) 172767"];
4890 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 172768"];
4891 [label="this.LexSyntaxToken() 172769"];
4892 [label="param LexSyntaxToken(this) 172770"];
4893 [label="_leadingTriviaCache.Clear(); 172771"];
4894 [label="TextWindow.Position 172772"];
4895 [label="get\n            {\n                return _basis + _offset;\n            } 172773"];
4896 [label="param LexSyntaxTrivia(bool afterFirstToken) 172774"];
4897 [label="param LexSyntaxTrivia(bool isTrailing) 172775"];
4898 [label="bool onlyWhitespaceOnLine = !isTrailing; 172776"];
4899 [label="TextWindow.Start(); 172777"];
4900 [label="this.Start(); 172778"];
4901 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 172779"];
4902 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 172780"];
4903 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 172781"];
4904 [label="return; 172782"];
4905 [label="this.Start(); 172783"];
4906 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172784"];
4907 [label="GetFullWidth(leading) 172785"];
4908 [label="param GetFullWidth(SyntaxListBuilder builder) 172786"];
4909 [label="int width = 0; 172787"];
4910 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 172788"];
4911 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 172789"];
4912 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 172790"];
4913 [label="return width; 172791"];
4914 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172792"];
4915 [label="this.GetErrors(GetFullWidth(leading)) 172793"];
4916 [label="param GetErrors(int leadingTriviaWidth) 172794"];
4917 [label="param GetErrors(this) 172795"];
4918 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 172796"];
4919 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 172797"];
4920 [label="return null; 172798"];
4921 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172799"];
4922 [label="param LexSyntaxTrivia(bool afterFirstToken) 172800"];
4923 [label="param Create(ref TokenInfo info) 172801"];
4924 [label="param Create(SyntaxDiagnosticInfo[] errors) 172802"];
4925 [label="param Create(this) 172803"];
4926 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 172804"];
4927 [label="SyntaxToken token; 172805"];
4928 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 172806"];
4929 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 172807"];
4930 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 172808"];
4931 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 172809"];
4932 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 172810"];
4933 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 172811"];
4934 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 172812"];
4935 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 172813"];
4936 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 172814"];
4937 [label="param Token(GreenNode leading) 172815"];
4938 [label="param Token(SyntaxKind kind) 172816"];
4939 [label="param Token(GreenNode trailing) 172817"];
4940 [label="return SyntaxToken.Create(kind, leading, trailing); 172818"];
4941 [label="return SyntaxToken.Create(kind, leading, trailing); 172819"];
4942 [label="return SyntaxToken.Create(kind, leading, trailing); 172820"];
4943 [label="SyntaxToken.Create(kind, leading, trailing) 172821"];
4944 [label="param Create(SyntaxKind kind) 172822"];
4945 [label="param Create(GreenNode leading) 172823"];
4946 [label="param Create(GreenNode trailing) 172824"];
4947 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 172825"];
4948 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 172826"];
4949 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 172827"];
4950 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 172828"];
4951 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 172829"];
4952 [label="return s_tokensWithNoTrivia[(int)kind].Value; 172830"];
4953 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172831"];
4954 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172832"];
4955 [label="return token; 172833"];
4956 [label="var token = this.LexSyntaxToken(); 172834"];
4957 [label="Debug.Assert(quickWidth == token.FullWidth); 172835"];
4958 [label="return token; 172836"];
4959 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 172837"];
4960 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 172838"];
4961 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 172839"];
4962 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 172840"];
4963 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 172841"];
4964 [label="return value; 172842"];
4965 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 172843"];
4966 [label="this.AddLexedToken(token); 172844"];
4967 [label="param AddLexedToken(SyntaxToken token) 172845"];
4968 [label="Debug.Assert(token != null); 172846"];
4969 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 172847"];
4970 [label="_lexedTokens[_tokenCount].Value = token; 172848"];
4971 [label="_lexedTokens[_tokenCount].Value 172849"];
4972 [label="get { return (SyntaxKind)this.RawKind; } 172850"];
4973 [label="return (SyntaxKind)this.RawKind; 172851"];
4974 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 172852"];
4975 [label="TextWindow.Start(); 172853"];
4976 [label="TextWindow.Width 172854"];
4977 [label="var quickWidth = TextWindow.Width; 172855"];
4978 [label="TextWindow.Position 172856"];
4979 [label="param LexSyntaxTrivia(bool afterFirstToken) 172857"];
4980 [label="param LexSyntaxTrivia(bool isTrailing) 172858"];
4981 [label="bool onlyWhitespaceOnLine = !isTrailing; 172859"];
4982 [label="this.Start(); 172860"];
4983 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 172861"];
4984 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 172862"];
4985 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 172863"];
4986 [label="return; 172864"];
4987 [label="this.Start(); 172865"];
4988 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 172866"];
4989 [label="param TryGetKeywordKind(out SyntaxKind kind) 172867"];
4990 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 172868"];
4991 [label="return SyntaxKind.None; 172869"];
4992 [label="param GetContextualKeywordKind(string text) 172870"];
4993 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 172871"];
4994 [label="return SyntaxKind.None; 172872"];
4995 [label="kind = _keywordKindMap.GetOrMakeValue(key); 172873"];
4996 [label="return kind != SyntaxKind.None; 172874"];
4997 [label="info.Kind 172875"];
4998 [label="info.ContextualKind 172876"];
4999 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 172877"];
5000 [label="this.ScanSyntaxToken(ref tokenInfo); 172878"];
5001 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172879"];
5002 [label="GetFullWidth(leading) 172880"];
5003 [label="param GetFullWidth(SyntaxListBuilder builder) 172881"];
5004 [label="int width = 0; 172882"];
5005 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 172883"];
5006 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 172884"];
5007 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 172885"];
5008 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 172886"];
5009 [label="return width; 172887"];
5010 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172888"];
5011 [label="this.GetErrors(GetFullWidth(leading)) 172889"];
5012 [label="param GetErrors(int leadingTriviaWidth) 172890"];
5013 [label="param GetErrors(this) 172891"];
5014 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 172892"];
5015 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 172893"];
5016 [label="return null; 172894"];
5017 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172895"];
5018 [label="param LexSyntaxTrivia(bool afterFirstToken) 172896"];
5019 [label="param LexSyntaxTrivia(bool isTrailing) 172897"];
5020 [label="bool onlyWhitespaceOnLine = !isTrailing; 172898"];
5021 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 172899"];
5022 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 172900"];
5023 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 172901"];
5024 [label="return; 172902"];
5025 [label="param Create(SyntaxDiagnosticInfo[] errors) 172903"];
5026 [label="param Create(this) 172904"];
5027 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 172905"];
5028 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 172906"];
5029 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 172907"];
5030 [label="SyntaxToken token; 172908"];
5031 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 172909"];
5032 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 172910"];
5033 [label="param Identifier(SyntaxKind contextualKind) 172911"];
5034 [label="param Identifier(GreenNode leading) 172912"];
5035 [label="param Identifier(string text) 172913"];
5036 [label="param Identifier(string valueText) 172914"];
5037 [label="param Identifier(GreenNode trailing) 172915"];
5038 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 172916"];
5039 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 172917"];
5040 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 172918"];
5041 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 172919"];
5042 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 172920"];
5043 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 172921"];
5044 [label="param Identifier(SyntaxKind contextualKind) 172922"];
5045 [label="param Identifier(GreenNode leading) 172923"];
5046 [label="param Identifier(string text) 172924"];
5047 [label="param Identifier(string valueText) 172925"];
5048 [label="param Identifier(GreenNode trailing) 172926"];
5049 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 172927"];
5050 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 172928"];
5051 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 172929"];
5052 [label="return Identifier(leading, text, trailing); 172930"];
5053 [label="return Identifier(leading, text, trailing); 172931"];
5054 [label="return Identifier(leading, text, trailing); 172932"];
5055 [label="Identifier(leading, text, trailing) 172933"];
5056 [label="param Identifier(GreenNode leading) 172934"];
5057 [label="param Identifier(string text) 172935"];
5058 [label="param Identifier(GreenNode trailing) 172936"];
5059 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 172937"];
5060 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 172938"];
5061 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 172939"];
5062 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 172940"];
5063 [label="return Identifier(text); 172941"];
5064 [label="Identifier(text) 172942"];
5065 [label="param Identifier(string text) 172943"];
5066 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 172944"];
5067 [label="return new SyntaxIdentifier(text); 172945"];
5068 [label="return new SyntaxIdentifier(text); 172946"];
5069 [label="new SyntaxIdentifier(text) 172947"];
5070 [label="param SyntaxIdentifier(string text) 172948"];
5071 [label="param SyntaxIdentifier(this) 172949"];
5072 [label="SyntaxKind.IdentifierToken 172950"];
5073 [label="text 172951"];
5074 [label="param SyntaxIdentifier(this) 172952"];
5075 [label="param SyntaxToken(SyntaxKind kind) 172953"];
5076 [label="param SyntaxToken(int fullWidth) 172954"];
5077 [label="param SyntaxToken(this) 172955"];
5078 [label="kind 172956"];
5079 [label="fullWidth 172957"];
5080 [label="param SyntaxToken(this) 172958"];
5081 [label="param CSharpSyntaxNode(SyntaxKind kind) 172959"];
5082 [label="param CSharpSyntaxNode(int fullWidth) 172960"];
5083 [label="param CSharpSyntaxNode(this) 172961"];
5084 [label="kind 172962"];
5085 [label="fullWidth 172963"];
5086 [label="param CSharpSyntaxNode(this) 172964"];
5087 [label="param CSharpSyntaxNode(this) 172965"];
5088 [label="GreenStats.NoteGreen(this); 172966"];
5089 [label="GreenStats.NoteGreen(this); 172967"];
5090 [label="this.flags |= NodeFlags.IsNotMissing; 172968"];
5091 [label="this.flags 172969"];
5092 [label="TextField 172970"];
5093 [label="this.TextField 172971"];
5094 [label="return Identifier(text); 172972"];
5095 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172973"];
5096 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 172974"];
5097 [label="Debug.Assert(quickWidth == token.FullWidth); 172975"];
5098 [label="value = createTokenFunction(); 172976"];
5099 [label="this.AddLexedToken(token); 172977"];
5100 [label="param AddLexedToken(SyntaxToken token) 172978"];
5101 [label="Debug.Assert(token != null); 172979"];
5102 [label="_lexedTokens[_tokenCount].Value 172980"];
5103 [label="get { return (SyntaxKind)this.RawKind; } 172981"];
5104 [label="return (SyntaxKind)this.RawKind; 172982"];
5105 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 172983"];
5106 [label="TextWindow.Start(); 172984"];
5107 [label="TextWindow.Width 172985"];
5108 [label="var quickWidth = TextWindow.Width; 172986"];
5109 [label="param LexSyntaxTrivia(bool afterFirstToken) 172987"];
5110 [label="param LexSyntaxTrivia(bool isTrailing) 172988"];
5111 [label="bool onlyWhitespaceOnLine = !isTrailing; 172989"];
5112 [label="this.Start(); 172990"];
5113 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 172991"];
5114 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 172992"];
5115 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 172993"];
5116 [label="return; 172994"];
5117 [label="this.Start(); 172995"];
5118 [label="var errors = this.GetErrors(GetFullWidth(leading)); 172996"];
5119 [label="GetFullWidth(leading) 172997"];
5120 [label="param GetFullWidth(SyntaxListBuilder builder) 172998"];
5121 [label="int width = 0; 172999"];
5122 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173000"];
5123 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173001"];
5124 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173002"];
5125 [label="return width; 173003"];
5126 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173004"];
5127 [label="this.GetErrors(GetFullWidth(leading)) 173005"];
5128 [label="param GetErrors(int leadingTriviaWidth) 173006"];
5129 [label="param GetErrors(this) 173007"];
5130 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173008"];
5131 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173009"];
5132 [label="return null; 173010"];
5133 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173011"];
5134 [label="param AddTrivia(this) 173012"];
5135 [label="this.HasErrors 173013"];
5136 [label="get { return _errors != null; } 173014"];
5137 [label="return _errors != null; 173015"];
5138 [label="return _errors != null; 173016"];
5139 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 173017"];
5140 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 173018"];
5141 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 173019"];
5142 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173020"];
5143 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 173021"];
5144 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173022"];
5145 [label="return; 173023"];
5146 [label="param Create(SyntaxDiagnosticInfo[] errors) 173024"];
5147 [label="param Create(this) 173025"];
5148 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173026"];
5149 [label="SyntaxToken token; 173027"];
5150 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 173028"];
5151 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 173029"];
5152 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 173030"];
5153 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 173031"];
5154 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 173032"];
5155 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 173033"];
5156 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 173034"];
5157 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173035"];
5158 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173036"];
5159 [label="Debug.Assert(quickWidth == token.FullWidth); 173037"];
5160 [label="this.AddLexedToken(token); 173038"];
5161 [label="param AddLexedToken(SyntaxToken token) 173039"];
5162 [label="Debug.Assert(token != null); 173040"];
5163 [label="_lexedTokens[_tokenCount].Value 173041"];
5164 [label="get { return (SyntaxKind)this.RawKind; } 173042"];
5165 [label="return (SyntaxKind)this.RawKind; 173043"];
5166 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 173044"];
5167 [label="TextWindow.Start(); 173045"];
5168 [label="var quickWidth = TextWindow.Width; 173046"];
5169 [label="param LexSyntaxTrivia(bool afterFirstToken) 173047"];
5170 [label="param LexSyntaxTrivia(bool isTrailing) 173048"];
5171 [label="bool onlyWhitespaceOnLine = !isTrailing; 173049"];
5172 [label="this.Start(); 173050"];
5173 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173051"];
5174 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 173052"];
5175 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173053"];
5176 [label="return; 173054"];
5177 [label="this.Start(); 173055"];
5178 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173056"];
5179 [label="GetFullWidth(leading) 173057"];
5180 [label="param GetFullWidth(SyntaxListBuilder builder) 173058"];
5181 [label="int width = 0; 173059"];
5182 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173060"];
5183 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173061"];
5184 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173062"];
5185 [label="return width; 173063"];
5186 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173064"];
5187 [label="this.GetErrors(GetFullWidth(leading)) 173065"];
5188 [label="param GetErrors(int leadingTriviaWidth) 173066"];
5189 [label="param GetErrors(this) 173067"];
5190 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173068"];
5191 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173069"];
5192 [label="return null; 173070"];
5193 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173071"];
5194 [label="param AddTrivia(this) 173072"];
5195 [label="this.HasErrors 173073"];
5196 [label="get { return _errors != null; } 173074"];
5197 [label="return _errors != null; 173075"];
5198 [label="return _errors != null; 173076"];
5199 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 173077"];
5200 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 173078"];
5201 [label="param Create(SyntaxDiagnosticInfo[] errors) 173079"];
5202 [label="param Create(this) 173080"];
5203 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173081"];
5204 [label="SyntaxToken token; 173082"];
5205 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 173083"];
5206 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 173084"];
5207 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 173085"];
5208 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 173086"];
5209 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 173087"];
5210 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173088"];
5211 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173089"];
5212 [label="Debug.Assert(quickWidth == token.FullWidth); 173090"];
5213 [label="param TryGetKeywordKind(out SyntaxKind kind) 173091"];
5214 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 173092"];
5215 [label="return SyntaxKind.CaseKeyword; 173093"];
5216 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 173094"];
5217 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 173095"];
5218 [label="param IsContextualKeyword(SyntaxKind kind) 173096"];
5219 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 173097"];
5220 [label="return false; 173098"];
5221 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 173099"];
5222 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173100"];
5223 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173101"];
5224 [label="return null; 173102"];
5225 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173103"];
5226 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173104"];
5227 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173105"];
5228 [label="param AddTrivia(this) 173106"];
5229 [label="this.HasErrors 173107"];
5230 [label="get { return _errors != null; } 173108"];
5231 [label="return _errors != null; 173109"];
5232 [label="return _errors != null; 173110"];
5233 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 173111"];
5234 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 173112"];
5235 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 173113"];
5236 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173114"];
5237 [label="return; 173115"];
5238 [label="param Create(SyntaxDiagnosticInfo[] errors) 173116"];
5239 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173117"];
5240 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 173118"];
5241 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 173119"];
5242 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 173120"];
5243 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 173121"];
5244 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 173122"];
5245 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173123"];
5246 [label="Debug.Assert(quickWidth == token.FullWidth); 173124"];
5247 [label="this.AddLexedToken(token); 173125"];
5248 [label="param AddLexedToken(SyntaxToken token) 173126"];
5249 [label="Debug.Assert(token != null); 173127"];
5250 [label="_lexedTokens[_tokenCount].Value 173128"];
5251 [label="get { return (SyntaxKind)this.RawKind; } 173129"];
5252 [label="return (SyntaxKind)this.RawKind; 173130"];
5253 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 173131"];
5254 [label="TextWindow.Start(); 173132"];
5255 [label="var quickWidth = TextWindow.Width; 173133"];
5256 [label="param LexSyntaxTrivia(bool afterFirstToken) 173134"];
5257 [label="param LexSyntaxTrivia(bool isTrailing) 173135"];
5258 [label="bool onlyWhitespaceOnLine = !isTrailing; 173136"];
5259 [label="this.Start(); 173137"];
5260 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173138"];
5261 [label="return; 173139"];
5262 [label="this.Start(); 173140"];
5263 [label="param TryGetKeywordKind(out SyntaxKind kind) 173141"];
5264 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 173142"];
5265 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 173143"];
5266 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173144"];
5267 [label="GetFullWidth(leading) 173145"];
5268 [label="param GetFullWidth(SyntaxListBuilder builder) 173146"];
5269 [label="int width = 0; 173147"];
5270 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173148"];
5271 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173149"];
5272 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173150"];
5273 [label="return width; 173151"];
5274 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173152"];
5275 [label="this.GetErrors(GetFullWidth(leading)) 173153"];
5276 [label="param GetErrors(int leadingTriviaWidth) 173154"];
5277 [label="param GetErrors(this) 173155"];
5278 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173156"];
5279 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173157"];
5280 [label="return null; 173158"];
5281 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173159"];
5282 [label="param Create(SyntaxDiagnosticInfo[] errors) 173160"];
5283 [label="param Create(this) 173161"];
5284 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173162"];
5285 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173163"];
5286 [label="SyntaxToken token; 173164"];
5287 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173165"];
5288 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173166"];
5289 [label="Debug.Assert(quickWidth == token.FullWidth); 173167"];
5290 [label="param AddTrivia(this) 173168"];
5291 [label="get { return _errors != null; } 173169"];
5292 [label="return _errors != null; 173170"];
5293 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 173171"];
5294 [label="this.Position 173172"];
5295 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 173173"];
5296 [label="return false; 173174"];
5297 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173175"];
5298 [label="return InvalidCharacter; 173176"];
5299 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 173177"];
5300 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 173178"];
5301 [label="SyntaxFacts.IsWhitespace(ch) 173179"];
5302 [label="param IsWhitespace(char ch) 173180"];
5303 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173181"];
5304 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173182"];
5305 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173183"];
5306 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 173184"];
5307 [label="SyntaxFacts.IsNewLine(ch) 173185"];
5308 [label="param IsNewLine(char ch) 173186"];
5309 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 173187"];
5310 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 173188"];
5311 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173189"];
5312 [label="return; 173190"];
5313 [label="return (SyntaxKind)this.RawKind; 173191"];
5314 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 173192"];
5315 [label="param LexSyntaxTrivia(bool afterFirstToken) 173193"];
5316 [label="param LexSyntaxTrivia(bool isTrailing) 173194"];
5317 [label="bool onlyWhitespaceOnLine = !isTrailing; 173195"];
5318 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173196"];
5319 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 173197"];
5320 [label="return false; 173198"];
5321 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 173199"];
5322 [label="return InvalidCharacter; 173200"];
5323 [label="param IsReallyAtEnd(this) 173201"];
5324 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 173202"];
5325 [label="Position 173203"];
5326 [label="get\n            {\n                return _basis + _offset;\n            } 173204"];
5327 [label="return _basis + _offset; 173205"];
5328 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 173206"];
5329 [label="ConsList<Directive>.Empty 173207"];
5330 [label="new DirectiveStack(ConsList<Directive>.Empty) 173208"];
5331 [label="param DirectiveStack(ConsList<Directive> directives) 173209"];
5332 [label="param DirectiveStack(this) 173210"];
5333 [label="_directives 173211"];
5334 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 173212"];
5335 [label="null 173213"];
5336 [label="new DirectiveStack(null) 173214"];
5337 [label="param DirectiveStack(ConsList<Directive> directives) 173215"];
5338 [label="param DirectiveStack(this) 173216"];
5339 [label="_directives 173217"];
5340 [label="Null = new DirectiveStack(null) 173218"];
5341 [label="param HasUnfinishedIf(this) 173219"];
5342 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 173220"];
5343 [label="GetPreviousIfElifElseOrRegion(_directives) 173221"];
5344 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 173222"];
5345 [label="var current = directives; 173223"];
5346 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 173224"];
5347 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 173225"];
5348 [label="return current; 173226"];
5349 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 173227"];
5350 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 173228"];
5351 [label="param HasUnfinishedRegion(this) 173229"];
5352 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 173230"];
5353 [label="GetPreviousIfElifElseOrRegion(_directives) 173231"];
5354 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 173232"];
5355 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 173233"];
5356 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 173234"];
5357 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 173235"];
5358 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 173236"];
5359 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173237"];
5360 [label="param GetFullWidth(SyntaxListBuilder builder) 173238"];
5361 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 173239"];
5362 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173240"];
5363 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 173241"];
5364 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 173242"];
5365 [label="return null; 173243"];
5366 [label="var errors = this.GetErrors(GetFullWidth(leading)); 173244"];
5367 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 173245"];
5368 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 173246"];
5369 [label="SyntaxFacts.IsWhitespace(ch) 173247"];
5370 [label="param IsWhitespace(char ch) 173248"];
5371 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173249"];
5372 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173250"];
5373 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 173251"];
5374 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 173252"];
5375 [label="SyntaxFacts.IsNewLine(ch) 173253"];
5376 [label="param IsNewLine(char ch) 173254"];
5377 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 173255"];
5378 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 173256"];
5379 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 173257"];
5380 [label="return; 173258"];
5381 [label="param Create(SyntaxDiagnosticInfo[] errors) 173259"];
5382 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 173260"];
5383 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 173261"];
5384 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 173262"];
5385 [label="param Token(GreenNode leading) 173263"];
5386 [label="param Token(SyntaxKind kind) 173264"];
5387 [label="param Token(GreenNode trailing) 173265"];
5388 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 173266"];
5389 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 173267"];
5390 [label="this.AddLexedToken(token); 173268"];
5391 [label="param AddLexedToken(SyntaxToken token) 173269"];
5392 [label="Debug.Assert(token != null); 173270"];
5393 [label="_lexedTokens[_tokenCount].Value 173271"];
5394 [label="get { return (SyntaxKind)this.RawKind; } 173272"];
5395 [label="return (SyntaxKind)this.RawKind; 173273"];
5396 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 173274"];
5397 [label="this.PreLex(); 173275"];
5398 [label="new SyntaxListPool() 173276"];
5399 [label="_pool = new SyntaxListPool() 173277"];
5400 [label="_syntaxFactoryContext 173278"];
5401 [label="_syntaxFactory 173279"];
5402 [label="_recursionDepth 173280"];
5403 [label="_termState 173281"];
5404 [label="_isInTry 173282"];
5405 [label="_checkedTopLevelStatementsFeatureAvailability 173283"];
5406 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 173284"];
5407 [label="_syntaxFactoryContext 173285"];
5408 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 173286"];
5409 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 173287"];
5410 [label="_syntaxFactory 173288"];
5411 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 173289"];
5412 [label="parser.ParseStatement() 173290"];
5413 [label="param ParseStatement(this) 173291"];
5414 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 173292"];
5415 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 173293"];
5416 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 173294"];
5417 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 173295"];
5418 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 173296"];
5419 [label="param ParseWithStackGuard(this) 173297"];
5420 [label="Debug.Assert(_recursionDepth == 0); 173298"];
5421 [label="Debug.Assert(_recursionDepth == 0); 173299"];
5422 [label="return parseFunc(); 173300"];
5423 [label="return parseFunc(); 173301"];
5424 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 173302"];
5425 [label="ParseAttributeDeclarations() 173303"];
5426 [label="param ParseAttributeDeclarations(this) 173304"];
5427 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 173305"];
5428 [label="var saveTerm = _termState; 173306"];
5429 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 173307"];
5430 [label="_termState 173308"];
5431 [label="this.IsPossibleAttributeDeclaration() 173309"];
5432 [label="param IsPossibleAttributeDeclaration(this) 173310"];
5433 [label="this.CurrentToken 173311"];
5434 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173312"];
5435 [label="this.FetchCurrentToken() 173313"];
5436 [label="param FetchCurrentToken(this) 173314"];
5437 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173315"];
5438 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 173316"];
5439 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 173317"];
5440 [label="return _lexedTokens[_tokenOffset]; 173318"];
5441 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173319"];
5442 [label="_currentToken 173320"];
5443 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 173321"];
5444 [label="this.CurrentToken.Kind 173322"];
5445 [label="get { return (SyntaxKind)this.RawKind; } 173323"];
5446 [label="return (SyntaxKind)this.RawKind; 173324"];
5447 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 173325"];
5448 [label="_termState 173326"];
5449 [label="return attributes.ToList(); 173327"];
5450 [label="_pool.Free(attributes); 173328"];
5451 [label="_pool.Free(attributes); 173329"];
5452 [label="false 173330"];
5453 [label="isGlobal: false 173331"];
5454 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 173332"];
5455 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 173333"];
5456 [label="param ParseStatementCore(bool isGlobal) 173334"];
5457 [label="param ParseStatementCore(this) 173335"];
5458 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 173336"];
5459 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 173337"];
5460 [label="canReuseStatement(attributes, isGlobal) 173338"];
5461 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 173339"];
5462 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 173340"];
5463 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 173341"];
5464 [label="this.IsIncrementalAndFactoryContextMatches 173342"];
5465 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 173343"];
5466 [label="base.IsIncremental 173344"];
5467 [label="get\n            {\n                return _isIncremental;\n            } 173345"];
5468 [label="return _isIncremental; 173346"];
5469 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 173347"];
5470 [label="return false; 173348"];
5471 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 173349"];
5472 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 173350"];
5473 [label="this.GetResetPoint() 173351"];
5474 [label="param GetResetPoint(this) 173352"];
5475 [label="base.GetResetPoint() 173353"];
5476 [label="param GetResetPoint(this) 173354"];
5477 [label="CurrentTokenPosition 173355"];
5478 [label="=> _firstToken + _tokenOffset 173356"];
5479 [label="_firstToken + _tokenOffset 173357"];
5480 [label="var pos = CurrentTokenPosition; 173358"];
5481 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 173359"];
5482 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 173360"];
5483 [label="_resetStart 173361"];
5484 [label="_resetCount 173362"];
5485 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173363"];
5486 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173364"];
5487 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173365"];
5488 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173366"];
5489 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173367"];
5490 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173368"];
5491 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173369"];
5492 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 173370"];
5493 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 173371"];
5494 [label="param ResetPoint(TerminatorState terminatorState) 173372"];
5495 [label="param ResetPoint(bool isInTry) 173373"];
5496 [label="param ResetPoint(bool isInAsync) 173374"];
5497 [label="param ResetPoint(int queryDepth) 173375"];
5498 [label="param ResetPoint(this) 173376"];
5499 [label="this.BaseResetPoint 173377"];
5500 [label="this.TerminatorState 173378"];
5501 [label="this.IsInTry 173379"];
5502 [label="this.IsInAsync 173380"];
5503 [label="this.QueryDepth 173381"];
5504 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 173382"];
5505 [label="_recursionDepth 173383"];
5506 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 173384"];
5507 [label="StatementSyntax result; 173385"];
5508 [label="this.CurrentToken 173386"];
5509 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173387"];
5510 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173388"];
5511 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 173389"];
5512 [label="this.CurrentToken.Kind 173390"];
5513 [label="get { return (SyntaxKind)this.RawKind; } 173391"];
5514 [label="return (SyntaxKind)this.RawKind; 173392"];
5515 [label="return this.ParseSwitchStatement(attributes); 173393"];
5516 [label="this.ParseSwitchStatement(attributes) 173394"];
5517 [label="param ParseSwitchStatement(SyntaxList<AttributeListSyntax> attributes) 173395"];
5518 [label="param ParseSwitchStatement(this) 173396"];
5519 [label="this.CurrentToken 173397"];
5520 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173398"];
5521 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.SwitchKeyword); 173399"];
5522 [label="this.CurrentToken.Kind 173400"];
5523 [label="get { return (SyntaxKind)this.RawKind; } 173401"];
5524 [label="var @switch = this.EatToken(SyntaxKind.SwitchKeyword); 173402"];
5525 [label="this.EatToken(SyntaxKind.SwitchKeyword) 173403"];
5526 [label="param EatToken(SyntaxKind kind) 173404"];
5527 [label="param EatToken(this) 173405"];
5528 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 173406"];
5529 [label="SyntaxFacts.IsAnyToken(kind) 173407"];
5530 [label="param IsAnyToken(SyntaxKind kind) 173408"];
5531 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 173409"];
5532 [label="return true; 173410"];
5533 [label="this.CurrentToken 173411"];
5534 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173412"];
5535 [label="var ct = this.CurrentToken; 173413"];
5536 [label="ct.Kind 173414"];
5537 [label="get { return (SyntaxKind)this.RawKind; } 173415"];
5538 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 173416"];
5539 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 173417"];
5540 [label="MoveToNextToken() 173418"];
5541 [label="param MoveToNextToken(this) 173419"];
5542 [label="_currentToken.GetTrailingTrivia() 173420"];
5543 [label="param GetTrailingTrivia(this) 173421"];
5544 [label="return this.TrailingField; 173422"];
5545 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 173423"];
5546 [label="_prevTokenTrailingTrivia 173424"];
5547 [label="_currentToken = null; 173425"];
5548 [label="_currentToken 173426"];
5549 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173427"];
5550 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173428"];
5551 [label="_tokenOffset 173429"];
5552 [label="MoveToNextToken(); 173430"];
5553 [label="return ct; 173431"];
5554 [label="this.ParseExpressionCore() 173432"];
5555 [label="param ParseExpressionCore(this) 173433"];
5556 [label="return this.ParseSubExpression(Precedence.Expression); 173434"];
5557 [label="this.ParseSubExpression(Precedence.Expression) 173435"];
5558 [label="param ParseSubExpression(Precedence precedence) 173436"];
5559 [label="param ParseSubExpression(this) 173437"];
5560 [label="_recursionDepth 173438"];
5561 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 173439"];
5562 [label="var result = ParseSubExpressionCore(precedence); 173440"];
5563 [label="ParseSubExpressionCore(precedence) 173441"];
5564 [label="param ParseSubExpressionCore(Precedence precedence) 173442"];
5565 [label="param ParseSubExpressionCore(this) 173443"];
5566 [label="ExpressionSyntax leftOperand; 173444"];
5567 [label="Precedence newPrecedence = 0; 173445"];
5568 [label="this.CurrentToken 173446"];
5569 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173447"];
5570 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173448"];
5571 [label="return _lexedTokens[_tokenOffset]; 173449"];
5572 [label="var tk = this.CurrentToken.Kind; 173450"];
5573 [label="this.CurrentToken.Kind 173451"];
5574 [label="get { return (SyntaxKind)this.RawKind; } 173452"];
5575 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 173453"];
5576 [label="IsInvalidSubExpression(tk) 173454"];
5577 [label="param IsInvalidSubExpression(SyntaxKind kind) 173455"];
5578 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 173456"];
5579 [label="return false; 173457"];
5580 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173458"];
5581 [label="IsExpectedPrefixUnaryOperator(tk) 173459"];
5582 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 173460"];
5583 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 173461"];
5584 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 173462"];
5585 [label="param IsPrefixUnaryExpression(SyntaxKind token) 173463"];
5586 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 173464"];
5587 [label="GetPrefixUnaryExpression(token) 173465"];
5588 [label="param GetPrefixUnaryExpression(SyntaxKind token) 173466"];
5589 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 173467"];
5590 [label="return SyntaxKind.None; 173468"];
5591 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173469"];
5592 [label="IsAwaitExpression() 173470"];
5593 [label="param IsAwaitExpression(this) 173471"];
5594 [label="this.CurrentToken 173472"];
5595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173473"];
5596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 173474"];
5597 [label="this.CurrentToken.ContextualKind 173475"];
5598 [label="get\n            {\n                return this.Kind;\n            } 173476"];
5599 [label="this.Kind 173477"];
5600 [label="get { return (SyntaxKind)this.RawKind; } 173478"];
5601 [label="return this.Kind; 173479"];
5602 [label="return false; 173480"];
5603 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173481"];
5604 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173482"];
5605 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 173483"];
5606 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 173484"];
5607 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 173485"];
5608 [label="param IsQueryExpression(this) 173486"];
5609 [label="this.CurrentToken 173487"];
5610 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173488"];
5611 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 173489"];
5612 [label="this.CurrentToken.ContextualKind 173490"];
5613 [label="get\n            {\n                return this.Kind;\n            } 173491"];
5614 [label="this.Kind 173492"];
5615 [label="get { return (SyntaxKind)this.RawKind; } 173493"];
5616 [label="return this.Kind; 173494"];
5617 [label="return false; 173495"];
5618 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173496"];
5619 [label="this.CurrentToken 173497"];
5620 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173498"];
5621 [label="this.CurrentToken.ContextualKind 173499"];
5622 [label="get\n            {\n                return this.Kind;\n            } 173500"];
5623 [label="this.Kind 173501"];
5624 [label="get { return (SyntaxKind)this.RawKind; } 173502"];
5625 [label="return this.Kind; 173503"];
5626 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173504"];
5627 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 173505"];
5628 [label="this.IsPossibleDeconstructionLeft(precedence) 173506"];
5629 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 173507"];
5630 [label="param IsPossibleDeconstructionLeft(this) 173508"];
5631 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 173509"];
5632 [label="this.CurrentToken 173510"];
5633 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173511"];
5634 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 173512"];
5635 [label="this.CurrentToken.IsIdentifierVar() 173513"];
5636 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 173514"];
5637 [label="node.ContextualKind 173515"];
5638 [label="get\n            {\n                return this.Kind;\n            } 173516"];
5639 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 173517"];
5640 [label="this.CurrentToken 173518"];
5641 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173519"];
5642 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 173520"];
5643 [label="this.CurrentToken.Kind 173521"];
5644 [label="get { return (SyntaxKind)this.RawKind; } 173522"];
5645 [label="IsPredefinedType(this.CurrentToken.Kind) 173523"];
5646 [label="param IsPredefinedType(SyntaxKind keyword) 173524"];
5647 [label="return SyntaxFacts.IsPredefinedType(keyword); 173525"];
5648 [label="SyntaxFacts.IsPredefinedType(keyword) 173526"];
5649 [label="param IsPredefinedType(SyntaxKind kind) 173527"];
5650 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 173528"];
5651 [label="return false; 173529"];
5652 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 173530"];
5653 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 173531"];
5654 [label="return false; 173532"];
5655 [label="leftOperand = this.ParseTerm(precedence); 173533"];
5656 [label="this.ParseTerm(precedence) 173534"];
5657 [label="param ParseTerm(Precedence precedence) 173535"];
5658 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 173536"];
5659 [label="precedence 173537"];
5660 [label="ParseTermWithoutPostfix(precedence) 173538"];
5661 [label="param ParseTermWithoutPostfix(Precedence precedence) 173539"];
5662 [label="param ParseTermWithoutPostfix(this) 173540"];
5663 [label="this.CurrentToken 173541"];
5664 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173542"];
5665 [label="var tk = this.CurrentToken.Kind; 173543"];
5666 [label="this.CurrentToken.Kind 173544"];
5667 [label="get { return (SyntaxKind)this.RawKind; } 173545"];
5668 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 173546"];
5669 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 173547"];
5670 [label="this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence) 173548"];
5671 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(Precedence precedence) 173549"];
5672 [label="param ParseCastOrParenExpressionOrLambdaOrTuple(this) 173550"];
5673 [label="this.CurrentToken 173551"];
5674 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173552"];
5675 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.OpenParenToken); 173553"];
5676 [label="this.CurrentToken.Kind 173554"];
5677 [label="get { return (SyntaxKind)this.RawKind; } 173555"];
5678 [label="this.GetResetPoint() 173556"];
5679 [label="param GetResetPoint(this) 173557"];
5680 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173558"];
5681 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173559"];
5682 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 173560"];
5683 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 173561"];
5684 [label="param ResetPoint(TerminatorState terminatorState) 173562"];
5685 [label="param ResetPoint(bool isInTry) 173563"];
5686 [label="param ResetPoint(bool isInAsync) 173564"];
5687 [label="param ResetPoint(int queryDepth) 173565"];
5688 [label="param ResetPoint(this) 173566"];
5689 [label="this.BaseResetPoint 173567"];
5690 [label="this.TerminatorState 173568"];
5691 [label="this.IsInTry 173569"];
5692 [label="this.IsInAsync 173570"];
5693 [label="this.QueryDepth 173571"];
5694 [label="var resetPoint = this.GetResetPoint(); 173572"];
5695 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 173573"];
5696 [label="ScanParenthesizedImplicitlyTypedLambda(precedence) 173574"];
5697 [label="param ScanParenthesizedImplicitlyTypedLambda(Precedence precedence) 173575"];
5698 [label="param ScanParenthesizedImplicitlyTypedLambda(this) 173576"];
5699 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 173577"];
5700 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 173578"];
5701 [label="this.PeekToken(1) 173579"];
5702 [label="param PeekToken(int n) 173580"];
5703 [label="param PeekToken(this) 173581"];
5704 [label="Debug.Assert(n >= 0); 173582"];
5705 [label="Debug.Assert(n >= 0); 173583"];
5706 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173584"];
5707 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173585"];
5708 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173586"];
5709 [label="return _lexedTokens[_tokenOffset + n]; 173587"];
5710 [label="this.PeekToken(1).Kind 173588"];
5711 [label="get { return (SyntaxKind)this.RawKind; } 173589"];
5712 [label="this.IsInQuery 173590"];
5713 [label="get { return _syntaxFactoryContext.IsInQuery; } 173591"];
5714 [label="return _syntaxFactoryContext.IsInQuery; 173592"];
5715 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 173593"];
5716 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 173594"];
5717 [label="this.PeekToken(2) 173595"];
5718 [label="param PeekToken(int n) 173596"];
5719 [label="param PeekToken(this) 173597"];
5720 [label="Debug.Assert(n >= 0); 173598"];
5721 [label="Debug.Assert(n >= 0); 173599"];
5722 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173600"];
5723 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173601"];
5724 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173602"];
5725 [label="return _lexedTokens[_tokenOffset + n]; 173603"];
5726 [label="this.PeekToken(2).Kind 173604"];
5727 [label="get { return (SyntaxKind)this.RawKind; } 173605"];
5728 [label="if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken\n                && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))\n                && this.PeekToken(2).Kind == SyntaxKind.CommaToken)\n            {\n                // Make sure it really looks like a lambda, not just a tuple\n                int curTk = 3;\n                while (true)\n                {\n                    var tk = this.PeekToken(curTk++);\n\n                    // skip  identifiers commas and predefined types in any combination for error recovery\n                    if (tk.Kind != SyntaxKind.IdentifierToken\n                        && !SyntaxFacts.IsPredefinedType(tk.Kind)\n                        && tk.Kind != SyntaxKind.CommaToken\n                        && (this.IsInQuery || !IsTokenQueryContextualKeyword(tk)))\n                    {\n                        break;\n                    };\n                }\n\n                // ) =>\n                return this.PeekToken(curTk - 1).Kind == SyntaxKind.CloseParenToken &&\n                       this.PeekToken(curTk).Kind == SyntaxKind.EqualsGreaterThanToken;\n            } 173606"];
5729 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 173607"];
5730 [label="this.PeekToken(1) 173608"];
5731 [label="param PeekToken(int n) 173609"];
5732 [label="param PeekToken(this) 173610"];
5733 [label="Debug.Assert(n >= 0); 173611"];
5734 [label="Debug.Assert(n >= 0); 173612"];
5735 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173613"];
5736 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173614"];
5737 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173615"];
5738 [label="return _lexedTokens[_tokenOffset + n]; 173616"];
5739 [label="IsTrueIdentifier(this.PeekToken(1)) 173617"];
5740 [label="param IsTrueIdentifier(SyntaxToken token) 173618"];
5741 [label="param IsTrueIdentifier(this) 173619"];
5742 [label="token.Kind 173620"];
5743 [label="get { return (SyntaxKind)this.RawKind; } 173621"];
5744 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 173622"];
5745 [label="this.IsInQuery 173623"];
5746 [label="get { return _syntaxFactoryContext.IsInQuery; } 173624"];
5747 [label="return _syntaxFactoryContext.IsInQuery; 173625"];
5748 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 173626"];
5749 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 173627"];
5750 [label="this.PeekToken(2) 173628"];
5751 [label="param PeekToken(int n) 173629"];
5752 [label="param PeekToken(this) 173630"];
5753 [label="Debug.Assert(n >= 0); 173631"];
5754 [label="Debug.Assert(n >= 0); 173632"];
5755 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173633"];
5756 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173634"];
5757 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173635"];
5758 [label="return _lexedTokens[_tokenOffset + n]; 173636"];
5759 [label="this.PeekToken(2).Kind 173637"];
5760 [label="get { return (SyntaxKind)this.RawKind; } 173638"];
5761 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 173639"];
5762 [label="this.PeekToken(3) 173640"];
5763 [label="param PeekToken(int n) 173641"];
5764 [label="param PeekToken(this) 173642"];
5765 [label="Debug.Assert(n >= 0); 173643"];
5766 [label="Debug.Assert(n >= 0); 173644"];
5767 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173645"];
5768 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173646"];
5769 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173647"];
5770 [label="return _lexedTokens[_tokenOffset + n]; 173648"];
5771 [label="this.PeekToken(3).Kind 173649"];
5772 [label="get { return (SyntaxKind)this.RawKind; } 173650"];
5773 [label="if (IsTrueIdentifier(this.PeekToken(1))\n                && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 173651"];
5774 [label="if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken\n                && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                return true;\n            } 173652"];
5775 [label="this.PeekToken(1) 173653"];
5776 [label="param PeekToken(int n) 173654"];
5777 [label="param PeekToken(this) 173655"];
5778 [label="Debug.Assert(n >= 0); 173656"];
5779 [label="Debug.Assert(n >= 0); 173657"];
5780 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173658"];
5781 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173659"];
5782 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173660"];
5783 [label="return _lexedTokens[_tokenOffset + n]; 173661"];
5784 [label="this.PeekToken(1).Kind 173662"];
5785 [label="get { return (SyntaxKind)this.RawKind; } 173663"];
5786 [label="if (this.PeekToken(1).Kind == SyntaxKind.ParamsKeyword)\n            {\n                return true;\n            } 173664"];
5787 [label="this.PeekToken(1) 173665"];
5788 [label="param PeekToken(int n) 173666"];
5789 [label="param PeekToken(this) 173667"];
5790 [label="Debug.Assert(n >= 0); 173668"];
5791 [label="Debug.Assert(n >= 0); 173669"];
5792 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173670"];
5793 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173671"];
5794 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173672"];
5795 [label="return _lexedTokens[_tokenOffset + n]; 173673"];
5796 [label="this.PeekToken(1).Kind 173674"];
5797 [label="get { return (SyntaxKind)this.RawKind; } 173675"];
5798 [label="return false; 173676"];
5799 [label="if (ScanParenthesizedImplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 173677"];
5800 [label="if (this.ScanCast())\n                {\n                    if (!IsCurrentTokenQueryKeywordInQuery())\n                    {\n                        // Looks like a cast, so parse it as one.\n                        this.Reset(ref resetPoint);\n                        var openParen = this.EatToken(SyntaxKind.OpenParenToken);\n                        var type = this.ParseType();\n                        var closeParen = this.EatToken(SyntaxKind.CloseParenToken);\n                        var expr = this.ParseSubExpression(Precedence.Cast);\n                        return _syntaxFactory.CastExpression(openParen, type, closeParen, expr);\n                    }\n                } 173678"];
5801 [label="this.ScanCast() 173679"];
5802 [label="param ScanCast(bool forPattern = false) 173680"];
5803 [label="param ScanCast(this) 173681"];
5804 [label="this.CurrentToken 173682"];
5805 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173683"];
5806 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173684"];
5807 [label="if (this.CurrentToken.Kind != SyntaxKind.OpenParenToken)\n            {\n                return false;\n            } 173685"];
5808 [label="this.CurrentToken.Kind 173686"];
5809 [label="get { return (SyntaxKind)this.RawKind; } 173687"];
5810 [label="this.EatToken() 173688"];
5811 [label="param EatToken(this) 173689"];
5812 [label="this.CurrentToken 173690"];
5813 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173691"];
5814 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173692"];
5815 [label="var ct = this.CurrentToken; 173693"];
5816 [label="MoveToNextToken() 173694"];
5817 [label="param MoveToNextToken(this) 173695"];
5818 [label="param GetTrailingTrivia(this) 173696"];
5819 [label="return null; 173697"];
5820 [label="_prevTokenTrailingTrivia 173698"];
5821 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173699"];
5822 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173700"];
5823 [label="_tokenOffset 173701"];
5824 [label="MoveToNextToken(); 173702"];
5825 [label="return ct; 173703"];
5826 [label="this.EatToken(); 173704"];
5827 [label="var type = this.ScanType(forPattern: forPattern); 173705"];
5828 [label="this.ScanType(forPattern: forPattern) 173706"];
5829 [label="param ScanType(bool forPattern = false) 173707"];
5830 [label="param ScanType(this) 173708"];
5831 [label="return ScanType(out _, forPattern); 173709"];
5832 [label="return ScanType(out _, forPattern); 173710"];
5833 [label="ScanType(out _, forPattern) 173711"];
5834 [label="param ScanType(out SyntaxToken lastTokenOfType) 173712"];
5835 [label="param ScanType(bool forPattern = false) 173713"];
5836 [label="param ScanType(this) 173714"];
5837 [label="forPattern 173715"];
5838 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173716"];
5839 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173717"];
5840 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173718"];
5841 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173719"];
5842 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173720"];
5843 [label="param PeekToken(int n) 173721"];
5844 [label="param PeekToken(this) 173722"];
5845 [label="Debug.Assert(n >= 0); 173723"];
5846 [label="Debug.Assert(n >= 0); 173724"];
5847 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173725"];
5848 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173726"];
5849 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173727"];
5850 [label="return _lexedTokens[_tokenOffset + n]; 173728"];
5851 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 173729"];
5852 [label="param ScanNamedTypePart(this) 173730"];
5853 [label="this.CurrentToken 173731"];
5854 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173732"];
5855 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173733"];
5856 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173734"];
5857 [label="this.CurrentToken.Kind 173735"];
5858 [label="get { return (SyntaxKind)this.RawKind; } 173736"];
5859 [label="this.IsTrueIdentifier() 173737"];
5860 [label="param IsTrueIdentifier(this) 173738"];
5861 [label="this.CurrentToken 173739"];
5862 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173740"];
5863 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173741"];
5864 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 173742"];
5865 [label="this.CurrentToken.Kind 173743"];
5866 [label="get { return (SyntaxKind)this.RawKind; } 173744"];
5867 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 173745"];
5868 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 173746"];
5869 [label="this.CurrentToken 173747"];
5870 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173748"];
5871 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 173749"];
5872 [label="this.CurrentToken.ContextualKind 173750"];
5873 [label="get\n            {\n                return this.Kind;\n            } 173751"];
5874 [label="return false; 173752"];
5875 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173753"];
5876 [label="IsCurrentTokenQueryKeywordInQuery() 173754"];
5877 [label="param IsCurrentTokenQueryKeywordInQuery(this) 173755"];
5878 [label="this.IsInQuery 173756"];
5879 [label="get { return _syntaxFactoryContext.IsInQuery; } 173757"];
5880 [label="return _syntaxFactoryContext.IsInQuery; 173758"];
5881 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 173759"];
5882 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173760"];
5883 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173761"];
5884 [label="IsCurrentTokenWhereOfConstraintClause() 173762"];
5885 [label="param IsCurrentTokenWhereOfConstraintClause(this) 173763"];
5886 [label="this.CurrentToken 173764"];
5887 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173765"];
5888 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 173766"];
5889 [label="this.CurrentToken.ContextualKind 173767"];
5890 [label="get\n            {\n                return this.Kind;\n            } 173768"];
5891 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173769"];
5892 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173770"];
5893 [label="return true; 173771"];
5894 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173772"];
5895 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173773"];
5896 [label="this.EatToken() 173774"];
5897 [label="param EatToken(this) 173775"];
5898 [label="this.CurrentToken 173776"];
5899 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173777"];
5900 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173778"];
5901 [label="var ct = this.CurrentToken; 173779"];
5902 [label="MoveToNextToken() 173780"];
5903 [label="param GetTrailingTrivia(this) 173781"];
5904 [label="return null; 173782"];
5905 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173783"];
5906 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173784"];
5907 [label="_tokenOffset 173785"];
5908 [label="MoveToNextToken(); 173786"];
5909 [label="return ct; 173787"];
5910 [label="lastTokenOfType = this.EatToken(); 173788"];
5911 [label="this.CurrentToken 173789"];
5912 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173790"];
5913 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173791"];
5914 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 173792"];
5915 [label="return _lexedTokens[_tokenOffset]; 173793"];
5916 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 173794"];
5917 [label="this.CurrentToken.Kind 173795"];
5918 [label="get { return (SyntaxKind)this.RawKind; } 173796"];
5919 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 173797"];
5920 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173798"];
5921 [label="param IsDotOrColonColon(this) 173799"];
5922 [label="this.CurrentToken 173800"];
5923 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173801"];
5924 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173802"];
5925 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 173803"];
5926 [label="this.CurrentToken.Kind 173804"];
5927 [label="get { return (SyntaxKind)this.RawKind; } 173805"];
5928 [label="this.CurrentToken 173806"];
5929 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173807"];
5930 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173808"];
5931 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 173809"];
5932 [label="this.CurrentToken.Kind 173810"];
5933 [label="get { return (SyntaxKind)this.RawKind; } 173811"];
5934 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 173812"];
5935 [label="param IsMakingProgress(ref int lastTokenPosition) 173813"];
5936 [label="param IsMakingProgress(bool assertIfFalse = true) 173814"];
5937 [label="param IsMakingProgress(this) 173815"];
5938 [label="CurrentTokenPosition 173816"];
5939 [label="=> _firstToken + _tokenOffset 173817"];
5940 [label="_firstToken + _tokenOffset 173818"];
5941 [label="var pos = CurrentTokenPosition; 173819"];
5942 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 173820"];
5943 [label="lastTokenPosition = pos; 173821"];
5944 [label="return true; 173822"];
5945 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173823"];
5946 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173824"];
5947 [label="if (type == ScanTypeFlags.NotType)\n            {\n                return false;\n            } 173825"];
5948 [label="this.CurrentToken 173826"];
5949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173827"];
5950 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173828"];
5951 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n            {\n                return false;\n            } 173829"];
5952 [label="this.CurrentToken.Kind 173830"];
5953 [label="get { return (SyntaxKind)this.RawKind; } 173831"];
5954 [label="this.EatToken() 173832"];
5955 [label="param EatToken(this) 173833"];
5956 [label="this.CurrentToken 173834"];
5957 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173835"];
5958 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173836"];
5959 [label="MoveToNextToken() 173837"];
5960 [label="param MoveToNextToken(this) 173838"];
5961 [label="param GetTrailingTrivia(this) 173839"];
5962 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173840"];
5963 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173841"];
5964 [label="_tokenOffset 173842"];
5965 [label="MoveToNextToken(); 173843"];
5966 [label="this.EatToken(); 173844"];
5967 [label="switch (type)\n            {\n                // If we have any of the following, we know it must be a cast:\n                // 1) (Goo*)bar;\n                // 2) (Goo?)bar;\n                // 3) '(int)bar' or '(int[])bar'\n                // 4) (G::Goo)bar\n                case ScanTypeFlags.PointerOrMultiplication:\n                case ScanTypeFlags.NullableType:\n                case ScanTypeFlags.MustBeType:\n                case ScanTypeFlags.AliasQualifiedName:\n                    // The thing between parens is unambiguously a type.\n                    // In a pattern, we need more lookahead to confirm it is a cast and not\n                    // a parenthesized type pattern.  In this case the tokens that\n                    // have both unary and binary operator forms may appear in their unary form\n                    // following a cast.\n                    return !forPattern || this.CurrentToken.Kind switch\n                    {\n                        SyntaxKind.PlusToken => true,\n                        SyntaxKind.MinusToken => true,\n                        SyntaxKind.AmpersandToken => true,\n                        SyntaxKind.AsteriskToken => true,\n                        SyntaxKind.DotDotToken => true,\n                        _ => CanFollowCast(this.CurrentToken.Kind)\n                    };\n\n                case ScanTypeFlags.GenericTypeOrMethod:\n                case ScanTypeFlags.GenericTypeOrExpression:\n                case ScanTypeFlags.NonGenericTypeOrExpression:\n                case ScanTypeFlags.TupleType:\n                    // check for ambiguous type or expression followed by disambiguating token.  i.e.\n                    //\n                    // '(A)b' is a cast.  But '(A)+b' is not a cast.  \n                    return CanFollowCast(this.CurrentToken.Kind);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type);\n            } 173845"];
5968 [label="this.CurrentToken 173846"];
5969 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173847"];
5970 [label="return _lexedTokens[_tokenOffset]; 173848"];
5971 [label="return CanFollowCast(this.CurrentToken.Kind); 173849"];
5972 [label="this.CurrentToken.Kind 173850"];
5973 [label="get { return (SyntaxKind)this.RawKind; } 173851"];
5974 [label="CanFollowCast(this.CurrentToken.Kind) 173852"];
5975 [label="param CanFollowCast(SyntaxKind kind) 173853"];
5976 [label="switch (kind)\n            {\n                case SyntaxKind.AsKeyword:\n                case SyntaxKind.IsKeyword:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.EqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.QuestionToken:\n                case SyntaxKind.ColonToken:\n                case SyntaxKind.BarBarToken:\n                case SyntaxKind.AmpersandAmpersandToken:\n                case SyntaxKind.BarToken:\n                case SyntaxKind.CaretToken:\n                case SyntaxKind.AmpersandToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.LessThanLessThanToken:\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                case SyntaxKind.PlusToken:\n                case SyntaxKind.MinusToken:\n                case SyntaxKind.AsteriskToken:\n                case SyntaxKind.SlashToken:\n                case SyntaxKind.PercentToken:\n                case SyntaxKind.PlusPlusToken:\n                case SyntaxKind.MinusMinusToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.DotToken:\n                case SyntaxKind.MinusGreaterThanToken:\n                case SyntaxKind.QuestionQuestionToken:\n                case SyntaxKind.EndOfFileToken:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.EqualsGreaterThanToken:\n                case SyntaxKind.DotDotToken:\n                    return false;\n                default:\n                    return true;\n            } 173854"];
5977 [label="return false; 173855"];
5978 [label="this.Reset(ref resetPoint); 173856"];
5979 [label="this.Reset(ref resetPoint) 173857"];
5980 [label="param Reset(ref ResetPoint state) 173858"];
5981 [label="param Reset(this) 173859"];
5982 [label="_termState 173860"];
5983 [label="_isInTry 173861"];
5984 [label="_syntaxFactoryContext.IsInAsync 173862"];
5985 [label="_syntaxFactoryContext.QueryDepth 173863"];
5986 [label="base.Reset(ref state.BaseResetPoint); 173864"];
5987 [label="base.Reset(ref state.BaseResetPoint) 173865"];
5988 [label="param Reset(ref ResetPoint point) 173866"];
5989 [label="param Reset(this) 173867"];
5990 [label="var offset = point.Position - _firstToken; 173868"];
5991 [label="Debug.Assert(offset >= 0); 173869"];
5992 [label="Debug.Assert(offset >= 0); 173870"];
5993 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 173871"];
5994 [label="_mode 173872"];
5995 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 173873"];
5996 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 173874"];
5997 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 173875"];
5998 [label="_tokenOffset 173876"];
5999 [label="_currentToken = null; 173877"];
6000 [label="_currentToken 173878"];
6001 [label="_currentNode = default(BlendedNode); 173879"];
6002 [label="_currentNode 173880"];
6003 [label="_prevTokenTrailingTrivia 173881"];
6004 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 173882"];
6005 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 173883"];
6006 [label="base.Reset(ref state.BaseResetPoint); 173884"];
6007 [label="this.Reset(ref resetPoint); 173885"];
6008 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 173886"];
6009 [label="this.ScanExplicitlyTypedLambda(precedence) 173887"];
6010 [label="param ScanExplicitlyTypedLambda(Precedence precedence) 173888"];
6011 [label="param ScanExplicitlyTypedLambda(this) 173889"];
6012 [label="if (!(precedence <= Precedence.Lambda))\n            {\n                return false;\n            } 173890"];
6013 [label="this.GetResetPoint() 173891"];
6014 [label="param GetResetPoint(this) 173892"];
6015 [label="_firstToken + _tokenOffset 173893"];
6016 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 173894"];
6017 [label="_resetCount 173895"];
6018 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173896"];
6019 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173897"];
6020 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 173898"];
6021 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 173899"];
6022 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 173900"];
6023 [label="param ResetPoint(this) 173901"];
6024 [label="var resetPoint = this.GetResetPoint(); 173902"];
6025 [label="bool foundParameterModifier = false; 173903"];
6026 [label="while (true)\n                {\n                    // Advance past the open paren or comma.\n                    this.EatToken();\n\n                    // Eat 'out' or 'ref' for cases [3, 6]. Even though not allowed in a lambda,\n                    // we treat `params` similarly for better error recovery.\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    }\n\n                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    }\n\n                    // NOTE: advances CurrentToken\n                    if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    }\n\n                    if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    }\n\n                    switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    }\n                } 173904"];
6027 [label="this.EatToken() 173905"];
6028 [label="param EatToken(this) 173906"];
6029 [label="this.CurrentToken 173907"];
6030 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173908"];
6031 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173909"];
6032 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 173910"];
6033 [label="MoveToNextToken() 173911"];
6034 [label="param MoveToNextToken(this) 173912"];
6035 [label="param GetTrailingTrivia(this) 173913"];
6036 [label="return null; 173914"];
6037 [label="_prevTokenTrailingTrivia 173915"];
6038 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173916"];
6039 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 173917"];
6040 [label="_tokenOffset 173918"];
6041 [label="MoveToNextToken(); 173919"];
6042 [label="this.EatToken(); 173920"];
6043 [label="this.CurrentToken 173921"];
6044 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173922"];
6045 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173923"];
6046 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 173924"];
6047 [label="return _lexedTokens[_tokenOffset]; 173925"];
6048 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.RefKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                            {\n                                this.EatToken();\n                            }\n                            break;\n                        case SyntaxKind.OutKeyword:\n                        case SyntaxKind.InKeyword:\n                        case SyntaxKind.ParamsKeyword:\n                            this.EatToken();\n                            foundParameterModifier = true;\n                            break;\n                    } 173926"];
6049 [label="this.CurrentToken.Kind 173927"];
6050 [label="get { return (SyntaxKind)this.RawKind; } 173928"];
6051 [label="this.CurrentToken 173929"];
6052 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173930"];
6053 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 173931"];
6054 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n                    {\n                        return foundParameterModifier;\n                    } 173932"];
6055 [label="this.CurrentToken.Kind 173933"];
6056 [label="get { return (SyntaxKind)this.RawKind; } 173934"];
6057 [label="if (this.ScanType() == ScanTypeFlags.NotType)\n                    {\n                        return false;\n                    } 173935"];
6058 [label="this.ScanType() 173936"];
6059 [label="param ScanType(bool forPattern = false) 173937"];
6060 [label="param ScanType(this) 173938"];
6061 [label="return ScanType(out _, forPattern); 173939"];
6062 [label="return ScanType(out _, forPattern); 173940"];
6063 [label="ScanType(out _, forPattern) 173941"];
6064 [label="param ScanType(out SyntaxToken lastTokenOfType) 173942"];
6065 [label="param ScanType(bool forPattern = false) 173943"];
6066 [label="param ScanType(this) 173944"];
6067 [label="forPattern 173945"];
6068 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173946"];
6069 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173947"];
6070 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173948"];
6071 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 173949"];
6072 [label="Debug.Assert(n >= 0); 173950"];
6073 [label="Debug.Assert(n >= 0); 173951"];
6074 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 173952"];
6075 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 173953"];
6076 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 173954"];
6077 [label="this.CurrentToken 173955"];
6078 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173956"];
6079 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173957"];
6080 [label="this.CurrentToken.Kind 173958"];
6081 [label="get { return (SyntaxKind)this.RawKind; } 173959"];
6082 [label="this.IsTrueIdentifier() 173960"];
6083 [label="param IsTrueIdentifier(this) 173961"];
6084 [label="this.CurrentToken 173962"];
6085 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173963"];
6086 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 173964"];
6087 [label="this.CurrentToken.Kind 173965"];
6088 [label="get { return (SyntaxKind)this.RawKind; } 173966"];
6089 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 173967"];
6090 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 173968"];
6091 [label="this.CurrentToken 173969"];
6092 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173970"];
6093 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 173971"];
6094 [label="this.CurrentToken.ContextualKind 173972"];
6095 [label="get\n            {\n                return this.Kind;\n            } 173973"];
6096 [label="return false; 173974"];
6097 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173975"];
6098 [label="IsCurrentTokenQueryKeywordInQuery() 173976"];
6099 [label="param IsCurrentTokenQueryKeywordInQuery(this) 173977"];
6100 [label="this.IsInQuery 173978"];
6101 [label="get { return _syntaxFactoryContext.IsInQuery; } 173979"];
6102 [label="return _syntaxFactoryContext.IsInQuery; 173980"];
6103 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 173981"];
6104 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173982"];
6105 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173983"];
6106 [label="IsCurrentTokenWhereOfConstraintClause() 173984"];
6107 [label="param IsCurrentTokenWhereOfConstraintClause(this) 173985"];
6108 [label="this.CurrentToken 173986"];
6109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 173987"];
6110 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 173988"];
6111 [label="this.CurrentToken.ContextualKind 173989"];
6112 [label="get\n            {\n                return this.Kind;\n            } 173990"];
6113 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173991"];
6114 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 173992"];
6115 [label="return true; 173993"];
6116 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173994"];
6117 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 173995"];
6118 [label="this.EatToken() 173996"];
6119 [label="this.CurrentToken 173997"];
6120 [label="MoveToNextToken() 173998"];
6121 [label="param GetTrailingTrivia(this) 173999"];
6122 [label="return null; 174000"];
6123 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174001"];
6124 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174002"];
6125 [label="MoveToNextToken(); 174003"];
6126 [label="this.CurrentToken 174004"];
6127 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174005"];
6128 [label="this.CurrentToken.Kind 174006"];
6129 [label="this.CurrentToken 174007"];
6130 [label="this.CurrentToken.Kind 174008"];
6131 [label="this.CurrentToken 174009"];
6132 [label="this.CurrentToken.Kind 174010"];
6133 [label="param IsMakingProgress(bool assertIfFalse = true) 174011"];
6134 [label="CurrentTokenPosition 174012"];
6135 [label="this.IsTrueIdentifier() 174013"];
6136 [label="param IsTrueIdentifier(this) 174014"];
6137 [label="this.CurrentToken 174015"];
6138 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174016"];
6139 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174017"];
6140 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 174018"];
6141 [label="this.CurrentToken.Kind 174019"];
6142 [label="get { return (SyntaxKind)this.RawKind; } 174020"];
6143 [label="return false; 174021"];
6144 [label="if (this.IsTrueIdentifier())\n                    {\n                        // eat the identifier\n                        this.EatToken();\n                    } 174022"];
6145 [label="this.CurrentToken 174023"];
6146 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174024"];
6147 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174025"];
6148 [label="switch (this.CurrentToken.Kind)\n                    {\n                        case SyntaxKind.EndOfFileToken:\n                            return foundParameterModifier;\n\n                        case SyntaxKind.CommaToken:\n                            if (foundParameterModifier)\n                            {\n                                return true;\n                            }\n\n                            continue;\n\n                        case SyntaxKind.CloseParenToken:\n                            return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken;\n\n                        default:\n                            return false;\n                    } 174026"];
6149 [label="this.CurrentToken.Kind 174027"];
6150 [label="get { return (SyntaxKind)this.RawKind; } 174028"];
6151 [label="return this.PeekToken(1).Kind == SyntaxKind.EqualsGreaterThanToken; 174029"];
6152 [label="this.PeekToken(1) 174030"];
6153 [label="param PeekToken(int n) 174031"];
6154 [label="Debug.Assert(n >= 0); 174032"];
6155 [label="Debug.Assert(n >= 0); 174033"];
6156 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174034"];
6157 [label="this.PeekToken(1).Kind 174035"];
6158 [label="get { return (SyntaxKind)this.RawKind; } 174036"];
6159 [label="this.Reset(ref resetPoint); 174037"];
6160 [label="this.Reset(ref resetPoint) 174038"];
6161 [label="param Reset(ref ResetPoint state) 174039"];
6162 [label="Debug.Assert(offset >= 0); 174040"];
6163 [label="Debug.Assert(offset >= 0); 174041"];
6164 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 174042"];
6165 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174043"];
6166 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174044"];
6167 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174045"];
6168 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 174046"];
6169 [label="this.Reset(ref resetPoint); 174047"];
6170 [label="this.Release(ref resetPoint); 174048"];
6171 [label="this.Release(ref resetPoint) 174049"];
6172 [label="param Release(ref ResetPoint state) 174050"];
6173 [label="param Release(this) 174051"];
6174 [label="base.Release(ref state.BaseResetPoint); 174052"];
6175 [label="base.Release(ref state.BaseResetPoint) 174053"];
6176 [label="param Release(ref ResetPoint point) 174054"];
6177 [label="param Release(this) 174055"];
6178 [label="Debug.Assert(_resetCount == point.ResetCount); 174056"];
6179 [label="_resetCount 174057"];
6180 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 174058"];
6181 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 174059"];
6182 [label="base.Release(ref state.BaseResetPoint); 174060"];
6183 [label="this.Release(ref resetPoint); 174061"];
6184 [label="if (this.ScanExplicitlyTypedLambda(precedence))\n                {\n                    return this.ParseLambdaExpression();\n                } 174062"];
6185 [label="this.Reset(ref resetPoint); 174063"];
6186 [label="this.Reset(ref resetPoint) 174064"];
6187 [label="param Reset(ref ResetPoint state) 174065"];
6188 [label="param Reset(this) 174066"];
6189 [label="_termState 174067"];
6190 [label="_isInTry 174068"];
6191 [label="_syntaxFactoryContext.IsInAsync 174069"];
6192 [label="_syntaxFactoryContext.QueryDepth 174070"];
6193 [label="base.Reset(ref state.BaseResetPoint); 174071"];
6194 [label="base.Reset(ref state.BaseResetPoint) 174072"];
6195 [label="param Reset(this) 174073"];
6196 [label="var offset = point.Position - _firstToken; 174074"];
6197 [label="Debug.Assert(offset >= 0); 174075"];
6198 [label="Debug.Assert(offset >= 0); 174076"];
6199 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 174077"];
6200 [label="_mode 174078"];
6201 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174079"];
6202 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174080"];
6203 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174081"];
6204 [label="_currentToken = null; 174082"];
6205 [label="_currentToken 174083"];
6206 [label="_currentNode = default(BlendedNode); 174084"];
6207 [label="_currentNode 174085"];
6208 [label="_prevTokenTrailingTrivia 174086"];
6209 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 174087"];
6210 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 174088"];
6211 [label="base.Reset(ref state.BaseResetPoint); 174089"];
6212 [label="this.Reset(ref resetPoint); 174090"];
6213 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 174091"];
6214 [label="this.EatToken(SyntaxKind.OpenParenToken) 174092"];
6215 [label="param EatToken(SyntaxKind kind) 174093"];
6216 [label="param EatToken(this) 174094"];
6217 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 174095"];
6218 [label="SyntaxFacts.IsAnyToken(kind) 174096"];
6219 [label="param IsAnyToken(SyntaxKind kind) 174097"];
6220 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 174098"];
6221 [label="return true; 174099"];
6222 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174100"];
6223 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 174101"];
6224 [label="return _lexedTokens[_tokenOffset]; 174102"];
6225 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 174103"];
6226 [label="param GetTrailingTrivia(this) 174104"];
6227 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174105"];
6228 [label="MoveToNextToken(); 174106"];
6229 [label="return ct; 174107"];
6230 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 174108"];
6231 [label="var expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true); 174109"];
6232 [label="this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true) 174110"];
6233 [label="param ParseExpressionOrDeclaration(ParseTypeMode mode) 174111"];
6234 [label="param ParseExpressionOrDeclaration(MessageID feature) 174112"];
6235 [label="param ParseExpressionOrDeclaration(bool permitTupleDesignation) 174113"];
6236 [label="param ParseExpressionOrDeclaration(this) 174114"];
6237 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 174115"];
6238 [label="return IsPossibleDeclarationExpression(mode, permitTupleDesignation)\n                ? this.ParseDeclarationExpression(mode, feature)\n                : this.ParseSubExpression(Precedence.Expression); 174116"];
6239 [label="IsPossibleDeclarationExpression(mode, permitTupleDesignation) 174117"];
6240 [label="param IsPossibleDeclarationExpression(ParseTypeMode mode) 174118"];
6241 [label="param IsPossibleDeclarationExpression(bool permitTupleDesignation) 174119"];
6242 [label="param IsPossibleDeclarationExpression(this) 174120"];
6243 [label="this.IsInAsync 174121"];
6244 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 174122"];
6245 [label="return _syntaxFactoryContext.IsInAsync; 174123"];
6246 [label="if (this.IsInAsync && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                // can't be a declaration expression.\n                return false;\n            } 174124"];
6247 [label="this.GetResetPoint() 174125"];
6248 [label="param GetResetPoint(this) 174126"];
6249 [label="_firstToken + _tokenOffset 174127"];
6250 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 174128"];
6251 [label="_resetCount 174129"];
6252 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 174130"];
6253 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 174131"];
6254 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 174132"];
6255 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 174133"];
6256 [label="param ResetPoint(this) 174134"];
6257 [label="var resetPoint = this.GetResetPoint(); 174135"];
6258 [label="IsVarType() 174136"];
6259 [label="param IsVarType(this) 174137"];
6260 [label="this.CurrentToken 174138"];
6261 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174139"];
6262 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174140"];
6263 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 174141"];
6264 [label="if (!this.CurrentToken.IsIdentifierVar())\n            {\n                return false;\n            } 174142"];
6265 [label="this.CurrentToken.IsIdentifierVar() 174143"];
6266 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 174144"];
6267 [label="return false; 174145"];
6268 [label="bool typeIsVar = IsVarType(); 174146"];
6269 [label="SyntaxToken lastTokenOfType; 174147"];
6270 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 174148"];
6271 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 174149"];
6272 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 174150"];
6273 [label="if (ScanType(mode, out lastTokenOfType) == ScanTypeFlags.NotType)\n                {\n                    return false;\n                } 174151"];
6274 [label="Debug.Assert(n >= 0); 174152"];
6275 [label="Debug.Assert(n >= 0); 174153"];
6276 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174154"];
6277 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 174155"];
6278 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 174156"];
6279 [label="this.CurrentToken 174157"];
6280 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174158"];
6281 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 174159"];
6282 [label="this.CurrentToken.Kind 174160"];
6283 [label="get { return (SyntaxKind)this.RawKind; } 174161"];
6284 [label="this.IsTrueIdentifier() 174162"];
6285 [label="param IsTrueIdentifier(this) 174163"];
6286 [label="this.CurrentToken 174164"];
6287 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174165"];
6288 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 174166"];
6289 [label="this.CurrentToken.Kind 174167"];
6290 [label="get { return (SyntaxKind)this.RawKind; } 174168"];
6291 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 174169"];
6292 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 174170"];
6293 [label="this.CurrentToken 174171"];
6294 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174172"];
6295 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 174173"];
6296 [label="this.CurrentToken.ContextualKind 174174"];
6297 [label="get\n            {\n                return this.Kind;\n            } 174175"];
6298 [label="return false; 174176"];
6299 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174177"];
6300 [label="IsCurrentTokenQueryKeywordInQuery() 174178"];
6301 [label="param IsCurrentTokenQueryKeywordInQuery(this) 174179"];
6302 [label="this.IsInQuery 174180"];
6303 [label="get { return _syntaxFactoryContext.IsInQuery; } 174181"];
6304 [label="return _syntaxFactoryContext.IsInQuery; 174182"];
6305 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 174183"];
6306 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174184"];
6307 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174185"];
6308 [label="IsCurrentTokenWhereOfConstraintClause() 174186"];
6309 [label="param IsCurrentTokenWhereOfConstraintClause(this) 174187"];
6310 [label="this.CurrentToken 174188"];
6311 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174189"];
6312 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 174190"];
6313 [label="this.CurrentToken.ContextualKind 174191"];
6314 [label="get\n            {\n                return this.Kind;\n            } 174192"];
6315 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174193"];
6316 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174194"];
6317 [label="return true; 174195"];
6318 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 174196"];
6319 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 174197"];
6320 [label="this.EatToken() 174198"];
6321 [label="this.CurrentToken 174199"];
6322 [label="MoveToNextToken() 174200"];
6323 [label="param GetTrailingTrivia(this) 174201"];
6324 [label="return null; 174202"];
6325 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174203"];
6326 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174204"];
6327 [label="MoveToNextToken(); 174205"];
6328 [label="this.CurrentToken 174206"];
6329 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174207"];
6330 [label="this.CurrentToken.Kind 174208"];
6331 [label="this.CurrentToken 174209"];
6332 [label="this.CurrentToken.Kind 174210"];
6333 [label="this.CurrentToken 174211"];
6334 [label="this.CurrentToken.Kind 174212"];
6335 [label="param IsMakingProgress(bool assertIfFalse = true) 174213"];
6336 [label="CurrentTokenPosition 174214"];
6337 [label="lastTokenOfType.Kind 174215"];
6338 [label="get { return (SyntaxKind)this.RawKind; } 174216"];
6339 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 174217"];
6340 [label="IsPredefinedType(lastTokenOfType.Kind) 174218"];
6341 [label="param IsPredefinedType(SyntaxKind keyword) 174219"];
6342 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 174220"];
6343 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 174221"];
6344 [label="ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))) 174222"];
6345 [label="param ScanDesignation(bool permitTuple) 174223"];
6346 [label="param ScanDesignation(this) 174224"];
6347 [label="this.CurrentToken 174225"];
6348 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174226"];
6349 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174227"];
6350 [label="switch (this.CurrentToken.Kind)\n            {\n                default:\n                    return false;\n                case SyntaxKind.IdentifierToken:\n                    bool result = this.IsTrueIdentifier();\n                    this.EatToken();\n                    return result;\n                case SyntaxKind.OpenParenToken:\n                    if (!permitTuple)\n                    {\n                        return false;\n                    }\n\n                    bool sawComma = false;\n                    while (true)\n                    {\n                        this.EatToken(); // consume the `(` or `,`\n                        if (!ScanDesignation(permitTuple: true))\n                        {\n                            return false;\n                        }\n                        switch (this.CurrentToken.Kind)\n                        {\n                            case SyntaxKind.CloseParenToken:\n                                this.EatToken();\n                                return sawComma;\n                            case SyntaxKind.CommaToken:\n                                sawComma = true;\n                                continue;\n                            default:\n                                return false;\n                        }\n                    }\n            } 174228"];
6351 [label="this.CurrentToken.Kind 174229"];
6352 [label="get { return (SyntaxKind)this.RawKind; } 174230"];
6353 [label="return false; 174231"];
6354 [label="if (!ScanDesignation(permitTupleDesignation && (typeIsVar || IsPredefinedType(lastTokenOfType.Kind))))\n                {\n                    return false;\n                } 174232"];
6355 [label="return false; 174233"];
6356 [label="this.Reset(ref resetPoint); 174234"];
6357 [label="this.Reset(ref resetPoint) 174235"];
6358 [label="param Reset(ref ResetPoint state) 174236"];
6359 [label="Debug.Assert(offset >= 0); 174237"];
6360 [label="Debug.Assert(offset >= 0); 174238"];
6361 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 174239"];
6362 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174240"];
6363 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174241"];
6364 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 174242"];
6365 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 174243"];
6366 [label="this.Reset(ref resetPoint); 174244"];
6367 [label="this.Release(ref resetPoint); 174245"];
6368 [label="this.Release(ref resetPoint) 174246"];
6369 [label="param Release(ref ResetPoint state) 174247"];
6370 [label="base.Release(ref state.BaseResetPoint); 174248"];
6371 [label="param Release(ref ResetPoint point) 174249"];
6372 [label="Debug.Assert(_resetCount == point.ResetCount); 174250"];
6373 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 174251"];
6374 [label="base.Release(ref state.BaseResetPoint); 174252"];
6375 [label="this.Release(ref resetPoint); 174253"];
6376 [label="this.ParseSubExpression(Precedence.Expression) 174254"];
6377 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 174255"];
6378 [label="ExpressionSyntax leftOperand; 174256"];
6379 [label="Precedence newPrecedence = 0; 174257"];
6380 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174258"];
6381 [label="return _lexedTokens[_tokenOffset]; 174259"];
6382 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 174260"];
6383 [label="IsInvalidSubExpression(tk) 174261"];
6384 [label="param IsInvalidSubExpression(SyntaxKind kind) 174262"];
6385 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 174263"];
6386 [label="return false; 174264"];
6387 [label="param IsAwaitExpression(this) 174265"];
6388 [label="this.CurrentToken 174266"];
6389 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174267"];
6390 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 174268"];
6391 [label="this.CurrentToken.ContextualKind 174269"];
6392 [label="get\n            {\n                return this.Kind;\n            } 174270"];
6393 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 174271"];
6394 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 174272"];
6395 [label="param IsQueryExpression(this) 174273"];
6396 [label="this.CurrentToken 174274"];
6397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174275"];
6398 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 174276"];
6399 [label="this.CurrentToken.ContextualKind 174277"];
6400 [label="get\n            {\n                return this.Kind;\n            } 174278"];
6401 [label="leftOperand = this.ParseTerm(precedence); 174279"];
6402 [label="param ParseTerm(Precedence precedence) 174280"];
6403 [label="precedence 174281"];
6404 [label="param ParseTermWithoutPostfix(Precedence precedence) 174282"];
6405 [label="this.IsTrueIdentifier() 174283"];
6406 [label="param IsTrueIdentifier(this) 174284"];
6407 [label="this.CurrentToken 174285"];
6408 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174286"];
6409 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 174287"];
6410 [label="this.CurrentToken.Kind 174288"];
6411 [label="get { return (SyntaxKind)this.RawKind; } 174289"];
6412 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 174290"];
6413 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 174291"];
6414 [label="this.CurrentToken 174292"];
6415 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174293"];
6416 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 174294"];
6417 [label="this.CurrentToken.ContextualKind 174295"];
6418 [label="get\n            {\n                return this.Kind;\n            } 174296"];
6419 [label="return false; 174297"];
6420 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174298"];
6421 [label="IsCurrentTokenQueryKeywordInQuery() 174299"];
6422 [label="param IsCurrentTokenQueryKeywordInQuery(this) 174300"];
6423 [label="this.IsInQuery 174301"];
6424 [label="get { return _syntaxFactoryContext.IsInQuery; } 174302"];
6425 [label="return _syntaxFactoryContext.IsInQuery; 174303"];
6426 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 174304"];
6427 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174305"];
6428 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174306"];
6429 [label="IsCurrentTokenWhereOfConstraintClause() 174307"];
6430 [label="param IsCurrentTokenWhereOfConstraintClause(this) 174308"];
6431 [label="this.CurrentToken 174309"];
6432 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174310"];
6433 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 174311"];
6434 [label="this.CurrentToken.ContextualKind 174312"];
6435 [label="get\n            {\n                return this.Kind;\n            } 174313"];
6436 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174314"];
6437 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 174315"];
6438 [label="return true; 174316"];
6439 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 174317"];
6440 [label="this.IsPossibleAnonymousMethodExpression() 174318"];
6441 [label="param IsPossibleAnonymousMethodExpression(this) 174319"];
6442 [label="var tokenIndex = 0; 174320"];
6443 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 174321"];
6444 [label="this.PeekToken(tokenIndex) 174322"];
6445 [label="param PeekToken(int n) 174323"];
6446 [label="param PeekToken(this) 174324"];
6447 [label="Debug.Assert(n >= 0); 174325"];
6448 [label="Debug.Assert(n >= 0); 174326"];
6449 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174327"];
6450 [label="return _lexedTokens[_tokenOffset + n]; 174328"];
6451 [label="this.PeekToken(tokenIndex).Kind 174329"];
6452 [label="get { return (SyntaxKind)this.RawKind; } 174330"];
6453 [label="this.PeekToken(tokenIndex) 174331"];
6454 [label="param PeekToken(int n) 174332"];
6455 [label="param PeekToken(this) 174333"];
6456 [label="Debug.Assert(n >= 0); 174334"];
6457 [label="Debug.Assert(n >= 0); 174335"];
6458 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174336"];
6459 [label="return _lexedTokens[_tokenOffset + n]; 174337"];
6460 [label="this.PeekToken(tokenIndex).ContextualKind 174338"];
6461 [label="get\n            {\n                return this.Kind;\n            } 174339"];
6462 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 174340"];
6463 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 174341"];
6464 [label="this.PeekToken(tokenIndex) 174342"];
6465 [label="param PeekToken(int n) 174343"];
6466 [label="param PeekToken(this) 174344"];
6467 [label="Debug.Assert(n >= 0); 174345"];
6468 [label="Debug.Assert(n >= 0); 174346"];
6469 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174347"];
6470 [label="return _lexedTokens[_tokenOffset + n]; 174348"];
6471 [label="this.PeekToken(tokenIndex).Kind 174349"];
6472 [label="get { return (SyntaxKind)this.RawKind; } 174350"];
6473 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 174351"];
6474 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 174352"];
6475 [label="this.IsPossibleLambdaExpression(precedence) 174353"];
6476 [label="param IsPossibleLambdaExpression(Precedence precedence) 174354"];
6477 [label="param IsPossibleLambdaExpression(this) 174355"];
6478 [label="this.CurrentToken 174356"];
6479 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174357"];
6480 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 174358"];
6481 [label="this.CurrentToken.Kind 174359"];
6482 [label="get { return (SyntaxKind)this.RawKind; } 174360"];
6483 [label="this.CurrentToken 174361"];
6484 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174362"];
6485 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 174363"];
6486 [label="this.IsTrueIdentifier(this.CurrentToken) 174364"];
6487 [label="param IsTrueIdentifier(SyntaxToken token) 174365"];
6488 [label="param IsTrueIdentifier(this) 174366"];
6489 [label="token.Kind 174367"];
6490 [label="get { return (SyntaxKind)this.RawKind; } 174368"];
6491 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 174369"];
6492 [label="this.IsInQuery 174370"];
6493 [label="get { return _syntaxFactoryContext.IsInQuery; } 174371"];
6494 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 174372"];
6495 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 174373"];
6496 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 174374"];
6497 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 174375"];
6498 [label="int peekIndex; 174376"];
6499 [label="bool seenStatic; 174377"];
6500 [label="this.CurrentToken 174378"];
6501 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174379"];
6502 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 174380"];
6503 [label="this.CurrentToken.Kind 174381"];
6504 [label="get { return (SyntaxKind)this.RawKind; } 174382"];
6505 [label="this.CurrentToken 174383"];
6506 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 174384"];
6507 [label="this.CurrentToken.ContextualKind 174385"];
6508 [label="get\n            {\n                return this.Kind;\n            } 174386"];
6509 [label="peekIndex = 0; 174387"];
6510 [label="seenStatic = false; 174388"];
6511 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 174389"];
6512 [label="this.PeekToken(peekIndex) 174390"];
6513 [label="param PeekToken(int n) 174391"];
6514 [label="param PeekToken(this) 174392"];
6515 [label="Debug.Assert(n >= 0); 174393"];
6516 [label="Debug.Assert(n >= 0); 174394"];
6517 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174395"];
6518 [label="this.PeekToken(peekIndex).Kind 174396"];
6519 [label="get { return (SyntaxKind)this.RawKind; } 174397"];
6520 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 174398"];
6521 [label="this.PeekToken(peekIndex) 174399"];
6522 [label="param PeekToken(int n) 174400"];
6523 [label="param PeekToken(this) 174401"];
6524 [label="Debug.Assert(n >= 0); 174402"];
6525 [label="Debug.Assert(n >= 0); 174403"];
6526 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174404"];
6527 [label="this.PeekToken(peekIndex).Kind 174405"];
6528 [label="get { return (SyntaxKind)this.RawKind; } 174406"];
6529 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 174407"];
6530 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 174408"];
6531 [label="this.PeekToken(peekIndex + 1) 174409"];
6532 [label="param PeekToken(int n) 174410"];
6533 [label="param PeekToken(this) 174411"];
6534 [label="Debug.Assert(n >= 0); 174412"];
6535 [label="Debug.Assert(n >= 0); 174413"];
6536 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174414"];
6537 [label="this.PeekToken(peekIndex + 1).Kind 174415"];
6538 [label="get { return (SyntaxKind)this.RawKind; } 174416"];
6539 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 174417"];
6540 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 174418"];
6541 [label="this.PeekToken(peekIndex) 174419"];
6542 [label="param PeekToken(int n) 174420"];
6543 [label="param PeekToken(this) 174421"];
6544 [label="Debug.Assert(n >= 0); 174422"];
6545 [label="Debug.Assert(n >= 0); 174423"];
6546 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174424"];
6547 [label="this.PeekToken(peekIndex).Kind 174425"];
6548 [label="get { return (SyntaxKind)this.RawKind; } 174426"];
6549 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 174427"];
6550 [label="this.PeekToken(peekIndex) 174428"];
6551 [label="param PeekToken(int n) 174429"];
6552 [label="param PeekToken(this) 174430"];
6553 [label="Debug.Assert(n >= 0); 174431"];
6554 [label="Debug.Assert(n >= 0); 174432"];
6555 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174433"];
6556 [label="this.PeekToken(peekIndex).ContextualKind 174434"];
6557 [label="get\n            {\n                return this.Kind;\n            } 174435"];
6558 [label="return false; 174436"];
6559 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 174437"];
6560 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 174438"];
6561 [label="this.IsPossibleDeconstructionLeft(precedence) 174439"];
6562 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 174440"];
6563 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 174441"];
6564 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 174442"];
6565 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 174443"];
6566 [label="param ParseAliasQualifiedName(this) 174444"];
6567 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 174445"];
6568 [label="this.ParseSimpleName(allowedParts) 174446"];
6569 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 174447"];
6570 [label="param ParseSimpleName(this) 174448"];
6571 [label="var id = this.ParseIdentifierName(); 174449"];
6572 [label="this.ParseIdentifierName() 174450"];
6573 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 174451"];
6574 [label="param ParseIdentifierName(this) 174452"];
6575 [label="this.IsIncrementalAndFactoryContextMatches 174453"];
6576 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 174454"];
6577 [label="base.IsIncremental 174455"];
6578 [label="get\n            {\n                return _isIncremental;\n            } 174456"];
6579 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 174457"];
6580 [label="return false; 174458"];
6581 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 174459"];
6582 [label="var tk = ParseIdentifierToken(code); 174460"];
6583 [label="ParseIdentifierToken(code) 174461"];
6584 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 174462"];
6585 [label="param ParseIdentifierToken(this) 174463"];
6586 [label="this.CurrentToken 174464"];
6587 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174465"];
6588 [label="var ctk = this.CurrentToken.Kind; 174466"];
6589 [label="this.CurrentToken.Kind 174467"];
6590 [label="get { return (SyntaxKind)this.RawKind; } 174468"];
6591 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 174469"];
6592 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 174470"];
6593 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 174471"];
6594 [label="this.CurrentToken 174472"];
6595 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174473"];
6596 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 174474"];
6597 [label="this.CurrentToken.ContextualKind 174475"];
6598 [label="get\n            {\n                return this.Kind;\n            } 174476"];
6599 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174477"];
6600 [label="IsCurrentTokenQueryKeywordInQuery() 174478"];
6601 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174479"];
6602 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174480"];
6603 [label="this.EatToken() 174481"];
6604 [label="param GetTrailingTrivia(this) 174482"];
6605 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174483"];
6606 [label="MoveToNextToken(); 174484"];
6607 [label="SyntaxToken identifierToken = this.EatToken(); 174485"];
6608 [label="this.IsInAsync 174486"];
6609 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 174487"];
6610 [label="return _syntaxFactoryContext.IsInAsync; 174488"];
6611 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 174489"];
6612 [label="return identifierToken; 174490"];
6613 [label="var tk = ParseIdentifierToken(code); 174491"];
6614 [label="return SyntaxFactory.IdentifierName(tk); 174492"];
6615 [label="return SyntaxFactory.IdentifierName(tk); 174493"];
6616 [label="param CSharpSyntaxNode(SyntaxKind kind) 174494"];
6617 [label="param CSharpSyntaxNode(this) 174495"];
6618 [label="kind 174496"];
6619 [label="param CSharpSyntaxNode(this) 174497"];
6620 [label="param CSharpSyntaxNode(this) 174498"];
6621 [label="GreenStats.NoteGreen(this); 174499"];
6622 [label="GreenStats.NoteGreen(this); 174500"];
6623 [label="var id = this.ParseIdentifierName(); 174501"];
6624 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 174502"];
6625 [label="SimpleNameSyntax name = id; 174503"];
6626 [label="this.CurrentToken 174504"];
6627 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174505"];
6628 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174506"];
6629 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 174507"];
6630 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 174508"];
6631 [label="this.CurrentToken.Kind 174509"];
6632 [label="get { return (SyntaxKind)this.RawKind; } 174510"];
6633 [label="return name; 174511"];
6634 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 174512"];
6635 [label="this.CurrentToken 174513"];
6636 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174514"];
6637 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174515"];
6638 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 174516"];
6639 [label="this.CurrentToken.Kind 174517"];
6640 [label="get { return (SyntaxKind)this.RawKind; } 174518"];
6641 [label="return name; 174519"];
6642 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 174520"];
6643 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 174521"];
6644 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 174522"];
6645 [label="return ParseExpressionContinued(leftOperand, precedence); 174523"];
6646 [label="return ParseExpressionContinued(leftOperand, precedence); 174524"];
6647 [label="ParseExpressionContinued(leftOperand, precedence) 174525"];
6648 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 174526"];
6649 [label="param ParseExpressionContinued(Precedence precedence) 174527"];
6650 [label="param ParseExpressionContinued(this) 174528"];
6651 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 174529"];
6652 [label="this.CurrentToken 174530"];
6653 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174531"];
6654 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174532"];
6655 [label="var tk = this.CurrentToken.ContextualKind; 174533"];
6656 [label="this.CurrentToken.ContextualKind 174534"];
6657 [label="get\n            {\n                return this.Kind;\n            } 174535"];
6658 [label="bool isAssignmentOperator = false; 174536"];
6659 [label="SyntaxKind opKind; 174537"];
6660 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174538"];
6661 [label="IsExpectedBinaryOperator(tk) 174539"];
6662 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 174540"];
6663 [label="return SyntaxFacts.IsBinaryExpression(kind); 174541"];
6664 [label="SyntaxFacts.IsBinaryExpression(kind) 174542"];
6665 [label="param IsBinaryExpression(SyntaxKind token) 174543"];
6666 [label="return GetBinaryExpression(token) != SyntaxKind.None; 174544"];
6667 [label="GetBinaryExpression(token) 174545"];
6668 [label="param GetBinaryExpression(SyntaxKind token) 174546"];
6669 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 174547"];
6670 [label="return SyntaxKind.None; 174548"];
6671 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174549"];
6672 [label="IsExpectedAssignmentOperator(tk) 174550"];
6673 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 174551"];
6674 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 174552"];
6675 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 174553"];
6676 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 174554"];
6677 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 174555"];
6678 [label="return false; 174556"];
6679 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174557"];
6680 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174558"];
6681 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174559"];
6682 [label="CurrentToken 174560"];
6683 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174561"];
6684 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174562"];
6685 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 174563"];
6686 [label="CurrentToken.Kind 174564"];
6687 [label="get { return (SyntaxKind)this.RawKind; } 174565"];
6688 [label="return leftOperand; 174566"];
6689 [label="_ = GetPrecedence(result.Kind); 174567"];
6690 [label="result.Kind 174568"];
6691 [label="get { return (SyntaxKind)this.RawKind; } 174569"];
6692 [label="_ = GetPrecedence(result.Kind); 174570"];
6693 [label="GetPrecedence(result.Kind) 174571"];
6694 [label="param GetPrecedence(SyntaxKind op) 174572"];
6695 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 174573"];
6696 [label="return Precedence.Primary; 174574"];
6697 [label="_recursionDepth 174575"];
6698 [label="return result; 174576"];
6699 [label="this.CurrentToken 174577"];
6700 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174578"];
6701 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174579"];
6702 [label="if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        var firstArg = _syntaxFactory.Argument(nameColon: null, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 174580"];
6703 [label="this.CurrentToken.Kind 174581"];
6704 [label="get { return (SyntaxKind)this.RawKind; } 174582"];
6705 [label="expression.Kind 174583"];
6706 [label="get { return (SyntaxKind)this.RawKind; } 174584"];
6707 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 174585"];
6708 [label="this.CurrentToken 174586"];
6709 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174587"];
6710 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174588"];
6711 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 174589"];
6712 [label="this.CurrentToken.Kind 174590"];
6713 [label="get { return (SyntaxKind)this.RawKind; } 174591"];
6714 [label="if (expression.Kind == SyntaxKind.IdentifierName && this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                    {\n                        var nameColon = _syntaxFactory.NameColon((IdentifierNameSyntax)expression, EatToken());\n                        expression = this.ParseExpressionOrDeclaration(ParseTypeMode.FirstElementOfPossibleTupleLiteral, feature: 0, permitTupleDesignation: true);\n\n                        var firstArg = _syntaxFactory.Argument(nameColon, refKindKeyword: null, expression: expression);\n                        return ParseTupleExpressionTail(openParen, firstArg);\n                    } 174592"];
6715 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 174593"];
6716 [label="this.EatToken(SyntaxKind.CloseParenToken) 174594"];
6717 [label="param EatToken(SyntaxKind kind) 174595"];
6718 [label="param EatToken(this) 174596"];
6719 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 174597"];
6720 [label="SyntaxFacts.IsAnyToken(kind) 174598"];
6721 [label="param IsAnyToken(SyntaxKind kind) 174599"];
6722 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 174600"];
6723 [label="return true; 174601"];
6724 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174602"];
6725 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 174603"];
6726 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174604"];
6727 [label="MoveToNextToken(); 174605"];
6728 [label="return ct; 174606"];
6729 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 174607"];
6730 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 174608"];
6731 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 174609"];
6732 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 174610"];
6733 [label="return _syntaxFactory.ParenthesizedExpression(openParen, expression, closeParen); 174611"];
6734 [label="param TryGetNode(int kind) 174612"];
6735 [label="param TryGetNode(GreenNode child1) 174613"];
6736 [label="param TryGetNode(GreenNode child2) 174614"];
6737 [label="param TryGetNode(GreenNode child3) 174615"];
6738 [label="param TryGetNode(SyntaxFactoryContext context) 174616"];
6739 [label="param TryGetNode(out int hash) 174617"];
6740 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174618"];
6741 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174619"];
6742 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174620"];
6743 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174621"];
6744 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174622"];
6745 [label="GetNodeFlags(context) 174623"];
6746 [label="param GetNodeFlags(SyntaxFactoryContext context) 174624"];
6747 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 174625"];
6748 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 174626"];
6749 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 174627"];
6750 [label="return flags; 174628"];
6751 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174629"];
6752 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174630"];
6753 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 174631"];
6754 [label="param CSharpSyntaxNode(this) 174632"];
6755 [label="GreenStats.NoteGreen(this); 174633"];
6756 [label="param SetFactoryContext(SyntaxFactoryContext context) 174634"];
6757 [label="param SetFactoryContext(this) 174635"];
6758 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 174636"];
6759 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 174637"];
6760 [label="this.Release(ref resetPoint); 174638"];
6761 [label="this.Release(ref resetPoint) 174639"];
6762 [label="param Release(ref ResetPoint state) 174640"];
6763 [label="param Release(this) 174641"];
6764 [label="base.Release(ref state.BaseResetPoint); 174642"];
6765 [label="base.Release(ref state.BaseResetPoint) 174643"];
6766 [label="param Release(ref ResetPoint point) 174644"];
6767 [label="param Release(this) 174645"];
6768 [label="Debug.Assert(_resetCount == point.ResetCount); 174646"];
6769 [label="_resetCount 174647"];
6770 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 174648"];
6771 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 174649"];
6772 [label="base.Release(ref state.BaseResetPoint); 174650"];
6773 [label="this.Release(ref resetPoint); 174651"];
6774 [label="return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence); 174652"];
6775 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 174653"];
6776 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 174654"];
6777 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174655"];
6778 [label="return ParseExpressionContinued(leftOperand, precedence); 174656"];
6779 [label="ParseExpressionContinued(leftOperand, precedence) 174657"];
6780 [label="param ParseExpressionContinued(Precedence precedence) 174658"];
6781 [label="param ParseExpressionContinued(this) 174659"];
6782 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 174660"];
6783 [label="this.CurrentToken 174661"];
6784 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174662"];
6785 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174663"];
6786 [label="var tk = this.CurrentToken.ContextualKind; 174664"];
6787 [label="this.CurrentToken.ContextualKind 174665"];
6788 [label="get\n            {\n                return this.Kind;\n            } 174666"];
6789 [label="this.Kind 174667"];
6790 [label="bool isAssignmentOperator = false; 174668"];
6791 [label="SyntaxKind opKind; 174669"];
6792 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174670"];
6793 [label="IsExpectedBinaryOperator(tk) 174671"];
6794 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 174672"];
6795 [label="return SyntaxFacts.IsBinaryExpression(kind); 174673"];
6796 [label="SyntaxFacts.IsBinaryExpression(kind) 174674"];
6797 [label="param IsBinaryExpression(SyntaxKind token) 174675"];
6798 [label="return GetBinaryExpression(token) != SyntaxKind.None; 174676"];
6799 [label="GetBinaryExpression(token) 174677"];
6800 [label="param GetBinaryExpression(SyntaxKind token) 174678"];
6801 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 174679"];
6802 [label="return SyntaxKind.None; 174680"];
6803 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174681"];
6804 [label="IsExpectedAssignmentOperator(tk) 174682"];
6805 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 174683"];
6806 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 174684"];
6807 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 174685"];
6808 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 174686"];
6809 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 174687"];
6810 [label="return false; 174688"];
6811 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174689"];
6812 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174690"];
6813 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 174691"];
6814 [label="CurrentToken 174692"];
6815 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174693"];
6816 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174694"];
6817 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 174695"];
6818 [label="CurrentToken.Kind 174696"];
6819 [label="get { return (SyntaxKind)this.RawKind; } 174697"];
6820 [label="_ = GetPrecedence(result.Kind); 174698"];
6821 [label="result.Kind 174699"];
6822 [label="get { return (SyntaxKind)this.RawKind; } 174700"];
6823 [label="_ = GetPrecedence(result.Kind); 174701"];
6824 [label="GetPrecedence(result.Kind) 174702"];
6825 [label="param GetPrecedence(SyntaxKind op) 174703"];
6826 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 174704"];
6827 [label="return Precedence.Primary; 174705"];
6828 [label="var expression = this.ParseExpressionCore(); 174706"];
6829 [label="SyntaxToken openParen; 174707"];
6830 [label="SyntaxToken closeParen; 174708"];
6831 [label="expression.Kind 174709"];
6832 [label="get { return (SyntaxKind)this.RawKind; } 174710"];
6833 [label="if (expression.Kind == SyntaxKind.ParenthesizedExpression)\n            {\n                var parenExpression = (ParenthesizedExpressionSyntax)expression;\n                openParen = parenExpression.OpenParenToken;\n                expression = parenExpression.Expression;\n                closeParen = parenExpression.CloseParenToken;\n\n                Debug.Assert(parenExpression.GetDiagnostics().Length == 0);\n            }\n            else if (expression.Kind == SyntaxKind.TupleExpression)\n            {\n                // As a special case, when a tuple literal is the governing expression of\n                // a switch statement we permit the switch statement's own parentheses to be omitted.\n                // LDM 2018-04-04.\n                openParen = closeParen = null;\n            }\n            else\n            {\n                // Some other expression has appeared without parens. Give a syntax error.\n                openParen = SyntaxFactory.MissingToken(SyntaxKind.OpenParenToken);\n                expression = this.AddError(expression, ErrorCode.ERR_SwitchGoverningExpressionRequiresParens);\n                closeParen = SyntaxFactory.MissingToken(SyntaxKind.CloseParenToken);\n            } 174711"];
6834 [label="var parenExpression = (ParenthesizedExpressionSyntax)expression; 174712"];
6835 [label="openParen = parenExpression.OpenParenToken; 174713"];
6836 [label="expression = parenExpression.Expression; 174714"];
6837 [label="closeParen = parenExpression.CloseParenToken; 174715"];
6838 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 174716"];
6839 [label="Debug.Assert(parenExpression.GetDiagnostics().Length == 0); 174717"];
6840 [label="var openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 174718"];
6841 [label="this.EatToken(SyntaxKind.OpenBraceToken) 174719"];
6842 [label="param EatToken(SyntaxKind kind) 174720"];
6843 [label="param EatToken(this) 174721"];
6844 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 174722"];
6845 [label="SyntaxFacts.IsAnyToken(kind) 174723"];
6846 [label="param IsAnyToken(SyntaxKind kind) 174724"];
6847 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 174725"];
6848 [label="return true; 174726"];
6849 [label="this.CurrentToken 174727"];
6850 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174728"];
6851 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174729"];
6852 [label="ct.Kind 174730"];
6853 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 174731"];
6854 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174732"];
6855 [label="MoveToNextToken(); 174733"];
6856 [label="var sections = _pool.Allocate<SwitchSectionSyntax>(); 174734"];
6857 [label="this.IsPossibleSwitchSection() 174735"];
6858 [label="param IsPossibleSwitchSection(this) 174736"];
6859 [label="this.CurrentToken 174737"];
6860 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174738"];
6861 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174739"];
6862 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 174740"];
6863 [label="return (this.CurrentToken.Kind == SyntaxKind.CaseKeyword) ||\n                   (this.CurrentToken.Kind == SyntaxKind.DefaultKeyword && this.PeekToken(1).Kind != SyntaxKind.OpenParenToken); 174741"];
6864 [label="this.CurrentToken.Kind 174742"];
6865 [label="get { return (SyntaxKind)this.RawKind; } 174743"];
6866 [label="while (this.IsPossibleSwitchSection())\n                {\n                    var swcase = this.ParseSwitchSection();\n                    sections.Add(swcase);\n                } 174744"];
6867 [label="this.ParseSwitchSection() 174745"];
6868 [label="param ParseSwitchSection(this) 174746"];
6869 [label="this.IsPossibleSwitchSection() 174747"];
6870 [label="param IsPossibleSwitchSection(this) 174748"];
6871 [label="Debug.Assert(this.IsPossibleSwitchSection()); 174749"];
6872 [label="var labels = _pool.Allocate<SwitchLabelSyntax>(); 174750"];
6873 [label="var statements = _pool.Allocate<StatementSyntax>(); 174751"];
6874 [label="SyntaxToken specifier; 174752"];
6875 [label="SwitchLabelSyntax label; 174753"];
6876 [label="SyntaxToken colon; 174754"];
6877 [label="this.CurrentToken 174755"];
6878 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174756"];
6879 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174757"];
6880 [label="if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    } 174758"];
6881 [label="this.CurrentToken.Kind 174759"];
6882 [label="get { return (SyntaxKind)this.RawKind; } 174760"];
6883 [label="ExpressionSyntax expression; 174761"];
6884 [label="this.EatToken() 174762"];
6885 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174763"];
6886 [label="MoveToNextToken(); 174764"];
6887 [label="specifier = this.EatToken(); 174765"];
6888 [label="this.CurrentToken 174766"];
6889 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174767"];
6890 [label="return _lexedTokens[_tokenOffset]; 174768"];
6891 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        } 174769"];
6892 [label="this.CurrentToken.Kind 174770"];
6893 [label="get { return (SyntaxKind)this.RawKind; } 174771"];
6894 [label="ParseExpressionOrPatternForSwitchStatement() 174772"];
6895 [label="param ParseExpressionOrPatternForSwitchStatement(this) 174773"];
6896 [label="ParseExpressionOrPatternForSwitchStatementCore() 174774"];
6897 [label="param ParseExpressionOrPatternForSwitchStatementCore(this) 174775"];
6898 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 174776"];
6899 [label="var pattern = ParsePattern(Precedence.Conditional, whenIsKeyword: true); 174777"];
6900 [label="ParsePattern(Precedence.Conditional, whenIsKeyword: true) 174778"];
6901 [label="param ParsePattern(Precedence precedence) 174779"];
6902 [label="param ParsePattern(bool afterIs = false) 174780"];
6903 [label="param ParsePattern(bool whenIsKeyword = false) 174781"];
6904 [label="param ParsePattern(this) 174782"];
6905 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 174783"];
6906 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 174784"];
6907 [label="return ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword); 174785"];
6908 [label="ParseDisjunctivePattern(precedence, afterIs, whenIsKeyword) 174786"];
6909 [label="param ParseDisjunctivePattern(Precedence precedence) 174787"];
6910 [label="param ParseDisjunctivePattern(bool afterIs) 174788"];
6911 [label="param ParseDisjunctivePattern(bool whenIsKeyword) 174789"];
6912 [label="param ParseDisjunctivePattern(this) 174790"];
6913 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 174791"];
6914 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 174792"];
6915 [label="PatternSyntax result = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword); 174793"];
6916 [label="ParseConjunctivePattern(precedence, afterIs, whenIsKeyword) 174794"];
6917 [label="param ParseConjunctivePattern(Precedence precedence) 174795"];
6918 [label="param ParseConjunctivePattern(bool afterIs) 174796"];
6919 [label="param ParseConjunctivePattern(bool whenIsKeyword) 174797"];
6920 [label="param ParseConjunctivePattern(this) 174798"];
6921 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 174799"];
6922 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 174800"];
6923 [label="PatternSyntax result = ParseNegatedPattern(precedence, afterIs, whenIsKeyword); 174801"];
6924 [label="ParseNegatedPattern(precedence, afterIs, whenIsKeyword) 174802"];
6925 [label="param ParseNegatedPattern(Precedence precedence) 174803"];
6926 [label="param ParseNegatedPattern(bool afterIs) 174804"];
6927 [label="param ParseNegatedPattern(bool whenIsKeyword) 174805"];
6928 [label="param ParseNegatedPattern(this) 174806"];
6929 [label="this.CurrentToken 174807"];
6930 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174808"];
6931 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.NotKeyword)\n            {\n                var notToken = ConvertToKeyword(this.EatToken());\n                var pattern = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                var result = _syntaxFactory.UnaryPattern(notToken, pattern);\n                return CheckFeatureAvailability(result, MessageID.IDS_FeatureNotPattern);\n            }\n            else\n            {\n                return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword);\n            } 174809"];
6932 [label="this.CurrentToken.ContextualKind 174810"];
6933 [label="get\n            {\n                return this.Kind;\n            } 174811"];
6934 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 174812"];
6935 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 174813"];
6936 [label="return ParsePrimaryPattern(precedence, afterIs, whenIsKeyword); 174814"];
6937 [label="ParsePrimaryPattern(precedence, afterIs, whenIsKeyword) 174815"];
6938 [label="param ParsePrimaryPattern(Precedence precedence) 174816"];
6939 [label="param ParsePrimaryPattern(bool afterIs) 174817"];
6940 [label="param ParsePrimaryPattern(bool whenIsKeyword) 174818"];
6941 [label="param ParsePrimaryPattern(this) 174819"];
6942 [label="this.CurrentToken 174820"];
6943 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174821"];
6944 [label="var tk = this.CurrentToken.Kind; 174822"];
6945 [label="this.CurrentToken.Kind 174823"];
6946 [label="get { return (SyntaxKind)this.RawKind; } 174824"];
6947 [label="switch (tk)\n            {\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.CloseBraceToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return _syntaxFactory.ConstantPattern(this.ParseIdentifierName(ErrorCode.ERR_MissingPattern));\n            } 174825"];
6948 [label="CurrentToken 174826"];
6949 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174827"];
6950 [label="if (CurrentToken.ContextualKind == SyntaxKind.UnderscoreToken)\n            {\n                return _syntaxFactory.DiscardPattern(this.EatContextualToken(SyntaxKind.UnderscoreToken));\n            } 174828"];
6951 [label="CurrentToken.ContextualKind 174829"];
6952 [label="get\n            {\n                return this.Kind;\n            } 174830"];
6953 [label="CurrentToken 174831"];
6954 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174832"];
6955 [label="switch (CurrentToken.Kind)\n            {\n                case SyntaxKind.LessThanToken:\n                case SyntaxKind.LessThanEqualsToken:\n                case SyntaxKind.GreaterThanToken:\n                case SyntaxKind.GreaterThanEqualsToken:\n                case SyntaxKind.EqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsToken:\n                    // this is a relational pattern.\n                    var relationalToken = this.EatToken();\n                    Debug.Assert(precedence < Precedence.Shift);\n                    var expression = this.ParseSubExpression(Precedence.Relational);\n                    var result = _syntaxFactory.RelationalPattern(relationalToken, expression);\n                    return CheckFeatureAvailability(result, MessageID.IDS_FeatureRelationalPattern);\n            } 174833"];
6956 [label="CurrentToken.Kind 174834"];
6957 [label="get { return (SyntaxKind)this.RawKind; } 174835"];
6958 [label="this.GetResetPoint() 174836"];
6959 [label="param GetResetPoint(this) 174837"];
6960 [label="var resetPoint = this.GetResetPoint(); 174838"];
6961 [label="TypeSyntax type = null; 174839"];
6962 [label="LooksLikeTypeOfPattern() 174840"];
6963 [label="param LooksLikeTypeOfPattern(this) 174841"];
6964 [label="CurrentToken 174842"];
6965 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174843"];
6966 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174844"];
6967 [label="var tk = CurrentToken.Kind; 174845"];
6968 [label="CurrentToken.Kind 174846"];
6969 [label="get { return (SyntaxKind)this.RawKind; } 174847"];
6970 [label="if (SyntaxFacts.IsPredefinedType(tk))\n            {\n                return true;\n            } 174848"];
6971 [label="SyntaxFacts.IsPredefinedType(tk) 174849"];
6972 [label="param IsPredefinedType(SyntaxKind kind) 174850"];
6973 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 174851"];
6974 [label="this.CurrentToken 174852"];
6975 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174853"];
6976 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174854"];
6977 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 174855"];
6978 [label="this.CurrentToken.ContextualKind 174856"];
6979 [label="get\n            {\n                return this.Kind;\n            } 174857"];
6980 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 174858"];
6981 [label="this.CurrentToken 174859"];
6982 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174860"];
6983 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174861"];
6984 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 174862"];
6985 [label="this.CurrentToken.ContextualKind 174863"];
6986 [label="get\n            {\n                return this.Kind;\n            } 174864"];
6987 [label="if (tk == SyntaxKind.IdentifierToken && this.CurrentToken.ContextualKind != SyntaxKind.UnderscoreToken &&\n                (this.CurrentToken.ContextualKind != SyntaxKind.NameOfKeyword || this.PeekToken(1).Kind != SyntaxKind.OpenParenToken))\n            {\n                return true;\n            } 174865"];
6988 [label="return true; 174866"];
6989 [label="if (LooksLikeTypeOfPattern())\n                {\n                    type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern);\n                    if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    }\n                } 174867"];
6990 [label="afterIs 174868"];
6991 [label="type = this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern); 174869"];
6992 [label="this.ParseType(afterIs ? ParseTypeMode.AfterIs : ParseTypeMode.DefinitePattern) 174870"];
6993 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 174871"];
6994 [label="param ParseType(this) 174872"];
6995 [label="this.CurrentToken 174873"];
6996 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174874"];
6997 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 174875"];
6998 [label="this.CurrentToken.Kind 174876"];
6999 [label="get { return (SyntaxKind)this.RawKind; } 174877"];
7000 [label="return ParseTypeCore(mode); 174878"];
7001 [label="return ParseTypeCore(mode); 174879"];
7002 [label="return ParseTypeCore(mode); 174880"];
7003 [label="param ParseUnderlyingType(ParseTypeMode mode) 174881"];
7004 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 174882"];
7005 [label="param ParseUnderlyingType(this) 174883"];
7006 [label="this.CurrentToken 174884"];
7007 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174885"];
7008 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 174886"];
7009 [label="this.CurrentToken.Kind 174887"];
7010 [label="get { return (SyntaxKind)this.RawKind; } 174888"];
7011 [label="IsPredefinedType(this.CurrentToken.Kind) 174889"];
7012 [label="param IsPredefinedType(SyntaxKind keyword) 174890"];
7013 [label="IsTrueIdentifier() 174891"];
7014 [label="param IsTrueIdentifier(this) 174892"];
7015 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 174893"];
7016 [label="this.CurrentToken 174894"];
7017 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174895"];
7018 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 174896"];
7019 [label="this.CurrentToken.ContextualKind 174897"];
7020 [label="get\n            {\n                return this.Kind;\n            } 174898"];
7021 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 174899"];
7022 [label="return this.ParseQualifiedName(options); 174900"];
7023 [label="this.ParseQualifiedName(options) 174901"];
7024 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 174902"];
7025 [label="param ParseQualifiedName(this) 174903"];
7026 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 174904"];
7027 [label="this.ParseAliasQualifiedName(options) 174905"];
7028 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 174906"];
7029 [label="param ParseAliasQualifiedName(this) 174907"];
7030 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 174908"];
7031 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 174909"];
7032 [label="this.IsIncrementalAndFactoryContextMatches 174910"];
7033 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 174911"];
7034 [label="base.IsIncremental 174912"];
7035 [label="get\n            {\n                return _isIncremental;\n            } 174913"];
7036 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 174914"];
7037 [label="return false; 174915"];
7038 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 174916"];
7039 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 174917"];
7040 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 174918"];
7041 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 174919"];
7042 [label="this.CurrentToken 174920"];
7043 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174921"];
7044 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 174922"];
7045 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174923"];
7046 [label="IsCurrentTokenQueryKeywordInQuery() 174924"];
7047 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174925"];
7048 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 174926"];
7049 [label="param GetTrailingTrivia(this) 174927"];
7050 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 174928"];
7051 [label="MoveToNextToken(); 174929"];
7052 [label="this.IsInAsync 174930"];
7053 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 174931"];
7054 [label="return _syntaxFactoryContext.IsInAsync; 174932"];
7055 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 174933"];
7056 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 174934"];
7057 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 174935"];
7058 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 174936"];
7059 [label="this.CurrentToken.Kind 174937"];
7060 [label="get { return (SyntaxKind)this.RawKind; } 174938"];
7061 [label="this.CurrentToken 174939"];
7062 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174940"];
7063 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 174941"];
7064 [label="this.CurrentToken.Kind 174942"];
7065 [label="get { return (SyntaxKind)this.RawKind; } 174943"];
7066 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 174944"];
7067 [label="this.IsDotOrColonColon() 174945"];
7068 [label="param IsDotOrColonColon(this) 174946"];
7069 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174947"];
7070 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 174948"];
7071 [label="this.CurrentToken 174949"];
7072 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174950"];
7073 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174951"];
7074 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 174952"];
7075 [label="this.CurrentToken.Kind 174953"];
7076 [label="get { return (SyntaxKind)this.RawKind; } 174954"];
7077 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 174955"];
7078 [label="return name; 174956"];
7079 [label="return this.ParseQualifiedName(options); 174957"];
7080 [label="param IsMakingProgress(bool assertIfFalse = true) 174958"];
7081 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 174959"];
7082 [label="CanTokenFollowTypeInPattern(precedence) 174960"];
7083 [label="param CanTokenFollowTypeInPattern(Precedence precedence) 174961"];
7084 [label="param CanTokenFollowTypeInPattern(this) 174962"];
7085 [label="this.CurrentToken 174963"];
7086 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174964"];
7087 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174965"];
7088 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenParenToken:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.CloseBraceToken:   // for efficiency, test some tokens that can follow a type pattern\n                case SyntaxKind.CloseBracketToken:\n                case SyntaxKind.CloseParenToken:\n                case SyntaxKind.CommaToken:\n                case SyntaxKind.SemicolonToken:\n                    return true;\n                case SyntaxKind.DotToken:\n                    // int.MaxValue is an expression, not a type.\n                    return false;\n                case var kind:\n                    // If we find what looks like a continuation of an expression, it is not a type.\n                    return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence;\n            } 174966"];
7089 [label="this.CurrentToken.Kind 174967"];
7090 [label="get { return (SyntaxKind)this.RawKind; } 174968"];
7091 [label="return !SyntaxFacts.IsBinaryExpressionOperatorToken(kind) ||\n                           GetPrecedence(SyntaxFacts.GetBinaryExpression(kind)) <= precedence; 174969"];
7092 [label="SyntaxFacts.IsBinaryExpressionOperatorToken(kind) 174970"];
7093 [label="param IsBinaryExpressionOperatorToken(SyntaxKind token) 174971"];
7094 [label="return GetBinaryExpression(token) != SyntaxKind.None; 174972"];
7095 [label="GetBinaryExpression(token) 174973"];
7096 [label="param GetBinaryExpression(SyntaxKind token) 174974"];
7097 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 174975"];
7098 [label="return SyntaxKind.None; 174976"];
7099 [label="if (type.IsMissing || !CanTokenFollowTypeInPattern(precedence))\n                    {\n                        // either it is not shaped like a type, or it is a constant expression.\n                        this.Reset(ref resetPoint);\n                        type = null;\n                    } 174977"];
7100 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 174978"];
7101 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 174979"];
7102 [label="PatternSyntax p = ParsePatternContinued(type, precedence, whenIsKeyword); 174980"];
7103 [label="ParsePatternContinued(type, precedence, whenIsKeyword) 174981"];
7104 [label="param ParsePatternContinued(TypeSyntax type) 174982"];
7105 [label="param ParsePatternContinued(Precedence precedence) 174983"];
7106 [label="param ParsePatternContinued(bool whenIsKeyword) 174984"];
7107 [label="param ParsePatternContinued(this) 174985"];
7108 [label=".Kind 174986"];
7109 [label="get { return (SyntaxKind)this.RawKind; } 174987"];
7110 [label="if (type?.Kind == SyntaxKind.IdentifierName)\n            {\n                var typeIdentifier = (IdentifierNameSyntax)type;\n                var typeIdentifierToken = typeIdentifier.Identifier;\n                if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                }\n            } 174988"];
7111 [label="var typeIdentifier = (IdentifierNameSyntax)type; 174989"];
7112 [label="var typeIdentifierToken = typeIdentifier.Identifier; 174990"];
7113 [label="typeIdentifierToken.ContextualKind 174991"];
7114 [label="get\n            {\n                return this.Kind;\n            } 174992"];
7115 [label="if (typeIdentifierToken.ContextualKind == SyntaxKind.VarKeyword &&\n                    (this.CurrentToken.Kind == SyntaxKind.OpenParenToken || this.IsValidPatternDesignation(whenIsKeyword)))\n                {\n                    // we have a 'var' pattern; 'var' is not permitted to be a stand-in for a type (or a constant) in a pattern.\n                    var varToken = ConvertToKeyword(typeIdentifierToken);\n                    var varDesignation = ParseDesignation(forPattern: true);\n                    return _syntaxFactory.VarPattern(varToken, varDesignation);\n                } 174993"];
7116 [label="this.CurrentToken 174994"];
7117 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 174995"];
7118 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 174996"];
7119 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken && (type != null || !looksLikeCast()))\n            {\n                // It is possible this is a parenthesized (constant) expression.\n                // We normalize later.\n                ParseSubpatternList(\n                    openToken: out SyntaxToken openParenToken,\n                    subPatterns: out SeparatedSyntaxList<SubpatternSyntax> subPatterns,\n                    closeToken: out SyntaxToken closeParenToken,\n                    openKind: SyntaxKind.OpenParenToken,\n                    closeKind: SyntaxKind.CloseParenToken);\n\n                parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause0);\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n\n                if (type == null &&\n                    propertyPatternClause0 == null &&\n                    designation0 == null &&\n                    subPatterns.Count == 1 &&\n                    subPatterns.SeparatorCount == 0 &&\n                    subPatterns[0].NameColon == null)\n                {\n                    var subpattern = subPatterns[0].Pattern;\n                    switch (subpattern)\n                    {\n                        case ConstantPatternSyntax cp:\n                            // There is an ambiguity between a positional pattern `(` pattern `)`\n                            // and a constant expression pattern that happens to be parenthesized.\n                            // Per 2017-11-20 LDM we treat such syntax as a parenthesized expression always.\n                            ExpressionSyntax expression = _syntaxFactory.ParenthesizedExpression(openParenToken, cp.Expression, closeParenToken);\n                            expression = ParseExpressionContinued(expression, precedence);\n                            return _syntaxFactory.ConstantPattern(expression);\n                        default:\n                            var parenthesizedPattern = _syntaxFactory.ParenthesizedPattern(openParenToken, subPatterns[0].Pattern, closeParenToken);\n                            return CheckFeatureAvailability(parenthesizedPattern, MessageID.IDS_FeatureParenthesizedPattern);\n                    }\n                }\n\n                var positionalPatternClause = _syntaxFactory.PositionalPatternClause(openParenToken, subPatterns, closeParenToken);\n                var result = _syntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause0, designation0);\n                return result;\n            } 174997"];
7120 [label="this.CurrentToken.Kind 174998"];
7121 [label="get { return (SyntaxKind)this.RawKind; } 174999"];
7122 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 175000"];
7123 [label="parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause) 175001"];
7124 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 175002"];
7125 [label="bool parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClauseResult)\n            {\n                propertyPatternClauseResult = null;\n                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                }\n\n                return false;\n            } 175003"];
7126 [label="propertyPatternClauseResult = null; 175004"];
7127 [label="this.CurrentToken 175005"];
7128 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175006"];
7129 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175007"];
7130 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken)\n                {\n                    propertyPatternClauseResult = ParsePropertyPatternClause();\n                    return true;\n                } 175008"];
7131 [label="this.CurrentToken.Kind 175009"];
7132 [label="get { return (SyntaxKind)this.RawKind; } 175010"];
7133 [label="return false; 175011"];
7134 [label="if (parsePropertyPatternClause(out PropertyPatternClauseSyntax propertyPatternClause))\n            {\n                parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation0);\n                return _syntaxFactory.RecursivePattern(type, positionalPatternClause: null, propertyPatternClause, designation0);\n            } 175012"];
7135 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 175013"];
7136 [label="if (type != null)\n            {\n                if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                }\n            } 175014"];
7137 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 175015"];
7138 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 175016"];
7139 [label="parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation) 175017"];
7140 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 175018"];
7141 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 175019"];
7142 [label="bool parseDesignation(bool whenIsKeywordB, out VariableDesignationSyntax designationResult)\n            {\n                designationResult = null;\n                if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                }\n\n                return false;\n            } 175020"];
7143 [label="designationResult = null; 175021"];
7144 [label="this.IsTrueIdentifier() 175022"];
7145 [label="param IsTrueIdentifier(this) 175023"];
7146 [label="return false; 175024"];
7147 [label="if (this.IsTrueIdentifier() && this.IsValidPatternDesignation(whenIsKeywordB))\n                {\n                    designationResult = ParseSimpleDesignation();\n                    return true;\n                } 175025"];
7148 [label="return false; 175026"];
7149 [label="if (parseDesignation(whenIsKeyword, out VariableDesignationSyntax designation))\n                {\n                    return _syntaxFactory.DeclarationPattern(type, designation);\n                }\n                else\n                {\n                    // We normally prefer an expression rather than a type in a pattern.\n                    if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    }\n\n                    var typePattern = _syntaxFactory.TypePattern(type);\n                    return CheckFeatureAvailability(typePattern, MessageID.IDS_FeatureTypePattern);\n                } 175027"];
7150 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 175028"];
7151 [label="if (ConvertTypeToExpression(type, out var expression))\n                    {\n                        expression = ParseExpressionContinued(expression, precedence);\n                        return _syntaxFactory.ConstantPattern(expression);\n                    } 175029"];
7152 [label="ConvertTypeToExpression(type, out var expression) 175030"];
7153 [label="param ConvertTypeToExpression(TypeSyntax type) 175031"];
7154 [label="param ConvertTypeToExpression(out ExpressionSyntax expr) 175032"];
7155 [label="param ConvertTypeToExpression(bool permitTypeArguments = false) 175033"];
7156 [label="param ConvertTypeToExpression(this) 175034"];
7157 [label="expr = null; 175035"];
7158 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 175036"];
7159 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 175037"];
7160 [label="switch (type)\n            {\n                case GenericNameSyntax g:\n                    expr = g;\n                    return permitTypeArguments;\n                case SimpleNameSyntax s:\n                    expr = s;\n                    return true;\n                case QualifiedNameSyntax { Left: var left, dotToken: var dotToken, Right: var right }\n                            when (permitTypeArguments || !(right is GenericNameSyntax)):\n                    var newLeft = ConvertTypeToExpression(left, out var leftExpr, permitTypeArguments: true) ? leftExpr : left;\n                    expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, newLeft, dotToken, right);\n                    return true;\n                default:\n                    return false;\n            } 175038"];
7161 [label="expr = s; 175039"];
7162 [label="return true; 175040"];
7163 [label="expression = ParseExpressionContinued(expression, precedence); 175041"];
7164 [label="expression = ParseExpressionContinued(expression, precedence); 175042"];
7165 [label="ParseExpressionContinued(expression, precedence) 175043"];
7166 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 175044"];
7167 [label="param ParseExpressionContinued(Precedence precedence) 175045"];
7168 [label="param ParseExpressionContinued(this) 175046"];
7169 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 175047"];
7170 [label="this.CurrentToken 175048"];
7171 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175049"];
7172 [label="var tk = this.CurrentToken.ContextualKind; 175050"];
7173 [label="this.CurrentToken.ContextualKind 175051"];
7174 [label="get\n            {\n                return this.Kind;\n            } 175052"];
7175 [label="bool isAssignmentOperator = false; 175053"];
7176 [label="SyntaxKind opKind; 175054"];
7177 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175055"];
7178 [label="IsExpectedBinaryOperator(tk) 175056"];
7179 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 175057"];
7180 [label="return SyntaxFacts.IsBinaryExpression(kind); 175058"];
7181 [label="SyntaxFacts.IsBinaryExpression(kind) 175059"];
7182 [label="param IsBinaryExpression(SyntaxKind token) 175060"];
7183 [label="return GetBinaryExpression(token) != SyntaxKind.None; 175061"];
7184 [label="GetBinaryExpression(token) 175062"];
7185 [label="param GetBinaryExpression(SyntaxKind token) 175063"];
7186 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 175064"];
7187 [label="return SyntaxKind.None; 175065"];
7188 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175066"];
7189 [label="IsExpectedAssignmentOperator(tk) 175067"];
7190 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 175068"];
7191 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 175069"];
7192 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 175070"];
7193 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 175071"];
7194 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 175072"];
7195 [label="return false; 175073"];
7196 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175074"];
7197 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175075"];
7198 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175076"];
7199 [label="CurrentToken 175077"];
7200 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175078"];
7201 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 175079"];
7202 [label="CurrentToken.Kind 175080"];
7203 [label="get { return (SyntaxKind)this.RawKind; } 175081"];
7204 [label="return _syntaxFactory.ConstantPattern(expression); 175082"];
7205 [label="return _syntaxFactory.ConstantPattern(expression); 175083"];
7206 [label="return _syntaxFactory.ConstantPattern(expression); 175084"];
7207 [label="param TryGetNode(int kind) 175085"];
7208 [label="param TryGetNode(GreenNode child1) 175086"];
7209 [label="param TryGetNode(SyntaxFactoryContext context) 175087"];
7210 [label="param TryGetNode(out int hash) 175088"];
7211 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175089"];
7212 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175090"];
7213 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175091"];
7214 [label="GetNodeFlags(context) 175092"];
7215 [label="param GetNodeFlags(SyntaxFactoryContext context) 175093"];
7216 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 175094"];
7217 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 175095"];
7218 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175096"];
7219 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175097"];
7220 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 175098"];
7221 [label="param SetFactoryContext(SyntaxFactoryContext context) 175099"];
7222 [label="param SetFactoryContext(this) 175100"];
7223 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 175101"];
7224 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 175102"];
7225 [label="if (p != null)\n                    return p; 175103"];
7226 [label="if (p != null)\n                    return p; 175104"];
7227 [label="return p; 175105"];
7228 [label="this.Release(ref resetPoint); 175106"];
7229 [label="this.Release(ref resetPoint) 175107"];
7230 [label="param Release(ref ResetPoint state) 175108"];
7231 [label="base.Release(ref state.BaseResetPoint); 175109"];
7232 [label="param Release(ref ResetPoint point) 175110"];
7233 [label="Debug.Assert(_resetCount == point.ResetCount); 175111"];
7234 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 175112"];
7235 [label="base.Release(ref state.BaseResetPoint); 175113"];
7236 [label="this.Release(ref resetPoint); 175114"];
7237 [label="this.CurrentToken 175115"];
7238 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175116"];
7239 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175117"];
7240 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.AndKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseNegatedPattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.AndPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureAndPattern);\n            } 175118"];
7241 [label="this.CurrentToken.ContextualKind 175119"];
7242 [label="get\n            {\n                return this.Kind;\n            } 175120"];
7243 [label="return result; 175121"];
7244 [label="this.CurrentToken 175122"];
7245 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175123"];
7246 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175124"];
7247 [label="while (this.CurrentToken.ContextualKind == SyntaxKind.OrKeyword)\n            {\n                var orToken = ConvertToKeyword(this.EatToken());\n                var right = ParseConjunctivePattern(precedence, afterIs, whenIsKeyword);\n                result = _syntaxFactory.BinaryPattern(SyntaxKind.OrPattern, result, orToken, right);\n                result = CheckFeatureAvailability(result, MessageID.IDS_FeatureOrPattern);\n            } 175125"];
7248 [label="this.CurrentToken.ContextualKind 175126"];
7249 [label="get\n            {\n                return this.Kind;\n            } 175127"];
7250 [label="return result; 175128"];
7251 [label="pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            } 175129"];
7252 [label="return pattern switch\n            {\n                ConstantPatternSyntax cp => cp.Expression,\n                TypePatternSyntax tp when ConvertTypeToExpression(tp.Type, out ExpressionSyntax expr) => expr,\n                DiscardPatternSyntax dp => _syntaxFactory.IdentifierName(ConvertToIdentifier(dp.UnderscoreToken)),\n                var p => p,\n            }; 175130"];
7253 [label="return CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()); 175131"];
7254 [label="CheckRecursivePatternFeature(ParseExpressionOrPatternForSwitchStatementCore()) 175132"];
7255 [label="param CheckRecursivePatternFeature(CSharpSyntaxNode node) 175133"];
7256 [label="param CheckRecursivePatternFeature(this) 175134"];
7257 [label="node.Kind 175135"];
7258 [label="get { return (SyntaxKind)this.RawKind; } 175136"];
7259 [label="switch (node.Kind)\n            {\n                case SyntaxKind.RecursivePattern:\n                case SyntaxKind.DiscardPattern:\n                case SyntaxKind.VarPattern when ((VarPatternSyntax)node).Designation.Kind == SyntaxKind.ParenthesizedVariableDesignation:\n                    return this.CheckFeatureAvailability(node, MessageID.IDS_FeatureRecursivePatterns);\n                default:\n                    return node;\n            } 175137"];
7260 [label="return node; 175138"];
7261 [label="var node = ParseExpressionOrPatternForSwitchStatement(); 175139"];
7262 [label="this.CurrentToken 175140"];
7263 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175141"];
7264 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex); 175142"];
7265 [label="this.CurrentToken.ContextualKind 175143"];
7266 [label="get\n            {\n                return this.Kind;\n            } 175144"];
7267 [label="node.Kind 175145"];
7268 [label="get { return (SyntaxKind)this.RawKind; } 175146"];
7269 [label="if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement); 175147"];
7270 [label="if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            } 175148"];
7271 [label="colon = this.EatToken(SyntaxKind.ColonToken); 175149"];
7272 [label="this.EatToken(SyntaxKind.ColonToken) 175150"];
7273 [label="param EatToken(SyntaxKind kind) 175151"];
7274 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 175152"];
7275 [label="SyntaxFacts.IsAnyToken(kind) 175153"];
7276 [label="param IsAnyToken(SyntaxKind kind) 175154"];
7277 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 175155"];
7278 [label="return true; 175156"];
7279 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175157"];
7280 [label="MoveToNextToken(); 175158"];
7281 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 175159"];
7282 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 175160"];
7283 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 175161"];
7284 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 175162"];
7285 [label="label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon); 175163"];
7286 [label="param TryGetNode(SyntaxFactoryContext context) 175164"];
7287 [label="param GetNodeFlags(SyntaxFactoryContext context) 175165"];
7288 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 175166"];
7289 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 175167"];
7290 [label="param SetFactoryContext(SyntaxFactoryContext context) 175168"];
7291 [label="param SetFactoryContext(this) 175169"];
7292 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 175170"];
7293 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 175171"];
7294 [label="labels.Add(label); 175172"];
7295 [label="IsPossibleSwitchSection() 175173"];
7296 [label="param IsPossibleSwitchSection(this) 175174"];
7297 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175175"];
7298 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 175176"];
7299 [label="this.CurrentToken 175177"];
7300 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175178"];
7301 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175179"];
7302 [label="this.CurrentToken.Kind 175180"];
7303 [label="get { return (SyntaxKind)this.RawKind; } 175181"];
7304 [label="do\n                {\n                    SyntaxToken specifier;\n                    SwitchLabelSyntax label;\n                    SyntaxToken colon;\n                    if (this.CurrentToken.Kind == SyntaxKind.CaseKeyword)\n                    {\n                        ExpressionSyntax expression;\n                        specifier = this.EatToken();\n\n                        if (this.CurrentToken.Kind == SyntaxKind.ColonToken)\n                        {\n                            expression = ParseIdentifierName(ErrorCode.ERR_ConstantExpected);\n                            colon = this.EatToken(SyntaxKind.ColonToken);\n                            label = _syntaxFactory.CaseSwitchLabel(specifier, expression, colon);\n                        }\n                        else\n                        {\n                            var node = ParseExpressionOrPatternForSwitchStatement();\n\n                            // if there is a 'when' token, we treat a case expression as a constant pattern.\n                            if (this.CurrentToken.ContextualKind == SyntaxKind.WhenKeyword && node is ExpressionSyntax ex)\n                                node = _syntaxFactory.ConstantPattern(ex);\n\n                            if (node.Kind == SyntaxKind.DiscardPattern)\n                                node = this.AddError(node, ErrorCode.ERR_DiscardPatternInSwitchStatement);\n\n                            if (node is PatternSyntax pat)\n                            {\n                                var whenClause = ParseWhenClause(Precedence.Expression);\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CasePatternSwitchLabel(specifier, pat, whenClause, colon);\n                                label = CheckFeatureAvailability(label, MessageID.IDS_FeaturePatternMatching);\n                            }\n                            else\n                            {\n                                colon = this.EatToken(SyntaxKind.ColonToken);\n                                label = _syntaxFactory.CaseSwitchLabel(specifier, (ExpressionSyntax)node, colon);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(this.CurrentToken.Kind == SyntaxKind.DefaultKeyword);\n                        specifier = this.EatToken(SyntaxKind.DefaultKeyword);\n                        colon = this.EatToken(SyntaxKind.ColonToken);\n                        label = _syntaxFactory.DefaultSwitchLabel(specifier, colon);\n                    }\n\n                    labels.Add(label);\n                }\n                while (IsPossibleSwitchSection()); 175182"];
7305 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 175183"];
7306 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 175184"];
7307 [label="CSharpSyntaxNode tmp = labels[labels.Count - 1]; 175185"];
7308 [label="this.ParseStatements(ref tmp, statements, true); 175186"];
7309 [label="this.ParseStatements(ref tmp, statements, true); 175187"];
7310 [label="this.ParseStatements(ref tmp, statements, true); 175188"];
7311 [label="this.ParseStatements(ref tmp, statements, true) 175189"];
7312 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 175190"];
7313 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 175191"];
7314 [label="param ParseStatements(bool stopOnSwitchSections) 175192"];
7315 [label="param ParseStatements(this) 175193"];
7316 [label="var saveTerm = _termState; 175194"];
7317 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 175195"];
7318 [label="_termState 175196"];
7319 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 175197"];
7320 [label="_termState |= TerminatorState.IsSwitchSectionStart; 175198"];
7321 [label="_termState 175199"];
7322 [label="int lastTokenPosition = -1; 175200"];
7323 [label="this.CurrentToken 175201"];
7324 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175202"];
7325 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175203"];
7326 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175204"];
7327 [label="this.CurrentToken.Kind 175205"];
7328 [label="get { return (SyntaxKind)this.RawKind; } 175206"];
7329 [label="this.CurrentToken 175207"];
7330 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175208"];
7331 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175209"];
7332 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175210"];
7333 [label="this.CurrentToken.Kind 175211"];
7334 [label="get { return (SyntaxKind)this.RawKind; } 175212"];
7335 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175213"];
7336 [label="this.IsPossibleSwitchSection() 175214"];
7337 [label="param IsPossibleSwitchSection(this) 175215"];
7338 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175216"];
7339 [label="this.CurrentToken 175217"];
7340 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175218"];
7341 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175219"];
7342 [label="this.CurrentToken.Kind 175220"];
7343 [label="get { return (SyntaxKind)this.RawKind; } 175221"];
7344 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175222"];
7345 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175223"];
7346 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175224"];
7347 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175225"];
7348 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175226"];
7349 [label="IsMakingProgress(ref lastTokenPosition) 175227"];
7350 [label="param IsMakingProgress(ref int lastTokenPosition) 175228"];
7351 [label="param IsMakingProgress(bool assertIfFalse = true) 175229"];
7352 [label="param IsMakingProgress(this) 175230"];
7353 [label="_firstToken + _tokenOffset 175231"];
7354 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 175232"];
7355 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 175233"];
7356 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 175234"];
7357 [label="this.IsPossibleStatement(acceptAccessibilityMods: true) 175235"];
7358 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 175236"];
7359 [label="param IsPossibleStatement(this) 175237"];
7360 [label="this.CurrentToken 175238"];
7361 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175239"];
7362 [label="var tk = this.CurrentToken.Kind; 175240"];
7363 [label="this.CurrentToken.Kind 175241"];
7364 [label="get { return (SyntaxKind)this.RawKind; } 175242"];
7365 [label="switch (tk)\n            {\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.ThrowKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                case SyntaxKind.OpenBraceToken:\n                case SyntaxKind.SemicolonToken:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.RefKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.OpenBracketToken:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    return IsTrueIdentifier();\n\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.FinallyKeyword:\n                    return !_isInTry;\n\n                // Accessibility modifiers are not legal in a statement,\n                // but a common mistake for local functions. Parse to give a\n                // better error message.\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return acceptAccessibilityMods;\n                default:\n                    return IsPredefinedType(tk)\n                        || IsPossibleExpression();\n            } 175243"];
7366 [label="IsTrueIdentifier() 175244"];
7367 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175245"];
7368 [label="this.CurrentToken 175246"];
7369 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175247"];
7370 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175248"];
7371 [label="return _syntaxFactoryContext.IsInQuery; 175249"];
7372 [label="return IsTrueIdentifier(); 175250"];
7373 [label="if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                } 175251"];
7374 [label="this.ParsePossiblyAttributedStatement() 175252"];
7375 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 175253"];
7376 [label="this.CurrentToken.Kind 175254"];
7377 [label="get { return (SyntaxKind)this.RawKind; } 175255"];
7378 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 175256"];
7379 [label="false 175257"];
7380 [label="isGlobal: false 175258"];
7381 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 175259"];
7382 [label="param ParseStatementCore(bool isGlobal) 175260"];
7383 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175261"];
7384 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175262"];
7385 [label="canReuseStatement(attributes, isGlobal) 175263"];
7386 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175264"];
7387 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175265"];
7388 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175266"];
7389 [label="this.IsIncrementalAndFactoryContextMatches 175267"];
7390 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 175268"];
7391 [label="base.IsIncremental 175269"];
7392 [label="get\n            {\n                return _isIncremental;\n            } 175270"];
7393 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 175271"];
7394 [label="return false; 175272"];
7395 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 175273"];
7396 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175274"];
7397 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 175275"];
7398 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 175276"];
7399 [label="StatementSyntax result; 175277"];
7400 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175278"];
7401 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175279"];
7402 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 175280"];
7403 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 175281"];
7404 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 175282"];
7405 [label="param TryParseStatementStartingWithIdentifier(this) 175283"];
7406 [label="this.CurrentToken 175284"];
7407 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175285"];
7408 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175286"];
7409 [label="this.CurrentToken.ContextualKind 175287"];
7410 [label="get\n            {\n                return this.Kind;\n            } 175288"];
7411 [label="IsPossibleAwaitUsing() 175289"];
7412 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175290"];
7413 [label="CurrentToken 175291"];
7414 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175292"];
7415 [label="CurrentToken.ContextualKind 175293"];
7416 [label="get\n            {\n                return this.Kind;\n            } 175294"];
7417 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 175295"];
7418 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175296"];
7419 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175297"];
7420 [label="this.IsPossibleLabeledStatement() 175298"];
7421 [label="param IsPossibleLabeledStatement(this) 175299"];
7422 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 175300"];
7423 [label="this.PeekToken(1) 175301"];
7424 [label="param PeekToken(int n) 175302"];
7425 [label="param PeekToken(this) 175303"];
7426 [label="Debug.Assert(n >= 0); 175304"];
7427 [label="Debug.Assert(n >= 0); 175305"];
7428 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175306"];
7429 [label="return _lexedTokens[_tokenOffset + n]; 175307"];
7430 [label="this.PeekToken(1).Kind 175308"];
7431 [label="get { return (SyntaxKind)this.RawKind; } 175309"];
7432 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175310"];
7433 [label="this.IsPossibleYieldStatement() 175311"];
7434 [label="param IsPossibleYieldStatement(this) 175312"];
7435 [label="this.CurrentToken 175313"];
7436 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175314"];
7437 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 175315"];
7438 [label="this.CurrentToken.ContextualKind 175316"];
7439 [label="get\n            {\n                return this.Kind;\n            } 175317"];
7440 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175318"];
7441 [label="this.IsPossibleAwaitExpressionStatement() 175319"];
7442 [label="param IsPossibleAwaitExpressionStatement(this) 175320"];
7443 [label="this.IsScript 175321"];
7444 [label="get { return Options.Kind == SourceCodeKind.Script; } 175322"];
7445 [label="Options 175323"];
7446 [label="get { return this.lexer.Options; } 175324"];
7447 [label="this.lexer.Options 175325"];
7448 [label="get { return _options; } 175326"];
7449 [label="return _options; 175327"];
7450 [label="return this.lexer.Options; 175328"];
7451 [label="return Options.Kind == SourceCodeKind.Script; 175329"];
7452 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175330"];
7453 [label="this.IsInAsync 175331"];
7454 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 175332"];
7455 [label="return _syntaxFactoryContext.IsInAsync; 175333"];
7456 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175334"];
7457 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175335"];
7458 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175336"];
7459 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175337"];
7460 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175338"];
7461 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 175339"];
7462 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 175340"];
7463 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 175341"];
7464 [label="param IsQueryExpression(this) 175342"];
7465 [label="this.CurrentToken 175343"];
7466 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175344"];
7467 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 175345"];
7468 [label="this.CurrentToken.ContextualKind 175346"];
7469 [label="get\n            {\n                return this.Kind;\n            } 175347"];
7470 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175348"];
7471 [label="return null; 175349"];
7472 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175350"];
7473 [label="if (result != null)\n                            return result; 175351"];
7474 [label="if (result != null)\n                            return result; 175352"];
7475 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 175353"];
7476 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 175354"];
7477 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 175355"];
7478 [label="ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement) 175356"];
7479 [label="param ParseStatementCoreRest(SyntaxList<AttributeListSyntax> attributes) 175357"];
7480 [label="param ParseStatementCoreRest(bool isGlobal) 175358"];
7481 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 175359"];
7482 [label="param ParseStatementCoreRest(this) 175360"];
7483 [label="isGlobal = isGlobal && IsScript; 175361"];
7484 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 175362"];
7485 [label="this.IsPossibleLocalDeclarationStatement(isGlobal) 175363"];
7486 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 175364"];
7487 [label="param IsPossibleLocalDeclarationStatement(this) 175365"];
7488 [label="this.CurrentToken 175366"];
7489 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175367"];
7490 [label="var tk = this.CurrentToken.Kind; 175368"];
7491 [label="this.CurrentToken.Kind 175369"];
7492 [label="get { return (SyntaxKind)this.RawKind; } 175370"];
7493 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175371"];
7494 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175372"];
7495 [label="IsDeclarationModifier(tk) 175373"];
7496 [label="param IsDeclarationModifier(SyntaxKind kind) 175374"];
7497 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 175375"];
7498 [label="return false; 175376"];
7499 [label="SyntaxFacts.IsPredefinedType(tk) 175377"];
7500 [label="param IsPredefinedType(SyntaxKind kind) 175378"];
7501 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175379"];
7502 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 175380"];
7503 [label="IsPossibleAwaitUsing() 175381"];
7504 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175382"];
7505 [label="CurrentToken 175383"];
7506 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175384"];
7507 [label="CurrentToken.ContextualKind 175385"];
7508 [label="get\n            {\n                return this.Kind;\n            } 175386"];
7509 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 175387"];
7510 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175388"];
7511 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 175389"];
7512 [label="this.CurrentToken 175390"];
7513 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175391"];
7514 [label="tk = this.CurrentToken.ContextualKind; 175392"];
7515 [label="this.CurrentToken.ContextualKind 175393"];
7516 [label="get\n            {\n                return this.Kind;\n            } 175394"];
7517 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 175395"];
7518 [label="IsAdditionalLocalFunctionModifier(tk) 175396"];
7519 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 175397"];
7520 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 175398"];
7521 [label="return false; 175399"];
7522 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 175400"];
7523 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 175401"];
7524 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 175402"];
7525 [label="IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel) 175403"];
7526 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 175404"];
7527 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(this) 175405"];
7528 [label="this.CurrentToken 175406"];
7529 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175407"];
7530 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 175408"];
7531 [label="bool? typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false); 175409"];
7532 [label="this.PeekToken(1) 175410"];
7533 [label="param PeekToken(int n) 175411"];
7534 [label="param PeekToken(this) 175412"];
7535 [label="Debug.Assert(n >= 0); 175413"];
7536 [label="Debug.Assert(n >= 0); 175414"];
7537 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175415"];
7538 [label="return _lexedTokens[_tokenOffset + n]; 175416"];
7539 [label="IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false) 175417"];
7540 [label="param IsPossibleTypedIdentifierStart(SyntaxToken current) 175418"];
7541 [label="param IsPossibleTypedIdentifierStart(SyntaxToken next) 175419"];
7542 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 175420"];
7543 [label="param IsPossibleTypedIdentifierStart(this) 175421"];
7544 [label="if (IsTrueIdentifier(current))\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            } 175422"];
7545 [label="IsTrueIdentifier(current) 175423"];
7546 [label="param IsTrueIdentifier(SyntaxToken token) 175424"];
7547 [label="param IsTrueIdentifier(this) 175425"];
7548 [label="token.Kind 175426"];
7549 [label="get { return (SyntaxKind)this.RawKind; } 175427"];
7550 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 175428"];
7551 [label="this.IsInQuery 175429"];
7552 [label="get { return _syntaxFactoryContext.IsInQuery; } 175430"];
7553 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 175431"];
7554 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 175432"];
7555 [label="next.Kind 175433"];
7556 [label="get { return (SyntaxKind)this.RawKind; } 175434"];
7557 [label="switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                } 175435"];
7558 [label="if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        } 175436"];
7559 [label="current.IsIdentifierVar() 175437"];
7560 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 175438"];
7561 [label="return false; 175439"];
7562 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 175440"];
7563 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 175441"];
7564 [label="return typedIdentifier.Value; 175442"];
7565 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 175443"];
7566 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 175444"];
7567 [label="return this.ParseExpressionStatement(attributes); 175445"];
7568 [label="this.ParseExpressionStatement(attributes) 175446"];
7569 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 175447"];
7570 [label="param ParseExpressionStatement(this) 175448"];
7571 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 175449"];
7572 [label="this.ParseExpressionCore() 175450"];
7573 [label="param ParseExpressionCore(this) 175451"];
7574 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 175452"];
7575 [label="ExpressionSyntax leftOperand; 175453"];
7576 [label="Precedence newPrecedence = 0; 175454"];
7577 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 175455"];
7578 [label="IsInvalidSubExpression(tk) 175456"];
7579 [label="param IsInvalidSubExpression(SyntaxKind kind) 175457"];
7580 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 175458"];
7581 [label="return false; 175459"];
7582 [label="param IsAwaitExpression(this) 175460"];
7583 [label="this.CurrentToken 175461"];
7584 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175462"];
7585 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 175463"];
7586 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 175464"];
7587 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 175465"];
7588 [label="param IsQueryExpression(this) 175466"];
7589 [label="this.CurrentToken 175467"];
7590 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175468"];
7591 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 175469"];
7592 [label="this.CurrentToken.ContextualKind 175470"];
7593 [label="get\n            {\n                return this.Kind;\n            } 175471"];
7594 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175472"];
7595 [label="this.CurrentToken 175473"];
7596 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175474"];
7597 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175475"];
7598 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 175476"];
7599 [label="this.PeekToken(tokenIndex) 175477"];
7600 [label="param PeekToken(int n) 175478"];
7601 [label="Debug.Assert(n >= 0); 175479"];
7602 [label="Debug.Assert(n >= 0); 175480"];
7603 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175481"];
7604 [label="this.PeekToken(tokenIndex).Kind 175482"];
7605 [label="get { return (SyntaxKind)this.RawKind; } 175483"];
7606 [label="this.PeekToken(tokenIndex) 175484"];
7607 [label="param PeekToken(int n) 175485"];
7608 [label="Debug.Assert(n >= 0); 175486"];
7609 [label="Debug.Assert(n >= 0); 175487"];
7610 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175488"];
7611 [label="this.PeekToken(tokenIndex).ContextualKind 175489"];
7612 [label="get\n            {\n                return this.Kind;\n            } 175490"];
7613 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 175491"];
7614 [label="Debug.Assert(n >= 0); 175492"];
7615 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175493"];
7616 [label="param IsPossibleLambdaExpression(Precedence precedence) 175494"];
7617 [label="this.CurrentToken 175495"];
7618 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175496"];
7619 [label="this.CurrentToken.Kind 175497"];
7620 [label="get { return (SyntaxKind)this.RawKind; } 175498"];
7621 [label="this.CurrentToken 175499"];
7622 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175500"];
7623 [label="this.IsTrueIdentifier(this.CurrentToken) 175501"];
7624 [label="param IsTrueIdentifier(SyntaxToken token) 175502"];
7625 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175503"];
7626 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 175504"];
7627 [label="int peekIndex; 175505"];
7628 [label="bool seenStatic; 175506"];
7629 [label="seenStatic = false; 175507"];
7630 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 175508"];
7631 [label="this.PeekToken(peekIndex) 175509"];
7632 [label="param PeekToken(int n) 175510"];
7633 [label="Debug.Assert(n >= 0); 175511"];
7634 [label="Debug.Assert(n >= 0); 175512"];
7635 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175513"];
7636 [label="this.PeekToken(peekIndex).Kind 175514"];
7637 [label="get { return (SyntaxKind)this.RawKind; } 175515"];
7638 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175516"];
7639 [label="this.PeekToken(peekIndex) 175517"];
7640 [label="param PeekToken(int n) 175518"];
7641 [label="Debug.Assert(n >= 0); 175519"];
7642 [label="Debug.Assert(n >= 0); 175520"];
7643 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175521"];
7644 [label="this.PeekToken(peekIndex).Kind 175522"];
7645 [label="get { return (SyntaxKind)this.RawKind; } 175523"];
7646 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175524"];
7647 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175525"];
7648 [label="this.PeekToken(peekIndex + 1) 175526"];
7649 [label="param PeekToken(int n) 175527"];
7650 [label="Debug.Assert(n >= 0); 175528"];
7651 [label="Debug.Assert(n >= 0); 175529"];
7652 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175530"];
7653 [label="this.PeekToken(peekIndex + 1).Kind 175531"];
7654 [label="get { return (SyntaxKind)this.RawKind; } 175532"];
7655 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175533"];
7656 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 175534"];
7657 [label="this.PeekToken(peekIndex) 175535"];
7658 [label="param PeekToken(int n) 175536"];
7659 [label="Debug.Assert(n >= 0); 175537"];
7660 [label="Debug.Assert(n >= 0); 175538"];
7661 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175539"];
7662 [label="this.PeekToken(peekIndex).Kind 175540"];
7663 [label="get { return (SyntaxKind)this.RawKind; } 175541"];
7664 [label="Debug.Assert(n >= 0); 175542"];
7665 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175543"];
7666 [label="return _lexedTokens[_tokenOffset + n]; 175544"];
7667 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 175545"];
7668 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 175546"];
7669 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 175547"];
7670 [label="this.IsIncrementalAndFactoryContextMatches 175548"];
7671 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 175549"];
7672 [label="base.IsIncremental 175550"];
7673 [label="get\n            {\n                return _isIncremental;\n            } 175551"];
7674 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 175552"];
7675 [label="return false; 175553"];
7676 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 175554"];
7677 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 175555"];
7678 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 175556"];
7679 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175557"];
7680 [label="this.CurrentToken 175558"];
7681 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175559"];
7682 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175560"];
7683 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175561"];
7684 [label="IsCurrentTokenQueryKeywordInQuery() 175562"];
7685 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175563"];
7686 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175564"];
7687 [label="param GetTrailingTrivia(this) 175565"];
7688 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175566"];
7689 [label="MoveToNextToken(); 175567"];
7690 [label="this.IsInAsync 175568"];
7691 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 175569"];
7692 [label="return _syntaxFactoryContext.IsInAsync; 175570"];
7693 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 175571"];
7694 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 175572"];
7695 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175573"];
7696 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 175574"];
7697 [label="this.CurrentToken.Kind 175575"];
7698 [label="get { return (SyntaxKind)this.RawKind; } 175576"];
7699 [label="this.CurrentToken 175577"];
7700 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175578"];
7701 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 175579"];
7702 [label="this.CurrentToken.Kind 175580"];
7703 [label="get { return (SyntaxKind)this.RawKind; } 175581"];
7704 [label="param ParseParenthesizedArgumentList(this) 175582"];
7705 [label="this.IsIncrementalAndFactoryContextMatches 175583"];
7706 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 175584"];
7707 [label="base.IsIncremental 175585"];
7708 [label="get\n            {\n                return _isIncremental;\n            } 175586"];
7709 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 175587"];
7710 [label="return false; 175588"];
7711 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            } 175589"];
7712 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 175590"];
7713 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 175591"];
7714 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 175592"];
7715 [label="param EatTokenAsKind(SyntaxKind expected) 175593"];
7716 [label="param EatTokenAsKind(this) 175594"];
7717 [label="Debug.Assert(SyntaxFacts.IsAnyToken(expected)); 175595"];
7718 [label="SyntaxFacts.IsAnyToken(expected) 175596"];
7719 [label="param IsAnyToken(SyntaxKind kind) 175597"];
7720 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 175598"];
7721 [label="return true; 175599"];
7722 [label="this.CurrentToken 175600"];
7723 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175601"];
7724 [label="var ct = this.CurrentToken; 175602"];
7725 [label="ct.Kind 175603"];
7726 [label="get { return (SyntaxKind)this.RawKind; } 175604"];
7727 [label="if (ct.Kind == expected)\n            {\n                MoveToNextToken();\n                return ct;\n            } 175605"];
7728 [label="if (ct.Kind == expected)\n            {\n                MoveToNextToken();\n                return ct;\n            } 175606"];
7729 [label="MoveToNextToken() 175607"];
7730 [label="param GetTrailingTrivia(this) 175608"];
7731 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175609"];
7732 [label="MoveToNextToken(); 175610"];
7733 [label="return ct; 175611"];
7734 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken); 175612"];
7735 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175613"];
7736 [label="param GetTrailingTrivia(this) 175614"];
7737 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175615"];
7738 [label="MoveToNextToken(); 175616"];
7739 [label="return _syntaxFactory.ArgumentList(openToken, arguments, closeToken); 175617"];
7740 [label="return _syntaxFactory.ArgumentList(openToken, arguments, closeToken); 175618"];
7741 [label="param GetNodeFlags(SyntaxFactoryContext context) 175619"];
7742 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 175620"];
7743 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 175621"];
7744 [label="param SetFactoryContext(SyntaxFactoryContext context) 175622"];
7745 [label="param SetFactoryContext(this) 175623"];
7746 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 175624"];
7747 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 175625"];
7748 [label="param TryGetNode(int kind) 175626"];
7749 [label="param TryGetNode(GreenNode child1) 175627"];
7750 [label="param TryGetNode(GreenNode child2) 175628"];
7751 [label="param TryGetNode(SyntaxFactoryContext context) 175629"];
7752 [label="param TryGetNode(out int hash) 175630"];
7753 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175631"];
7754 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175632"];
7755 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175633"];
7756 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175634"];
7757 [label="GetNodeFlags(context) 175635"];
7758 [label="param GetNodeFlags(SyntaxFactoryContext context) 175636"];
7759 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 175637"];
7760 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 175638"];
7761 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175639"];
7762 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175640"];
7763 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 175641"];
7764 [label="param SetFactoryContext(SyntaxFactoryContext context) 175642"];
7765 [label="param SetFactoryContext(this) 175643"];
7766 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 175644"];
7767 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 175645"];
7768 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175646"];
7769 [label="param ParseExpressionContinued(Precedence precedence) 175647"];
7770 [label="param ParseExpressionContinued(this) 175648"];
7771 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 175649"];
7772 [label="this.CurrentToken 175650"];
7773 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175651"];
7774 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175652"];
7775 [label="var tk = this.CurrentToken.ContextualKind; 175653"];
7776 [label="this.CurrentToken.ContextualKind 175654"];
7777 [label="get\n            {\n                return this.Kind;\n            } 175655"];
7778 [label="bool isAssignmentOperator = false; 175656"];
7779 [label="SyntaxKind opKind; 175657"];
7780 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175658"];
7781 [label="IsExpectedBinaryOperator(tk) 175659"];
7782 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 175660"];
7783 [label="return SyntaxFacts.IsBinaryExpression(kind); 175661"];
7784 [label="SyntaxFacts.IsBinaryExpression(kind) 175662"];
7785 [label="param IsBinaryExpression(SyntaxKind token) 175663"];
7786 [label="return GetBinaryExpression(token) != SyntaxKind.None; 175664"];
7787 [label="GetBinaryExpression(token) 175665"];
7788 [label="param GetBinaryExpression(SyntaxKind token) 175666"];
7789 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 175667"];
7790 [label="return SyntaxKind.None; 175668"];
7791 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175669"];
7792 [label="IsExpectedAssignmentOperator(tk) 175670"];
7793 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 175671"];
7794 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 175672"];
7795 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 175673"];
7796 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 175674"];
7797 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 175675"];
7798 [label="return false; 175676"];
7799 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175677"];
7800 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175678"];
7801 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 175679"];
7802 [label="CurrentToken 175680"];
7803 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175681"];
7804 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 175682"];
7805 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 175683"];
7806 [label="CurrentToken.Kind 175684"];
7807 [label="get { return (SyntaxKind)this.RawKind; } 175685"];
7808 [label="_ = GetPrecedence(result.Kind); 175686"];
7809 [label="result.Kind 175687"];
7810 [label="get { return (SyntaxKind)this.RawKind; } 175688"];
7811 [label="_ = GetPrecedence(result.Kind); 175689"];
7812 [label="GetPrecedence(result.Kind) 175690"];
7813 [label="param GetPrecedence(SyntaxKind op) 175691"];
7814 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 175692"];
7815 [label="return Precedence.Primary; 175693"];
7816 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 175694"];
7817 [label="ParseExpressionStatement(attributes, this.ParseExpressionCore()) 175695"];
7818 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 175696"];
7819 [label="param ParseExpressionStatement(ExpressionSyntax expression) 175697"];
7820 [label="param ParseExpressionStatement(this) 175698"];
7821 [label="SyntaxToken semicolon; 175699"];
7822 [label="IsScript 175700"];
7823 [label="get { return Options.Kind == SourceCodeKind.Script; } 175701"];
7824 [label="Options 175702"];
7825 [label="get { return this.lexer.Options; } 175703"];
7826 [label="this.lexer.Options 175704"];
7827 [label="get { return _options; } 175705"];
7828 [label="return _options; 175706"];
7829 [label="return this.lexer.Options; 175707"];
7830 [label="return Options.Kind == SourceCodeKind.Script; 175708"];
7831 [label="if (IsScript && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            } 175709"];
7832 [label="semicolon = this.EatToken(SyntaxKind.SemicolonToken); 175710"];
7833 [label="this.EatToken(SyntaxKind.SemicolonToken) 175711"];
7834 [label="param EatToken(SyntaxKind kind) 175712"];
7835 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 175713"];
7836 [label="SyntaxFacts.IsAnyToken(kind) 175714"];
7837 [label="param IsAnyToken(SyntaxKind kind) 175715"];
7838 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 175716"];
7839 [label="return true; 175717"];
7840 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175718"];
7841 [label="MoveToNextToken(); 175719"];
7842 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 175720"];
7843 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 175721"];
7844 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 175722"];
7845 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 175723"];
7846 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 175724"];
7847 [label="param GetNodeFlags(SyntaxFactoryContext context) 175725"];
7848 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 175726"];
7849 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 175727"];
7850 [label="param SetFactoryContext(SyntaxFactoryContext context) 175728"];
7851 [label="param SetFactoryContext(this) 175729"];
7852 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 175730"];
7853 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 175731"];
7854 [label="_recursionDepth 175732"];
7855 [label="this.Release(ref resetPointBeforeStatement); 175733"];
7856 [label="this.Release(ref resetPointBeforeStatement) 175734"];
7857 [label="param Release(ref ResetPoint state) 175735"];
7858 [label="base.Release(ref state.BaseResetPoint); 175736"];
7859 [label="param Release(ref ResetPoint point) 175737"];
7860 [label="Debug.Assert(_resetCount == point.ResetCount); 175738"];
7861 [label="_resetCount 175739"];
7862 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 175740"];
7863 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 175741"];
7864 [label="base.Release(ref state.BaseResetPoint); 175742"];
7865 [label="this.Release(ref resetPointBeforeStatement); 175743"];
7866 [label="var statement = this.ParsePossiblyAttributedStatement(); 175744"];
7867 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 175745"];
7868 [label="if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    } 175746"];
7869 [label="statements.Add(statement); 175747"];
7870 [label="statements.Add(statement); 175748"];
7871 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175749"];
7872 [label="param IsMakingProgress(bool assertIfFalse = true) 175750"];
7873 [label="param IsPossibleStatement(bool acceptAccessibilityMods) 175751"];
7874 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175752"];
7875 [label="this.CurrentToken 175753"];
7876 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175754"];
7877 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175755"];
7878 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 175756"];
7879 [label="this.CurrentToken.Kind 175757"];
7880 [label="get { return (SyntaxKind)this.RawKind; } 175758"];
7881 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 175759"];
7882 [label="false 175760"];
7883 [label="isGlobal: false 175761"];
7884 [label="param ParseStatementCore(bool isGlobal) 175762"];
7885 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175763"];
7886 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175764"];
7887 [label="canReuseStatement(attributes, isGlobal) 175765"];
7888 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175766"];
7889 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175767"];
7890 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 175768"];
7891 [label="this.IsIncrementalAndFactoryContextMatches 175769"];
7892 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 175770"];
7893 [label="base.IsIncremental 175771"];
7894 [label="get\n            {\n                return _isIncremental;\n            } 175772"];
7895 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 175773"];
7896 [label="return false; 175774"];
7897 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 175775"];
7898 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 175776"];
7899 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 175777"];
7900 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 175778"];
7901 [label="StatementSyntax result; 175779"];
7902 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175780"];
7903 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175781"];
7904 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 175782"];
7905 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 175783"];
7906 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 175784"];
7907 [label="param TryParseStatementStartingWithIdentifier(this) 175785"];
7908 [label="this.CurrentToken 175786"];
7909 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175787"];
7910 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175788"];
7911 [label="this.CurrentToken.ContextualKind 175789"];
7912 [label="get\n            {\n                return this.Kind;\n            } 175790"];
7913 [label="IsPossibleAwaitUsing() 175791"];
7914 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175792"];
7915 [label="CurrentToken 175793"];
7916 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175794"];
7917 [label="CurrentToken.ContextualKind 175795"];
7918 [label="get\n            {\n                return this.Kind;\n            } 175796"];
7919 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 175797"];
7920 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175798"];
7921 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175799"];
7922 [label="this.IsPossibleLabeledStatement() 175800"];
7923 [label="param IsPossibleLabeledStatement(this) 175801"];
7924 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 175802"];
7925 [label="this.PeekToken(1) 175803"];
7926 [label="param PeekToken(int n) 175804"];
7927 [label="param PeekToken(this) 175805"];
7928 [label="Debug.Assert(n >= 0); 175806"];
7929 [label="Debug.Assert(n >= 0); 175807"];
7930 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175808"];
7931 [label="return _lexedTokens[_tokenOffset + n]; 175809"];
7932 [label="this.PeekToken(1).Kind 175810"];
7933 [label="get { return (SyntaxKind)this.RawKind; } 175811"];
7934 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175812"];
7935 [label="this.IsPossibleYieldStatement() 175813"];
7936 [label="param IsPossibleYieldStatement(this) 175814"];
7937 [label="this.CurrentToken 175815"];
7938 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175816"];
7939 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 175817"];
7940 [label="this.CurrentToken.ContextualKind 175818"];
7941 [label="get\n            {\n                return this.Kind;\n            } 175819"];
7942 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175820"];
7943 [label="this.IsPossibleAwaitExpressionStatement() 175821"];
7944 [label="param IsPossibleAwaitExpressionStatement(this) 175822"];
7945 [label="this.IsScript 175823"];
7946 [label="get { return Options.Kind == SourceCodeKind.Script; } 175824"];
7947 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175825"];
7948 [label="this.IsInAsync 175826"];
7949 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 175827"];
7950 [label="return _syntaxFactoryContext.IsInAsync; 175828"];
7951 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175829"];
7952 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 175830"];
7953 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175831"];
7954 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175832"];
7955 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175833"];
7956 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 175834"];
7957 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 175835"];
7958 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 175836"];
7959 [label="param IsQueryExpression(this) 175837"];
7960 [label="this.CurrentToken 175838"];
7961 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175839"];
7962 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 175840"];
7963 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 175841"];
7964 [label="return null; 175842"];
7965 [label="result = TryParseStatementStartingWithIdentifier(attributes, isGlobal); 175843"];
7966 [label="if (result != null)\n                            return result; 175844"];
7967 [label="if (result != null)\n                            return result; 175845"];
7968 [label="param ParseStatementCoreRest(bool isGlobal) 175846"];
7969 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 175847"];
7970 [label="isGlobal = isGlobal && IsScript; 175848"];
7971 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 175849"];
7972 [label="this.CurrentToken 175850"];
7973 [label="var tk = this.CurrentToken.Kind; 175851"];
7974 [label="this.CurrentToken.Kind 175852"];
7975 [label="get { return (SyntaxKind)this.RawKind; } 175853"];
7976 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175854"];
7977 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175855"];
7978 [label="IsDeclarationModifier(tk) 175856"];
7979 [label="param IsDeclarationModifier(SyntaxKind kind) 175857"];
7980 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 175858"];
7981 [label="return false; 175859"];
7982 [label="SyntaxFacts.IsPredefinedType(tk) 175860"];
7983 [label="param IsPredefinedType(SyntaxKind kind) 175861"];
7984 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 175862"];
7985 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 175863"];
7986 [label="IsPossibleAwaitUsing() 175864"];
7987 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175865"];
7988 [label="CurrentToken 175866"];
7989 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175867"];
7990 [label="CurrentToken.ContextualKind 175868"];
7991 [label="get\n            {\n                return this.Kind;\n            } 175869"];
7992 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 175870"];
7993 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 175871"];
7994 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 175872"];
7995 [label="this.CurrentToken 175873"];
7996 [label="tk = this.CurrentToken.ContextualKind; 175874"];
7997 [label="this.CurrentToken.ContextualKind 175875"];
7998 [label="get\n            {\n                return this.Kind;\n            } 175876"];
7999 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 175877"];
8000 [label="IsAdditionalLocalFunctionModifier(tk) 175878"];
8001 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 175879"];
8002 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 175880"];
8003 [label="return false; 175881"];
8004 [label="var isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)); 175882"];
8005 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 175883"];
8006 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 175884"];
8007 [label="Debug.Assert(n >= 0); 175885"];
8008 [label="Debug.Assert(n >= 0); 175886"];
8009 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175887"];
8010 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 175888"];
8011 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 175889"];
8012 [label="ExpressionSyntax leftOperand; 175890"];
8013 [label="Precedence newPrecedence = 0; 175891"];
8014 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 175892"];
8015 [label="IsInvalidSubExpression(tk) 175893"];
8016 [label="param IsInvalidSubExpression(SyntaxKind kind) 175894"];
8017 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 175895"];
8018 [label="return false; 175896"];
8019 [label="param IsAwaitExpression(this) 175897"];
8020 [label="this.CurrentToken 175898"];
8021 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175899"];
8022 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 175900"];
8023 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 175901"];
8024 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 175902"];
8025 [label="param IsQueryExpression(this) 175903"];
8026 [label="this.CurrentToken 175904"];
8027 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175905"];
8028 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 175906"];
8029 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175907"];
8030 [label="this.CurrentToken 175908"];
8031 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175909"];
8032 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175910"];
8033 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 175911"];
8034 [label="Debug.Assert(n >= 0); 175912"];
8035 [label="Debug.Assert(n >= 0); 175913"];
8036 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175914"];
8037 [label="this.PeekToken(tokenIndex).Kind 175915"];
8038 [label="get { return (SyntaxKind)this.RawKind; } 175916"];
8039 [label="this.PeekToken(tokenIndex) 175917"];
8040 [label="param PeekToken(int n) 175918"];
8041 [label="Debug.Assert(n >= 0); 175919"];
8042 [label="Debug.Assert(n >= 0); 175920"];
8043 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175921"];
8044 [label="this.PeekToken(tokenIndex).ContextualKind 175922"];
8045 [label="get\n            {\n                return this.Kind;\n            } 175923"];
8046 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 175924"];
8047 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175925"];
8048 [label="return _lexedTokens[_tokenOffset + n]; 175926"];
8049 [label="param IsPossibleLambdaExpression(Precedence precedence) 175927"];
8050 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175928"];
8051 [label="this.CurrentToken.Kind 175929"];
8052 [label="get { return (SyntaxKind)this.RawKind; } 175930"];
8053 [label="this.CurrentToken 175931"];
8054 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175932"];
8055 [label="this.IsTrueIdentifier(this.CurrentToken) 175933"];
8056 [label="param IsTrueIdentifier(SyntaxToken token) 175934"];
8057 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)); 175935"];
8058 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 175936"];
8059 [label="int peekIndex; 175937"];
8060 [label="bool seenStatic; 175938"];
8061 [label="seenStatic = false; 175939"];
8062 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 175940"];
8063 [label="Debug.Assert(n >= 0); 175941"];
8064 [label="Debug.Assert(n >= 0); 175942"];
8065 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175943"];
8066 [label="this.PeekToken(peekIndex).Kind 175944"];
8067 [label="get { return (SyntaxKind)this.RawKind; } 175945"];
8068 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175946"];
8069 [label="this.PeekToken(peekIndex) 175947"];
8070 [label="param PeekToken(int n) 175948"];
8071 [label="Debug.Assert(n >= 0); 175949"];
8072 [label="Debug.Assert(n >= 0); 175950"];
8073 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175951"];
8074 [label="this.PeekToken(peekIndex).Kind 175952"];
8075 [label="get { return (SyntaxKind)this.RawKind; } 175953"];
8076 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175954"];
8077 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175955"];
8078 [label="this.PeekToken(peekIndex + 1) 175956"];
8079 [label="param PeekToken(int n) 175957"];
8080 [label="Debug.Assert(n >= 0); 175958"];
8081 [label="Debug.Assert(n >= 0); 175959"];
8082 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175960"];
8083 [label="this.PeekToken(peekIndex + 1).Kind 175961"];
8084 [label="get { return (SyntaxKind)this.RawKind; } 175962"];
8085 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 175963"];
8086 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 175964"];
8087 [label="this.PeekToken(peekIndex) 175965"];
8088 [label="param PeekToken(int n) 175966"];
8089 [label="Debug.Assert(n >= 0); 175967"];
8090 [label="Debug.Assert(n >= 0); 175968"];
8091 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175969"];
8092 [label="this.PeekToken(peekIndex).Kind 175970"];
8093 [label="get { return (SyntaxKind)this.RawKind; } 175971"];
8094 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 175972"];
8095 [label="return _lexedTokens[_tokenOffset + n]; 175973"];
8096 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 175974"];
8097 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 175975"];
8098 [label="this.IsIncrementalAndFactoryContextMatches 175976"];
8099 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 175977"];
8100 [label="base.IsIncremental 175978"];
8101 [label="get\n            {\n                return _isIncremental;\n            } 175979"];
8102 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 175980"];
8103 [label="return false; 175981"];
8104 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 175982"];
8105 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 175983"];
8106 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 175984"];
8107 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 175985"];
8108 [label="this.CurrentToken 175986"];
8109 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 175987"];
8110 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 175988"];
8111 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175989"];
8112 [label="IsCurrentTokenQueryKeywordInQuery() 175990"];
8113 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175991"];
8114 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 175992"];
8115 [label="param GetTrailingTrivia(this) 175993"];
8116 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 175994"];
8117 [label="MoveToNextToken(); 175995"];
8118 [label="this.IsInAsync 175996"];
8119 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 175997"];
8120 [label="return _syntaxFactoryContext.IsInAsync; 175998"];
8121 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 175999"];
8122 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 176000"];
8123 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 176001"];
8124 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 176002"];
8125 [label="this.CurrentToken.Kind 176003"];
8126 [label="get { return (SyntaxKind)this.RawKind; } 176004"];
8127 [label="this.CurrentToken 176005"];
8128 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 176006"];
8129 [label="this.CurrentToken.Kind 176007"];
8130 [label="get { return (SyntaxKind)this.RawKind; } 176008"];
8131 [label="this.IsIncrementalAndFactoryContextMatches 176009"];
8132 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 176010"];
8133 [label="base.IsIncremental 176011"];
8134 [label="get\n            {\n                return _isIncremental;\n            } 176012"];
8135 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 176013"];
8136 [label="return false; 176014"];
8137 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            } 176015"];
8138 [label="Debug.Assert(SyntaxFacts.IsAnyToken(expected)); 176016"];
8139 [label="SyntaxFacts.IsAnyToken(expected) 176017"];
8140 [label="param IsAnyToken(SyntaxKind kind) 176018"];
8141 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 176019"];
8142 [label="return true; 176020"];
8143 [label="param GetTrailingTrivia(this) 176021"];
8144 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 176022"];
8145 [label="MoveToNextToken(); 176023"];
8146 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 176024"];
8147 [label="param GetNodeFlags(SyntaxFactoryContext context) 176025"];
8148 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 176026"];
8149 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 176027"];
8150 [label="param TryGetNode(SyntaxFactoryContext context) 176028"];
8151 [label="param GetNodeFlags(SyntaxFactoryContext context) 176029"];
8152 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 176030"];
8153 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 176031"];
8154 [label="param SetFactoryContext(SyntaxFactoryContext context) 176032"];
8155 [label="param SetFactoryContext(this) 176033"];
8156 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 176034"];
8157 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 176035"];
8158 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 176036"];
8159 [label="param ParseExpressionContinued(Precedence precedence) 176037"];
8160 [label="param ParseExpressionContinued(this) 176038"];
8161 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 176039"];
8162 [label="this.CurrentToken 176040"];
8163 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 176041"];
8164 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 176042"];
8165 [label="var tk = this.CurrentToken.ContextualKind; 176043"];
8166 [label="this.CurrentToken.ContextualKind 176044"];
8167 [label="get\n            {\n                return this.Kind;\n            } 176045"];
8168 [label="bool isAssignmentOperator = false; 176046"];
8169 [label="SyntaxKind opKind; 176047"];
8170 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 176048"];
8171 [label="IsExpectedBinaryOperator(tk) 176049"];
8172 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 176050"];
8173 [label="return SyntaxFacts.IsBinaryExpression(kind); 176051"];
8174 [label="SyntaxFacts.IsBinaryExpression(kind) 176052"];
8175 [label="param IsBinaryExpression(SyntaxKind token) 176053"];
8176 [label="return GetBinaryExpression(token) != SyntaxKind.None; 176054"];
8177 [label="GetBinaryExpression(token) 176055"];
8178 [label="param GetBinaryExpression(SyntaxKind token) 176056"];
8179 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 176057"];
8180 [label="return SyntaxKind.None; 176058"];
8181 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 176059"];
8182 [label="IsExpectedAssignmentOperator(tk) 176060"];
8183 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 176061"];
8184 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 176062"];
8185 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 176063"];
8186 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 176064"];
8187 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 176065"];
8188 [label="return false; 176066"];
8189 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 176067"];
8190 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 176068"];
8191 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 176069"];
8192 [label="CurrentToken 176070"];
8193 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 176071"];
8194 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 176072"];
8195 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 176073"];
8196 [label="CurrentToken.Kind 176074"];
8197 [label="get { return (SyntaxKind)this.RawKind; } 176075"];
8198 [label="_ = GetPrecedence(result.Kind); 176076"];
8199 [label="result.Kind 176077"];
8200 [label="get { return (SyntaxKind)this.RawKind; } 176078"];
8201 [label="_ = GetPrecedence(result.Kind); 176079"];
8202 [label="GetPrecedence(result.Kind) 176080"];
8203 [label="param GetPrecedence(SyntaxKind op) 176081"];
8204 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 176082"];
8205 [label="return Precedence.Primary; 176083"];
8206 [label="SyntaxToken semicolon; 176084"];
8207 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 176085"];
8208 [label="SyntaxFacts.IsAnyToken(kind) 176086"];
8209 [label="param IsAnyToken(SyntaxKind kind) 176087"];
8210 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 176088"];
8211 [label="return true; 176089"];
8212 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 176090"];
8213 [label="MoveToNextToken(); 176091"];
8214 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 176092"];
8215 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 176093"];
8216 [label="this.Release(ref resetPointBeforeStatement); 176094"];
8217 [label="param Release(ref ResetPoint state) 176095"];
8218 [label="base.Release(ref state.BaseResetPoint); 176096"];
8219 [label="param Release(ref ResetPoint point) 176097"];
8220 [label="Debug.Assert(_resetCount == point.ResetCount); 176098"];
8221 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 176099"];
8222 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 176100"];
8223 [label="base.Release(ref state.BaseResetPoint); 176101"];
8224 [label="this.Release(ref resetPointBeforeStatement); 176102"];
8225 [label="_termState 176103"];
8226 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 176104"];
8227 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 176105"];
8228 [label="labels[labels.Count - 1] = (SwitchLabelSyntax)tmp; 176106"];
8229 [label="return _syntaxFactory.SwitchSection(labels, statements); 176107"];
8230 [label="return _syntaxFactory.SwitchSection(labels, statements); 176108"];
8231 [label="return _syntaxFactory.SwitchSection(labels, statements); 176109"];
8232 [label="return _syntaxFactory.SwitchSection(labels, statements); 176110"];
8233 [label="GetNodeFlags(context) 176111"];
8234 [label="param GetNodeFlags(SyntaxFactoryContext context) 176112"];
8235 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 176113"];
8236 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 176114"];
8237 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 176115"];
8238 [label="param SetFactoryContext(SyntaxFactoryContext context) 176116"];
8239 [label="param SetFactoryContext(this) 176117"];
8240 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 176118"];
8241 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 176119"];
8242 [label="_pool.Free(statements); 176120"];
8243 [label="_pool.Free(statements); 176121"];
8244 [label="_pool.Free(labels); 176122"];
8245 [label="_pool.Free(labels); 176123"];
8246 [label="var swcase = this.ParseSwitchSection(); 176124"];
8247 [label="sections.Add(swcase); 176125"];
8248 [label="sections.Add(swcase); 176126"];
8249 [label="this.CurrentToken 176127"];
8250 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 176128"];
8251 [label="this.CurrentToken.Kind 176129"];
8252 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 176130"];
8253 [label="this.EatToken(SyntaxKind.CloseBraceToken) 176131"];
8254 [label="param EatToken(SyntaxKind kind) 176132"];
8255 [label="param EatToken(this) 176133"];
8256 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 176134"];
8257 [label="SyntaxFacts.IsAnyToken(kind) 176135"];
8258 [label="param IsAnyToken(SyntaxKind kind) 176136"];
8259 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 176137"];
8260 [label="return true; 176138"];
8261 [label="this.CurrentToken 176139"];
8262 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 176140"];
8263 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 176141"];
8264 [label="ct.Kind 176142"];
8265 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 176143"];
8266 [label="param GetTrailingTrivia(this) 176144"];
8267 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 176145"];
8268 [label="MoveToNextToken(); 176146"];
8269 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176147"];
8270 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176148"];
8271 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176149"];
8272 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176150"];
8273 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176151"];
8274 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176152"];
8275 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176153"];
8276 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176154"];
8277 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176155"];
8278 [label="return _syntaxFactory.SwitchStatement(attributes, @switch, openParen, expression, closeParen, openBrace, sections, closeBrace); 176156"];
8279 [label="param CSharpSyntaxNode(this) 176157"];
8280 [label="GreenStats.NoteGreen(this); 176158"];
8281 [label="param SetFactoryContext(SyntaxFactoryContext context) 176159"];
8282 [label="param SetFactoryContext(this) 176160"];
8283 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 176161"];
8284 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 176162"];
8285 [label="_pool.Free(sections); 176163"];
8286 [label="_pool.Free(sections); 176164"];
8287 [label="this.Release(ref resetPointBeforeStatement); 176165"];
8288 [label="this.Release(ref resetPointBeforeStatement) 176166"];
8289 [label="param Release(ref ResetPoint state) 176167"];
8290 [label="param Release(this) 176168"];
8291 [label="base.Release(ref state.BaseResetPoint); 176169"];
8292 [label="base.Release(ref state.BaseResetPoint) 176170"];
8293 [label="param Release(ref ResetPoint point) 176171"];
8294 [label="param Release(this) 176172"];
8295 [label="Debug.Assert(_resetCount == point.ResetCount); 176173"];
8296 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 176174"];
8297 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 176175"];
8298 [label="_resetStart = -1; 176176"];
8299 [label="_resetStart 176177"];
8300 [label="base.Release(ref state.BaseResetPoint); 176178"];
8301 [label="this.Release(ref resetPointBeforeStatement); 176179"];
8302 [label="var node = parser.ParseStatement(); 176180"];
8303 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 176181"];
8304 [label="node = parser.ConsumeUnexpectedTokens(node); 176182"];
8305 [label="parser.ConsumeUnexpectedTokens(node) 176183"];
8306 [label="param ConsumeUnexpectedTokens(TNode node) 176184"];
8307 [label="param ConsumeUnexpectedTokens(this) 176185"];
8308 [label="this.CurrentToken 176186"];
8309 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 176187"];
8310 [label="this.FetchCurrentToken() 176188"];
8311 [label="param FetchCurrentToken(this) 176189"];
8312 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 176190"];
8313 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 176191"];
8314 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 176192"];
8315 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 176193"];
8316 [label="this.CurrentToken.Kind 176194"];
8317 [label="get { return (SyntaxKind)this.RawKind; } 176195"];
8318 [label="return node; 176196"];
8319 [label="return (StatementSyntax)node.CreateRed(); 176197"];
8320 [label="return (StatementSyntax)node.CreateRed(); 176198"];
8321 [label="return (StatementSyntax)node.CreateRed(); 176199"];
8322 [label="param CSharpSyntaxNode(GreenNode green) 176200"];
8323 [label="param CSharpSyntaxNode(SyntaxNode? parent) 176201"];
8324 [label="param CSharpSyntaxNode(int position) 176202"];
8325 [label="param CSharpSyntaxNode(this) 176203"];
8326 [label="green 176204"];
8327 [label="parent 176205"];
8328 [label="position 176206"];
8329 [label="param CSharpSyntaxNode(this) 176207"];
8330 [label="param CSharpSyntaxNode(this) 176208"];
8331 [label="CustomAssert.NotNull(statement); 176209"];
8332 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 176210"];
8333 [label="statement.Kind() 176211"];
8334 [label="param Kind(this) 176212"];
8335 [label="return (SyntaxKind)this.Green.RawKind; 176213"];
8336 [label="CustomAssert.Equal(SyntaxKind.SwitchStatement, statement.Kind()); 176214"];
8337 [label="CustomAssert.Equal(text, statement.ToString()); 176215"];
8338 [label="CustomAssert.Equal(text, statement.ToString()); 176216"];
8339 [label="CustomAssert.Equal(text, statement.ToString()); 176217"];
8340 [label="=> true 176218"];
8341 [label="true 176219"];
8342 [label="CustomAssert.Equal(text, statement.ToString()); 176220"];
8343 [label="param WriteTokenTo(System.IO.TextWriter writer) 176221"];
8344 [label="param WriteTokenTo(bool leading) 176222"];
8345 [label="param WriteTokenTo(bool trailing) 176223"];
8346 [label="param WriteTokenTo(this) 176224"];
8347 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 176225"];
8348 [label="this.Text 176226"];
8349 [label="get { return SyntaxFacts.GetText(this.Kind); } 176227"];
8350 [label="this.Kind 176228"];
8351 [label="get { return (SyntaxKind)this.RawKind; } 176229"];
8352 [label="return (SyntaxKind)this.RawKind; 176230"];
8353 [label="return SyntaxFacts.GetText(this.Kind); 176231"];
8354 [label="SyntaxFacts.GetText(this.Kind) 176232"];
8355 [label="param GetText(SyntaxKind kind) 176233"];
8356 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 176234"];
8357 [label="return 'switch'; 176235"];
8358 [label="writer.Write(this.Text); 176236"];
8359 [label="writer.Write(this.Text); 176237"];
8360 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 176238"];
8361 [label="this.GetTrailingTrivia() 176239"];
8362 [label="param GetTrailingTrivia(this) 176240"];
8363 [label="return this.TrailingField; 176241"];
8364 [label="var trivia = this.GetTrailingTrivia(); 176242"];
8365 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176243"];
8366 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176244"];
8367 [label="trivia.WriteTo(writer, true, true); 176245"];
8368 [label="trivia.WriteTo(writer, true, true); 176246"];
8369 [label="=> true 176247"];
8370 [label="true 176248"];
8371 [label="param WriteTriviaTo(System.IO.TextWriter writer) 176249"];
8372 [label="param WriteTriviaTo(this) 176250"];
8373 [label="writer.Write(Text); 176251"];
8374 [label="writer.Write(Text); 176252"];
8375 [label="this.GetLeadingTrivia() 176253"];
8376 [label="param GetLeadingTrivia(this) 176254"];
8377 [label="return null; 176255"];
8378 [label="var trivia = this.GetLeadingTrivia(); 176256"];
8379 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176257"];
8380 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176258"];
8381 [label="return '('; 176259"];
8382 [label="param GetTrailingTrivia(this) 176260"];
8383 [label="var trivia = this.GetTrailingTrivia(); 176261"];
8384 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176262"];
8385 [label="get { return this.TextField; } 176263"];
8386 [label="return this.TextField; 176264"];
8387 [label="param GetLeadingTrivia(this) 176265"];
8388 [label="return this.LeadingField; 176266"];
8389 [label="var trivia = this.GetLeadingTrivia(); 176267"];
8390 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176268"];
8391 [label="return ')'; 176269"];
8392 [label="=> true 176270"];
8393 [label="return this.LeadingField; 176271"];
8394 [label="var trivia = this.GetLeadingTrivia(); 176272"];
8395 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176273"];
8396 [label="return '{'; 176274"];
8397 [label="=> true 176275"];
8398 [label="return this.LeadingField; 176276"];
8399 [label="var trivia = this.GetLeadingTrivia(); 176277"];
8400 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176278"];
8401 [label="return 'case'; 176279"];
8402 [label="=> true 176280"];
8403 [label="return this.LeadingField; 176281"];
8404 [label="var trivia = this.GetLeadingTrivia(); 176282"];
8405 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176283"];
8406 [label="return ':'; 176284"];
8407 [label="=> true 176285"];
8408 [label="return this.LeadingField; 176286"];
8409 [label="var trivia = this.GetLeadingTrivia(); 176287"];
8410 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176288"];
8411 [label="return ';'; 176289"];
8412 [label="=> true 176290"];
8413 [label="return this.LeadingField; 176291"];
8414 [label="var trivia = this.GetLeadingTrivia(); 176292"];
8415 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176293"];
8416 [label="return '}'; 176294"];
8417 [label="CustomAssert.Equal(0, statement.Errors().Length); 176295"];
8418 [label="CustomAssert.Equal(0, statement.Errors().Length); 176296"];
8419 [label="statement.Errors() 176297"];
8420 [label="param Errors(this SyntaxNode node) 176298"];
8421 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 176299"];
8422 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 176300"];
8423 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 176301"];
8424 [label="param ErrorsOrWarnings(this GreenNode node) 176302"];
8425 [label="param ErrorsOrWarnings(bool errorsOnly) 176303"];
8426 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 176304"];
8427 [label="var l = new SyntaxDiagnosticInfoList(node); 176305"];
8428 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 176306"];
8429 [label="return b.ToImmutableAndFree(); 176307"];
8430 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 176308"];
8431 [label="CustomAssert.Equal(0, statement.Errors().Length); 176309"];
8432 [label="var ss = (SwitchStatementSyntax)statement; 176310"];
8433 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 176311"];
8434 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 176312"];
8435 [label="ss.SwitchKeyword 176313"];
8436 [label="=> true 176314"];
8437 [label="true 176315"];
8438 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 176316"];
8439 [label="CustomAssert.NotEqual(default, ss.SwitchKeyword); 176317"];
8440 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 176318"];
8441 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 176319"];
8442 [label="ss.SwitchKeyword 176320"];
8443 [label="=> true 176321"];
8444 [label="true 176322"];
8445 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 176323"];
8446 [label="CustomAssert.Equal(SyntaxKind.SwitchKeyword, ss.SwitchKeyword.Kind()); 176324"];
8447 [label="param Kind(this SyntaxToken token) 176325"];
8448 [label="var rawKind = token.RawKind; 176326"];
8449 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 176327"];
8450 [label="IsCSharpKind(rawKind) 176328"];
8451 [label="param IsCSharpKind(int rawKind) 176329"];
8452 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 176330"];
8453 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 176331"];
8454 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176332"];
8455 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176333"];
8456 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176334"];
8457 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176335"];
8458 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176336"];
8459 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 176337"];
8460 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 176338"];
8461 [label="ss.OpenParenToken 176339"];
8462 [label="=> true 176340"];
8463 [label="true 176341"];
8464 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 176342"];
8465 [label="CustomAssert.NotEqual(default, ss.OpenParenToken); 176343"];
8466 [label="CustomAssert.NotNull(ss.Expression); 176344"];
8467 [label="ss.Expression 176345"];
8468 [label="param CSharpSyntaxNode(GreenNode green) 176346"];
8469 [label="param CSharpSyntaxNode(SyntaxNode? parent) 176347"];
8470 [label="param CSharpSyntaxNode(int position) 176348"];
8471 [label="param CSharpSyntaxNode(this) 176349"];
8472 [label="param CSharpSyntaxNode(this) 176350"];
8473 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 176351"];
8474 [label="ss.Expression.ToString() 176352"];
8475 [label="param ToString(this) 176353"];
8476 [label="this.Identifier.Text 176354"];
8477 [label="get { return this.TextField; } 176355"];
8478 [label="return this.Identifier.Text; 176356"];
8479 [label="CustomAssert.Equal('a', ss.Expression.ToString()); 176357"];
8480 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 176358"];
8481 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 176359"];
8482 [label="ss.CloseParenToken 176360"];
8483 [label="=> true 176361"];
8484 [label="true 176362"];
8485 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 176363"];
8486 [label="CustomAssert.NotEqual(default, ss.CloseParenToken); 176364"];
8487 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 176365"];
8488 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 176366"];
8489 [label="ss.OpenBraceToken 176367"];
8490 [label="=> true 176368"];
8491 [label="true 176369"];
8492 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 176370"];
8493 [label="CustomAssert.NotEqual(default, ss.OpenBraceToken); 176371"];
8494 [label="CustomAssert.Equal(1, ss.Sections.Count); 176372"];
8495 [label="CustomAssert.Equal(1, ss.Sections.Count); 176373"];
8496 [label="ss.Sections 176374"];
8497 [label="param CSharpSyntaxNode(GreenNode green) 176375"];
8498 [label="param CSharpSyntaxNode(SyntaxNode? parent) 176376"];
8499 [label="param CSharpSyntaxNode(int position) 176377"];
8500 [label="param CSharpSyntaxNode(this) 176378"];
8501 [label="param CSharpSyntaxNode(this) 176379"];
8502 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 176380"];
8503 [label="CustomAssert.Equal(1, ss.Sections[0].Labels.Count); 176381"];
8504 [label="ss.Sections[0].Labels 176382"];
8505 [label="param CSharpSyntaxNode(GreenNode green) 176383"];
8506 [label="param CSharpSyntaxNode(SyntaxNode? parent) 176384"];
8507 [label="param CSharpSyntaxNode(int position) 176385"];
8508 [label="param CSharpSyntaxNode(this) 176386"];
8509 [label="param CSharpSyntaxNode(this) 176387"];
8510 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 176388"];
8511 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 176389"];
8512 [label="ss.Sections[0].Labels[0].Keyword 176390"];
8513 [label="=> true 176391"];
8514 [label="true 176392"];
8515 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 176393"];
8516 [label="CustomAssert.NotEqual(default, ss.Sections[0].Labels[0].Keyword); 176394"];
8517 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 176395"];
8518 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 176396"];
8519 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 176397"];
8520 [label="ss.Sections[0].Labels[0].Keyword 176398"];
8521 [label="=> true 176399"];
8522 [label="true 176400"];
8523 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 176401"];
8524 [label="CustomAssert.Equal(SyntaxKind.CaseKeyword, ss.Sections[0].Labels[0].Keyword.Kind()); 176402"];
8525 [label="param Kind(this SyntaxToken token) 176403"];
8526 [label="IsCSharpKind(rawKind) 176404"];
8527 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 176405"];
8528 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 176406"];
8529 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176407"];
8530 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176408"];
8531 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 176409"];
8532 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 176410"];
8533 [label="var caseLabelSyntax = ss.Sections[0].Labels[0] as CaseSwitchLabelSyntax; 176411"];
8534 [label="CustomAssert.NotNull(caseLabelSyntax); 176412"];
8535 [label="CustomAssert.NotNull(caseLabelSyntax.Value); 176413"];
8536 [label="caseLabelSyntax.Value 176414"];
8537 [label="param CSharpSyntaxNode(GreenNode green) 176415"];
8538 [label="param CSharpSyntaxNode(SyntaxNode? parent) 176416"];
8539 [label="param CSharpSyntaxNode(int position) 176417"];
8540 [label="param CSharpSyntaxNode(this) 176418"];
8541 [label="param CSharpSyntaxNode(this) 176419"];
8542 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 176420"];
8543 [label="caseLabelSyntax.Value.ToString() 176421"];
8544 [label="param ToString(this) 176422"];
8545 [label="this.Identifier.Text 176423"];
8546 [label="get { return this.TextField; } 176424"];
8547 [label="return this.Identifier.Text; 176425"];
8548 [label="CustomAssert.Equal('b', caseLabelSyntax.Value.ToString()); 176426"];
8549 [label="CustomAssert.Equal(2, ss.Sections[0].Statements.Count); 176427"];
8550 [label="CustomAssert.Equal(2, ss.Sections[0].Statements.Count); 176428"];
8551 [label="CustomAssert.Equal('s1();', ss.Sections[0].Statements[0].ToString()); 176429"];
8552 [label="CustomAssert.Equal('s1();', ss.Sections[0].Statements[0].ToString()); 176430"];
8553 [label="param CSharpSyntaxNode(this) 176431"];
8554 [label="=> true 176432"];
8555 [label="true 176433"];
8556 [label="param WriteTokenTo(bool leading) 176434"];
8557 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 176435"];
8558 [label="this.Text 176436"];
8559 [label="param GetTrailingTrivia(this) 176437"];
8560 [label="this.GetLeadingTrivia() 176438"];
8561 [label="param GetLeadingTrivia(this) 176439"];
8562 [label="return null; 176440"];
8563 [label="var trivia = this.GetLeadingTrivia(); 176441"];
8564 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176442"];
8565 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176443"];
8566 [label="this.Kind 176444"];
8567 [label="SyntaxFacts.GetText(this.Kind) 176445"];
8568 [label="param GetLeadingTrivia(this) 176446"];
8569 [label="return this.LeadingField; 176447"];
8570 [label="var trivia = this.GetLeadingTrivia(); 176448"];
8571 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176449"];
8572 [label="CustomAssert.Equal('s2();', ss.Sections[0].Statements[1].ToString()); 176450"];
8573 [label="CustomAssert.Equal('s2();', ss.Sections[0].Statements[1].ToString()); 176451"];
8574 [label="param CSharpSyntaxNode(this) 176452"];
8575 [label="=> true 176453"];
8576 [label="true 176454"];
8577 [label="param WriteTokenTo(bool leading) 176455"];
8578 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 176456"];
8579 [label="this.Text 176457"];
8580 [label="param GetTrailingTrivia(this) 176458"];
8581 [label="this.GetLeadingTrivia() 176459"];
8582 [label="param GetLeadingTrivia(this) 176460"];
8583 [label="return null; 176461"];
8584 [label="var trivia = this.GetLeadingTrivia(); 176462"];
8585 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176463"];
8586 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176464"];
8587 [label="this.Kind 176465"];
8588 [label="SyntaxFacts.GetText(this.Kind) 176466"];
8589 [label="param GetLeadingTrivia(this) 176467"];
8590 [label="return this.LeadingField; 176468"];
8591 [label="var trivia = this.GetLeadingTrivia(); 176469"];
8592 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 176470"];
8593 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 176471"];
8594 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 176472"];
8595 [label="ss.CloseBraceToken 176473"];
8596 [label="=> true 176474"];
8597 [label="true 176475"];
8598 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 176476"];
8599 [label="CustomAssert.NotEqual(default, ss.CloseBraceToken); 176477"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
914 -> 912;
915 -> 912;
916 -> 912;
917 -> 912;
918 -> 913;
918 -> 912;
919 -> 914;
919 -> 912;
920 -> 915;
920 -> 912;
921 -> 916;
921 -> 912;
922 -> 921;
922 -> 912;
923 -> 0;
923 -> 912;
924 -> 918;
924 -> 917;
925 -> 919;
925 -> 917;
926 -> 920;
926 -> 917;
927 -> 922;
927 -> 917;
928 -> 923;
928 -> 917;
929 -> 917;
930 -> 926;
930 -> 917;
931 -> 925;
931 -> 917;
932 -> 929;
932 -> 930;
932 -> 931;
932 -> 917;
933 -> 929;
933 -> 917;
934 -> 929;
934 -> 917;
935 -> 929;
935 -> 917;
936 -> 924;
936 -> 929;
936 -> 917;
937 -> 924;
937 -> 917;
938 -> 917;
939 -> 937;
939 -> 938;
940 -> 939;
940 -> 938;
941 -> 0;
941 -> 940;
942 -> 941;
942 -> 929;
942 -> 917;
943 -> 927;
943 -> 917;
944 -> 943;
944 -> 929;
944 -> 917;
945 -> 928;
945 -> 917;
946 -> 0;
946 -> 917;
947 -> 945;
947 -> 929;
947 -> 917;
948 -> 912;
950 -> 949;
953 -> 952;
955 -> 954;
966 -> 957;
966 -> 956;
967 -> 958;
967 -> 956;
968 -> 959;
968 -> 956;
969 -> 960;
969 -> 956;
970 -> 961;
970 -> 956;
971 -> 962;
971 -> 956;
972 -> 963;
972 -> 956;
973 -> 964;
973 -> 956;
974 -> 965;
974 -> 956;
975 -> 956;
977 -> 976;
978 -> 948;
978 -> 898;
979 -> 978;
979 -> 901;
979 -> 898;
980 -> 898;
981 -> 898;
982 -> 911;
982 -> 981;
983 -> 979;
983 -> 981;
984 -> 980;
984 -> 981;
985 -> 980;
985 -> 981;
986 -> 980;
986 -> 981;
987 -> 982;
987 -> 981;
988 -> 981;
989 -> 987;
989 -> 988;
990 -> 986;
990 -> 988;
991 -> 990;
991 -> 988;
992 -> 990;
992 -> 988;
993 -> 0;
995 -> 994;
997 -> 996;
998 -> 997;
999 -> 989;
999 -> 988;
1000 -> 988;
1001 -> 988;
1002 -> 999;
1002 -> 1001;
1003 -> 1000;
1003 -> 1001;
1004 -> 1003;
1004 -> 1001;
1005 -> 1003;
1005 -> 1001;
1006 -> 1003;
1006 -> 1001;
1007 -> 1003;
1007 -> 1001;
1008 -> 1003;
1008 -> 1001;
1009 -> 1003;
1009 -> 1001;
1010 -> 1003;
1010 -> 1001;
1011 -> 1003;
1011 -> 1001;
1012 -> 1002;
1012 -> 1003;
1012 -> 1001;
1013 -> 1001;
1014 -> 1013;
1014 -> 1003;
1014 -> 1001;
1015 -> 1001;
1016 -> 1015;
1016 -> 1003;
1016 -> 1001;
1017 -> 1002;
1017 -> 911;
1017 -> 1003;
1017 -> 1001;
1018 -> 1001;
1019 -> 1018;
1019 -> 1003;
1019 -> 1001;
1020 -> 998;
1020 -> 997;
1020 -> 1001;
1021 -> 1020;
1021 -> 1003;
1021 -> 1001;
1022 -> 1001;
1023 -> 1022;
1023 -> 1003;
1023 -> 1001;
1024 -> 1000;
1024 -> 990;
1024 -> 988;
1025 -> 986;
1025 -> 981;
1026 -> 986;
1026 -> 981;
1027 -> 986;
1027 -> 981;
1028 -> 986;
1028 -> 981;
1029 -> 986;
1029 -> 981;
1030 -> 986;
1030 -> 981;
1031 -> 986;
1031 -> 981;
1032 -> 986;
1032 -> 981;
1033 -> 986;
1033 -> 981;
1034 -> 986;
1034 -> 981;
1035 -> 981;
1036 -> 1035;
1036 -> 981;
1037 -> 1036;
1037 -> 986;
1037 -> 981;
1038 -> 981;
1039 -> 1038;
1039 -> 981;
1040 -> 1039;
1040 -> 986;
1040 -> 981;
1041 -> 986;
1041 -> 981;
1042 -> 986;
1042 -> 981;
1043 -> 981;
1044 -> 983;
1044 -> 1043;
1044 -> 981;
1045 -> 983;
1045 -> 986;
1045 -> 981;
1046 -> 981;
1047 -> 1046;
1047 -> 986;
1047 -> 981;
1048 -> 981;
1049 -> 1048;
1049 -> 986;
1049 -> 981;
1052 -> 1050;
1052 -> 1051;
1053 -> 1052;
1055 -> 1054;
1056 -> 981;
1057 -> 981;
1058 -> 1056;
1058 -> 1057;
1059 -> 1058;
1059 -> 1057;
1060 -> 1058;
1060 -> 1057;
1061 -> 1058;
1061 -> 1057;
1062 -> 1057;
1063 -> 1062;
1063 -> 1058;
1063 -> 1057;
1064 -> 1057;
1065 -> 1064;
1065 -> 1058;
1065 -> 1057;
1066 -> 1053;
1066 -> 1052;
1066 -> 1057;
1067 -> 1066;
1067 -> 1058;
1067 -> 1057;
1068 -> 1056;
1068 -> 986;
1068 -> 981;
1069 -> 986;
1069 -> 981;
1070 -> 984;
1070 -> 986;
1070 -> 981;
1071 -> 985;
1071 -> 986;
1071 -> 981;
1072 -> 980;
1072 -> 890;
1073 -> 1072;
1073 -> 890;
1074 -> 890;
1075 -> 1073;
1075 -> 1074;
1076 -> 0;
1077 -> 1075;
1077 -> 1074;
1078 -> 1074;
1079 -> 1074;
1080 -> 1077;
1080 -> 1079;
1081 -> 1078;
1081 -> 1079;
1082 -> 1078;
1082 -> 1079;
1083 -> 1078;
1083 -> 1079;
1084 -> 1078;
1084 -> 1079;
1085 -> 1078;
1085 -> 1079;
1088 -> 1086;
1088 -> 1087;
1089 -> 1088;
1090 -> 1080;
1090 -> 1079;
1091 -> 1083;
1091 -> 1079;
1092 -> 1081;
1092 -> 1079;
1093 -> 1082;
1093 -> 1079;
1094 -> 1079;
1095 -> 1079;
1096 -> 1084;
1096 -> 1079;
1097 -> 1079;
1098 -> 1090;
1098 -> 1097;
1099 -> 1091;
1099 -> 1097;
1100 -> 1092;
1100 -> 1097;
1101 -> 1093;
1101 -> 1097;
1102 -> 1094;
1102 -> 1097;
1103 -> 1095;
1103 -> 1097;
1104 -> 1096;
1104 -> 1097;
1105 -> 1085;
1105 -> 1097;
1106 -> 1105;
1106 -> 1097;
1107 -> 1105;
1107 -> 1097;
1108 -> 1105;
1108 -> 1097;
1109 -> 1105;
1109 -> 1097;
1110 -> 1105;
1110 -> 1097;
1111 -> 1105;
1111 -> 1097;
1112 -> 1105;
1112 -> 1097;
1113 -> 1105;
1113 -> 1097;
1114 -> 1105;
1114 -> 1097;
1115 -> 1105;
1115 -> 1097;
1116 -> 1105;
1116 -> 1097;
1117 -> 1105;
1117 -> 1097;
1118 -> 1105;
1118 -> 1097;
1119 -> 1098;
1119 -> 1105;
1119 -> 1097;
1120 -> 1099;
1120 -> 1105;
1120 -> 1097;
1121 -> 1102;
1121 -> 1105;
1121 -> 1097;
1122 -> 1104;
1122 -> 1105;
1122 -> 1097;
1123 -> 1097;
1124 -> 1123;
1124 -> 1105;
1124 -> 1097;
1125 -> 1097;
1126 -> 1100;
1126 -> 1125;
1126 -> 1097;
1127 -> 1126;
1127 -> 1105;
1127 -> 1097;
1128 -> 1097;
1129 -> 1105;
1129 -> 1128;
1130 -> 1129;
1130 -> 1127;
1130 -> 1128;
1131 -> 1130;
1131 -> 1097;
1132 -> 1131;
1132 -> 1102;
1132 -> 1097;
1133 -> 1132;
1134 -> 1133;
1134 -> 1105;
1134 -> 1132;
1135 -> 1132;
1136 -> 1135;
1136 -> 1105;
1136 -> 1132;
1137 -> 1097;
1138 -> 1105;
1138 -> 1137;
1139 -> 1138;
1139 -> 1127;
1139 -> 1137;
1140 -> 1139;
1140 -> 1097;
1141 -> 1103;
1141 -> 1140;
1141 -> 1097;
1142 -> 1141;
1142 -> 1104;
1142 -> 1078;
1142 -> 1097;
1143 -> 1142;
1144 -> 1105;
1144 -> 1143;
1145 -> 1143;
1146 -> 1143;
1147 -> 1144;
1147 -> 1119;
1147 -> 1024;
1147 -> 1146;
1148 -> 1147;
1148 -> 1012;
1148 -> 1146;
1149 -> 1148;
1149 -> 1143;
1150 -> 1149;
1150 -> 1143;
1151 -> 1150;
1151 -> 1144;
1151 -> 1143;
1152 -> 1144;
1152 -> 1119;
1152 -> 1143;
1153 -> 1144;
1153 -> 1120;
1153 -> 1143;
1154 -> 1143;
1155 -> 1154;
1155 -> 1149;
1155 -> 1143;
1156 -> 1153;
1156 -> 1155;
1157 -> 1155;
1158 -> 1156;
1158 -> 1157;
1159 -> 1152;
1159 -> 1157;
1160 -> 951;
1160 -> 1157;
1161 -> 1158;
1161 -> 1159;
1161 -> 1157;
1162 -> 1159;
1162 -> 1161;
1162 -> 1157;
1163 -> 1159;
1163 -> 1024;
1163 -> 992;
1163 -> 1045;
1163 -> 1161;
1163 -> 1047;
1163 -> 1049;
1163 -> 1029;
1163 -> 1068;
1163 -> 1070;
1163 -> 1071;
1163 -> 1033;
1163 -> 1034;
1163 -> 1037;
1163 -> 1040;
1163 -> 1041;
1163 -> 1069;
1163 -> 1012;
1163 -> 1014;
1163 -> 1016;
1163 -> 1017;
1163 -> 1021;
1163 -> 1009;
1163 -> 1023;
1163 -> 1019;
1163 -> 911;
1163 -> 1036;
1163 -> 1039;
1163 -> 932;
1163 -> 933;
1163 -> 947;
1163 -> 934;
1163 -> 942;
1163 -> 935;
1163 -> 936;
1163 -> 944;
1163 -> 945;
1163 -> 943;
1163 -> 1046;
1163 -> 1048;
1163 -> 1063;
1163 -> 1065;
1163 -> 1067;
1163 -> 1066;
1163 -> 1064;
1163 -> 1062;
1163 -> 1018;
1163 -> 1020;
1163 -> 1162;
1164 -> 1162;
1165 -> 1163;
1165 -> 1164;
1166 -> 1164;
1167 -> 1165;
1167 -> 1163;
1167 -> 1166;
1168 -> 1167;
1168 -> 1163;
1168 -> 1166;
1169 -> 1164;
1170 -> 1164;
1171 -> 1170;
1171 -> 1165;
1171 -> 1164;
1172 -> 1163;
1172 -> 1164;
1173 -> 1172;
1173 -> 1163;
1173 -> 1164;
1174 -> 1163;
1174 -> 1173;
1174 -> 1168;
1174 -> 1171;
1174 -> 1162;
1175 -> 1163;
1175 -> 1164;
1176 -> 1175;
1176 -> 1174;
1176 -> 1164;
1177 -> 1163;
1177 -> 1164;
1178 -> 1177;
1178 -> 1176;
1178 -> 1164;
1179 -> 1163;
1179 -> 1164;
1180 -> 1163;
1180 -> 1164;
1181 -> 1180;
1181 -> 1178;
1181 -> 1179;
1181 -> 1164;
1182 -> 1181;
1182 -> 1180;
1182 -> 1164;
1183 -> 1163;
1183 -> 1164;
1184 -> 1183;
1184 -> 1178;
1184 -> 1164;
1185 -> 1163;
1185 -> 1184;
1185 -> 1178;
1185 -> 1182;
1185 -> 1162;
1186 -> 1163;
1186 -> 1164;
1187 -> 1163;
1187 -> 1164;
1188 -> 1186;
1188 -> 1187;
1188 -> 1185;
1188 -> 1164;
1189 -> 1164;
1190 -> 1188;
1190 -> 1189;
1190 -> 1164;
1191 -> 1188;
1191 -> 1187;
1191 -> 1185;
1191 -> 1164;
1192 -> 1188;
1192 -> 1187;
1192 -> 1190;
1193 -> 1162;
1194 -> 1159;
1194 -> 1193;
1195 -> 1194;
1195 -> 1192;
1195 -> 1193;
1196 -> 1193;
1197 -> 1194;
1197 -> 1195;
1197 -> 1196;
1198 -> 1197;
1198 -> 1195;
1198 -> 1196;
1199 -> 1198;
1199 -> 1193;
1200 -> 1193;
1201 -> 1194;
1201 -> 1195;
1201 -> 1193;
1202 -> 1193;
1203 -> 1199;
1203 -> 1202;
1204 -> 1200;
1204 -> 1202;
1205 -> 1201;
1205 -> 1202;
1206 -> 1194;
1206 -> 1202;
1207 -> 1204;
1207 -> 1202;
1208 -> 1202;
1209 -> 1208;
1210 -> 1206;
1210 -> 1209;
1211 -> 1209;
1212 -> 1210;
1212 -> 1195;
1212 -> 1211;
1213 -> 1209;
1214 -> 1209;
1215 -> 1214;
1215 -> 1210;
1215 -> 1209;
1216 -> 1208;
1217 -> 1208;
1218 -> 1206;
1218 -> 1195;
1218 -> 1217;
1219 -> 1218;
1219 -> 1195;
1219 -> 1217;
1220 -> 1217;
1221 -> 1218;
1221 -> 1220;
1222 -> 1221;
1222 -> 1195;
1222 -> 1220;
1223 -> 1222;
1224 -> 1221;
1224 -> 1223;
1225 -> 1224;
1225 -> 1195;
1225 -> 1223;
1226 -> 1225;
1226 -> 1222;
1227 -> 1222;
1228 -> 1221;
1228 -> 1195;
1228 -> 1212;
1228 -> 1227;
1228 -> 1222;
1229 -> 1221;
1229 -> 1195;
1229 -> 1212;
1229 -> 1215;
1229 -> 1222;
1230 -> 1221;
1230 -> 1195;
1230 -> 1222;
1231 -> 1221;
1231 -> 1195;
1231 -> 1212;
1231 -> 1215;
1231 -> 1222;
1232 -> 1221;
1232 -> 1195;
1232 -> 1222;
1233 -> 1231;
1233 -> 1222;
1234 -> 1221;
1234 -> 1233;
1234 -> 1231;
1234 -> 1222;
1235 -> 1234;
1235 -> 1221;
1235 -> 1222;
1236 -> 1222;
1237 -> 1231;
1237 -> 1236;
1237 -> 1222;
1238 -> 1237;
1238 -> 1217;
1239 -> 1218;
1239 -> 1233;
1239 -> 1235;
1239 -> 1217;
1240 -> 1239;
1240 -> 1208;
1241 -> 1208;
1242 -> 1240;
1242 -> 1241;
1242 -> 1208;
1243 -> 1242;
1244 -> 1240;
1244 -> 1208;
1245 -> 1244;
1246 -> 1194;
1246 -> 1233;
1246 -> 1205;
1246 -> 1193;
1247 -> 1193;
1248 -> 1193;
1249 -> 1194;
1249 -> 1248;
1250 -> 1248;
1251 -> 1249;
1251 -> 1233;
1251 -> 1250;
1252 -> 1248;
1253 -> 1248;
1254 -> 1253;
1254 -> 1249;
1254 -> 1248;
1255 -> 1193;
1256 -> 1247;
1256 -> 1193;
1257 -> 1256;
1257 -> 1194;
1257 -> 1233;
1257 -> 1235;
1257 -> 1205;
1257 -> 1251;
1257 -> 1254;
1257 -> 1247;
1257 -> 1193;
1258 -> 1193;
1259 -> 1257;
1259 -> 1258;
1260 -> 1259;
1260 -> 1257;
1260 -> 1258;
1261 -> 1257;
1261 -> 1260;
1261 -> 1258;
1262 -> 1257;
1262 -> 1260;
1262 -> 1258;
1263 -> 1257;
1263 -> 1258;
1264 -> 1257;
1264 -> 1258;
1265 -> 0;
1265 -> 1263;
1265 -> 1258;
1266 -> 1263;
1266 -> 1258;
1267 -> 1258;
1268 -> 1266;
1268 -> 1267;
1269 -> 1264;
1269 -> 1267;
1270 -> 1268;
1270 -> 1267;
1271 -> 1270;
1271 -> 1269;
1271 -> 1262;
1271 -> 1265;
1271 -> 1267;
1272 -> 1267;
1273 -> 1271;
1273 -> 1272;
1274 -> 1271;
1274 -> 1272;
1275 -> 1271;
1275 -> 1272;
1276 -> 1271;
1276 -> 1272;
1277 -> 1273;
1277 -> 1272;
1278 -> 1274;
1278 -> 1272;
1279 -> 1275;
1279 -> 1272;
1280 -> 1276;
1280 -> 1271;
1280 -> 1277;
1280 -> 1278;
1280 -> 1279;
1280 -> 1272;
1281 -> 1280;
1282 -> 0;
1282 -> 1281;
1283 -> 1281;
1284 -> 1282;
1284 -> 1283;
1285 -> 1264;
1285 -> 1283;
1286 -> 1285;
1286 -> 1280;
1286 -> 1283;
1287 -> 1283;
1288 -> 1286;
1288 -> 1287;
1289 -> 1288;
1289 -> 0;
1289 -> 1287;
1290 -> 1289;
1290 -> 1284;
1290 -> 1283;
1291 -> 1280;
1291 -> 1290;
1292 -> 1290;
1293 -> 1291;
1293 -> 1292;
1294 -> 1291;
1294 -> 1292;
1295 -> 1264;
1295 -> 1280;
1295 -> 1292;
1296 -> 1293;
1296 -> 1055;
1296 -> 1292;
1298 -> 1297;
1299 -> 1297;
1300 -> 1293;
1300 -> 1292;
1301 -> 1300;
1301 -> 1295;
1301 -> 1280;
1301 -> 1292;
1302 -> 1292;
1303 -> 1301;
1303 -> 1302;
1304 -> 1303;
1304 -> 1302;
1305 -> 0;
1305 -> 1304;
1306 -> 1305;
1306 -> 0;
1306 -> 1292;
1307 -> 1280;
1307 -> 1305;
1307 -> 1306;
1308 -> 1306;
1309 -> 1307;
1309 -> 1308;
1310 -> 1309;
1310 -> 1308;
1311 -> 1310;
1312 -> 1280;
1312 -> 1305;
1312 -> 0;
1312 -> 1281;
1313 -> 1280;
1314 -> 1280;
1314 -> 1313;
1314 -> 1305;
1314 -> 1193;
1315 -> 1246;
1315 -> 1193;
1316 -> 1193;
1317 -> 1315;
1317 -> 1316;
1318 -> 1316;
1319 -> 1316;
1320 -> 1317;
1320 -> 1319;
1320 -> 1316;
1321 -> 1320;
1322 -> 1321;
1322 -> 1317;
1322 -> 1314;
1322 -> 1320;
1323 -> 1318;
1323 -> 1316;
1324 -> 1323;
1324 -> 1193;
1325 -> 1193;
1326 -> 1324;
1326 -> 1325;
1327 -> 1194;
1327 -> 1325;
1328 -> 1325;
1329 -> 1327;
1329 -> 1314;
1329 -> 1328;
1329 -> 1325;
1330 -> 1329;
1331 -> 1330;
1331 -> 1193;
1332 -> 1194;
1332 -> 1314;
1332 -> 1193;
1333 -> 1193;
1334 -> 1194;
1334 -> 1332;
1334 -> 1193;
1335 -> 1193;
1336 -> 1333;
1336 -> 1335;
1337 -> 1333;
1337 -> 1335;
1338 -> 1334;
1338 -> 1335;
1339 -> 1194;
1339 -> 1335;
1340 -> 1337;
1340 -> 1335;
1341 -> 1335;
1342 -> 1341;
1343 -> 1339;
1343 -> 1342;
1344 -> 1342;
1345 -> 1343;
1345 -> 1332;
1345 -> 1344;
1346 -> 1342;
1347 -> 1342;
1348 -> 1347;
1348 -> 1343;
1348 -> 1342;
1349 -> 1341;
1350 -> 1341;
1351 -> 1339;
1351 -> 1332;
1351 -> 1350;
1352 -> 1351;
1352 -> 1332;
1352 -> 1350;
1353 -> 1351;
1353 -> 1341;
1354 -> 1341;
1355 -> 1353;
1355 -> 1354;
1355 -> 1341;
1356 -> 1339;
1356 -> 1332;
1356 -> 1345;
1356 -> 1348;
1356 -> 1355;
1357 -> 1355;
1358 -> 1356;
1358 -> 1357;
1359 -> 1356;
1359 -> 1357;
1360 -> 1359;
1360 -> 1356;
1360 -> 1357;
1361 -> 1356;
1361 -> 1360;
1361 -> 1357;
1362 -> 1356;
1362 -> 1357;
1363 -> 1362;
1363 -> 1360;
1363 -> 1357;
1364 -> 1338;
1364 -> 1355;
1365 -> 1355;
1366 -> 1363;
1366 -> 1365;
1367 -> 1364;
1367 -> 1365;
1368 -> 1339;
1368 -> 1365;
1369 -> 1365;
1370 -> 1368;
1370 -> 1369;
1371 -> 1369;
1372 -> 1370;
1372 -> 1363;
1372 -> 1371;
1372 -> 1369;
1373 -> 1372;
1373 -> 1365;
1374 -> 1365;
1375 -> 1367;
1375 -> 1374;
1375 -> 1365;
1376 -> 1366;
1376 -> 1365;
1377 -> 1367;
1377 -> 1376;
1377 -> 1363;
1377 -> 1365;
1378 -> 1377;
1378 -> 1350;
1379 -> 1377;
1380 -> 1377;
1380 -> 1341;
1381 -> 1380;
1382 -> 1194;
1382 -> 1377;
1382 -> 1367;
1382 -> 1193;
1383 -> 1314;
1383 -> 1193;
1384 -> 1246;
1384 -> 1193;
1385 -> 1382;
1385 -> 1193;
1386 -> 1331;
1386 -> 1193;
1387 -> 1193;
1388 -> 1383;
1388 -> 1387;
1389 -> 1384;
1389 -> 1387;
1390 -> 1385;
1390 -> 1387;
1391 -> 1386;
1391 -> 1387;
1392 -> 1194;
1392 -> 1387;
1393 -> 1388;
1393 -> 1314;
1393 -> 0;
1393 -> 1387;
1394 -> 1389;
1394 -> 1377;
1394 -> 1348;
1394 -> 1367;
1394 -> 1387;
1395 -> 1390;
1395 -> 1394;
1395 -> 1387;
1396 -> 1387;
1397 -> 1388;
1397 -> 1314;
1397 -> 1387;
1398 -> 1388;
1398 -> 1314;
1398 -> 1397;
1399 -> 1388;
1399 -> 1314;
1399 -> 1398;
1400 -> 1398;
1401 -> 1399;
1401 -> 1400;
1402 -> 1401;
1402 -> 0;
1402 -> 1400;
1403 -> 1394;
1403 -> 1398;
1404 -> 1388;
1404 -> 1314;
1404 -> 1398;
1405 -> 1395;
1405 -> 1398;
1406 -> 1398;
1407 -> 1403;
1407 -> 1406;
1408 -> 1404;
1408 -> 1406;
1409 -> 1405;
1409 -> 1406;
1410 -> 0;
1411 -> 0;
1413 -> 1411;
1413 -> 1412;
1414 -> 1413;
1415 -> 1414;
1417 -> 1411;
1417 -> 1416;
1418 -> 1417;
1419 -> 1418;
1421 -> 1411;
1421 -> 1420;
1422 -> 1421;
1423 -> 1422;
1425 -> 1411;
1425 -> 1424;
1426 -> 1425;
1427 -> 1426;
1429 -> 1410;
1430 -> 1429;
1430 -> 1411;
1431 -> 1415;
1431 -> 1414;
1431 -> 1429;
1431 -> 1430;
1432 -> 1429;
1432 -> 1430;
1433 -> 1430;
1434 -> 1430;
1435 -> 1432;
1435 -> 1434;
1436 -> 1433;
1436 -> 1434;
1437 -> 1435;
1437 -> 1434;
1438 -> 1434;
1439 -> 1437;
1439 -> 1438;
1440 -> 1436;
1440 -> 1438;
1441 -> 1439;
1441 -> 1438;
1442 -> 1438;
1443 -> 1442;
1443 -> 1441;
1443 -> 1438;
1444 -> 1442;
1444 -> 1438;
1445 -> 1444;
1445 -> 1443;
1445 -> 1438;
1446 -> 1434;
1447 -> 1436;
1447 -> 1446;
1448 -> 1446;
1449 -> 1447;
1449 -> 1448;
1450 -> 1449;
1450 -> 1445;
1450 -> 1448;
1451 -> 1450;
1451 -> 1446;
1452 -> 1446;
1453 -> 1451;
1453 -> 1452;
1454 -> 1453;
1454 -> 1452;
1455 -> 1454;
1456 -> 1455;
1456 -> 1434;
1457 -> 1456;
1457 -> 1436;
1457 -> 1434;
1458 -> 1436;
1458 -> 1445;
1458 -> 0;
1458 -> 1434;
1459 -> 1458;
1459 -> 1436;
1459 -> 1434;
1460 -> 1433;
1460 -> 1431;
1460 -> 1430;
1462 -> 1419;
1462 -> 1418;
1462 -> 1429;
1462 -> 1430;
1463 -> 1429;
1463 -> 1430;
1464 -> 829;
1464 -> 1430;
1465 -> 1430;
1466 -> 1430;
1467 -> 1463;
1467 -> 1466;
1468 -> 1464;
1468 -> 1466;
1469 -> 1464;
1469 -> 1466;
1470 -> 1465;
1470 -> 1466;
1471 -> 1467;
1471 -> 1466;
1472 -> 1466;
1473 -> 1471;
1473 -> 1472;
1474 -> 1470;
1474 -> 1472;
1475 -> 1473;
1475 -> 1472;
1476 -> 1472;
1477 -> 1475;
1477 -> 1476;
1478 -> 1474;
1478 -> 1476;
1479 -> 1477;
1479 -> 1476;
1480 -> 1476;
1481 -> 1480;
1481 -> 1479;
1481 -> 1476;
1482 -> 1480;
1482 -> 1476;
1483 -> 1482;
1483 -> 1481;
1483 -> 1476;
1484 -> 1472;
1485 -> 1474;
1485 -> 1484;
1486 -> 1484;
1487 -> 1485;
1487 -> 1486;
1488 -> 1487;
1488 -> 1483;
1488 -> 1486;
1489 -> 1488;
1489 -> 1484;
1490 -> 1484;
1491 -> 1489;
1491 -> 1490;
1492 -> 1491;
1492 -> 1490;
1493 -> 1492;
1494 -> 1493;
1494 -> 1472;
1495 -> 1494;
1495 -> 1474;
1495 -> 1472;
1496 -> 1474;
1496 -> 1483;
1496 -> 0;
1496 -> 1472;
1497 -> 1496;
1497 -> 1474;
1497 -> 1472;
1498 -> 1470;
1498 -> 1466;
1499 -> 1470;
1499 -> 1466;
1500 -> 1466;
1501 -> 1468;
1501 -> 1500;
1501 -> 1466;
1502 -> 1468;
1502 -> 1501;
1503 -> 1470;
1503 -> 1502;
1503 -> 1483;
1503 -> 1495;
1503 -> 1497;
1503 -> 1498;
1503 -> 1499;
1503 -> 885;
1503 -> 1501;
1504 -> 1468;
1504 -> 1470;
1504 -> 1501;
1505 -> 1466;
1506 -> 1469;
1506 -> 1505;
1506 -> 1466;
1507 -> 1469;
1507 -> 1506;
1508 -> 1470;
1508 -> 1507;
1508 -> 1503;
1508 -> 1504;
1508 -> 1506;
1509 -> 1469;
1509 -> 1470;
1509 -> 1506;
1510 -> 1465;
1510 -> 1462;
1510 -> 1430;
1511 -> 1423;
1511 -> 1422;
1511 -> 1429;
1511 -> 1430;
1512 -> 1429;
1512 -> 1430;
1513 -> 1430;
1514 -> 408;
1514 -> 1430;
1515 -> 1430;
1516 -> 1512;
1516 -> 1515;
1517 -> 1513;
1517 -> 1515;
1518 -> 1514;
1518 -> 1515;
1519 -> 1513;
1519 -> 1515;
1520 -> 1516;
1520 -> 1515;
1521 -> 1515;
1522 -> 1520;
1522 -> 1521;
1523 -> 1519;
1523 -> 1521;
1524 -> 1522;
1524 -> 1521;
1525 -> 1521;
1526 -> 1524;
1526 -> 1525;
1527 -> 1523;
1527 -> 1525;
1528 -> 1526;
1528 -> 1525;
1529 -> 1525;
1530 -> 1529;
1530 -> 1528;
1530 -> 1525;
1531 -> 1529;
1531 -> 1525;
1532 -> 1531;
1532 -> 1530;
1532 -> 1525;
1533 -> 1521;
1534 -> 1523;
1534 -> 1533;
1535 -> 1533;
1536 -> 1534;
1536 -> 1535;
1537 -> 1536;
1537 -> 1532;
1537 -> 1535;
1538 -> 1537;
1538 -> 1533;
1539 -> 1533;
1540 -> 1538;
1540 -> 1539;
1541 -> 1540;
1541 -> 1539;
1542 -> 1541;
1543 -> 1542;
1543 -> 1521;
1544 -> 1543;
1544 -> 1523;
1544 -> 1521;
1545 -> 1523;
1545 -> 1532;
1545 -> 0;
1545 -> 1521;
1546 -> 1545;
1546 -> 1523;
1546 -> 1521;
1547 -> 1519;
1547 -> 1515;
1548 -> 1519;
1548 -> 1515;
1549 -> 1515;
1550 -> 1517;
1550 -> 1549;
1550 -> 1515;
1551 -> 1515;
1552 -> 1518;
1552 -> 1551;
1552 -> 1515;
1553 -> 1518;
1553 -> 1552;
1554 -> 1519;
1554 -> 1553;
1554 -> 1532;
1554 -> 1544;
1554 -> 1546;
1554 -> 1547;
1554 -> 1548;
1554 -> 850;
1554 -> 1552;
1555 -> 1518;
1555 -> 1519;
1555 -> 1552;
1556 -> 1513;
1556 -> 1511;
1556 -> 1430;
1557 -> 1427;
1557 -> 1426;
1557 -> 1429;
1557 -> 1430;
1558 -> 1429;
1558 -> 1430;
1559 -> 1430;
1560 -> 267;
1560 -> 1430;
1561 -> 1430;
1562 -> 1558;
1562 -> 1561;
1563 -> 1559;
1563 -> 1561;
1564 -> 1560;
1564 -> 1561;
1565 -> 1559;
1565 -> 1561;
1566 -> 1562;
1566 -> 1561;
1567 -> 1561;
1568 -> 1566;
1568 -> 1567;
1569 -> 1565;
1569 -> 1567;
1570 -> 1568;
1570 -> 1567;
1571 -> 1567;
1572 -> 1570;
1572 -> 1571;
1573 -> 1569;
1573 -> 1571;
1574 -> 1572;
1574 -> 1571;
1575 -> 1571;
1576 -> 1575;
1576 -> 1574;
1576 -> 1571;
1577 -> 1575;
1577 -> 1571;
1578 -> 1577;
1578 -> 1576;
1578 -> 1571;
1579 -> 1567;
1580 -> 1569;
1580 -> 1579;
1581 -> 1579;
1582 -> 1580;
1582 -> 1581;
1583 -> 1582;
1583 -> 1578;
1583 -> 1581;
1584 -> 1583;
1584 -> 1579;
1585 -> 1579;
1586 -> 1584;
1586 -> 1585;
1587 -> 1586;
1587 -> 1585;
1588 -> 1587;
1589 -> 1588;
1589 -> 1567;
1590 -> 1589;
1590 -> 1569;
1590 -> 1567;
1591 -> 1569;
1591 -> 1578;
1591 -> 0;
1591 -> 1567;
1592 -> 1591;
1592 -> 1569;
1592 -> 1567;
1593 -> 1565;
1593 -> 1561;
1594 -> 1565;
1594 -> 1561;
1595 -> 1561;
1596 -> 1563;
1596 -> 1595;
1596 -> 1561;
1597 -> 1561;
1598 -> 1564;
1598 -> 1597;
1598 -> 1561;
1599 -> 1564;
1599 -> 1598;
1600 -> 1565;
1600 -> 1599;
1600 -> 1578;
1600 -> 1590;
1600 -> 1592;
1600 -> 1593;
1600 -> 1594;
1600 -> 835;
1600 -> 1598;
1601 -> 1564;
1601 -> 1565;
1601 -> 1598;
1602 -> 1559;
1602 -> 1557;
1602 -> 1430;
1603 -> 1415;
1603 -> 1414;
1603 -> 1430;
1604 -> 1433;
1604 -> 1434;
1605 -> 1604;
1605 -> 1434;
1606 -> 1605;
1606 -> 1438;
1607 -> 1606;
1607 -> 1438;
1608 -> 1442;
1608 -> 1607;
1608 -> 1438;
1609 -> 1444;
1609 -> 1608;
1609 -> 1438;
1610 -> 1449;
1610 -> 1609;
1610 -> 1448;
1611 -> 1610;
1611 -> 1446;
1612 -> 1611;
1612 -> 1452;
1613 -> 1612;
1613 -> 1452;
1614 -> 1613;
1615 -> 1614;
1615 -> 1434;
1616 -> 1615;
1616 -> 1436;
1616 -> 1434;
1617 -> 1436;
1617 -> 1609;
1617 -> 0;
1617 -> 1434;
1618 -> 1617;
1618 -> 1436;
1618 -> 1434;
1619 -> 1433;
1619 -> 1603;
1619 -> 1430;
1620 -> 1419;
1620 -> 1418;
1620 -> 1430;
1621 -> 1465;
1621 -> 1466;
1622 -> 1621;
1622 -> 1466;
1623 -> 1622;
1623 -> 1472;
1624 -> 1623;
1624 -> 1472;
1625 -> 1624;
1625 -> 1476;
1626 -> 1625;
1626 -> 1476;
1627 -> 1480;
1627 -> 1626;
1627 -> 1476;
1628 -> 1482;
1628 -> 1627;
1628 -> 1476;
1629 -> 1487;
1629 -> 1628;
1629 -> 1486;
1630 -> 1629;
1630 -> 1484;
1631 -> 1630;
1631 -> 1490;
1632 -> 1631;
1632 -> 1490;
1633 -> 1632;
1634 -> 1633;
1634 -> 1472;
1635 -> 1634;
1635 -> 1474;
1635 -> 1472;
1636 -> 1474;
1636 -> 1628;
1636 -> 0;
1636 -> 1472;
1637 -> 1636;
1637 -> 1474;
1637 -> 1472;
1638 -> 1470;
1638 -> 1502;
1638 -> 1628;
1638 -> 1635;
1638 -> 1637;
1638 -> 1498;
1638 -> 1499;
1638 -> 1508;
1638 -> 1509;
1638 -> 1501;
1639 -> 1465;
1639 -> 1620;
1639 -> 1430;
1640 -> 1423;
1640 -> 1422;
1640 -> 1430;
1641 -> 1513;
1641 -> 1515;
1642 -> 1641;
1642 -> 1515;
1643 -> 1642;
1643 -> 1521;
1644 -> 1643;
1644 -> 1521;
1645 -> 1644;
1645 -> 1525;
1646 -> 1645;
1646 -> 1525;
1647 -> 1529;
1647 -> 1646;
1647 -> 1525;
1648 -> 1531;
1648 -> 1647;
1648 -> 1525;
1649 -> 1536;
1649 -> 1648;
1649 -> 1535;
1650 -> 1649;
1650 -> 1533;
1651 -> 1650;
1651 -> 1539;
1652 -> 1651;
1652 -> 1539;
1653 -> 1652;
1654 -> 1653;
1654 -> 1521;
1655 -> 1654;
1655 -> 1523;
1655 -> 1521;
1656 -> 1523;
1656 -> 1648;
1656 -> 0;
1656 -> 1521;
1657 -> 1656;
1657 -> 1523;
1657 -> 1521;
1658 -> 1519;
1658 -> 1553;
1658 -> 1648;
1658 -> 1655;
1658 -> 1657;
1658 -> 1547;
1658 -> 1548;
1658 -> 1554;
1658 -> 1555;
1658 -> 1552;
1659 -> 1513;
1659 -> 1640;
1659 -> 1430;
1660 -> 1427;
1660 -> 1426;
1660 -> 1430;
1661 -> 1559;
1661 -> 1561;
1662 -> 1661;
1662 -> 1561;
1663 -> 1662;
1663 -> 1567;
1664 -> 1663;
1664 -> 1567;
1665 -> 1664;
1665 -> 1571;
1666 -> 1665;
1666 -> 1571;
1667 -> 1575;
1667 -> 1666;
1667 -> 1571;
1668 -> 1577;
1668 -> 1667;
1668 -> 1571;
1669 -> 1582;
1669 -> 1668;
1669 -> 1581;
1670 -> 1669;
1670 -> 1579;
1671 -> 1670;
1671 -> 1585;
1672 -> 1671;
1672 -> 1585;
1673 -> 1672;
1674 -> 1673;
1674 -> 1567;
1675 -> 1674;
1675 -> 1569;
1675 -> 1567;
1676 -> 1569;
1676 -> 1668;
1676 -> 0;
1676 -> 1567;
1677 -> 1676;
1677 -> 1569;
1677 -> 1567;
1678 -> 1565;
1678 -> 1599;
1678 -> 1668;
1678 -> 1675;
1678 -> 1677;
1678 -> 1593;
1678 -> 1594;
1678 -> 1600;
1678 -> 1601;
1678 -> 1598;
1679 -> 1559;
1679 -> 1660;
1679 -> 1430;
1680 -> 1613;
1681 -> 1680;
1681 -> 1434;
1682 -> 1681;
1682 -> 1436;
1682 -> 1434;
1683 -> 1632;
1684 -> 1683;
1684 -> 1472;
1685 -> 1684;
1685 -> 1474;
1685 -> 1472;
1686 -> 1470;
1686 -> 1502;
1686 -> 1628;
1686 -> 1685;
1686 -> 1637;
1686 -> 1498;
1686 -> 1499;
1686 -> 1638;
1686 -> 1509;
1686 -> 1501;
1687 -> 1652;
1688 -> 1687;
1688 -> 1521;
1689 -> 1688;
1689 -> 1523;
1689 -> 1521;
1690 -> 1519;
1690 -> 1553;
1690 -> 1648;
1690 -> 1689;
1690 -> 1657;
1690 -> 1547;
1690 -> 1548;
1690 -> 1658;
1690 -> 1555;
1690 -> 1552;
1691 -> 1672;
1692 -> 1691;
1692 -> 1567;
1693 -> 1692;
1693 -> 1569;
1693 -> 1567;
1694 -> 1565;
1694 -> 1599;
1694 -> 1668;
1694 -> 1693;
1694 -> 1677;
1694 -> 1593;
1694 -> 1594;
1694 -> 1678;
1694 -> 1601;
1694 -> 1598;
1695 -> 1613;
1696 -> 1695;
1696 -> 1434;
1697 -> 1696;
1697 -> 1436;
1697 -> 1434;
1698 -> 1632;
1699 -> 1698;
1699 -> 1472;
1700 -> 1699;
1700 -> 1474;
1700 -> 1472;
1701 -> 1470;
1701 -> 1502;
1701 -> 1628;
1701 -> 1700;
1701 -> 1637;
1701 -> 1498;
1701 -> 1499;
1701 -> 1686;
1701 -> 1509;
1701 -> 1501;
1702 -> 1652;
1703 -> 1702;
1703 -> 1521;
1704 -> 1703;
1704 -> 1523;
1704 -> 1521;
1705 -> 1519;
1705 -> 1553;
1705 -> 1648;
1705 -> 1704;
1705 -> 1657;
1705 -> 1547;
1705 -> 1548;
1705 -> 1690;
1705 -> 1555;
1705 -> 1552;
1706 -> 1672;
1707 -> 1706;
1707 -> 1567;
1708 -> 1707;
1708 -> 1569;
1708 -> 1567;
1709 -> 1565;
1709 -> 1599;
1709 -> 1668;
1709 -> 1708;
1709 -> 1677;
1709 -> 1593;
1709 -> 1594;
1709 -> 1694;
1709 -> 1601;
1709 -> 1598;
1710 -> 1613;
1711 -> 1710;
1711 -> 1434;
1712 -> 1711;
1712 -> 1436;
1712 -> 1434;
1713 -> 1632;
1714 -> 1713;
1714 -> 1472;
1715 -> 1714;
1715 -> 1474;
1715 -> 1472;
1716 -> 1470;
1716 -> 1502;
1716 -> 1628;
1716 -> 1715;
1716 -> 1637;
1716 -> 1498;
1716 -> 1499;
1716 -> 1701;
1716 -> 1509;
1716 -> 1501;
1717 -> 1652;
1718 -> 1717;
1718 -> 1521;
1719 -> 1718;
1719 -> 1523;
1719 -> 1521;
1720 -> 1519;
1720 -> 1553;
1720 -> 1648;
1720 -> 1719;
1720 -> 1657;
1720 -> 1547;
1720 -> 1548;
1720 -> 1705;
1720 -> 1555;
1720 -> 1552;
1721 -> 1672;
1722 -> 1721;
1722 -> 1567;
1723 -> 1722;
1723 -> 1569;
1723 -> 1567;
1724 -> 1565;
1724 -> 1599;
1724 -> 1668;
1724 -> 1723;
1724 -> 1677;
1724 -> 1593;
1724 -> 1594;
1724 -> 1709;
1724 -> 1601;
1724 -> 1598;
1725 -> 1613;
1726 -> 1725;
1726 -> 1434;
1727 -> 1726;
1727 -> 1436;
1727 -> 1434;
1728 -> 1632;
1729 -> 1728;
1729 -> 1472;
1730 -> 1729;
1730 -> 1474;
1730 -> 1472;
1731 -> 1470;
1731 -> 1502;
1731 -> 1628;
1731 -> 1730;
1731 -> 1637;
1731 -> 1498;
1731 -> 1499;
1731 -> 1716;
1731 -> 1509;
1731 -> 1501;
1732 -> 1652;
1733 -> 1732;
1733 -> 1521;
1734 -> 1733;
1734 -> 1523;
1734 -> 1521;
1735 -> 1519;
1735 -> 1553;
1735 -> 1648;
1735 -> 1734;
1735 -> 1657;
1735 -> 1547;
1735 -> 1548;
1735 -> 1720;
1735 -> 1555;
1735 -> 1552;
1736 -> 1672;
1737 -> 1736;
1737 -> 1567;
1738 -> 1737;
1738 -> 1569;
1738 -> 1567;
1739 -> 1565;
1739 -> 1599;
1739 -> 1668;
1739 -> 1738;
1739 -> 1677;
1739 -> 1593;
1739 -> 1594;
1739 -> 1724;
1739 -> 1601;
1739 -> 1598;
1740 -> 1613;
1741 -> 1740;
1741 -> 1434;
1742 -> 1741;
1742 -> 1436;
1742 -> 1434;
1743 -> 1632;
1744 -> 1743;
1744 -> 1472;
1745 -> 1744;
1745 -> 1474;
1745 -> 1472;
1746 -> 1470;
1746 -> 1502;
1746 -> 1628;
1746 -> 1745;
1746 -> 1637;
1746 -> 1498;
1746 -> 1499;
1746 -> 1731;
1746 -> 1509;
1746 -> 1501;
1747 -> 1652;
1748 -> 1747;
1748 -> 1521;
1749 -> 1748;
1749 -> 1523;
1749 -> 1521;
1750 -> 1519;
1750 -> 1553;
1750 -> 1648;
1750 -> 1749;
1750 -> 1657;
1750 -> 1547;
1750 -> 1548;
1750 -> 1735;
1750 -> 1555;
1750 -> 1552;
1751 -> 1672;
1752 -> 1751;
1752 -> 1567;
1753 -> 1752;
1753 -> 1569;
1753 -> 1567;
1754 -> 1565;
1754 -> 1599;
1754 -> 1668;
1754 -> 1753;
1754 -> 1677;
1754 -> 1593;
1754 -> 1594;
1754 -> 1739;
1754 -> 1601;
1754 -> 1598;
1755 -> 1613;
1756 -> 1755;
1756 -> 1434;
1757 -> 1756;
1757 -> 1436;
1757 -> 1434;
1758 -> 1632;
1759 -> 1758;
1759 -> 1472;
1760 -> 1759;
1760 -> 1474;
1760 -> 1472;
1761 -> 1470;
1761 -> 1502;
1761 -> 1628;
1761 -> 1760;
1761 -> 1637;
1761 -> 1498;
1761 -> 1499;
1761 -> 1746;
1761 -> 1509;
1761 -> 1501;
1762 -> 1652;
1763 -> 1762;
1763 -> 1521;
1764 -> 1763;
1764 -> 1523;
1764 -> 1521;
1765 -> 1519;
1765 -> 1553;
1765 -> 1648;
1765 -> 1764;
1765 -> 1657;
1765 -> 1547;
1765 -> 1548;
1765 -> 1750;
1765 -> 1555;
1765 -> 1552;
1766 -> 1672;
1767 -> 1766;
1767 -> 1567;
1768 -> 1767;
1768 -> 1569;
1768 -> 1567;
1769 -> 1565;
1769 -> 1599;
1769 -> 1668;
1769 -> 1768;
1769 -> 1677;
1769 -> 1593;
1769 -> 1594;
1769 -> 1754;
1769 -> 1601;
1769 -> 1598;
1770 -> 1613;
1771 -> 1770;
1771 -> 1434;
1772 -> 1771;
1772 -> 1436;
1772 -> 1434;
1773 -> 1632;
1774 -> 1773;
1774 -> 1472;
1775 -> 1774;
1775 -> 1474;
1775 -> 1472;
1776 -> 1470;
1776 -> 1502;
1776 -> 1628;
1776 -> 1775;
1776 -> 1637;
1776 -> 1498;
1776 -> 1499;
1776 -> 1761;
1776 -> 1509;
1776 -> 1501;
1777 -> 1652;
1778 -> 1777;
1778 -> 1521;
1779 -> 1778;
1779 -> 1523;
1779 -> 1521;
1780 -> 1519;
1780 -> 1553;
1780 -> 1648;
1780 -> 1779;
1780 -> 1657;
1780 -> 1547;
1780 -> 1548;
1780 -> 1765;
1780 -> 1555;
1780 -> 1552;
1781 -> 1672;
1782 -> 1781;
1782 -> 1567;
1783 -> 1782;
1783 -> 1569;
1783 -> 1567;
1784 -> 1565;
1784 -> 1599;
1784 -> 1668;
1784 -> 1783;
1784 -> 1677;
1784 -> 1593;
1784 -> 1594;
1784 -> 1769;
1784 -> 1601;
1784 -> 1598;
1785 -> 1613;
1786 -> 1785;
1786 -> 1434;
1787 -> 1786;
1787 -> 1436;
1787 -> 1434;
1788 -> 1632;
1789 -> 1788;
1789 -> 1472;
1790 -> 1789;
1790 -> 1474;
1790 -> 1472;
1791 -> 1470;
1791 -> 1502;
1791 -> 1628;
1791 -> 1790;
1791 -> 1637;
1791 -> 1498;
1791 -> 1499;
1791 -> 1776;
1791 -> 1509;
1791 -> 1501;
1792 -> 1652;
1793 -> 1792;
1793 -> 1521;
1794 -> 1793;
1794 -> 1523;
1794 -> 1521;
1795 -> 1519;
1795 -> 1553;
1795 -> 1648;
1795 -> 1794;
1795 -> 1657;
1795 -> 1547;
1795 -> 1548;
1795 -> 1780;
1795 -> 1555;
1795 -> 1552;
1796 -> 1672;
1797 -> 1796;
1797 -> 1567;
1798 -> 1797;
1798 -> 1569;
1798 -> 1567;
1799 -> 1565;
1799 -> 1599;
1799 -> 1668;
1799 -> 1798;
1799 -> 1677;
1799 -> 1593;
1799 -> 1594;
1799 -> 1784;
1799 -> 1601;
1799 -> 1598;
1800 -> 1613;
1801 -> 1800;
1801 -> 1434;
1802 -> 1801;
1802 -> 1436;
1802 -> 1434;
1803 -> 1632;
1804 -> 1803;
1804 -> 1472;
1805 -> 1804;
1805 -> 1474;
1805 -> 1472;
1806 -> 1470;
1806 -> 1502;
1806 -> 1628;
1806 -> 1805;
1806 -> 1637;
1806 -> 1498;
1806 -> 1499;
1806 -> 1791;
1806 -> 1509;
1806 -> 1501;
1807 -> 1652;
1808 -> 1807;
1808 -> 1521;
1809 -> 1808;
1809 -> 1523;
1809 -> 1521;
1810 -> 1519;
1810 -> 1553;
1810 -> 1648;
1810 -> 1809;
1810 -> 1657;
1810 -> 1547;
1810 -> 1548;
1810 -> 1795;
1810 -> 1555;
1810 -> 1552;
1811 -> 1672;
1812 -> 1811;
1812 -> 1567;
1813 -> 1812;
1813 -> 1569;
1813 -> 1567;
1814 -> 1565;
1814 -> 1599;
1814 -> 1668;
1814 -> 1813;
1814 -> 1677;
1814 -> 1593;
1814 -> 1594;
1814 -> 1799;
1814 -> 1601;
1814 -> 1598;
1815 -> 1613;
1816 -> 1815;
1816 -> 1434;
1817 -> 1816;
1817 -> 1436;
1817 -> 1434;
1818 -> 1632;
1819 -> 1818;
1819 -> 1472;
1820 -> 1819;
1820 -> 1474;
1820 -> 1472;
1821 -> 1470;
1821 -> 1502;
1821 -> 1628;
1821 -> 1820;
1821 -> 1637;
1821 -> 1498;
1821 -> 1499;
1821 -> 1806;
1821 -> 1509;
1821 -> 1501;
1822 -> 1652;
1823 -> 1822;
1823 -> 1521;
1824 -> 1823;
1824 -> 1523;
1824 -> 1521;
1825 -> 1519;
1825 -> 1553;
1825 -> 1648;
1825 -> 1824;
1825 -> 1657;
1825 -> 1547;
1825 -> 1548;
1825 -> 1810;
1825 -> 1555;
1825 -> 1552;
1826 -> 1672;
1827 -> 1826;
1827 -> 1567;
1828 -> 1827;
1828 -> 1569;
1828 -> 1567;
1829 -> 1565;
1829 -> 1599;
1829 -> 1668;
1829 -> 1828;
1829 -> 1677;
1829 -> 1593;
1829 -> 1594;
1829 -> 1814;
1829 -> 1601;
1829 -> 1598;
1830 -> 1613;
1831 -> 1830;
1831 -> 1434;
1832 -> 1831;
1832 -> 1436;
1832 -> 1434;
1833 -> 1632;
1834 -> 1833;
1834 -> 1472;
1835 -> 1834;
1835 -> 1474;
1835 -> 1472;
1836 -> 1470;
1836 -> 1502;
1836 -> 1628;
1836 -> 1835;
1836 -> 1637;
1836 -> 1498;
1836 -> 1499;
1836 -> 1821;
1836 -> 1509;
1836 -> 1501;
1837 -> 1652;
1838 -> 1837;
1838 -> 1521;
1839 -> 1838;
1839 -> 1523;
1839 -> 1521;
1840 -> 1519;
1840 -> 1553;
1840 -> 1648;
1840 -> 1839;
1840 -> 1657;
1840 -> 1547;
1840 -> 1548;
1840 -> 1825;
1840 -> 1555;
1840 -> 1552;
1841 -> 1672;
1842 -> 1841;
1842 -> 1567;
1843 -> 1842;
1843 -> 1569;
1843 -> 1567;
1844 -> 1565;
1844 -> 1599;
1844 -> 1668;
1844 -> 1843;
1844 -> 1677;
1844 -> 1593;
1844 -> 1594;
1844 -> 1829;
1844 -> 1601;
1844 -> 1598;
1845 -> 1613;
1846 -> 1845;
1846 -> 1434;
1847 -> 1846;
1847 -> 1436;
1847 -> 1434;
1848 -> 1632;
1849 -> 1848;
1849 -> 1472;
1850 -> 1849;
1850 -> 1474;
1850 -> 1472;
1851 -> 1470;
1851 -> 1502;
1851 -> 1628;
1851 -> 1850;
1851 -> 1637;
1851 -> 1498;
1851 -> 1499;
1851 -> 1836;
1851 -> 1509;
1851 -> 1501;
1852 -> 1652;
1853 -> 1852;
1853 -> 1521;
1854 -> 1853;
1854 -> 1523;
1854 -> 1521;
1855 -> 1519;
1855 -> 1553;
1855 -> 1648;
1855 -> 1854;
1855 -> 1657;
1855 -> 1547;
1855 -> 1548;
1855 -> 1840;
1855 -> 1555;
1855 -> 1552;
1856 -> 1672;
1857 -> 1856;
1857 -> 1567;
1858 -> 1857;
1858 -> 1569;
1858 -> 1567;
1859 -> 1565;
1859 -> 1599;
1859 -> 1668;
1859 -> 1858;
1859 -> 1677;
1859 -> 1593;
1859 -> 1594;
1859 -> 1844;
1859 -> 1601;
1859 -> 1598;
1860 -> 1613;
1861 -> 1860;
1861 -> 1434;
1862 -> 1861;
1862 -> 1436;
1862 -> 1434;
1863 -> 1632;
1864 -> 1863;
1864 -> 1472;
1865 -> 1864;
1865 -> 1474;
1865 -> 1472;
1866 -> 1470;
1866 -> 1502;
1866 -> 1628;
1866 -> 1865;
1866 -> 1637;
1866 -> 1498;
1866 -> 1499;
1866 -> 1851;
1866 -> 1509;
1866 -> 1501;
1867 -> 1652;
1868 -> 1867;
1868 -> 1521;
1869 -> 1868;
1869 -> 1523;
1869 -> 1521;
1870 -> 1519;
1870 -> 1553;
1870 -> 1648;
1870 -> 1869;
1870 -> 1657;
1870 -> 1547;
1870 -> 1548;
1870 -> 1855;
1870 -> 1555;
1870 -> 1552;
1871 -> 1672;
1872 -> 1871;
1872 -> 1567;
1873 -> 1872;
1873 -> 1569;
1873 -> 1567;
1874 -> 1565;
1874 -> 1599;
1874 -> 1668;
1874 -> 1873;
1874 -> 1677;
1874 -> 1593;
1874 -> 1594;
1874 -> 1859;
1874 -> 1601;
1874 -> 1598;
1875 -> 1613;
1876 -> 1875;
1876 -> 1434;
1877 -> 1876;
1877 -> 1436;
1877 -> 1434;
1878 -> 1632;
1879 -> 1878;
1879 -> 1472;
1880 -> 1879;
1880 -> 1474;
1880 -> 1472;
1881 -> 1470;
1881 -> 1502;
1881 -> 1628;
1881 -> 1880;
1881 -> 1637;
1881 -> 1498;
1881 -> 1499;
1881 -> 1866;
1881 -> 1509;
1881 -> 1501;
1882 -> 1652;
1883 -> 1882;
1883 -> 1521;
1884 -> 1883;
1884 -> 1523;
1884 -> 1521;
1885 -> 1519;
1885 -> 1553;
1885 -> 1648;
1885 -> 1884;
1885 -> 1657;
1885 -> 1547;
1885 -> 1548;
1885 -> 1870;
1885 -> 1555;
1885 -> 1552;
1886 -> 1672;
1887 -> 1886;
1887 -> 1567;
1888 -> 1887;
1888 -> 1569;
1888 -> 1567;
1889 -> 1565;
1889 -> 1599;
1889 -> 1668;
1889 -> 1888;
1889 -> 1677;
1889 -> 1593;
1889 -> 1594;
1889 -> 1874;
1889 -> 1601;
1889 -> 1598;
1890 -> 1613;
1891 -> 1890;
1891 -> 1434;
1892 -> 1891;
1892 -> 1436;
1892 -> 1434;
1893 -> 1632;
1894 -> 1893;
1894 -> 1472;
1895 -> 1894;
1895 -> 1474;
1895 -> 1472;
1896 -> 1470;
1896 -> 1502;
1896 -> 1628;
1896 -> 1895;
1896 -> 1637;
1896 -> 1498;
1896 -> 1499;
1896 -> 1881;
1896 -> 1509;
1896 -> 1501;
1897 -> 1652;
1898 -> 1897;
1898 -> 1521;
1899 -> 1898;
1899 -> 1523;
1899 -> 1521;
1900 -> 1519;
1900 -> 1553;
1900 -> 1648;
1900 -> 1899;
1900 -> 1657;
1900 -> 1547;
1900 -> 1548;
1900 -> 1885;
1900 -> 1555;
1900 -> 1552;
1901 -> 1672;
1902 -> 1901;
1902 -> 1567;
1903 -> 1902;
1903 -> 1569;
1903 -> 1567;
1904 -> 1565;
1904 -> 1599;
1904 -> 1668;
1904 -> 1903;
1904 -> 1677;
1904 -> 1593;
1904 -> 1594;
1904 -> 1889;
1904 -> 1601;
1904 -> 1598;
1905 -> 1613;
1906 -> 1905;
1906 -> 1434;
1907 -> 1906;
1907 -> 1436;
1907 -> 1434;
1908 -> 1632;
1909 -> 1908;
1909 -> 1472;
1910 -> 1909;
1910 -> 1474;
1910 -> 1472;
1911 -> 1470;
1911 -> 1502;
1911 -> 1628;
1911 -> 1910;
1911 -> 1637;
1911 -> 1498;
1911 -> 1499;
1911 -> 1896;
1911 -> 1509;
1911 -> 1501;
1912 -> 1652;
1913 -> 1912;
1913 -> 1521;
1914 -> 1913;
1914 -> 1523;
1914 -> 1521;
1915 -> 1519;
1915 -> 1553;
1915 -> 1648;
1915 -> 1914;
1915 -> 1657;
1915 -> 1547;
1915 -> 1548;
1915 -> 1900;
1915 -> 1555;
1915 -> 1552;
1916 -> 1672;
1917 -> 1916;
1917 -> 1567;
1918 -> 1917;
1918 -> 1569;
1918 -> 1567;
1919 -> 1565;
1919 -> 1599;
1919 -> 1668;
1919 -> 1918;
1919 -> 1677;
1919 -> 1593;
1919 -> 1594;
1919 -> 1904;
1919 -> 1601;
1919 -> 1598;
1920 -> 1613;
1921 -> 1920;
1921 -> 1434;
1922 -> 1921;
1922 -> 1436;
1922 -> 1434;
1923 -> 1632;
1924 -> 1923;
1924 -> 1472;
1925 -> 1924;
1925 -> 1474;
1925 -> 1472;
1926 -> 1470;
1926 -> 1502;
1926 -> 1628;
1926 -> 1925;
1926 -> 1637;
1926 -> 1498;
1926 -> 1499;
1926 -> 1911;
1926 -> 1509;
1926 -> 1501;
1927 -> 1652;
1928 -> 1927;
1928 -> 1521;
1929 -> 1928;
1929 -> 1523;
1929 -> 1521;
1930 -> 1519;
1930 -> 1553;
1930 -> 1648;
1930 -> 1929;
1930 -> 1657;
1930 -> 1547;
1930 -> 1548;
1930 -> 1915;
1930 -> 1555;
1930 -> 1552;
1931 -> 1672;
1932 -> 1931;
1932 -> 1567;
1933 -> 1932;
1933 -> 1569;
1933 -> 1567;
1934 -> 1565;
1934 -> 1599;
1934 -> 1668;
1934 -> 1933;
1934 -> 1677;
1934 -> 1593;
1934 -> 1594;
1934 -> 1919;
1934 -> 1601;
1934 -> 1598;
1935 -> 1613;
1936 -> 1935;
1936 -> 1434;
1937 -> 1936;
1937 -> 1436;
1937 -> 1434;
1938 -> 1632;
1939 -> 1938;
1939 -> 1472;
1940 -> 1939;
1940 -> 1474;
1940 -> 1472;
1941 -> 1470;
1941 -> 1502;
1941 -> 1628;
1941 -> 1940;
1941 -> 1637;
1941 -> 1498;
1941 -> 1499;
1941 -> 1926;
1941 -> 1509;
1941 -> 1501;
1942 -> 1652;
1943 -> 1942;
1943 -> 1521;
1944 -> 1943;
1944 -> 1523;
1944 -> 1521;
1945 -> 1519;
1945 -> 1553;
1945 -> 1648;
1945 -> 1944;
1945 -> 1657;
1945 -> 1547;
1945 -> 1548;
1945 -> 1930;
1945 -> 1555;
1945 -> 1552;
1946 -> 1672;
1947 -> 1946;
1947 -> 1567;
1948 -> 1947;
1948 -> 1569;
1948 -> 1567;
1949 -> 1565;
1949 -> 1599;
1949 -> 1668;
1949 -> 1948;
1949 -> 1677;
1949 -> 1593;
1949 -> 1594;
1949 -> 1934;
1949 -> 1601;
1949 -> 1598;
1950 -> 1613;
1951 -> 1950;
1951 -> 1434;
1952 -> 1951;
1952 -> 1436;
1952 -> 1434;
1953 -> 1632;
1954 -> 1953;
1954 -> 1472;
1955 -> 1954;
1955 -> 1474;
1955 -> 1472;
1956 -> 1470;
1956 -> 1502;
1956 -> 1628;
1956 -> 1955;
1956 -> 1637;
1956 -> 1498;
1956 -> 1499;
1956 -> 1941;
1956 -> 1509;
1956 -> 1501;
1957 -> 1652;
1958 -> 1957;
1958 -> 1521;
1959 -> 1958;
1959 -> 1523;
1959 -> 1521;
1960 -> 1519;
1960 -> 1553;
1960 -> 1648;
1960 -> 1959;
1960 -> 1657;
1960 -> 1547;
1960 -> 1548;
1960 -> 1945;
1960 -> 1555;
1960 -> 1552;
1961 -> 1672;
1962 -> 1961;
1962 -> 1567;
1963 -> 1962;
1963 -> 1569;
1963 -> 1567;
1964 -> 1565;
1964 -> 1599;
1964 -> 1668;
1964 -> 1963;
1964 -> 1677;
1964 -> 1593;
1964 -> 1594;
1964 -> 1949;
1964 -> 1601;
1964 -> 1598;
1965 -> 1613;
1966 -> 1965;
1966 -> 1434;
1967 -> 1966;
1967 -> 1436;
1967 -> 1434;
1968 -> 1632;
1969 -> 1968;
1969 -> 1472;
1970 -> 1969;
1970 -> 1474;
1970 -> 1472;
1971 -> 1470;
1971 -> 1502;
1971 -> 1628;
1971 -> 1970;
1971 -> 1637;
1971 -> 1498;
1971 -> 1499;
1971 -> 1956;
1971 -> 1509;
1971 -> 1501;
1972 -> 1652;
1973 -> 1972;
1973 -> 1521;
1974 -> 1973;
1974 -> 1523;
1974 -> 1521;
1975 -> 1519;
1975 -> 1553;
1975 -> 1648;
1975 -> 1974;
1975 -> 1657;
1975 -> 1547;
1975 -> 1548;
1975 -> 1960;
1975 -> 1555;
1975 -> 1552;
1976 -> 1672;
1977 -> 1976;
1977 -> 1567;
1978 -> 1977;
1978 -> 1569;
1978 -> 1567;
1979 -> 1565;
1979 -> 1599;
1979 -> 1668;
1979 -> 1978;
1979 -> 1677;
1979 -> 1593;
1979 -> 1594;
1979 -> 1964;
1979 -> 1601;
1979 -> 1598;
1980 -> 1613;
1981 -> 1980;
1981 -> 1434;
1982 -> 1981;
1982 -> 1436;
1982 -> 1434;
1983 -> 1632;
1984 -> 1983;
1984 -> 1472;
1985 -> 1984;
1985 -> 1474;
1985 -> 1472;
1986 -> 1470;
1986 -> 1502;
1986 -> 1628;
1986 -> 1985;
1986 -> 1637;
1986 -> 1498;
1986 -> 1499;
1986 -> 1971;
1986 -> 1509;
1986 -> 1501;
1987 -> 1652;
1988 -> 1987;
1988 -> 1521;
1989 -> 1988;
1989 -> 1523;
1989 -> 1521;
1990 -> 1519;
1990 -> 1553;
1990 -> 1648;
1990 -> 1989;
1990 -> 1657;
1990 -> 1547;
1990 -> 1548;
1990 -> 1975;
1990 -> 1555;
1990 -> 1552;
1991 -> 1672;
1992 -> 1991;
1992 -> 1567;
1993 -> 1992;
1993 -> 1569;
1993 -> 1567;
1994 -> 1565;
1994 -> 1599;
1994 -> 1668;
1994 -> 1993;
1994 -> 1677;
1994 -> 1593;
1994 -> 1594;
1994 -> 1979;
1994 -> 1601;
1994 -> 1598;
1995 -> 1613;
1996 -> 1995;
1996 -> 1434;
1997 -> 1996;
1997 -> 1436;
1997 -> 1434;
1998 -> 1632;
1999 -> 1998;
1999 -> 1472;
2000 -> 1999;
2000 -> 1474;
2000 -> 1472;
2001 -> 1470;
2001 -> 1502;
2001 -> 1628;
2001 -> 2000;
2001 -> 1637;
2001 -> 1498;
2001 -> 1499;
2001 -> 1986;
2001 -> 1509;
2001 -> 1501;
2002 -> 1652;
2003 -> 2002;
2003 -> 1521;
2004 -> 2003;
2004 -> 1523;
2004 -> 1521;
2005 -> 1519;
2005 -> 1553;
2005 -> 1648;
2005 -> 2004;
2005 -> 1657;
2005 -> 1547;
2005 -> 1548;
2005 -> 1990;
2005 -> 1555;
2005 -> 1552;
2006 -> 1672;
2007 -> 2006;
2007 -> 1567;
2008 -> 2007;
2008 -> 1569;
2008 -> 1567;
2009 -> 1565;
2009 -> 1599;
2009 -> 1668;
2009 -> 2008;
2009 -> 1677;
2009 -> 1593;
2009 -> 1594;
2009 -> 1994;
2009 -> 1601;
2009 -> 1598;
2010 -> 1613;
2011 -> 2010;
2011 -> 1434;
2012 -> 2011;
2012 -> 1436;
2012 -> 1434;
2013 -> 1632;
2014 -> 2013;
2014 -> 1472;
2015 -> 2014;
2015 -> 1474;
2015 -> 1472;
2016 -> 1470;
2016 -> 1502;
2016 -> 1628;
2016 -> 2015;
2016 -> 1637;
2016 -> 1498;
2016 -> 1499;
2016 -> 2001;
2016 -> 1509;
2016 -> 1501;
2017 -> 1652;
2018 -> 2017;
2018 -> 1521;
2019 -> 2018;
2019 -> 1523;
2019 -> 1521;
2020 -> 1519;
2020 -> 1553;
2020 -> 1648;
2020 -> 2019;
2020 -> 1657;
2020 -> 1547;
2020 -> 1548;
2020 -> 2005;
2020 -> 1555;
2020 -> 1552;
2021 -> 1672;
2022 -> 2021;
2022 -> 1567;
2023 -> 2022;
2023 -> 1569;
2023 -> 1567;
2024 -> 1565;
2024 -> 1599;
2024 -> 1668;
2024 -> 2023;
2024 -> 1677;
2024 -> 1593;
2024 -> 1594;
2024 -> 2009;
2024 -> 1601;
2024 -> 1598;
2025 -> 1613;
2026 -> 2025;
2026 -> 1434;
2027 -> 2026;
2027 -> 1436;
2027 -> 1434;
2028 -> 1632;
2029 -> 2028;
2029 -> 1472;
2030 -> 2029;
2030 -> 1474;
2030 -> 1472;
2031 -> 1470;
2031 -> 1502;
2031 -> 1628;
2031 -> 2030;
2031 -> 1637;
2031 -> 1498;
2031 -> 1499;
2031 -> 2016;
2031 -> 1509;
2031 -> 1501;
2032 -> 1652;
2033 -> 2032;
2033 -> 1521;
2034 -> 2033;
2034 -> 1523;
2034 -> 1521;
2035 -> 1519;
2035 -> 1553;
2035 -> 1648;
2035 -> 2034;
2035 -> 1657;
2035 -> 1547;
2035 -> 1548;
2035 -> 2020;
2035 -> 1555;
2035 -> 1552;
2036 -> 1672;
2037 -> 2036;
2037 -> 1567;
2038 -> 2037;
2038 -> 1569;
2038 -> 1567;
2039 -> 1565;
2039 -> 1599;
2039 -> 1668;
2039 -> 2038;
2039 -> 1677;
2039 -> 1593;
2039 -> 1594;
2039 -> 2024;
2039 -> 1601;
2039 -> 1598;
2040 -> 1613;
2041 -> 2040;
2041 -> 1434;
2042 -> 2041;
2042 -> 1436;
2042 -> 1434;
2043 -> 1632;
2044 -> 2043;
2044 -> 1472;
2045 -> 2044;
2045 -> 1474;
2045 -> 1472;
2046 -> 1470;
2046 -> 1502;
2046 -> 1628;
2046 -> 2045;
2046 -> 1637;
2046 -> 1498;
2046 -> 1499;
2046 -> 2031;
2046 -> 1509;
2046 -> 1501;
2047 -> 1652;
2048 -> 2047;
2048 -> 1521;
2049 -> 2048;
2049 -> 1523;
2049 -> 1521;
2050 -> 1519;
2050 -> 1553;
2050 -> 1648;
2050 -> 2049;
2050 -> 1657;
2050 -> 1547;
2050 -> 1548;
2050 -> 2035;
2050 -> 1555;
2050 -> 1552;
2051 -> 1672;
2052 -> 2051;
2052 -> 1567;
2053 -> 2052;
2053 -> 1569;
2053 -> 1567;
2054 -> 1565;
2054 -> 1599;
2054 -> 1668;
2054 -> 2053;
2054 -> 1677;
2054 -> 1593;
2054 -> 1594;
2054 -> 2039;
2054 -> 1601;
2054 -> 1598;
2055 -> 1613;
2056 -> 2055;
2056 -> 1434;
2057 -> 2056;
2057 -> 1436;
2057 -> 1434;
2058 -> 1632;
2059 -> 2058;
2059 -> 1472;
2060 -> 2059;
2060 -> 1474;
2060 -> 1472;
2061 -> 1470;
2061 -> 1502;
2061 -> 1628;
2061 -> 2060;
2061 -> 1637;
2061 -> 1498;
2061 -> 1499;
2061 -> 2046;
2061 -> 1509;
2061 -> 1501;
2062 -> 1652;
2063 -> 2062;
2063 -> 1521;
2064 -> 2063;
2064 -> 1523;
2064 -> 1521;
2065 -> 1519;
2065 -> 1553;
2065 -> 1648;
2065 -> 2064;
2065 -> 1657;
2065 -> 1547;
2065 -> 1548;
2065 -> 2050;
2065 -> 1555;
2065 -> 1552;
2066 -> 1672;
2067 -> 2066;
2067 -> 1567;
2068 -> 2067;
2068 -> 1569;
2068 -> 1567;
2069 -> 1565;
2069 -> 1599;
2069 -> 1668;
2069 -> 2068;
2069 -> 1677;
2069 -> 1593;
2069 -> 1594;
2069 -> 2054;
2069 -> 1601;
2069 -> 1598;
2070 -> 1613;
2071 -> 2070;
2071 -> 1434;
2072 -> 2071;
2072 -> 1436;
2072 -> 1434;
2073 -> 1632;
2074 -> 2073;
2074 -> 1472;
2075 -> 2074;
2075 -> 1474;
2075 -> 1472;
2076 -> 1470;
2076 -> 1502;
2076 -> 1628;
2076 -> 2075;
2076 -> 1637;
2076 -> 1498;
2076 -> 1499;
2076 -> 2061;
2076 -> 1509;
2076 -> 1501;
2077 -> 1652;
2078 -> 2077;
2078 -> 1521;
2079 -> 2078;
2079 -> 1523;
2079 -> 1521;
2080 -> 1519;
2080 -> 1553;
2080 -> 1648;
2080 -> 2079;
2080 -> 1657;
2080 -> 1547;
2080 -> 1548;
2080 -> 2065;
2080 -> 1555;
2080 -> 1552;
2081 -> 1672;
2082 -> 2081;
2082 -> 1567;
2083 -> 2082;
2083 -> 1569;
2083 -> 1567;
2084 -> 1565;
2084 -> 1599;
2084 -> 1668;
2084 -> 2083;
2084 -> 1677;
2084 -> 1593;
2084 -> 1594;
2084 -> 2069;
2084 -> 1601;
2084 -> 1598;
2085 -> 1613;
2086 -> 2085;
2086 -> 1434;
2087 -> 2086;
2087 -> 1436;
2087 -> 1434;
2088 -> 1632;
2089 -> 2088;
2089 -> 1472;
2090 -> 2089;
2090 -> 1474;
2090 -> 1472;
2091 -> 1470;
2091 -> 1502;
2091 -> 1628;
2091 -> 2090;
2091 -> 1637;
2091 -> 1498;
2091 -> 1499;
2091 -> 2076;
2091 -> 1509;
2091 -> 1501;
2092 -> 1652;
2093 -> 2092;
2093 -> 1521;
2094 -> 2093;
2094 -> 1523;
2094 -> 1521;
2095 -> 1519;
2095 -> 1553;
2095 -> 1648;
2095 -> 2094;
2095 -> 1657;
2095 -> 1547;
2095 -> 1548;
2095 -> 2080;
2095 -> 1555;
2095 -> 1552;
2096 -> 1672;
2097 -> 2096;
2097 -> 1567;
2098 -> 2097;
2098 -> 1569;
2098 -> 1567;
2099 -> 1565;
2099 -> 1599;
2099 -> 1668;
2099 -> 2098;
2099 -> 1677;
2099 -> 1593;
2099 -> 1594;
2099 -> 2084;
2099 -> 1601;
2099 -> 1598;
2100 -> 0;
2100 -> 1613;
2101 -> 2100;
2101 -> 1434;
2102 -> 2101;
2102 -> 1436;
2102 -> 1434;
2103 -> 0;
2103 -> 1632;
2104 -> 2103;
2104 -> 1472;
2105 -> 2104;
2105 -> 1474;
2105 -> 1472;
2106 -> 1470;
2106 -> 1502;
2106 -> 1628;
2106 -> 2105;
2106 -> 1637;
2106 -> 1498;
2106 -> 1499;
2106 -> 2091;
2106 -> 1509;
2106 -> 1501;
2107 -> 0;
2107 -> 1652;
2108 -> 2107;
2108 -> 1521;
2109 -> 2108;
2109 -> 1523;
2109 -> 1521;
2110 -> 1519;
2110 -> 1553;
2110 -> 1648;
2110 -> 2109;
2110 -> 1657;
2110 -> 1547;
2110 -> 1548;
2110 -> 2095;
2110 -> 1555;
2110 -> 1552;
2111 -> 0;
2111 -> 1672;
2112 -> 2111;
2112 -> 1567;
2113 -> 2112;
2113 -> 1569;
2113 -> 1567;
2114 -> 1565;
2114 -> 1599;
2114 -> 1668;
2114 -> 2113;
2114 -> 1677;
2114 -> 1593;
2114 -> 1594;
2114 -> 2099;
2114 -> 1601;
2114 -> 1598;
2115 -> 1613;
2116 -> 2115;
2116 -> 1434;
2117 -> 2116;
2117 -> 1436;
2117 -> 1434;
2118 -> 1632;
2119 -> 2118;
2119 -> 1472;
2120 -> 2119;
2120 -> 1474;
2120 -> 1472;
2121 -> 1470;
2121 -> 1502;
2121 -> 1628;
2121 -> 2120;
2121 -> 1637;
2121 -> 1498;
2121 -> 1499;
2121 -> 2106;
2121 -> 1509;
2121 -> 1501;
2122 -> 1652;
2123 -> 2122;
2123 -> 1521;
2124 -> 2123;
2124 -> 1523;
2124 -> 1521;
2125 -> 1519;
2125 -> 1553;
2125 -> 1648;
2125 -> 2124;
2125 -> 1657;
2125 -> 1547;
2125 -> 1548;
2125 -> 2110;
2125 -> 1555;
2125 -> 1552;
2126 -> 1672;
2127 -> 2126;
2127 -> 1567;
2128 -> 2127;
2128 -> 1569;
2128 -> 1567;
2129 -> 1565;
2129 -> 1599;
2129 -> 1668;
2129 -> 2128;
2129 -> 1677;
2129 -> 1593;
2129 -> 1594;
2129 -> 2114;
2129 -> 1601;
2129 -> 1598;
2130 -> 1613;
2131 -> 2130;
2131 -> 1434;
2132 -> 2131;
2132 -> 1436;
2132 -> 1434;
2133 -> 1632;
2134 -> 2133;
2134 -> 1472;
2135 -> 2134;
2135 -> 1474;
2135 -> 1472;
2136 -> 1470;
2136 -> 1502;
2136 -> 1628;
2136 -> 2135;
2136 -> 1637;
2136 -> 1498;
2136 -> 1499;
2136 -> 2121;
2136 -> 1509;
2136 -> 1501;
2137 -> 1652;
2138 -> 2137;
2138 -> 1521;
2139 -> 2138;
2139 -> 1523;
2139 -> 1521;
2140 -> 1519;
2140 -> 1553;
2140 -> 1648;
2140 -> 2139;
2140 -> 1657;
2140 -> 1547;
2140 -> 1548;
2140 -> 2125;
2140 -> 1555;
2140 -> 1552;
2141 -> 1672;
2142 -> 2141;
2142 -> 1567;
2143 -> 2142;
2143 -> 1569;
2143 -> 1567;
2144 -> 1565;
2144 -> 1599;
2144 -> 1668;
2144 -> 2143;
2144 -> 1677;
2144 -> 1593;
2144 -> 1594;
2144 -> 2129;
2144 -> 1601;
2144 -> 1598;
2145 -> 1613;
2146 -> 2145;
2146 -> 1434;
2147 -> 2146;
2147 -> 1436;
2147 -> 1434;
2148 -> 1632;
2149 -> 2148;
2149 -> 1472;
2150 -> 2149;
2150 -> 1474;
2150 -> 1472;
2151 -> 1470;
2151 -> 1502;
2151 -> 1628;
2151 -> 2150;
2151 -> 1637;
2151 -> 1498;
2151 -> 1499;
2151 -> 2136;
2151 -> 1509;
2151 -> 1501;
2152 -> 1652;
2153 -> 2152;
2153 -> 1521;
2154 -> 2153;
2154 -> 1523;
2154 -> 1521;
2155 -> 1519;
2155 -> 1553;
2155 -> 1648;
2155 -> 2154;
2155 -> 1657;
2155 -> 1547;
2155 -> 1548;
2155 -> 2140;
2155 -> 1555;
2155 -> 1552;
2156 -> 1672;
2157 -> 2156;
2157 -> 1567;
2158 -> 2157;
2158 -> 1569;
2158 -> 1567;
2159 -> 1565;
2159 -> 1599;
2159 -> 1668;
2159 -> 2158;
2159 -> 1677;
2159 -> 1593;
2159 -> 1594;
2159 -> 2144;
2159 -> 1601;
2159 -> 1598;
2160 -> 1613;
2161 -> 2160;
2161 -> 1434;
2162 -> 2161;
2162 -> 1436;
2162 -> 1434;
2163 -> 1632;
2164 -> 2163;
2164 -> 1472;
2165 -> 2164;
2165 -> 1474;
2165 -> 1472;
2166 -> 1470;
2166 -> 1502;
2166 -> 1628;
2166 -> 2165;
2166 -> 1637;
2166 -> 1498;
2166 -> 1499;
2166 -> 2151;
2166 -> 1509;
2166 -> 1501;
2167 -> 1652;
2168 -> 2167;
2168 -> 1521;
2169 -> 2168;
2169 -> 1523;
2169 -> 1521;
2170 -> 1519;
2170 -> 1553;
2170 -> 1648;
2170 -> 2169;
2170 -> 1657;
2170 -> 1547;
2170 -> 1548;
2170 -> 2155;
2170 -> 1555;
2170 -> 1552;
2171 -> 1672;
2172 -> 2171;
2172 -> 1567;
2173 -> 2172;
2173 -> 1569;
2173 -> 1567;
2174 -> 1565;
2174 -> 1599;
2174 -> 1668;
2174 -> 2173;
2174 -> 1677;
2174 -> 1593;
2174 -> 1594;
2174 -> 2159;
2174 -> 1601;
2174 -> 1598;
2175 -> 1613;
2176 -> 2175;
2176 -> 1434;
2177 -> 2176;
2177 -> 1436;
2177 -> 1434;
2178 -> 1632;
2179 -> 2178;
2179 -> 1472;
2180 -> 2179;
2180 -> 1474;
2180 -> 1472;
2181 -> 1470;
2181 -> 1502;
2181 -> 1628;
2181 -> 2180;
2181 -> 1637;
2181 -> 1498;
2181 -> 1499;
2181 -> 2166;
2181 -> 1509;
2181 -> 1501;
2182 -> 1652;
2183 -> 2182;
2183 -> 1521;
2184 -> 2183;
2184 -> 1523;
2184 -> 1521;
2185 -> 1519;
2185 -> 1553;
2185 -> 1648;
2185 -> 2184;
2185 -> 1657;
2185 -> 1547;
2185 -> 1548;
2185 -> 2170;
2185 -> 1555;
2185 -> 1552;
2186 -> 1672;
2187 -> 2186;
2187 -> 1567;
2188 -> 2187;
2188 -> 1569;
2188 -> 1567;
2189 -> 1565;
2189 -> 1599;
2189 -> 1668;
2189 -> 2188;
2189 -> 1677;
2189 -> 1593;
2189 -> 1594;
2189 -> 2174;
2189 -> 1601;
2189 -> 1598;
2190 -> 1613;
2191 -> 2190;
2191 -> 1434;
2192 -> 2191;
2192 -> 1436;
2192 -> 1434;
2193 -> 1632;
2194 -> 2193;
2194 -> 1472;
2195 -> 2194;
2195 -> 1474;
2195 -> 1472;
2196 -> 1470;
2196 -> 1502;
2196 -> 1628;
2196 -> 2195;
2196 -> 1637;
2196 -> 1498;
2196 -> 1499;
2196 -> 2181;
2196 -> 1509;
2196 -> 1501;
2197 -> 1652;
2198 -> 2197;
2198 -> 1521;
2199 -> 2198;
2199 -> 1523;
2199 -> 1521;
2200 -> 1519;
2200 -> 1553;
2200 -> 1648;
2200 -> 2199;
2200 -> 1657;
2200 -> 1547;
2200 -> 1548;
2200 -> 2185;
2200 -> 1555;
2200 -> 1552;
2201 -> 1672;
2202 -> 2201;
2202 -> 1567;
2203 -> 2202;
2203 -> 1569;
2203 -> 1567;
2204 -> 1565;
2204 -> 1599;
2204 -> 1668;
2204 -> 2203;
2204 -> 1677;
2204 -> 1593;
2204 -> 1594;
2204 -> 2189;
2204 -> 1601;
2204 -> 1598;
2205 -> 1613;
2206 -> 2205;
2206 -> 1434;
2207 -> 2206;
2207 -> 1436;
2207 -> 1434;
2208 -> 1632;
2209 -> 2208;
2209 -> 1472;
2210 -> 2209;
2210 -> 1474;
2210 -> 1472;
2211 -> 1470;
2211 -> 1502;
2211 -> 1628;
2211 -> 2210;
2211 -> 1637;
2211 -> 1498;
2211 -> 1499;
2211 -> 2196;
2211 -> 1509;
2211 -> 1501;
2212 -> 1652;
2213 -> 2212;
2213 -> 1521;
2214 -> 2213;
2214 -> 1523;
2214 -> 1521;
2215 -> 1519;
2215 -> 1553;
2215 -> 1648;
2215 -> 2214;
2215 -> 1657;
2215 -> 1547;
2215 -> 1548;
2215 -> 2200;
2215 -> 1555;
2215 -> 1552;
2216 -> 1672;
2217 -> 2216;
2217 -> 1567;
2218 -> 2217;
2218 -> 1569;
2218 -> 1567;
2219 -> 1565;
2219 -> 1599;
2219 -> 1668;
2219 -> 2218;
2219 -> 1677;
2219 -> 1593;
2219 -> 1594;
2219 -> 2204;
2219 -> 1601;
2219 -> 1598;
2220 -> 1613;
2221 -> 2220;
2221 -> 1434;
2222 -> 2221;
2222 -> 1436;
2222 -> 1434;
2223 -> 1632;
2224 -> 2223;
2224 -> 1472;
2225 -> 2224;
2225 -> 1474;
2225 -> 1472;
2226 -> 1470;
2226 -> 1502;
2226 -> 1628;
2226 -> 2225;
2226 -> 1637;
2226 -> 1498;
2226 -> 1499;
2226 -> 2211;
2226 -> 1509;
2226 -> 1501;
2227 -> 1652;
2228 -> 2227;
2228 -> 1521;
2229 -> 2228;
2229 -> 1523;
2229 -> 1521;
2230 -> 1519;
2230 -> 1553;
2230 -> 1648;
2230 -> 2229;
2230 -> 1657;
2230 -> 1547;
2230 -> 1548;
2230 -> 2215;
2230 -> 1555;
2230 -> 1552;
2231 -> 1672;
2232 -> 2231;
2232 -> 1567;
2233 -> 2232;
2233 -> 1569;
2233 -> 1567;
2234 -> 1565;
2234 -> 1599;
2234 -> 1668;
2234 -> 2233;
2234 -> 1677;
2234 -> 1593;
2234 -> 1594;
2234 -> 2219;
2234 -> 1601;
2234 -> 1598;
2235 -> 1613;
2236 -> 2235;
2236 -> 1434;
2237 -> 2236;
2237 -> 1436;
2237 -> 1434;
2238 -> 1632;
2239 -> 2238;
2239 -> 1472;
2240 -> 2239;
2240 -> 1474;
2240 -> 1472;
2241 -> 1470;
2241 -> 1502;
2241 -> 1628;
2241 -> 2240;
2241 -> 1637;
2241 -> 1498;
2241 -> 1499;
2241 -> 2226;
2241 -> 1509;
2241 -> 1501;
2242 -> 1652;
2243 -> 2242;
2243 -> 1521;
2244 -> 2243;
2244 -> 1523;
2244 -> 1521;
2245 -> 1519;
2245 -> 1553;
2245 -> 1648;
2245 -> 2244;
2245 -> 1657;
2245 -> 1547;
2245 -> 1548;
2245 -> 2230;
2245 -> 1555;
2245 -> 1552;
2246 -> 1672;
2247 -> 2246;
2247 -> 1567;
2248 -> 2247;
2248 -> 1569;
2248 -> 1567;
2249 -> 1565;
2249 -> 1599;
2249 -> 1668;
2249 -> 2248;
2249 -> 1677;
2249 -> 1593;
2249 -> 1594;
2249 -> 2234;
2249 -> 1601;
2249 -> 1598;
2250 -> 1613;
2251 -> 2250;
2251 -> 1434;
2252 -> 2251;
2252 -> 1436;
2252 -> 1434;
2253 -> 1632;
2254 -> 2253;
2254 -> 1472;
2255 -> 2254;
2255 -> 1474;
2255 -> 1472;
2256 -> 1470;
2256 -> 1502;
2256 -> 1628;
2256 -> 2255;
2256 -> 1637;
2256 -> 1498;
2256 -> 1499;
2256 -> 2241;
2256 -> 1509;
2256 -> 1501;
2257 -> 1652;
2258 -> 2257;
2258 -> 1521;
2259 -> 2258;
2259 -> 1523;
2259 -> 1521;
2260 -> 1519;
2260 -> 1553;
2260 -> 1648;
2260 -> 2259;
2260 -> 1657;
2260 -> 1547;
2260 -> 1548;
2260 -> 2245;
2260 -> 1555;
2260 -> 1552;
2261 -> 1672;
2262 -> 2261;
2262 -> 1567;
2263 -> 2262;
2263 -> 1569;
2263 -> 1567;
2264 -> 1565;
2264 -> 1599;
2264 -> 1668;
2264 -> 2263;
2264 -> 1677;
2264 -> 1593;
2264 -> 1594;
2264 -> 2249;
2264 -> 1601;
2264 -> 1598;
2265 -> 1613;
2266 -> 2265;
2266 -> 1434;
2267 -> 2266;
2267 -> 1436;
2267 -> 1434;
2268 -> 1632;
2269 -> 2268;
2269 -> 1472;
2270 -> 2269;
2270 -> 1474;
2270 -> 1472;
2271 -> 1470;
2271 -> 1502;
2271 -> 1628;
2271 -> 2270;
2271 -> 1637;
2271 -> 1498;
2271 -> 1499;
2271 -> 2256;
2271 -> 1509;
2271 -> 1501;
2272 -> 1652;
2273 -> 2272;
2273 -> 1521;
2274 -> 2273;
2274 -> 1523;
2274 -> 1521;
2275 -> 1519;
2275 -> 1553;
2275 -> 1648;
2275 -> 2274;
2275 -> 1657;
2275 -> 1547;
2275 -> 1548;
2275 -> 2260;
2275 -> 1555;
2275 -> 1552;
2276 -> 1672;
2277 -> 2276;
2277 -> 1567;
2278 -> 2277;
2278 -> 1569;
2278 -> 1567;
2279 -> 1565;
2279 -> 1599;
2279 -> 1668;
2279 -> 2278;
2279 -> 1677;
2279 -> 1593;
2279 -> 1594;
2279 -> 2264;
2279 -> 1601;
2279 -> 1598;
2280 -> 1613;
2281 -> 2280;
2281 -> 1434;
2282 -> 2281;
2282 -> 1436;
2282 -> 1434;
2283 -> 1632;
2284 -> 2283;
2284 -> 1472;
2285 -> 2284;
2285 -> 1474;
2285 -> 1472;
2286 -> 1470;
2286 -> 1502;
2286 -> 1628;
2286 -> 2285;
2286 -> 1637;
2286 -> 1498;
2286 -> 1499;
2286 -> 2271;
2286 -> 1509;
2286 -> 1501;
2287 -> 1652;
2288 -> 2287;
2288 -> 1521;
2289 -> 2288;
2289 -> 1523;
2289 -> 1521;
2290 -> 1519;
2290 -> 1553;
2290 -> 1648;
2290 -> 2289;
2290 -> 1657;
2290 -> 1547;
2290 -> 1548;
2290 -> 2275;
2290 -> 1555;
2290 -> 1552;
2291 -> 1672;
2292 -> 2291;
2292 -> 1567;
2293 -> 2292;
2293 -> 1569;
2293 -> 1567;
2294 -> 1565;
2294 -> 1599;
2294 -> 1668;
2294 -> 2293;
2294 -> 1677;
2294 -> 1593;
2294 -> 1594;
2294 -> 2279;
2294 -> 1601;
2294 -> 1598;
2295 -> 1613;
2296 -> 2295;
2296 -> 1434;
2297 -> 2296;
2297 -> 1436;
2297 -> 1434;
2298 -> 1632;
2299 -> 2298;
2299 -> 1472;
2300 -> 2299;
2300 -> 1474;
2300 -> 1472;
2301 -> 1470;
2301 -> 1502;
2301 -> 1628;
2301 -> 2300;
2301 -> 1637;
2301 -> 1498;
2301 -> 1499;
2301 -> 2286;
2301 -> 1509;
2301 -> 1501;
2302 -> 1652;
2303 -> 2302;
2303 -> 1521;
2304 -> 2303;
2304 -> 1523;
2304 -> 1521;
2305 -> 1519;
2305 -> 1553;
2305 -> 1648;
2305 -> 2304;
2305 -> 1657;
2305 -> 1547;
2305 -> 1548;
2305 -> 2290;
2305 -> 1555;
2305 -> 1552;
2306 -> 1672;
2307 -> 2306;
2307 -> 1567;
2308 -> 2307;
2308 -> 1569;
2308 -> 1567;
2309 -> 1565;
2309 -> 1599;
2309 -> 1668;
2309 -> 2308;
2309 -> 1677;
2309 -> 1593;
2309 -> 1594;
2309 -> 2294;
2309 -> 1601;
2309 -> 1598;
2310 -> 1613;
2311 -> 2310;
2311 -> 1434;
2312 -> 2311;
2312 -> 1436;
2312 -> 1434;
2313 -> 1632;
2314 -> 2313;
2314 -> 1472;
2315 -> 2314;
2315 -> 1474;
2315 -> 1472;
2316 -> 1470;
2316 -> 1502;
2316 -> 1628;
2316 -> 2315;
2316 -> 1637;
2316 -> 1498;
2316 -> 1499;
2316 -> 2301;
2316 -> 1509;
2316 -> 1501;
2317 -> 1652;
2318 -> 2317;
2318 -> 1521;
2319 -> 2318;
2319 -> 1523;
2319 -> 1521;
2320 -> 1519;
2320 -> 1553;
2320 -> 1648;
2320 -> 2319;
2320 -> 1657;
2320 -> 1547;
2320 -> 1548;
2320 -> 2305;
2320 -> 1555;
2320 -> 1552;
2321 -> 1672;
2322 -> 2321;
2322 -> 1567;
2323 -> 2322;
2323 -> 1569;
2323 -> 1567;
2324 -> 1565;
2324 -> 1599;
2324 -> 1668;
2324 -> 2323;
2324 -> 1677;
2324 -> 1593;
2324 -> 1594;
2324 -> 2309;
2324 -> 1601;
2324 -> 1598;
2325 -> 1613;
2326 -> 2325;
2326 -> 1434;
2327 -> 2326;
2327 -> 1436;
2327 -> 1434;
2328 -> 1632;
2329 -> 2328;
2329 -> 1472;
2330 -> 2329;
2330 -> 1474;
2330 -> 1472;
2331 -> 1470;
2331 -> 1502;
2331 -> 1628;
2331 -> 2330;
2331 -> 1637;
2331 -> 1498;
2331 -> 1499;
2331 -> 2316;
2331 -> 1509;
2331 -> 1501;
2332 -> 1652;
2333 -> 2332;
2333 -> 1521;
2334 -> 2333;
2334 -> 1523;
2334 -> 1521;
2335 -> 1519;
2335 -> 1553;
2335 -> 1648;
2335 -> 2334;
2335 -> 1657;
2335 -> 1547;
2335 -> 1548;
2335 -> 2320;
2335 -> 1555;
2335 -> 1552;
2336 -> 1672;
2337 -> 2336;
2337 -> 1567;
2338 -> 2337;
2338 -> 1569;
2338 -> 1567;
2339 -> 1565;
2339 -> 1599;
2339 -> 1668;
2339 -> 2338;
2339 -> 1677;
2339 -> 1593;
2339 -> 1594;
2339 -> 2324;
2339 -> 1601;
2339 -> 1598;
2340 -> 1613;
2341 -> 2340;
2341 -> 1434;
2342 -> 2341;
2342 -> 1436;
2342 -> 1434;
2343 -> 1632;
2344 -> 2343;
2344 -> 1472;
2345 -> 2344;
2345 -> 1474;
2345 -> 1472;
2346 -> 1470;
2346 -> 1502;
2346 -> 1628;
2346 -> 2345;
2346 -> 1637;
2346 -> 1498;
2346 -> 1499;
2346 -> 2331;
2346 -> 1509;
2346 -> 1501;
2347 -> 1652;
2348 -> 2347;
2348 -> 1521;
2349 -> 2348;
2349 -> 1523;
2349 -> 1521;
2350 -> 1519;
2350 -> 1553;
2350 -> 1648;
2350 -> 2349;
2350 -> 1657;
2350 -> 1547;
2350 -> 1548;
2350 -> 2335;
2350 -> 1555;
2350 -> 1552;
2351 -> 1672;
2352 -> 2351;
2352 -> 1567;
2353 -> 2352;
2353 -> 1569;
2353 -> 1567;
2354 -> 1565;
2354 -> 1599;
2354 -> 1668;
2354 -> 2353;
2354 -> 1677;
2354 -> 1593;
2354 -> 1594;
2354 -> 2339;
2354 -> 1601;
2354 -> 1598;
2355 -> 1613;
2356 -> 2355;
2356 -> 1434;
2357 -> 2356;
2357 -> 1436;
2357 -> 1434;
2358 -> 1632;
2359 -> 2358;
2359 -> 1472;
2360 -> 2359;
2360 -> 1474;
2360 -> 1472;
2361 -> 1470;
2361 -> 1502;
2361 -> 1628;
2361 -> 2360;
2361 -> 1637;
2361 -> 1498;
2361 -> 1499;
2361 -> 2346;
2361 -> 1509;
2361 -> 1501;
2362 -> 1652;
2363 -> 2362;
2363 -> 1521;
2364 -> 2363;
2364 -> 1523;
2364 -> 1521;
2365 -> 1519;
2365 -> 1553;
2365 -> 1648;
2365 -> 2364;
2365 -> 1657;
2365 -> 1547;
2365 -> 1548;
2365 -> 2350;
2365 -> 1555;
2365 -> 1552;
2366 -> 1672;
2367 -> 2366;
2367 -> 1567;
2368 -> 2367;
2368 -> 1569;
2368 -> 1567;
2369 -> 1565;
2369 -> 1599;
2369 -> 1668;
2369 -> 2368;
2369 -> 1677;
2369 -> 1593;
2369 -> 1594;
2369 -> 2354;
2369 -> 1601;
2369 -> 1598;
2370 -> 1613;
2371 -> 2370;
2371 -> 1434;
2372 -> 2371;
2372 -> 1436;
2372 -> 1434;
2373 -> 1632;
2374 -> 2373;
2374 -> 1472;
2375 -> 2374;
2375 -> 1474;
2375 -> 1472;
2376 -> 1470;
2376 -> 1502;
2376 -> 1628;
2376 -> 2375;
2376 -> 1637;
2376 -> 1498;
2376 -> 1499;
2376 -> 2361;
2376 -> 1509;
2376 -> 1501;
2377 -> 1652;
2378 -> 2377;
2378 -> 1521;
2379 -> 2378;
2379 -> 1523;
2379 -> 1521;
2380 -> 1519;
2380 -> 1553;
2380 -> 1648;
2380 -> 2379;
2380 -> 1657;
2380 -> 1547;
2380 -> 1548;
2380 -> 2365;
2380 -> 1555;
2380 -> 1552;
2381 -> 1672;
2382 -> 2381;
2382 -> 1567;
2383 -> 2382;
2383 -> 1569;
2383 -> 1567;
2384 -> 1565;
2384 -> 1599;
2384 -> 1668;
2384 -> 2383;
2384 -> 1677;
2384 -> 1593;
2384 -> 1594;
2384 -> 2369;
2384 -> 1601;
2384 -> 1598;
2385 -> 1613;
2386 -> 2385;
2386 -> 1434;
2387 -> 2386;
2387 -> 1436;
2387 -> 1434;
2388 -> 1632;
2389 -> 2388;
2389 -> 1472;
2390 -> 2389;
2390 -> 1474;
2390 -> 1472;
2391 -> 1470;
2391 -> 1502;
2391 -> 1628;
2391 -> 2390;
2391 -> 1637;
2391 -> 1498;
2391 -> 1499;
2391 -> 2376;
2391 -> 1509;
2391 -> 1501;
2392 -> 1652;
2393 -> 2392;
2393 -> 1521;
2394 -> 2393;
2394 -> 1523;
2394 -> 1521;
2395 -> 1519;
2395 -> 1553;
2395 -> 1648;
2395 -> 2394;
2395 -> 1657;
2395 -> 1547;
2395 -> 1548;
2395 -> 2380;
2395 -> 1555;
2395 -> 1552;
2396 -> 1672;
2397 -> 2396;
2397 -> 1567;
2398 -> 2397;
2398 -> 1569;
2398 -> 1567;
2399 -> 1565;
2399 -> 1599;
2399 -> 1668;
2399 -> 2398;
2399 -> 1677;
2399 -> 1593;
2399 -> 1594;
2399 -> 2384;
2399 -> 1601;
2399 -> 1598;
2400 -> 1613;
2401 -> 2400;
2401 -> 1434;
2402 -> 2401;
2402 -> 1436;
2402 -> 1434;
2403 -> 1632;
2404 -> 2403;
2404 -> 1472;
2405 -> 2404;
2405 -> 1474;
2405 -> 1472;
2406 -> 1470;
2406 -> 1502;
2406 -> 1628;
2406 -> 2405;
2406 -> 1637;
2406 -> 1498;
2406 -> 1499;
2406 -> 2391;
2406 -> 1509;
2406 -> 1501;
2407 -> 1652;
2408 -> 2407;
2408 -> 1521;
2409 -> 2408;
2409 -> 1523;
2409 -> 1521;
2410 -> 1519;
2410 -> 1553;
2410 -> 1648;
2410 -> 2409;
2410 -> 1657;
2410 -> 1547;
2410 -> 1548;
2410 -> 2395;
2410 -> 1555;
2410 -> 1552;
2411 -> 1672;
2412 -> 2411;
2412 -> 1567;
2413 -> 2412;
2413 -> 1569;
2413 -> 1567;
2414 -> 1565;
2414 -> 1599;
2414 -> 1668;
2414 -> 2413;
2414 -> 1677;
2414 -> 1593;
2414 -> 1594;
2414 -> 2399;
2414 -> 1601;
2414 -> 1598;
2415 -> 1613;
2416 -> 2415;
2416 -> 1434;
2417 -> 2416;
2417 -> 1436;
2417 -> 1434;
2418 -> 1632;
2419 -> 2418;
2419 -> 1472;
2420 -> 2419;
2420 -> 1474;
2420 -> 1472;
2421 -> 1470;
2421 -> 1502;
2421 -> 1628;
2421 -> 2420;
2421 -> 1637;
2421 -> 1498;
2421 -> 1499;
2421 -> 2406;
2421 -> 1509;
2421 -> 1501;
2422 -> 1652;
2423 -> 2422;
2423 -> 1521;
2424 -> 2423;
2424 -> 1523;
2424 -> 1521;
2425 -> 1519;
2425 -> 1553;
2425 -> 1648;
2425 -> 2424;
2425 -> 1657;
2425 -> 1547;
2425 -> 1548;
2425 -> 2410;
2425 -> 1555;
2425 -> 1552;
2426 -> 1672;
2427 -> 2426;
2427 -> 1567;
2428 -> 2427;
2428 -> 1569;
2428 -> 1567;
2429 -> 1565;
2429 -> 1599;
2429 -> 1668;
2429 -> 2428;
2429 -> 1677;
2429 -> 1593;
2429 -> 1594;
2429 -> 2414;
2429 -> 1601;
2429 -> 1598;
2430 -> 1613;
2431 -> 2430;
2431 -> 1434;
2432 -> 2431;
2432 -> 1436;
2432 -> 1434;
2433 -> 1632;
2434 -> 2433;
2434 -> 1472;
2435 -> 2434;
2435 -> 1474;
2435 -> 1472;
2436 -> 1470;
2436 -> 1502;
2436 -> 1628;
2436 -> 2435;
2436 -> 1637;
2436 -> 1498;
2436 -> 1499;
2436 -> 2421;
2436 -> 1509;
2436 -> 1501;
2437 -> 1652;
2438 -> 2437;
2438 -> 1521;
2439 -> 2438;
2439 -> 1523;
2439 -> 1521;
2440 -> 1519;
2440 -> 1553;
2440 -> 1648;
2440 -> 2439;
2440 -> 1657;
2440 -> 1547;
2440 -> 1548;
2440 -> 2425;
2440 -> 1555;
2440 -> 1552;
2441 -> 1672;
2442 -> 2441;
2442 -> 1567;
2443 -> 2442;
2443 -> 1569;
2443 -> 1567;
2444 -> 1565;
2444 -> 1599;
2444 -> 1668;
2444 -> 2443;
2444 -> 1677;
2444 -> 1593;
2444 -> 1594;
2444 -> 2429;
2444 -> 1601;
2444 -> 1598;
2445 -> 1613;
2446 -> 2445;
2446 -> 1434;
2447 -> 2446;
2447 -> 1436;
2447 -> 1434;
2448 -> 1632;
2449 -> 2448;
2449 -> 1472;
2450 -> 2449;
2450 -> 1474;
2450 -> 1472;
2451 -> 1470;
2451 -> 1502;
2451 -> 1628;
2451 -> 2450;
2451 -> 1637;
2451 -> 1498;
2451 -> 1499;
2451 -> 2436;
2451 -> 1509;
2451 -> 1501;
2452 -> 1652;
2453 -> 2452;
2453 -> 1521;
2454 -> 2453;
2454 -> 1523;
2454 -> 1521;
2455 -> 1519;
2455 -> 1553;
2455 -> 1648;
2455 -> 2454;
2455 -> 1657;
2455 -> 1547;
2455 -> 1548;
2455 -> 2440;
2455 -> 1555;
2455 -> 1552;
2456 -> 1672;
2457 -> 2456;
2457 -> 1567;
2458 -> 2457;
2458 -> 1569;
2458 -> 1567;
2459 -> 1565;
2459 -> 1599;
2459 -> 1668;
2459 -> 2458;
2459 -> 1677;
2459 -> 1593;
2459 -> 1594;
2459 -> 2444;
2459 -> 1601;
2459 -> 1598;
2460 -> 1613;
2461 -> 2460;
2461 -> 1434;
2462 -> 2461;
2462 -> 1436;
2462 -> 1434;
2463 -> 1632;
2464 -> 2463;
2464 -> 1472;
2465 -> 2464;
2465 -> 1474;
2465 -> 1472;
2466 -> 1470;
2466 -> 1502;
2466 -> 1628;
2466 -> 2465;
2466 -> 1637;
2466 -> 1498;
2466 -> 1499;
2466 -> 2451;
2466 -> 1509;
2466 -> 1501;
2467 -> 1652;
2468 -> 2467;
2468 -> 1521;
2469 -> 2468;
2469 -> 1523;
2469 -> 1521;
2470 -> 1519;
2470 -> 1553;
2470 -> 1648;
2470 -> 2469;
2470 -> 1657;
2470 -> 1547;
2470 -> 1548;
2470 -> 2455;
2470 -> 1555;
2470 -> 1552;
2471 -> 1672;
2472 -> 2471;
2472 -> 1567;
2473 -> 2472;
2473 -> 1569;
2473 -> 1567;
2474 -> 1565;
2474 -> 1599;
2474 -> 1668;
2474 -> 2473;
2474 -> 1677;
2474 -> 1593;
2474 -> 1594;
2474 -> 2459;
2474 -> 1601;
2474 -> 1598;
2475 -> 1613;
2476 -> 2475;
2476 -> 1434;
2477 -> 2476;
2477 -> 1436;
2477 -> 1434;
2478 -> 1632;
2479 -> 2478;
2479 -> 1472;
2480 -> 2479;
2480 -> 1474;
2480 -> 1472;
2481 -> 1470;
2481 -> 1502;
2481 -> 1628;
2481 -> 2480;
2481 -> 1637;
2481 -> 1498;
2481 -> 1499;
2481 -> 2466;
2481 -> 1509;
2481 -> 1501;
2482 -> 1652;
2483 -> 2482;
2483 -> 1521;
2484 -> 2483;
2484 -> 1523;
2484 -> 1521;
2485 -> 1519;
2485 -> 1553;
2485 -> 1648;
2485 -> 2484;
2485 -> 1657;
2485 -> 1547;
2485 -> 1548;
2485 -> 2470;
2485 -> 1555;
2485 -> 1552;
2486 -> 1672;
2487 -> 2486;
2487 -> 1567;
2488 -> 2487;
2488 -> 1569;
2488 -> 1567;
2489 -> 1565;
2489 -> 1599;
2489 -> 1668;
2489 -> 2488;
2489 -> 1677;
2489 -> 1593;
2489 -> 1594;
2489 -> 2474;
2489 -> 1601;
2489 -> 1598;
2490 -> 1613;
2491 -> 2490;
2491 -> 1434;
2492 -> 2491;
2492 -> 1436;
2492 -> 1434;
2493 -> 1632;
2494 -> 2493;
2494 -> 1472;
2495 -> 2494;
2495 -> 1474;
2495 -> 1472;
2496 -> 1470;
2496 -> 1502;
2496 -> 1628;
2496 -> 2495;
2496 -> 1637;
2496 -> 1498;
2496 -> 1499;
2496 -> 2481;
2496 -> 1509;
2496 -> 1501;
2497 -> 1652;
2498 -> 2497;
2498 -> 1521;
2499 -> 2498;
2499 -> 1523;
2499 -> 1521;
2500 -> 1519;
2500 -> 1553;
2500 -> 1648;
2500 -> 2499;
2500 -> 1657;
2500 -> 1547;
2500 -> 1548;
2500 -> 2485;
2500 -> 1555;
2500 -> 1552;
2501 -> 1672;
2502 -> 2501;
2502 -> 1567;
2503 -> 2502;
2503 -> 1569;
2503 -> 1567;
2504 -> 1565;
2504 -> 1599;
2504 -> 1668;
2504 -> 2503;
2504 -> 1677;
2504 -> 1593;
2504 -> 1594;
2504 -> 2489;
2504 -> 1601;
2504 -> 1598;
2505 -> 1613;
2506 -> 2505;
2506 -> 1434;
2507 -> 2506;
2507 -> 1436;
2507 -> 1434;
2508 -> 1632;
2509 -> 2508;
2509 -> 1472;
2510 -> 2509;
2510 -> 1474;
2510 -> 1472;
2511 -> 1470;
2511 -> 1502;
2511 -> 1628;
2511 -> 2510;
2511 -> 1637;
2511 -> 1498;
2511 -> 1499;
2511 -> 2496;
2511 -> 1509;
2511 -> 1501;
2512 -> 1652;
2513 -> 2512;
2513 -> 1521;
2514 -> 2513;
2514 -> 1523;
2514 -> 1521;
2515 -> 1519;
2515 -> 1553;
2515 -> 1648;
2515 -> 2514;
2515 -> 1657;
2515 -> 1547;
2515 -> 1548;
2515 -> 2500;
2515 -> 1555;
2515 -> 1552;
2516 -> 1672;
2517 -> 2516;
2517 -> 1567;
2518 -> 2517;
2518 -> 1569;
2518 -> 1567;
2519 -> 1565;
2519 -> 1599;
2519 -> 1668;
2519 -> 2518;
2519 -> 1677;
2519 -> 1593;
2519 -> 1594;
2519 -> 2504;
2519 -> 1601;
2519 -> 1598;
2520 -> 1613;
2521 -> 2520;
2521 -> 1434;
2522 -> 2521;
2522 -> 1436;
2522 -> 1434;
2523 -> 1632;
2524 -> 2523;
2524 -> 1472;
2525 -> 2524;
2525 -> 1474;
2525 -> 1472;
2526 -> 1470;
2526 -> 1502;
2526 -> 1628;
2526 -> 2525;
2526 -> 1637;
2526 -> 1498;
2526 -> 1499;
2526 -> 2511;
2526 -> 1509;
2526 -> 1501;
2527 -> 1652;
2528 -> 2527;
2528 -> 1521;
2529 -> 2528;
2529 -> 1523;
2529 -> 1521;
2530 -> 1519;
2530 -> 1553;
2530 -> 1648;
2530 -> 2529;
2530 -> 1657;
2530 -> 1547;
2530 -> 1548;
2530 -> 2515;
2530 -> 1555;
2530 -> 1552;
2531 -> 1672;
2532 -> 2531;
2532 -> 1567;
2533 -> 2532;
2533 -> 1569;
2533 -> 1567;
2534 -> 1565;
2534 -> 1599;
2534 -> 1668;
2534 -> 2533;
2534 -> 1677;
2534 -> 1593;
2534 -> 1594;
2534 -> 2519;
2534 -> 1601;
2534 -> 1598;
2535 -> 1613;
2536 -> 2535;
2536 -> 1434;
2537 -> 2536;
2537 -> 1436;
2537 -> 1434;
2538 -> 1632;
2539 -> 2538;
2539 -> 1472;
2540 -> 2539;
2540 -> 1474;
2540 -> 1472;
2541 -> 1470;
2541 -> 1502;
2541 -> 1628;
2541 -> 2540;
2541 -> 1637;
2541 -> 1498;
2541 -> 1499;
2541 -> 2526;
2541 -> 1509;
2541 -> 1501;
2542 -> 1652;
2543 -> 2542;
2543 -> 1521;
2544 -> 2543;
2544 -> 1523;
2544 -> 1521;
2545 -> 1519;
2545 -> 1553;
2545 -> 1648;
2545 -> 2544;
2545 -> 1657;
2545 -> 1547;
2545 -> 1548;
2545 -> 2530;
2545 -> 1555;
2545 -> 1552;
2546 -> 1672;
2547 -> 2546;
2547 -> 1567;
2548 -> 2547;
2548 -> 1569;
2548 -> 1567;
2549 -> 1565;
2549 -> 1599;
2549 -> 1668;
2549 -> 2548;
2549 -> 1677;
2549 -> 1593;
2549 -> 1594;
2549 -> 2534;
2549 -> 1601;
2549 -> 1598;
2550 -> 1613;
2551 -> 2550;
2551 -> 1434;
2552 -> 2551;
2552 -> 1436;
2552 -> 1434;
2553 -> 1632;
2554 -> 2553;
2554 -> 1472;
2555 -> 2554;
2555 -> 1474;
2555 -> 1472;
2556 -> 1470;
2556 -> 1502;
2556 -> 1628;
2556 -> 2555;
2556 -> 1637;
2556 -> 1498;
2556 -> 1499;
2556 -> 2541;
2556 -> 1509;
2556 -> 1501;
2557 -> 1652;
2558 -> 2557;
2558 -> 1521;
2559 -> 2558;
2559 -> 1523;
2559 -> 1521;
2560 -> 1519;
2560 -> 1553;
2560 -> 1648;
2560 -> 2559;
2560 -> 1657;
2560 -> 1547;
2560 -> 1548;
2560 -> 2545;
2560 -> 1555;
2560 -> 1552;
2561 -> 1672;
2562 -> 2561;
2562 -> 1567;
2563 -> 2562;
2563 -> 1569;
2563 -> 1567;
2564 -> 1565;
2564 -> 1599;
2564 -> 1668;
2564 -> 2563;
2564 -> 1677;
2564 -> 1593;
2564 -> 1594;
2564 -> 2549;
2564 -> 1601;
2564 -> 1598;
2565 -> 1613;
2566 -> 2565;
2566 -> 1434;
2567 -> 2566;
2567 -> 1436;
2567 -> 1434;
2568 -> 1632;
2569 -> 2568;
2569 -> 1472;
2570 -> 2569;
2570 -> 1474;
2570 -> 1472;
2571 -> 1470;
2571 -> 1502;
2571 -> 1628;
2571 -> 2570;
2571 -> 1637;
2571 -> 1498;
2571 -> 1499;
2571 -> 2556;
2571 -> 1509;
2571 -> 1501;
2572 -> 1652;
2573 -> 2572;
2573 -> 1521;
2574 -> 2573;
2574 -> 1523;
2574 -> 1521;
2575 -> 1519;
2575 -> 1553;
2575 -> 1648;
2575 -> 2574;
2575 -> 1657;
2575 -> 1547;
2575 -> 1548;
2575 -> 2560;
2575 -> 1555;
2575 -> 1552;
2576 -> 1672;
2577 -> 2576;
2577 -> 1567;
2578 -> 2577;
2578 -> 1569;
2578 -> 1567;
2579 -> 1565;
2579 -> 1599;
2579 -> 1668;
2579 -> 2578;
2579 -> 1677;
2579 -> 1593;
2579 -> 1594;
2579 -> 2564;
2579 -> 1601;
2579 -> 1598;
2580 -> 1613;
2581 -> 2580;
2581 -> 1434;
2582 -> 2581;
2582 -> 1436;
2582 -> 1434;
2583 -> 1632;
2584 -> 2583;
2584 -> 1472;
2585 -> 2584;
2585 -> 1474;
2585 -> 1472;
2586 -> 1470;
2586 -> 1502;
2586 -> 1628;
2586 -> 2585;
2586 -> 1637;
2586 -> 1498;
2586 -> 1499;
2586 -> 2571;
2586 -> 1509;
2586 -> 1501;
2587 -> 1652;
2588 -> 2587;
2588 -> 1521;
2589 -> 2588;
2589 -> 1523;
2589 -> 1521;
2590 -> 1519;
2590 -> 1553;
2590 -> 1648;
2590 -> 2589;
2590 -> 1657;
2590 -> 1547;
2590 -> 1548;
2590 -> 2575;
2590 -> 1555;
2590 -> 1552;
2591 -> 1672;
2592 -> 2591;
2592 -> 1567;
2593 -> 2592;
2593 -> 1569;
2593 -> 1567;
2594 -> 1565;
2594 -> 1599;
2594 -> 1668;
2594 -> 2593;
2594 -> 1677;
2594 -> 1593;
2594 -> 1594;
2594 -> 2579;
2594 -> 1601;
2594 -> 1598;
2595 -> 1613;
2596 -> 2595;
2596 -> 1434;
2597 -> 2596;
2597 -> 1436;
2597 -> 1434;
2598 -> 1632;
2599 -> 2598;
2599 -> 1472;
2600 -> 2599;
2600 -> 1474;
2600 -> 1472;
2601 -> 1470;
2601 -> 1502;
2601 -> 1628;
2601 -> 2600;
2601 -> 1637;
2601 -> 1498;
2601 -> 1499;
2601 -> 2586;
2601 -> 1509;
2601 -> 1501;
2602 -> 1652;
2603 -> 2602;
2603 -> 1521;
2604 -> 2603;
2604 -> 1523;
2604 -> 1521;
2605 -> 1519;
2605 -> 1553;
2605 -> 1648;
2605 -> 2604;
2605 -> 1657;
2605 -> 1547;
2605 -> 1548;
2605 -> 2590;
2605 -> 1555;
2605 -> 1552;
2606 -> 1672;
2607 -> 2606;
2607 -> 1567;
2608 -> 2607;
2608 -> 1569;
2608 -> 1567;
2609 -> 1565;
2609 -> 1599;
2609 -> 1668;
2609 -> 2608;
2609 -> 1677;
2609 -> 1593;
2609 -> 1594;
2609 -> 2594;
2609 -> 1601;
2609 -> 1598;
2610 -> 1613;
2611 -> 2610;
2611 -> 1434;
2612 -> 2611;
2612 -> 1436;
2612 -> 1434;
2613 -> 1632;
2614 -> 2613;
2614 -> 1472;
2615 -> 2614;
2615 -> 1474;
2615 -> 1472;
2616 -> 1470;
2616 -> 1502;
2616 -> 1628;
2616 -> 2615;
2616 -> 1637;
2616 -> 1498;
2616 -> 1499;
2616 -> 2601;
2616 -> 1509;
2616 -> 1501;
2617 -> 1652;
2618 -> 2617;
2618 -> 1521;
2619 -> 2618;
2619 -> 1523;
2619 -> 1521;
2620 -> 1519;
2620 -> 1553;
2620 -> 1648;
2620 -> 2619;
2620 -> 1657;
2620 -> 1547;
2620 -> 1548;
2620 -> 2605;
2620 -> 1555;
2620 -> 1552;
2621 -> 1672;
2622 -> 2621;
2622 -> 1567;
2623 -> 2622;
2623 -> 1569;
2623 -> 1567;
2624 -> 1565;
2624 -> 1599;
2624 -> 1668;
2624 -> 2623;
2624 -> 1677;
2624 -> 1593;
2624 -> 1594;
2624 -> 2609;
2624 -> 1601;
2624 -> 1598;
2625 -> 1613;
2626 -> 2625;
2626 -> 1434;
2627 -> 2626;
2627 -> 1436;
2627 -> 1434;
2628 -> 1632;
2629 -> 2628;
2629 -> 1472;
2630 -> 2629;
2630 -> 1474;
2630 -> 1472;
2631 -> 1470;
2631 -> 1502;
2631 -> 1628;
2631 -> 2630;
2631 -> 1637;
2631 -> 1498;
2631 -> 1499;
2631 -> 2616;
2631 -> 1509;
2631 -> 1501;
2632 -> 1652;
2633 -> 2632;
2633 -> 1521;
2634 -> 2633;
2634 -> 1523;
2634 -> 1521;
2635 -> 1519;
2635 -> 1553;
2635 -> 1648;
2635 -> 2634;
2635 -> 1657;
2635 -> 1547;
2635 -> 1548;
2635 -> 2620;
2635 -> 1555;
2635 -> 1552;
2636 -> 1672;
2637 -> 2636;
2637 -> 1567;
2638 -> 2637;
2638 -> 1569;
2638 -> 1567;
2639 -> 1565;
2639 -> 1599;
2639 -> 1668;
2639 -> 2638;
2639 -> 1677;
2639 -> 1593;
2639 -> 1594;
2639 -> 2624;
2639 -> 1601;
2639 -> 1598;
2640 -> 1613;
2641 -> 2640;
2641 -> 1434;
2642 -> 2641;
2642 -> 1436;
2642 -> 1434;
2643 -> 1632;
2644 -> 2643;
2644 -> 1472;
2645 -> 2644;
2645 -> 1474;
2645 -> 1472;
2646 -> 1470;
2646 -> 1502;
2646 -> 1628;
2646 -> 2645;
2646 -> 1637;
2646 -> 1498;
2646 -> 1499;
2646 -> 2631;
2646 -> 1509;
2646 -> 1501;
2647 -> 1652;
2648 -> 2647;
2648 -> 1521;
2649 -> 2648;
2649 -> 1523;
2649 -> 1521;
2650 -> 1519;
2650 -> 1553;
2650 -> 1648;
2650 -> 2649;
2650 -> 1657;
2650 -> 1547;
2650 -> 1548;
2650 -> 2635;
2650 -> 1555;
2650 -> 1552;
2651 -> 1672;
2652 -> 2651;
2652 -> 1567;
2653 -> 2652;
2653 -> 1569;
2653 -> 1567;
2654 -> 1565;
2654 -> 1599;
2654 -> 1668;
2654 -> 2653;
2654 -> 1677;
2654 -> 1593;
2654 -> 1594;
2654 -> 2639;
2654 -> 1601;
2654 -> 1598;
2655 -> 1613;
2656 -> 2655;
2656 -> 1434;
2657 -> 2656;
2657 -> 1436;
2657 -> 1434;
2658 -> 1632;
2659 -> 2658;
2659 -> 1472;
2660 -> 2659;
2660 -> 1474;
2660 -> 1472;
2661 -> 1470;
2661 -> 1502;
2661 -> 1628;
2661 -> 2660;
2661 -> 1637;
2661 -> 1498;
2661 -> 1499;
2661 -> 2646;
2661 -> 1509;
2661 -> 1501;
2662 -> 1652;
2663 -> 2662;
2663 -> 1521;
2664 -> 2663;
2664 -> 1523;
2664 -> 1521;
2665 -> 1519;
2665 -> 1553;
2665 -> 1648;
2665 -> 2664;
2665 -> 1657;
2665 -> 1547;
2665 -> 1548;
2665 -> 2650;
2665 -> 1555;
2665 -> 1552;
2666 -> 1672;
2667 -> 2666;
2667 -> 1567;
2668 -> 2667;
2668 -> 1569;
2668 -> 1567;
2669 -> 1565;
2669 -> 1599;
2669 -> 1668;
2669 -> 2668;
2669 -> 1677;
2669 -> 1593;
2669 -> 1594;
2669 -> 2654;
2669 -> 1601;
2669 -> 1598;
2670 -> 1613;
2671 -> 2670;
2671 -> 1434;
2672 -> 2671;
2672 -> 1436;
2672 -> 1434;
2673 -> 1632;
2674 -> 2673;
2674 -> 1472;
2675 -> 2674;
2675 -> 1474;
2675 -> 1472;
2676 -> 1470;
2676 -> 1502;
2676 -> 1628;
2676 -> 2675;
2676 -> 1637;
2676 -> 1498;
2676 -> 1499;
2676 -> 2661;
2676 -> 1509;
2676 -> 1501;
2677 -> 1652;
2678 -> 2677;
2678 -> 1521;
2679 -> 2678;
2679 -> 1523;
2679 -> 1521;
2680 -> 1519;
2680 -> 1553;
2680 -> 1648;
2680 -> 2679;
2680 -> 1657;
2680 -> 1547;
2680 -> 1548;
2680 -> 2665;
2680 -> 1555;
2680 -> 1552;
2681 -> 1672;
2682 -> 2681;
2682 -> 1567;
2683 -> 2682;
2683 -> 1569;
2683 -> 1567;
2684 -> 1565;
2684 -> 1599;
2684 -> 1668;
2684 -> 2683;
2684 -> 1677;
2684 -> 1593;
2684 -> 1594;
2684 -> 2669;
2684 -> 1601;
2684 -> 1598;
2685 -> 1613;
2686 -> 2685;
2686 -> 1434;
2687 -> 2686;
2687 -> 1436;
2687 -> 1434;
2688 -> 1632;
2689 -> 2688;
2689 -> 1472;
2690 -> 2689;
2690 -> 1474;
2690 -> 1472;
2691 -> 1470;
2691 -> 1502;
2691 -> 1628;
2691 -> 2690;
2691 -> 1637;
2691 -> 1498;
2691 -> 1499;
2691 -> 2676;
2691 -> 1509;
2691 -> 1501;
2692 -> 1652;
2693 -> 2692;
2693 -> 1521;
2694 -> 2693;
2694 -> 1523;
2694 -> 1521;
2695 -> 1519;
2695 -> 1553;
2695 -> 1648;
2695 -> 2694;
2695 -> 1657;
2695 -> 1547;
2695 -> 1548;
2695 -> 2680;
2695 -> 1555;
2695 -> 1552;
2696 -> 1672;
2697 -> 2696;
2697 -> 1567;
2698 -> 2697;
2698 -> 1569;
2698 -> 1567;
2699 -> 1565;
2699 -> 1599;
2699 -> 1668;
2699 -> 2698;
2699 -> 1677;
2699 -> 1593;
2699 -> 1594;
2699 -> 2684;
2699 -> 1601;
2699 -> 1598;
2700 -> 1613;
2701 -> 2700;
2701 -> 1434;
2702 -> 2701;
2702 -> 1436;
2702 -> 1434;
2703 -> 1632;
2704 -> 2703;
2704 -> 1472;
2705 -> 2704;
2705 -> 1474;
2705 -> 1472;
2706 -> 1470;
2706 -> 1502;
2706 -> 1628;
2706 -> 2705;
2706 -> 1637;
2706 -> 1498;
2706 -> 1499;
2706 -> 2691;
2706 -> 1509;
2706 -> 1501;
2707 -> 1652;
2708 -> 2707;
2708 -> 1521;
2709 -> 2708;
2709 -> 1523;
2709 -> 1521;
2710 -> 1519;
2710 -> 1553;
2710 -> 1648;
2710 -> 2709;
2710 -> 1657;
2710 -> 1547;
2710 -> 1548;
2710 -> 2695;
2710 -> 1555;
2710 -> 1552;
2711 -> 1672;
2712 -> 2711;
2712 -> 1567;
2713 -> 2712;
2713 -> 1569;
2713 -> 1567;
2714 -> 1565;
2714 -> 1599;
2714 -> 1668;
2714 -> 2713;
2714 -> 1677;
2714 -> 1593;
2714 -> 1594;
2714 -> 2699;
2714 -> 1601;
2714 -> 1598;
2715 -> 1613;
2716 -> 2715;
2716 -> 1434;
2717 -> 2716;
2717 -> 1436;
2717 -> 1434;
2718 -> 1632;
2719 -> 2718;
2719 -> 1472;
2720 -> 2719;
2720 -> 1474;
2720 -> 1472;
2721 -> 1470;
2721 -> 1502;
2721 -> 1628;
2721 -> 2720;
2721 -> 1637;
2721 -> 1498;
2721 -> 1499;
2721 -> 2706;
2721 -> 1509;
2721 -> 1501;
2722 -> 1652;
2723 -> 2722;
2723 -> 1521;
2724 -> 2723;
2724 -> 1523;
2724 -> 1521;
2725 -> 1519;
2725 -> 1553;
2725 -> 1648;
2725 -> 2724;
2725 -> 1657;
2725 -> 1547;
2725 -> 1548;
2725 -> 2710;
2725 -> 1555;
2725 -> 1552;
2726 -> 1672;
2727 -> 2726;
2727 -> 1567;
2728 -> 2727;
2728 -> 1569;
2728 -> 1567;
2729 -> 1565;
2729 -> 1599;
2729 -> 1668;
2729 -> 2728;
2729 -> 1677;
2729 -> 1593;
2729 -> 1594;
2729 -> 2714;
2729 -> 1601;
2729 -> 1598;
2730 -> 1613;
2731 -> 2730;
2731 -> 1434;
2732 -> 2731;
2732 -> 1436;
2732 -> 1434;
2733 -> 1632;
2734 -> 2733;
2734 -> 1472;
2735 -> 2734;
2735 -> 1474;
2735 -> 1472;
2736 -> 1470;
2736 -> 1502;
2736 -> 1628;
2736 -> 2735;
2736 -> 1637;
2736 -> 1498;
2736 -> 1499;
2736 -> 2721;
2736 -> 1509;
2736 -> 1501;
2737 -> 1652;
2738 -> 2737;
2738 -> 1521;
2739 -> 2738;
2739 -> 1523;
2739 -> 1521;
2740 -> 1519;
2740 -> 1553;
2740 -> 1648;
2740 -> 2739;
2740 -> 1657;
2740 -> 1547;
2740 -> 1548;
2740 -> 2725;
2740 -> 1555;
2740 -> 1552;
2741 -> 1672;
2742 -> 2741;
2742 -> 1567;
2743 -> 2742;
2743 -> 1569;
2743 -> 1567;
2744 -> 1565;
2744 -> 1599;
2744 -> 1668;
2744 -> 2743;
2744 -> 1677;
2744 -> 1593;
2744 -> 1594;
2744 -> 2729;
2744 -> 1601;
2744 -> 1598;
2745 -> 1613;
2746 -> 2745;
2746 -> 1434;
2747 -> 2746;
2747 -> 1436;
2747 -> 1434;
2748 -> 1632;
2749 -> 2748;
2749 -> 1472;
2750 -> 2749;
2750 -> 1474;
2750 -> 1472;
2751 -> 1470;
2751 -> 1502;
2751 -> 1628;
2751 -> 2750;
2751 -> 1637;
2751 -> 1498;
2751 -> 1499;
2751 -> 2736;
2751 -> 1509;
2751 -> 1501;
2752 -> 1652;
2753 -> 2752;
2753 -> 1521;
2754 -> 2753;
2754 -> 1523;
2754 -> 1521;
2755 -> 1519;
2755 -> 1553;
2755 -> 1648;
2755 -> 2754;
2755 -> 1657;
2755 -> 1547;
2755 -> 1548;
2755 -> 2740;
2755 -> 1555;
2755 -> 1552;
2756 -> 1672;
2757 -> 2756;
2757 -> 1567;
2758 -> 2757;
2758 -> 1569;
2758 -> 1567;
2759 -> 1565;
2759 -> 1599;
2759 -> 1668;
2759 -> 2758;
2759 -> 1677;
2759 -> 1593;
2759 -> 1594;
2759 -> 2744;
2759 -> 1601;
2759 -> 1598;
2760 -> 1613;
2761 -> 2760;
2761 -> 1434;
2762 -> 2761;
2762 -> 1436;
2762 -> 1434;
2763 -> 1632;
2764 -> 2763;
2764 -> 1472;
2765 -> 2764;
2765 -> 1474;
2765 -> 1472;
2766 -> 1470;
2766 -> 1502;
2766 -> 1628;
2766 -> 2765;
2766 -> 1637;
2766 -> 1498;
2766 -> 1499;
2766 -> 2751;
2766 -> 1509;
2766 -> 1501;
2767 -> 1652;
2768 -> 2767;
2768 -> 1521;
2769 -> 2768;
2769 -> 1523;
2769 -> 1521;
2770 -> 1519;
2770 -> 1553;
2770 -> 1648;
2770 -> 2769;
2770 -> 1657;
2770 -> 1547;
2770 -> 1548;
2770 -> 2755;
2770 -> 1555;
2770 -> 1552;
2771 -> 1672;
2772 -> 2771;
2772 -> 1567;
2773 -> 2772;
2773 -> 1569;
2773 -> 1567;
2774 -> 1565;
2774 -> 1599;
2774 -> 1668;
2774 -> 2773;
2774 -> 1677;
2774 -> 1593;
2774 -> 1594;
2774 -> 2759;
2774 -> 1601;
2774 -> 1598;
2775 -> 1613;
2776 -> 2775;
2776 -> 1434;
2777 -> 2776;
2777 -> 1436;
2777 -> 1434;
2778 -> 1632;
2779 -> 2778;
2779 -> 1472;
2780 -> 2779;
2780 -> 1474;
2780 -> 1472;
2781 -> 1470;
2781 -> 1502;
2781 -> 1628;
2781 -> 2780;
2781 -> 1637;
2781 -> 1498;
2781 -> 1499;
2781 -> 2766;
2781 -> 1509;
2781 -> 1501;
2782 -> 1652;
2783 -> 2782;
2783 -> 1521;
2784 -> 2783;
2784 -> 1523;
2784 -> 1521;
2785 -> 1519;
2785 -> 1553;
2785 -> 1648;
2785 -> 2784;
2785 -> 1657;
2785 -> 1547;
2785 -> 1548;
2785 -> 2770;
2785 -> 1555;
2785 -> 1552;
2786 -> 1672;
2787 -> 2786;
2787 -> 1567;
2788 -> 2787;
2788 -> 1569;
2788 -> 1567;
2789 -> 1565;
2789 -> 1599;
2789 -> 1668;
2789 -> 2788;
2789 -> 1677;
2789 -> 1593;
2789 -> 1594;
2789 -> 2774;
2789 -> 1601;
2789 -> 1598;
2790 -> 1613;
2791 -> 2790;
2791 -> 1434;
2792 -> 2791;
2792 -> 1436;
2792 -> 1434;
2793 -> 1632;
2794 -> 2793;
2794 -> 1472;
2795 -> 2794;
2795 -> 1474;
2795 -> 1472;
2796 -> 1470;
2796 -> 1502;
2796 -> 1628;
2796 -> 2795;
2796 -> 1637;
2796 -> 1498;
2796 -> 1499;
2796 -> 2781;
2796 -> 1509;
2796 -> 1501;
2797 -> 1652;
2798 -> 2797;
2798 -> 1521;
2799 -> 2798;
2799 -> 1523;
2799 -> 1521;
2800 -> 1519;
2800 -> 1553;
2800 -> 1648;
2800 -> 2799;
2800 -> 1657;
2800 -> 1547;
2800 -> 1548;
2800 -> 2785;
2800 -> 1555;
2800 -> 1552;
2801 -> 1672;
2802 -> 2801;
2802 -> 1567;
2803 -> 2802;
2803 -> 1569;
2803 -> 1567;
2804 -> 1565;
2804 -> 1599;
2804 -> 1668;
2804 -> 2803;
2804 -> 1677;
2804 -> 1593;
2804 -> 1594;
2804 -> 2789;
2804 -> 1601;
2804 -> 1598;
2805 -> 1613;
2806 -> 2805;
2806 -> 1434;
2807 -> 2806;
2807 -> 1436;
2807 -> 1434;
2808 -> 1632;
2809 -> 2808;
2809 -> 1472;
2810 -> 2809;
2810 -> 1474;
2810 -> 1472;
2811 -> 1470;
2811 -> 1502;
2811 -> 1628;
2811 -> 2810;
2811 -> 1637;
2811 -> 1498;
2811 -> 1499;
2811 -> 2796;
2811 -> 1509;
2811 -> 1501;
2812 -> 1652;
2813 -> 2812;
2813 -> 1521;
2814 -> 2813;
2814 -> 1523;
2814 -> 1521;
2815 -> 1519;
2815 -> 1553;
2815 -> 1648;
2815 -> 2814;
2815 -> 1657;
2815 -> 1547;
2815 -> 1548;
2815 -> 2800;
2815 -> 1555;
2815 -> 1552;
2816 -> 1672;
2817 -> 2816;
2817 -> 1567;
2818 -> 2817;
2818 -> 1569;
2818 -> 1567;
2819 -> 1565;
2819 -> 1599;
2819 -> 1668;
2819 -> 2818;
2819 -> 1677;
2819 -> 1593;
2819 -> 1594;
2819 -> 2804;
2819 -> 1601;
2819 -> 1598;
2820 -> 1613;
2821 -> 2820;
2821 -> 1434;
2822 -> 2821;
2822 -> 1436;
2822 -> 1434;
2823 -> 1632;
2824 -> 2823;
2824 -> 1472;
2825 -> 2824;
2825 -> 1474;
2825 -> 1472;
2826 -> 1470;
2826 -> 1502;
2826 -> 1628;
2826 -> 2825;
2826 -> 1637;
2826 -> 1498;
2826 -> 1499;
2826 -> 2811;
2826 -> 1509;
2826 -> 1501;
2827 -> 1652;
2828 -> 2827;
2828 -> 1521;
2829 -> 2828;
2829 -> 1523;
2829 -> 1521;
2830 -> 1519;
2830 -> 1553;
2830 -> 1648;
2830 -> 2829;
2830 -> 1657;
2830 -> 1547;
2830 -> 1548;
2830 -> 2815;
2830 -> 1555;
2830 -> 1552;
2831 -> 1672;
2832 -> 2831;
2832 -> 1567;
2833 -> 2832;
2833 -> 1569;
2833 -> 1567;
2834 -> 1565;
2834 -> 1599;
2834 -> 1668;
2834 -> 2833;
2834 -> 1677;
2834 -> 1593;
2834 -> 1594;
2834 -> 2819;
2834 -> 1601;
2834 -> 1598;
2835 -> 1613;
2836 -> 2835;
2836 -> 1434;
2837 -> 2836;
2837 -> 1436;
2837 -> 1434;
2838 -> 1632;
2839 -> 2838;
2839 -> 1472;
2840 -> 2839;
2840 -> 1474;
2840 -> 1472;
2841 -> 1470;
2841 -> 1502;
2841 -> 1628;
2841 -> 2840;
2841 -> 1637;
2841 -> 1498;
2841 -> 1499;
2841 -> 2826;
2841 -> 1509;
2841 -> 1501;
2842 -> 1652;
2843 -> 2842;
2843 -> 1521;
2844 -> 2843;
2844 -> 1523;
2844 -> 1521;
2845 -> 1519;
2845 -> 1553;
2845 -> 1648;
2845 -> 2844;
2845 -> 1657;
2845 -> 1547;
2845 -> 1548;
2845 -> 2830;
2845 -> 1555;
2845 -> 1552;
2846 -> 1672;
2847 -> 2846;
2847 -> 1567;
2848 -> 2847;
2848 -> 1569;
2848 -> 1567;
2849 -> 1565;
2849 -> 1599;
2849 -> 1668;
2849 -> 2848;
2849 -> 1677;
2849 -> 1593;
2849 -> 1594;
2849 -> 2834;
2849 -> 1601;
2849 -> 1598;
2850 -> 1613;
2851 -> 2850;
2851 -> 1434;
2852 -> 2851;
2852 -> 1436;
2852 -> 1434;
2853 -> 1632;
2854 -> 2853;
2854 -> 1472;
2855 -> 2854;
2855 -> 1474;
2855 -> 1472;
2856 -> 1470;
2856 -> 1502;
2856 -> 1628;
2856 -> 2855;
2856 -> 1637;
2856 -> 1498;
2856 -> 1499;
2856 -> 2841;
2856 -> 1509;
2856 -> 1501;
2857 -> 1652;
2858 -> 2857;
2858 -> 1521;
2859 -> 2858;
2859 -> 1523;
2859 -> 1521;
2860 -> 1519;
2860 -> 1553;
2860 -> 1648;
2860 -> 2859;
2860 -> 1657;
2860 -> 1547;
2860 -> 1548;
2860 -> 2845;
2860 -> 1555;
2860 -> 1552;
2861 -> 1672;
2862 -> 2861;
2862 -> 1567;
2863 -> 2862;
2863 -> 1569;
2863 -> 1567;
2864 -> 1565;
2864 -> 1599;
2864 -> 1668;
2864 -> 2863;
2864 -> 1677;
2864 -> 1593;
2864 -> 1594;
2864 -> 2849;
2864 -> 1601;
2864 -> 1598;
2865 -> 1613;
2866 -> 2865;
2866 -> 1434;
2867 -> 2866;
2867 -> 1436;
2867 -> 1434;
2868 -> 1632;
2869 -> 2868;
2869 -> 1472;
2870 -> 2869;
2870 -> 1474;
2870 -> 1472;
2871 -> 1470;
2871 -> 1502;
2871 -> 1628;
2871 -> 2870;
2871 -> 1637;
2871 -> 1498;
2871 -> 1499;
2871 -> 2856;
2871 -> 1509;
2871 -> 1501;
2872 -> 1652;
2873 -> 2872;
2873 -> 1521;
2874 -> 2873;
2874 -> 1523;
2874 -> 1521;
2875 -> 1519;
2875 -> 1553;
2875 -> 1648;
2875 -> 2874;
2875 -> 1657;
2875 -> 1547;
2875 -> 1548;
2875 -> 2860;
2875 -> 1555;
2875 -> 1552;
2876 -> 1672;
2877 -> 2876;
2877 -> 1567;
2878 -> 2877;
2878 -> 1569;
2878 -> 1567;
2879 -> 1565;
2879 -> 1599;
2879 -> 1668;
2879 -> 2878;
2879 -> 1677;
2879 -> 1593;
2879 -> 1594;
2879 -> 2864;
2879 -> 1601;
2879 -> 1598;
2880 -> 1613;
2881 -> 2880;
2881 -> 1434;
2882 -> 2881;
2882 -> 1436;
2882 -> 1434;
2883 -> 1632;
2884 -> 2883;
2884 -> 1472;
2885 -> 2884;
2885 -> 1474;
2885 -> 1472;
2886 -> 1470;
2886 -> 1502;
2886 -> 1628;
2886 -> 2885;
2886 -> 1637;
2886 -> 1498;
2886 -> 1499;
2886 -> 2871;
2886 -> 1509;
2886 -> 1501;
2887 -> 1652;
2888 -> 2887;
2888 -> 1521;
2889 -> 2888;
2889 -> 1523;
2889 -> 1521;
2890 -> 1519;
2890 -> 1553;
2890 -> 1648;
2890 -> 2889;
2890 -> 1657;
2890 -> 1547;
2890 -> 1548;
2890 -> 2875;
2890 -> 1555;
2890 -> 1552;
2891 -> 1672;
2892 -> 2891;
2892 -> 1567;
2893 -> 2892;
2893 -> 1569;
2893 -> 1567;
2894 -> 1565;
2894 -> 1599;
2894 -> 1668;
2894 -> 2893;
2894 -> 1677;
2894 -> 1593;
2894 -> 1594;
2894 -> 2879;
2894 -> 1601;
2894 -> 1598;
2895 -> 1613;
2896 -> 2895;
2896 -> 1434;
2897 -> 2896;
2897 -> 1436;
2897 -> 1434;
2898 -> 1632;
2899 -> 2898;
2899 -> 1472;
2900 -> 2899;
2900 -> 1474;
2900 -> 1472;
2901 -> 1470;
2901 -> 1502;
2901 -> 1628;
2901 -> 2900;
2901 -> 1637;
2901 -> 1498;
2901 -> 1499;
2901 -> 2886;
2901 -> 1509;
2901 -> 1501;
2902 -> 1652;
2903 -> 2902;
2903 -> 1521;
2904 -> 2903;
2904 -> 1523;
2904 -> 1521;
2905 -> 1519;
2905 -> 1553;
2905 -> 1648;
2905 -> 2904;
2905 -> 1657;
2905 -> 1547;
2905 -> 1548;
2905 -> 2890;
2905 -> 1555;
2905 -> 1552;
2906 -> 1672;
2907 -> 2906;
2907 -> 1567;
2908 -> 2907;
2908 -> 1569;
2908 -> 1567;
2909 -> 1565;
2909 -> 1599;
2909 -> 1668;
2909 -> 2908;
2909 -> 1677;
2909 -> 1593;
2909 -> 1594;
2909 -> 2894;
2909 -> 1601;
2909 -> 1598;
2910 -> 1613;
2911 -> 2910;
2911 -> 1434;
2912 -> 2911;
2912 -> 1436;
2912 -> 1434;
2913 -> 1632;
2914 -> 2913;
2914 -> 1472;
2915 -> 2914;
2915 -> 1474;
2915 -> 1472;
2916 -> 1470;
2916 -> 1502;
2916 -> 1628;
2916 -> 2915;
2916 -> 1637;
2916 -> 1498;
2916 -> 1499;
2916 -> 2901;
2916 -> 1509;
2916 -> 1501;
2917 -> 1652;
2918 -> 2917;
2918 -> 1521;
2919 -> 2918;
2919 -> 1523;
2919 -> 1521;
2920 -> 1519;
2920 -> 1553;
2920 -> 1648;
2920 -> 2919;
2920 -> 1657;
2920 -> 1547;
2920 -> 1548;
2920 -> 2905;
2920 -> 1555;
2920 -> 1552;
2921 -> 1672;
2922 -> 2921;
2922 -> 1567;
2923 -> 2922;
2923 -> 1569;
2923 -> 1567;
2924 -> 1565;
2924 -> 1599;
2924 -> 1668;
2924 -> 2923;
2924 -> 1677;
2924 -> 1593;
2924 -> 1594;
2924 -> 2909;
2924 -> 1601;
2924 -> 1598;
2925 -> 1613;
2926 -> 2925;
2926 -> 1434;
2927 -> 2926;
2927 -> 1436;
2927 -> 1434;
2928 -> 1632;
2929 -> 2928;
2929 -> 1472;
2930 -> 2929;
2930 -> 1474;
2930 -> 1472;
2931 -> 1470;
2931 -> 1502;
2931 -> 1628;
2931 -> 2930;
2931 -> 1637;
2931 -> 1498;
2931 -> 1499;
2931 -> 2916;
2931 -> 1509;
2931 -> 1501;
2932 -> 1652;
2933 -> 2932;
2933 -> 1521;
2934 -> 2933;
2934 -> 1523;
2934 -> 1521;
2935 -> 1519;
2935 -> 1553;
2935 -> 1648;
2935 -> 2934;
2935 -> 1657;
2935 -> 1547;
2935 -> 1548;
2935 -> 2920;
2935 -> 1555;
2935 -> 1552;
2936 -> 1672;
2937 -> 2936;
2937 -> 1567;
2938 -> 2937;
2938 -> 1569;
2938 -> 1567;
2939 -> 1565;
2939 -> 1599;
2939 -> 1668;
2939 -> 2938;
2939 -> 1677;
2939 -> 1593;
2939 -> 1594;
2939 -> 2924;
2939 -> 1601;
2939 -> 1598;
2940 -> 1613;
2941 -> 2940;
2941 -> 1434;
2942 -> 2941;
2942 -> 1436;
2942 -> 1434;
2943 -> 1632;
2944 -> 2943;
2944 -> 1472;
2945 -> 2944;
2945 -> 1474;
2945 -> 1472;
2946 -> 1470;
2946 -> 1502;
2946 -> 1628;
2946 -> 2945;
2946 -> 1637;
2946 -> 1498;
2946 -> 1499;
2946 -> 2931;
2946 -> 1509;
2946 -> 1501;
2947 -> 1652;
2948 -> 2947;
2948 -> 1521;
2949 -> 2948;
2949 -> 1523;
2949 -> 1521;
2950 -> 1519;
2950 -> 1553;
2950 -> 1648;
2950 -> 2949;
2950 -> 1657;
2950 -> 1547;
2950 -> 1548;
2950 -> 2935;
2950 -> 1555;
2950 -> 1552;
2951 -> 1672;
2952 -> 2951;
2952 -> 1567;
2953 -> 2952;
2953 -> 1569;
2953 -> 1567;
2954 -> 1565;
2954 -> 1599;
2954 -> 1668;
2954 -> 2953;
2954 -> 1677;
2954 -> 1593;
2954 -> 1594;
2954 -> 2939;
2954 -> 1601;
2954 -> 1598;
2955 -> 1613;
2956 -> 2955;
2956 -> 1434;
2957 -> 2956;
2957 -> 1436;
2957 -> 1434;
2958 -> 1632;
2959 -> 2958;
2959 -> 1472;
2960 -> 2959;
2960 -> 1474;
2960 -> 1472;
2961 -> 1470;
2961 -> 1502;
2961 -> 1628;
2961 -> 2960;
2961 -> 1637;
2961 -> 1498;
2961 -> 1499;
2961 -> 2946;
2961 -> 1509;
2961 -> 1501;
2962 -> 1652;
2963 -> 2962;
2963 -> 1521;
2964 -> 2963;
2964 -> 1523;
2964 -> 1521;
2965 -> 1519;
2965 -> 1553;
2965 -> 1648;
2965 -> 2964;
2965 -> 1657;
2965 -> 1547;
2965 -> 1548;
2965 -> 2950;
2965 -> 1555;
2965 -> 1552;
2966 -> 1672;
2967 -> 2966;
2967 -> 1567;
2968 -> 2967;
2968 -> 1569;
2968 -> 1567;
2969 -> 1565;
2969 -> 1599;
2969 -> 1668;
2969 -> 2968;
2969 -> 1677;
2969 -> 1593;
2969 -> 1594;
2969 -> 2954;
2969 -> 1601;
2969 -> 1598;
2970 -> 1613;
2971 -> 2970;
2971 -> 1434;
2972 -> 2971;
2972 -> 1436;
2972 -> 1434;
2973 -> 1632;
2974 -> 2973;
2974 -> 1472;
2975 -> 2974;
2975 -> 1474;
2975 -> 1472;
2976 -> 1470;
2976 -> 1502;
2976 -> 1628;
2976 -> 2975;
2976 -> 1637;
2976 -> 1498;
2976 -> 1499;
2976 -> 2961;
2976 -> 1509;
2976 -> 1501;
2977 -> 1652;
2978 -> 2977;
2978 -> 1521;
2979 -> 2978;
2979 -> 1523;
2979 -> 1521;
2980 -> 1519;
2980 -> 1553;
2980 -> 1648;
2980 -> 2979;
2980 -> 1657;
2980 -> 1547;
2980 -> 1548;
2980 -> 2965;
2980 -> 1555;
2980 -> 1552;
2981 -> 1672;
2982 -> 2981;
2982 -> 1567;
2983 -> 2982;
2983 -> 1569;
2983 -> 1567;
2984 -> 1565;
2984 -> 1599;
2984 -> 1668;
2984 -> 2983;
2984 -> 1677;
2984 -> 1593;
2984 -> 1594;
2984 -> 2969;
2984 -> 1601;
2984 -> 1598;
2985 -> 1613;
2986 -> 2985;
2986 -> 1434;
2987 -> 2986;
2987 -> 1436;
2987 -> 1434;
2988 -> 1632;
2989 -> 2988;
2989 -> 1472;
2990 -> 2989;
2990 -> 1474;
2990 -> 1472;
2991 -> 1470;
2991 -> 1502;
2991 -> 1628;
2991 -> 2990;
2991 -> 1637;
2991 -> 1498;
2991 -> 1499;
2991 -> 2976;
2991 -> 1509;
2991 -> 1501;
2992 -> 1652;
2993 -> 2992;
2993 -> 1521;
2994 -> 2993;
2994 -> 1523;
2994 -> 1521;
2995 -> 1519;
2995 -> 1553;
2995 -> 1648;
2995 -> 2994;
2995 -> 1657;
2995 -> 1547;
2995 -> 1548;
2995 -> 2980;
2995 -> 1555;
2995 -> 1552;
2996 -> 1672;
2997 -> 2996;
2997 -> 1567;
2998 -> 2997;
2998 -> 1569;
2998 -> 1567;
2999 -> 1565;
2999 -> 1599;
2999 -> 1668;
2999 -> 2998;
2999 -> 1677;
2999 -> 1593;
2999 -> 1594;
2999 -> 2984;
2999 -> 1601;
2999 -> 1598;
3000 -> 1613;
3001 -> 3000;
3001 -> 1434;
3002 -> 3001;
3002 -> 1436;
3002 -> 1434;
3003 -> 1632;
3004 -> 3003;
3004 -> 1472;
3005 -> 3004;
3005 -> 1474;
3005 -> 1472;
3006 -> 1470;
3006 -> 1502;
3006 -> 1628;
3006 -> 3005;
3006 -> 1637;
3006 -> 1498;
3006 -> 1499;
3006 -> 2991;
3006 -> 1509;
3006 -> 1501;
3007 -> 1652;
3008 -> 3007;
3008 -> 1521;
3009 -> 3008;
3009 -> 1523;
3009 -> 1521;
3010 -> 1519;
3010 -> 1553;
3010 -> 1648;
3010 -> 3009;
3010 -> 1657;
3010 -> 1547;
3010 -> 1548;
3010 -> 2995;
3010 -> 1555;
3010 -> 1552;
3011 -> 1672;
3012 -> 3011;
3012 -> 1567;
3013 -> 3012;
3013 -> 1569;
3013 -> 1567;
3014 -> 1565;
3014 -> 1599;
3014 -> 1668;
3014 -> 3013;
3014 -> 1677;
3014 -> 1593;
3014 -> 1594;
3014 -> 2999;
3014 -> 1601;
3014 -> 1598;
3015 -> 1613;
3016 -> 3015;
3016 -> 1434;
3017 -> 3016;
3017 -> 1436;
3017 -> 1434;
3018 -> 1632;
3019 -> 3018;
3019 -> 1472;
3020 -> 3019;
3020 -> 1474;
3020 -> 1472;
3021 -> 1470;
3021 -> 1502;
3021 -> 1628;
3021 -> 3020;
3021 -> 1637;
3021 -> 1498;
3021 -> 1499;
3021 -> 3006;
3021 -> 1509;
3021 -> 1501;
3022 -> 1652;
3023 -> 3022;
3023 -> 1521;
3024 -> 3023;
3024 -> 1523;
3024 -> 1521;
3025 -> 1519;
3025 -> 1553;
3025 -> 1648;
3025 -> 3024;
3025 -> 1657;
3025 -> 1547;
3025 -> 1548;
3025 -> 3010;
3025 -> 1555;
3025 -> 1552;
3026 -> 1672;
3027 -> 3026;
3027 -> 1567;
3028 -> 3027;
3028 -> 1569;
3028 -> 1567;
3029 -> 1565;
3029 -> 1599;
3029 -> 1668;
3029 -> 3028;
3029 -> 1677;
3029 -> 1593;
3029 -> 1594;
3029 -> 3014;
3029 -> 1601;
3029 -> 1598;
3030 -> 1613;
3031 -> 3030;
3031 -> 1434;
3032 -> 3031;
3032 -> 1436;
3032 -> 1434;
3033 -> 1632;
3034 -> 3033;
3034 -> 1472;
3035 -> 3034;
3035 -> 1474;
3035 -> 1472;
3036 -> 1470;
3036 -> 1502;
3036 -> 1628;
3036 -> 3035;
3036 -> 1637;
3036 -> 1498;
3036 -> 1499;
3036 -> 3021;
3036 -> 1509;
3036 -> 1501;
3037 -> 1652;
3038 -> 3037;
3038 -> 1521;
3039 -> 3038;
3039 -> 1523;
3039 -> 1521;
3040 -> 1519;
3040 -> 1553;
3040 -> 1648;
3040 -> 3039;
3040 -> 1657;
3040 -> 1547;
3040 -> 1548;
3040 -> 3025;
3040 -> 1555;
3040 -> 1552;
3041 -> 1672;
3042 -> 3041;
3042 -> 1567;
3043 -> 3042;
3043 -> 1569;
3043 -> 1567;
3044 -> 1565;
3044 -> 1599;
3044 -> 1668;
3044 -> 3043;
3044 -> 1677;
3044 -> 1593;
3044 -> 1594;
3044 -> 3029;
3044 -> 1601;
3044 -> 1598;
3045 -> 1613;
3046 -> 3045;
3046 -> 1434;
3047 -> 3046;
3047 -> 1436;
3047 -> 1434;
3048 -> 1632;
3049 -> 3048;
3049 -> 1472;
3050 -> 3049;
3050 -> 1474;
3050 -> 1472;
3051 -> 1470;
3051 -> 1502;
3051 -> 1628;
3051 -> 3050;
3051 -> 1637;
3051 -> 1498;
3051 -> 1499;
3051 -> 3036;
3051 -> 1509;
3051 -> 1501;
3052 -> 1652;
3053 -> 3052;
3053 -> 1521;
3054 -> 3053;
3054 -> 1523;
3054 -> 1521;
3055 -> 1519;
3055 -> 1553;
3055 -> 1648;
3055 -> 3054;
3055 -> 1657;
3055 -> 1547;
3055 -> 1548;
3055 -> 3040;
3055 -> 1555;
3055 -> 1552;
3056 -> 1672;
3057 -> 3056;
3057 -> 1567;
3058 -> 3057;
3058 -> 1569;
3058 -> 1567;
3059 -> 1565;
3059 -> 1599;
3059 -> 1668;
3059 -> 3058;
3059 -> 1677;
3059 -> 1593;
3059 -> 1594;
3059 -> 3044;
3059 -> 1601;
3059 -> 1598;
3060 -> 1613;
3061 -> 3060;
3061 -> 1434;
3062 -> 3061;
3062 -> 1436;
3062 -> 1434;
3063 -> 1632;
3064 -> 3063;
3064 -> 1472;
3065 -> 3064;
3065 -> 1474;
3065 -> 1472;
3066 -> 1470;
3066 -> 1502;
3066 -> 1628;
3066 -> 3065;
3066 -> 1637;
3066 -> 1498;
3066 -> 1499;
3066 -> 3051;
3066 -> 1509;
3066 -> 1501;
3067 -> 1652;
3068 -> 3067;
3068 -> 1521;
3069 -> 3068;
3069 -> 1523;
3069 -> 1521;
3070 -> 1519;
3070 -> 1553;
3070 -> 1648;
3070 -> 3069;
3070 -> 1657;
3070 -> 1547;
3070 -> 1548;
3070 -> 3055;
3070 -> 1555;
3070 -> 1552;
3071 -> 1672;
3072 -> 3071;
3072 -> 1567;
3073 -> 3072;
3073 -> 1569;
3073 -> 1567;
3074 -> 1565;
3074 -> 1599;
3074 -> 1668;
3074 -> 3073;
3074 -> 1677;
3074 -> 1593;
3074 -> 1594;
3074 -> 3059;
3074 -> 1601;
3074 -> 1598;
3075 -> 1613;
3076 -> 3075;
3076 -> 1434;
3077 -> 3076;
3077 -> 1436;
3077 -> 1434;
3078 -> 1632;
3079 -> 3078;
3079 -> 1472;
3080 -> 3079;
3080 -> 1474;
3080 -> 1472;
3081 -> 1470;
3081 -> 1502;
3081 -> 1628;
3081 -> 3080;
3081 -> 1637;
3081 -> 1498;
3081 -> 1499;
3081 -> 3066;
3081 -> 1509;
3081 -> 1501;
3082 -> 1652;
3083 -> 3082;
3083 -> 1521;
3084 -> 3083;
3084 -> 1523;
3084 -> 1521;
3085 -> 1519;
3085 -> 1553;
3085 -> 1648;
3085 -> 3084;
3085 -> 1657;
3085 -> 1547;
3085 -> 1548;
3085 -> 3070;
3085 -> 1555;
3085 -> 1552;
3086 -> 1672;
3087 -> 3086;
3087 -> 1567;
3088 -> 3087;
3088 -> 1569;
3088 -> 1567;
3089 -> 1565;
3089 -> 1599;
3089 -> 1668;
3089 -> 3088;
3089 -> 1677;
3089 -> 1593;
3089 -> 1594;
3089 -> 3074;
3089 -> 1601;
3089 -> 1598;
3090 -> 1613;
3091 -> 3090;
3091 -> 1434;
3092 -> 3091;
3092 -> 1436;
3092 -> 1434;
3093 -> 1632;
3094 -> 3093;
3094 -> 1472;
3095 -> 3094;
3095 -> 1474;
3095 -> 1472;
3096 -> 1470;
3096 -> 1502;
3096 -> 1628;
3096 -> 3095;
3096 -> 1637;
3096 -> 1498;
3096 -> 1499;
3096 -> 3081;
3096 -> 1509;
3096 -> 1501;
3097 -> 1652;
3098 -> 3097;
3098 -> 1521;
3099 -> 3098;
3099 -> 1523;
3099 -> 1521;
3100 -> 1519;
3100 -> 1553;
3100 -> 1648;
3100 -> 3099;
3100 -> 1657;
3100 -> 1547;
3100 -> 1548;
3100 -> 3085;
3100 -> 1555;
3100 -> 1552;
3101 -> 1672;
3102 -> 3101;
3102 -> 1567;
3103 -> 3102;
3103 -> 1569;
3103 -> 1567;
3104 -> 1565;
3104 -> 1599;
3104 -> 1668;
3104 -> 3103;
3104 -> 1677;
3104 -> 1593;
3104 -> 1594;
3104 -> 3089;
3104 -> 1601;
3104 -> 1598;
3105 -> 1613;
3106 -> 3105;
3106 -> 1434;
3107 -> 3106;
3107 -> 1436;
3107 -> 1434;
3108 -> 1632;
3109 -> 3108;
3109 -> 1472;
3110 -> 3109;
3110 -> 1474;
3110 -> 1472;
3111 -> 1470;
3111 -> 1502;
3111 -> 1628;
3111 -> 3110;
3111 -> 1637;
3111 -> 1498;
3111 -> 1499;
3111 -> 3096;
3111 -> 1509;
3111 -> 1501;
3112 -> 1652;
3113 -> 3112;
3113 -> 1521;
3114 -> 3113;
3114 -> 1523;
3114 -> 1521;
3115 -> 1519;
3115 -> 1553;
3115 -> 1648;
3115 -> 3114;
3115 -> 1657;
3115 -> 1547;
3115 -> 1548;
3115 -> 3100;
3115 -> 1555;
3115 -> 1552;
3116 -> 1672;
3117 -> 3116;
3117 -> 1567;
3118 -> 3117;
3118 -> 1569;
3118 -> 1567;
3119 -> 1565;
3119 -> 1599;
3119 -> 1668;
3119 -> 3118;
3119 -> 1677;
3119 -> 1593;
3119 -> 1594;
3119 -> 3104;
3119 -> 1601;
3119 -> 1598;
3120 -> 1613;
3121 -> 3120;
3121 -> 1434;
3122 -> 3121;
3122 -> 1436;
3122 -> 1434;
3123 -> 1632;
3124 -> 3123;
3124 -> 1472;
3125 -> 3124;
3125 -> 1474;
3125 -> 1472;
3126 -> 1470;
3126 -> 1502;
3126 -> 1628;
3126 -> 3125;
3126 -> 1637;
3126 -> 1498;
3126 -> 1499;
3126 -> 3111;
3126 -> 1509;
3126 -> 1501;
3127 -> 1652;
3128 -> 3127;
3128 -> 1521;
3129 -> 3128;
3129 -> 1523;
3129 -> 1521;
3130 -> 1519;
3130 -> 1553;
3130 -> 1648;
3130 -> 3129;
3130 -> 1657;
3130 -> 1547;
3130 -> 1548;
3130 -> 3115;
3130 -> 1555;
3130 -> 1552;
3131 -> 1672;
3132 -> 3131;
3132 -> 1567;
3133 -> 3132;
3133 -> 1569;
3133 -> 1567;
3134 -> 1565;
3134 -> 1599;
3134 -> 1668;
3134 -> 3133;
3134 -> 1677;
3134 -> 1593;
3134 -> 1594;
3134 -> 3119;
3134 -> 1601;
3134 -> 1598;
3135 -> 1613;
3136 -> 3135;
3136 -> 1434;
3137 -> 3136;
3137 -> 1436;
3137 -> 1434;
3138 -> 1632;
3139 -> 3138;
3139 -> 1472;
3140 -> 3139;
3140 -> 1474;
3140 -> 1472;
3141 -> 1470;
3141 -> 1502;
3141 -> 1628;
3141 -> 3140;
3141 -> 1637;
3141 -> 1498;
3141 -> 1499;
3141 -> 3126;
3141 -> 1509;
3141 -> 1501;
3142 -> 1652;
3143 -> 3142;
3143 -> 1521;
3144 -> 3143;
3144 -> 1523;
3144 -> 1521;
3145 -> 1519;
3145 -> 1553;
3145 -> 1648;
3145 -> 3144;
3145 -> 1657;
3145 -> 1547;
3145 -> 1548;
3145 -> 3130;
3145 -> 1555;
3145 -> 1552;
3146 -> 1672;
3147 -> 3146;
3147 -> 1567;
3148 -> 3147;
3148 -> 1569;
3148 -> 1567;
3149 -> 1565;
3149 -> 1599;
3149 -> 1668;
3149 -> 3148;
3149 -> 1677;
3149 -> 1593;
3149 -> 1594;
3149 -> 3134;
3149 -> 1601;
3149 -> 1598;
3150 -> 1613;
3151 -> 3150;
3151 -> 1434;
3152 -> 3151;
3152 -> 1436;
3152 -> 1434;
3153 -> 1632;
3154 -> 3153;
3154 -> 1472;
3155 -> 3154;
3155 -> 1474;
3155 -> 1472;
3156 -> 1470;
3156 -> 1502;
3156 -> 1628;
3156 -> 3155;
3156 -> 1637;
3156 -> 1498;
3156 -> 1499;
3156 -> 3141;
3156 -> 1509;
3156 -> 1501;
3157 -> 1652;
3158 -> 3157;
3158 -> 1521;
3159 -> 3158;
3159 -> 1523;
3159 -> 1521;
3160 -> 1519;
3160 -> 1553;
3160 -> 1648;
3160 -> 3159;
3160 -> 1657;
3160 -> 1547;
3160 -> 1548;
3160 -> 3145;
3160 -> 1555;
3160 -> 1552;
3161 -> 1672;
3162 -> 3161;
3162 -> 1567;
3163 -> 3162;
3163 -> 1569;
3163 -> 1567;
3164 -> 1565;
3164 -> 1599;
3164 -> 1668;
3164 -> 3163;
3164 -> 1677;
3164 -> 1593;
3164 -> 1594;
3164 -> 3149;
3164 -> 1601;
3164 -> 1598;
3165 -> 1613;
3166 -> 3165;
3166 -> 1434;
3167 -> 3166;
3167 -> 1436;
3167 -> 1434;
3168 -> 1632;
3169 -> 3168;
3169 -> 1472;
3170 -> 3169;
3170 -> 1474;
3170 -> 1472;
3171 -> 1470;
3171 -> 1502;
3171 -> 1628;
3171 -> 3170;
3171 -> 1637;
3171 -> 1498;
3171 -> 1499;
3171 -> 3156;
3171 -> 1509;
3171 -> 1501;
3172 -> 1652;
3173 -> 3172;
3173 -> 1521;
3174 -> 3173;
3174 -> 1523;
3174 -> 1521;
3175 -> 1519;
3175 -> 1553;
3175 -> 1648;
3175 -> 3174;
3175 -> 1657;
3175 -> 1547;
3175 -> 1548;
3175 -> 3160;
3175 -> 1555;
3175 -> 1552;
3176 -> 1672;
3177 -> 3176;
3177 -> 1567;
3178 -> 3177;
3178 -> 1569;
3178 -> 1567;
3179 -> 1565;
3179 -> 1599;
3179 -> 1668;
3179 -> 3178;
3179 -> 1677;
3179 -> 1593;
3179 -> 1594;
3179 -> 3164;
3179 -> 1601;
3179 -> 1598;
3180 -> 1613;
3181 -> 3180;
3181 -> 1434;
3182 -> 3181;
3182 -> 1436;
3182 -> 1434;
3183 -> 1632;
3184 -> 3183;
3184 -> 1472;
3185 -> 3184;
3185 -> 1474;
3185 -> 1472;
3186 -> 1470;
3186 -> 1502;
3186 -> 1628;
3186 -> 3185;
3186 -> 1637;
3186 -> 1498;
3186 -> 1499;
3186 -> 3171;
3186 -> 1509;
3186 -> 1501;
3187 -> 1652;
3188 -> 3187;
3188 -> 1521;
3189 -> 3188;
3189 -> 1523;
3189 -> 1521;
3190 -> 1519;
3190 -> 1553;
3190 -> 1648;
3190 -> 3189;
3190 -> 1657;
3190 -> 1547;
3190 -> 1548;
3190 -> 3175;
3190 -> 1555;
3190 -> 1552;
3191 -> 1672;
3192 -> 3191;
3192 -> 1567;
3193 -> 3192;
3193 -> 1569;
3193 -> 1567;
3194 -> 1565;
3194 -> 1599;
3194 -> 1668;
3194 -> 3193;
3194 -> 1677;
3194 -> 1593;
3194 -> 1594;
3194 -> 3179;
3194 -> 1601;
3194 -> 1598;
3195 -> 1613;
3196 -> 3195;
3196 -> 1434;
3197 -> 3196;
3197 -> 1436;
3197 -> 1434;
3198 -> 1632;
3199 -> 3198;
3199 -> 1472;
3200 -> 3199;
3200 -> 1474;
3200 -> 1472;
3201 -> 1470;
3201 -> 1502;
3201 -> 1628;
3201 -> 3200;
3201 -> 1637;
3201 -> 1498;
3201 -> 1499;
3201 -> 3186;
3201 -> 1509;
3201 -> 1501;
3202 -> 1652;
3203 -> 3202;
3203 -> 1521;
3204 -> 3203;
3204 -> 1523;
3204 -> 1521;
3205 -> 1519;
3205 -> 1553;
3205 -> 1648;
3205 -> 3204;
3205 -> 1657;
3205 -> 1547;
3205 -> 1548;
3205 -> 3190;
3205 -> 1555;
3205 -> 1552;
3206 -> 1672;
3207 -> 3206;
3207 -> 1567;
3208 -> 3207;
3208 -> 1569;
3208 -> 1567;
3209 -> 1565;
3209 -> 1599;
3209 -> 1668;
3209 -> 3208;
3209 -> 1677;
3209 -> 1593;
3209 -> 1594;
3209 -> 3194;
3209 -> 1601;
3209 -> 1598;
3210 -> 1613;
3211 -> 3210;
3211 -> 1434;
3212 -> 3211;
3212 -> 1436;
3212 -> 1434;
3213 -> 1632;
3214 -> 3213;
3214 -> 1472;
3215 -> 3214;
3215 -> 1474;
3215 -> 1472;
3216 -> 1470;
3216 -> 1502;
3216 -> 1628;
3216 -> 3215;
3216 -> 1637;
3216 -> 1498;
3216 -> 1499;
3216 -> 3201;
3216 -> 1509;
3216 -> 1501;
3217 -> 1652;
3218 -> 3217;
3218 -> 1521;
3219 -> 3218;
3219 -> 1523;
3219 -> 1521;
3220 -> 1519;
3220 -> 1553;
3220 -> 1648;
3220 -> 3219;
3220 -> 1657;
3220 -> 1547;
3220 -> 1548;
3220 -> 3205;
3220 -> 1555;
3220 -> 1552;
3221 -> 1672;
3222 -> 3221;
3222 -> 1567;
3223 -> 3222;
3223 -> 1569;
3223 -> 1567;
3224 -> 1565;
3224 -> 1599;
3224 -> 1668;
3224 -> 3223;
3224 -> 1677;
3224 -> 1593;
3224 -> 1594;
3224 -> 3209;
3224 -> 1601;
3224 -> 1598;
3225 -> 1613;
3226 -> 3225;
3226 -> 1434;
3227 -> 3226;
3227 -> 1436;
3227 -> 1434;
3228 -> 1632;
3229 -> 3228;
3229 -> 1472;
3230 -> 3229;
3230 -> 1474;
3230 -> 1472;
3231 -> 1470;
3231 -> 1502;
3231 -> 1628;
3231 -> 3230;
3231 -> 1637;
3231 -> 1498;
3231 -> 1499;
3231 -> 3216;
3231 -> 1509;
3231 -> 1501;
3232 -> 1652;
3233 -> 3232;
3233 -> 1521;
3234 -> 3233;
3234 -> 1523;
3234 -> 1521;
3235 -> 1519;
3235 -> 1553;
3235 -> 1648;
3235 -> 3234;
3235 -> 1657;
3235 -> 1547;
3235 -> 1548;
3235 -> 3220;
3235 -> 1555;
3235 -> 1552;
3236 -> 1672;
3237 -> 3236;
3237 -> 1567;
3238 -> 3237;
3238 -> 1569;
3238 -> 1567;
3239 -> 1565;
3239 -> 1599;
3239 -> 1668;
3239 -> 3238;
3239 -> 1677;
3239 -> 1593;
3239 -> 1594;
3239 -> 3224;
3239 -> 1601;
3239 -> 1598;
3240 -> 1613;
3241 -> 3240;
3241 -> 1434;
3242 -> 3241;
3242 -> 1436;
3242 -> 1434;
3243 -> 1632;
3244 -> 3243;
3244 -> 1472;
3245 -> 3244;
3245 -> 1474;
3245 -> 1472;
3246 -> 1470;
3246 -> 1502;
3246 -> 1628;
3246 -> 3245;
3246 -> 1637;
3246 -> 1498;
3246 -> 1499;
3246 -> 3231;
3246 -> 1509;
3246 -> 1501;
3247 -> 1652;
3248 -> 3247;
3248 -> 1521;
3249 -> 3248;
3249 -> 1523;
3249 -> 1521;
3250 -> 1519;
3250 -> 1553;
3250 -> 1648;
3250 -> 3249;
3250 -> 1657;
3250 -> 1547;
3250 -> 1548;
3250 -> 3235;
3250 -> 1555;
3250 -> 1552;
3251 -> 1672;
3252 -> 3251;
3252 -> 1567;
3253 -> 3252;
3253 -> 1569;
3253 -> 1567;
3254 -> 1565;
3254 -> 1599;
3254 -> 1668;
3254 -> 3253;
3254 -> 1677;
3254 -> 1593;
3254 -> 1594;
3254 -> 3239;
3254 -> 1601;
3254 -> 1598;
3255 -> 1613;
3256 -> 3255;
3256 -> 1434;
3257 -> 3256;
3257 -> 1436;
3257 -> 1434;
3258 -> 1632;
3259 -> 3258;
3259 -> 1472;
3260 -> 3259;
3260 -> 1474;
3260 -> 1472;
3261 -> 1470;
3261 -> 1502;
3261 -> 1628;
3261 -> 3260;
3261 -> 1637;
3261 -> 1498;
3261 -> 1499;
3261 -> 3246;
3261 -> 1509;
3261 -> 1501;
3262 -> 1652;
3263 -> 3262;
3263 -> 1521;
3264 -> 3263;
3264 -> 1523;
3264 -> 1521;
3265 -> 1519;
3265 -> 1553;
3265 -> 1648;
3265 -> 3264;
3265 -> 1657;
3265 -> 1547;
3265 -> 1548;
3265 -> 3250;
3265 -> 1555;
3265 -> 1552;
3266 -> 1672;
3267 -> 3266;
3267 -> 1567;
3268 -> 3267;
3268 -> 1569;
3268 -> 1567;
3269 -> 1565;
3269 -> 1599;
3269 -> 1668;
3269 -> 3268;
3269 -> 1677;
3269 -> 1593;
3269 -> 1594;
3269 -> 3254;
3269 -> 1601;
3269 -> 1598;
3270 -> 1613;
3271 -> 3270;
3271 -> 1434;
3272 -> 3271;
3272 -> 1436;
3272 -> 1434;
3273 -> 1632;
3274 -> 3273;
3274 -> 1472;
3275 -> 3274;
3275 -> 1474;
3275 -> 1472;
3276 -> 1470;
3276 -> 1502;
3276 -> 1628;
3276 -> 3275;
3276 -> 1637;
3276 -> 1498;
3276 -> 1499;
3276 -> 3261;
3276 -> 1509;
3276 -> 1501;
3277 -> 1652;
3278 -> 3277;
3278 -> 1521;
3279 -> 3278;
3279 -> 1523;
3279 -> 1521;
3280 -> 1519;
3280 -> 1553;
3280 -> 1648;
3280 -> 3279;
3280 -> 1657;
3280 -> 1547;
3280 -> 1548;
3280 -> 3265;
3280 -> 1555;
3280 -> 1552;
3281 -> 1672;
3282 -> 3281;
3282 -> 1567;
3283 -> 3282;
3283 -> 1569;
3283 -> 1567;
3284 -> 1565;
3284 -> 1599;
3284 -> 1668;
3284 -> 3283;
3284 -> 1677;
3284 -> 1593;
3284 -> 1594;
3284 -> 3269;
3284 -> 1601;
3284 -> 1598;
3285 -> 1613;
3286 -> 3285;
3286 -> 1434;
3287 -> 3286;
3287 -> 1436;
3287 -> 1434;
3288 -> 1632;
3289 -> 3288;
3289 -> 1472;
3290 -> 3289;
3290 -> 1474;
3290 -> 1472;
3291 -> 1470;
3291 -> 1502;
3291 -> 1628;
3291 -> 3290;
3291 -> 1637;
3291 -> 1498;
3291 -> 1499;
3291 -> 3276;
3291 -> 1509;
3291 -> 1501;
3292 -> 1652;
3293 -> 3292;
3293 -> 1521;
3294 -> 3293;
3294 -> 1523;
3294 -> 1521;
3295 -> 1519;
3295 -> 1553;
3295 -> 1648;
3295 -> 3294;
3295 -> 1657;
3295 -> 1547;
3295 -> 1548;
3295 -> 3280;
3295 -> 1555;
3295 -> 1552;
3296 -> 1672;
3297 -> 3296;
3297 -> 1567;
3298 -> 3297;
3298 -> 1569;
3298 -> 1567;
3299 -> 1565;
3299 -> 1599;
3299 -> 1668;
3299 -> 3298;
3299 -> 1677;
3299 -> 1593;
3299 -> 1594;
3299 -> 3284;
3299 -> 1601;
3299 -> 1598;
3300 -> 1613;
3301 -> 3300;
3301 -> 1434;
3302 -> 3301;
3302 -> 1436;
3302 -> 1434;
3303 -> 1632;
3304 -> 3303;
3304 -> 1472;
3305 -> 3304;
3305 -> 1474;
3305 -> 1472;
3306 -> 1470;
3306 -> 1502;
3306 -> 1628;
3306 -> 3305;
3306 -> 1637;
3306 -> 1498;
3306 -> 1499;
3306 -> 3291;
3306 -> 1509;
3306 -> 1501;
3307 -> 1652;
3308 -> 3307;
3308 -> 1521;
3309 -> 3308;
3309 -> 1523;
3309 -> 1521;
3310 -> 1519;
3310 -> 1553;
3310 -> 1648;
3310 -> 3309;
3310 -> 1657;
3310 -> 1547;
3310 -> 1548;
3310 -> 3295;
3310 -> 1555;
3310 -> 1552;
3311 -> 1672;
3312 -> 3311;
3312 -> 1567;
3313 -> 3312;
3313 -> 1569;
3313 -> 1567;
3314 -> 1565;
3314 -> 1599;
3314 -> 1668;
3314 -> 3313;
3314 -> 1677;
3314 -> 1593;
3314 -> 1594;
3314 -> 3299;
3314 -> 1601;
3314 -> 1598;
3315 -> 1613;
3316 -> 3315;
3316 -> 1434;
3317 -> 3316;
3317 -> 1436;
3317 -> 1434;
3318 -> 1632;
3319 -> 3318;
3319 -> 1472;
3320 -> 3319;
3320 -> 1474;
3320 -> 1472;
3321 -> 1470;
3321 -> 1502;
3321 -> 1628;
3321 -> 3320;
3321 -> 1637;
3321 -> 1498;
3321 -> 1499;
3321 -> 3306;
3321 -> 1509;
3321 -> 1501;
3322 -> 1652;
3323 -> 3322;
3323 -> 1521;
3324 -> 3323;
3324 -> 1523;
3324 -> 1521;
3325 -> 1519;
3325 -> 1553;
3325 -> 1648;
3325 -> 3324;
3325 -> 1657;
3325 -> 1547;
3325 -> 1548;
3325 -> 3310;
3325 -> 1555;
3325 -> 1552;
3326 -> 1672;
3327 -> 3326;
3327 -> 1567;
3328 -> 3327;
3328 -> 1569;
3328 -> 1567;
3329 -> 1565;
3329 -> 1599;
3329 -> 1668;
3329 -> 3328;
3329 -> 1677;
3329 -> 1593;
3329 -> 1594;
3329 -> 3314;
3329 -> 1601;
3329 -> 1598;
3330 -> 1613;
3331 -> 3330;
3331 -> 1434;
3332 -> 3331;
3332 -> 1436;
3332 -> 1434;
3333 -> 1632;
3334 -> 3333;
3334 -> 1472;
3335 -> 3334;
3335 -> 1474;
3335 -> 1472;
3336 -> 1470;
3336 -> 1502;
3336 -> 1628;
3336 -> 3335;
3336 -> 1637;
3336 -> 1498;
3336 -> 1499;
3336 -> 3321;
3336 -> 1509;
3336 -> 1501;
3337 -> 1652;
3338 -> 3337;
3338 -> 1521;
3339 -> 3338;
3339 -> 1523;
3339 -> 1521;
3340 -> 1519;
3340 -> 1553;
3340 -> 1648;
3340 -> 3339;
3340 -> 1657;
3340 -> 1547;
3340 -> 1548;
3340 -> 3325;
3340 -> 1555;
3340 -> 1552;
3341 -> 1672;
3342 -> 3341;
3342 -> 1567;
3343 -> 3342;
3343 -> 1569;
3343 -> 1567;
3344 -> 1565;
3344 -> 1599;
3344 -> 1668;
3344 -> 3343;
3344 -> 1677;
3344 -> 1593;
3344 -> 1594;
3344 -> 3329;
3344 -> 1601;
3344 -> 1598;
3345 -> 1613;
3346 -> 3345;
3346 -> 1434;
3347 -> 3346;
3347 -> 1436;
3347 -> 1434;
3348 -> 1632;
3349 -> 3348;
3349 -> 1472;
3350 -> 3349;
3350 -> 1474;
3350 -> 1472;
3351 -> 1470;
3351 -> 1502;
3351 -> 1628;
3351 -> 3350;
3351 -> 1637;
3351 -> 1498;
3351 -> 1499;
3351 -> 3336;
3351 -> 1509;
3351 -> 1501;
3352 -> 1652;
3353 -> 3352;
3353 -> 1521;
3354 -> 3353;
3354 -> 1523;
3354 -> 1521;
3355 -> 1519;
3355 -> 1553;
3355 -> 1648;
3355 -> 3354;
3355 -> 1657;
3355 -> 1547;
3355 -> 1548;
3355 -> 3340;
3355 -> 1555;
3355 -> 1552;
3356 -> 1672;
3357 -> 3356;
3357 -> 1567;
3358 -> 3357;
3358 -> 1569;
3358 -> 1567;
3359 -> 1565;
3359 -> 1599;
3359 -> 1668;
3359 -> 3358;
3359 -> 1677;
3359 -> 1593;
3359 -> 1594;
3359 -> 3344;
3359 -> 1601;
3359 -> 1598;
3360 -> 1613;
3361 -> 3360;
3361 -> 1434;
3362 -> 3361;
3362 -> 1436;
3362 -> 1434;
3363 -> 1632;
3364 -> 3363;
3364 -> 1472;
3365 -> 3364;
3365 -> 1474;
3365 -> 1472;
3366 -> 1470;
3366 -> 1502;
3366 -> 1628;
3366 -> 3365;
3366 -> 1637;
3366 -> 1498;
3366 -> 1499;
3366 -> 3351;
3366 -> 1509;
3366 -> 1501;
3367 -> 1652;
3368 -> 3367;
3368 -> 1521;
3369 -> 3368;
3369 -> 1523;
3369 -> 1521;
3370 -> 1519;
3370 -> 1553;
3370 -> 1648;
3370 -> 3369;
3370 -> 1657;
3370 -> 1547;
3370 -> 1548;
3370 -> 3355;
3370 -> 1555;
3370 -> 1552;
3371 -> 1672;
3372 -> 3371;
3372 -> 1567;
3373 -> 3372;
3373 -> 1569;
3373 -> 1567;
3374 -> 1565;
3374 -> 1599;
3374 -> 1668;
3374 -> 3373;
3374 -> 1677;
3374 -> 1593;
3374 -> 1594;
3374 -> 3359;
3374 -> 1601;
3374 -> 1598;
3375 -> 1613;
3376 -> 3375;
3376 -> 1434;
3377 -> 3376;
3377 -> 1436;
3377 -> 1434;
3378 -> 1632;
3379 -> 3378;
3379 -> 1472;
3380 -> 3379;
3380 -> 1474;
3380 -> 1472;
3381 -> 1470;
3381 -> 1502;
3381 -> 1628;
3381 -> 3380;
3381 -> 1637;
3381 -> 1498;
3381 -> 1499;
3381 -> 3366;
3381 -> 1509;
3381 -> 1501;
3382 -> 1652;
3383 -> 3382;
3383 -> 1521;
3384 -> 3383;
3384 -> 1523;
3384 -> 1521;
3385 -> 1519;
3385 -> 1553;
3385 -> 1648;
3385 -> 3384;
3385 -> 1657;
3385 -> 1547;
3385 -> 1548;
3385 -> 3370;
3385 -> 1555;
3385 -> 1552;
3386 -> 1672;
3387 -> 3386;
3387 -> 1567;
3388 -> 3387;
3388 -> 1569;
3388 -> 1567;
3389 -> 1565;
3389 -> 1599;
3389 -> 1668;
3389 -> 3388;
3389 -> 1677;
3389 -> 1593;
3389 -> 1594;
3389 -> 3374;
3389 -> 1601;
3389 -> 1598;
3390 -> 1613;
3391 -> 3390;
3391 -> 1434;
3392 -> 3391;
3392 -> 1436;
3392 -> 1434;
3393 -> 1632;
3394 -> 3393;
3394 -> 1472;
3395 -> 3394;
3395 -> 1474;
3395 -> 1472;
3396 -> 1470;
3396 -> 1502;
3396 -> 1628;
3396 -> 3395;
3396 -> 1637;
3396 -> 1498;
3396 -> 1499;
3396 -> 3381;
3396 -> 1509;
3396 -> 1501;
3397 -> 1652;
3398 -> 3397;
3398 -> 1521;
3399 -> 3398;
3399 -> 1523;
3399 -> 1521;
3400 -> 1519;
3400 -> 1553;
3400 -> 1648;
3400 -> 3399;
3400 -> 1657;
3400 -> 1547;
3400 -> 1548;
3400 -> 3385;
3400 -> 1555;
3400 -> 1552;
3401 -> 1672;
3402 -> 3401;
3402 -> 1567;
3403 -> 3402;
3403 -> 1569;
3403 -> 1567;
3404 -> 1565;
3404 -> 1599;
3404 -> 1668;
3404 -> 3403;
3404 -> 1677;
3404 -> 1593;
3404 -> 1594;
3404 -> 3389;
3404 -> 1601;
3404 -> 1598;
3405 -> 1613;
3406 -> 3405;
3406 -> 1434;
3407 -> 3406;
3407 -> 1436;
3407 -> 1434;
3408 -> 1632;
3409 -> 3408;
3409 -> 1472;
3410 -> 3409;
3410 -> 1474;
3410 -> 1472;
3411 -> 1470;
3411 -> 1502;
3411 -> 1628;
3411 -> 3410;
3411 -> 1637;
3411 -> 1498;
3411 -> 1499;
3411 -> 3396;
3411 -> 1509;
3411 -> 1501;
3412 -> 1652;
3413 -> 3412;
3413 -> 1521;
3414 -> 3413;
3414 -> 1523;
3414 -> 1521;
3415 -> 1519;
3415 -> 1553;
3415 -> 1648;
3415 -> 3414;
3415 -> 1657;
3415 -> 1547;
3415 -> 1548;
3415 -> 3400;
3415 -> 1555;
3415 -> 1552;
3416 -> 1672;
3417 -> 3416;
3417 -> 1567;
3418 -> 3417;
3418 -> 1569;
3418 -> 1567;
3419 -> 1565;
3419 -> 1599;
3419 -> 1668;
3419 -> 3418;
3419 -> 1677;
3419 -> 1593;
3419 -> 1594;
3419 -> 3404;
3419 -> 1601;
3419 -> 1598;
3420 -> 1613;
3421 -> 3420;
3421 -> 1434;
3422 -> 3421;
3422 -> 1436;
3422 -> 1434;
3423 -> 1632;
3424 -> 3423;
3424 -> 1472;
3425 -> 3424;
3425 -> 1474;
3425 -> 1472;
3426 -> 1470;
3426 -> 1502;
3426 -> 1628;
3426 -> 3425;
3426 -> 1637;
3426 -> 1498;
3426 -> 1499;
3426 -> 3411;
3426 -> 1509;
3426 -> 1501;
3427 -> 1652;
3428 -> 3427;
3428 -> 1521;
3429 -> 3428;
3429 -> 1523;
3429 -> 1521;
3430 -> 1519;
3430 -> 1553;
3430 -> 1648;
3430 -> 3429;
3430 -> 1657;
3430 -> 1547;
3430 -> 1548;
3430 -> 3415;
3430 -> 1555;
3430 -> 1552;
3431 -> 1672;
3432 -> 3431;
3432 -> 1567;
3433 -> 3432;
3433 -> 1569;
3433 -> 1567;
3434 -> 1565;
3434 -> 1599;
3434 -> 1668;
3434 -> 3433;
3434 -> 1677;
3434 -> 1593;
3434 -> 1594;
3434 -> 3419;
3434 -> 1601;
3434 -> 1598;
3435 -> 1613;
3436 -> 3435;
3436 -> 1434;
3437 -> 3436;
3437 -> 1436;
3437 -> 1434;
3438 -> 1632;
3439 -> 3438;
3439 -> 1472;
3440 -> 3439;
3440 -> 1474;
3440 -> 1472;
3441 -> 1470;
3441 -> 1502;
3441 -> 1628;
3441 -> 3440;
3441 -> 1637;
3441 -> 1498;
3441 -> 1499;
3441 -> 3426;
3441 -> 1509;
3441 -> 1501;
3442 -> 1652;
3443 -> 3442;
3443 -> 1521;
3444 -> 3443;
3444 -> 1523;
3444 -> 1521;
3445 -> 1519;
3445 -> 1553;
3445 -> 1648;
3445 -> 3444;
3445 -> 1657;
3445 -> 1547;
3445 -> 1548;
3445 -> 3430;
3445 -> 1555;
3445 -> 1552;
3446 -> 1672;
3447 -> 3446;
3447 -> 1567;
3448 -> 3447;
3448 -> 1569;
3448 -> 1567;
3449 -> 1565;
3449 -> 1599;
3449 -> 1668;
3449 -> 3448;
3449 -> 1677;
3449 -> 1593;
3449 -> 1594;
3449 -> 3434;
3449 -> 1601;
3449 -> 1598;
3450 -> 1613;
3451 -> 3450;
3451 -> 1434;
3452 -> 3451;
3452 -> 1436;
3452 -> 1434;
3453 -> 1632;
3454 -> 3453;
3454 -> 1472;
3455 -> 3454;
3455 -> 1474;
3455 -> 1472;
3456 -> 1470;
3456 -> 1502;
3456 -> 1628;
3456 -> 3455;
3456 -> 1637;
3456 -> 1498;
3456 -> 1499;
3456 -> 3441;
3456 -> 1509;
3456 -> 1501;
3457 -> 1652;
3458 -> 3457;
3458 -> 1521;
3459 -> 3458;
3459 -> 1523;
3459 -> 1521;
3460 -> 1519;
3460 -> 1553;
3460 -> 1648;
3460 -> 3459;
3460 -> 1657;
3460 -> 1547;
3460 -> 1548;
3460 -> 3445;
3460 -> 1555;
3460 -> 1552;
3461 -> 1672;
3462 -> 3461;
3462 -> 1567;
3463 -> 3462;
3463 -> 1569;
3463 -> 1567;
3464 -> 1565;
3464 -> 1599;
3464 -> 1668;
3464 -> 3463;
3464 -> 1677;
3464 -> 1593;
3464 -> 1594;
3464 -> 3449;
3464 -> 1601;
3464 -> 1598;
3465 -> 1613;
3466 -> 3465;
3466 -> 1434;
3467 -> 3466;
3467 -> 1436;
3467 -> 1434;
3468 -> 1632;
3469 -> 3468;
3469 -> 1472;
3470 -> 3469;
3470 -> 1474;
3470 -> 1472;
3471 -> 1470;
3471 -> 1502;
3471 -> 1628;
3471 -> 3470;
3471 -> 1637;
3471 -> 1498;
3471 -> 1499;
3471 -> 3456;
3471 -> 1509;
3471 -> 1501;
3472 -> 1652;
3473 -> 3472;
3473 -> 1521;
3474 -> 3473;
3474 -> 1523;
3474 -> 1521;
3475 -> 1519;
3475 -> 1553;
3475 -> 1648;
3475 -> 3474;
3475 -> 1657;
3475 -> 1547;
3475 -> 1548;
3475 -> 3460;
3475 -> 1555;
3475 -> 1552;
3476 -> 1672;
3477 -> 3476;
3477 -> 1567;
3478 -> 3477;
3478 -> 1569;
3478 -> 1567;
3479 -> 1565;
3479 -> 1599;
3479 -> 1668;
3479 -> 3478;
3479 -> 1677;
3479 -> 1593;
3479 -> 1594;
3479 -> 3464;
3479 -> 1601;
3479 -> 1598;
3480 -> 1613;
3481 -> 3480;
3481 -> 1434;
3482 -> 3481;
3482 -> 1436;
3482 -> 1434;
3483 -> 1632;
3484 -> 3483;
3484 -> 1472;
3485 -> 3484;
3485 -> 1474;
3485 -> 1472;
3486 -> 1470;
3486 -> 1502;
3486 -> 1628;
3486 -> 3485;
3486 -> 1637;
3486 -> 1498;
3486 -> 1499;
3486 -> 3471;
3486 -> 1509;
3486 -> 1501;
3487 -> 1652;
3488 -> 3487;
3488 -> 1521;
3489 -> 3488;
3489 -> 1523;
3489 -> 1521;
3490 -> 1519;
3490 -> 1553;
3490 -> 1648;
3490 -> 3489;
3490 -> 1657;
3490 -> 1547;
3490 -> 1548;
3490 -> 3475;
3490 -> 1555;
3490 -> 1552;
3491 -> 1672;
3492 -> 3491;
3492 -> 1567;
3493 -> 3492;
3493 -> 1569;
3493 -> 1567;
3494 -> 1565;
3494 -> 1599;
3494 -> 1668;
3494 -> 3493;
3494 -> 1677;
3494 -> 1593;
3494 -> 1594;
3494 -> 3479;
3494 -> 1601;
3494 -> 1598;
3495 -> 1613;
3496 -> 3495;
3496 -> 1434;
3497 -> 3496;
3497 -> 1436;
3497 -> 1434;
3498 -> 1632;
3499 -> 3498;
3499 -> 1472;
3500 -> 3499;
3500 -> 1474;
3500 -> 1472;
3501 -> 1470;
3501 -> 1502;
3501 -> 1628;
3501 -> 3500;
3501 -> 1637;
3501 -> 1498;
3501 -> 1499;
3501 -> 3486;
3501 -> 1509;
3501 -> 1501;
3502 -> 1652;
3503 -> 3502;
3503 -> 1521;
3504 -> 3503;
3504 -> 1523;
3504 -> 1521;
3505 -> 1519;
3505 -> 1553;
3505 -> 1648;
3505 -> 3504;
3505 -> 1657;
3505 -> 1547;
3505 -> 1548;
3505 -> 3490;
3505 -> 1555;
3505 -> 1552;
3506 -> 1672;
3507 -> 3506;
3507 -> 1567;
3508 -> 3507;
3508 -> 1569;
3508 -> 1567;
3509 -> 1565;
3509 -> 1599;
3509 -> 1668;
3509 -> 3508;
3509 -> 1677;
3509 -> 1593;
3509 -> 1594;
3509 -> 3494;
3509 -> 1601;
3509 -> 1598;
3510 -> 1613;
3511 -> 3510;
3511 -> 1434;
3512 -> 3511;
3512 -> 1436;
3512 -> 1434;
3513 -> 1632;
3514 -> 3513;
3514 -> 1472;
3515 -> 3514;
3515 -> 1474;
3515 -> 1472;
3516 -> 1470;
3516 -> 1502;
3516 -> 1628;
3516 -> 3515;
3516 -> 1637;
3516 -> 1498;
3516 -> 1499;
3516 -> 3501;
3516 -> 1509;
3516 -> 1501;
3517 -> 1652;
3518 -> 3517;
3518 -> 1521;
3519 -> 3518;
3519 -> 1523;
3519 -> 1521;
3520 -> 1519;
3520 -> 1553;
3520 -> 1648;
3520 -> 3519;
3520 -> 1657;
3520 -> 1547;
3520 -> 1548;
3520 -> 3505;
3520 -> 1555;
3520 -> 1552;
3521 -> 1672;
3522 -> 3521;
3522 -> 1567;
3523 -> 3522;
3523 -> 1569;
3523 -> 1567;
3524 -> 1565;
3524 -> 1599;
3524 -> 1668;
3524 -> 3523;
3524 -> 1677;
3524 -> 1593;
3524 -> 1594;
3524 -> 3509;
3524 -> 1601;
3524 -> 1598;
3525 -> 1613;
3526 -> 3525;
3526 -> 1434;
3527 -> 3526;
3527 -> 1436;
3527 -> 1434;
3528 -> 1632;
3529 -> 3528;
3529 -> 1472;
3530 -> 3529;
3530 -> 1474;
3530 -> 1472;
3531 -> 1470;
3531 -> 1502;
3531 -> 1628;
3531 -> 3530;
3531 -> 1637;
3531 -> 1498;
3531 -> 1499;
3531 -> 3516;
3531 -> 1509;
3531 -> 1501;
3532 -> 1652;
3533 -> 3532;
3533 -> 1521;
3534 -> 3533;
3534 -> 1523;
3534 -> 1521;
3535 -> 1519;
3535 -> 1553;
3535 -> 1648;
3535 -> 3534;
3535 -> 1657;
3535 -> 1547;
3535 -> 1548;
3535 -> 3520;
3535 -> 1555;
3535 -> 1552;
3536 -> 1672;
3537 -> 3536;
3537 -> 1567;
3538 -> 3537;
3538 -> 1569;
3538 -> 1567;
3539 -> 1565;
3539 -> 1599;
3539 -> 1668;
3539 -> 3538;
3539 -> 1677;
3539 -> 1593;
3539 -> 1594;
3539 -> 3524;
3539 -> 1601;
3539 -> 1598;
3540 -> 1613;
3541 -> 3540;
3541 -> 1434;
3542 -> 3541;
3542 -> 1436;
3542 -> 1434;
3543 -> 1632;
3544 -> 3543;
3544 -> 1472;
3545 -> 3544;
3545 -> 1474;
3545 -> 1472;
3546 -> 1470;
3546 -> 1502;
3546 -> 1628;
3546 -> 3545;
3546 -> 1637;
3546 -> 1498;
3546 -> 1499;
3546 -> 3531;
3546 -> 1509;
3546 -> 1501;
3547 -> 1652;
3548 -> 3547;
3548 -> 1521;
3549 -> 3548;
3549 -> 1523;
3549 -> 1521;
3550 -> 1519;
3550 -> 1553;
3550 -> 1648;
3550 -> 3549;
3550 -> 1657;
3550 -> 1547;
3550 -> 1548;
3550 -> 3535;
3550 -> 1555;
3550 -> 1552;
3551 -> 1672;
3552 -> 3551;
3552 -> 1567;
3553 -> 3552;
3553 -> 1569;
3553 -> 1567;
3554 -> 1565;
3554 -> 1599;
3554 -> 1668;
3554 -> 3553;
3554 -> 1677;
3554 -> 1593;
3554 -> 1594;
3554 -> 3539;
3554 -> 1601;
3554 -> 1598;
3555 -> 1613;
3556 -> 3555;
3556 -> 1434;
3557 -> 3556;
3557 -> 1436;
3557 -> 1434;
3558 -> 1632;
3559 -> 3558;
3559 -> 1472;
3560 -> 3559;
3560 -> 1474;
3560 -> 1472;
3561 -> 1470;
3561 -> 1502;
3561 -> 1628;
3561 -> 3560;
3561 -> 1637;
3561 -> 1498;
3561 -> 1499;
3561 -> 3546;
3561 -> 1509;
3561 -> 1501;
3562 -> 1652;
3563 -> 3562;
3563 -> 1521;
3564 -> 3563;
3564 -> 1523;
3564 -> 1521;
3565 -> 1519;
3565 -> 1553;
3565 -> 1648;
3565 -> 3564;
3565 -> 1657;
3565 -> 1547;
3565 -> 1548;
3565 -> 3550;
3565 -> 1555;
3565 -> 1552;
3566 -> 1672;
3567 -> 3566;
3567 -> 1567;
3568 -> 3567;
3568 -> 1569;
3568 -> 1567;
3569 -> 1565;
3569 -> 1599;
3569 -> 1668;
3569 -> 3568;
3569 -> 1677;
3569 -> 1593;
3569 -> 1594;
3569 -> 3554;
3569 -> 1601;
3569 -> 1598;
3570 -> 1613;
3571 -> 3570;
3571 -> 1434;
3572 -> 3571;
3572 -> 1436;
3572 -> 1434;
3573 -> 1632;
3574 -> 3573;
3574 -> 1472;
3575 -> 3574;
3575 -> 1474;
3575 -> 1472;
3576 -> 1470;
3576 -> 1502;
3576 -> 1628;
3576 -> 3575;
3576 -> 1637;
3576 -> 1498;
3576 -> 1499;
3576 -> 3561;
3576 -> 1509;
3576 -> 1501;
3577 -> 1652;
3578 -> 3577;
3578 -> 1521;
3579 -> 3578;
3579 -> 1523;
3579 -> 1521;
3580 -> 1519;
3580 -> 1553;
3580 -> 1648;
3580 -> 3579;
3580 -> 1657;
3580 -> 1547;
3580 -> 1548;
3580 -> 3565;
3580 -> 1555;
3580 -> 1552;
3581 -> 1672;
3582 -> 3581;
3582 -> 1567;
3583 -> 3582;
3583 -> 1569;
3583 -> 1567;
3584 -> 1565;
3584 -> 1599;
3584 -> 1668;
3584 -> 3583;
3584 -> 1677;
3584 -> 1593;
3584 -> 1594;
3584 -> 3569;
3584 -> 1601;
3584 -> 1598;
3585 -> 1613;
3586 -> 3585;
3586 -> 1434;
3587 -> 3586;
3587 -> 1436;
3587 -> 1434;
3588 -> 1632;
3589 -> 3588;
3589 -> 1472;
3590 -> 3589;
3590 -> 1474;
3590 -> 1472;
3591 -> 1470;
3591 -> 1502;
3591 -> 1628;
3591 -> 3590;
3591 -> 1637;
3591 -> 1498;
3591 -> 1499;
3591 -> 3576;
3591 -> 1509;
3591 -> 1501;
3592 -> 1652;
3593 -> 3592;
3593 -> 1521;
3594 -> 3593;
3594 -> 1523;
3594 -> 1521;
3595 -> 1519;
3595 -> 1553;
3595 -> 1648;
3595 -> 3594;
3595 -> 1657;
3595 -> 1547;
3595 -> 1548;
3595 -> 3580;
3595 -> 1555;
3595 -> 1552;
3596 -> 1672;
3597 -> 3596;
3597 -> 1567;
3598 -> 3597;
3598 -> 1569;
3598 -> 1567;
3599 -> 1565;
3599 -> 1599;
3599 -> 1668;
3599 -> 3598;
3599 -> 1677;
3599 -> 1593;
3599 -> 1594;
3599 -> 3584;
3599 -> 1601;
3599 -> 1598;
3600 -> 1613;
3601 -> 3600;
3601 -> 1434;
3602 -> 3601;
3602 -> 1436;
3602 -> 1434;
3603 -> 1632;
3604 -> 3603;
3604 -> 1472;
3605 -> 3604;
3605 -> 1474;
3605 -> 1472;
3606 -> 1470;
3606 -> 1502;
3606 -> 1628;
3606 -> 3605;
3606 -> 1637;
3606 -> 1498;
3606 -> 1499;
3606 -> 3591;
3606 -> 1509;
3606 -> 1501;
3607 -> 1652;
3608 -> 3607;
3608 -> 1521;
3609 -> 3608;
3609 -> 1523;
3609 -> 1521;
3610 -> 1519;
3610 -> 1553;
3610 -> 1648;
3610 -> 3609;
3610 -> 1657;
3610 -> 1547;
3610 -> 1548;
3610 -> 3595;
3610 -> 1555;
3610 -> 1552;
3611 -> 1672;
3612 -> 3611;
3612 -> 1567;
3613 -> 3612;
3613 -> 1569;
3613 -> 1567;
3614 -> 1565;
3614 -> 1599;
3614 -> 1668;
3614 -> 3613;
3614 -> 1677;
3614 -> 1593;
3614 -> 1594;
3614 -> 3599;
3614 -> 1601;
3614 -> 1598;
3615 -> 1613;
3616 -> 3615;
3616 -> 1434;
3617 -> 3616;
3617 -> 1436;
3617 -> 1434;
3618 -> 1632;
3619 -> 3618;
3619 -> 1472;
3620 -> 3619;
3620 -> 1474;
3620 -> 1472;
3621 -> 1470;
3621 -> 1502;
3621 -> 1628;
3621 -> 3620;
3621 -> 1637;
3621 -> 1498;
3621 -> 1499;
3621 -> 3606;
3621 -> 1509;
3621 -> 1501;
3622 -> 1652;
3623 -> 3622;
3623 -> 1521;
3624 -> 3623;
3624 -> 1523;
3624 -> 1521;
3625 -> 1519;
3625 -> 1553;
3625 -> 1648;
3625 -> 3624;
3625 -> 1657;
3625 -> 1547;
3625 -> 1548;
3625 -> 3610;
3625 -> 1555;
3625 -> 1552;
3626 -> 1672;
3627 -> 3626;
3627 -> 1567;
3628 -> 3627;
3628 -> 1569;
3628 -> 1567;
3629 -> 1565;
3629 -> 1599;
3629 -> 1668;
3629 -> 3628;
3629 -> 1677;
3629 -> 1593;
3629 -> 1594;
3629 -> 3614;
3629 -> 1601;
3629 -> 1598;
3630 -> 1613;
3631 -> 3630;
3631 -> 1434;
3632 -> 3631;
3632 -> 1436;
3632 -> 1434;
3633 -> 1632;
3634 -> 3633;
3634 -> 1472;
3635 -> 3634;
3635 -> 1474;
3635 -> 1472;
3636 -> 1470;
3636 -> 1502;
3636 -> 1628;
3636 -> 3635;
3636 -> 1637;
3636 -> 1498;
3636 -> 1499;
3636 -> 3621;
3636 -> 1509;
3636 -> 1501;
3637 -> 1652;
3638 -> 3637;
3638 -> 1521;
3639 -> 3638;
3639 -> 1523;
3639 -> 1521;
3640 -> 1519;
3640 -> 1553;
3640 -> 1648;
3640 -> 3639;
3640 -> 1657;
3640 -> 1547;
3640 -> 1548;
3640 -> 3625;
3640 -> 1555;
3640 -> 1552;
3641 -> 1672;
3642 -> 3641;
3642 -> 1567;
3643 -> 3642;
3643 -> 1569;
3643 -> 1567;
3644 -> 1565;
3644 -> 1599;
3644 -> 1668;
3644 -> 3643;
3644 -> 1677;
3644 -> 1593;
3644 -> 1594;
3644 -> 3629;
3644 -> 1601;
3644 -> 1598;
3645 -> 1613;
3646 -> 3645;
3646 -> 1434;
3647 -> 3646;
3647 -> 1436;
3647 -> 1434;
3648 -> 1632;
3649 -> 3648;
3649 -> 1472;
3650 -> 3649;
3650 -> 1474;
3650 -> 1472;
3651 -> 1470;
3651 -> 1502;
3651 -> 1628;
3651 -> 3650;
3651 -> 1637;
3651 -> 1498;
3651 -> 1499;
3651 -> 3636;
3651 -> 1509;
3651 -> 1501;
3652 -> 1652;
3653 -> 3652;
3653 -> 1521;
3654 -> 3653;
3654 -> 1523;
3654 -> 1521;
3655 -> 1519;
3655 -> 1553;
3655 -> 1648;
3655 -> 3654;
3655 -> 1657;
3655 -> 1547;
3655 -> 1548;
3655 -> 3640;
3655 -> 1555;
3655 -> 1552;
3656 -> 1672;
3657 -> 3656;
3657 -> 1567;
3658 -> 3657;
3658 -> 1569;
3658 -> 1567;
3659 -> 1565;
3659 -> 1599;
3659 -> 1668;
3659 -> 3658;
3659 -> 1677;
3659 -> 1593;
3659 -> 1594;
3659 -> 3644;
3659 -> 1601;
3659 -> 1598;
3660 -> 1613;
3661 -> 3660;
3661 -> 1434;
3662 -> 3661;
3662 -> 1436;
3662 -> 1434;
3663 -> 1632;
3664 -> 3663;
3664 -> 1472;
3665 -> 3664;
3665 -> 1474;
3665 -> 1472;
3666 -> 1470;
3666 -> 1502;
3666 -> 1628;
3666 -> 3665;
3666 -> 1637;
3666 -> 1498;
3666 -> 1499;
3666 -> 3651;
3666 -> 1509;
3666 -> 1501;
3667 -> 1652;
3668 -> 3667;
3668 -> 1521;
3669 -> 3668;
3669 -> 1523;
3669 -> 1521;
3670 -> 1519;
3670 -> 1553;
3670 -> 1648;
3670 -> 3669;
3670 -> 1657;
3670 -> 1547;
3670 -> 1548;
3670 -> 3655;
3670 -> 1555;
3670 -> 1552;
3671 -> 1672;
3672 -> 3671;
3672 -> 1567;
3673 -> 3672;
3673 -> 1569;
3673 -> 1567;
3674 -> 1565;
3674 -> 1599;
3674 -> 1668;
3674 -> 3673;
3674 -> 1677;
3674 -> 1593;
3674 -> 1594;
3674 -> 3659;
3674 -> 1601;
3674 -> 1598;
3675 -> 1613;
3676 -> 3675;
3676 -> 1434;
3677 -> 3676;
3677 -> 1436;
3677 -> 1434;
3678 -> 1632;
3679 -> 3678;
3679 -> 1472;
3680 -> 3679;
3680 -> 1474;
3680 -> 1472;
3681 -> 1470;
3681 -> 1502;
3681 -> 1628;
3681 -> 3680;
3681 -> 1637;
3681 -> 1498;
3681 -> 1499;
3681 -> 3666;
3681 -> 1509;
3681 -> 1501;
3682 -> 1652;
3683 -> 3682;
3683 -> 1521;
3684 -> 3683;
3684 -> 1523;
3684 -> 1521;
3685 -> 1519;
3685 -> 1553;
3685 -> 1648;
3685 -> 3684;
3685 -> 1657;
3685 -> 1547;
3685 -> 1548;
3685 -> 3670;
3685 -> 1555;
3685 -> 1552;
3686 -> 1672;
3687 -> 3686;
3687 -> 1567;
3688 -> 3687;
3688 -> 1569;
3688 -> 1567;
3689 -> 1565;
3689 -> 1599;
3689 -> 1668;
3689 -> 3688;
3689 -> 1677;
3689 -> 1593;
3689 -> 1594;
3689 -> 3674;
3689 -> 1601;
3689 -> 1598;
3690 -> 1613;
3691 -> 3690;
3691 -> 1434;
3692 -> 3691;
3692 -> 1436;
3692 -> 1434;
3693 -> 1632;
3694 -> 3693;
3694 -> 1472;
3695 -> 3694;
3695 -> 1474;
3695 -> 1472;
3696 -> 1470;
3696 -> 1502;
3696 -> 1628;
3696 -> 3695;
3696 -> 1637;
3696 -> 1498;
3696 -> 1499;
3696 -> 3681;
3696 -> 1509;
3696 -> 1501;
3697 -> 1652;
3698 -> 3697;
3698 -> 1521;
3699 -> 3698;
3699 -> 1523;
3699 -> 1521;
3700 -> 1519;
3700 -> 1553;
3700 -> 1648;
3700 -> 3699;
3700 -> 1657;
3700 -> 1547;
3700 -> 1548;
3700 -> 3685;
3700 -> 1555;
3700 -> 1552;
3701 -> 1672;
3702 -> 3701;
3702 -> 1567;
3703 -> 3702;
3703 -> 1569;
3703 -> 1567;
3704 -> 1565;
3704 -> 1599;
3704 -> 1668;
3704 -> 3703;
3704 -> 1677;
3704 -> 1593;
3704 -> 1594;
3704 -> 3689;
3704 -> 1601;
3704 -> 1598;
3705 -> 1613;
3706 -> 3705;
3706 -> 1434;
3707 -> 3706;
3707 -> 1436;
3707 -> 1434;
3708 -> 1632;
3709 -> 3708;
3709 -> 1472;
3710 -> 3709;
3710 -> 1474;
3710 -> 1472;
3711 -> 1470;
3711 -> 1502;
3711 -> 1628;
3711 -> 3710;
3711 -> 1637;
3711 -> 1498;
3711 -> 1499;
3711 -> 3696;
3711 -> 1509;
3711 -> 1501;
3712 -> 1652;
3713 -> 3712;
3713 -> 1521;
3714 -> 3713;
3714 -> 1523;
3714 -> 1521;
3715 -> 1519;
3715 -> 1553;
3715 -> 1648;
3715 -> 3714;
3715 -> 1657;
3715 -> 1547;
3715 -> 1548;
3715 -> 3700;
3715 -> 1555;
3715 -> 1552;
3716 -> 1672;
3717 -> 3716;
3717 -> 1567;
3718 -> 3717;
3718 -> 1569;
3718 -> 1567;
3719 -> 1565;
3719 -> 1599;
3719 -> 1668;
3719 -> 3718;
3719 -> 1677;
3719 -> 1593;
3719 -> 1594;
3719 -> 3704;
3719 -> 1601;
3719 -> 1598;
3720 -> 1613;
3721 -> 3720;
3721 -> 1434;
3722 -> 3721;
3722 -> 1436;
3722 -> 1434;
3723 -> 1632;
3724 -> 3723;
3724 -> 1472;
3725 -> 3724;
3725 -> 1474;
3725 -> 1472;
3726 -> 1470;
3726 -> 1502;
3726 -> 1628;
3726 -> 3725;
3726 -> 1637;
3726 -> 1498;
3726 -> 1499;
3726 -> 3711;
3726 -> 1509;
3726 -> 1501;
3727 -> 1652;
3728 -> 3727;
3728 -> 1521;
3729 -> 3728;
3729 -> 1523;
3729 -> 1521;
3730 -> 1519;
3730 -> 1553;
3730 -> 1648;
3730 -> 3729;
3730 -> 1657;
3730 -> 1547;
3730 -> 1548;
3730 -> 3715;
3730 -> 1555;
3730 -> 1552;
3731 -> 1672;
3732 -> 3731;
3732 -> 1567;
3733 -> 3732;
3733 -> 1569;
3733 -> 1567;
3734 -> 1565;
3734 -> 1599;
3734 -> 1668;
3734 -> 3733;
3734 -> 1677;
3734 -> 1593;
3734 -> 1594;
3734 -> 3719;
3734 -> 1601;
3734 -> 1598;
3735 -> 1613;
3736 -> 3735;
3736 -> 1434;
3737 -> 3736;
3737 -> 1436;
3737 -> 1434;
3738 -> 1632;
3739 -> 3738;
3739 -> 1472;
3740 -> 3739;
3740 -> 1474;
3740 -> 1472;
3741 -> 1470;
3741 -> 1502;
3741 -> 1628;
3741 -> 3740;
3741 -> 1637;
3741 -> 1498;
3741 -> 1499;
3741 -> 3726;
3741 -> 1509;
3741 -> 1501;
3742 -> 1652;
3743 -> 3742;
3743 -> 1521;
3744 -> 3743;
3744 -> 1523;
3744 -> 1521;
3745 -> 1519;
3745 -> 1553;
3745 -> 1648;
3745 -> 3744;
3745 -> 1657;
3745 -> 1547;
3745 -> 1548;
3745 -> 3730;
3745 -> 1555;
3745 -> 1552;
3746 -> 1672;
3747 -> 3746;
3747 -> 1567;
3748 -> 3747;
3748 -> 1569;
3748 -> 1567;
3749 -> 1565;
3749 -> 1599;
3749 -> 1668;
3749 -> 3748;
3749 -> 1677;
3749 -> 1593;
3749 -> 1594;
3749 -> 3734;
3749 -> 1601;
3749 -> 1598;
3750 -> 1613;
3751 -> 3750;
3751 -> 1434;
3752 -> 3751;
3752 -> 1436;
3752 -> 1434;
3753 -> 1632;
3754 -> 3753;
3754 -> 1472;
3755 -> 3754;
3755 -> 1474;
3755 -> 1472;
3756 -> 1470;
3756 -> 1502;
3756 -> 1628;
3756 -> 3755;
3756 -> 1637;
3756 -> 1498;
3756 -> 1499;
3756 -> 3741;
3756 -> 1509;
3756 -> 1501;
3757 -> 1652;
3758 -> 3757;
3758 -> 1521;
3759 -> 3758;
3759 -> 1523;
3759 -> 1521;
3760 -> 1519;
3760 -> 1553;
3760 -> 1648;
3760 -> 3759;
3760 -> 1657;
3760 -> 1547;
3760 -> 1548;
3760 -> 3745;
3760 -> 1555;
3760 -> 1552;
3761 -> 1672;
3762 -> 3761;
3762 -> 1567;
3763 -> 3762;
3763 -> 1569;
3763 -> 1567;
3764 -> 1565;
3764 -> 1599;
3764 -> 1668;
3764 -> 3763;
3764 -> 1677;
3764 -> 1593;
3764 -> 1594;
3764 -> 3749;
3764 -> 1601;
3764 -> 1598;
3765 -> 1613;
3766 -> 3765;
3766 -> 1434;
3767 -> 3766;
3767 -> 1436;
3767 -> 1434;
3768 -> 1632;
3769 -> 3768;
3769 -> 1472;
3770 -> 3769;
3770 -> 1474;
3770 -> 1472;
3771 -> 1470;
3771 -> 1502;
3771 -> 1628;
3771 -> 3770;
3771 -> 1637;
3771 -> 1498;
3771 -> 1499;
3771 -> 3756;
3771 -> 1509;
3771 -> 1501;
3772 -> 1652;
3773 -> 3772;
3773 -> 1521;
3774 -> 3773;
3774 -> 1523;
3774 -> 1521;
3775 -> 1519;
3775 -> 1553;
3775 -> 1648;
3775 -> 3774;
3775 -> 1657;
3775 -> 1547;
3775 -> 1548;
3775 -> 3760;
3775 -> 1555;
3775 -> 1552;
3776 -> 1672;
3777 -> 3776;
3777 -> 1567;
3778 -> 3777;
3778 -> 1569;
3778 -> 1567;
3779 -> 1565;
3779 -> 1599;
3779 -> 1668;
3779 -> 3778;
3779 -> 1677;
3779 -> 1593;
3779 -> 1594;
3779 -> 3764;
3779 -> 1601;
3779 -> 1598;
3780 -> 1613;
3781 -> 3780;
3781 -> 1434;
3782 -> 3781;
3782 -> 1436;
3782 -> 1434;
3783 -> 1632;
3784 -> 3783;
3784 -> 1472;
3785 -> 3784;
3785 -> 1474;
3785 -> 1472;
3786 -> 1470;
3786 -> 1502;
3786 -> 1628;
3786 -> 3785;
3786 -> 1637;
3786 -> 1498;
3786 -> 1499;
3786 -> 3771;
3786 -> 1509;
3786 -> 1501;
3787 -> 1652;
3788 -> 3787;
3788 -> 1521;
3789 -> 3788;
3789 -> 1523;
3789 -> 1521;
3790 -> 1519;
3790 -> 1553;
3790 -> 1648;
3790 -> 3789;
3790 -> 1657;
3790 -> 1547;
3790 -> 1548;
3790 -> 3775;
3790 -> 1555;
3790 -> 1552;
3791 -> 1672;
3792 -> 3791;
3792 -> 1567;
3793 -> 3792;
3793 -> 1569;
3793 -> 1567;
3794 -> 1565;
3794 -> 1599;
3794 -> 1668;
3794 -> 3793;
3794 -> 1677;
3794 -> 1593;
3794 -> 1594;
3794 -> 3779;
3794 -> 1601;
3794 -> 1598;
3795 -> 1613;
3796 -> 3795;
3796 -> 1434;
3797 -> 3796;
3797 -> 1436;
3797 -> 1434;
3798 -> 1632;
3799 -> 3798;
3799 -> 1472;
3800 -> 3799;
3800 -> 1474;
3800 -> 1472;
3801 -> 1470;
3801 -> 1502;
3801 -> 1628;
3801 -> 3800;
3801 -> 1637;
3801 -> 1498;
3801 -> 1499;
3801 -> 3786;
3801 -> 1509;
3801 -> 1501;
3802 -> 1652;
3803 -> 3802;
3803 -> 1521;
3804 -> 3803;
3804 -> 1523;
3804 -> 1521;
3805 -> 1519;
3805 -> 1553;
3805 -> 1648;
3805 -> 3804;
3805 -> 1657;
3805 -> 1547;
3805 -> 1548;
3805 -> 3790;
3805 -> 1555;
3805 -> 1552;
3806 -> 1672;
3807 -> 3806;
3807 -> 1567;
3808 -> 3807;
3808 -> 1569;
3808 -> 1567;
3809 -> 1565;
3809 -> 1599;
3809 -> 1668;
3809 -> 3808;
3809 -> 1677;
3809 -> 1593;
3809 -> 1594;
3809 -> 3794;
3809 -> 1601;
3809 -> 1598;
3810 -> 1613;
3811 -> 3810;
3811 -> 1434;
3812 -> 3811;
3812 -> 1436;
3812 -> 1434;
3813 -> 1632;
3814 -> 3813;
3814 -> 1472;
3815 -> 3814;
3815 -> 1474;
3815 -> 1472;
3816 -> 1470;
3816 -> 1502;
3816 -> 1628;
3816 -> 3815;
3816 -> 1637;
3816 -> 1498;
3816 -> 1499;
3816 -> 3801;
3816 -> 1509;
3816 -> 1501;
3817 -> 1652;
3818 -> 3817;
3818 -> 1521;
3819 -> 3818;
3819 -> 1523;
3819 -> 1521;
3820 -> 1519;
3820 -> 1553;
3820 -> 1648;
3820 -> 3819;
3820 -> 1657;
3820 -> 1547;
3820 -> 1548;
3820 -> 3805;
3820 -> 1555;
3820 -> 1552;
3821 -> 1672;
3822 -> 3821;
3822 -> 1567;
3823 -> 3822;
3823 -> 1569;
3823 -> 1567;
3824 -> 1565;
3824 -> 1599;
3824 -> 1668;
3824 -> 3823;
3824 -> 1677;
3824 -> 1593;
3824 -> 1594;
3824 -> 3809;
3824 -> 1601;
3824 -> 1598;
3825 -> 1613;
3826 -> 3825;
3826 -> 1434;
3827 -> 3826;
3827 -> 1436;
3827 -> 1434;
3828 -> 1632;
3829 -> 3828;
3829 -> 1472;
3830 -> 3829;
3830 -> 1474;
3830 -> 1472;
3831 -> 1470;
3831 -> 1502;
3831 -> 1628;
3831 -> 3830;
3831 -> 1637;
3831 -> 1498;
3831 -> 1499;
3831 -> 3816;
3831 -> 1509;
3831 -> 1501;
3832 -> 1652;
3833 -> 3832;
3833 -> 1521;
3834 -> 3833;
3834 -> 1523;
3834 -> 1521;
3835 -> 1519;
3835 -> 1553;
3835 -> 1648;
3835 -> 3834;
3835 -> 1657;
3835 -> 1547;
3835 -> 1548;
3835 -> 3820;
3835 -> 1555;
3835 -> 1552;
3836 -> 1672;
3837 -> 3836;
3837 -> 1567;
3838 -> 3837;
3838 -> 1569;
3838 -> 1567;
3839 -> 1565;
3839 -> 1599;
3839 -> 1668;
3839 -> 3838;
3839 -> 1677;
3839 -> 1593;
3839 -> 1594;
3839 -> 3824;
3839 -> 1601;
3839 -> 1598;
3840 -> 1613;
3841 -> 3840;
3841 -> 1434;
3842 -> 3841;
3842 -> 1436;
3842 -> 1434;
3843 -> 1632;
3844 -> 3843;
3844 -> 1472;
3845 -> 3844;
3845 -> 1474;
3845 -> 1472;
3846 -> 1470;
3846 -> 1502;
3846 -> 1628;
3846 -> 3845;
3846 -> 1637;
3846 -> 1498;
3846 -> 1499;
3846 -> 3831;
3846 -> 1509;
3846 -> 1501;
3847 -> 1652;
3848 -> 3847;
3848 -> 1521;
3849 -> 3848;
3849 -> 1523;
3849 -> 1521;
3850 -> 1519;
3850 -> 1553;
3850 -> 1648;
3850 -> 3849;
3850 -> 1657;
3850 -> 1547;
3850 -> 1548;
3850 -> 3835;
3850 -> 1555;
3850 -> 1552;
3851 -> 1672;
3852 -> 3851;
3852 -> 1567;
3853 -> 3852;
3853 -> 1569;
3853 -> 1567;
3854 -> 1565;
3854 -> 1599;
3854 -> 1668;
3854 -> 3853;
3854 -> 1677;
3854 -> 1593;
3854 -> 1594;
3854 -> 3839;
3854 -> 1601;
3854 -> 1598;
3855 -> 1613;
3856 -> 3855;
3856 -> 1434;
3857 -> 3856;
3857 -> 1436;
3857 -> 1434;
3858 -> 1632;
3859 -> 3858;
3859 -> 1472;
3860 -> 3859;
3860 -> 1474;
3860 -> 1472;
3861 -> 1470;
3861 -> 1502;
3861 -> 1628;
3861 -> 3860;
3861 -> 1637;
3861 -> 1498;
3861 -> 1499;
3861 -> 3846;
3861 -> 1509;
3861 -> 1501;
3862 -> 1652;
3863 -> 3862;
3863 -> 1521;
3864 -> 3863;
3864 -> 1523;
3864 -> 1521;
3865 -> 1519;
3865 -> 1553;
3865 -> 1648;
3865 -> 3864;
3865 -> 1657;
3865 -> 1547;
3865 -> 1548;
3865 -> 3850;
3865 -> 1555;
3865 -> 1552;
3866 -> 1672;
3867 -> 3866;
3867 -> 1567;
3868 -> 3867;
3868 -> 1569;
3868 -> 1567;
3869 -> 1565;
3869 -> 1599;
3869 -> 1668;
3869 -> 3868;
3869 -> 1677;
3869 -> 1593;
3869 -> 1594;
3869 -> 3854;
3869 -> 1601;
3869 -> 1598;
3870 -> 1613;
3871 -> 3870;
3871 -> 1434;
3872 -> 3871;
3872 -> 1436;
3872 -> 1434;
3873 -> 1632;
3874 -> 3873;
3874 -> 1472;
3875 -> 3874;
3875 -> 1474;
3875 -> 1472;
3876 -> 1470;
3876 -> 1502;
3876 -> 1628;
3876 -> 3875;
3876 -> 1637;
3876 -> 1498;
3876 -> 1499;
3876 -> 3861;
3876 -> 1509;
3876 -> 1501;
3877 -> 1652;
3878 -> 3877;
3878 -> 1521;
3879 -> 3878;
3879 -> 1523;
3879 -> 1521;
3880 -> 1519;
3880 -> 1553;
3880 -> 1648;
3880 -> 3879;
3880 -> 1657;
3880 -> 1547;
3880 -> 1548;
3880 -> 3865;
3880 -> 1555;
3880 -> 1552;
3881 -> 1672;
3882 -> 3881;
3882 -> 1567;
3883 -> 3882;
3883 -> 1569;
3883 -> 1567;
3884 -> 1565;
3884 -> 1599;
3884 -> 1668;
3884 -> 3883;
3884 -> 1677;
3884 -> 1593;
3884 -> 1594;
3884 -> 3869;
3884 -> 1601;
3884 -> 1598;
3885 -> 1613;
3886 -> 3885;
3886 -> 1434;
3887 -> 3886;
3887 -> 1436;
3887 -> 1434;
3888 -> 1632;
3889 -> 3888;
3889 -> 1472;
3890 -> 3889;
3890 -> 1474;
3890 -> 1472;
3891 -> 1470;
3891 -> 1502;
3891 -> 1628;
3891 -> 3890;
3891 -> 1637;
3891 -> 1498;
3891 -> 1499;
3891 -> 3876;
3891 -> 1509;
3891 -> 1501;
3892 -> 1652;
3893 -> 3892;
3893 -> 1521;
3894 -> 3893;
3894 -> 1523;
3894 -> 1521;
3895 -> 1519;
3895 -> 1553;
3895 -> 1648;
3895 -> 3894;
3895 -> 1657;
3895 -> 1547;
3895 -> 1548;
3895 -> 3880;
3895 -> 1555;
3895 -> 1552;
3896 -> 1672;
3897 -> 3896;
3897 -> 1567;
3898 -> 3897;
3898 -> 1569;
3898 -> 1567;
3899 -> 1565;
3899 -> 1599;
3899 -> 1668;
3899 -> 3898;
3899 -> 1677;
3899 -> 1593;
3899 -> 1594;
3899 -> 3884;
3899 -> 1601;
3899 -> 1598;
3900 -> 1613;
3901 -> 3900;
3901 -> 1434;
3902 -> 3901;
3902 -> 1436;
3902 -> 1434;
3903 -> 1632;
3904 -> 3903;
3904 -> 1472;
3905 -> 3904;
3905 -> 1474;
3905 -> 1472;
3906 -> 1470;
3906 -> 1502;
3906 -> 1628;
3906 -> 3905;
3906 -> 1637;
3906 -> 1498;
3906 -> 1499;
3906 -> 3891;
3906 -> 1509;
3906 -> 1501;
3907 -> 1652;
3908 -> 3907;
3908 -> 1521;
3909 -> 3908;
3909 -> 1523;
3909 -> 1521;
3910 -> 1519;
3910 -> 1553;
3910 -> 1648;
3910 -> 3909;
3910 -> 1657;
3910 -> 1547;
3910 -> 1548;
3910 -> 3895;
3910 -> 1555;
3910 -> 1552;
3911 -> 1672;
3912 -> 3911;
3912 -> 1567;
3913 -> 3912;
3913 -> 1569;
3913 -> 1567;
3914 -> 1565;
3914 -> 1599;
3914 -> 1668;
3914 -> 3913;
3914 -> 1677;
3914 -> 1593;
3914 -> 1594;
3914 -> 3899;
3914 -> 1601;
3914 -> 1598;
3915 -> 1613;
3916 -> 3915;
3916 -> 1434;
3917 -> 3916;
3917 -> 1436;
3917 -> 1434;
3918 -> 1632;
3919 -> 3918;
3919 -> 1472;
3920 -> 3919;
3920 -> 1474;
3920 -> 1472;
3921 -> 1470;
3921 -> 1502;
3921 -> 1628;
3921 -> 3920;
3921 -> 1637;
3921 -> 1498;
3921 -> 1499;
3921 -> 3906;
3921 -> 1509;
3921 -> 1501;
3922 -> 1652;
3923 -> 3922;
3923 -> 1521;
3924 -> 3923;
3924 -> 1523;
3924 -> 1521;
3925 -> 1519;
3925 -> 1553;
3925 -> 1648;
3925 -> 3924;
3925 -> 1657;
3925 -> 1547;
3925 -> 1548;
3925 -> 3910;
3925 -> 1555;
3925 -> 1552;
3926 -> 1672;
3927 -> 3926;
3927 -> 1567;
3928 -> 3927;
3928 -> 1569;
3928 -> 1567;
3929 -> 1565;
3929 -> 1599;
3929 -> 1668;
3929 -> 3928;
3929 -> 1677;
3929 -> 1593;
3929 -> 1594;
3929 -> 3914;
3929 -> 1601;
3929 -> 1598;
3930 -> 1613;
3931 -> 3930;
3931 -> 1434;
3932 -> 3931;
3932 -> 1436;
3932 -> 1434;
3933 -> 1632;
3934 -> 3933;
3934 -> 1472;
3935 -> 3934;
3935 -> 1474;
3935 -> 1472;
3936 -> 1470;
3936 -> 1502;
3936 -> 1628;
3936 -> 3935;
3936 -> 1637;
3936 -> 1498;
3936 -> 1499;
3936 -> 3921;
3936 -> 1509;
3936 -> 1501;
3937 -> 1652;
3938 -> 3937;
3938 -> 1521;
3939 -> 3938;
3939 -> 1523;
3939 -> 1521;
3940 -> 1519;
3940 -> 1553;
3940 -> 1648;
3940 -> 3939;
3940 -> 1657;
3940 -> 1547;
3940 -> 1548;
3940 -> 3925;
3940 -> 1555;
3940 -> 1552;
3941 -> 1672;
3942 -> 3941;
3942 -> 1567;
3943 -> 3942;
3943 -> 1569;
3943 -> 1567;
3944 -> 1565;
3944 -> 1599;
3944 -> 1668;
3944 -> 3943;
3944 -> 1677;
3944 -> 1593;
3944 -> 1594;
3944 -> 3929;
3944 -> 1601;
3944 -> 1598;
3945 -> 1613;
3946 -> 3945;
3946 -> 1434;
3947 -> 3946;
3947 -> 1436;
3947 -> 1434;
3948 -> 1632;
3949 -> 3948;
3949 -> 1472;
3950 -> 3949;
3950 -> 1474;
3950 -> 1472;
3951 -> 1470;
3951 -> 1502;
3951 -> 1628;
3951 -> 3950;
3951 -> 1637;
3951 -> 1498;
3951 -> 1499;
3951 -> 3936;
3951 -> 1509;
3951 -> 1501;
3952 -> 1652;
3953 -> 3952;
3953 -> 1521;
3954 -> 3953;
3954 -> 1523;
3954 -> 1521;
3955 -> 1519;
3955 -> 1553;
3955 -> 1648;
3955 -> 3954;
3955 -> 1657;
3955 -> 1547;
3955 -> 1548;
3955 -> 3940;
3955 -> 1555;
3955 -> 1552;
3956 -> 1672;
3957 -> 3956;
3957 -> 1567;
3958 -> 3957;
3958 -> 1569;
3958 -> 1567;
3959 -> 1565;
3959 -> 1599;
3959 -> 1668;
3959 -> 3958;
3959 -> 1677;
3959 -> 1593;
3959 -> 1594;
3959 -> 3944;
3959 -> 1601;
3959 -> 1598;
3960 -> 1613;
3961 -> 3960;
3961 -> 1434;
3962 -> 3961;
3962 -> 1436;
3962 -> 1434;
3963 -> 1632;
3964 -> 3963;
3964 -> 1472;
3965 -> 3964;
3965 -> 1474;
3965 -> 1472;
3966 -> 1470;
3966 -> 1502;
3966 -> 1628;
3966 -> 3965;
3966 -> 1637;
3966 -> 1498;
3966 -> 1499;
3966 -> 3951;
3966 -> 1509;
3966 -> 1501;
3967 -> 1652;
3968 -> 3967;
3968 -> 1521;
3969 -> 3968;
3969 -> 1523;
3969 -> 1521;
3970 -> 1519;
3970 -> 1553;
3970 -> 1648;
3970 -> 3969;
3970 -> 1657;
3970 -> 1547;
3970 -> 1548;
3970 -> 3955;
3970 -> 1555;
3970 -> 1552;
3971 -> 1672;
3972 -> 3971;
3972 -> 1567;
3973 -> 3972;
3973 -> 1569;
3973 -> 1567;
3974 -> 1565;
3974 -> 1599;
3974 -> 1668;
3974 -> 3973;
3974 -> 1677;
3974 -> 1593;
3974 -> 1594;
3974 -> 3959;
3974 -> 1601;
3974 -> 1598;
3975 -> 1613;
3976 -> 3975;
3976 -> 1434;
3977 -> 3976;
3977 -> 1436;
3977 -> 1434;
3978 -> 1632;
3979 -> 3978;
3979 -> 1472;
3980 -> 3979;
3980 -> 1474;
3980 -> 1472;
3981 -> 1470;
3981 -> 1502;
3981 -> 1628;
3981 -> 3980;
3981 -> 1637;
3981 -> 1498;
3981 -> 1499;
3981 -> 3966;
3981 -> 1509;
3981 -> 1501;
3982 -> 1652;
3983 -> 3982;
3983 -> 1521;
3984 -> 3983;
3984 -> 1523;
3984 -> 1521;
3985 -> 1519;
3985 -> 1553;
3985 -> 1648;
3985 -> 3984;
3985 -> 1657;
3985 -> 1547;
3985 -> 1548;
3985 -> 3970;
3985 -> 1555;
3985 -> 1552;
3986 -> 1672;
3987 -> 3986;
3987 -> 1567;
3988 -> 3987;
3988 -> 1569;
3988 -> 1567;
3989 -> 1565;
3989 -> 1599;
3989 -> 1668;
3989 -> 3988;
3989 -> 1677;
3989 -> 1593;
3989 -> 1594;
3989 -> 3974;
3989 -> 1601;
3989 -> 1598;
3990 -> 1613;
3991 -> 3990;
3991 -> 1434;
3992 -> 3991;
3992 -> 1436;
3992 -> 1434;
3993 -> 1632;
3994 -> 3993;
3994 -> 1472;
3995 -> 3994;
3995 -> 1474;
3995 -> 1472;
3996 -> 1470;
3996 -> 1502;
3996 -> 1628;
3996 -> 3995;
3996 -> 1637;
3996 -> 1498;
3996 -> 1499;
3996 -> 3981;
3996 -> 1509;
3996 -> 1501;
3997 -> 1652;
3998 -> 3997;
3998 -> 1521;
3999 -> 3998;
3999 -> 1523;
3999 -> 1521;
4000 -> 1519;
4000 -> 1553;
4000 -> 1648;
4000 -> 3999;
4000 -> 1657;
4000 -> 1547;
4000 -> 1548;
4000 -> 3985;
4000 -> 1555;
4000 -> 1552;
4001 -> 1672;
4002 -> 4001;
4002 -> 1567;
4003 -> 4002;
4003 -> 1569;
4003 -> 1567;
4004 -> 1565;
4004 -> 1599;
4004 -> 1668;
4004 -> 4003;
4004 -> 1677;
4004 -> 1593;
4004 -> 1594;
4004 -> 3989;
4004 -> 1601;
4004 -> 1598;
4005 -> 1613;
4006 -> 4005;
4006 -> 1434;
4007 -> 4006;
4007 -> 1436;
4007 -> 1434;
4008 -> 1632;
4009 -> 4008;
4009 -> 1472;
4010 -> 4009;
4010 -> 1474;
4010 -> 1472;
4011 -> 1470;
4011 -> 1502;
4011 -> 1628;
4011 -> 4010;
4011 -> 1637;
4011 -> 1498;
4011 -> 1499;
4011 -> 3996;
4011 -> 1509;
4011 -> 1501;
4012 -> 1652;
4013 -> 4012;
4013 -> 1521;
4014 -> 4013;
4014 -> 1523;
4014 -> 1521;
4015 -> 1519;
4015 -> 1553;
4015 -> 1648;
4015 -> 4014;
4015 -> 1657;
4015 -> 1547;
4015 -> 1548;
4015 -> 4000;
4015 -> 1555;
4015 -> 1552;
4016 -> 1672;
4017 -> 4016;
4017 -> 1567;
4018 -> 4017;
4018 -> 1569;
4018 -> 1567;
4019 -> 1565;
4019 -> 1599;
4019 -> 1668;
4019 -> 4018;
4019 -> 1677;
4019 -> 1593;
4019 -> 1594;
4019 -> 4004;
4019 -> 1601;
4019 -> 1598;
4020 -> 1613;
4021 -> 4020;
4021 -> 1434;
4022 -> 4021;
4022 -> 1436;
4022 -> 1434;
4023 -> 1632;
4024 -> 4023;
4024 -> 1472;
4025 -> 4024;
4025 -> 1474;
4025 -> 1472;
4026 -> 1470;
4026 -> 1502;
4026 -> 1628;
4026 -> 4025;
4026 -> 1637;
4026 -> 1498;
4026 -> 1499;
4026 -> 4011;
4026 -> 1509;
4026 -> 1501;
4027 -> 1652;
4028 -> 4027;
4028 -> 1521;
4029 -> 4028;
4029 -> 1523;
4029 -> 1521;
4030 -> 1519;
4030 -> 1553;
4030 -> 1648;
4030 -> 4029;
4030 -> 1657;
4030 -> 1547;
4030 -> 1548;
4030 -> 4015;
4030 -> 1555;
4030 -> 1552;
4031 -> 1672;
4032 -> 4031;
4032 -> 1567;
4033 -> 4032;
4033 -> 1569;
4033 -> 1567;
4034 -> 1565;
4034 -> 1599;
4034 -> 1668;
4034 -> 4033;
4034 -> 1677;
4034 -> 1593;
4034 -> 1594;
4034 -> 4019;
4034 -> 1601;
4034 -> 1598;
4035 -> 1613;
4036 -> 4035;
4036 -> 1434;
4037 -> 4036;
4037 -> 1436;
4037 -> 1434;
4038 -> 1632;
4039 -> 4038;
4039 -> 1472;
4040 -> 4039;
4040 -> 1474;
4040 -> 1472;
4041 -> 1470;
4041 -> 1502;
4041 -> 1628;
4041 -> 4040;
4041 -> 1637;
4041 -> 1498;
4041 -> 1499;
4041 -> 4026;
4041 -> 1509;
4041 -> 1501;
4042 -> 1652;
4043 -> 4042;
4043 -> 1521;
4044 -> 4043;
4044 -> 1523;
4044 -> 1521;
4045 -> 1519;
4045 -> 1553;
4045 -> 1648;
4045 -> 4044;
4045 -> 1657;
4045 -> 1547;
4045 -> 1548;
4045 -> 4030;
4045 -> 1555;
4045 -> 1552;
4046 -> 1672;
4047 -> 4046;
4047 -> 1567;
4048 -> 4047;
4048 -> 1569;
4048 -> 1567;
4049 -> 1565;
4049 -> 1599;
4049 -> 1668;
4049 -> 4048;
4049 -> 1677;
4049 -> 1593;
4049 -> 1594;
4049 -> 4034;
4049 -> 1601;
4049 -> 1598;
4050 -> 1613;
4051 -> 4050;
4051 -> 1434;
4052 -> 4051;
4052 -> 1436;
4052 -> 1434;
4053 -> 1632;
4054 -> 4053;
4054 -> 1472;
4055 -> 4054;
4055 -> 1474;
4055 -> 1472;
4056 -> 1470;
4056 -> 1502;
4056 -> 1628;
4056 -> 4055;
4056 -> 1637;
4056 -> 1498;
4056 -> 1499;
4056 -> 4041;
4056 -> 1509;
4056 -> 1501;
4057 -> 1652;
4058 -> 4057;
4058 -> 1521;
4059 -> 4058;
4059 -> 1523;
4059 -> 1521;
4060 -> 1519;
4060 -> 1553;
4060 -> 1648;
4060 -> 4059;
4060 -> 1657;
4060 -> 1547;
4060 -> 1548;
4060 -> 4045;
4060 -> 1555;
4060 -> 1552;
4061 -> 1672;
4062 -> 4061;
4062 -> 1567;
4063 -> 4062;
4063 -> 1569;
4063 -> 1567;
4064 -> 1565;
4064 -> 1599;
4064 -> 1668;
4064 -> 4063;
4064 -> 1677;
4064 -> 1593;
4064 -> 1594;
4064 -> 4049;
4064 -> 1601;
4064 -> 1598;
4065 -> 1613;
4066 -> 4065;
4066 -> 1434;
4067 -> 4066;
4067 -> 1436;
4067 -> 1434;
4068 -> 1632;
4069 -> 4068;
4069 -> 1472;
4070 -> 4069;
4070 -> 1474;
4070 -> 1472;
4071 -> 1470;
4071 -> 1502;
4071 -> 1628;
4071 -> 4070;
4071 -> 1637;
4071 -> 1498;
4071 -> 1499;
4071 -> 4056;
4071 -> 1509;
4071 -> 1501;
4072 -> 1652;
4073 -> 4072;
4073 -> 1521;
4074 -> 4073;
4074 -> 1523;
4074 -> 1521;
4075 -> 1519;
4075 -> 1553;
4075 -> 1648;
4075 -> 4074;
4075 -> 1657;
4075 -> 1547;
4075 -> 1548;
4075 -> 4060;
4075 -> 1555;
4075 -> 1552;
4076 -> 1672;
4077 -> 4076;
4077 -> 1567;
4078 -> 4077;
4078 -> 1569;
4078 -> 1567;
4079 -> 1565;
4079 -> 1599;
4079 -> 1668;
4079 -> 4078;
4079 -> 1677;
4079 -> 1593;
4079 -> 1594;
4079 -> 4064;
4079 -> 1601;
4079 -> 1598;
4080 -> 1613;
4081 -> 4080;
4081 -> 1434;
4082 -> 4081;
4082 -> 1436;
4082 -> 1434;
4083 -> 1632;
4084 -> 4083;
4084 -> 1472;
4085 -> 4084;
4085 -> 1474;
4085 -> 1472;
4086 -> 1470;
4086 -> 1502;
4086 -> 1628;
4086 -> 4085;
4086 -> 1637;
4086 -> 1498;
4086 -> 1499;
4086 -> 4071;
4086 -> 1509;
4086 -> 1501;
4087 -> 1652;
4088 -> 4087;
4088 -> 1521;
4089 -> 4088;
4089 -> 1523;
4089 -> 1521;
4090 -> 1519;
4090 -> 1553;
4090 -> 1648;
4090 -> 4089;
4090 -> 1657;
4090 -> 1547;
4090 -> 1548;
4090 -> 4075;
4090 -> 1555;
4090 -> 1552;
4091 -> 1672;
4092 -> 4091;
4092 -> 1567;
4093 -> 4092;
4093 -> 1569;
4093 -> 1567;
4094 -> 1565;
4094 -> 1599;
4094 -> 1668;
4094 -> 4093;
4094 -> 1677;
4094 -> 1593;
4094 -> 1594;
4094 -> 4079;
4094 -> 1601;
4094 -> 1598;
4095 -> 1613;
4096 -> 4095;
4096 -> 1434;
4097 -> 4096;
4097 -> 1436;
4097 -> 1434;
4098 -> 1632;
4099 -> 4098;
4099 -> 1472;
4100 -> 4099;
4100 -> 1474;
4100 -> 1472;
4101 -> 1470;
4101 -> 1502;
4101 -> 1628;
4101 -> 4100;
4101 -> 1637;
4101 -> 1498;
4101 -> 1499;
4101 -> 4086;
4101 -> 1509;
4101 -> 1501;
4102 -> 1652;
4103 -> 4102;
4103 -> 1521;
4104 -> 4103;
4104 -> 1523;
4104 -> 1521;
4105 -> 1519;
4105 -> 1553;
4105 -> 1648;
4105 -> 4104;
4105 -> 1657;
4105 -> 1547;
4105 -> 1548;
4105 -> 4090;
4105 -> 1555;
4105 -> 1552;
4106 -> 1672;
4107 -> 4106;
4107 -> 1567;
4108 -> 4107;
4108 -> 1569;
4108 -> 1567;
4109 -> 1565;
4109 -> 1599;
4109 -> 1668;
4109 -> 4108;
4109 -> 1677;
4109 -> 1593;
4109 -> 1594;
4109 -> 4094;
4109 -> 1601;
4109 -> 1598;
4110 -> 1613;
4111 -> 4110;
4111 -> 1434;
4112 -> 4111;
4112 -> 1436;
4112 -> 1434;
4113 -> 1632;
4114 -> 4113;
4114 -> 1472;
4115 -> 4114;
4115 -> 1474;
4115 -> 1472;
4116 -> 1470;
4116 -> 1502;
4116 -> 1628;
4116 -> 4115;
4116 -> 1637;
4116 -> 1498;
4116 -> 1499;
4116 -> 4101;
4116 -> 1509;
4116 -> 1501;
4117 -> 1652;
4118 -> 4117;
4118 -> 1521;
4119 -> 4118;
4119 -> 1523;
4119 -> 1521;
4120 -> 1519;
4120 -> 1553;
4120 -> 1648;
4120 -> 4119;
4120 -> 1657;
4120 -> 1547;
4120 -> 1548;
4120 -> 4105;
4120 -> 1555;
4120 -> 1552;
4121 -> 1672;
4122 -> 4121;
4122 -> 1567;
4123 -> 4122;
4123 -> 1569;
4123 -> 1567;
4124 -> 1565;
4124 -> 1599;
4124 -> 1668;
4124 -> 4123;
4124 -> 1677;
4124 -> 1593;
4124 -> 1594;
4124 -> 4109;
4124 -> 1601;
4124 -> 1598;
4125 -> 1613;
4126 -> 4125;
4126 -> 1434;
4127 -> 4126;
4127 -> 1436;
4127 -> 1434;
4128 -> 1632;
4129 -> 4128;
4129 -> 1472;
4130 -> 4129;
4130 -> 1474;
4130 -> 1472;
4131 -> 1470;
4131 -> 1502;
4131 -> 1628;
4131 -> 4130;
4131 -> 1637;
4131 -> 1498;
4131 -> 1499;
4131 -> 4116;
4131 -> 1509;
4131 -> 1501;
4132 -> 1652;
4133 -> 4132;
4133 -> 1521;
4134 -> 4133;
4134 -> 1523;
4134 -> 1521;
4135 -> 1519;
4135 -> 1553;
4135 -> 1648;
4135 -> 4134;
4135 -> 1657;
4135 -> 1547;
4135 -> 1548;
4135 -> 4120;
4135 -> 1555;
4135 -> 1552;
4136 -> 1672;
4137 -> 4136;
4137 -> 1567;
4138 -> 4137;
4138 -> 1569;
4138 -> 1567;
4139 -> 1565;
4139 -> 1599;
4139 -> 1668;
4139 -> 4138;
4139 -> 1677;
4139 -> 1593;
4139 -> 1594;
4139 -> 4124;
4139 -> 1601;
4139 -> 1598;
4140 -> 1613;
4141 -> 4140;
4141 -> 1434;
4142 -> 4141;
4142 -> 1436;
4142 -> 1434;
4143 -> 1632;
4144 -> 4143;
4144 -> 1472;
4145 -> 4144;
4145 -> 1474;
4145 -> 1472;
4146 -> 1470;
4146 -> 1502;
4146 -> 1628;
4146 -> 4145;
4146 -> 1637;
4146 -> 1498;
4146 -> 1499;
4146 -> 4131;
4146 -> 1509;
4146 -> 1501;
4147 -> 1652;
4148 -> 4147;
4148 -> 1521;
4149 -> 4148;
4149 -> 1523;
4149 -> 1521;
4150 -> 1519;
4150 -> 1553;
4150 -> 1648;
4150 -> 4149;
4150 -> 1657;
4150 -> 1547;
4150 -> 1548;
4150 -> 4135;
4150 -> 1555;
4150 -> 1552;
4151 -> 1672;
4152 -> 4151;
4152 -> 1567;
4153 -> 4152;
4153 -> 1569;
4153 -> 1567;
4154 -> 1565;
4154 -> 1599;
4154 -> 1668;
4154 -> 4153;
4154 -> 1677;
4154 -> 1593;
4154 -> 1594;
4154 -> 4139;
4154 -> 1601;
4154 -> 1598;
4155 -> 1613;
4156 -> 4155;
4156 -> 1434;
4157 -> 4156;
4157 -> 1436;
4157 -> 1434;
4158 -> 1632;
4159 -> 4158;
4159 -> 1472;
4160 -> 4159;
4160 -> 1474;
4160 -> 1472;
4161 -> 1470;
4161 -> 1502;
4161 -> 1628;
4161 -> 4160;
4161 -> 1637;
4161 -> 1498;
4161 -> 1499;
4161 -> 4146;
4161 -> 1509;
4161 -> 1501;
4162 -> 1652;
4163 -> 4162;
4163 -> 1521;
4164 -> 4163;
4164 -> 1523;
4164 -> 1521;
4165 -> 1519;
4165 -> 1553;
4165 -> 1648;
4165 -> 4164;
4165 -> 1657;
4165 -> 1547;
4165 -> 1548;
4165 -> 4150;
4165 -> 1555;
4165 -> 1552;
4166 -> 1672;
4167 -> 4166;
4167 -> 1567;
4168 -> 4167;
4168 -> 1569;
4168 -> 1567;
4169 -> 1565;
4169 -> 1599;
4169 -> 1668;
4169 -> 4168;
4169 -> 1677;
4169 -> 1593;
4169 -> 1594;
4169 -> 4154;
4169 -> 1601;
4169 -> 1598;
4170 -> 1613;
4171 -> 4170;
4171 -> 1434;
4172 -> 4171;
4172 -> 1436;
4172 -> 1434;
4173 -> 1632;
4174 -> 4173;
4174 -> 1472;
4175 -> 4174;
4175 -> 1474;
4175 -> 1472;
4176 -> 1470;
4176 -> 1502;
4176 -> 1628;
4176 -> 4175;
4176 -> 1637;
4176 -> 1498;
4176 -> 1499;
4176 -> 4161;
4176 -> 1509;
4176 -> 1501;
4177 -> 1652;
4178 -> 4177;
4178 -> 1521;
4179 -> 4178;
4179 -> 1523;
4179 -> 1521;
4180 -> 1519;
4180 -> 1553;
4180 -> 1648;
4180 -> 4179;
4180 -> 1657;
4180 -> 1547;
4180 -> 1548;
4180 -> 4165;
4180 -> 1555;
4180 -> 1552;
4181 -> 1672;
4182 -> 4181;
4182 -> 1567;
4183 -> 4182;
4183 -> 1569;
4183 -> 1567;
4184 -> 1565;
4184 -> 1599;
4184 -> 1668;
4184 -> 4183;
4184 -> 1677;
4184 -> 1593;
4184 -> 1594;
4184 -> 4169;
4184 -> 1601;
4184 -> 1598;
4185 -> 1613;
4186 -> 4185;
4186 -> 1434;
4187 -> 4186;
4187 -> 1436;
4187 -> 1434;
4188 -> 1632;
4189 -> 4188;
4189 -> 1472;
4190 -> 4189;
4190 -> 1474;
4190 -> 1472;
4191 -> 1470;
4191 -> 1502;
4191 -> 1628;
4191 -> 4190;
4191 -> 1637;
4191 -> 1498;
4191 -> 1499;
4191 -> 4176;
4191 -> 1509;
4191 -> 1501;
4192 -> 1652;
4193 -> 4192;
4193 -> 1521;
4194 -> 4193;
4194 -> 1523;
4194 -> 1521;
4195 -> 1519;
4195 -> 1553;
4195 -> 1648;
4195 -> 4194;
4195 -> 1657;
4195 -> 1547;
4195 -> 1548;
4195 -> 4180;
4195 -> 1555;
4195 -> 1552;
4196 -> 1672;
4197 -> 4196;
4197 -> 1567;
4198 -> 4197;
4198 -> 1569;
4198 -> 1567;
4199 -> 1565;
4199 -> 1599;
4199 -> 1668;
4199 -> 4198;
4199 -> 1677;
4199 -> 1593;
4199 -> 1594;
4199 -> 4184;
4199 -> 1601;
4199 -> 1598;
4200 -> 1613;
4201 -> 4200;
4201 -> 1434;
4202 -> 4201;
4202 -> 1436;
4202 -> 1434;
4203 -> 1632;
4204 -> 4203;
4204 -> 1472;
4205 -> 4204;
4205 -> 1474;
4205 -> 1472;
4206 -> 1470;
4206 -> 1502;
4206 -> 1628;
4206 -> 4205;
4206 -> 1637;
4206 -> 1498;
4206 -> 1499;
4206 -> 4191;
4206 -> 1509;
4206 -> 1501;
4207 -> 1652;
4208 -> 4207;
4208 -> 1521;
4209 -> 4208;
4209 -> 1523;
4209 -> 1521;
4210 -> 1519;
4210 -> 1553;
4210 -> 1648;
4210 -> 4209;
4210 -> 1657;
4210 -> 1547;
4210 -> 1548;
4210 -> 4195;
4210 -> 1555;
4210 -> 1552;
4211 -> 1672;
4212 -> 4211;
4212 -> 1567;
4213 -> 4212;
4213 -> 1569;
4213 -> 1567;
4214 -> 1565;
4214 -> 1599;
4214 -> 1668;
4214 -> 4213;
4214 -> 1677;
4214 -> 1593;
4214 -> 1594;
4214 -> 4199;
4214 -> 1601;
4214 -> 1598;
4215 -> 1613;
4216 -> 4215;
4216 -> 1434;
4217 -> 4216;
4217 -> 1436;
4217 -> 1434;
4218 -> 1632;
4219 -> 4218;
4219 -> 1472;
4220 -> 4219;
4220 -> 1474;
4220 -> 1472;
4221 -> 1470;
4221 -> 1502;
4221 -> 1628;
4221 -> 4220;
4221 -> 1637;
4221 -> 1498;
4221 -> 1499;
4221 -> 4206;
4221 -> 1509;
4221 -> 1501;
4222 -> 1652;
4223 -> 4222;
4223 -> 1521;
4224 -> 4223;
4224 -> 1523;
4224 -> 1521;
4225 -> 1519;
4225 -> 1553;
4225 -> 1648;
4225 -> 4224;
4225 -> 1657;
4225 -> 1547;
4225 -> 1548;
4225 -> 4210;
4225 -> 1555;
4225 -> 1552;
4226 -> 1672;
4227 -> 4226;
4227 -> 1567;
4228 -> 4227;
4228 -> 1569;
4228 -> 1567;
4229 -> 1565;
4229 -> 1599;
4229 -> 1668;
4229 -> 4228;
4229 -> 1677;
4229 -> 1593;
4229 -> 1594;
4229 -> 4214;
4229 -> 1601;
4229 -> 1598;
4230 -> 1613;
4231 -> 4230;
4231 -> 1434;
4232 -> 4231;
4232 -> 1436;
4232 -> 1434;
4233 -> 1632;
4234 -> 4233;
4234 -> 1472;
4235 -> 4234;
4235 -> 1474;
4235 -> 1472;
4236 -> 1470;
4236 -> 1502;
4236 -> 1628;
4236 -> 4235;
4236 -> 1637;
4236 -> 1498;
4236 -> 1499;
4236 -> 4221;
4236 -> 1509;
4236 -> 1501;
4237 -> 1652;
4238 -> 4237;
4238 -> 1521;
4239 -> 4238;
4239 -> 1523;
4239 -> 1521;
4240 -> 1519;
4240 -> 1553;
4240 -> 1648;
4240 -> 4239;
4240 -> 1657;
4240 -> 1547;
4240 -> 1548;
4240 -> 4225;
4240 -> 1555;
4240 -> 1552;
4241 -> 1672;
4242 -> 4241;
4242 -> 1567;
4243 -> 4242;
4243 -> 1569;
4243 -> 1567;
4244 -> 1565;
4244 -> 1599;
4244 -> 1668;
4244 -> 4243;
4244 -> 1677;
4244 -> 1593;
4244 -> 1594;
4244 -> 4229;
4244 -> 1601;
4244 -> 1598;
4245 -> 1613;
4246 -> 4245;
4246 -> 1434;
4247 -> 4246;
4247 -> 1436;
4247 -> 1434;
4248 -> 1632;
4249 -> 4248;
4249 -> 1472;
4250 -> 4249;
4250 -> 1474;
4250 -> 1472;
4251 -> 1470;
4251 -> 1502;
4251 -> 1628;
4251 -> 4250;
4251 -> 1637;
4251 -> 1498;
4251 -> 1499;
4251 -> 4236;
4251 -> 1509;
4251 -> 1501;
4252 -> 1652;
4253 -> 4252;
4253 -> 1521;
4254 -> 4253;
4254 -> 1523;
4254 -> 1521;
4255 -> 1519;
4255 -> 1553;
4255 -> 1648;
4255 -> 4254;
4255 -> 1657;
4255 -> 1547;
4255 -> 1548;
4255 -> 4240;
4255 -> 1555;
4255 -> 1552;
4256 -> 1672;
4257 -> 4256;
4257 -> 1567;
4258 -> 4257;
4258 -> 1569;
4258 -> 1567;
4259 -> 1565;
4259 -> 1599;
4259 -> 1668;
4259 -> 4258;
4259 -> 1677;
4259 -> 1593;
4259 -> 1594;
4259 -> 4244;
4259 -> 1601;
4259 -> 1598;
4260 -> 1613;
4261 -> 4260;
4261 -> 1434;
4262 -> 4261;
4262 -> 1436;
4262 -> 1434;
4263 -> 1632;
4264 -> 4263;
4264 -> 1472;
4265 -> 4264;
4265 -> 1474;
4265 -> 1472;
4266 -> 1470;
4266 -> 1502;
4266 -> 1628;
4266 -> 4265;
4266 -> 1637;
4266 -> 1498;
4266 -> 1499;
4266 -> 4251;
4266 -> 1509;
4266 -> 1501;
4267 -> 1652;
4268 -> 4267;
4268 -> 1521;
4269 -> 4268;
4269 -> 1523;
4269 -> 1521;
4270 -> 1519;
4270 -> 1553;
4270 -> 1648;
4270 -> 4269;
4270 -> 1657;
4270 -> 1547;
4270 -> 1548;
4270 -> 4255;
4270 -> 1555;
4270 -> 1552;
4271 -> 1672;
4272 -> 4271;
4272 -> 1567;
4273 -> 4272;
4273 -> 1569;
4273 -> 1567;
4274 -> 1565;
4274 -> 1599;
4274 -> 1668;
4274 -> 4273;
4274 -> 1677;
4274 -> 1593;
4274 -> 1594;
4274 -> 4259;
4274 -> 1601;
4274 -> 1598;
4275 -> 1613;
4276 -> 4275;
4276 -> 1434;
4277 -> 4276;
4277 -> 1436;
4277 -> 1434;
4278 -> 1632;
4279 -> 4278;
4279 -> 1472;
4280 -> 4279;
4280 -> 1474;
4280 -> 1472;
4281 -> 1470;
4281 -> 1502;
4281 -> 1628;
4281 -> 4280;
4281 -> 1637;
4281 -> 1498;
4281 -> 1499;
4281 -> 4266;
4281 -> 1509;
4281 -> 1501;
4282 -> 1652;
4283 -> 4282;
4283 -> 1521;
4284 -> 4283;
4284 -> 1523;
4284 -> 1521;
4285 -> 1519;
4285 -> 1553;
4285 -> 1648;
4285 -> 4284;
4285 -> 1657;
4285 -> 1547;
4285 -> 1548;
4285 -> 4270;
4285 -> 1555;
4285 -> 1552;
4286 -> 1672;
4287 -> 4286;
4287 -> 1567;
4288 -> 4287;
4288 -> 1569;
4288 -> 1567;
4289 -> 1565;
4289 -> 1599;
4289 -> 1668;
4289 -> 4288;
4289 -> 1677;
4289 -> 1593;
4289 -> 1594;
4289 -> 4274;
4289 -> 1601;
4289 -> 1598;
4290 -> 1613;
4291 -> 4290;
4291 -> 1434;
4292 -> 4291;
4292 -> 1436;
4292 -> 1434;
4293 -> 1632;
4294 -> 4293;
4294 -> 1472;
4295 -> 4294;
4295 -> 1474;
4295 -> 1472;
4296 -> 1470;
4296 -> 1502;
4296 -> 1628;
4296 -> 4295;
4296 -> 1637;
4296 -> 1498;
4296 -> 1499;
4296 -> 4281;
4296 -> 1509;
4296 -> 1501;
4297 -> 1652;
4298 -> 4297;
4298 -> 1521;
4299 -> 4298;
4299 -> 1523;
4299 -> 1521;
4300 -> 1519;
4300 -> 1553;
4300 -> 1648;
4300 -> 4299;
4300 -> 1657;
4300 -> 1547;
4300 -> 1548;
4300 -> 4285;
4300 -> 1555;
4300 -> 1552;
4301 -> 1672;
4302 -> 4301;
4302 -> 1567;
4303 -> 4302;
4303 -> 1569;
4303 -> 1567;
4304 -> 1565;
4304 -> 1599;
4304 -> 1668;
4304 -> 4303;
4304 -> 1677;
4304 -> 1593;
4304 -> 1594;
4304 -> 4289;
4304 -> 1601;
4304 -> 1598;
4305 -> 1613;
4306 -> 4305;
4306 -> 1434;
4307 -> 4306;
4307 -> 1436;
4307 -> 1434;
4308 -> 1632;
4309 -> 4308;
4309 -> 1472;
4310 -> 4309;
4310 -> 1474;
4310 -> 1472;
4311 -> 1470;
4311 -> 1502;
4311 -> 1628;
4311 -> 4310;
4311 -> 1637;
4311 -> 1498;
4311 -> 1499;
4311 -> 4296;
4311 -> 1509;
4311 -> 1501;
4312 -> 1652;
4313 -> 4312;
4313 -> 1521;
4314 -> 4313;
4314 -> 1523;
4314 -> 1521;
4315 -> 1519;
4315 -> 1553;
4315 -> 1648;
4315 -> 4314;
4315 -> 1657;
4315 -> 1547;
4315 -> 1548;
4315 -> 4300;
4315 -> 1555;
4315 -> 1552;
4316 -> 1672;
4317 -> 4316;
4317 -> 1567;
4318 -> 4317;
4318 -> 1569;
4318 -> 1567;
4319 -> 1565;
4319 -> 1599;
4319 -> 1668;
4319 -> 4318;
4319 -> 1677;
4319 -> 1593;
4319 -> 1594;
4319 -> 4304;
4319 -> 1601;
4319 -> 1598;
4320 -> 1613;
4321 -> 4320;
4321 -> 1434;
4322 -> 4321;
4322 -> 1436;
4322 -> 1434;
4323 -> 1632;
4324 -> 4323;
4324 -> 1472;
4325 -> 4324;
4325 -> 1474;
4325 -> 1472;
4326 -> 1470;
4326 -> 1502;
4326 -> 1628;
4326 -> 4325;
4326 -> 1637;
4326 -> 1498;
4326 -> 1499;
4326 -> 4311;
4326 -> 1509;
4326 -> 1501;
4327 -> 1652;
4328 -> 4327;
4328 -> 1521;
4329 -> 4328;
4329 -> 1523;
4329 -> 1521;
4330 -> 1519;
4330 -> 1553;
4330 -> 1648;
4330 -> 4329;
4330 -> 1657;
4330 -> 1547;
4330 -> 1548;
4330 -> 4315;
4330 -> 1555;
4330 -> 1552;
4331 -> 1672;
4332 -> 4331;
4332 -> 1567;
4333 -> 4332;
4333 -> 1569;
4333 -> 1567;
4334 -> 1565;
4334 -> 1599;
4334 -> 1668;
4334 -> 4333;
4334 -> 1677;
4334 -> 1593;
4334 -> 1594;
4334 -> 4319;
4334 -> 1601;
4334 -> 1598;
4335 -> 1613;
4336 -> 4335;
4336 -> 1434;
4337 -> 4336;
4337 -> 1436;
4337 -> 1434;
4338 -> 1632;
4339 -> 4338;
4339 -> 1472;
4340 -> 4339;
4340 -> 1474;
4340 -> 1472;
4341 -> 1470;
4341 -> 1502;
4341 -> 1628;
4341 -> 4340;
4341 -> 1637;
4341 -> 1498;
4341 -> 1499;
4341 -> 4326;
4341 -> 1509;
4341 -> 1501;
4342 -> 1652;
4343 -> 4342;
4343 -> 1521;
4344 -> 4343;
4344 -> 1523;
4344 -> 1521;
4345 -> 1519;
4345 -> 1553;
4345 -> 1648;
4345 -> 4344;
4345 -> 1657;
4345 -> 1547;
4345 -> 1548;
4345 -> 4330;
4345 -> 1555;
4345 -> 1552;
4346 -> 1672;
4347 -> 4346;
4347 -> 1567;
4348 -> 4347;
4348 -> 1569;
4348 -> 1567;
4349 -> 1565;
4349 -> 1599;
4349 -> 1668;
4349 -> 4348;
4349 -> 1677;
4349 -> 1593;
4349 -> 1594;
4349 -> 4334;
4349 -> 1601;
4349 -> 1598;
4350 -> 1613;
4351 -> 4350;
4351 -> 1434;
4352 -> 4351;
4352 -> 1436;
4352 -> 1434;
4353 -> 1632;
4354 -> 4353;
4354 -> 1472;
4355 -> 4354;
4355 -> 1474;
4355 -> 1472;
4356 -> 1470;
4356 -> 1502;
4356 -> 1628;
4356 -> 4355;
4356 -> 1637;
4356 -> 1498;
4356 -> 1499;
4356 -> 4341;
4356 -> 1509;
4356 -> 1501;
4357 -> 1652;
4358 -> 4357;
4358 -> 1521;
4359 -> 4358;
4359 -> 1523;
4359 -> 1521;
4360 -> 1519;
4360 -> 1553;
4360 -> 1648;
4360 -> 4359;
4360 -> 1657;
4360 -> 1547;
4360 -> 1548;
4360 -> 4345;
4360 -> 1555;
4360 -> 1552;
4361 -> 1672;
4362 -> 4361;
4362 -> 1567;
4363 -> 4362;
4363 -> 1569;
4363 -> 1567;
4364 -> 1565;
4364 -> 1599;
4364 -> 1668;
4364 -> 4363;
4364 -> 1677;
4364 -> 1593;
4364 -> 1594;
4364 -> 4349;
4364 -> 1601;
4364 -> 1598;
4365 -> 1613;
4366 -> 4365;
4366 -> 1434;
4367 -> 4366;
4367 -> 1436;
4367 -> 1434;
4368 -> 1632;
4369 -> 4368;
4369 -> 1472;
4370 -> 4369;
4370 -> 1474;
4370 -> 1472;
4371 -> 1470;
4371 -> 1502;
4371 -> 1628;
4371 -> 4370;
4371 -> 1637;
4371 -> 1498;
4371 -> 1499;
4371 -> 4356;
4371 -> 1509;
4371 -> 1501;
4372 -> 1652;
4373 -> 4372;
4373 -> 1521;
4374 -> 4373;
4374 -> 1523;
4374 -> 1521;
4375 -> 1519;
4375 -> 1553;
4375 -> 1648;
4375 -> 4374;
4375 -> 1657;
4375 -> 1547;
4375 -> 1548;
4375 -> 4360;
4375 -> 1555;
4375 -> 1552;
4376 -> 1672;
4377 -> 4376;
4377 -> 1567;
4378 -> 4377;
4378 -> 1569;
4378 -> 1567;
4379 -> 1565;
4379 -> 1599;
4379 -> 1668;
4379 -> 4378;
4379 -> 1677;
4379 -> 1593;
4379 -> 1594;
4379 -> 4364;
4379 -> 1601;
4379 -> 1598;
4380 -> 1613;
4381 -> 4380;
4381 -> 1434;
4382 -> 4381;
4382 -> 1436;
4382 -> 1434;
4383 -> 1632;
4384 -> 4383;
4384 -> 1472;
4385 -> 4384;
4385 -> 1474;
4385 -> 1472;
4386 -> 1470;
4386 -> 1502;
4386 -> 1628;
4386 -> 4385;
4386 -> 1637;
4386 -> 1498;
4386 -> 1499;
4386 -> 4371;
4386 -> 1509;
4386 -> 1501;
4387 -> 1652;
4388 -> 4387;
4388 -> 1521;
4389 -> 4388;
4389 -> 1523;
4389 -> 1521;
4390 -> 1519;
4390 -> 1553;
4390 -> 1648;
4390 -> 4389;
4390 -> 1657;
4390 -> 1547;
4390 -> 1548;
4390 -> 4375;
4390 -> 1555;
4390 -> 1552;
4391 -> 1672;
4392 -> 4391;
4392 -> 1567;
4393 -> 4392;
4393 -> 1569;
4393 -> 1567;
4394 -> 1565;
4394 -> 1599;
4394 -> 1668;
4394 -> 4393;
4394 -> 1677;
4394 -> 1593;
4394 -> 1594;
4394 -> 4379;
4394 -> 1601;
4394 -> 1598;
4395 -> 1613;
4396 -> 4395;
4396 -> 1434;
4397 -> 4396;
4397 -> 1436;
4397 -> 1434;
4398 -> 1632;
4399 -> 4398;
4399 -> 1472;
4400 -> 4399;
4400 -> 1474;
4400 -> 1472;
4401 -> 1470;
4401 -> 1502;
4401 -> 1628;
4401 -> 4400;
4401 -> 1637;
4401 -> 1498;
4401 -> 1499;
4401 -> 4386;
4401 -> 1509;
4401 -> 1501;
4402 -> 1652;
4403 -> 4402;
4403 -> 1521;
4404 -> 4403;
4404 -> 1523;
4404 -> 1521;
4405 -> 1519;
4405 -> 1553;
4405 -> 1648;
4405 -> 4404;
4405 -> 1657;
4405 -> 1547;
4405 -> 1548;
4405 -> 4390;
4405 -> 1555;
4405 -> 1552;
4406 -> 1672;
4407 -> 4406;
4407 -> 1567;
4408 -> 4407;
4408 -> 1569;
4408 -> 1567;
4409 -> 1565;
4409 -> 1599;
4409 -> 1668;
4409 -> 4408;
4409 -> 1677;
4409 -> 1593;
4409 -> 1594;
4409 -> 4394;
4409 -> 1601;
4409 -> 1598;
4410 -> 1613;
4411 -> 4410;
4411 -> 1434;
4412 -> 4411;
4412 -> 1436;
4412 -> 1434;
4413 -> 1632;
4414 -> 4413;
4414 -> 1472;
4415 -> 4414;
4415 -> 1474;
4415 -> 1472;
4416 -> 1470;
4416 -> 1502;
4416 -> 1628;
4416 -> 4415;
4416 -> 1637;
4416 -> 1498;
4416 -> 1499;
4416 -> 4401;
4416 -> 1509;
4416 -> 1501;
4417 -> 1652;
4418 -> 4417;
4418 -> 1521;
4419 -> 4418;
4419 -> 1523;
4419 -> 1521;
4420 -> 1519;
4420 -> 1553;
4420 -> 1648;
4420 -> 4419;
4420 -> 1657;
4420 -> 1547;
4420 -> 1548;
4420 -> 4405;
4420 -> 1555;
4420 -> 1552;
4421 -> 1672;
4422 -> 4421;
4422 -> 1567;
4423 -> 4422;
4423 -> 1569;
4423 -> 1567;
4424 -> 1565;
4424 -> 1599;
4424 -> 1668;
4424 -> 4423;
4424 -> 1677;
4424 -> 1593;
4424 -> 1594;
4424 -> 4409;
4424 -> 1601;
4424 -> 1598;
4425 -> 1613;
4426 -> 4425;
4426 -> 1434;
4427 -> 4426;
4427 -> 1436;
4427 -> 1434;
4428 -> 1632;
4429 -> 4428;
4429 -> 1472;
4430 -> 4429;
4430 -> 1474;
4430 -> 1472;
4431 -> 1470;
4431 -> 1502;
4431 -> 1628;
4431 -> 4430;
4431 -> 1637;
4431 -> 1498;
4431 -> 1499;
4431 -> 4416;
4431 -> 1509;
4431 -> 1501;
4432 -> 1652;
4433 -> 4432;
4433 -> 1521;
4434 -> 4433;
4434 -> 1523;
4434 -> 1521;
4435 -> 1519;
4435 -> 1553;
4435 -> 1648;
4435 -> 4434;
4435 -> 1657;
4435 -> 1547;
4435 -> 1548;
4435 -> 4420;
4435 -> 1555;
4435 -> 1552;
4436 -> 1672;
4437 -> 4436;
4437 -> 1567;
4438 -> 4437;
4438 -> 1569;
4438 -> 1567;
4439 -> 1565;
4439 -> 1599;
4439 -> 1668;
4439 -> 4438;
4439 -> 1677;
4439 -> 1593;
4439 -> 1594;
4439 -> 4424;
4439 -> 1601;
4439 -> 1598;
4440 -> 1613;
4441 -> 4440;
4441 -> 1434;
4442 -> 4441;
4442 -> 1436;
4442 -> 1434;
4443 -> 1632;
4444 -> 4443;
4444 -> 1472;
4445 -> 4444;
4445 -> 1474;
4445 -> 1472;
4446 -> 1470;
4446 -> 1502;
4446 -> 1628;
4446 -> 4445;
4446 -> 1637;
4446 -> 1498;
4446 -> 1499;
4446 -> 4431;
4446 -> 1509;
4446 -> 1501;
4447 -> 1652;
4448 -> 4447;
4448 -> 1521;
4449 -> 4448;
4449 -> 1523;
4449 -> 1521;
4450 -> 1519;
4450 -> 1553;
4450 -> 1648;
4450 -> 4449;
4450 -> 1657;
4450 -> 1547;
4450 -> 1548;
4450 -> 4435;
4450 -> 1555;
4450 -> 1552;
4451 -> 1672;
4452 -> 4451;
4452 -> 1567;
4453 -> 4452;
4453 -> 1569;
4453 -> 1567;
4454 -> 1565;
4454 -> 1599;
4454 -> 1668;
4454 -> 4453;
4454 -> 1677;
4454 -> 1593;
4454 -> 1594;
4454 -> 4439;
4454 -> 1601;
4454 -> 1598;
4455 -> 1613;
4456 -> 4455;
4456 -> 1434;
4457 -> 4456;
4457 -> 1436;
4457 -> 1434;
4458 -> 1632;
4459 -> 4458;
4459 -> 1472;
4460 -> 4459;
4460 -> 1474;
4460 -> 1472;
4461 -> 1470;
4461 -> 1502;
4461 -> 1628;
4461 -> 4460;
4461 -> 1637;
4461 -> 1498;
4461 -> 1499;
4461 -> 4446;
4461 -> 1509;
4461 -> 1501;
4462 -> 1652;
4463 -> 4462;
4463 -> 1521;
4464 -> 4463;
4464 -> 1523;
4464 -> 1521;
4465 -> 1519;
4465 -> 1553;
4465 -> 1648;
4465 -> 4464;
4465 -> 1657;
4465 -> 1547;
4465 -> 1548;
4465 -> 4450;
4465 -> 1555;
4465 -> 1552;
4466 -> 1672;
4467 -> 4466;
4467 -> 1567;
4468 -> 4467;
4468 -> 1569;
4468 -> 1567;
4469 -> 1565;
4469 -> 1599;
4469 -> 1668;
4469 -> 4468;
4469 -> 1677;
4469 -> 1593;
4469 -> 1594;
4469 -> 4454;
4469 -> 1601;
4469 -> 1598;
4470 -> 1613;
4471 -> 4470;
4471 -> 1434;
4472 -> 4471;
4472 -> 1436;
4472 -> 1434;
4473 -> 1632;
4474 -> 4473;
4474 -> 1472;
4475 -> 4474;
4475 -> 1474;
4475 -> 1472;
4476 -> 1470;
4476 -> 1502;
4476 -> 1628;
4476 -> 4475;
4476 -> 1637;
4476 -> 1498;
4476 -> 1499;
4476 -> 4461;
4476 -> 1509;
4476 -> 1501;
4477 -> 1652;
4478 -> 4477;
4478 -> 1521;
4479 -> 4478;
4479 -> 1523;
4479 -> 1521;
4480 -> 1519;
4480 -> 1553;
4480 -> 1648;
4480 -> 4479;
4480 -> 1657;
4480 -> 1547;
4480 -> 1548;
4480 -> 4465;
4480 -> 1555;
4480 -> 1552;
4481 -> 1672;
4482 -> 4481;
4482 -> 1567;
4483 -> 4482;
4483 -> 1569;
4483 -> 1567;
4484 -> 1565;
4484 -> 1599;
4484 -> 1668;
4484 -> 4483;
4484 -> 1677;
4484 -> 1593;
4484 -> 1594;
4484 -> 4469;
4484 -> 1601;
4484 -> 1598;
4485 -> 1613;
4486 -> 4485;
4486 -> 1434;
4487 -> 4486;
4487 -> 1436;
4487 -> 1434;
4488 -> 1632;
4489 -> 4488;
4489 -> 1472;
4490 -> 4489;
4490 -> 1474;
4490 -> 1472;
4491 -> 1470;
4491 -> 1502;
4491 -> 1628;
4491 -> 4490;
4491 -> 1637;
4491 -> 1498;
4491 -> 1499;
4491 -> 4476;
4491 -> 1509;
4491 -> 1501;
4492 -> 1652;
4493 -> 4492;
4493 -> 1521;
4494 -> 4493;
4494 -> 1523;
4494 -> 1521;
4495 -> 1519;
4495 -> 1553;
4495 -> 1648;
4495 -> 4494;
4495 -> 1657;
4495 -> 1547;
4495 -> 1548;
4495 -> 4480;
4495 -> 1555;
4495 -> 1552;
4496 -> 1672;
4497 -> 4496;
4497 -> 1567;
4498 -> 4497;
4498 -> 1569;
4498 -> 1567;
4499 -> 1565;
4499 -> 1599;
4499 -> 1668;
4499 -> 4498;
4499 -> 1677;
4499 -> 1593;
4499 -> 1594;
4499 -> 4484;
4499 -> 1601;
4499 -> 1598;
4500 -> 1613;
4501 -> 4500;
4501 -> 1434;
4502 -> 4501;
4502 -> 1436;
4502 -> 1434;
4503 -> 1632;
4504 -> 4503;
4504 -> 1472;
4505 -> 4504;
4505 -> 1474;
4505 -> 1472;
4506 -> 1470;
4506 -> 1502;
4506 -> 1628;
4506 -> 4505;
4506 -> 1637;
4506 -> 1498;
4506 -> 1499;
4506 -> 4491;
4506 -> 1509;
4506 -> 1501;
4507 -> 1652;
4508 -> 4507;
4508 -> 1521;
4509 -> 4508;
4509 -> 1523;
4509 -> 1521;
4510 -> 1519;
4510 -> 1553;
4510 -> 1648;
4510 -> 4509;
4510 -> 1657;
4510 -> 1547;
4510 -> 1548;
4510 -> 4495;
4510 -> 1555;
4510 -> 1552;
4511 -> 1672;
4512 -> 4511;
4512 -> 1567;
4513 -> 4512;
4513 -> 1569;
4513 -> 1567;
4514 -> 1565;
4514 -> 1599;
4514 -> 1668;
4514 -> 4513;
4514 -> 1677;
4514 -> 1593;
4514 -> 1594;
4514 -> 4499;
4514 -> 1601;
4514 -> 1598;
4515 -> 1613;
4516 -> 4515;
4516 -> 1434;
4517 -> 4516;
4517 -> 1436;
4517 -> 1434;
4518 -> 1632;
4519 -> 4518;
4519 -> 1472;
4520 -> 4519;
4520 -> 1474;
4520 -> 1472;
4521 -> 1470;
4521 -> 1502;
4521 -> 1628;
4521 -> 4520;
4521 -> 1637;
4521 -> 1498;
4521 -> 1499;
4521 -> 4506;
4521 -> 1509;
4521 -> 1501;
4522 -> 1652;
4523 -> 4522;
4523 -> 1521;
4524 -> 4523;
4524 -> 1523;
4524 -> 1521;
4525 -> 1519;
4525 -> 1553;
4525 -> 1648;
4525 -> 4524;
4525 -> 1657;
4525 -> 1547;
4525 -> 1548;
4525 -> 4510;
4525 -> 1555;
4525 -> 1552;
4526 -> 1672;
4527 -> 4526;
4527 -> 1567;
4528 -> 4527;
4528 -> 1569;
4528 -> 1567;
4529 -> 1565;
4529 -> 1599;
4529 -> 1668;
4529 -> 4528;
4529 -> 1677;
4529 -> 1593;
4529 -> 1594;
4529 -> 4514;
4529 -> 1601;
4529 -> 1598;
4530 -> 1613;
4531 -> 4530;
4531 -> 1434;
4532 -> 4531;
4532 -> 1436;
4532 -> 1434;
4533 -> 1632;
4534 -> 4533;
4534 -> 1472;
4535 -> 4534;
4535 -> 1474;
4535 -> 1472;
4536 -> 1470;
4536 -> 1502;
4536 -> 1628;
4536 -> 4535;
4536 -> 1637;
4536 -> 1498;
4536 -> 1499;
4536 -> 4521;
4536 -> 1509;
4536 -> 1501;
4537 -> 1652;
4538 -> 4537;
4538 -> 1521;
4539 -> 4538;
4539 -> 1523;
4539 -> 1521;
4540 -> 1519;
4540 -> 1553;
4540 -> 1648;
4540 -> 4539;
4540 -> 1657;
4540 -> 1547;
4540 -> 1548;
4540 -> 4525;
4540 -> 1555;
4540 -> 1552;
4541 -> 1672;
4542 -> 4541;
4542 -> 1567;
4543 -> 4542;
4543 -> 1569;
4543 -> 1567;
4544 -> 1565;
4544 -> 1599;
4544 -> 1668;
4544 -> 4543;
4544 -> 1677;
4544 -> 1593;
4544 -> 1594;
4544 -> 4529;
4544 -> 1601;
4544 -> 1598;
4545 -> 1613;
4546 -> 4545;
4546 -> 1434;
4547 -> 4546;
4547 -> 1436;
4547 -> 1434;
4548 -> 1632;
4549 -> 4548;
4549 -> 1472;
4550 -> 4549;
4550 -> 1474;
4550 -> 1472;
4551 -> 1470;
4551 -> 1502;
4551 -> 1628;
4551 -> 4550;
4551 -> 1637;
4551 -> 1498;
4551 -> 1499;
4551 -> 4536;
4551 -> 1509;
4551 -> 1501;
4552 -> 1652;
4553 -> 4552;
4553 -> 1521;
4554 -> 4553;
4554 -> 1523;
4554 -> 1521;
4555 -> 1519;
4555 -> 1553;
4555 -> 1648;
4555 -> 4554;
4555 -> 1657;
4555 -> 1547;
4555 -> 1548;
4555 -> 4540;
4555 -> 1555;
4555 -> 1552;
4556 -> 1672;
4557 -> 4556;
4557 -> 1567;
4558 -> 4557;
4558 -> 1569;
4558 -> 1567;
4559 -> 1565;
4559 -> 1599;
4559 -> 1668;
4559 -> 4558;
4559 -> 1677;
4559 -> 1593;
4559 -> 1594;
4559 -> 4544;
4559 -> 1601;
4559 -> 1598;
4560 -> 1613;
4561 -> 4560;
4561 -> 1434;
4562 -> 4561;
4562 -> 1436;
4562 -> 1434;
4563 -> 1632;
4564 -> 4563;
4564 -> 1472;
4565 -> 4564;
4565 -> 1474;
4565 -> 1472;
4566 -> 1470;
4566 -> 1502;
4566 -> 1628;
4566 -> 4565;
4566 -> 1637;
4566 -> 1498;
4566 -> 1499;
4566 -> 4551;
4566 -> 1509;
4566 -> 1501;
4567 -> 1652;
4568 -> 4567;
4568 -> 1521;
4569 -> 4568;
4569 -> 1523;
4569 -> 1521;
4570 -> 1519;
4570 -> 1553;
4570 -> 1648;
4570 -> 4569;
4570 -> 1657;
4570 -> 1547;
4570 -> 1548;
4570 -> 4555;
4570 -> 1555;
4570 -> 1552;
4571 -> 1672;
4572 -> 4571;
4572 -> 1567;
4573 -> 4572;
4573 -> 1569;
4573 -> 1567;
4574 -> 1565;
4574 -> 1599;
4574 -> 1668;
4574 -> 4573;
4574 -> 1677;
4574 -> 1593;
4574 -> 1594;
4574 -> 4559;
4574 -> 1601;
4574 -> 1598;
4575 -> 1613;
4576 -> 4575;
4576 -> 1434;
4577 -> 4576;
4577 -> 1436;
4577 -> 1434;
4578 -> 1632;
4579 -> 4578;
4579 -> 1472;
4580 -> 4579;
4580 -> 1474;
4580 -> 1472;
4581 -> 1470;
4581 -> 1502;
4581 -> 1628;
4581 -> 4580;
4581 -> 1637;
4581 -> 1498;
4581 -> 1499;
4581 -> 4566;
4581 -> 1509;
4581 -> 1501;
4582 -> 1652;
4583 -> 4582;
4583 -> 1521;
4584 -> 4583;
4584 -> 1523;
4584 -> 1521;
4585 -> 1519;
4585 -> 1553;
4585 -> 1648;
4585 -> 4584;
4585 -> 1657;
4585 -> 1547;
4585 -> 1548;
4585 -> 4570;
4585 -> 1555;
4585 -> 1552;
4586 -> 1672;
4587 -> 4586;
4587 -> 1567;
4588 -> 4587;
4588 -> 1569;
4588 -> 1567;
4589 -> 1565;
4589 -> 1599;
4589 -> 1668;
4589 -> 4588;
4589 -> 1677;
4589 -> 1593;
4589 -> 1594;
4589 -> 4574;
4589 -> 1601;
4589 -> 1598;
4590 -> 1613;
4591 -> 4590;
4591 -> 1434;
4592 -> 4591;
4592 -> 1436;
4592 -> 1434;
4593 -> 1632;
4594 -> 4593;
4594 -> 1472;
4595 -> 4594;
4595 -> 1474;
4595 -> 1472;
4596 -> 1470;
4596 -> 1502;
4596 -> 1628;
4596 -> 4595;
4596 -> 1637;
4596 -> 1498;
4596 -> 1499;
4596 -> 4581;
4596 -> 1509;
4596 -> 1501;
4597 -> 1652;
4598 -> 4597;
4598 -> 1521;
4599 -> 4598;
4599 -> 1523;
4599 -> 1521;
4600 -> 1519;
4600 -> 1553;
4600 -> 1648;
4600 -> 4599;
4600 -> 1657;
4600 -> 1547;
4600 -> 1548;
4600 -> 4585;
4600 -> 1555;
4600 -> 1552;
4601 -> 1672;
4602 -> 4601;
4602 -> 1567;
4603 -> 4602;
4603 -> 1569;
4603 -> 1567;
4604 -> 1565;
4604 -> 1599;
4604 -> 1668;
4604 -> 4603;
4604 -> 1677;
4604 -> 1593;
4604 -> 1594;
4604 -> 4589;
4604 -> 1601;
4604 -> 1598;
4605 -> 1613;
4606 -> 4605;
4606 -> 1434;
4607 -> 4606;
4607 -> 1436;
4607 -> 1434;
4608 -> 1632;
4609 -> 4608;
4609 -> 1472;
4610 -> 4609;
4610 -> 1474;
4610 -> 1472;
4611 -> 1470;
4611 -> 1502;
4611 -> 1628;
4611 -> 4610;
4611 -> 1637;
4611 -> 1498;
4611 -> 1499;
4611 -> 4596;
4611 -> 1509;
4611 -> 1501;
4612 -> 1652;
4613 -> 4612;
4613 -> 1521;
4614 -> 4613;
4614 -> 1523;
4614 -> 1521;
4615 -> 1519;
4615 -> 1553;
4615 -> 1648;
4615 -> 4614;
4615 -> 1657;
4615 -> 1547;
4615 -> 1548;
4615 -> 4600;
4615 -> 1555;
4615 -> 1552;
4616 -> 1672;
4617 -> 4616;
4617 -> 1567;
4618 -> 4617;
4618 -> 1569;
4618 -> 1567;
4619 -> 1565;
4619 -> 1599;
4619 -> 1668;
4619 -> 4618;
4619 -> 1677;
4619 -> 1593;
4619 -> 1594;
4619 -> 4604;
4619 -> 1601;
4619 -> 1598;
4620 -> 1613;
4621 -> 4620;
4621 -> 1434;
4622 -> 4621;
4622 -> 1436;
4622 -> 1434;
4623 -> 1632;
4624 -> 4623;
4624 -> 1472;
4625 -> 4624;
4625 -> 1474;
4625 -> 1472;
4626 -> 1470;
4626 -> 1502;
4626 -> 1628;
4626 -> 4625;
4626 -> 1637;
4626 -> 1498;
4626 -> 1499;
4626 -> 4611;
4626 -> 1509;
4626 -> 1501;
4627 -> 1652;
4628 -> 4627;
4628 -> 1521;
4629 -> 4628;
4629 -> 1523;
4629 -> 1521;
4630 -> 1519;
4630 -> 1553;
4630 -> 1648;
4630 -> 4629;
4630 -> 1657;
4630 -> 1547;
4630 -> 1548;
4630 -> 4615;
4630 -> 1555;
4630 -> 1552;
4631 -> 1672;
4632 -> 4631;
4632 -> 1567;
4633 -> 4632;
4633 -> 1569;
4633 -> 1567;
4634 -> 1565;
4634 -> 1599;
4634 -> 1668;
4634 -> 4633;
4634 -> 1677;
4634 -> 1593;
4634 -> 1594;
4634 -> 4619;
4634 -> 1601;
4634 -> 1598;
4635 -> 1613;
4636 -> 4635;
4636 -> 1434;
4637 -> 4636;
4637 -> 1436;
4637 -> 1434;
4638 -> 1632;
4639 -> 4638;
4639 -> 1472;
4640 -> 4639;
4640 -> 1474;
4640 -> 1472;
4641 -> 1470;
4641 -> 1502;
4641 -> 1628;
4641 -> 4640;
4641 -> 1637;
4641 -> 1498;
4641 -> 1499;
4641 -> 4626;
4641 -> 1509;
4641 -> 1501;
4642 -> 1652;
4643 -> 4642;
4643 -> 1521;
4644 -> 4643;
4644 -> 1523;
4644 -> 1521;
4645 -> 1519;
4645 -> 1553;
4645 -> 1648;
4645 -> 4644;
4645 -> 1657;
4645 -> 1547;
4645 -> 1548;
4645 -> 4630;
4645 -> 1555;
4645 -> 1552;
4646 -> 1672;
4647 -> 4646;
4647 -> 1567;
4648 -> 4647;
4648 -> 1569;
4648 -> 1567;
4649 -> 1565;
4649 -> 1599;
4649 -> 1668;
4649 -> 4648;
4649 -> 1677;
4649 -> 1593;
4649 -> 1594;
4649 -> 4634;
4649 -> 1601;
4649 -> 1598;
4650 -> 1613;
4651 -> 4650;
4651 -> 1434;
4652 -> 4651;
4652 -> 1436;
4652 -> 1434;
4653 -> 1632;
4654 -> 4653;
4654 -> 1472;
4655 -> 4654;
4655 -> 1474;
4655 -> 1472;
4656 -> 1470;
4656 -> 1502;
4656 -> 1628;
4656 -> 4655;
4656 -> 1637;
4656 -> 1498;
4656 -> 1499;
4656 -> 4641;
4656 -> 1509;
4656 -> 1501;
4657 -> 1652;
4658 -> 4657;
4658 -> 1521;
4659 -> 4658;
4659 -> 1523;
4659 -> 1521;
4660 -> 1519;
4660 -> 1553;
4660 -> 1648;
4660 -> 4659;
4660 -> 1657;
4660 -> 1547;
4660 -> 1548;
4660 -> 4645;
4660 -> 1555;
4660 -> 1552;
4661 -> 1672;
4662 -> 4661;
4662 -> 1567;
4663 -> 4662;
4663 -> 1569;
4663 -> 1567;
4664 -> 1565;
4664 -> 1599;
4664 -> 1668;
4664 -> 4663;
4664 -> 1677;
4664 -> 1593;
4664 -> 1594;
4664 -> 4649;
4664 -> 1601;
4664 -> 1598;
4665 -> 1613;
4666 -> 4665;
4666 -> 1434;
4667 -> 4666;
4667 -> 1436;
4667 -> 1434;
4668 -> 1632;
4669 -> 4668;
4669 -> 1472;
4670 -> 4669;
4670 -> 1474;
4670 -> 1472;
4671 -> 1470;
4671 -> 1502;
4671 -> 1628;
4671 -> 4670;
4671 -> 1637;
4671 -> 1498;
4671 -> 1499;
4671 -> 4656;
4671 -> 1509;
4671 -> 1501;
4672 -> 1652;
4673 -> 4672;
4673 -> 1521;
4674 -> 4673;
4674 -> 1523;
4674 -> 1521;
4675 -> 1519;
4675 -> 1553;
4675 -> 1648;
4675 -> 4674;
4675 -> 1657;
4675 -> 1547;
4675 -> 1548;
4675 -> 4660;
4675 -> 1555;
4675 -> 1552;
4676 -> 1672;
4677 -> 4676;
4677 -> 1567;
4678 -> 4677;
4678 -> 1569;
4678 -> 1567;
4679 -> 1565;
4679 -> 1599;
4679 -> 1668;
4679 -> 4678;
4679 -> 1677;
4679 -> 1593;
4679 -> 1594;
4679 -> 4664;
4679 -> 1601;
4679 -> 1598;
4680 -> 1613;
4681 -> 4680;
4681 -> 1434;
4682 -> 4681;
4682 -> 1436;
4682 -> 1434;
4683 -> 1632;
4684 -> 4683;
4684 -> 1472;
4685 -> 4684;
4685 -> 1474;
4685 -> 1472;
4686 -> 1470;
4686 -> 1502;
4686 -> 1628;
4686 -> 4685;
4686 -> 1637;
4686 -> 1498;
4686 -> 1499;
4686 -> 4671;
4686 -> 1509;
4686 -> 1501;
4687 -> 1652;
4688 -> 4687;
4688 -> 1521;
4689 -> 4688;
4689 -> 1523;
4689 -> 1521;
4690 -> 1519;
4690 -> 1553;
4690 -> 1648;
4690 -> 4689;
4690 -> 1657;
4690 -> 1547;
4690 -> 1548;
4690 -> 4675;
4690 -> 1555;
4690 -> 1552;
4691 -> 1672;
4692 -> 4691;
4692 -> 1567;
4693 -> 4692;
4693 -> 1569;
4693 -> 1567;
4694 -> 1565;
4694 -> 1599;
4694 -> 1668;
4694 -> 4693;
4694 -> 1677;
4694 -> 1593;
4694 -> 1594;
4694 -> 4679;
4694 -> 1601;
4694 -> 1598;
4695 -> 1613;
4696 -> 4695;
4696 -> 1434;
4697 -> 4696;
4697 -> 1436;
4697 -> 1434;
4698 -> 1632;
4699 -> 4698;
4699 -> 1472;
4700 -> 4699;
4700 -> 1474;
4700 -> 1472;
4701 -> 1470;
4701 -> 1502;
4701 -> 1628;
4701 -> 4700;
4701 -> 1637;
4701 -> 1498;
4701 -> 1499;
4701 -> 4686;
4701 -> 1509;
4701 -> 1501;
4702 -> 1652;
4703 -> 4702;
4703 -> 1521;
4704 -> 4703;
4704 -> 1523;
4704 -> 1521;
4705 -> 1519;
4705 -> 1553;
4705 -> 1648;
4705 -> 4704;
4705 -> 1657;
4705 -> 1547;
4705 -> 1548;
4705 -> 4690;
4705 -> 1555;
4705 -> 1552;
4706 -> 1672;
4707 -> 4706;
4707 -> 1567;
4708 -> 4707;
4708 -> 1569;
4708 -> 1567;
4709 -> 1565;
4709 -> 1599;
4709 -> 1668;
4709 -> 4708;
4709 -> 1677;
4709 -> 1593;
4709 -> 1594;
4709 -> 4694;
4709 -> 1601;
4709 -> 1598;
4710 -> 1613;
4711 -> 4710;
4711 -> 1434;
4712 -> 4711;
4712 -> 1436;
4712 -> 1434;
4713 -> 1632;
4714 -> 4713;
4714 -> 1472;
4715 -> 4714;
4715 -> 1474;
4715 -> 1472;
4716 -> 1470;
4716 -> 1502;
4716 -> 1628;
4716 -> 4715;
4716 -> 1637;
4716 -> 1498;
4716 -> 1499;
4716 -> 4701;
4716 -> 1509;
4716 -> 1501;
4717 -> 1652;
4718 -> 4717;
4718 -> 1521;
4719 -> 4718;
4719 -> 1523;
4719 -> 1521;
4720 -> 1519;
4720 -> 1553;
4720 -> 1648;
4720 -> 4719;
4720 -> 1657;
4720 -> 1547;
4720 -> 1548;
4720 -> 4705;
4720 -> 1555;
4720 -> 1552;
4721 -> 1672;
4722 -> 4721;
4722 -> 1567;
4723 -> 4722;
4723 -> 1569;
4723 -> 1567;
4724 -> 1565;
4724 -> 1599;
4724 -> 1668;
4724 -> 4723;
4724 -> 1677;
4724 -> 1593;
4724 -> 1594;
4724 -> 4709;
4724 -> 1601;
4724 -> 1598;
4725 -> 1613;
4726 -> 4725;
4726 -> 1434;
4727 -> 4726;
4727 -> 1436;
4727 -> 1434;
4728 -> 1632;
4729 -> 4728;
4729 -> 1472;
4730 -> 4729;
4730 -> 1474;
4730 -> 1472;
4731 -> 1470;
4731 -> 1502;
4731 -> 1628;
4731 -> 4730;
4731 -> 1637;
4731 -> 1498;
4731 -> 1499;
4731 -> 4716;
4731 -> 1509;
4731 -> 1501;
4732 -> 1652;
4733 -> 4732;
4733 -> 1521;
4734 -> 4733;
4734 -> 1523;
4734 -> 1521;
4735 -> 1519;
4735 -> 1553;
4735 -> 1648;
4735 -> 4734;
4735 -> 1657;
4735 -> 1547;
4735 -> 1548;
4735 -> 4720;
4735 -> 1555;
4735 -> 1552;
4736 -> 1672;
4737 -> 4736;
4737 -> 1567;
4738 -> 4737;
4738 -> 1569;
4738 -> 1567;
4739 -> 1565;
4739 -> 1599;
4739 -> 1668;
4739 -> 4738;
4739 -> 1677;
4739 -> 1593;
4739 -> 1594;
4739 -> 4724;
4739 -> 1601;
4739 -> 1598;
4740 -> 1613;
4741 -> 4740;
4741 -> 1434;
4742 -> 4741;
4742 -> 1436;
4742 -> 1434;
4743 -> 1632;
4744 -> 4743;
4744 -> 1472;
4745 -> 4744;
4745 -> 1474;
4745 -> 1472;
4746 -> 1470;
4746 -> 1502;
4746 -> 1628;
4746 -> 4745;
4746 -> 1637;
4746 -> 1498;
4746 -> 1499;
4746 -> 4731;
4746 -> 1509;
4746 -> 1501;
4747 -> 1652;
4748 -> 4747;
4748 -> 1521;
4749 -> 4748;
4749 -> 1523;
4749 -> 1521;
4750 -> 1519;
4750 -> 1553;
4750 -> 1648;
4750 -> 4749;
4750 -> 1657;
4750 -> 1547;
4750 -> 1548;
4750 -> 4735;
4750 -> 1555;
4750 -> 1552;
4751 -> 1672;
4752 -> 4751;
4752 -> 1567;
4753 -> 4752;
4753 -> 1569;
4753 -> 1567;
4754 -> 1565;
4754 -> 1599;
4754 -> 1668;
4754 -> 4753;
4754 -> 1677;
4754 -> 1593;
4754 -> 1594;
4754 -> 4739;
4754 -> 1601;
4754 -> 1598;
4755 -> 1613;
4756 -> 4755;
4756 -> 1434;
4757 -> 4756;
4757 -> 1436;
4757 -> 1434;
4758 -> 1632;
4759 -> 4758;
4759 -> 1472;
4760 -> 4759;
4760 -> 1474;
4760 -> 1472;
4761 -> 1470;
4761 -> 1502;
4761 -> 1628;
4761 -> 4760;
4761 -> 1637;
4761 -> 1498;
4761 -> 1499;
4761 -> 4746;
4761 -> 1509;
4761 -> 1501;
4762 -> 1652;
4763 -> 4762;
4763 -> 1521;
4764 -> 4763;
4764 -> 1523;
4764 -> 1521;
4765 -> 1519;
4765 -> 1553;
4765 -> 1648;
4765 -> 4764;
4765 -> 1657;
4765 -> 1547;
4765 -> 1548;
4765 -> 4750;
4765 -> 1555;
4765 -> 1552;
4766 -> 1672;
4767 -> 4766;
4767 -> 1567;
4768 -> 4767;
4768 -> 1569;
4768 -> 1567;
4769 -> 1565;
4769 -> 1599;
4769 -> 1668;
4769 -> 4768;
4769 -> 1677;
4769 -> 1593;
4769 -> 1594;
4769 -> 4754;
4769 -> 1601;
4769 -> 1598;
4770 -> 1613;
4771 -> 4770;
4771 -> 1434;
4772 -> 4771;
4772 -> 1436;
4772 -> 1434;
4773 -> 1632;
4774 -> 4773;
4774 -> 1472;
4775 -> 4774;
4775 -> 1474;
4775 -> 1472;
4776 -> 1470;
4776 -> 1502;
4776 -> 1628;
4776 -> 4775;
4776 -> 1637;
4776 -> 1498;
4776 -> 1499;
4776 -> 4761;
4776 -> 1509;
4776 -> 1501;
4777 -> 1652;
4778 -> 4777;
4778 -> 1521;
4779 -> 4778;
4779 -> 1523;
4779 -> 1521;
4780 -> 1519;
4780 -> 1553;
4780 -> 1648;
4780 -> 4779;
4780 -> 1657;
4780 -> 1547;
4780 -> 1548;
4780 -> 4765;
4780 -> 1555;
4780 -> 1552;
4781 -> 1672;
4782 -> 4781;
4782 -> 1567;
4783 -> 4782;
4783 -> 1569;
4783 -> 1567;
4784 -> 1565;
4784 -> 1599;
4784 -> 1668;
4784 -> 4783;
4784 -> 1677;
4784 -> 1593;
4784 -> 1594;
4784 -> 4769;
4784 -> 1601;
4784 -> 1598;
4785 -> 1613;
4786 -> 4785;
4786 -> 1434;
4787 -> 4786;
4787 -> 1436;
4787 -> 1434;
4788 -> 1632;
4789 -> 4788;
4789 -> 1472;
4790 -> 4789;
4790 -> 1474;
4790 -> 1472;
4791 -> 1470;
4791 -> 1502;
4791 -> 1628;
4791 -> 4790;
4791 -> 1637;
4791 -> 1498;
4791 -> 1499;
4791 -> 4776;
4791 -> 1509;
4791 -> 1501;
4792 -> 1652;
4793 -> 4792;
4793 -> 1521;
4794 -> 4793;
4794 -> 1523;
4794 -> 1521;
4795 -> 1519;
4795 -> 1553;
4795 -> 1648;
4795 -> 4794;
4795 -> 1657;
4795 -> 1547;
4795 -> 1548;
4795 -> 4780;
4795 -> 1555;
4795 -> 1552;
4796 -> 1672;
4797 -> 4796;
4797 -> 1567;
4798 -> 4797;
4798 -> 1569;
4798 -> 1567;
4799 -> 1565;
4799 -> 1599;
4799 -> 1668;
4799 -> 4798;
4799 -> 1677;
4799 -> 1593;
4799 -> 1594;
4799 -> 4784;
4799 -> 1601;
4799 -> 1598;
4800 -> 1613;
4801 -> 4800;
4801 -> 1434;
4802 -> 4801;
4802 -> 1436;
4802 -> 1434;
4803 -> 1632;
4804 -> 4803;
4804 -> 1472;
4805 -> 4804;
4805 -> 1474;
4805 -> 1472;
4806 -> 1470;
4806 -> 1502;
4806 -> 1628;
4806 -> 4805;
4806 -> 1637;
4806 -> 1498;
4806 -> 1499;
4806 -> 4791;
4806 -> 1509;
4806 -> 1501;
4807 -> 1652;
4808 -> 4807;
4808 -> 1521;
4809 -> 4808;
4809 -> 1523;
4809 -> 1521;
4810 -> 1519;
4810 -> 1553;
4810 -> 1648;
4810 -> 4809;
4810 -> 1657;
4810 -> 1547;
4810 -> 1548;
4810 -> 4795;
4810 -> 1555;
4810 -> 1552;
4811 -> 1672;
4812 -> 4811;
4812 -> 1567;
4813 -> 4812;
4813 -> 1569;
4813 -> 1567;
4814 -> 1565;
4814 -> 1599;
4814 -> 1668;
4814 -> 4813;
4814 -> 1677;
4814 -> 1593;
4814 -> 1594;
4814 -> 4799;
4814 -> 1601;
4814 -> 1598;
4815 -> 1613;
4816 -> 4815;
4816 -> 1434;
4817 -> 4816;
4817 -> 1436;
4817 -> 1434;
4818 -> 1632;
4819 -> 4818;
4819 -> 1472;
4820 -> 4819;
4820 -> 1474;
4820 -> 1472;
4821 -> 1470;
4821 -> 1502;
4821 -> 1628;
4821 -> 4820;
4821 -> 1637;
4821 -> 1498;
4821 -> 1499;
4821 -> 4806;
4821 -> 1509;
4821 -> 1501;
4822 -> 1652;
4823 -> 4822;
4823 -> 1521;
4824 -> 4823;
4824 -> 1523;
4824 -> 1521;
4825 -> 1519;
4825 -> 1553;
4825 -> 1648;
4825 -> 4824;
4825 -> 1657;
4825 -> 1547;
4825 -> 1548;
4825 -> 4810;
4825 -> 1555;
4825 -> 1552;
4826 -> 1672;
4827 -> 4826;
4827 -> 1567;
4828 -> 4827;
4828 -> 1569;
4828 -> 1567;
4829 -> 1565;
4829 -> 1599;
4829 -> 1668;
4829 -> 4828;
4829 -> 1677;
4829 -> 1593;
4829 -> 1594;
4829 -> 4814;
4829 -> 1601;
4829 -> 1598;
4830 -> 1408;
4830 -> 1406;
4831 -> 1407;
4831 -> 1406;
4832 -> 1409;
4832 -> 1406;
4833 -> 1406;
4834 -> 4830;
4834 -> 4833;
4835 -> 4831;
4835 -> 4833;
4836 -> 4832;
4836 -> 4833;
4837 -> 4834;
4837 -> 1411;
4837 -> 4833;
4838 -> 4833;
4839 -> 4835;
4839 -> 4838;
4839 -> 4833;
4840 -> 4839;
4841 -> 4836;
4841 -> 4840;
4841 -> 4839;
4842 -> 4836;
4842 -> 408;
4842 -> 4841;
4843 -> 1423;
4843 -> 1422;
4843 -> 4834;
4843 -> 4842;
4844 -> 1387;
4845 -> 1391;
4845 -> 4844;
4845 -> 1387;
4846 -> 4843;
4846 -> 1387;
4847 -> 4846;
4847 -> 1155;
4848 -> 1155;
4849 -> 4847;
4849 -> 4848;
4850 -> 1144;
4850 -> 4848;
4851 -> 4848;
4852 -> 4849;
4852 -> 4851;
4852 -> 4848;
4853 -> 4850;
4853 -> 1115;
4853 -> 1151;
4853 -> 1150;
4853 -> 4848;
4854 -> 4850;
4854 -> 1151;
4854 -> 1150;
4854 -> 1115;
4854 -> 4848;
4855 -> 4849;
4855 -> 4854;
4855 -> 4848;
4856 -> 4850;
4856 -> 1115;
4856 -> 4848;
4857 -> 1155;
4858 -> 1155;
4859 -> 4846;
4859 -> 4858;
4860 -> 4859;
4860 -> 4858;
4861 -> 4860;
4861 -> 1155;
4862 -> 1395;
4863 -> 1395;
4864 -> 4863;
4864 -> 1395;
4865 -> 1395;
4866 -> 1395;
4867 -> 1395;
4868 -> 1395;
4869 -> 1395;
4870 -> 1395;
4871 -> 4865;
4871 -> 1395;
4872 -> 4866;
4872 -> 1395;
4873 -> 4867;
4873 -> 1395;
4874 -> 4868;
4874 -> 1395;
4875 -> 4870;
4875 -> 4864;
4875 -> 4871;
4875 -> 4872;
4875 -> 4873;
4875 -> 4874;
4875 -> 1395;
4876 -> 1395;
4877 -> 4875;
4877 -> 4876;
4877 -> 1395;
4878 -> 4869;
4878 -> 4875;
4878 -> 4877;
4879 -> 4877;
4880 -> 4878;
4880 -> 4879;
4881 -> 4879;
4882 -> 4880;
4882 -> 4878;
4882 -> 4881;
4883 -> 4882;
4883 -> 4879;
4884 -> 4879;
4885 -> 4880;
4885 -> 4878;
4885 -> 4884;
4886 -> 4885;
4886 -> 4879;
4887 -> 4879;
4888 -> 4886;
4888 -> 4887;
4889 -> 4880;
4889 -> 4878;
4889 -> 4887;
4890 -> 4879;
4891 -> 4879;
4892 -> 4880;
4892 -> 4891;
4893 -> 4892;
4893 -> 4878;
4893 -> 4888;
4893 -> 4891;
4894 -> 4891;
4895 -> 4892;
4895 -> 4893;
4895 -> 4894;
4896 -> 4895;
4896 -> 4891;
4897 -> 4891;
4898 -> 4897;
4898 -> 4891;
4899 -> 4891;
4900 -> 4891;
4901 -> 4893;
4901 -> 4891;
4902 -> 4893;
4903 -> 4893;
4903 -> 4891;
4904 -> 4903;
4905 -> 4891;
4906 -> 4893;
4906 -> 4891;
4907 -> 4891;
4908 -> 4906;
4908 -> 4907;
4909 -> 4907;
4910 -> 4907;
4911 -> 4908;
4911 -> 4910;
4911 -> 4907;
4912 -> 4911;
4913 -> 4909;
4913 -> 4907;
4914 -> 4913;
4914 -> 4891;
4915 -> 4891;
4916 -> 4914;
4916 -> 4915;
4917 -> 4892;
4917 -> 4915;
4918 -> 4915;
4919 -> 4917;
4919 -> 4893;
4919 -> 4918;
4919 -> 4915;
4920 -> 4919;
4921 -> 4920;
4921 -> 4891;
4922 -> 4891;
4923 -> 4893;
4923 -> 4891;
4924 -> 4921;
4924 -> 4891;
4925 -> 4892;
4925 -> 4891;
4926 -> 4923;
4926 -> 4893;
4926 -> 0;
4926 -> 4891;
4927 -> 4891;
4928 -> 4923;
4928 -> 4893;
4928 -> 4891;
4929 -> 4923;
4929 -> 4893;
4929 -> 4928;
4930 -> 4923;
4930 -> 4893;
4930 -> 4929;
4931 -> 4929;
4932 -> 4930;
4932 -> 4931;
4933 -> 4932;
4933 -> 0;
4933 -> 4931;
4934 -> 4893;
4934 -> 4929;
4935 -> 4923;
4935 -> 4893;
4935 -> 4929;
4936 -> 4929;
4937 -> 4934;
4937 -> 4936;
4938 -> 4935;
4938 -> 4936;
4939 -> 4934;
4939 -> 4936;
4940 -> 4938;
4940 -> 4936;
4941 -> 4937;
4941 -> 4936;
4942 -> 4939;
4942 -> 4936;
4943 -> 4936;
4944 -> 4940;
4944 -> 4943;
4945 -> 4941;
4945 -> 4943;
4946 -> 4942;
4946 -> 4943;
4947 -> 4944;
4947 -> 1411;
4947 -> 4943;
4948 -> 4943;
4949 -> 4945;
4949 -> 4948;
4949 -> 4943;
4950 -> 4949;
4951 -> 4946;
4951 -> 4950;
4951 -> 4949;
4952 -> 1415;
4952 -> 1414;
4952 -> 4944;
4952 -> 4951;
4953 -> 4891;
4954 -> 4924;
4954 -> 4953;
4954 -> 4891;
4955 -> 4952;
4955 -> 4891;
4956 -> 4955;
4956 -> 4879;
4957 -> 4883;
4957 -> 4956;
4957 -> 4879;
4958 -> 4956;
4958 -> 4879;
4959 -> 4865;
4959 -> 4877;
4960 -> 4866;
4960 -> 4877;
4961 -> 4867;
4961 -> 4877;
4962 -> 4868;
4962 -> 4877;
4963 -> 4958;
4963 -> 4877;
4964 -> 4958;
4964 -> 1395;
4965 -> 1395;
4965 -> 4964;
4965 -> 4963;
4966 -> 4965;
4966 -> 1155;
4967 -> 4966;
4967 -> 4848;
4968 -> 4967;
4968 -> 4851;
4968 -> 4848;
4969 -> 4850;
4969 -> 4856;
4969 -> 1151;
4969 -> 1150;
4969 -> 4848;
4970 -> 4850;
4970 -> 1151;
4970 -> 1150;
4970 -> 4856;
4970 -> 4848;
4971 -> 4967;
4971 -> 4970;
4971 -> 4848;
4972 -> 4965;
4972 -> 4858;
4973 -> 4972;
4973 -> 4965;
4973 -> 4858;
4974 -> 4973;
4974 -> 1155;
4975 -> 4965;
4976 -> 4965;
4977 -> 4976;
4977 -> 4965;
4978 -> 4965;
4979 -> 4978;
4979 -> 4965;
4980 -> 4978;
4980 -> 4965;
4981 -> 4980;
4981 -> 4965;
4982 -> 4965;
4983 -> 4965;
4984 -> 4965;
4985 -> 4965;
4986 -> 4985;
4987 -> 4965;
4988 -> 4978;
4989 -> 4978;
4990 -> 4978;
4990 -> 1055;
4991 -> 0;
4991 -> 4978;
4992 -> 4978;
4993 -> 4992;
4993 -> 4978;
4994 -> 0;
4994 -> 4993;
4995 -> 4978;
4995 -> 4994;
4995 -> 4991;
4996 -> 4995;
4996 -> 0;
4996 -> 4978;
4997 -> 0;
4997 -> 4978;
4997 -> 4996;
4998 -> 0;
4998 -> 4978;
4998 -> 4996;
4999 -> 4978;
4999 -> 4995;
4999 -> 4997;
4999 -> 0;
5000 -> 4978;
5000 -> 4995;
5000 -> 4997;
5000 -> 4998;
5000 -> 4965;
5001 -> 4978;
5001 -> 4965;
5002 -> 4965;
5003 -> 5001;
5003 -> 5002;
5004 -> 5002;
5005 -> 5002;
5006 -> 5003;
5006 -> 5005;
5006 -> 5002;
5007 -> 5006;
5008 -> 5007;
5008 -> 5003;
5008 -> 5000;
5008 -> 5006;
5009 -> 5004;
5009 -> 5002;
5010 -> 5009;
5010 -> 4965;
5011 -> 4965;
5012 -> 5010;
5012 -> 5011;
5013 -> 4965;
5013 -> 5011;
5014 -> 5011;
5015 -> 5013;
5015 -> 5000;
5015 -> 5014;
5015 -> 5011;
5016 -> 5015;
5017 -> 5016;
5017 -> 4965;
5018 -> 4965;
5019 -> 4965;
5020 -> 5019;
5020 -> 4965;
5021 -> 5000;
5021 -> 4965;
5022 -> 5000;
5023 -> 5000;
5023 -> 4965;
5024 -> 5023;
5025 -> 5017;
5025 -> 4965;
5026 -> 4965;
5027 -> 5000;
5027 -> 0;
5027 -> 4965;
5028 -> 4965;
5029 -> 5000;
5029 -> 5028;
5029 -> 4965;
5030 -> 4965;
5031 -> 5000;
5032 -> 5000;
5033 -> 5031;
5033 -> 5032;
5034 -> 5031;
5034 -> 5032;
5035 -> 5031;
5035 -> 5032;
5036 -> 5031;
5036 -> 5032;
5037 -> 5031;
5037 -> 5032;
5038 -> 5033;
5038 -> 5032;
5039 -> 5034;
5039 -> 5032;
5040 -> 5035;
5040 -> 5032;
5041 -> 5036;
5041 -> 5032;
5042 -> 5037;
5042 -> 5032;
5043 -> 5032;
5044 -> 5038;
5044 -> 5043;
5045 -> 5039;
5045 -> 5043;
5046 -> 5040;
5046 -> 5043;
5047 -> 5041;
5047 -> 5043;
5048 -> 5042;
5048 -> 5043;
5049 -> 5044;
5049 -> 0;
5049 -> 5043;
5050 -> 5047;
5050 -> 5046;
5050 -> 5043;
5051 -> 5049;
5051 -> 5050;
5051 -> 5043;
5052 -> 5045;
5052 -> 5051;
5053 -> 5046;
5053 -> 5051;
5054 -> 5048;
5054 -> 5051;
5055 -> 5051;
5056 -> 5052;
5056 -> 5055;
5057 -> 5053;
5057 -> 5055;
5058 -> 5054;
5058 -> 5055;
5059 -> 5055;
5060 -> 5056;
5060 -> 5059;
5060 -> 5055;
5061 -> 5060;
5062 -> 5058;
5062 -> 5061;
5062 -> 5060;
5063 -> 5057;
5063 -> 5062;
5064 -> 5062;
5065 -> 5063;
5065 -> 5064;
5067 -> 5065;
5067 -> 5064;
5068 -> 5064;
5069 -> 5064;
5070 -> 5067;
5070 -> 5069;
5071 -> 5068;
5071 -> 5069;
5072 -> 0;
5072 -> 5069;
5073 -> 5070;
5073 -> 5069;
5074 -> 5069;
5075 -> 5072;
5075 -> 5074;
5076 -> 5073;
5076 -> 5074;
5077 -> 5071;
5077 -> 5074;
5078 -> 5075;
5078 -> 5074;
5079 -> 5076;
5079 -> 5074;
5080 -> 5074;
5081 -> 5078;
5081 -> 5080;
5082 -> 5079;
5082 -> 5080;
5083 -> 5077;
5083 -> 5080;
5084 -> 5081;
5084 -> 5080;
5085 -> 5082;
5085 -> 5080;
5086 -> 5080;
5087 -> 5086;
5087 -> 5084;
5087 -> 5085;
5087 -> 5080;
5088 -> 5086;
5088 -> 5080;
5089 -> 5088;
5089 -> 5087;
5089 -> 5080;
5090 -> 5077;
5090 -> 5089;
5090 -> 0;
5090 -> 5074;
5091 -> 5090;
5091 -> 5077;
5091 -> 5074;
5092 -> 5071;
5092 -> 5069;
5093 -> 5070;
5093 -> 5071;
5093 -> 5069;
5094 -> 5068;
5094 -> 5062;
5095 -> 4965;
5096 -> 5025;
5096 -> 5095;
5096 -> 4965;
5097 -> 4977;
5097 -> 5094;
5097 -> 5089;
5097 -> 4965;
5098 -> 4965;
5098 -> 5094;
5098 -> 5000;
5098 -> 5089;
5098 -> 5091;
5098 -> 5092;
5098 -> 5093;
5099 -> 5098;
5099 -> 1155;
5100 -> 5099;
5100 -> 4848;
5101 -> 5100;
5101 -> 4851;
5101 -> 4848;
5102 -> 5100;
5102 -> 4970;
5102 -> 4848;
5103 -> 5098;
5103 -> 4858;
5104 -> 5103;
5104 -> 5098;
5104 -> 4858;
5105 -> 5104;
5105 -> 1155;
5106 -> 5098;
5107 -> 5098;
5108 -> 5107;
5108 -> 5098;
5109 -> 5098;
5110 -> 5098;
5111 -> 5110;
5111 -> 5098;
5112 -> 5098;
5113 -> 5098;
5114 -> 5098;
5115 -> 5098;
5116 -> 5115;
5117 -> 5098;
5118 -> 5098;
5119 -> 5098;
5120 -> 5118;
5120 -> 5119;
5121 -> 5119;
5122 -> 5119;
5123 -> 5120;
5123 -> 5122;
5123 -> 5119;
5124 -> 5123;
5125 -> 5121;
5125 -> 5119;
5126 -> 5125;
5126 -> 5098;
5127 -> 5098;
5128 -> 5126;
5128 -> 5127;
5129 -> 5098;
5129 -> 5127;
5130 -> 5127;
5131 -> 5129;
5131 -> 5098;
5131 -> 5130;
5131 -> 5127;
5132 -> 5131;
5133 -> 5132;
5133 -> 5098;
5134 -> 5098;
5135 -> 5098;
5136 -> 5134;
5136 -> 5135;
5137 -> 5135;
5138 -> 5136;
5138 -> 5107;
5138 -> 5137;
5138 -> 5135;
5139 -> 5138;
5139 -> 5098;
5140 -> 5098;
5141 -> 5107;
5141 -> 5140;
5141 -> 5098;
5142 -> 5107;
5142 -> 5098;
5143 -> 5107;
5144 -> 5107;
5144 -> 5098;
5145 -> 5144;
5146 -> 5133;
5146 -> 5098;
5147 -> 5098;
5148 -> 5098;
5148 -> 0;
5149 -> 5098;
5150 -> 5098;
5151 -> 5098;
5152 -> 5150;
5152 -> 5151;
5153 -> 5152;
5153 -> 0;
5153 -> 5151;
5154 -> 5107;
5154 -> 1411;
5154 -> 5098;
5155 -> 5107;
5155 -> 408;
5156 -> 1423;
5156 -> 1422;
5156 -> 5107;
5156 -> 5155;
5157 -> 5098;
5158 -> 5146;
5158 -> 5157;
5158 -> 5098;
5159 -> 5108;
5159 -> 5156;
5159 -> 5098;
5160 -> 5156;
5160 -> 1155;
5161 -> 5160;
5161 -> 4848;
5162 -> 5161;
5162 -> 4851;
5162 -> 4848;
5163 -> 5161;
5163 -> 4970;
5163 -> 4848;
5164 -> 5156;
5164 -> 4858;
5165 -> 5164;
5165 -> 5156;
5165 -> 4858;
5166 -> 5165;
5166 -> 1155;
5167 -> 5156;
5168 -> 5156;
5169 -> 5156;
5170 -> 5156;
5171 -> 5170;
5171 -> 5156;
5172 -> 5156;
5173 -> 5156;
5174 -> 5156;
5175 -> 5156;
5176 -> 5175;
5177 -> 5156;
5178 -> 5156;
5179 -> 5156;
5180 -> 5178;
5180 -> 5179;
5181 -> 5179;
5182 -> 5179;
5183 -> 5180;
5183 -> 5182;
5183 -> 5179;
5184 -> 5183;
5185 -> 5181;
5185 -> 5179;
5186 -> 5185;
5186 -> 5156;
5187 -> 5156;
5188 -> 5186;
5188 -> 5187;
5189 -> 5156;
5189 -> 5187;
5190 -> 5187;
5191 -> 5189;
5191 -> 5156;
5191 -> 5190;
5191 -> 5187;
5192 -> 5191;
5193 -> 5192;
5193 -> 5156;
5194 -> 5156;
5195 -> 5156;
5196 -> 5194;
5196 -> 5195;
5197 -> 5195;
5198 -> 5196;
5198 -> 5156;
5198 -> 5197;
5198 -> 5195;
5199 -> 5198;
5199 -> 5156;
5200 -> 5156;
5201 -> 5193;
5201 -> 5156;
5202 -> 5156;
5203 -> 5156;
5203 -> 0;
5204 -> 5156;
5205 -> 5156;
5206 -> 5156;
5207 -> 5205;
5207 -> 5206;
5208 -> 5207;
5208 -> 0;
5208 -> 5206;
5209 -> 5156;
5209 -> 1411;
5210 -> 5156;
5211 -> 5201;
5211 -> 5210;
5211 -> 5156;
5212 -> 5168;
5212 -> 5156;
5213 -> 5156;
5214 -> 5156;
5214 -> 1055;
5215 -> 0;
5215 -> 5156;
5216 -> 5156;
5216 -> 5215;
5217 -> 5215;
5218 -> 5216;
5218 -> 5217;
5219 -> 5218;
5219 -> 5217;
5220 -> 5219;
5221 -> 5156;
5221 -> 5215;
5221 -> 0;
5222 -> 5184;
5222 -> 5180;
5222 -> 5215;
5222 -> 5183;
5223 -> 5189;
5223 -> 5215;
5223 -> 5190;
5223 -> 5187;
5224 -> 5223;
5225 -> 5224;
5225 -> 5156;
5226 -> 5215;
5226 -> 5156;
5227 -> 5215;
5228 -> 5156;
5228 -> 5215;
5229 -> 5215;
5230 -> 5228;
5230 -> 5229;
5231 -> 5229;
5232 -> 5230;
5232 -> 5215;
5232 -> 5231;
5232 -> 5229;
5233 -> 5232;
5233 -> 5215;
5234 -> 5215;
5235 -> 5215;
5236 -> 5215;
5236 -> 5156;
5237 -> 5236;
5238 -> 5225;
5238 -> 5156;
5239 -> 5215;
5239 -> 0;
5239 -> 5156;
5240 -> 5215;
5241 -> 5215;
5242 -> 5240;
5242 -> 5241;
5243 -> 5242;
5243 -> 0;
5243 -> 5241;
5244 -> 5215;
5244 -> 1411;
5245 -> 5238;
5245 -> 5210;
5245 -> 5156;
5246 -> 5168;
5246 -> 5215;
5246 -> 5156;
5247 -> 5215;
5247 -> 1155;
5248 -> 5247;
5248 -> 4848;
5249 -> 5248;
5249 -> 4851;
5249 -> 4848;
5250 -> 5248;
5250 -> 4970;
5250 -> 4848;
5251 -> 5215;
5251 -> 4858;
5252 -> 5251;
5252 -> 5215;
5252 -> 4858;
5253 -> 5252;
5253 -> 1155;
5254 -> 5215;
5255 -> 5215;
5256 -> 5215;
5257 -> 5215;
5258 -> 5257;
5258 -> 5215;
5259 -> 5215;
5260 -> 5215;
5261 -> 5260;
5262 -> 5215;
5263 -> 5215;
5264 -> 5215;
5264 -> 1055;
5265 -> 5215;
5265 -> 0;
5266 -> 5215;
5267 -> 5215;
5268 -> 5266;
5268 -> 5267;
5269 -> 5267;
5270 -> 5267;
5271 -> 5268;
5271 -> 5270;
5271 -> 5267;
5272 -> 5271;
5273 -> 5269;
5273 -> 5267;
5274 -> 5273;
5274 -> 5215;
5275 -> 5215;
5276 -> 5274;
5276 -> 5275;
5277 -> 5215;
5277 -> 5275;
5278 -> 5275;
5279 -> 5277;
5279 -> 5215;
5279 -> 5278;
5279 -> 5275;
5280 -> 5279;
5281 -> 5280;
5281 -> 5215;
5282 -> 5281;
5282 -> 5215;
5283 -> 5215;
5284 -> 5215;
5284 -> 0;
5285 -> 5215;
5286 -> 5215;
5287 -> 5215;
5288 -> 5282;
5288 -> 5287;
5288 -> 5215;
5289 -> 5255;
5289 -> 5215;
5290 -> 5215;
5291 -> 5290;
5291 -> 5229;
5292 -> 5291;
5292 -> 5215;
5292 -> 5231;
5292 -> 5229;
5293 -> 5292;
5293 -> 5215;
5294 -> 5215;
5295 -> 5294;
5295 -> 5215;
5296 -> 5295;
5297 -> 5296;
5297 -> 5215;
5298 -> 993;
5298 -> 5297;
5299 -> 5298;
5300 -> 5298;
5300 -> 5299;
5301 -> 5299;
5302 -> 5300;
5302 -> 5301;
5303 -> 5301;
5304 -> 5302;
5304 -> 5303;
5304 -> 5301;
5305 -> 5302;
5305 -> 5301;
5306 -> 5298;
5306 -> 5304;
5307 -> 5304;
5308 -> 5306;
5308 -> 5307;
5309 -> 5307;
5310 -> 5308;
5310 -> 5309;
5310 -> 5307;
5311 -> 5298;
5311 -> 5215;
5312 -> 5311;
5313 -> 5251;
5313 -> 4858;
5314 -> 5313;
5314 -> 1155;
5315 -> 5294;
5315 -> 5215;
5316 -> 5294;
5316 -> 5215;
5317 -> 5316;
5317 -> 5215;
5318 -> 5294;
5319 -> 5294;
5320 -> 5319;
5321 -> 5320;
5321 -> 5294;
5322 -> 993;
5322 -> 5321;
5323 -> 5294;
5324 -> 5323;
5324 -> 5322;
5324 -> 5294;
5325 -> 5294;
5326 -> 5323;
5326 -> 5325;
5327 -> 5326;
5327 -> 5322;
5327 -> 5325;
5328 -> 5327;
5328 -> 5294;
5329 -> 0;
5331 -> 5329;
5331 -> 5330;
5332 -> 5330;
5333 -> 5331;
5333 -> 5332;
5333 -> 5330;
5334 -> 5330;
5337 -> 5335;
5337 -> 5336;
5338 -> 5336;
5339 -> 5337;
5339 -> 5338;
5339 -> 5336;
5340 -> 5336;
5341 -> 5294;
5342 -> 5341;
5342 -> 5328;
5342 -> 5294;
5343 -> 5294;
5344 -> 5342;
5344 -> 5343;
5345 -> 5344;
5345 -> 5343;
5346 -> 5343;
5347 -> 5345;
5347 -> 5346;
5347 -> 5343;
5348 -> 5345;
5348 -> 5343;
5349 -> 5294;
5350 -> 5348;
5350 -> 5349;
5350 -> 5294;
5351 -> 5294;
5352 -> 5351;
5352 -> 5350;
5352 -> 5294;
5353 -> 5294;
5354 -> 5352;
5354 -> 5353;
5355 -> 5353;
5356 -> 5354;
5356 -> 5355;
5356 -> 5353;
5357 -> 5294;
5358 -> 5354;
5358 -> 5357;
5358 -> 5294;
5359 -> 5294;
5359 -> 5215;
5360 -> 5359;
5360 -> 5267;
5361 -> 5360;
5361 -> 5270;
5361 -> 5267;
5362 -> 5361;
5363 -> 5362;
5363 -> 5360;
5363 -> 5358;
5363 -> 5361;
5364 -> 5277;
5364 -> 5358;
5364 -> 5278;
5364 -> 5275;
5365 -> 5364;
5366 -> 5365;
5366 -> 5215;
5367 -> 5358;
5368 -> 5358;
5368 -> 5367;
5369 -> 5367;
5370 -> 5368;
5370 -> 5369;
5371 -> 5369;
5372 -> 5370;
5372 -> 5371;
5372 -> 5369;
5373 -> 5370;
5373 -> 5369;
5374 -> 5358;
5374 -> 5372;
5375 -> 5372;
5376 -> 5374;
5376 -> 5375;
5377 -> 5375;
5378 -> 5376;
5378 -> 5377;
5378 -> 5375;
5379 -> 5358;
5379 -> 5215;
5380 -> 5379;
5381 -> 5366;
5381 -> 5215;
5382 -> 5358;
5382 -> 0;
5382 -> 5215;
5383 -> 5358;
5384 -> 5358;
5385 -> 5383;
5385 -> 5384;
5386 -> 5383;
5386 -> 5384;
5387 -> 5383;
5387 -> 5384;
5388 -> 5386;
5388 -> 1411;
5388 -> 5384;
5389 -> 5381;
5389 -> 5287;
5389 -> 5215;
5390 -> 5386;
5390 -> 1155;
5391 -> 5390;
5391 -> 4848;
5392 -> 5391;
5392 -> 4851;
5392 -> 4848;
5393 -> 5391;
5393 -> 4970;
5393 -> 4848;
5394 -> 5386;
5394 -> 4858;
5395 -> 5394;
5395 -> 4858;
5396 -> 5395;
5396 -> 1155;
5397 -> 1142;
5398 -> 1079;
5399 -> 5398;
5399 -> 1085;
5399 -> 1079;
5400 -> 1085;
5400 -> 1079;
5401 -> 1085;
5401 -> 1079;
5402 -> 1085;
5402 -> 1079;
5403 -> 1085;
5403 -> 1079;
5404 -> 1085;
5404 -> 1079;
5405 -> 1085;
5405 -> 1079;
5406 -> 1079;
5407 -> 5406;
5407 -> 1085;
5407 -> 1079;
5408 -> 1085;
5408 -> 5407;
5408 -> 1079;
5409 -> 1079;
5410 -> 5409;
5410 -> 1085;
5410 -> 1079;
5411 -> 1078;
5411 -> 890;
5412 -> 890;
5413 -> 5411;
5413 -> 5412;
5414 -> 5413;
5414 -> 5412;
5415 -> 0;
5415 -> 5412;
5416 -> 5412;
5417 -> 5414;
5417 -> 5416;
5418 -> 5415;
5418 -> 5416;
5419 -> 5413;
5419 -> 5416;
5420 -> 5416;
5421 -> 5419;
5421 -> 5402;
5421 -> 5420;
5421 -> 5416;
5422 -> 5417;
5422 -> 5414;
5422 -> 1119;
5422 -> 1127;
5422 -> 1121;
5422 -> 1120;
5422 -> 1110;
5422 -> 1151;
5422 -> 1112;
5422 -> 1113;
5422 -> 1114;
5422 -> 4856;
5422 -> 1116;
5422 -> 1117;
5422 -> 1118;
5422 -> 1122;
5422 -> 1124;
5422 -> 1134;
5422 -> 5399;
5422 -> 5407;
5422 -> 5410;
5422 -> 5402;
5422 -> 5403;
5422 -> 5404;
5422 -> 5405;
5422 -> 5358;
5422 -> 1078;
5422 -> 1123;
5422 -> 1133;
5422 -> 1150;
5422 -> 5398;
5422 -> 5408;
5422 -> 5416;
5423 -> 5416;
5424 -> 5422;
5424 -> 5423;
5425 -> 5423;
5426 -> 5424;
5426 -> 5425;
5427 -> 5426;
5427 -> 5422;
5427 -> 5425;
5428 -> 5426;
5428 -> 5427;
5428 -> 5425;
5429 -> 5426;
5429 -> 5427;
5429 -> 0;
5429 -> 5425;
5430 -> 5429;
5430 -> 5426;
5430 -> 5425;
5431 -> 5425;
5432 -> 5426;
5432 -> 5431;
5433 -> 5431;
5434 -> 5432;
5434 -> 5433;
5435 -> 5433;
5436 -> 5434;
5436 -> 5435;
5437 -> 5436;
5437 -> 5427;
5437 -> 5435;
5438 -> 5435;
5439 -> 5436;
5439 -> 5427;
5439 -> 5438;
5439 -> 5435;
5440 -> 5436;
5440 -> 5427;
5440 -> 5430;
5440 -> 5439;
5441 -> 5440;
5441 -> 5433;
5442 -> 5441;
5442 -> 5434;
5442 -> 5433;
5443 -> 5442;
5443 -> 5431;
5444 -> 5431;
5445 -> 5443;
5445 -> 5444;
5446 -> 5445;
5446 -> 5427;
5446 -> 5444;
5447 -> 5446;
5447 -> 5425;
5448 -> 5428;
5448 -> 5426;
5448 -> 5425;
5449 -> 5427;
5449 -> 5430;
5449 -> 5448;
5449 -> 5442;
5449 -> 5425;
5450 -> 5427;
5450 -> 5425;
5451 -> 5426;
5451 -> 5449;
5451 -> 5450;
5451 -> 5425;
5452 -> 5423;
5453 -> 5452;
5453 -> 5423;
5454 -> 5423;
5455 -> 5449;
5455 -> 5454;
5456 -> 5453;
5456 -> 5454;
5457 -> 5424;
5457 -> 5454;
5458 -> 5455;
5458 -> 5454;
5459 -> 5456;
5459 -> 5454;
5460 -> 5454;
5461 -> 5458;
5461 -> 5460;
5462 -> 5459;
5462 -> 5460;
5463 -> 5457;
5463 -> 5460;
5464 -> 5460;
5465 -> 5463;
5465 -> 5464;
5466 -> 5464;
5467 -> 5465;
5467 -> 5466;
5468 -> 5467;
5468 -> 5451;
5468 -> 5466;
5469 -> 5468;
5469 -> 5464;
5470 -> 5469;
5471 -> 5470;
5471 -> 5460;
5472 -> 5471;
5472 -> 5454;
5473 -> 5454;
5474 -> 5457;
5474 -> 5473;
5475 -> 5473;
5476 -> 5474;
5476 -> 5475;
5477 -> 5475;
5478 -> 5476;
5478 -> 5477;
5479 -> 5478;
5479 -> 5451;
5479 -> 5477;
5480 -> 5479;
5480 -> 5475;
5481 -> 5475;
5482 -> 5476;
5482 -> 5451;
5482 -> 5481;
5482 -> 5475;
5483 -> 5480;
5483 -> 5476;
5483 -> 5482;
5484 -> 5476;
5484 -> 5451;
5484 -> 5475;
5485 -> 5476;
5485 -> 5451;
5485 -> 5484;
5485 -> 5475;
5486 -> 5476;
5486 -> 5451;
5486 -> 5475;
5487 -> 5480;
5487 -> 5475;
5488 -> 5485;
5488 -> 5486;
5488 -> 5487;
5488 -> 5451;
5488 -> 5483;
5488 -> 5484;
5488 -> 5475;
5489 -> 5488;
5489 -> 5473;
5490 -> 5474;
5490 -> 5488;
5490 -> 5473;
5491 -> 5473;
5492 -> 5473;
5493 -> 5489;
5493 -> 5492;
5494 -> 5490;
5494 -> 5492;
5495 -> 5490;
5495 -> 5492;
5496 -> 5490;
5496 -> 5492;
5497 -> 5490;
5497 -> 5492;
5498 -> 5491;
5498 -> 5492;
5499 -> 5493;
5499 -> 5498;
5499 -> 5492;
5500 -> 5494;
5500 -> 5498;
5500 -> 5492;
5501 -> 5495;
5501 -> 5498;
5501 -> 5492;
5502 -> 5496;
5502 -> 5498;
5502 -> 5492;
5503 -> 5497;
5503 -> 5498;
5503 -> 5492;
5504 -> 5491;
5504 -> 5454;
5505 -> 5457;
5505 -> 5488;
5505 -> 5454;
5506 -> 5457;
5506 -> 5488;
5506 -> 5505;
5506 -> 5454;
5507 -> 5454;
5508 -> 5454;
5509 -> 5457;
5509 -> 5508;
5510 -> 5509;
5510 -> 5488;
5510 -> 5508;
5511 -> 5510;
5511 -> 5454;
5512 -> 5454;
5513 -> 5511;
5513 -> 5512;
5514 -> 5513;
5514 -> 5488;
5514 -> 5512;
5515 -> 5455;
5515 -> 5514;
5516 -> 5514;
5517 -> 5515;
5517 -> 5516;
5518 -> 5457;
5518 -> 5516;
5519 -> 5516;
5520 -> 5518;
5520 -> 5519;
5521 -> 5520;
5521 -> 5516;
5522 -> 5516;
5523 -> 5521;
5523 -> 5522;
5524 -> 0;
5524 -> 5516;
5525 -> 5516;
5526 -> 5524;
5526 -> 5525;
5527 -> 5518;
5527 -> 5525;
5528 -> 5526;
5528 -> 5525;
5529 -> 5525;
5530 -> 5528;
5530 -> 5529;
5531 -> 5530;
5531 -> 0;
5531 -> 5529;
5532 -> 5531;
5533 -> 5525;
5534 -> 5527;
5534 -> 5533;
5535 -> 5534;
5535 -> 5525;
5536 -> 5525;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5525;
5539 -> 5538;
5539 -> 5526;
5539 -> 5525;
5540 -> 5539;
5541 -> 5527;
5541 -> 5540;
5542 -> 5540;
5543 -> 5541;
5543 -> 5488;
5543 -> 5542;
5544 -> 5543;
5544 -> 5488;
5544 -> 5542;
5545 -> 5544;
5545 -> 5540;
5546 -> 5545;
5546 -> 5541;
5546 -> 5540;
5547 -> 5540;
5548 -> 5547;
5548 -> 5541;
5548 -> 5540;
5549 -> 5540;
5550 -> 5541;
5550 -> 5488;
5550 -> 5549;
5550 -> 5540;
5551 -> 5541;
5551 -> 5488;
5551 -> 5540;
5552 -> 5539;
5553 -> 5535;
5553 -> 5539;
5554 -> 5516;
5555 -> 5518;
5555 -> 5554;
5556 -> 0;
5556 -> 5554;
5557 -> 5554;
5558 -> 5556;
5558 -> 5557;
5559 -> 5555;
5559 -> 5557;
5560 -> 5559;
5560 -> 5488;
5560 -> 5505;
5560 -> 5557;
5561 -> 5559;
5561 -> 5488;
5561 -> 5505;
5561 -> 5560;
5561 -> 5557;
5562 -> 5558;
5562 -> 5557;
5563 -> 5557;
5564 -> 5562;
5564 -> 5563;
5565 -> 5559;
5565 -> 5563;
5566 -> 5563;
5567 -> 5563;
5568 -> 5563;
5569 -> 5565;
5569 -> 5568;
5570 -> 5569;
5570 -> 5488;
5570 -> 5551;
5570 -> 5568;
5571 -> 5569;
5571 -> 5488;
5571 -> 5505;
5571 -> 5560;
5571 -> 5546;
5571 -> 5548;
5571 -> 5551;
5572 -> 5571;
5572 -> 5563;
5573 -> 5563;
5574 -> 5572;
5574 -> 5573;
5575 -> 5574;
5575 -> 5563;
5576 -> 5563;
5577 -> 5575;
5577 -> 5576;
5578 -> 5577;
5578 -> 5576;
5579 -> 5578;
5580 -> 5574;
5580 -> 5563;
5581 -> 5563;
5582 -> 5580;
5582 -> 5581;
5583 -> 5582;
5583 -> 5581;
5584 -> 5581;
5585 -> 5583;
5585 -> 5584;
5586 -> 5585;
5586 -> 5584;
5587 -> 5584;
5588 -> 5586;
5588 -> 5587;
5589 -> 5588;
5589 -> 5587;
5590 -> 0;
5590 -> 5589;
5591 -> 5574;
5591 -> 0;
5591 -> 5590;
5592 -> 5591;
5593 -> 5565;
5593 -> 5592;
5594 -> 5592;
5595 -> 5593;
5595 -> 5594;
5596 -> 5595;
5596 -> 5592;
5597 -> 5592;
5598 -> 5596;
5598 -> 5597;
5599 -> 5597;
5600 -> 5598;
5600 -> 5599;
5601 -> 5600;
5601 -> 5597;
5602 -> 5592;
5603 -> 5602;
5603 -> 5591;
5604 -> 5603;
5605 -> 5603;
5606 -> 5604;
5606 -> 5605;
5607 -> 5604;
5607 -> 5605;
5608 -> 5565;
5608 -> 5605;
5609 -> 5605;
5610 -> 5608;
5610 -> 5609;
5611 -> 5610;
5611 -> 5605;
5612 -> 5605;
5613 -> 5611;
5613 -> 5612;
5614 -> 5612;
5615 -> 5613;
5615 -> 5614;
5616 -> 5615;
5616 -> 5612;
5617 -> 5605;
5618 -> 5617;
5618 -> 5603;
5619 -> 5618;
5620 -> 5619;
5620 -> 5618;
5621 -> 5618;
5622 -> 5620;
5622 -> 5621;
5623 -> 5621;
5624 -> 5622;
5624 -> 5623;
5625 -> 5624;
5625 -> 5621;
5626 -> 5574;
5626 -> 0;
5626 -> 5625;
5627 -> 5564;
5627 -> 5626;
5628 -> 5626;
5629 -> 5627;
5629 -> 5628;
5630 -> 5565;
5630 -> 5628;
5631 -> 5629;
5631 -> 0;
5631 -> 5628;
5632 -> 5628;
5633 -> 5630;
5633 -> 5632;
5634 -> 5633;
5634 -> 5628;
5635 -> 5628;
5636 -> 5634;
5636 -> 5635;
5637 -> 5635;
5638 -> 5636;
5638 -> 5637;
5639 -> 5638;
5639 -> 5635;
5640 -> 5628;
5641 -> 5630;
5641 -> 5640;
5642 -> 5641;
5642 -> 5628;
5643 -> 5628;
5644 -> 5642;
5644 -> 5643;
5645 -> 5628;
5646 -> 5644;
5646 -> 5645;
5647 -> 5646;
5647 -> 5645;
5648 -> 5645;
5649 -> 5647;
5649 -> 5648;
5650 -> 5649;
5650 -> 5648;
5651 -> 5650;
5652 -> 5639;
5652 -> 5651;
5652 -> 5628;
5653 -> 5631;
5653 -> 5652;
5653 -> 5628;
5654 -> 5653;
5655 -> 5564;
5655 -> 5654;
5656 -> 5654;
5657 -> 5655;
5657 -> 5656;
5658 -> 5565;
5658 -> 5656;
5659 -> 5657;
5659 -> 5656;
5660 -> 5656;
5661 -> 5659;
5661 -> 5660;
5662 -> 5658;
5662 -> 5660;
5663 -> 5660;
5664 -> 5662;
5664 -> 5663;
5665 -> 5664;
5665 -> 5660;
5666 -> 5660;
5667 -> 5665;
5667 -> 5666;
5668 -> 5667;
5668 -> 5660;
5669 -> 5661;
5669 -> 5668;
5670 -> 5668;
5671 -> 5669;
5671 -> 5670;
5672 -> 5662;
5672 -> 5670;
5673 -> 5670;
5674 -> 5672;
5674 -> 5673;
5675 -> 5674;
5675 -> 5670;
5676 -> 5670;
5677 -> 5675;
5677 -> 5676;
5678 -> 5670;
5679 -> 5672;
5679 -> 5678;
5680 -> 5679;
5680 -> 5678;
5681 -> 5678;
5682 -> 5678;
5683 -> 5680;
5683 -> 5682;
5684 -> 5680;
5684 -> 5682;
5685 -> 5680;
5685 -> 5682;
5686 -> 5680;
5686 -> 5682;
5687 -> 5680;
5687 -> 5682;
5688 -> 5681;
5688 -> 5682;
5689 -> 5683;
5689 -> 5688;
5689 -> 5682;
5690 -> 5684;
5690 -> 5688;
5690 -> 5682;
5691 -> 5685;
5691 -> 5688;
5691 -> 5682;
5692 -> 5686;
5692 -> 5688;
5692 -> 5682;
5693 -> 5687;
5693 -> 5688;
5693 -> 5682;
5694 -> 5681;
5694 -> 5670;
5695 -> 5671;
5695 -> 5670;
5696 -> 5670;
5697 -> 5695;
5697 -> 5696;
5698 -> 5672;
5698 -> 5696;
5699 -> 5697;
5699 -> 0;
5699 -> 5696;
5700 -> 5696;
5701 -> 5696;
5702 -> 5700;
5702 -> 5701;
5703 -> 5698;
5703 -> 5701;
5704 -> 5701;
5705 -> 5702;
5705 -> 5704;
5705 -> 5701;
5706 -> 5703;
5706 -> 5679;
5706 -> 5702;
5706 -> 5701;
5707 -> 5701;
5708 -> 5703;
5708 -> 5679;
5708 -> 5707;
5708 -> 5701;
5709 -> 5703;
5709 -> 5679;
5709 -> 5702;
5709 -> 5708;
5710 -> 5696;
5711 -> 5709;
5711 -> 5710;
5712 -> 5696;
5713 -> 5698;
5713 -> 5712;
5714 -> 5713;
5714 -> 5679;
5714 -> 5712;
5715 -> 5714;
5715 -> 5696;
5716 -> 5711;
5716 -> 5715;
5716 -> 5696;
5717 -> 5696;
5718 -> 5700;
5718 -> 5717;
5719 -> 5698;
5719 -> 5717;
5720 -> 5717;
5721 -> 5718;
5721 -> 5720;
5721 -> 5717;
5722 -> 5719;
5722 -> 5679;
5722 -> 5718;
5722 -> 5717;
5723 -> 5717;
5724 -> 5719;
5724 -> 5679;
5724 -> 5723;
5724 -> 5717;
5725 -> 5719;
5725 -> 5679;
5725 -> 5718;
5725 -> 5724;
5726 -> 5696;
5727 -> 5725;
5727 -> 5726;
5728 -> 5716;
5728 -> 5727;
5728 -> 5696;
5729 -> 5696;
5730 -> 5696;
5731 -> 5729;
5731 -> 5730;
5732 -> 5698;
5732 -> 5730;
5733 -> 5730;
5734 -> 5731;
5734 -> 5733;
5734 -> 5730;
5735 -> 5732;
5735 -> 5679;
5735 -> 5731;
5735 -> 5730;
5736 -> 5730;
5737 -> 5732;
5737 -> 5679;
5737 -> 5736;
5737 -> 5730;
5738 -> 5732;
5738 -> 5679;
5738 -> 5731;
5738 -> 5737;
5739 -> 5696;
5740 -> 5738;
5740 -> 5739;
5741 -> 5698;
5741 -> 5739;
5742 -> 5739;
5743 -> 5740;
5743 -> 5742;
5744 -> 5743;
5744 -> 5739;
5745 -> 5739;
5746 -> 5741;
5746 -> 5745;
5747 -> 5746;
5747 -> 5679;
5747 -> 5745;
5748 -> 5747;
5748 -> 5739;
5749 -> 5744;
5749 -> 5748;
5749 -> 5739;
5750 -> 5696;
5751 -> 5729;
5751 -> 5750;
5752 -> 5698;
5752 -> 5750;
5753 -> 5750;
5754 -> 5751;
5754 -> 5753;
5754 -> 5750;
5755 -> 5752;
5755 -> 5679;
5755 -> 5751;
5755 -> 5750;
5756 -> 5750;
5757 -> 5752;
5757 -> 5679;
5757 -> 5756;
5757 -> 5750;
5758 -> 5752;
5758 -> 5679;
5758 -> 5751;
5758 -> 5757;
5759 -> 5696;
5760 -> 5758;
5760 -> 5759;
5761 -> 5749;
5761 -> 5760;
5761 -> 5696;
5762 -> 5696;
5763 -> 5729;
5763 -> 5762;
5764 -> 5698;
5764 -> 5762;
5765 -> 5762;
5766 -> 5763;
5766 -> 5765;
5766 -> 5762;
5767 -> 5764;
5767 -> 5679;
5767 -> 5763;
5767 -> 5762;
5768 -> 5762;
5769 -> 5764;
5769 -> 5679;
5769 -> 5768;
5769 -> 5762;
5770 -> 5764;
5770 -> 5679;
5770 -> 5763;
5770 -> 5769;
5771 -> 5696;
5772 -> 5770;
5772 -> 5771;
5773 -> 5761;
5773 -> 5772;
5773 -> 5696;
5774 -> 5696;
5775 -> 5696;
5776 -> 5774;
5776 -> 5775;
5777 -> 5698;
5777 -> 5775;
5778 -> 5775;
5779 -> 5776;
5779 -> 5778;
5779 -> 5775;
5780 -> 5777;
5780 -> 5679;
5780 -> 5776;
5780 -> 5775;
5781 -> 5775;
5782 -> 5777;
5782 -> 5679;
5782 -> 5781;
5782 -> 5775;
5783 -> 5777;
5783 -> 5679;
5783 -> 5776;
5783 -> 5782;
5784 -> 5696;
5785 -> 5783;
5785 -> 5784;
5786 -> 5696;
5787 -> 5696;
5788 -> 5786;
5788 -> 5787;
5789 -> 5698;
5789 -> 5787;
5790 -> 5787;
5791 -> 5788;
5791 -> 5790;
5791 -> 5787;
5792 -> 5789;
5792 -> 5679;
5792 -> 5788;
5792 -> 5787;
5793 -> 5787;
5794 -> 5789;
5794 -> 5679;
5794 -> 5793;
5794 -> 5787;
5795 -> 5789;
5795 -> 5679;
5795 -> 5788;
5795 -> 5794;
5796 -> 5696;
5797 -> 5795;
5797 -> 5796;
5798 -> 5696;
5799 -> 5798;
5799 -> 5670;
5800 -> 5670;
5801 -> 5670;
5802 -> 5800;
5802 -> 5801;
5803 -> 5672;
5803 -> 5801;
5804 -> 5801;
5805 -> 5803;
5805 -> 5804;
5806 -> 5805;
5806 -> 5679;
5806 -> 5804;
5807 -> 5806;
5807 -> 5801;
5808 -> 5801;
5809 -> 5807;
5809 -> 5808;
5810 -> 5801;
5811 -> 5803;
5811 -> 5810;
5812 -> 5810;
5813 -> 5811;
5813 -> 5812;
5814 -> 5813;
5814 -> 5679;
5814 -> 5812;
5815 -> 5814;
5815 -> 5810;
5816 -> 5810;
5817 -> 5811;
5817 -> 5816;
5818 -> 5817;
5818 -> 5679;
5818 -> 5816;
5819 -> 5816;
5820 -> 5819;
5820 -> 5817;
5820 -> 5816;
5821 -> 5816;
5822 -> 5817;
5822 -> 5679;
5822 -> 5821;
5822 -> 5816;
5823 -> 5817;
5823 -> 5679;
5823 -> 5816;
5824 -> 5810;
5825 -> 5815;
5825 -> 5810;
5826 -> 5825;
5826 -> 5801;
5827 -> 5802;
5827 -> 5801;
5828 -> 5801;
5829 -> 5827;
5829 -> 5828;
5830 -> 5803;
5830 -> 5828;
5831 -> 5828;
5832 -> 5829;
5832 -> 5828;
5833 -> 5828;
5834 -> 5831;
5834 -> 5833;
5835 -> 5832;
5835 -> 5833;
5836 -> 5830;
5836 -> 5833;
5837 -> 5835;
5837 -> 5833;
5838 -> 0;
5838 -> 5837;
5839 -> 5834;
5839 -> 5833;
5840 -> 5838;
5840 -> 5839;
5840 -> 5836;
5840 -> 5679;
5840 -> 5820;
5840 -> 5817;
5840 -> 5823;
5840 -> 5833;
5841 -> 5833;
5842 -> 5840;
5842 -> 5841;
5843 -> 5840;
5843 -> 5841;
5844 -> 5840;
5844 -> 5841;
5845 -> 5841;
5846 -> 5843;
5846 -> 5845;
5846 -> 5841;
5847 -> 5844;
5847 -> 5840;
5847 -> 5843;
5847 -> 5841;
5848 -> 5841;
5849 -> 5844;
5849 -> 5840;
5849 -> 5848;
5849 -> 5841;
5850 -> 5844;
5850 -> 5840;
5850 -> 5843;
5850 -> 5849;
5851 -> 5840;
5851 -> 5841;
5852 -> 5840;
5852 -> 5841;
5853 -> 5841;
5854 -> 5852;
5854 -> 5853;
5855 -> 5854;
5855 -> 5850;
5855 -> 5853;
5856 -> 5855;
5856 -> 5841;
5857 -> 5841;
5858 -> 5856;
5858 -> 5857;
5859 -> 5841;
5860 -> 5852;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5861;
5863 -> 5862;
5863 -> 5850;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5859;
5866 -> 5864;
5866 -> 5865;
5867 -> 5866;
5868 -> 5860;
5868 -> 5867;
5869 -> 5867;
5870 -> 5868;
5870 -> 5869;
5871 -> 5870;
5871 -> 5867;
5872 -> 5867;
5873 -> 5871;
5873 -> 5872;
5874 -> 5867;
5875 -> 5874;
5875 -> 5866;
5876 -> 5866;
5877 -> 5860;
5877 -> 5876;
5878 -> 5876;
5879 -> 5877;
5879 -> 5878;
5880 -> 5879;
5880 -> 5850;
5880 -> 5878;
5881 -> 5880;
5881 -> 5876;
5882 -> 5881;
5882 -> 5866;
5883 -> 5875;
5883 -> 5882;
5883 -> 5866;
5884 -> 5866;
5885 -> 5860;
5885 -> 5884;
5886 -> 5884;
5887 -> 5885;
5887 -> 5886;
5888 -> 5887;
5888 -> 5884;
5889 -> 5884;
5890 -> 5888;
5890 -> 5889;
5891 -> 5890;
5891 -> 5866;
5892 -> 5883;
5892 -> 5891;
5892 -> 5866;
5893 -> 5892;
5894 -> 5893;
5894 -> 5841;
5895 -> 5858;
5895 -> 5894;
5895 -> 5841;
5896 -> 5841;
5897 -> 5852;
5897 -> 5896;
5898 -> 5896;
5899 -> 5897;
5899 -> 5898;
5900 -> 5899;
5900 -> 5850;
5900 -> 5898;
5901 -> 5900;
5901 -> 5896;
5902 -> 5896;
5903 -> 5897;
5903 -> 5850;
5903 -> 5902;
5904 -> 5902;
5905 -> 5902;
5906 -> 5897;
5906 -> 5850;
5906 -> 5905;
5906 -> 5902;
5907 -> 5897;
5907 -> 5850;
5907 -> 5902;
5908 -> 5896;
5909 -> 5901;
5909 -> 5896;
5910 -> 5909;
5910 -> 5841;
5911 -> 5841;
5912 -> 5852;
5912 -> 5911;
5913 -> 5912;
5913 -> 5850;
5913 -> 5907;
5913 -> 5911;
5914 -> 5912;
5914 -> 5850;
5914 -> 5911;
5915 -> 5912;
5915 -> 5850;
5915 -> 5897;
5915 -> 5907;
5915 -> 5914;
5916 -> 5915;
5916 -> 5841;
5917 -> 5841;
5918 -> 5916;
5918 -> 5917;
5919 -> 0;
5919 -> 5918;
5920 -> 5910;
5920 -> 5919;
5920 -> 5850;
5920 -> 5897;
5920 -> 5915;
5920 -> 5907;
5920 -> 5833;
5921 -> 5910;
5921 -> 5841;
5922 -> 5841;
5923 -> 5921;
5923 -> 5922;
5924 -> 5923;
5924 -> 5920;
5924 -> 5922;
5925 -> 5924;
5925 -> 5841;
5926 -> 5841;
5927 -> 5925;
5927 -> 5926;
5928 -> 5841;
5929 -> 5921;
5929 -> 5928;
5930 -> 5929;
5930 -> 5920;
5930 -> 5928;
5931 -> 5930;
5931 -> 5841;
5932 -> 5841;
5933 -> 5931;
5933 -> 5932;
5934 -> 5927;
5934 -> 5933;
5934 -> 5841;
5935 -> 5910;
5935 -> 5841;
5936 -> 5910;
5936 -> 5841;
5937 -> 5910;
5937 -> 5841;
5938 -> 5841;
5939 -> 5937;
5939 -> 5938;
5940 -> 5939;
5940 -> 5934;
5940 -> 5938;
5941 -> 5940;
5941 -> 5841;
5942 -> 5941;
5942 -> 5935;
5942 -> 5841;
5943 -> 5941;
5943 -> 5942;
5944 -> 5942;
5945 -> 5943;
5945 -> 5944;
5945 -> 5833;
5946 -> 5836;
5946 -> 5838;
5946 -> 5839;
5946 -> 5840;
5946 -> 5850;
5946 -> 5919;
5946 -> 5934;
5946 -> 5944;
5946 -> 5943;
5946 -> 5833;
5947 -> 5946;
5947 -> 0;
5947 -> 5801;
5948 -> 5801;
5949 -> 5803;
5949 -> 5948;
5950 -> 5949;
5950 -> 5946;
5950 -> 5948;
5951 -> 5950;
5951 -> 5801;
5952 -> 5801;
5953 -> 5951;
5953 -> 5952;
5954 -> 5801;
5955 -> 5803;
5955 -> 5954;
5956 -> 5954;
5957 -> 5955;
5957 -> 5956;
5958 -> 5957;
5958 -> 5946;
5958 -> 5956;
5959 -> 5954;
5960 -> 5955;
5960 -> 5959;
5961 -> 5960;
5961 -> 5946;
5961 -> 5959;
5962 -> 5959;
5963 -> 5960;
5963 -> 5946;
5963 -> 5962;
5963 -> 5959;
5964 -> 5960;
5964 -> 5946;
5964 -> 5959;
5965 -> 5954;
5966 -> 5958;
5966 -> 5801;
5967 -> 5946;
5967 -> 5801;
5968 -> 5967;
5969 -> 5968;
5969 -> 5946;
5969 -> 5964;
5970 -> 5968;
5970 -> 5946;
5970 -> 5961;
5970 -> 5960;
5970 -> 5964;
5971 -> 5970;
5971 -> 5967;
5972 -> 5967;
5973 -> 5971;
5973 -> 5972;
5974 -> 5967;
5975 -> 5973;
5975 -> 5974;
5976 -> 5975;
5976 -> 5974;
5977 -> 5976;
5978 -> 5694;
5978 -> 5670;
5979 -> 5670;
5980 -> 5978;
5980 -> 5979;
5981 -> 5672;
5981 -> 5979;
5982 -> 5980;
5982 -> 5690;
5982 -> 5981;
5982 -> 5979;
5983 -> 5980;
5983 -> 5691;
5983 -> 5981;
5983 -> 5979;
5984 -> 5980;
5984 -> 5692;
5984 -> 5981;
5984 -> 5946;
5984 -> 5979;
5985 -> 5980;
5985 -> 5693;
5985 -> 5981;
5985 -> 5946;
5985 -> 5979;
5986 -> 5980;
5986 -> 5689;
5986 -> 5979;
5987 -> 5979;
5988 -> 5986;
5988 -> 5987;
5989 -> 5981;
5989 -> 5987;
5990 -> 5988;
5990 -> 5679;
5990 -> 5989;
5990 -> 5946;
5990 -> 5987;
5991 -> 5987;
5992 -> 5990;
5992 -> 5991;
5992 -> 5987;
5993 -> 5990;
5993 -> 5989;
5993 -> 5946;
5993 -> 5987;
5994 -> 5988;
5994 -> 5679;
5994 -> 5989;
5994 -> 5987;
5995 -> 5987;
5996 -> 5990;
5996 -> 5995;
5996 -> 5987;
5997 -> 5990;
5997 -> 5989;
5997 -> 5946;
5997 -> 5987;
5998 -> 5990;
5998 -> 5989;
5998 -> 5987;
5999 -> 5987;
6000 -> 5999;
6000 -> 5989;
6000 -> 5987;
6001 -> 5987;
6002 -> 6001;
6002 -> 5989;
6002 -> 5987;
6003 -> 5988;
6003 -> 5679;
6003 -> 5989;
6003 -> 5987;
6004 -> 5987;
6005 -> 5989;
6005 -> 5946;
6005 -> 6004;
6005 -> 5987;
6006 -> 5979;
6007 -> 5670;
6008 -> 5671;
6008 -> 5670;
6009 -> 5670;
6010 -> 6008;
6010 -> 6009;
6011 -> 5672;
6011 -> 6009;
6012 -> 6010;
6012 -> 0;
6012 -> 6009;
6013 -> 6009;
6014 -> 6011;
6014 -> 6013;
6015 -> 6014;
6015 -> 5946;
6015 -> 5964;
6015 -> 5998;
6015 -> 6013;
6016 -> 6014;
6016 -> 5946;
6016 -> 6013;
6017 -> 6014;
6017 -> 5946;
6017 -> 6013;
6018 -> 6014;
6018 -> 5946;
6018 -> 5994;
6018 -> 6013;
6019 -> 6014;
6019 -> 5946;
6019 -> 5961;
6019 -> 6003;
6019 -> 6013;
6020 -> 6017;
6020 -> 6018;
6020 -> 6015;
6020 -> 6019;
6020 -> 5946;
6020 -> 5961;
6020 -> 6003;
6020 -> 5960;
6020 -> 5970;
6020 -> 6000;
6020 -> 5964;
6020 -> 5998;
6020 -> 5982;
6020 -> 5983;
6020 -> 5984;
6020 -> 5985;
6020 -> 5994;
6020 -> 6002;
6020 -> 6001;
6020 -> 6013;
6021 -> 6013;
6022 -> 6013;
6023 -> 6021;
6023 -> 6022;
6024 -> 6021;
6024 -> 6009;
6025 -> 6009;
6026 -> 6009;
6027 -> 6026;
6028 -> 6011;
6028 -> 6027;
6029 -> 6027;
6030 -> 6028;
6030 -> 6029;
6031 -> 6030;
6031 -> 6020;
6031 -> 6029;
6032 -> 6030;
6032 -> 6020;
6032 -> 6029;
6033 -> 6027;
6034 -> 6028;
6034 -> 6033;
6035 -> 6034;
6035 -> 6020;
6035 -> 6032;
6035 -> 6033;
6036 -> 6033;
6037 -> 6036;
6037 -> 6034;
6037 -> 6033;
6038 -> 6033;
6039 -> 6034;
6039 -> 6020;
6039 -> 6038;
6039 -> 6033;
6040 -> 6034;
6040 -> 6020;
6040 -> 6033;
6041 -> 6027;
6042 -> 6032;
6042 -> 6026;
6043 -> 6026;
6044 -> 6011;
6044 -> 6043;
6045 -> 6044;
6045 -> 6020;
6045 -> 6040;
6045 -> 6043;
6046 -> 6044;
6046 -> 6020;
6046 -> 6043;
6047 -> 6044;
6047 -> 6020;
6047 -> 6032;
6047 -> 6034;
6047 -> 6037;
6047 -> 6040;
6047 -> 6046;
6048 -> 6047;
6048 -> 6026;
6049 -> 6026;
6050 -> 6048;
6050 -> 6049;
6051 -> 6026;
6052 -> 6011;
6052 -> 6051;
6053 -> 6052;
6053 -> 6020;
6053 -> 6032;
6053 -> 6034;
6053 -> 6047;
6053 -> 6051;
6054 -> 6053;
6054 -> 6026;
6055 -> 6026;
6056 -> 6054;
6056 -> 6055;
6057 -> 6026;
6058 -> 6026;
6059 -> 6057;
6059 -> 6058;
6060 -> 6011;
6060 -> 6058;
6061 -> 6058;
6062 -> 6059;
6062 -> 6058;
6063 -> 6058;
6064 -> 6061;
6064 -> 6063;
6065 -> 6062;
6065 -> 6063;
6066 -> 6060;
6066 -> 6063;
6067 -> 6065;
6067 -> 6063;
6068 -> 5838;
6068 -> 6067;
6069 -> 6064;
6069 -> 6063;
6070 -> 6068;
6070 -> 6069;
6070 -> 6066;
6070 -> 6020;
6070 -> 6032;
6070 -> 6034;
6070 -> 6047;
6070 -> 6037;
6070 -> 6040;
6070 -> 6063;
6071 -> 6063;
6072 -> 6071;
6073 -> 6070;
6073 -> 6072;
6073 -> 6071;
6074 -> 6070;
6074 -> 6071;
6075 -> 6071;
6076 -> 6070;
6076 -> 6071;
6077 -> 6071;
6078 -> 6070;
6078 -> 6077;
6079 -> 6078;
6079 -> 6071;
6080 -> 6071;
6081 -> 6079;
6081 -> 6080;
6082 -> 6071;
6083 -> 6070;
6083 -> 6082;
6084 -> 6082;
6085 -> 6083;
6085 -> 6084;
6086 -> 6085;
6086 -> 6082;
6087 -> 6082;
6088 -> 6086;
6088 -> 6087;
6089 -> 6088;
6090 -> 6083;
6090 -> 6089;
6091 -> 6089;
6092 -> 6090;
6092 -> 6091;
6093 -> 6092;
6093 -> 6089;
6094 -> 6089;
6095 -> 6093;
6095 -> 6094;
6096 -> 6089;
6097 -> 6096;
6097 -> 6088;
6098 -> 6088;
6099 -> 6083;
6099 -> 6098;
6100 -> 6098;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6070;
6102 -> 6100;
6103 -> 6102;
6103 -> 6098;
6104 -> 6103;
6104 -> 6088;
6105 -> 6097;
6105 -> 6104;
6105 -> 6088;
6106 -> 6088;
6107 -> 6083;
6107 -> 6106;
6108 -> 6106;
6109 -> 6107;
6109 -> 6108;
6110 -> 6109;
6110 -> 6106;
6111 -> 6106;
6112 -> 6110;
6112 -> 6111;
6113 -> 6112;
6113 -> 6088;
6114 -> 6105;
6114 -> 6113;
6114 -> 6088;
6115 -> 6114;
6116 -> 6115;
6116 -> 6071;
6117 -> 6081;
6117 -> 6116;
6117 -> 6071;
6118 -> 6071;
6119 -> 6118;
6120 -> 6118;
6121 -> 6070;
6121 -> 6120;
6122 -> 6120;
6123 -> 6120;
6124 -> 6070;
6124 -> 6123;
6124 -> 6120;
6125 -> 6118;
6126 -> 6071;
6127 -> 6070;
6127 -> 6126;
6128 -> 6071;
6129 -> 6071;
6130 -> 6071;
6131 -> 6071;
6132 -> 6071;
6133 -> 6070;
6133 -> 6071;
6134 -> 6071;
6135 -> 6026;
6136 -> 6011;
6136 -> 6135;
6137 -> 6135;
6138 -> 6136;
6138 -> 6137;
6139 -> 6138;
6139 -> 6070;
6139 -> 6137;
6140 -> 6139;
6140 -> 6135;
6141 -> 6135;
6142 -> 6140;
6142 -> 6141;
6143 -> 6135;
6144 -> 6143;
6144 -> 6026;
6145 -> 6026;
6146 -> 6011;
6146 -> 6145;
6147 -> 6146;
6147 -> 6070;
6147 -> 6145;
6148 -> 6147;
6148 -> 6026;
6149 -> 6026;
6150 -> 6148;
6150 -> 6149;
6151 -> 6150;
6152 -> 6150;
6153 -> 6151;
6153 -> 6152;
6154 -> 6152;
6155 -> 6153;
6155 -> 6154;
6155 -> 6152;
6156 -> 6152;
6156 -> 6070;
6156 -> 6153;
6157 -> 6150;
6158 -> 6153;
6158 -> 6157;
6159 -> 6024;
6159 -> 6150;
6160 -> 6150;
6161 -> 6159;
6161 -> 6160;
6162 -> 6160;
6163 -> 6161;
6163 -> 6162;
6163 -> 6160;
6164 -> 6161;
6164 -> 6160;
6164 -> 6070;
6165 -> 6160;
6166 -> 6161;
6166 -> 6165;
6166 -> 6160;
6167 -> 6161;
6167 -> 6160;
6167 -> 6070;
6168 -> 6160;
6169 -> 6150;
6170 -> 6161;
6170 -> 6150;
6171 -> 6150;
6172 -> 6170;
6172 -> 6171;
6173 -> 6011;
6173 -> 6171;
6174 -> 6172;
6174 -> 6161;
6174 -> 6171;
6175 -> 6171;
6176 -> 6174;
6176 -> 6175;
6177 -> 6173;
6177 -> 6175;
6178 -> 6177;
6178 -> 6070;
6178 -> 6176;
6178 -> 6020;
6178 -> 6175;
6179 -> 6177;
6179 -> 6070;
6179 -> 6175;
6180 -> 6175;
6181 -> 6177;
6181 -> 6070;
6181 -> 6179;
6181 -> 6180;
6181 -> 6175;
6182 -> 6171;
6183 -> 6150;
6184 -> 6158;
6184 -> 5670;
6185 -> 5980;
6185 -> 5670;
6186 -> 5670;
6187 -> 6185;
6187 -> 6186;
6188 -> 5672;
6188 -> 6186;
6189 -> 6187;
6189 -> 5690;
6189 -> 6188;
6189 -> 6186;
6190 -> 6187;
6190 -> 5691;
6190 -> 6188;
6190 -> 6186;
6191 -> 6187;
6191 -> 5692;
6191 -> 6188;
6191 -> 6070;
6191 -> 6186;
6192 -> 6187;
6192 -> 5693;
6192 -> 6188;
6192 -> 6070;
6192 -> 6186;
6193 -> 6187;
6193 -> 5988;
6193 -> 6186;
6194 -> 6186;
6195 -> 6188;
6195 -> 6194;
6196 -> 6193;
6196 -> 5679;
6196 -> 6195;
6196 -> 6070;
6196 -> 6194;
6197 -> 6194;
6198 -> 6196;
6198 -> 6197;
6198 -> 6194;
6199 -> 6196;
6199 -> 6195;
6199 -> 6070;
6199 -> 6194;
6200 -> 6193;
6200 -> 5679;
6200 -> 6195;
6200 -> 6194;
6201 -> 6194;
6202 -> 6196;
6202 -> 6201;
6202 -> 6194;
6203 -> 6196;
6203 -> 6195;
6203 -> 6070;
6203 -> 6194;
6204 -> 6194;
6205 -> 6204;
6205 -> 6195;
6205 -> 6194;
6206 -> 6194;
6207 -> 6206;
6207 -> 6195;
6207 -> 6194;
6208 -> 6193;
6208 -> 5679;
6208 -> 6195;
6208 -> 6194;
6209 -> 6194;
6210 -> 6195;
6210 -> 6070;
6210 -> 6209;
6210 -> 6194;
6211 -> 6186;
6212 -> 5670;
6213 -> 0;
6213 -> 5670;
6214 -> 5670;
6215 -> 6213;
6215 -> 6214;
6216 -> 5672;
6216 -> 6214;
6217 -> 6215;
6217 -> 6214;
6218 -> 6214;
6219 -> 6217;
6219 -> 6218;
6220 -> 6219;
6220 -> 0;
6220 -> 6218;
6221 -> 6220;
6222 -> 6216;
6222 -> 6070;
6222 -> 6161;
6222 -> 6196;
6222 -> 6214;
6223 -> 6216;
6223 -> 6070;
6223 -> 6214;
6224 -> 6216;
6224 -> 6070;
6224 -> 6161;
6224 -> 6189;
6224 -> 6190;
6224 -> 6191;
6224 -> 6192;
6224 -> 6200;
6224 -> 6196;
6224 -> 6160;
6224 -> 6205;
6224 -> 6207;
6224 -> 6208;
6224 -> 6179;
6224 -> 6223;
6225 -> 6224;
6225 -> 6215;
6225 -> 6214;
6226 -> 6225;
6226 -> 6070;
6226 -> 6160;
6226 -> 6205;
6226 -> 6224;
6227 -> 6225;
6228 -> 6225;
6229 -> 6224;
6229 -> 6225;
6230 -> 0;
6230 -> 5670;
6231 -> 5670;
6232 -> 5670;
6233 -> 6230;
6233 -> 6232;
6234 -> 6231;
6234 -> 6232;
6235 -> 6231;
6235 -> 6232;
6236 -> 5672;
6236 -> 6232;
6237 -> 6233;
6237 -> 6232;
6238 -> 6235;
6238 -> 6232;
6239 -> 6232;
6240 -> 6237;
6240 -> 6239;
6241 -> 6238;
6241 -> 6239;
6242 -> 6236;
6242 -> 6239;
6243 -> 6239;
6244 -> 6242;
6244 -> 6243;
6245 -> 6244;
6245 -> 6070;
6245 -> 6161;
6245 -> 6189;
6245 -> 6190;
6245 -> 6191;
6245 -> 6192;
6245 -> 6200;
6245 -> 6196;
6245 -> 6225;
6245 -> 6160;
6245 -> 6205;
6245 -> 6224;
6245 -> 6207;
6245 -> 6208;
6245 -> 6179;
6245 -> 6243;
6246 -> 6245;
6246 -> 6239;
6247 -> 6239;
6248 -> 6242;
6248 -> 6247;
6249 -> 6248;
6249 -> 6070;
6249 -> 6161;
6249 -> 6196;
6249 -> 6225;
6249 -> 6247;
6250 -> 6248;
6250 -> 6070;
6250 -> 6179;
6250 -> 6247;
6251 -> 6248;
6251 -> 6070;
6251 -> 6179;
6251 -> 6247;
6252 -> 6248;
6252 -> 6070;
6252 -> 6161;
6252 -> 6200;
6252 -> 6247;
6253 -> 6248;
6253 -> 6070;
6253 -> 6161;
6253 -> 6208;
6253 -> 6225;
6253 -> 6247;
6254 -> 6247;
6255 -> 6247;
6256 -> 6254;
6256 -> 6255;
6257 -> 6254;
6257 -> 6239;
6258 -> 6239;
6259 -> 6242;
6259 -> 6258;
6260 -> 6258;
6261 -> 6259;
6261 -> 6260;
6262 -> 6261;
6262 -> 6249;
6262 -> 6260;
6263 -> 6261;
6263 -> 6249;
6263 -> 6260;
6264 -> 6263;
6264 -> 6258;
6265 -> 6258;
6266 -> 6264;
6266 -> 6265;
6267 -> 6266;
6268 -> 6267;
6268 -> 6239;
6269 -> 6239;
6270 -> 6240;
6270 -> 6239;
6271 -> 6269;
6271 -> 6239;
6272 -> 6270;
6272 -> 6271;
6272 -> 6242;
6272 -> 6249;
6272 -> 6263;
6272 -> 6239;
6273 -> 6239;
6274 -> 6273;
6275 -> 6272;
6275 -> 6274;
6275 -> 6273;
6276 -> 6272;
6276 -> 6273;
6277 -> 6273;
6278 -> 6272;
6278 -> 6273;
6279 -> 6273;
6280 -> 6272;
6280 -> 6279;
6281 -> 6280;
6281 -> 6273;
6282 -> 6273;
6283 -> 6281;
6283 -> 6282;
6284 -> 6273;
6285 -> 6272;
6285 -> 6284;
6286 -> 6284;
6287 -> 6285;
6287 -> 6286;
6288 -> 6287;
6288 -> 6284;
6289 -> 6284;
6290 -> 6288;
6290 -> 6289;
6291 -> 6290;
6292 -> 6285;
6292 -> 6291;
6293 -> 6291;
6294 -> 6292;
6294 -> 6293;
6295 -> 6294;
6295 -> 6291;
6296 -> 6291;
6297 -> 6295;
6297 -> 6296;
6298 -> 6291;
6299 -> 6298;
6299 -> 6290;
6300 -> 6290;
6301 -> 6285;
6301 -> 6300;
6302 -> 6300;
6303 -> 6301;
6303 -> 6302;
6304 -> 6303;
6304 -> 6272;
6304 -> 6302;
6305 -> 6304;
6305 -> 6300;
6306 -> 6305;
6306 -> 6290;
6307 -> 6299;
6307 -> 6306;
6307 -> 6290;
6308 -> 6290;
6309 -> 6285;
6309 -> 6308;
6310 -> 6308;
6311 -> 6309;
6311 -> 6310;
6312 -> 6311;
6312 -> 6308;
6313 -> 6308;
6314 -> 6312;
6314 -> 6313;
6315 -> 6314;
6315 -> 6290;
6316 -> 6307;
6316 -> 6315;
6316 -> 6290;
6317 -> 6316;
6318 -> 6317;
6318 -> 6273;
6319 -> 6283;
6319 -> 6318;
6319 -> 6273;
6320 -> 6273;
6321 -> 6320;
6322 -> 6320;
6323 -> 6272;
6323 -> 6322;
6324 -> 6322;
6325 -> 6322;
6326 -> 6272;
6326 -> 6325;
6326 -> 6322;
6327 -> 6320;
6328 -> 6273;
6329 -> 6272;
6329 -> 6328;
6330 -> 6273;
6331 -> 6273;
6332 -> 6273;
6333 -> 6273;
6334 -> 6273;
6335 -> 6272;
6335 -> 6273;
6336 -> 6273;
6337 -> 6239;
6338 -> 6272;
6338 -> 6337;
6339 -> 6338;
6339 -> 6239;
6340 -> 6239;
6341 -> 6339;
6341 -> 6340;
6342 -> 6268;
6342 -> 6341;
6342 -> 6239;
6343 -> 6241;
6343 -> 6342;
6343 -> 6239;
6344 -> 6239;
6345 -> 6343;
6345 -> 6344;
6346 -> 6242;
6346 -> 6344;
6347 -> 6344;
6348 -> 6346;
6348 -> 6347;
6349 -> 6348;
6349 -> 6272;
6349 -> 6347;
6350 -> 6349;
6350 -> 6344;
6351 -> 6344;
6352 -> 6350;
6352 -> 6351;
6353 -> 6352;
6354 -> 6353;
6354 -> 6239;
6355 -> 6354;
6356 -> 6257;
6356 -> 6354;
6357 -> 6354;
6358 -> 6356;
6358 -> 6357;
6359 -> 6357;
6360 -> 6358;
6360 -> 6359;
6360 -> 6357;
6361 -> 6358;
6361 -> 6357;
6361 -> 6272;
6362 -> 6357;
6363 -> 6358;
6363 -> 6362;
6363 -> 6357;
6364 -> 6358;
6364 -> 6357;
6364 -> 6272;
6365 -> 6357;
6366 -> 6354;
6367 -> 6358;
6367 -> 6354;
6368 -> 6354;
6369 -> 6367;
6369 -> 6368;
6370 -> 6369;
6370 -> 6358;
6370 -> 6368;
6371 -> 6370;
6371 -> 6368;
6372 -> 6368;
6372 -> 6272;
6372 -> 6371;
6372 -> 6249;
6373 -> 6368;
6374 -> 6368;
6375 -> 6354;
6376 -> 6355;
6377 -> 6376;
6377 -> 6272;
6378 -> 6376;
6379 -> 6376;
6380 -> 6376;
6380 -> 6272;
6380 -> 6358;
6381 -> 6376;
6381 -> 6272;
6381 -> 6358;
6381 -> 6357;
6381 -> 6368;
6382 -> 6381;
6382 -> 6376;
6383 -> 6376;
6384 -> 6382;
6384 -> 6383;
6385 -> 6384;
6385 -> 6383;
6386 -> 6385;
6387 -> 6376;
6387 -> 6381;
6388 -> 6381;
6389 -> 6387;
6389 -> 6388;
6390 -> 6389;
6390 -> 6381;
6391 -> 6381;
6392 -> 6390;
6392 -> 6391;
6393 -> 6381;
6394 -> 6381;
6395 -> 6376;
6395 -> 6381;
6396 -> 6381;
6397 -> 6395;
6397 -> 6396;
6398 -> 6397;
6398 -> 6381;
6399 -> 6381;
6400 -> 6398;
6400 -> 6399;
6401 -> 6376;
6401 -> 6391;
6402 -> 6401;
6402 -> 6391;
6403 -> 6402;
6403 -> 6391;
6404 -> 6403;
6404 -> 6391;
6405 -> 6391;
6406 -> 6391;
6406 -> 6405;
6407 -> 6405;
6408 -> 6406;
6408 -> 6407;
6409 -> 6408;
6409 -> 6405;
6410 -> 6405;
6411 -> 6409;
6411 -> 6410;
6412 -> 6411;
6413 -> 6406;
6413 -> 6412;
6414 -> 6412;
6415 -> 6413;
6415 -> 6414;
6416 -> 6415;
6416 -> 6412;
6417 -> 6412;
6418 -> 6416;
6418 -> 6417;
6419 -> 6412;
6420 -> 6419;
6420 -> 6411;
6421 -> 6411;
6422 -> 6406;
6422 -> 6421;
6423 -> 6421;
6424 -> 6422;
6424 -> 6423;
6425 -> 6424;
6425 -> 6272;
6425 -> 6358;
6425 -> 6357;
6425 -> 6381;
6425 -> 6368;
6425 -> 6376;
6425 -> 6423;
6426 -> 6425;
6426 -> 6421;
6427 -> 6426;
6427 -> 6411;
6428 -> 6420;
6428 -> 6427;
6428 -> 6411;
6429 -> 6411;
6430 -> 6406;
6430 -> 6429;
6431 -> 6429;
6432 -> 6430;
6432 -> 6431;
6433 -> 6432;
6433 -> 6429;
6434 -> 6429;
6435 -> 6433;
6435 -> 6434;
6436 -> 6435;
6436 -> 6411;
6437 -> 6428;
6437 -> 6436;
6437 -> 6411;
6438 -> 6437;
6439 -> 6438;
6439 -> 6391;
6440 -> 6439;
6441 -> 6391;
6441 -> 6440;
6442 -> 6440;
6443 -> 6442;
6443 -> 6440;
6444 -> 6440;
6445 -> 6443;
6445 -> 6444;
6446 -> 6441;
6446 -> 6444;
6447 -> 6444;
6448 -> 6445;
6448 -> 6447;
6448 -> 6444;
6449 -> 6446;
6449 -> 6272;
6449 -> 6358;
6449 -> 6445;
6449 -> 6444;
6450 -> 6446;
6450 -> 6272;
6450 -> 6358;
6450 -> 6445;
6451 -> 6440;
6452 -> 6450;
6452 -> 6451;
6453 -> 6440;
6454 -> 6443;
6454 -> 6453;
6455 -> 6441;
6455 -> 6453;
6456 -> 6453;
6457 -> 6454;
6457 -> 6456;
6457 -> 6453;
6458 -> 6455;
6458 -> 6272;
6458 -> 6358;
6458 -> 6454;
6458 -> 6453;
6459 -> 6455;
6459 -> 6272;
6459 -> 6358;
6459 -> 6454;
6460 -> 6440;
6461 -> 6459;
6461 -> 6460;
6462 -> 6452;
6462 -> 6461;
6462 -> 6440;
6463 -> 6442;
6463 -> 6440;
6464 -> 6440;
6465 -> 6463;
6465 -> 6464;
6466 -> 6441;
6466 -> 6464;
6467 -> 6464;
6468 -> 6465;
6468 -> 6467;
6468 -> 6464;
6469 -> 6466;
6469 -> 6272;
6469 -> 6358;
6469 -> 6465;
6469 -> 6464;
6470 -> 6466;
6470 -> 6272;
6470 -> 6358;
6470 -> 6465;
6471 -> 6440;
6472 -> 6470;
6472 -> 6471;
6473 -> 6472;
6473 -> 6439;
6474 -> 6404;
6474 -> 6473;
6475 -> 6473;
6476 -> 6474;
6476 -> 6475;
6477 -> 6391;
6477 -> 6475;
6478 -> 6475;
6479 -> 6477;
6479 -> 6478;
6480 -> 6479;
6480 -> 6475;
6481 -> 6475;
6482 -> 6480;
6482 -> 6481;
6483 -> 6475;
6484 -> 6477;
6484 -> 6483;
6485 -> 6484;
6485 -> 6475;
6486 -> 6475;
6487 -> 6485;
6487 -> 6486;
6488 -> 6477;
6488 -> 6486;
6489 -> 6486;
6490 -> 6487;
6490 -> 6489;
6491 -> 6490;
6491 -> 6486;
6492 -> 6486;
6493 -> 6488;
6493 -> 6492;
6494 -> 6493;
6494 -> 6486;
6495 -> 6491;
6495 -> 6494;
6495 -> 6486;
6496 -> 6482;
6496 -> 6495;
6496 -> 6475;
6497 -> 6476;
6497 -> 0;
6497 -> 6475;
6498 -> 6475;
6499 -> 6475;
6500 -> 6475;
6501 -> 6477;
6501 -> 6500;
6502 -> 6501;
6502 -> 6475;
6503 -> 6475;
6504 -> 6502;
6504 -> 6503;
6505 -> 6504;
6506 -> 6505;
6506 -> 6504;
6507 -> 6504;
6508 -> 6506;
6508 -> 6507;
6509 -> 6508;
6510 -> 6508;
6511 -> 6509;
6511 -> 6475;
6512 -> 6475;
6513 -> 6511;
6513 -> 6512;
6514 -> 6477;
6514 -> 6512;
6515 -> 6512;
6516 -> 6513;
6516 -> 6515;
6516 -> 6512;
6517 -> 6514;
6517 -> 6272;
6517 -> 6358;
6517 -> 6513;
6517 -> 6512;
6518 -> 6475;
6519 -> 6513;
6519 -> 6518;
6520 -> 6509;
6520 -> 6475;
6521 -> 6475;
6522 -> 6520;
6522 -> 6521;
6523 -> 6477;
6523 -> 6521;
6524 -> 6521;
6525 -> 6522;
6525 -> 6524;
6525 -> 6521;
6526 -> 6523;
6526 -> 6272;
6526 -> 6358;
6526 -> 6522;
6526 -> 6521;
6527 -> 6475;
6528 -> 6522;
6528 -> 6527;
6529 -> 6475;
6530 -> 6509;
6530 -> 6529;
6530 -> 6475;
6531 -> 6475;
6532 -> 6530;
6532 -> 6531;
6533 -> 6477;
6533 -> 6531;
6534 -> 6531;
6535 -> 6532;
6535 -> 6534;
6535 -> 6531;
6536 -> 6533;
6536 -> 6272;
6536 -> 6358;
6536 -> 6532;
6536 -> 6531;
6537 -> 6475;
6538 -> 6532;
6538 -> 6537;
6539 -> 6528;
6539 -> 6538;
6539 -> 6475;
6540 -> 6509;
6540 -> 6475;
6541 -> 6475;
6542 -> 6540;
6542 -> 6541;
6543 -> 6477;
6543 -> 6541;
6544 -> 6541;
6545 -> 6542;
6545 -> 6544;
6545 -> 6541;
6546 -> 6543;
6546 -> 6272;
6546 -> 6358;
6546 -> 6542;
6546 -> 6541;
6547 -> 6475;
6548 -> 6542;
6548 -> 6547;
6549 -> 6509;
6549 -> 6475;
6550 -> 6475;
6551 -> 6549;
6551 -> 6550;
6552 -> 6477;
6552 -> 6550;
6553 -> 6550;
6554 -> 6551;
6554 -> 6553;
6554 -> 6550;
6555 -> 6552;
6555 -> 6272;
6555 -> 6358;
6555 -> 6551;
6555 -> 6550;
6556 -> 6475;
6557 -> 6551;
6557 -> 6556;
6558 -> 6557;
6559 -> 6558;
6559 -> 6473;
6560 -> 6404;
6560 -> 6559;
6561 -> 6559;
6562 -> 6560;
6562 -> 6561;
6563 -> 0;
6563 -> 6562;
6564 -> 6562;
6565 -> 6563;
6565 -> 6564;
6566 -> 6391;
6566 -> 6564;
6567 -> 6565;
6567 -> 6564;
6568 -> 6564;
6569 -> 6567;
6569 -> 6568;
6570 -> 6566;
6570 -> 6568;
6571 -> 6568;
6572 -> 6568;
6573 -> 6571;
6573 -> 6572;
6574 -> 6570;
6574 -> 6572;
6575 -> 6572;
6576 -> 6574;
6576 -> 6575;
6577 -> 6575;
6578 -> 6576;
6578 -> 6577;
6579 -> 6578;
6579 -> 6575;
6580 -> 6579;
6581 -> 6580;
6581 -> 6572;
6582 -> 6573;
6582 -> 6572;
6583 -> 6572;
6584 -> 6582;
6584 -> 6583;
6585 -> 6574;
6585 -> 6583;
6586 -> 6583;
6587 -> 6585;
6587 -> 6586;
6588 -> 6587;
6588 -> 6583;
6589 -> 6583;
6590 -> 6588;
6590 -> 6589;
6591 -> 6590;
6591 -> 0;
6591 -> 6583;
6592 -> 6591;
6593 -> 6585;
6593 -> 6592;
6594 -> 6592;
6595 -> 6593;
6595 -> 6594;
6596 -> 6595;
6596 -> 6592;
6597 -> 6592;
6598 -> 6596;
6598 -> 6597;
6599 -> 6592;
6599 -> 6591;
6600 -> 6591;
6601 -> 6600;
6601 -> 6591;
6602 -> 6599;
6602 -> 6601;
6602 -> 6591;
6603 -> 6591;
6604 -> 6603;
6604 -> 6272;
6604 -> 6357;
6604 -> 6381;
6605 -> 6603;
6606 -> 6603;
6607 -> 6603;
6607 -> 6591;
6608 -> 6591;
6609 -> 6585;
6609 -> 6608;
6610 -> 6609;
6610 -> 6272;
6610 -> 6358;
6610 -> 6603;
6610 -> 6357;
6610 -> 6381;
6610 -> 6368;
6610 -> 6376;
6610 -> 6608;
6611 -> 6610;
6611 -> 6591;
6612 -> 6607;
6612 -> 6591;
6613 -> 6612;
6613 -> 6572;
6614 -> 6613;
6614 -> 6572;
6615 -> 6572;
6616 -> 6614;
6616 -> 6615;
6617 -> 6614;
6617 -> 6615;
6618 -> 6616;
6618 -> 6615;
6619 -> 6615;
6620 -> 6619;
6620 -> 6618;
6620 -> 6615;
6621 -> 6619;
6621 -> 6615;
6622 -> 6621;
6622 -> 6620;
6622 -> 6615;
6623 -> 6622;
6623 -> 6568;
6624 -> 6623;
6624 -> 6622;
6624 -> 6568;
6625 -> 6623;
6625 -> 6568;
6626 -> 6568;
6627 -> 6570;
6627 -> 6626;
6628 -> 6627;
6628 -> 6622;
6628 -> 6626;
6629 -> 6627;
6629 -> 6622;
6629 -> 6626;
6630 -> 6629;
6630 -> 6568;
6631 -> 6568;
6632 -> 6630;
6632 -> 6631;
6633 -> 6625;
6633 -> 6568;
6634 -> 6633;
6634 -> 6564;
6635 -> 6564;
6636 -> 6566;
6636 -> 6635;
6637 -> 6636;
6637 -> 6622;
6637 -> 6629;
6637 -> 6635;
6638 -> 6637;
6638 -> 6564;
6639 -> 6564;
6640 -> 6638;
6640 -> 6639;
6641 -> 6634;
6641 -> 6564;
6642 -> 6641;
6642 -> 6562;
6643 -> 6642;
6643 -> 6391;
6643 -> 6622;
6643 -> 6629;
6644 -> 6391;
6645 -> 6643;
6645 -> 6376;
6646 -> 6376;
6647 -> 6376;
6648 -> 6645;
6648 -> 6647;
6649 -> 6646;
6649 -> 6647;
6650 -> 6376;
6650 -> 6647;
6651 -> 6647;
6652 -> 6651;
6653 -> 6650;
6653 -> 6652;
6654 -> 6653;
6654 -> 6643;
6654 -> 6652;
6655 -> 6654;
6655 -> 6651;
6656 -> 6651;
6657 -> 6655;
6657 -> 6656;
6658 -> 6651;
6659 -> 6651;
6660 -> 6657;
6660 -> 6651;
6661 -> 6651;
6662 -> 6660;
6662 -> 6661;
6663 -> 6662;
6663 -> 6661;
6664 -> 6661;
6665 -> 6663;
6665 -> 6664;
6666 -> 6665;
6666 -> 6664;
6667 -> 6664;
6668 -> 6666;
6668 -> 6667;
6669 -> 6668;
6669 -> 6667;
6670 -> 0;
6670 -> 6669;
6671 -> 6657;
6671 -> 6670;
6672 -> 6670;
6673 -> 6671;
6673 -> 6672;
6674 -> 6673;
6674 -> 6672;
6675 -> 6672;
6676 -> 6674;
6676 -> 6675;
6677 -> 6676;
6677 -> 6675;
6678 -> 6677;
6679 -> 6657;
6679 -> 0;
6679 -> 6678;
6680 -> 6657;
6680 -> 0;
6680 -> 6679;
6681 -> 6657;
6681 -> 0;
6681 -> 6680;
6682 -> 6647;
6683 -> 6650;
6683 -> 6682;
6684 -> 6683;
6684 -> 6643;
6684 -> 6682;
6685 -> 6684;
6685 -> 6647;
6686 -> 6647;
6687 -> 6685;
6687 -> 6686;
6688 -> 6648;
6688 -> 6647;
6689 -> 6376;
6690 -> 6376;
6691 -> 6688;
6691 -> 6690;
6692 -> 6691;
6692 -> 6376;
6693 -> 6376;
6694 -> 6692;
6694 -> 6693;
6695 -> 6694;
6695 -> 6693;
6696 -> 0;
6696 -> 6695;
6697 -> 6376;
6697 -> 6643;
6698 -> 6688;
6698 -> 6376;
6699 -> 5670;
6700 -> 5672;
6700 -> 6699;
6701 -> 6700;
6701 -> 6643;
6701 -> 6699;
6702 -> 6701;
6702 -> 5670;
6703 -> 5670;
6704 -> 6702;
6704 -> 6703;
6705 -> 5670;
6706 -> 6698;
6706 -> 6705;
6707 -> 6706;
6707 -> 5670;
6708 -> 5670;
6709 -> 5672;
6709 -> 6708;
6710 -> 6709;
6710 -> 6643;
6710 -> 6708;
6711 -> 6710;
6711 -> 5670;
6712 -> 5670;
6713 -> 6711;
6713 -> 6712;
6714 -> 6707;
6714 -> 6713;
6714 -> 5670;
6715 -> 0;
6715 -> 5670;
6716 -> 5670;
6717 -> 6715;
6717 -> 6716;
6718 -> 5672;
6718 -> 6716;
6719 -> 6717;
6719 -> 6716;
6720 -> 6716;
6721 -> 6719;
6721 -> 6720;
6722 -> 6721;
6722 -> 0;
6722 -> 6720;
6723 -> 6722;
6724 -> 6718;
6724 -> 6643;
6724 -> 6716;
6725 -> 6724;
6725 -> 6717;
6725 -> 6716;
6726 -> 6725;
6727 -> 6725;
6728 -> 6724;
6728 -> 6725;
6729 -> 6229;
6729 -> 5670;
6730 -> 6698;
6730 -> 5670;
6731 -> 6728;
6731 -> 5670;
6732 -> 6729;
6732 -> 6730;
6732 -> 6731;
6732 -> 5672;
6732 -> 6643;
6732 -> 6697;
6732 -> 6725;
6732 -> 5670;
6733 -> 5670;
6734 -> 6732;
6734 -> 6733;
6735 -> 6732;
6735 -> 6733;
6736 -> 6732;
6736 -> 6733;
6737 -> 6732;
6737 -> 6733;
6738 -> 6732;
6738 -> 6733;
6739 -> 6732;
6739 -> 6733;
6740 -> 6734;
6740 -> 6733;
6741 -> 6735;
6741 -> 6733;
6742 -> 6736;
6742 -> 6733;
6743 -> 6737;
6743 -> 6733;
6744 -> 6738;
6744 -> 6733;
6745 -> 6733;
6746 -> 6744;
6746 -> 6745;
6747 -> 6745;
6748 -> 6746;
6748 -> 6732;
6748 -> 6745;
6749 -> 6746;
6749 -> 6732;
6749 -> 6745;
6750 -> 6747;
6750 -> 6745;
6751 -> 6750;
6751 -> 6733;
6752 -> 6739;
6752 -> 6733;
6753 -> 6740;
6753 -> 6741;
6753 -> 6742;
6753 -> 6743;
6753 -> 6751;
6753 -> 6752;
6753 -> 6732;
6753 -> 6733;
6754 -> 6733;
6755 -> 6754;
6755 -> 6733;
6756 -> 6753;
6756 -> 6733;
6757 -> 6753;
6757 -> 6733;
6758 -> 6756;
6758 -> 6733;
6759 -> 6756;
6759 -> 6733;
6760 -> 6187;
6760 -> 5670;
6761 -> 5670;
6762 -> 6760;
6762 -> 6761;
6763 -> 5672;
6763 -> 6761;
6764 -> 6762;
6764 -> 6193;
6764 -> 6761;
6765 -> 6761;
6766 -> 6764;
6766 -> 6765;
6767 -> 6763;
6767 -> 6765;
6768 -> 6767;
6768 -> 6753;
6768 -> 6766;
6768 -> 5679;
6768 -> 6765;
6769 -> 6767;
6769 -> 6753;
6769 -> 6765;
6770 -> 6765;
6771 -> 6767;
6771 -> 6753;
6771 -> 6769;
6771 -> 6770;
6771 -> 6765;
6772 -> 6761;
6773 -> 5670;
6774 -> 6753;
6774 -> 5668;
6775 -> 6774;
6775 -> 5658;
6775 -> 6753;
6775 -> 6769;
6775 -> 5656;
6776 -> 5656;
6777 -> 6775;
6777 -> 6776;
6778 -> 5564;
6778 -> 5563;
6779 -> 5563;
6780 -> 6778;
6780 -> 6779;
6781 -> 5565;
6781 -> 6779;
6782 -> 6779;
6783 -> 6782;
6784 -> 6781;
6784 -> 6783;
6785 -> 6784;
6785 -> 6775;
6785 -> 6783;
6786 -> 6785;
6786 -> 6782;
6787 -> 6782;
6788 -> 6786;
6788 -> 6787;
6789 -> 6787;
6790 -> 6782;
6791 -> 6782;
6792 -> 6788;
6792 -> 6782;
6793 -> 6782;
6794 -> 6792;
6794 -> 6793;
6795 -> 6794;
6795 -> 6793;
6796 -> 6793;
6797 -> 6795;
6797 -> 6796;
6798 -> 6797;
6798 -> 6796;
6799 -> 6796;
6800 -> 6798;
6800 -> 6799;
6801 -> 6800;
6801 -> 6799;
6802 -> 0;
6802 -> 6801;
6803 -> 6788;
6803 -> 6802;
6804 -> 6802;
6805 -> 6803;
6805 -> 6804;
6806 -> 6805;
6806 -> 6804;
6807 -> 6804;
6808 -> 6806;
6808 -> 6807;
6809 -> 6808;
6809 -> 6807;
6810 -> 6809;
6811 -> 6788;
6811 -> 0;
6811 -> 6810;
6812 -> 6788;
6812 -> 0;
6812 -> 6811;
6813 -> 6788;
6813 -> 0;
6813 -> 6812;
6814 -> 6779;
6815 -> 6781;
6815 -> 6814;
6816 -> 6815;
6816 -> 6775;
6816 -> 6814;
6817 -> 6816;
6817 -> 6779;
6818 -> 6779;
6819 -> 6817;
6819 -> 6818;
6820 -> 5557;
6821 -> 5557;
6822 -> 6775;
6822 -> 6821;
6823 -> 6822;
6823 -> 5557;
6824 -> 5557;
6825 -> 6823;
6825 -> 6824;
6826 -> 6825;
6826 -> 6824;
6827 -> 0;
6827 -> 6826;
6828 -> 6775;
6828 -> 5516;
6829 -> 5516;
6830 -> 5516;
6831 -> 5516;
6832 -> 6828;
6832 -> 6831;
6833 -> 6832;
6833 -> 5516;
6834 -> 6828;
6834 -> 6833;
6835 -> 6834;
6835 -> 6775;
6835 -> 6833;
6836 -> 6834;
6836 -> 6775;
6836 -> 6833;
6837 -> 6834;
6837 -> 6775;
6837 -> 6833;
6838 -> 6834;
6838 -> 6775;
6838 -> 6833;
6839 -> 6833;
6840 -> 0;
6840 -> 5516;
6841 -> 5516;
6842 -> 6840;
6842 -> 6841;
6843 -> 5518;
6843 -> 6841;
6844 -> 6842;
6844 -> 6841;
6845 -> 6841;
6846 -> 6844;
6846 -> 6845;
6847 -> 6846;
6847 -> 0;
6847 -> 6845;
6848 -> 6847;
6849 -> 6841;
6850 -> 6843;
6850 -> 6849;
6851 -> 6850;
6851 -> 6838;
6851 -> 6849;
6852 -> 6841;
6853 -> 6851;
6853 -> 6842;
6853 -> 6841;
6854 -> 6853;
6855 -> 6853;
6856 -> 5518;
6856 -> 6838;
6856 -> 6853;
6856 -> 5516;
6857 -> 5516;
6858 -> 5518;
6858 -> 6857;
6859 -> 6857;
6860 -> 6858;
6860 -> 6859;
6861 -> 6860;
6861 -> 6856;
6861 -> 6859;
6862 -> 6860;
6862 -> 6856;
6862 -> 6859;
6863 -> 6862;
6863 -> 6857;
6864 -> 6857;
6865 -> 6863;
6865 -> 6864;
6866 -> 6865;
6866 -> 5516;
6867 -> 6866;
6868 -> 5518;
6868 -> 6867;
6869 -> 6867;
6870 -> 6868;
6870 -> 6869;
6871 -> 6870;
6871 -> 6867;
6872 -> 6868;
6872 -> 6856;
6872 -> 6862;
6872 -> 6867;
6873 -> 6868;
6873 -> 6872;
6873 -> 6867;
6874 -> 6867;
6875 -> 6867;
6876 -> 6867;
6877 -> 6867;
6878 -> 6868;
6878 -> 6877;
6879 -> 6878;
6879 -> 6873;
6879 -> 6877;
6880 -> 6879;
6880 -> 6867;
6881 -> 6867;
6882 -> 6880;
6882 -> 6881;
6883 -> 6882;
6884 -> 6882;
6885 -> 6884;
6886 -> 6884;
6887 -> 6884;
6887 -> 6882;
6888 -> 6882;
6889 -> 6888;
6889 -> 6873;
6889 -> 6884;
6890 -> 6888;
6890 -> 6873;
6890 -> 6884;
6891 -> 6890;
6891 -> 6882;
6892 -> 6882;
6893 -> 6891;
6893 -> 6892;
6894 -> 6893;
6895 -> 6868;
6895 -> 6894;
6896 -> 6894;
6897 -> 6895;
6897 -> 6896;
6898 -> 0;
6898 -> 6896;
6899 -> 6896;
6900 -> 6896;
6901 -> 6898;
6901 -> 6900;
6902 -> 6899;
6902 -> 6900;
6903 -> 6899;
6903 -> 6900;
6904 -> 6897;
6904 -> 6900;
6905 -> 6901;
6905 -> 6900;
6906 -> 6902;
6906 -> 6900;
6907 -> 6903;
6907 -> 6900;
6908 -> 6900;
6909 -> 6905;
6909 -> 6908;
6910 -> 6906;
6910 -> 6908;
6911 -> 6907;
6911 -> 6908;
6912 -> 6904;
6912 -> 6908;
6913 -> 6909;
6913 -> 6908;
6914 -> 6910;
6914 -> 6908;
6915 -> 6911;
6915 -> 6908;
6916 -> 6908;
6917 -> 6913;
6917 -> 6916;
6918 -> 6914;
6918 -> 6916;
6919 -> 6915;
6919 -> 6916;
6920 -> 6912;
6920 -> 6916;
6921 -> 6917;
6921 -> 6916;
6922 -> 6918;
6922 -> 6916;
6923 -> 6919;
6923 -> 6916;
6924 -> 6916;
6925 -> 6921;
6925 -> 6924;
6926 -> 6922;
6926 -> 6924;
6927 -> 6923;
6927 -> 6924;
6928 -> 6920;
6928 -> 6924;
6929 -> 6924;
6930 -> 6928;
6930 -> 6929;
6931 -> 6930;
6931 -> 6924;
6932 -> 6924;
6933 -> 6931;
6933 -> 6932;
6934 -> 6925;
6934 -> 6933;
6935 -> 6926;
6935 -> 6933;
6936 -> 6927;
6936 -> 6933;
6937 -> 6933;
6938 -> 6934;
6938 -> 6937;
6939 -> 6935;
6939 -> 6937;
6940 -> 6936;
6940 -> 6937;
6941 -> 6928;
6941 -> 6937;
6942 -> 6937;
6943 -> 6941;
6943 -> 6942;
6944 -> 6943;
6944 -> 6937;
6945 -> 6937;
6946 -> 6944;
6946 -> 6945;
6947 -> 6946;
6947 -> 6937;
6948 -> 6937;
6949 -> 6941;
6949 -> 6948;
6950 -> 6949;
6950 -> 6937;
6951 -> 6937;
6952 -> 6950;
6952 -> 6951;
6953 -> 6937;
6954 -> 6941;
6954 -> 6953;
6955 -> 6954;
6955 -> 6937;
6956 -> 6937;
6957 -> 6955;
6957 -> 6956;
6958 -> 6937;
6959 -> 6941;
6959 -> 6958;
6960 -> 6958;
6960 -> 6937;
6961 -> 6937;
6962 -> 6937;
6963 -> 6941;
6963 -> 6962;
6964 -> 6962;
6965 -> 6963;
6965 -> 6964;
6966 -> 6965;
6966 -> 6959;
6966 -> 6964;
6967 -> 6966;
6967 -> 6962;
6968 -> 6962;
6969 -> 6967;
6969 -> 6968;
6970 -> 6969;
6970 -> 6962;
6971 -> 6962;
6972 -> 6970;
6972 -> 6971;
6973 -> 6969;
6973 -> 0;
6973 -> 6962;
6974 -> 6962;
6975 -> 6963;
6975 -> 6974;
6976 -> 6975;
6976 -> 6959;
6976 -> 6974;
6977 -> 6976;
6977 -> 6962;
6978 -> 6962;
6979 -> 6977;
6979 -> 6978;
6980 -> 6973;
6980 -> 6979;
6980 -> 6962;
6981 -> 6962;
6982 -> 6963;
6982 -> 6981;
6983 -> 6982;
6983 -> 6959;
6983 -> 6981;
6984 -> 6983;
6984 -> 6962;
6985 -> 6962;
6986 -> 6984;
6986 -> 6985;
6987 -> 6980;
6987 -> 6986;
6987 -> 6962;
6988 -> 6987;
6989 -> 6988;
6989 -> 6937;
6990 -> 6939;
6990 -> 6989;
6991 -> 0;
6991 -> 6990;
6992 -> 6989;
6993 -> 6991;
6993 -> 6992;
6994 -> 6941;
6994 -> 6992;
6995 -> 6992;
6996 -> 6994;
6996 -> 6995;
6997 -> 6996;
6997 -> 6992;
6998 -> 6992;
6999 -> 6997;
6999 -> 6998;
7000 -> 6993;
7000 -> 6992;
7001 -> 7000;
7001 -> 6994;
7001 -> 6959;
7001 -> 6992;
7002 -> 6992;
7003 -> 7001;
7003 -> 7002;
7004 -> 7001;
7004 -> 7002;
7005 -> 7001;
7005 -> 7002;
7006 -> 7002;
7007 -> 7005;
7007 -> 7006;
7008 -> 7007;
7008 -> 7002;
7009 -> 7002;
7010 -> 7008;
7010 -> 7009;
7011 -> 7002;
7012 -> 7010;
7012 -> 7011;
7013 -> 7002;
7014 -> 7005;
7014 -> 7013;
7015 -> 7014;
7016 -> 7014;
7017 -> 7015;
7017 -> 7016;
7018 -> 7017;
7018 -> 7014;
7019 -> 7014;
7020 -> 7018;
7020 -> 7019;
7021 -> 7019;
7021 -> 7002;
7022 -> 7004;
7022 -> 7021;
7023 -> 7021;
7024 -> 7022;
7024 -> 7023;
7025 -> 7005;
7025 -> 7023;
7026 -> 7024;
7026 -> 7023;
7027 -> 7023;
7028 -> 7026;
7028 -> 7027;
7029 -> 7025;
7029 -> 7027;
7030 -> 7028;
7030 -> 7027;
7031 -> 7027;
7032 -> 7027;
7033 -> 7029;
7033 -> 7032;
7034 -> 7032;
7035 -> 7033;
7035 -> 7034;
7036 -> 7035;
7036 -> 7032;
7037 -> 7036;
7038 -> 7037;
7038 -> 7027;
7039 -> 7031;
7039 -> 7027;
7040 -> 7029;
7041 -> 7029;
7041 -> 7040;
7042 -> 7040;
7043 -> 7041;
7043 -> 7042;
7044 -> 7043;
7044 -> 7040;
7045 -> 7040;
7045 -> 7029;
7046 -> 7029;
7047 -> 7046;
7047 -> 7029;
7048 -> 7045;
7048 -> 7047;
7048 -> 7029;
7049 -> 7029;
7049 -> 7001;
7050 -> 7029;
7051 -> 7029;
7052 -> 7029;
7053 -> 7029;
7053 -> 7052;
7054 -> 7053;
7054 -> 7001;
7054 -> 7029;
7054 -> 7052;
7055 -> 7054;
7055 -> 7029;
7056 -> 7029;
7056 -> 7027;
7057 -> 7029;
7057 -> 7027;
7058 -> 7029;
7058 -> 7027;
7059 -> 7027;
7060 -> 7058;
7060 -> 7059;
7061 -> 7027;
7062 -> 7029;
7062 -> 7061;
7063 -> 7062;
7063 -> 7027;
7064 -> 7027;
7065 -> 7063;
7065 -> 7064;
7066 -> 7029;
7066 -> 7023;
7067 -> 7023;
7068 -> 7025;
7068 -> 7067;
7069 -> 7068;
7069 -> 7029;
7069 -> 7067;
7070 -> 7069;
7070 -> 7023;
7071 -> 7023;
7072 -> 7025;
7072 -> 7071;
7073 -> 7072;
7073 -> 7029;
7073 -> 7071;
7074 -> 7073;
7074 -> 7023;
7075 -> 7023;
7076 -> 7074;
7076 -> 7075;
7077 -> 7070;
7077 -> 7076;
7077 -> 7023;
7078 -> 7066;
7078 -> 7023;
7079 -> 7078;
7079 -> 7021;
7080 -> 7001;
7080 -> 7002;
7081 -> 6938;
7081 -> 6989;
7082 -> 6989;
7083 -> 7081;
7083 -> 7082;
7084 -> 6941;
7084 -> 7082;
7085 -> 7082;
7086 -> 7084;
7086 -> 7085;
7087 -> 7086;
7087 -> 7079;
7087 -> 7085;
7088 -> 7087;
7088 -> 7082;
7089 -> 7082;
7090 -> 7088;
7090 -> 7089;
7091 -> 7090;
7092 -> 7090;
7093 -> 7091;
7093 -> 7092;
7094 -> 7093;
7094 -> 7092;
7095 -> 7092;
7096 -> 7094;
7096 -> 7095;
7097 -> 7096;
7097 -> 7095;
7098 -> 0;
7098 -> 7097;
7099 -> 7098;
7099 -> 6989;
7100 -> 7079;
7100 -> 6937;
7101 -> 6938;
7101 -> 6937;
7102 -> 6940;
7102 -> 6937;
7103 -> 6937;
7104 -> 7100;
7104 -> 7103;
7105 -> 7101;
7105 -> 7103;
7106 -> 7102;
7106 -> 7103;
7107 -> 6941;
7107 -> 7103;
7108 -> 7103;
7109 -> 7104;
7109 -> 7108;
7110 -> 7109;
7110 -> 7103;
7111 -> 7104;
7111 -> 7110;
7112 -> 7111;
7112 -> 7079;
7112 -> 7110;
7113 -> 7110;
7114 -> 7112;
7114 -> 7113;
7115 -> 7114;
7115 -> 7110;
7116 -> 7103;
7117 -> 7107;
7117 -> 7116;
7118 -> 7117;
7118 -> 7079;
7118 -> 7116;
7119 -> 7118;
7119 -> 7103;
7120 -> 7103;
7121 -> 7119;
7121 -> 7120;
7122 -> 7103;
7123 -> 7103;
7124 -> 7122;
7124 -> 7123;
7125 -> 7107;
7125 -> 7123;
7126 -> 7123;
7127 -> 7123;
7128 -> 7125;
7128 -> 7127;
7129 -> 7128;
7129 -> 7079;
7129 -> 7127;
7130 -> 7129;
7130 -> 7123;
7131 -> 7123;
7132 -> 7130;
7132 -> 7131;
7133 -> 7123;
7134 -> 7133;
7134 -> 7103;
7135 -> 7103;
7136 -> 7104;
7136 -> 7135;
7136 -> 7103;
7137 -> 7106;
7137 -> 7136;
7138 -> 7136;
7139 -> 7136;
7140 -> 7137;
7140 -> 7139;
7141 -> 7138;
7141 -> 7139;
7142 -> 7107;
7142 -> 7139;
7143 -> 7139;
7144 -> 7139;
7145 -> 7142;
7145 -> 7144;
7146 -> 7144;
7147 -> 7146;
7147 -> 7139;
7148 -> 7139;
7149 -> 7148;
7149 -> 7136;
7150 -> 7104;
7150 -> 7149;
7151 -> 7149;
7152 -> 7149;
7153 -> 7150;
7153 -> 7152;
7154 -> 7151;
7154 -> 7152;
7155 -> 7151;
7155 -> 7152;
7156 -> 7107;
7156 -> 7152;
7157 -> 7152;
7158 -> 7153;
7158 -> 7152;
7159 -> 7153;
7159 -> 7079;
7159 -> 7152;
7160 -> 7156;
7160 -> 7079;
7160 -> 7152;
7161 -> 7158;
7161 -> 7159;
7162 -> 7159;
7163 -> 7161;
7163 -> 7162;
7164 -> 7105;
7164 -> 7162;
7165 -> 7162;
7166 -> 7163;
7166 -> 7165;
7167 -> 7164;
7167 -> 7165;
7168 -> 7107;
7168 -> 7165;
7169 -> 7165;
7170 -> 7169;
7171 -> 7168;
7171 -> 7170;
7172 -> 7171;
7172 -> 7169;
7173 -> 7169;
7174 -> 7172;
7174 -> 7173;
7175 -> 7169;
7176 -> 7169;
7177 -> 7174;
7177 -> 7169;
7178 -> 7169;
7179 -> 7177;
7179 -> 7178;
7180 -> 7179;
7180 -> 7178;
7181 -> 7178;
7182 -> 7180;
7182 -> 7181;
7183 -> 7182;
7183 -> 7181;
7184 -> 7181;
7185 -> 7183;
7185 -> 7184;
7186 -> 7185;
7186 -> 7184;
7187 -> 0;
7187 -> 7186;
7188 -> 7174;
7188 -> 7187;
7189 -> 7187;
7190 -> 7188;
7190 -> 7189;
7191 -> 7190;
7191 -> 7189;
7192 -> 7189;
7193 -> 7191;
7193 -> 7192;
7194 -> 7193;
7194 -> 7192;
7195 -> 7194;
7196 -> 7174;
7196 -> 0;
7196 -> 7195;
7197 -> 7174;
7197 -> 0;
7197 -> 7196;
7198 -> 7174;
7198 -> 0;
7198 -> 7197;
7199 -> 7165;
7200 -> 7168;
7200 -> 7199;
7201 -> 7200;
7201 -> 7165;
7202 -> 7165;
7203 -> 7201;
7203 -> 7202;
7204 -> 7166;
7204 -> 7162;
7205 -> 7204;
7205 -> 7107;
7205 -> 7079;
7205 -> 7162;
7206 -> 7162;
7207 -> 7205;
7207 -> 7206;
7208 -> 7205;
7208 -> 7206;
7209 -> 7205;
7209 -> 7206;
7210 -> 7205;
7210 -> 7206;
7211 -> 7207;
7211 -> 7206;
7212 -> 7208;
7212 -> 7206;
7213 -> 7209;
7213 -> 7206;
7214 -> 7206;
7215 -> 7213;
7215 -> 7214;
7216 -> 7215;
7216 -> 7205;
7216 -> 7214;
7217 -> 7215;
7217 -> 7205;
7217 -> 7214;
7218 -> 7214;
7218 -> 7206;
7219 -> 7210;
7219 -> 7206;
7220 -> 7211;
7220 -> 7212;
7220 -> 7218;
7220 -> 7219;
7220 -> 7205;
7220 -> 7206;
7221 -> 7220;
7221 -> 7206;
7222 -> 7220;
7222 -> 7206;
7223 -> 7221;
7223 -> 7206;
7224 -> 7221;
7224 -> 7206;
7225 -> 6937;
7226 -> 7220;
7226 -> 7225;
7226 -> 6937;
7227 -> 7220;
7227 -> 7226;
7228 -> 6960;
7228 -> 7226;
7229 -> 7226;
7230 -> 7228;
7230 -> 7229;
7231 -> 7230;
7231 -> 6959;
7231 -> 7229;
7232 -> 7231;
7232 -> 7229;
7233 -> 7229;
7233 -> 7220;
7233 -> 7232;
7233 -> 6959;
7234 -> 7229;
7235 -> 7229;
7236 -> 7226;
7237 -> 6916;
7238 -> 6920;
7238 -> 7237;
7239 -> 7238;
7239 -> 7220;
7239 -> 7237;
7240 -> 7239;
7240 -> 6916;
7241 -> 6916;
7242 -> 7240;
7242 -> 7241;
7243 -> 7227;
7243 -> 6916;
7244 -> 6908;
7245 -> 6912;
7245 -> 7244;
7246 -> 7245;
7246 -> 7220;
7246 -> 7244;
7247 -> 7246;
7247 -> 6908;
7248 -> 6908;
7249 -> 7247;
7249 -> 7248;
7250 -> 7243;
7250 -> 6908;
7251 -> 7250;
7251 -> 6896;
7252 -> 7250;
7252 -> 6896;
7253 -> 7252;
7253 -> 6894;
7254 -> 6894;
7255 -> 7253;
7255 -> 7254;
7256 -> 6895;
7256 -> 7254;
7257 -> 7254;
7258 -> 7255;
7258 -> 7257;
7259 -> 7258;
7259 -> 7254;
7260 -> 7255;
7260 -> 7259;
7261 -> 7260;
7261 -> 6893;
7262 -> 6893;
7263 -> 7262;
7263 -> 7220;
7264 -> 7263;
7264 -> 6893;
7265 -> 6893;
7266 -> 7264;
7266 -> 7265;
7267 -> 6893;
7268 -> 7261;
7268 -> 7267;
7269 -> 7268;
7269 -> 6893;
7270 -> 7261;
7270 -> 6893;
7271 -> 0;
7271 -> 7270;
7272 -> 7270;
7273 -> 7271;
7273 -> 7272;
7274 -> 7273;
7274 -> 7272;
7275 -> 7272;
7276 -> 7274;
7276 -> 7275;
7277 -> 7276;
7277 -> 0;
7277 -> 7275;
7278 -> 7277;
7279 -> 7273;
7280 -> 7273;
7281 -> 6887;
7281 -> 7270;
7282 -> 7261;
7282 -> 7270;
7283 -> 7273;
7283 -> 7270;
7284 -> 7281;
7284 -> 7282;
7284 -> 7283;
7284 -> 6868;
7284 -> 7220;
7284 -> 7229;
7284 -> 7273;
7284 -> 7270;
7285 -> 7270;
7286 -> 7284;
7286 -> 7285;
7287 -> 7286;
7287 -> 7285;
7288 -> 7287;
7288 -> 7284;
7288 -> 7285;
7289 -> 7287;
7289 -> 7284;
7289 -> 7285;
7290 -> 7286;
7290 -> 7285;
7291 -> 7286;
7291 -> 7285;
7292 -> 7290;
7292 -> 7285;
7293 -> 7290;
7293 -> 7285;
7294 -> 7286;
7294 -> 6867;
7295 -> 6867;
7296 -> 6868;
7296 -> 7295;
7297 -> 7296;
7297 -> 7294;
7297 -> 7295;
7298 -> 7296;
7298 -> 7294;
7298 -> 7295;
7299 -> 7295;
7300 -> 7296;
7300 -> 7299;
7301 -> 7300;
7301 -> 7294;
7301 -> 7298;
7301 -> 7299;
7302 -> 7295;
7303 -> 7301;
7303 -> 7302;
7304 -> 7303;
7304 -> 6867;
7305 -> 6867;
7306 -> 6872;
7306 -> 7294;
7306 -> 7305;
7306 -> 6867;
7307 -> 6872;
7307 -> 7306;
7307 -> 7294;
7307 -> 7298;
7307 -> 6867;
7308 -> 7307;
7308 -> 6867;
7309 -> 6873;
7309 -> 6867;
7310 -> 6867;
7311 -> 6867;
7312 -> 7308;
7312 -> 7311;
7313 -> 7309;
7313 -> 7311;
7314 -> 7310;
7314 -> 7311;
7315 -> 6868;
7315 -> 7311;
7316 -> 7315;
7316 -> 7307;
7316 -> 7311;
7317 -> 7315;
7317 -> 7307;
7317 -> 0;
7317 -> 7311;
7318 -> 7317;
7318 -> 7315;
7318 -> 7311;
7319 -> 7314;
7319 -> 7311;
7320 -> 7315;
7320 -> 7307;
7320 -> 7318;
7320 -> 0;
7320 -> 7319;
7321 -> 7320;
7321 -> 7315;
7321 -> 7319;
7322 -> 7311;
7323 -> 7311;
7324 -> 7315;
7324 -> 7323;
7325 -> 7324;
7325 -> 7307;
7325 -> 7323;
7326 -> 7325;
7326 -> 7311;
7327 -> 7311;
7328 -> 7326;
7328 -> 7327;
7329 -> 7311;
7330 -> 7315;
7330 -> 7329;
7331 -> 7330;
7331 -> 7307;
7331 -> 7329;
7332 -> 7331;
7332 -> 7311;
7333 -> 7311;
7334 -> 7332;
7334 -> 7333;
7335 -> 7328;
7335 -> 7334;
7335 -> 7311;
7336 -> 7311;
7337 -> 7315;
7337 -> 7336;
7338 -> 7337;
7338 -> 7307;
7338 -> 7336;
7339 -> 7336;
7340 -> 7337;
7340 -> 7339;
7341 -> 7340;
7341 -> 7307;
7341 -> 7339;
7342 -> 7336;
7343 -> 7341;
7343 -> 7342;
7344 -> 7343;
7344 -> 7311;
7345 -> 7314;
7345 -> 7344;
7345 -> 7311;
7346 -> 7335;
7346 -> 7345;
7346 -> 7311;
7347 -> 7322;
7347 -> 7311;
7348 -> 7311;
7349 -> 7311;
7350 -> 7347;
7350 -> 7349;
7351 -> 7348;
7351 -> 7349;
7352 -> 7315;
7352 -> 7349;
7353 -> 7352;
7353 -> 7307;
7353 -> 7349;
7354 -> 7353;
7354 -> 7350;
7354 -> 7349;
7355 -> 7346;
7355 -> 7354;
7355 -> 7311;
7356 -> 7355;
7357 -> 7355;
7358 -> 7356;
7358 -> 7357;
7359 -> 7315;
7359 -> 7357;
7360 -> 7357;
7361 -> 7359;
7361 -> 7360;
7362 -> 7361;
7362 -> 7357;
7363 -> 7357;
7364 -> 7362;
7364 -> 7363;
7365 -> 7364;
7365 -> 7357;
7366 -> 7365;
7367 -> 7366;
7368 -> 7366;
7369 -> 7367;
7369 -> 7368;
7370 -> 7369;
7370 -> 7366;
7371 -> 7366;
7371 -> 7307;
7371 -> 7318;
7371 -> 7321;
7372 -> 7371;
7372 -> 7365;
7373 -> 7372;
7373 -> 7355;
7374 -> 7373;
7375 -> 7374;
7376 -> 7374;
7377 -> 7375;
7377 -> 7376;
7378 -> 7377;
7378 -> 7374;
7379 -> 7374;
7380 -> 7379;
7380 -> 7374;
7381 -> 7374;
7382 -> 7380;
7382 -> 7374;
7383 -> 7381;
7383 -> 7374;
7384 -> 7382;
7384 -> 7374;
7385 -> 7374;
7386 -> 7383;
7386 -> 7385;
7387 -> 7384;
7387 -> 7385;
7388 -> 7374;
7388 -> 7385;
7389 -> 7385;
7390 -> 7388;
7390 -> 7389;
7391 -> 7389;
7392 -> 7390;
7392 -> 7391;
7393 -> 7392;
7393 -> 7389;
7394 -> 7393;
7395 -> 7394;
7395 -> 7385;
7396 -> 7395;
7396 -> 7374;
7397 -> 7374;
7398 -> 7374;
7399 -> 7374;
7400 -> 7381;
7400 -> 7374;
7401 -> 7382;
7401 -> 7374;
7402 -> 7374;
7403 -> 7400;
7403 -> 7402;
7404 -> 7401;
7404 -> 7402;
7405 -> 7374;
7405 -> 7402;
7406 -> 7402;
7407 -> 7405;
7407 -> 7406;
7408 -> 7407;
7408 -> 7402;
7409 -> 7402;
7410 -> 7408;
7410 -> 7409;
7411 -> 7410;
7412 -> 7405;
7412 -> 7411;
7413 -> 7411;
7414 -> 7412;
7414 -> 7413;
7415 -> 7411;
7416 -> 7414;
7416 -> 7415;
7417 -> 7416;
7417 -> 0;
7417 -> 7411;
7418 -> 7417;
7418 -> 7411;
7419 -> 7418;
7419 -> 7410;
7420 -> 7419;
7421 -> 7405;
7421 -> 7420;
7422 -> 7420;
7423 -> 7420;
7424 -> 7422;
7424 -> 7423;
7425 -> 7421;
7425 -> 7423;
7426 -> 7423;
7427 -> 7424;
7427 -> 7426;
7427 -> 7423;
7428 -> 7425;
7428 -> 7374;
7428 -> 7424;
7428 -> 7423;
7429 -> 7425;
7429 -> 7374;
7429 -> 7424;
7430 -> 7420;
7431 -> 7429;
7431 -> 7430;
7432 -> 7431;
7432 -> 7419;
7433 -> 7432;
7434 -> 7405;
7434 -> 7433;
7435 -> 7433;
7436 -> 7434;
7436 -> 7435;
7437 -> 7436;
7437 -> 7433;
7438 -> 7433;
7439 -> 7437;
7439 -> 7438;
7440 -> 7439;
7440 -> 7432;
7441 -> 7440;
7442 -> 7405;
7442 -> 7441;
7443 -> 7441;
7444 -> 7442;
7444 -> 7443;
7445 -> 7443;
7446 -> 7444;
7446 -> 7445;
7447 -> 7445;
7448 -> 7446;
7448 -> 7374;
7448 -> 7447;
7449 -> 7448;
7449 -> 7374;
7449 -> 7447;
7450 -> 7449;
7450 -> 7445;
7451 -> 7450;
7451 -> 7443;
7452 -> 7451;
7452 -> 7441;
7453 -> 7441;
7454 -> 7442;
7454 -> 7453;
7455 -> 7454;
7455 -> 7374;
7455 -> 7453;
7456 -> 7455;
7456 -> 7441;
7457 -> 7452;
7457 -> 7456;
7457 -> 7441;
7458 -> 7457;
7458 -> 7440;
7459 -> 7458;
7460 -> 7404;
7460 -> 7458;
7461 -> 7458;
7462 -> 7459;
7462 -> 7461;
7463 -> 7460;
7463 -> 7461;
7464 -> 7405;
7464 -> 7461;
7465 -> 7461;
7466 -> 7464;
7466 -> 7465;
7467 -> 7466;
7467 -> 7461;
7468 -> 7461;
7469 -> 7467;
7469 -> 7468;
7470 -> 7461;
7470 -> 7458;
7471 -> 7402;
7472 -> 7471;
7472 -> 7374;
7473 -> 7374;
7474 -> 7472;
7474 -> 7473;
7474 -> 7374;
7475 -> 7381;
7475 -> 7374;
7476 -> 7382;
7476 -> 7374;
7477 -> 7397;
7477 -> 7374;
7478 -> 7374;
7479 -> 7475;
7479 -> 7478;
7480 -> 7476;
7480 -> 7478;
7481 -> 7477;
7481 -> 7478;
7482 -> 7374;
7482 -> 7478;
7483 -> 7480;
7483 -> 7478;
7484 -> 7483;
7484 -> 7478;
7485 -> 7478;
7486 -> 7484;
7486 -> 7485;
7487 -> 7482;
7487 -> 7485;
7488 -> 7485;
7489 -> 7487;
7489 -> 7488;
7490 -> 7489;
7490 -> 7485;
7491 -> 7485;
7492 -> 7490;
7492 -> 7491;
7493 -> 7492;
7493 -> 0;
7493 -> 7485;
7494 -> 7492;
7494 -> 7485;
7495 -> 7485;
7496 -> 7494;
7496 -> 7495;
7497 -> 7496;
7497 -> 7495;
7498 -> 7497;
7499 -> 7485;
7500 -> 7494;
7500 -> 7499;
7501 -> 7498;
7501 -> 7500;
7501 -> 7485;
7502 -> 7492;
7502 -> 0;
7502 -> 7485;
7503 -> 7485;
7504 -> 7487;
7504 -> 7503;
7505 -> 7503;
7506 -> 7504;
7506 -> 7505;
7507 -> 7503;
7508 -> 7506;
7508 -> 7507;
7509 -> 7508;
7509 -> 0;
7509 -> 7503;
7510 -> 7509;
7510 -> 7503;
7511 -> 7510;
7511 -> 7485;
7512 -> 7485;
7513 -> 7487;
7513 -> 7512;
7514 -> 7513;
7514 -> 7485;
7515 -> 7485;
7516 -> 7514;
7516 -> 7515;
7517 -> 7516;
7517 -> 7485;
7518 -> 7485;
7519 -> 7517;
7519 -> 7518;
7520 -> 7519;
7520 -> 7518;
7521 -> 7520;
7522 -> 7516;
7522 -> 0;
7522 -> 7485;
7523 -> 7521;
7523 -> 7485;
7524 -> 7486;
7524 -> 7485;
7525 -> 7485;
7526 -> 7524;
7526 -> 7525;
7527 -> 7487;
7527 -> 7525;
7528 -> 7525;
7529 -> 7527;
7529 -> 7528;
7530 -> 7529;
7530 -> 7525;
7531 -> 7525;
7532 -> 7525;
7533 -> 7531;
7533 -> 7532;
7534 -> 7527;
7534 -> 7532;
7535 -> 7532;
7536 -> 7533;
7536 -> 7535;
7536 -> 7532;
7537 -> 7534;
7537 -> 7374;
7537 -> 7533;
7537 -> 7532;
7538 -> 7534;
7538 -> 7374;
7538 -> 7533;
7539 -> 7525;
7540 -> 7530;
7540 -> 7539;
7541 -> 7538;
7541 -> 7539;
7542 -> 7531;
7542 -> 7539;
7543 -> 7527;
7543 -> 7539;
7544 -> 7540;
7544 -> 7539;
7545 -> 7539;
7546 -> 7544;
7546 -> 7545;
7547 -> 7543;
7547 -> 7545;
7548 -> 7545;
7549 -> 7546;
7549 -> 7548;
7550 -> 7549;
7550 -> 7545;
7551 -> 7545;
7552 -> 7547;
7552 -> 7551;
7553 -> 7552;
7553 -> 7545;
7554 -> 7550;
7554 -> 7553;
7554 -> 7545;
7555 -> 7554;
7556 -> 7541;
7556 -> 7555;
7557 -> 7556;
7557 -> 7554;
7558 -> 7540;
7558 -> 7557;
7559 -> 7557;
7560 -> 7558;
7560 -> 7559;
7561 -> 7560;
7562 -> 7525;
7563 -> 7561;
7563 -> 7562;
7563 -> 7525;
7564 -> 7561;
7564 -> 7563;
7565 -> 7564;
7565 -> 7485;
7566 -> 7565;
7566 -> 7478;
7567 -> 7479;
7567 -> 7566;
7568 -> 7566;
7569 -> 7567;
7569 -> 7568;
7570 -> 7482;
7570 -> 7568;
7571 -> 7569;
7571 -> 7568;
7572 -> 7568;
7573 -> 7570;
7573 -> 7572;
7574 -> 7573;
7574 -> 7374;
7574 -> 7572;
7575 -> 7572;
7576 -> 7572;
7577 -> 7573;
7577 -> 7572;
7578 -> 7572;
7579 -> 7577;
7579 -> 7578;
7580 -> 7579;
7580 -> 7578;
7581 -> 7580;
7582 -> 7573;
7583 -> 7573;
7584 -> 7582;
7584 -> 7583;
7585 -> 7584;
7585 -> 7573;
7586 -> 7573;
7587 -> 7573;
7588 -> 7573;
7589 -> 7573;
7590 -> 7588;
7590 -> 7589;
7591 -> 7590;
7591 -> 7573;
7592 -> 7573;
7593 -> 7591;
7593 -> 7592;
7594 -> 7592;
7595 -> 7592;
7596 -> 7594;
7596 -> 7595;
7597 -> 7596;
7597 -> 7592;
7598 -> 7592;
7599 -> 7592;
7600 -> 7598;
7600 -> 7599;
7601 -> 7599;
7602 -> 7600;
7602 -> 7601;
7602 -> 7599;
7603 -> 7599;
7603 -> 7374;
7603 -> 7600;
7604 -> 7592;
7605 -> 7600;
7605 -> 7604;
7606 -> 7592;
7607 -> 7598;
7607 -> 7606;
7608 -> 7606;
7609 -> 7607;
7609 -> 7608;
7609 -> 7606;
7610 -> 7606;
7610 -> 7374;
7610 -> 7607;
7611 -> 7592;
7612 -> 7607;
7612 -> 7611;
7613 -> 7605;
7613 -> 7612;
7613 -> 7592;
7614 -> 7592;
7615 -> 7599;
7615 -> 7374;
7615 -> 7592;
7616 -> 7599;
7617 -> 7599;
7618 -> 7617;
7618 -> 7599;
7619 -> 7599;
7620 -> 7618;
7620 -> 7619;
7621 -> 7599;
7622 -> 7621;
7622 -> 7599;
7623 -> 7599;
7624 -> 7622;
7624 -> 7623;
7625 -> 7620;
7625 -> 7624;
7625 -> 7599;
7626 -> 7616;
7626 -> 0;
7626 -> 7599;
7627 -> 7599;
7628 -> 7599;
7629 -> 7617;
7630 -> 7617;
7630 -> 7599;
7631 -> 7599;
7632 -> 7630;
7632 -> 7631;
7633 -> 7631;
7634 -> 7632;
7634 -> 7633;
7634 -> 7631;
7635 -> 7631;
7635 -> 7374;
7635 -> 7632;
7636 -> 7599;
7637 -> 7632;
7637 -> 7636;
7638 -> 7617;
7638 -> 7599;
7639 -> 7599;
7640 -> 7638;
7640 -> 7639;
7641 -> 7639;
7642 -> 7640;
7642 -> 7641;
7642 -> 7639;
7643 -> 7639;
7643 -> 7374;
7643 -> 7640;
7644 -> 7599;
7645 -> 7640;
7645 -> 7644;
7646 -> 7599;
7647 -> 7617;
7647 -> 7646;
7647 -> 7599;
7648 -> 7599;
7649 -> 7647;
7649 -> 7648;
7650 -> 7648;
7651 -> 7649;
7651 -> 7650;
7651 -> 7648;
7652 -> 7648;
7652 -> 7374;
7652 -> 7649;
7653 -> 7599;
7654 -> 7649;
7654 -> 7653;
7655 -> 7645;
7655 -> 7654;
7655 -> 7599;
7656 -> 7617;
7656 -> 7599;
7657 -> 7599;
7658 -> 7656;
7658 -> 7657;
7659 -> 7657;
7660 -> 7658;
7660 -> 7659;
7660 -> 7657;
7661 -> 7657;
7661 -> 7374;
7661 -> 7658;
7662 -> 7599;
7663 -> 7658;
7663 -> 7662;
7664 -> 7617;
7664 -> 7601;
7664 -> 7599;
7665 -> 7631;
7665 -> 7374;
7665 -> 7617;
7665 -> 7599;
7666 -> 7631;
7666 -> 7374;
7666 -> 7617;
7667 -> 7666;
7668 -> 7667;
7668 -> 7666;
7669 -> 7666;
7670 -> 7666;
7671 -> 7666;
7671 -> 7670;
7672 -> 7670;
7673 -> 7671;
7673 -> 7672;
7674 -> 7673;
7674 -> 7670;
7675 -> 7674;
7676 -> 7675;
7676 -> 7666;
7677 -> 7669;
7677 -> 7666;
7678 -> 7666;
7679 -> 7666;
7679 -> 7678;
7680 -> 7678;
7681 -> 7679;
7681 -> 7680;
7682 -> 7681;
7682 -> 7678;
7683 -> 7678;
7683 -> 7666;
7684 -> 7666;
7685 -> 7684;
7685 -> 7666;
7686 -> 7683;
7686 -> 7685;
7686 -> 7666;
7687 -> 7666;
7687 -> 7374;
7688 -> 7666;
7689 -> 7666;
7690 -> 7666;
7691 -> 7666;
7691 -> 7690;
7692 -> 7691;
7692 -> 7374;
7692 -> 7573;
7692 -> 7666;
7692 -> 7690;
7693 -> 7692;
7693 -> 7666;
7694 -> 7669;
7694 -> 7666;
7695 -> 7666;
7695 -> 7669;
7696 -> 7669;
7696 -> 7666;
7697 -> 7666;
7698 -> 7696;
7698 -> 7697;
7699 -> 7666;
7700 -> 7699;
7700 -> 7669;
7701 -> 7700;
7701 -> 7666;
7702 -> 7666;
7703 -> 7701;
7703 -> 7702;
7704 -> 7669;
7704 -> 7592;
7705 -> 7592;
7706 -> 7704;
7706 -> 7705;
7707 -> 7705;
7708 -> 7706;
7708 -> 7707;
7709 -> 7708;
7709 -> 7705;
7710 -> 7709;
7711 -> 7710;
7711 -> 7592;
7712 -> 7592;
7713 -> 0;
7713 -> 7592;
7714 -> 7712;
7714 -> 7713;
7714 -> 7704;
7714 -> 7669;
7714 -> 7592;
7715 -> 7714;
7715 -> 7712;
7716 -> 7714;
7716 -> 7712;
7717 -> 7715;
7717 -> 7712;
7718 -> 7712;
7719 -> 7717;
7719 -> 7718;
7720 -> 7719;
7720 -> 0;
7720 -> 7718;
7721 -> 7720;
7722 -> 7712;
7723 -> 7716;
7723 -> 7722;
7724 -> 7723;
7724 -> 7712;
7725 -> 7712;
7726 -> 7724;
7726 -> 7725;
7727 -> 7726;
7727 -> 7712;
7728 -> 7727;
7728 -> 7715;
7728 -> 7712;
7729 -> 7728;
7730 -> 7729;
7730 -> 7714;
7731 -> 7729;
7732 -> 7728;
7733 -> 7724;
7733 -> 7728;
7734 -> 7714;
7734 -> 7733;
7734 -> 7729;
7734 -> 7592;
7735 -> 7714;
7735 -> 7734;
7735 -> 7712;
7736 -> 7734;
7737 -> 7734;
7738 -> 7734;
7739 -> 7734;
7739 -> 7592;
7740 -> 7592;
7741 -> 7739;
7741 -> 7740;
7742 -> 7741;
7742 -> 7739;
7742 -> 7740;
7743 -> 7741;
7743 -> 7739;
7743 -> 7740;
7744 -> 7739;
7744 -> 7740;
7745 -> 7739;
7745 -> 7740;
7746 -> 7744;
7746 -> 7740;
7747 -> 7744;
7747 -> 7740;
7748 -> 7669;
7748 -> 7592;
7749 -> 7669;
7749 -> 7592;
7750 -> 7669;
7750 -> 7592;
7751 -> 7669;
7751 -> 7592;
7752 -> 7669;
7752 -> 7592;
7753 -> 7748;
7753 -> 7592;
7754 -> 7749;
7754 -> 7592;
7755 -> 7750;
7755 -> 7592;
7756 -> 7751;
7756 -> 7592;
7757 -> 7592;
7758 -> 7756;
7758 -> 7757;
7759 -> 7758;
7759 -> 7739;
7759 -> 7757;
7760 -> 7758;
7760 -> 7739;
7760 -> 7757;
7761 -> 7757;
7761 -> 7592;
7762 -> 7752;
7762 -> 7592;
7763 -> 7753;
7763 -> 7754;
7763 -> 7755;
7763 -> 7761;
7763 -> 7762;
7763 -> 7739;
7763 -> 7592;
7764 -> 7763;
7764 -> 7592;
7765 -> 7763;
7765 -> 7592;
7766 -> 7764;
7766 -> 7592;
7767 -> 7764;
7767 -> 7592;
7768 -> 7763;
7768 -> 7712;
7769 -> 7572;
7770 -> 7573;
7770 -> 7572;
7771 -> 7572;
7772 -> 7771;
7773 -> 7770;
7773 -> 7772;
7774 -> 7773;
7774 -> 7763;
7774 -> 7772;
7775 -> 7774;
7775 -> 7771;
7776 -> 7771;
7777 -> 7775;
7777 -> 7776;
7778 -> 7771;
7779 -> 7771;
7780 -> 7777;
7780 -> 7771;
7781 -> 7771;
7782 -> 7780;
7782 -> 7781;
7783 -> 7782;
7783 -> 7781;
7784 -> 7781;
7785 -> 7783;
7785 -> 7784;
7786 -> 7785;
7786 -> 7784;
7787 -> 7784;
7788 -> 7786;
7788 -> 7787;
7789 -> 7788;
7789 -> 7787;
7790 -> 0;
7790 -> 7789;
7791 -> 7777;
7791 -> 7790;
7792 -> 7790;
7793 -> 7791;
7793 -> 7792;
7794 -> 7793;
7794 -> 7792;
7795 -> 7792;
7796 -> 7794;
7796 -> 7795;
7797 -> 7796;
7797 -> 7795;
7798 -> 7797;
7799 -> 7777;
7799 -> 0;
7799 -> 7798;
7800 -> 7777;
7800 -> 0;
7800 -> 7799;
7801 -> 7777;
7801 -> 0;
7801 -> 7800;
7802 -> 7572;
7803 -> 7770;
7803 -> 7802;
7804 -> 7803;
7804 -> 7763;
7804 -> 7802;
7805 -> 7804;
7805 -> 7572;
7806 -> 7572;
7807 -> 7805;
7807 -> 7806;
7808 -> 7572;
7809 -> 7572;
7810 -> 7763;
7810 -> 7809;
7811 -> 7810;
7811 -> 7572;
7812 -> 7572;
7813 -> 7811;
7813 -> 7812;
7814 -> 7813;
7814 -> 7812;
7815 -> 0;
7815 -> 7814;
7816 -> 7763;
7816 -> 7568;
7817 -> 7568;
7818 -> 7571;
7818 -> 7817;
7819 -> 7816;
7819 -> 7817;
7820 -> 7570;
7820 -> 7817;
7821 -> 7817;
7822 -> 7817;
7823 -> 7820;
7823 -> 7822;
7824 -> 7822;
7825 -> 7823;
7825 -> 7824;
7826 -> 7824;
7827 -> 7825;
7827 -> 7763;
7827 -> 7826;
7828 -> 7827;
7828 -> 7763;
7828 -> 7826;
7829 -> 7828;
7829 -> 7824;
7830 -> 7829;
7830 -> 7822;
7831 -> 7830;
7831 -> 7817;
7832 -> 0;
7832 -> 7831;
7833 -> 7831;
7834 -> 7832;
7834 -> 7833;
7835 -> 7834;
7835 -> 7833;
7836 -> 7833;
7837 -> 7835;
7837 -> 7836;
7838 -> 7837;
7838 -> 0;
7838 -> 7836;
7839 -> 7838;
7840 -> 7834;
7841 -> 7834;
7842 -> 7818;
7842 -> 7817;
7843 -> 7819;
7843 -> 7817;
7844 -> 7834;
7844 -> 7817;
7845 -> 7842;
7845 -> 7843;
7845 -> 7844;
7845 -> 7820;
7845 -> 7763;
7845 -> 7374;
7845 -> 7834;
7845 -> 7817;
7846 -> 7817;
7847 -> 7845;
7847 -> 7846;
7848 -> 7847;
7848 -> 7845;
7848 -> 7846;
7849 -> 7847;
7849 -> 7845;
7849 -> 7846;
7850 -> 7845;
7850 -> 7846;
7851 -> 7845;
7851 -> 7846;
7852 -> 7850;
7852 -> 7846;
7853 -> 7850;
7853 -> 7846;
7854 -> 7374;
7854 -> 7845;
7855 -> 7481;
7855 -> 7374;
7856 -> 7374;
7857 -> 7855;
7857 -> 7856;
7858 -> 7857;
7858 -> 7374;
7858 -> 7856;
7859 -> 7858;
7859 -> 7856;
7860 -> 7856;
7860 -> 7845;
7860 -> 7859;
7860 -> 7374;
7861 -> 7856;
7861 -> 7845;
7862 -> 7856;
7863 -> 7856;
7863 -> 7845;
7863 -> 7861;
7863 -> 7862;
7864 -> 7856;
7865 -> 7374;
7866 -> 7845;
7866 -> 7373;
7867 -> 7373;
7868 -> 7866;
7868 -> 7867;
7868 -> 7373;
7869 -> 7866;
7869 -> 7868;
7870 -> 7313;
7870 -> 7869;
7870 -> 6873;
7870 -> 7845;
7870 -> 7854;
7870 -> 7861;
7870 -> 7868;
7871 -> 7355;
7871 -> 7870;
7872 -> 7870;
7873 -> 7870;
7874 -> 7870;
7875 -> 7870;
7876 -> 7874;
7876 -> 7875;
7877 -> 7876;
7877 -> 7870;
7878 -> 7870;
7879 -> 7870;
7880 -> 7878;
7880 -> 7879;
7881 -> 7880;
7881 -> 7870;
7882 -> 7870;
7883 -> 7882;
7883 -> 7870;
7884 -> 7883;
7884 -> 7870;
7885 -> 7870;
7886 -> 7884;
7886 -> 7870;
7887 -> 7870;
7888 -> 7885;
7888 -> 7887;
7889 -> 7886;
7889 -> 7887;
7890 -> 7870;
7890 -> 7887;
7891 -> 7887;
7892 -> 7890;
7892 -> 7891;
7893 -> 7891;
7894 -> 7892;
7894 -> 7893;
7895 -> 7894;
7895 -> 7891;
7896 -> 7895;
7897 -> 7896;
7897 -> 7887;
7898 -> 7897;
7898 -> 7870;
7899 -> 7870;
7900 -> 7870;
7901 -> 7870;
7902 -> 7870;
7903 -> 7884;
7903 -> 7870;
7904 -> 7870;
7905 -> 7902;
7905 -> 7904;
7906 -> 7903;
7906 -> 7904;
7907 -> 7870;
7907 -> 7904;
7908 -> 7904;
7909 -> 7907;
7909 -> 7908;
7910 -> 7909;
7910 -> 7904;
7911 -> 7904;
7912 -> 7910;
7912 -> 7911;
7913 -> 7912;
7914 -> 7907;
7914 -> 7913;
7915 -> 7913;
7916 -> 7914;
7916 -> 7915;
7917 -> 7913;
7918 -> 7916;
7918 -> 7917;
7919 -> 7918;
7919 -> 0;
7919 -> 7913;
7920 -> 7919;
7920 -> 7913;
7921 -> 7920;
7921 -> 7912;
7922 -> 7921;
7923 -> 7907;
7923 -> 7922;
7924 -> 7922;
7925 -> 7922;
7926 -> 7924;
7926 -> 7925;
7927 -> 7923;
7927 -> 7925;
7928 -> 7925;
7929 -> 7926;
7929 -> 7928;
7929 -> 7925;
7930 -> 7927;
7930 -> 7870;
7930 -> 7926;
7930 -> 7925;
7931 -> 7927;
7931 -> 7870;
7931 -> 7926;
7932 -> 7922;
7933 -> 7931;
7933 -> 7932;
7934 -> 7933;
7934 -> 7921;
7935 -> 7934;
7936 -> 7907;
7936 -> 7935;
7937 -> 7935;
7938 -> 7936;
7938 -> 7937;
7939 -> 7938;
7939 -> 7935;
7940 -> 7935;
7941 -> 7939;
7941 -> 7940;
7942 -> 7941;
7942 -> 7934;
7943 -> 7942;
7944 -> 7907;
7944 -> 7943;
7945 -> 7943;
7946 -> 7944;
7946 -> 7945;
7947 -> 7946;
7947 -> 7943;
7948 -> 7943;
7949 -> 7944;
7949 -> 7948;
7950 -> 7949;
7950 -> 7870;
7950 -> 7948;
7951 -> 7950;
7951 -> 7943;
7952 -> 7947;
7952 -> 7951;
7952 -> 7943;
7953 -> 7952;
7953 -> 7942;
7954 -> 7953;
7955 -> 7906;
7955 -> 7953;
7956 -> 7953;
7957 -> 7954;
7957 -> 7956;
7958 -> 7955;
7958 -> 7956;
7959 -> 7907;
7959 -> 7956;
7960 -> 7956;
7961 -> 7959;
7961 -> 7960;
7962 -> 7961;
7962 -> 7956;
7963 -> 7956;
7963 -> 7953;
7964 -> 7904;
7965 -> 7964;
7965 -> 7870;
7966 -> 7870;
7967 -> 7965;
7967 -> 7966;
7967 -> 7870;
7968 -> 7884;
7968 -> 7870;
7969 -> 7899;
7969 -> 7870;
7970 -> 7968;
7970 -> 7870;
7971 -> 7970;
7971 -> 7870;
7972 -> 7870;
7973 -> 7972;
7973 -> 7870;
7974 -> 7870;
7975 -> 7973;
7975 -> 7974;
7976 -> 7975;
7976 -> 0;
7976 -> 7870;
7977 -> 7975;
7977 -> 7870;
7978 -> 7870;
7979 -> 7977;
7979 -> 7978;
7980 -> 7979;
7980 -> 7978;
7981 -> 7980;
7982 -> 7870;
7983 -> 7977;
7983 -> 7982;
7984 -> 7981;
7984 -> 7983;
7984 -> 7870;
7985 -> 7975;
7985 -> 0;
7985 -> 7870;
7986 -> 7870;
7987 -> 7870;
7987 -> 7986;
7988 -> 7986;
7989 -> 7987;
7989 -> 7988;
7990 -> 7986;
7991 -> 7989;
7991 -> 7990;
7992 -> 7991;
7992 -> 0;
7992 -> 7986;
7993 -> 7992;
7993 -> 7986;
7994 -> 7993;
7994 -> 7870;
7995 -> 7870;
7996 -> 7995;
7996 -> 7870;
7997 -> 7870;
7998 -> 7996;
7998 -> 7997;
7999 -> 7998;
7999 -> 7870;
8000 -> 7870;
8001 -> 7999;
8001 -> 8000;
8002 -> 8001;
8002 -> 8000;
8003 -> 8002;
8004 -> 7998;
8004 -> 0;
8004 -> 7870;
8005 -> 8003;
8005 -> 7870;
8006 -> 7971;
8006 -> 7870;
8007 -> 7870;
8008 -> 7972;
8008 -> 8007;
8008 -> 7870;
8009 -> 7870;
8009 -> 7972;
8010 -> 7972;
8010 -> 7870;
8011 -> 7972;
8011 -> 7870;
8012 -> 7972;
8013 -> 7972;
8014 -> 7972;
8015 -> 7972;
8016 -> 8014;
8016 -> 8015;
8017 -> 8016;
8017 -> 8015;
8018 -> 8017;
8019 -> 7972;
8020 -> 7972;
8021 -> 8019;
8021 -> 8020;
8022 -> 8021;
8022 -> 7972;
8023 -> 7972;
8024 -> 7972;
8025 -> 7972;
8026 -> 7972;
8027 -> 8025;
8027 -> 8026;
8028 -> 8027;
8028 -> 7972;
8029 -> 7972;
8030 -> 7972;
8031 -> 8029;
8031 -> 8030;
8032 -> 8031;
8032 -> 7972;
8033 -> 7972;
8034 -> 7972;
8035 -> 8033;
8035 -> 8034;
8035 -> 7972;
8036 -> 7972;
8036 -> 7870;
8036 -> 8033;
8037 -> 7972;
8038 -> 8033;
8038 -> 8037;
8039 -> 7972;
8040 -> 8033;
8040 -> 8039;
8041 -> 8039;
8042 -> 8040;
8042 -> 8041;
8042 -> 8039;
8043 -> 8039;
8043 -> 7870;
8043 -> 8040;
8044 -> 7972;
8045 -> 8040;
8045 -> 8044;
8046 -> 8038;
8046 -> 8045;
8046 -> 7972;
8047 -> 8039;
8047 -> 7870;
8047 -> 8033;
8047 -> 7972;
8048 -> 8039;
8048 -> 7870;
8048 -> 8033;
8049 -> 8048;
8050 -> 8048;
8051 -> 8048;
8052 -> 8050;
8052 -> 8051;
8053 -> 8048;
8054 -> 8053;
8054 -> 8048;
8055 -> 8048;
8056 -> 8054;
8056 -> 8055;
8057 -> 8052;
8057 -> 8056;
8057 -> 8048;
8058 -> 8049;
8058 -> 0;
8058 -> 8048;
8059 -> 8048;
8060 -> 8048;
8061 -> 8053;
8062 -> 8053;
8062 -> 8048;
8063 -> 8048;
8064 -> 8062;
8064 -> 8063;
8064 -> 8048;
8065 -> 8048;
8065 -> 7870;
8065 -> 8062;
8066 -> 8048;
8067 -> 8062;
8067 -> 8066;
8068 -> 8053;
8068 -> 8048;
8069 -> 8048;
8070 -> 8068;
8070 -> 8069;
8071 -> 8069;
8072 -> 8070;
8072 -> 8071;
8072 -> 8069;
8073 -> 8069;
8073 -> 7870;
8073 -> 8070;
8074 -> 8048;
8075 -> 8070;
8075 -> 8074;
8076 -> 8048;
8077 -> 8053;
8077 -> 8076;
8077 -> 8048;
8078 -> 8048;
8079 -> 8077;
8079 -> 8078;
8080 -> 8078;
8081 -> 8079;
8081 -> 8080;
8081 -> 8078;
8082 -> 8078;
8082 -> 7870;
8082 -> 8079;
8083 -> 8048;
8084 -> 8079;
8084 -> 8083;
8085 -> 8075;
8085 -> 8084;
8085 -> 8048;
8086 -> 8053;
8086 -> 8048;
8087 -> 8048;
8088 -> 8086;
8088 -> 8087;
8089 -> 8087;
8090 -> 8088;
8090 -> 8089;
8090 -> 8087;
8091 -> 8087;
8091 -> 7870;
8091 -> 8088;
8092 -> 8048;
8093 -> 8088;
8093 -> 8092;
8094 -> 8069;
8094 -> 7870;
8094 -> 8062;
8094 -> 8048;
8095 -> 8069;
8095 -> 7870;
8095 -> 8062;
8096 -> 8095;
8097 -> 8096;
8097 -> 8095;
8098 -> 8095;
8099 -> 8095;
8099 -> 8098;
8100 -> 8098;
8101 -> 8099;
8101 -> 8100;
8102 -> 8101;
8102 -> 8098;
8103 -> 8102;
8104 -> 8103;
8104 -> 8095;
8105 -> 8095;
8106 -> 8095;
8107 -> 8095;
8107 -> 8106;
8108 -> 8106;
8109 -> 8107;
8109 -> 8108;
8110 -> 8109;
8110 -> 8106;
8111 -> 8106;
8111 -> 8095;
8112 -> 8095;
8113 -> 8112;
8113 -> 8095;
8114 -> 8111;
8114 -> 8113;
8114 -> 8095;
8115 -> 8095;
8115 -> 7870;
8116 -> 8095;
8117 -> 8095;
8118 -> 8095;
8119 -> 8095;
8119 -> 8118;
8120 -> 8119;
8120 -> 7870;
8120 -> 7972;
8120 -> 8095;
8120 -> 8118;
8121 -> 8120;
8121 -> 8095;
8122 -> 8095;
8123 -> 8095;
8124 -> 8095;
8125 -> 8095;
8126 -> 8124;
8126 -> 8125;
8127 -> 8095;
8128 -> 8127;
8128 -> 8095;
8129 -> 8095;
8130 -> 8128;
8130 -> 8129;
8131 -> 7972;
8132 -> 8096;
8132 -> 8131;
8133 -> 8131;
8134 -> 8132;
8134 -> 8133;
8135 -> 8134;
8135 -> 8131;
8136 -> 8135;
8137 -> 8136;
8137 -> 7972;
8138 -> 8096;
8138 -> 7972;
8139 -> 7972;
8140 -> 8138;
8140 -> 8139;
8141 -> 8140;
8141 -> 0;
8141 -> 8139;
8142 -> 8141;
8143 -> 8096;
8144 -> 8096;
8145 -> 8096;
8146 -> 8096;
8146 -> 7972;
8147 -> 8096;
8147 -> 7972;
8148 -> 8147;
8148 -> 8096;
8148 -> 7972;
8149 -> 8147;
8149 -> 8096;
8149 -> 7972;
8150 -> 8096;
8150 -> 7972;
8151 -> 8150;
8151 -> 7972;
8152 -> 8151;
8152 -> 8096;
8152 -> 7972;
8153 -> 8151;
8153 -> 8096;
8153 -> 7972;
8154 -> 8150;
8154 -> 7972;
8155 -> 8150;
8155 -> 7972;
8156 -> 8154;
8156 -> 7972;
8157 -> 8154;
8157 -> 7972;
8158 -> 8150;
8158 -> 7972;
8159 -> 7972;
8160 -> 7972;
8161 -> 7972;
8162 -> 8161;
8163 -> 8160;
8163 -> 8162;
8164 -> 8163;
8164 -> 8150;
8164 -> 8162;
8165 -> 8164;
8165 -> 8161;
8166 -> 8161;
8167 -> 8165;
8167 -> 8166;
8168 -> 8161;
8169 -> 8161;
8170 -> 8167;
8170 -> 8161;
8171 -> 8161;
8172 -> 8170;
8172 -> 8171;
8173 -> 8172;
8173 -> 8171;
8174 -> 8171;
8175 -> 8173;
8175 -> 8174;
8176 -> 8175;
8176 -> 8174;
8177 -> 8174;
8178 -> 8176;
8178 -> 8177;
8179 -> 8178;
8179 -> 8177;
8180 -> 0;
8180 -> 8179;
8181 -> 8167;
8181 -> 8180;
8182 -> 8180;
8183 -> 8181;
8183 -> 8182;
8184 -> 8183;
8184 -> 8182;
8185 -> 8182;
8186 -> 8184;
8186 -> 8185;
8187 -> 8186;
8187 -> 8185;
8188 -> 8187;
8189 -> 8167;
8189 -> 0;
8189 -> 8188;
8190 -> 8167;
8190 -> 0;
8190 -> 8189;
8191 -> 8167;
8191 -> 0;
8191 -> 8190;
8192 -> 7972;
8193 -> 8160;
8193 -> 8192;
8194 -> 8193;
8194 -> 8150;
8194 -> 8192;
8195 -> 8194;
8195 -> 7972;
8196 -> 7972;
8197 -> 8195;
8197 -> 8196;
8198 -> 7972;
8199 -> 7972;
8200 -> 8150;
8200 -> 8199;
8201 -> 8200;
8201 -> 7972;
8202 -> 7972;
8203 -> 8201;
8203 -> 8202;
8204 -> 8203;
8204 -> 8202;
8205 -> 0;
8205 -> 8204;
8206 -> 7972;
8207 -> 8150;
8208 -> 8150;
8209 -> 8207;
8209 -> 8208;
8210 -> 8209;
8210 -> 0;
8210 -> 8208;
8211 -> 8210;
8212 -> 8150;
8213 -> 8150;
8214 -> 8151;
8214 -> 8150;
8214 -> 7972;
8215 -> 8151;
8215 -> 8150;
8215 -> 7972;
8216 -> 7969;
8216 -> 7870;
8217 -> 8216;
8217 -> 7870;
8218 -> 8217;
8218 -> 7870;
8219 -> 8218;
8219 -> 7870;
8220 -> 7870;
8220 -> 8150;
8220 -> 8219;
8221 -> 7870;
8222 -> 7870;
8222 -> 8150;
8222 -> 8221;
8223 -> 7870;
8224 -> 7870;
8225 -> 7316;
8225 -> 7315;
8225 -> 8150;
8226 -> 6867;
8227 -> 6872;
8227 -> 8150;
8227 -> 8226;
8227 -> 6867;
8228 -> 7312;
8228 -> 8227;
8228 -> 6867;
8229 -> 8228;
8229 -> 6867;
8230 -> 6873;
8230 -> 6867;
8231 -> 8229;
8231 -> 8230;
8231 -> 6868;
8231 -> 8150;
8231 -> 6873;
8231 -> 8225;
8231 -> 6867;
8232 -> 6867;
8233 -> 8232;
8234 -> 8231;
8234 -> 8233;
8235 -> 8234;
8235 -> 8231;
8235 -> 8233;
8236 -> 8234;
8236 -> 8231;
8236 -> 8233;
8237 -> 8233;
8237 -> 8232;
8238 -> 8231;
8238 -> 8232;
8239 -> 8231;
8239 -> 8232;
8240 -> 8238;
8240 -> 8232;
8241 -> 8238;
8241 -> 8232;
8242 -> 6873;
8242 -> 6867;
8243 -> 6868;
8243 -> 8231;
8243 -> 8242;
8243 -> 6873;
8243 -> 6867;
8244 -> 8228;
8244 -> 6867;
8245 -> 6868;
8245 -> 8243;
8245 -> 8244;
8245 -> 6867;
8246 -> 8231;
8246 -> 6866;
8247 -> 8246;
8247 -> 6866;
8248 -> 6856;
8248 -> 8247;
8248 -> 8245;
8248 -> 6866;
8249 -> 6857;
8250 -> 6858;
8250 -> 8249;
8251 -> 6857;
8252 -> 0;
8252 -> 5516;
8253 -> 5516;
8254 -> 8252;
8254 -> 8253;
8255 -> 5518;
8255 -> 8253;
8256 -> 8254;
8256 -> 8253;
8257 -> 8253;
8258 -> 8256;
8258 -> 8257;
8259 -> 8258;
8259 -> 0;
8259 -> 8257;
8260 -> 8259;
8261 -> 8253;
8262 -> 8255;
8262 -> 8261;
8263 -> 8262;
8263 -> 8248;
8263 -> 8261;
8264 -> 8253;
8265 -> 8263;
8265 -> 8254;
8265 -> 8253;
8266 -> 8265;
8266 -> 8248;
8267 -> 8265;
8268 -> 8265;
8269 -> 5517;
8269 -> 5516;
8270 -> 5553;
8270 -> 5516;
8271 -> 6835;
8271 -> 5516;
8272 -> 6836;
8272 -> 5516;
8273 -> 6837;
8273 -> 5516;
8274 -> 6853;
8274 -> 5516;
8275 -> 6856;
8275 -> 5516;
8276 -> 8265;
8276 -> 5516;
8277 -> 8269;
8277 -> 8270;
8277 -> 8271;
8277 -> 8272;
8277 -> 8273;
8277 -> 8274;
8277 -> 8275;
8277 -> 8276;
8277 -> 5518;
8277 -> 8248;
8277 -> 5449;
8277 -> 8265;
8277 -> 5516;
8278 -> 5516;
8279 -> 8278;
8280 -> 8279;
8280 -> 8278;
8281 -> 8277;
8281 -> 8278;
8282 -> 8277;
8282 -> 8278;
8283 -> 8281;
8283 -> 8277;
8283 -> 8278;
8284 -> 8281;
8284 -> 8277;
8284 -> 8278;
8285 -> 6856;
8285 -> 5516;
8286 -> 5518;
8286 -> 8277;
8286 -> 8285;
8286 -> 5516;
8287 -> 5504;
8287 -> 5514;
8288 -> 5514;
8289 -> 8287;
8289 -> 8288;
8290 -> 5457;
8290 -> 8288;
8291 -> 8289;
8291 -> 5499;
8291 -> 8288;
8292 -> 8288;
8293 -> 8291;
8293 -> 8292;
8294 -> 8290;
8294 -> 8292;
8295 -> 8294;
8295 -> 8286;
8295 -> 8293;
8295 -> 5488;
8295 -> 8292;
8296 -> 8292;
8297 -> 8294;
8297 -> 8286;
8297 -> 8296;
8297 -> 8292;
8298 -> 8297;
8299 -> 8298;
8299 -> 8294;
8299 -> 8297;
8300 -> 8288;
8301 -> 5514;
8302 -> 8299;
8302 -> 890;
8303 -> 894;
8303 -> 890;
8304 -> 8302;
8304 -> 8303;
8305 -> 8303;
8306 -> 8304;
8306 -> 8305;
8307 -> 5411;
8307 -> 8305;
8308 -> 8305;
8309 -> 8307;
8309 -> 8308;
8310 -> 8308;
8311 -> 8309;
8311 -> 8310;
8312 -> 8311;
8312 -> 8299;
8312 -> 8310;
8313 -> 8310;
8314 -> 8311;
8314 -> 8299;
8314 -> 8313;
8314 -> 8310;
8315 -> 8314;
8315 -> 8305;
8316 -> 8305;
8317 -> 8315;
8317 -> 8316;
8318 -> 8306;
8318 -> 8317;
8319 -> 8318;
8319 -> 890;
8320 -> 8318;
8320 -> 8299;
8320 -> 8314;
8320 -> 890;
8321 -> 890;
8322 -> 8320;
8322 -> 8321;
8323 -> 8320;
8323 -> 8321;
8324 -> 8320;
8324 -> 8321;
8325 -> 8319;
8325 -> 8321;
8326 -> 8322;
8326 -> 8321;
8327 -> 8323;
8327 -> 8321;
8328 -> 8324;
8328 -> 8321;
8329 -> 8321;
8330 -> 8329;
8330 -> 8326;
8330 -> 8327;
8330 -> 8328;
8330 -> 8320;
8330 -> 8321;
8331 -> 8330;
8331 -> 1;
8332 -> 0;
8332 -> 1;
8333 -> 1;
8334 -> 8330;
8334 -> 8333;
8335 -> 8334;
8335 -> 8330;
8335 -> 8333;
8336 -> 8335;
8336 -> 1;
8337 -> 206;
8337 -> 1;
8338 -> 8330;
8338 -> 1;
8339 -> 1;
8340 -> 8338;
8340 -> 8339;
8341 -> 8339;
8342 -> 8338;
8342 -> 8341;
8342 -> 1;
8343 -> 8338;
8343 -> 8339;
8344 -> 8338;
8344 -> 8339;
8345 -> 8338;
8345 -> 8339;
8346 -> 8338;
8346 -> 8339;
8347 -> 8344;
8347 -> 8339;
8348 -> 8339;
8349 -> 8346;
8349 -> 8348;
8350 -> 8348;
8351 -> 8349;
8351 -> 8350;
8352 -> 8351;
8352 -> 8342;
8352 -> 8350;
8353 -> 8352;
8353 -> 8348;
8354 -> 8348;
8355 -> 8353;
8355 -> 8354;
8356 -> 8355;
8356 -> 8354;
8357 -> 8356;
8358 -> 8357;
8358 -> 8339;
8359 -> 8343;
8359 -> 8358;
8359 -> 8342;
8359 -> 8339;
8360 -> 8345;
8360 -> 8339;
8361 -> 8360;
8362 -> 8346;
8362 -> 8361;
8363 -> 8362;
8363 -> 8359;
8363 -> 8361;
8364 -> 8363;
8364 -> 8360;
8365 -> 8360;
8366 -> 8364;
8366 -> 8365;
8366 -> 8360;
8367 -> 8343;
8367 -> 8366;
8368 -> 8366;
8369 -> 8367;
8369 -> 8368;
8370 -> 8368;
8371 -> 8367;
8371 -> 8368;
8372 -> 8367;
8372 -> 8368;
8373 -> 8372;
8373 -> 8370;
8373 -> 8368;
8374 -> 8371;
8374 -> 8373;
8374 -> 8370;
8374 -> 8368;
8375 -> 8347;
8376 -> 8346;
8376 -> 8375;
8377 -> 8375;
8378 -> 8377;
8378 -> 8347;
8379 -> 8347;
8380 -> 8378;
8380 -> 8379;
8380 -> 8347;
8381 -> 8374;
8382 -> 8346;
8382 -> 8361;
8383 -> 8361;
8383 -> 8360;
8384 -> 8383;
8384 -> 8365;
8384 -> 8360;
8385 -> 8346;
8385 -> 8348;
8386 -> 8385;
8386 -> 8381;
8386 -> 8348;
8387 -> 8346;
8387 -> 8375;
8388 -> 8387;
8388 -> 8386;
8388 -> 8375;
8389 -> 8388;
8389 -> 8347;
8390 -> 8389;
8390 -> 8379;
8390 -> 8347;
8391 -> 8386;
8392 -> 8391;
8393 -> 8387;
8393 -> 8391;
8393 -> 8375;
8394 -> 8393;
8394 -> 8347;
8395 -> 8394;
8395 -> 8379;
8395 -> 8347;
8396 -> 8391;
8397 -> 8396;
8398 -> 8387;
8398 -> 8396;
8398 -> 8375;
8399 -> 8398;
8399 -> 8347;
8400 -> 8399;
8400 -> 8379;
8400 -> 8347;
8401 -> 8396;
8402 -> 8401;
8403 -> 8387;
8403 -> 8401;
8403 -> 8375;
8404 -> 8403;
8404 -> 8347;
8405 -> 8404;
8405 -> 8379;
8405 -> 8347;
8406 -> 8401;
8407 -> 8406;
8408 -> 8387;
8408 -> 8406;
8408 -> 8375;
8409 -> 8408;
8409 -> 8347;
8410 -> 8409;
8410 -> 8379;
8410 -> 8347;
8411 -> 8406;
8412 -> 8411;
8413 -> 8387;
8413 -> 8411;
8413 -> 8375;
8414 -> 8413;
8414 -> 8347;
8415 -> 8414;
8415 -> 8379;
8415 -> 8347;
8416 -> 8411;
8417 -> 1;
8418 -> 8330;
8418 -> 1;
8419 -> 1;
8420 -> 8418;
8420 -> 8419;
8421 -> 8420;
8421 -> 8416;
8421 -> 8419;
8422 -> 8419;
8423 -> 8419;
8424 -> 8421;
8424 -> 8423;
8425 -> 8422;
8425 -> 8423;
8426 -> 8423;
8427 -> 8424;
8427 -> 8423;
8428 -> 8427;
8428 -> 8423;
8429 -> 8426;
8429 -> 8423;
8430 -> 8429;
8430 -> 8419;
8431 -> 8430;
8431 -> 1;
8432 -> 8330;
8432 -> 1;
8433 -> 1;
8434 -> 8432;
8434 -> 8427;
8434 -> 1;
8435 -> 1;
8436 -> 8434;
8436 -> 8435;
8437 -> 8435;
8438 -> 8437;
8438 -> 1;
8439 -> 8434;
8439 -> 8438;
8439 -> 1;
8440 -> 0;
8440 -> 1;
8441 -> 8432;
8441 -> 8439;
8441 -> 1;
8442 -> 1;
8443 -> 8441;
8443 -> 8442;
8444 -> 8442;
8445 -> 8444;
8445 -> 1;
8446 -> 8441;
8446 -> 8445;
8446 -> 1;
8447 -> 8441;
8447 -> 8442;
8448 -> 8447;
8448 -> 8446;
8448 -> 8442;
8449 -> 8448;
8449 -> 8442;
8450 -> 8442;
8451 -> 8449;
8451 -> 8450;
8452 -> 8450;
8453 -> 0;
8453 -> 8450;
8454 -> 8451;
8454 -> 8452;
8454 -> 8450;
8455 -> 8450;
8456 -> 8453;
8456 -> 8455;
8456 -> 8450;
8457 -> 8456;
8457 -> 8452;
8457 -> 8450;
8458 -> 8454;
8458 -> 8457;
8458 -> 8450;
8459 -> 1;
8460 -> 8432;
8460 -> 8458;
8460 -> 1;
8461 -> 1;
8462 -> 8460;
8462 -> 8461;
8463 -> 8461;
8464 -> 8463;
8464 -> 1;
8465 -> 8460;
8465 -> 8464;
8465 -> 1;
8466 -> 8432;
8466 -> 8465;
8466 -> 1;
8467 -> 1;
8468 -> 8466;
8468 -> 8467;
8469 -> 8466;
8469 -> 8467;
8470 -> 8466;
8470 -> 8467;
8471 -> 8466;
8471 -> 8467;
8472 -> 8467;
8473 -> 1;
8474 -> 1;
8475 -> 8432;
8475 -> 8468;
8475 -> 8474;
8476 -> 8474;
8477 -> 8475;
8477 -> 8468;
8477 -> 8476;
8478 -> 8477;
8478 -> 8474;
8479 -> 8478;
8479 -> 1;
8480 -> 1;
8481 -> 8432;
8481 -> 8468;
8481 -> 1;
8482 -> 1;
8483 -> 8481;
8483 -> 8482;
8484 -> 8482;
8485 -> 8484;
8485 -> 1;
8486 -> 8481;
8486 -> 8485;
8486 -> 1;
8487 -> 1;
8488 -> 8432;
8488 -> 8486;
8488 -> 1;
8489 -> 1;
8490 -> 8488;
8490 -> 8489;
8491 -> 8489;
8492 -> 8491;
8492 -> 1;
8493 -> 8488;
8493 -> 8492;
8493 -> 1;
8494 -> 1;
8495 -> 8432;
8495 -> 8493;
8495 -> 1;
8496 -> 1;
8497 -> 8495;
8497 -> 8496;
8498 -> 8495;
8498 -> 8496;
8499 -> 8495;
8499 -> 8496;
8500 -> 8495;
8500 -> 8496;
8501 -> 8496;
8502 -> 1;
8503 -> 8432;
8503 -> 8497;
8503 -> 8502;
8503 -> 1;
8504 -> 1;
8505 -> 8503;
8505 -> 8504;
8506 -> 8503;
8506 -> 8504;
8507 -> 8503;
8507 -> 8504;
8508 -> 8503;
8508 -> 8504;
8509 -> 8504;
8510 -> 1;
8511 -> 8432;
8511 -> 8505;
8511 -> 8510;
8511 -> 1;
8512 -> 1;
8513 -> 8511;
8513 -> 8512;
8514 -> 8512;
8515 -> 8514;
8515 -> 1;
8516 -> 8511;
8516 -> 8515;
8516 -> 1;
8517 -> 0;
8517 -> 1;
8518 -> 1;
8519 -> 8432;
8519 -> 8516;
8519 -> 8518;
8519 -> 1;
8520 -> 1;
8521 -> 8519;
8521 -> 8520;
8522 -> 8520;
8523 -> 8522;
8523 -> 1;
8524 -> 8519;
8524 -> 8523;
8524 -> 1;
8525 -> 8519;
8525 -> 8520;
8526 -> 8520;
8527 -> 8526;
8528 -> 0;
8528 -> 8526;
8529 -> 8526;
8530 -> 8528;
8530 -> 8529;
8530 -> 8526;
8531 -> 8530;
8531 -> 8527;
8531 -> 8526;
8532 -> 1;
8533 -> 8432;
8533 -> 8525;
8533 -> 8532;
8533 -> 1;
8534 -> 8533;
8534 -> 1;
8535 -> 8533;
8535 -> 1;
8536 -> 1;
8537 -> 8535;
8537 -> 8536;
8538 -> 8535;
8538 -> 8536;
8539 -> 8535;
8539 -> 8536;
8540 -> 8535;
8540 -> 8536;
8541 -> 8536;
8542 -> 1;
8543 -> 1;
8544 -> 8533;
8544 -> 8537;
8544 -> 8543;
8545 -> 8543;
8546 -> 8544;
8546 -> 8537;
8546 -> 8545;
8547 -> 8546;
8547 -> 8543;
8548 -> 8547;
8548 -> 1;
8549 -> 1;
8550 -> 8432;
8550 -> 8537;
8550 -> 8549;
8550 -> 1;
8551 -> 1;
8552 -> 8432;
8552 -> 8550;
8552 -> 8551;
8552 -> 1;
8553 -> 8551;
8554 -> 8552;
8554 -> 8551;
8555 -> 8551;
8556 -> 8552;
8556 -> 8551;
8557 -> 8556;
8557 -> 8551;
8558 -> 8551;
8559 -> 8552;
8560 -> 8557;
8561 -> 8552;
8561 -> 8560;
8562 -> 8560;
8563 -> 8562;
8563 -> 8557;
8564 -> 8557;
8565 -> 8563;
8565 -> 8564;
8565 -> 8557;
8566 -> 8558;
8567 -> 8558;
8568 -> 8552;
8568 -> 8560;
8569 -> 8568;
8569 -> 8552;
8569 -> 8560;
8570 -> 8569;
8570 -> 8557;
8571 -> 8570;
8571 -> 8564;
8571 -> 8557;
8572 -> 1;
8573 -> 8432;
8573 -> 8552;
8573 -> 8572;
8573 -> 1;
8574 -> 8572;
8575 -> 8573;
8575 -> 8572;
8576 -> 8572;
8577 -> 8573;
8577 -> 8572;
8578 -> 8577;
8578 -> 8572;
8579 -> 8572;
8580 -> 8573;
8581 -> 8578;
8582 -> 8573;
8582 -> 8581;
8583 -> 8581;
8584 -> 8583;
8584 -> 8578;
8585 -> 8578;
8586 -> 8584;
8586 -> 8585;
8586 -> 8578;
8587 -> 8579;
8588 -> 8579;
8589 -> 8573;
8589 -> 8581;
8590 -> 8589;
8590 -> 8573;
8590 -> 8581;
8591 -> 8590;
8591 -> 8578;
8592 -> 8591;
8592 -> 8585;
8592 -> 8578;
8593 -> 1;
8594 -> 8432;
8594 -> 8573;
8594 -> 1;
8595 -> 1;
8596 -> 8594;
8596 -> 8595;
8597 -> 8595;
8598 -> 8597;
8598 -> 1;
8599 -> 8594;
8599 -> 8598;
8599 -> 1;
}