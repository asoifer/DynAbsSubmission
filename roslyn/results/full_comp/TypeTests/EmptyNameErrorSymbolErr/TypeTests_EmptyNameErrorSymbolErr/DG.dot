digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 250604"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 250605"];
3 [label="param TypeTests(this) 250606"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 250607"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 250608"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 250609"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 250610"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 250611"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 250612"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 250613"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 250614"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 250615"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 250616"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 250617"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 250618"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 250619"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 250620"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 250621"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 250622"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 250623"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 250624"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 250625"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 250626"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 250627"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 250628"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 250629"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 250630"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 250631"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 250632"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 250633"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 250634"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 250635"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 250636"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 250637"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 250638"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 250639"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 250640"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 250641"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 250642"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 250643"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 250644"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 250645"];
43 [label="LazyThreadSafetyMode.PublicationOnly 250646"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 250647"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 250648"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 250649"];
47 [label="LazyThreadSafetyMode.PublicationOnly 250650"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 250651"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 250652"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 250653"];
51 [label="'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 250654"];
52 [label="new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 250655"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 250656"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 250657"];
55 [label="LazyThreadSafetyMode.PublicationOnly 250658"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 250659"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 250660"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 250661"];
59 [label="LazyThreadSafetyMode.PublicationOnly 250662"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 250663"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 250664"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 250665"];
63 [label="LazyThreadSafetyMode.PublicationOnly 250666"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 250667"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 250668"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 250669"];
67 [label="LazyThreadSafetyMode.PublicationOnly 250670"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250671"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250672"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 250673"];
71 [label="LazyThreadSafetyMode.PublicationOnly 250674"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250675"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250676"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 250677"];
75 [label="LazyThreadSafetyMode.PublicationOnly 250678"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250679"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250680"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 250681"];
79 [label="LazyThreadSafetyMode.PublicationOnly 250682"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250683"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250684"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 250685"];
83 [label="LazyThreadSafetyMode.PublicationOnly 250686"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250687"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250688"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 250689"];
87 [label="LazyThreadSafetyMode.PublicationOnly 250690"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250691"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250692"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 250693"];
91 [label="LazyThreadSafetyMode.PublicationOnly 250694"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250695"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250696"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 250697"];
95 [label="LazyThreadSafetyMode.PublicationOnly 250698"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 250699"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 250700"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 250701"];
99 [label="LazyThreadSafetyMode.PublicationOnly 250702"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 250703"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 250704"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 250705"];
103 [label="LazyThreadSafetyMode.PublicationOnly 250706"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250707"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250708"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 250709"];
107 [label="LazyThreadSafetyMode.PublicationOnly 250710"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250711"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250712"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 250713"];
111 [label="LazyThreadSafetyMode.PublicationOnly 250714"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250715"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250716"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 250717"];
115 [label="LazyThreadSafetyMode.PublicationOnly 250718"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250719"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250720"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 250721"];
119 [label="LazyThreadSafetyMode.PublicationOnly 250722"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 250723"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 250724"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 250725"];
123 [label="LazyThreadSafetyMode.PublicationOnly 250726"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250727"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250728"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 250729"];
127 [label="LazyThreadSafetyMode.PublicationOnly 250730"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250731"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250732"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 250733"];
131 [label="LazyThreadSafetyMode.PublicationOnly 250734"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250735"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250736"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 250737"];
135 [label="LazyThreadSafetyMode.PublicationOnly 250738"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250739"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250740"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 250741"];
139 [label="LazyThreadSafetyMode.PublicationOnly 250742"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250743"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250744"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 250745"];
143 [label="LazyThreadSafetyMode.PublicationOnly 250746"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250747"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250748"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 250749"];
147 [label="LazyThreadSafetyMode.PublicationOnly 250750"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250751"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250752"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 250753"];
151 [label="LazyThreadSafetyMode.PublicationOnly 250754"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250755"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250756"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 250757"];
155 [label="LazyThreadSafetyMode.PublicationOnly 250758"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250759"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250760"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 250761"];
159 [label="LazyThreadSafetyMode.PublicationOnly 250762"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250763"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250764"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 250765"];
163 [label="LazyThreadSafetyMode.PublicationOnly 250766"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250767"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250768"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 250769"];
167 [label="LazyThreadSafetyMode.PublicationOnly 250770"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250771"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250772"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 250773"];
171 [label="LazyThreadSafetyMode.PublicationOnly 250774"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250775"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 250776"];
174 [label="@'R:\\Invalid.dll' 250777"];
175 [label="fullPath: @'R:\\Invalid.dll' 250778"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 250779"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 250780"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 250781"];
179 [label="MscorlibRef_v4_0_30316_17626 250782"];
180 [label="Net451.mscorlib 250783"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 250784"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 250785"];
183 [label="'/*<bind>*/' 250786"];
184 [label="StartString = '/*<bind>*/' 250787"];
185 [label="'/*</bind>*/' 250788"];
186 [label="EndString = '/*</bind>*/' 250789"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 250790"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 250791"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 250792"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 250793"];
191 [label="param CSharpTestBase(this) 250794"];
192 [label="param CommonTestBase(this) 250795"];
193 [label="param TestBase(this) 250796"];
194 [label="_temp 250797"];
195 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 250798"];
196 [label="param EmptyNameErrorSymbolErr(this) 250799"];
197 [label="var text = @'\nnamespace NS\n{\n  class A { }\n  class B : A[] {}\n}\n'; 250800"];
198 [label="var comp = CreateCompilation(text); 250801"];
199 [label="text 250802"];
200 [label="param operator(string source) 250803"];
201 [label="source 250804"];
202 [label="new CSharpTestSource(source) 250805"];
203 [label="param CSharpTestSource(object value) 250806"];
204 [label="param CSharpTestSource(this) 250807"];
205 [label="Value 250808"];
206 [label="var comp = CreateCompilation(text); 250809"];
207 [label="var comp = CreateCompilation(text); 250810"];
208 [label="CreateCompilation(text) 250811"];
209 [label="param CreateCompilation(CSharpTestSource source) 250812"];
210 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 250813"];
211 [label="param CreateCompilation(CSharpCompilationOptions options = null) 250814"];
212 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 250815"];
213 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 250816"];
214 [label="param CreateCompilation(string assemblyName = '') 250817"];
215 [label="param CreateCompilation(string sourceFileName = '') 250818"];
216 [label="param CreateCompilation(bool skipUsesIsNullable = false) 250819"];
217 [label="source 250820"];
218 [label="targetFramework 250821"];
219 [label="references 250822"];
220 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 250823"];
221 [label="param GetReferences(TargetFramework tf) 250824"];
222 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 250825"];
223 [label="var references = GetReferences(tf); 250826"];
224 [label="GetReferences(tf) 250827"];
225 [label="param GetReferences(TargetFramework targetFramework) 250828"];
226 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 250829"];
227 [label="StandardReferences 250830"];
228 [label="RuntimeUtilities.IsCoreClrRuntime 250831"];
229 [label="Mscorlib46ExtendedReferences 250832"];
230 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 250833"];
231 [label="TestBase.ValueTupleRef 250834"];
232 [label="TestReferences.NetFx.ValueTuple.tuplelib 250835"];
233 [label="ImmutableArray.Create<MetadataReference>(Net461.mscorlib, Net461.System, TestMetadata.Net461.SystemCore, TestBase.ValueTupleRef, Net461.SystemRuntime) 250836"];
234 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 250837"];
235 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 250838"];
236 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 250839"];
237 [label="return references; 250840"];
238 [label="options 250841"];
239 [label="parseOptions 250842"];
240 [label="assemblyName 250843"];
241 [label="sourceFileName 250844"];
242 [label="skipUsesIsNullable 250845"];
243 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 250846"];
244 [label="param CreateEmptyCompilation(CSharpTestSource source) 250847"];
245 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 250848"];
246 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 250849"];
247 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 250850"];
248 [label="param CreateEmptyCompilation(string assemblyName = '') 250851"];
249 [label="param CreateEmptyCompilation(string sourceFileName = '') 250852"];
250 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 250853"];
251 [label="source 250854"];
252 [label="references 250855"];
253 [label="options 250856"];
254 [label="parseOptions 250857"];
255 [label="assemblyName 250858"];
256 [label="sourceFileName 250859"];
257 [label="skipUsesIsNullable 250860"];
258 [label="null 250861"];
259 [label="experimentalFeature: null 250862"];
260 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 250863"];
261 [label="param CreateCompilationCore(CSharpTestSource source) 250864"];
262 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 250865"];
263 [label="param CreateCompilationCore(CSharpCompilationOptions options) 250866"];
264 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 250867"];
265 [label="param CreateCompilationCore(string assemblyName) 250868"];
266 [label="param CreateCompilationCore(string sourceFileName) 250869"];
267 [label="param CreateCompilationCore(bool skipUsesIsNullable) 250870"];
268 [label="param CreateCompilationCore(MessageID? experimentalFeature) 250871"];
269 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 250872"];
270 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 250873"];
271 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 250874"];
272 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 250875"];
273 [label="param GetSyntaxTrees(string sourceFileName = '') 250876"];
274 [label="param GetSyntaxTrees(this) 250877"];
275 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 250878"];
276 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 250879"];
277 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 250880"];
278 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 250881"];
279 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 250882"];
280 [label="param Parse(string text) 250883"];
281 [label="param Parse(string filename = '') 250884"];
282 [label="param Parse(CSharpParseOptions options = null) 250885"];
283 [label="param Parse(Encoding encoding = null) 250886"];
284 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 250887"];
285 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 250888"];
286 [label="new CSharpParseOptions() 250889"];
287 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 250890"];
288 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 250891"];
289 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 250892"];
290 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 250893"];
291 [label="param CSharpParseOptions(this) 250894"];
292 [label="languageVersion 250895"];
293 [label="documentationMode 250896"];
294 [label="kind 250897"];
295 [label="preprocessorSymbols 250898"];
296 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 250899"];
297 [label="ImmutableDictionary<string, string>.Empty 250900"];
298 [label="param CSharpParseOptions(LanguageVersion languageVersion) 250901"];
299 [label="param CSharpParseOptions(DocumentationMode documentationMode) 250902"];
300 [label="param CSharpParseOptions(SourceCodeKind kind) 250903"];
301 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 250904"];
302 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 250905"];
303 [label="param CSharpParseOptions(this) 250906"];
304 [label="kind 250907"];
305 [label="documentationMode 250908"];
306 [label="param CSharpParseOptions(this) 250909"];
307 [label="_features 250910"];
308 [label="public LanguageVersion LanguageVersion { get; private set; } 250911"];
309 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 250912"];
310 [label="this.SpecifiedLanguageVersion 250913"];
311 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 250914"];
312 [label="languageVersion.MapSpecifiedToEffectiveVersion() 250915"];
313 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 250916"];
314 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 250917"];
315 [label="return LanguageVersion.CSharp9; 250918"];
316 [label="this.LanguageVersion 250919"];
317 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 250920"];
318 [label="this.PreprocessorSymbols 250921"];
319 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 250922"];
320 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 250923"];
321 [label="_features 250924"];
322 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 250925"];
323 [label="kind: SourceCodeKind.Regular 250926"];
324 [label="documentationMode: DocumentationMode.Parse 250927"];
325 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 250928"];
326 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 250929"];
327 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 250930"];
328 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 250931"];
329 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 250932"];
330 [label="param CSharpParseOptions(this) 250933"];
331 [label="languageVersion 250934"];
332 [label="documentationMode 250935"];
333 [label="kind 250936"];
334 [label="preprocessorSymbols 250937"];
335 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 250938"];
336 [label="ImmutableDictionary<string, string>.Empty 250939"];
337 [label="param CSharpParseOptions(LanguageVersion languageVersion) 250940"];
338 [label="param CSharpParseOptions(DocumentationMode documentationMode) 250941"];
339 [label="param CSharpParseOptions(SourceCodeKind kind) 250942"];
340 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 250943"];
341 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 250944"];
342 [label="param CSharpParseOptions(this) 250945"];
343 [label="kind 250946"];
344 [label="documentationMode 250947"];
345 [label="param CSharpParseOptions(this) 250948"];
346 [label="_features 250949"];
347 [label="public LanguageVersion LanguageVersion { get; private set; } 250950"];
348 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 250951"];
349 [label="this.SpecifiedLanguageVersion 250952"];
350 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 250953"];
351 [label="languageVersion.MapSpecifiedToEffectiveVersion() 250954"];
352 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 250955"];
353 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 250956"];
354 [label="return LanguageVersion.CSharp9; 250957"];
355 [label="this.LanguageVersion 250958"];
356 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 250959"];
357 [label="this.PreprocessorSymbols 250960"];
358 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 250961"];
359 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 250962"];
360 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 250963"];
361 [label="_features 250964"];
362 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 250965"];
363 [label="SourceCodeKind.Script 250966"];
364 [label="Regular.WithKind(SourceCodeKind.Script) 250967"];
365 [label="param WithKind(SourceCodeKind kind) 250968"];
366 [label="param WithKind(this) 250969"];
367 [label="if (kind == this.SpecifiedKind)\n            {\n                return this;\n            } 250970"];
368 [label="var effectiveKind = kind.MapSpecifiedToEffectiveKind(); 250971"];
369 [label="return new CSharpParseOptions(this) { SpecifiedKind = kind, Kind = effectiveKind }; 250972"];
370 [label="return new CSharpParseOptions(this) { SpecifiedKind = kind, Kind = effectiveKind }; 250973"];
371 [label="new CSharpParseOptions(this) { SpecifiedKind = kind, Kind = effectiveKind } 250974"];
372 [label="param CSharpParseOptions(CSharpParseOptions other) 250975"];
373 [label="param CSharpParseOptions(this) 250976"];
374 [label="other.SpecifiedLanguageVersion 250977"];
375 [label="other.DocumentationMode 250978"];
376 [label="other.Kind 250979"];
377 [label="other.PreprocessorSymbols 250980"];
378 [label="other.Features 250981"];
379 [label="get\n            {\n                return _features;\n            } 250982"];
380 [label="return _features; 250983"];
381 [label="param CSharpParseOptions(this) 250984"];
382 [label="param CSharpParseOptions(LanguageVersion languageVersion) 250985"];
383 [label="param CSharpParseOptions(DocumentationMode documentationMode) 250986"];
384 [label="param CSharpParseOptions(SourceCodeKind kind) 250987"];
385 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 250988"];
386 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 250989"];
387 [label="param CSharpParseOptions(this) 250990"];
388 [label="param CSharpParseOptions(this) 250991"];
389 [label="param CSharpParseOptions(this) 250992"];
390 [label="_features 250993"];
391 [label="public LanguageVersion LanguageVersion { get; private set; } 250994"];
392 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 250995"];
393 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 250996"];
394 [label="languageVersion.MapSpecifiedToEffectiveVersion() 250997"];
395 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 250998"];
396 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 250999"];
397 [label="return LanguageVersion.CSharp9; 251000"];
398 [label="this.LanguageVersion 251001"];
399 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 251002"];
400 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251003"];
401 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251004"];
402 [label="SpecifiedKind 251005"];
403 [label="Kind 251006"];
404 [label="Script = Regular.WithKind(SourceCodeKind.Script) 251007"];
405 [label="LanguageVersion.CSharp6 251008"];
406 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 251009"];
407 [label="param WithLanguageVersion(LanguageVersion version) 251010"];
408 [label="param WithLanguageVersion(this) 251011"];
409 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251012"];
410 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251013"];
411 [label="version.MapSpecifiedToEffectiveVersion() 251014"];
412 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251015"];
413 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251016"];
414 [label="return version; 251017"];
415 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251018"];
416 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251019"];
417 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251020"];
418 [label="param CSharpParseOptions(CSharpParseOptions other) 251021"];
419 [label="param CSharpParseOptions(this) 251022"];
420 [label="other.SpecifiedLanguageVersion 251023"];
421 [label="other.DocumentationMode 251024"];
422 [label="other.Kind 251025"];
423 [label="other.PreprocessorSymbols 251026"];
424 [label="other.Features 251027"];
425 [label="get\n            {\n                return _features;\n            } 251028"];
426 [label="return _features; 251029"];
427 [label="param CSharpParseOptions(this) 251030"];
428 [label="param CSharpParseOptions(this) 251031"];
429 [label="param CSharpParseOptions(this) 251032"];
430 [label="param CSharpParseOptions(this) 251033"];
431 [label="_features 251034"];
432 [label="public LanguageVersion LanguageVersion { get; private set; } 251035"];
433 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251036"];
434 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251037"];
435 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251038"];
436 [label="SpecifiedLanguageVersion 251039"];
437 [label="LanguageVersion 251040"];
438 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 251041"];
439 [label="LanguageVersion.CSharp7 251042"];
440 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 251043"];
441 [label="param WithLanguageVersion(LanguageVersion version) 251044"];
442 [label="param WithLanguageVersion(this) 251045"];
443 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251046"];
444 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251047"];
445 [label="version.MapSpecifiedToEffectiveVersion() 251048"];
446 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251049"];
447 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251050"];
448 [label="return version; 251051"];
449 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251052"];
450 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251053"];
451 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251054"];
452 [label="param CSharpParseOptions(CSharpParseOptions other) 251055"];
453 [label="param CSharpParseOptions(this) 251056"];
454 [label="other.SpecifiedLanguageVersion 251057"];
455 [label="other.DocumentationMode 251058"];
456 [label="other.Kind 251059"];
457 [label="other.PreprocessorSymbols 251060"];
458 [label="other.Features 251061"];
459 [label="get\n            {\n                return _features;\n            } 251062"];
460 [label="return _features; 251063"];
461 [label="param CSharpParseOptions(this) 251064"];
462 [label="param CSharpParseOptions(this) 251065"];
463 [label="param CSharpParseOptions(this) 251066"];
464 [label="param CSharpParseOptions(this) 251067"];
465 [label="_features 251068"];
466 [label="public LanguageVersion LanguageVersion { get; private set; } 251069"];
467 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251070"];
468 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251071"];
469 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251072"];
470 [label="SpecifiedLanguageVersion 251073"];
471 [label="LanguageVersion 251074"];
472 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 251075"];
473 [label="LanguageVersion.CSharp7_1 251076"];
474 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 251077"];
475 [label="param WithLanguageVersion(LanguageVersion version) 251078"];
476 [label="param WithLanguageVersion(this) 251079"];
477 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251080"];
478 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251081"];
479 [label="version.MapSpecifiedToEffectiveVersion() 251082"];
480 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251083"];
481 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251084"];
482 [label="return version; 251085"];
483 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251086"];
484 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251087"];
485 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251088"];
486 [label="param CSharpParseOptions(CSharpParseOptions other) 251089"];
487 [label="param CSharpParseOptions(this) 251090"];
488 [label="other.SpecifiedLanguageVersion 251091"];
489 [label="other.DocumentationMode 251092"];
490 [label="other.Kind 251093"];
491 [label="other.PreprocessorSymbols 251094"];
492 [label="other.Features 251095"];
493 [label="get\n            {\n                return _features;\n            } 251096"];
494 [label="return _features; 251097"];
495 [label="param CSharpParseOptions(this) 251098"];
496 [label="param CSharpParseOptions(this) 251099"];
497 [label="param CSharpParseOptions(this) 251100"];
498 [label="param CSharpParseOptions(this) 251101"];
499 [label="_features 251102"];
500 [label="public LanguageVersion LanguageVersion { get; private set; } 251103"];
501 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251104"];
502 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251105"];
503 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251106"];
504 [label="SpecifiedLanguageVersion 251107"];
505 [label="LanguageVersion 251108"];
506 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 251109"];
507 [label="LanguageVersion.CSharp7_2 251110"];
508 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 251111"];
509 [label="param WithLanguageVersion(LanguageVersion version) 251112"];
510 [label="param WithLanguageVersion(this) 251113"];
511 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251114"];
512 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251115"];
513 [label="version.MapSpecifiedToEffectiveVersion() 251116"];
514 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251117"];
515 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251118"];
516 [label="return version; 251119"];
517 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251120"];
518 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251121"];
519 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251122"];
520 [label="param CSharpParseOptions(CSharpParseOptions other) 251123"];
521 [label="param CSharpParseOptions(this) 251124"];
522 [label="other.SpecifiedLanguageVersion 251125"];
523 [label="other.DocumentationMode 251126"];
524 [label="other.Kind 251127"];
525 [label="other.PreprocessorSymbols 251128"];
526 [label="other.Features 251129"];
527 [label="get\n            {\n                return _features;\n            } 251130"];
528 [label="return _features; 251131"];
529 [label="param CSharpParseOptions(this) 251132"];
530 [label="param CSharpParseOptions(this) 251133"];
531 [label="param CSharpParseOptions(this) 251134"];
532 [label="param CSharpParseOptions(this) 251135"];
533 [label="_features 251136"];
534 [label="public LanguageVersion LanguageVersion { get; private set; } 251137"];
535 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251138"];
536 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251139"];
537 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251140"];
538 [label="SpecifiedLanguageVersion 251141"];
539 [label="LanguageVersion 251142"];
540 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 251143"];
541 [label="LanguageVersion.CSharp7_3 251144"];
542 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 251145"];
543 [label="param WithLanguageVersion(LanguageVersion version) 251146"];
544 [label="param WithLanguageVersion(this) 251147"];
545 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251148"];
546 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251149"];
547 [label="version.MapSpecifiedToEffectiveVersion() 251150"];
548 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251151"];
549 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251152"];
550 [label="return version; 251153"];
551 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251154"];
552 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251155"];
553 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251156"];
554 [label="param CSharpParseOptions(CSharpParseOptions other) 251157"];
555 [label="param CSharpParseOptions(this) 251158"];
556 [label="other.SpecifiedLanguageVersion 251159"];
557 [label="other.DocumentationMode 251160"];
558 [label="other.Kind 251161"];
559 [label="other.PreprocessorSymbols 251162"];
560 [label="other.Features 251163"];
561 [label="get\n            {\n                return _features;\n            } 251164"];
562 [label="return _features; 251165"];
563 [label="param CSharpParseOptions(this) 251166"];
564 [label="param CSharpParseOptions(this) 251167"];
565 [label="param CSharpParseOptions(this) 251168"];
566 [label="param CSharpParseOptions(this) 251169"];
567 [label="_features 251170"];
568 [label="public LanguageVersion LanguageVersion { get; private set; } 251171"];
569 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251172"];
570 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251173"];
571 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251174"];
572 [label="SpecifiedLanguageVersion 251175"];
573 [label="LanguageVersion 251176"];
574 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 251177"];
575 [label="LanguageVersion.Default 251178"];
576 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 251179"];
577 [label="param WithLanguageVersion(LanguageVersion version) 251180"];
578 [label="param WithLanguageVersion(this) 251181"];
579 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251182"];
580 [label="return this; 251183"];
581 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 251184"];
582 [label="LanguageVersion.Preview 251185"];
583 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 251186"];
584 [label="param WithLanguageVersion(LanguageVersion version) 251187"];
585 [label="param WithLanguageVersion(this) 251188"];
586 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251189"];
587 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251190"];
588 [label="version.MapSpecifiedToEffectiveVersion() 251191"];
589 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251192"];
590 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251193"];
591 [label="return version; 251194"];
592 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251195"];
593 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251196"];
594 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251197"];
595 [label="param CSharpParseOptions(CSharpParseOptions other) 251198"];
596 [label="param CSharpParseOptions(this) 251199"];
597 [label="other.SpecifiedLanguageVersion 251200"];
598 [label="other.DocumentationMode 251201"];
599 [label="other.Kind 251202"];
600 [label="other.PreprocessorSymbols 251203"];
601 [label="other.Features 251204"];
602 [label="get\n            {\n                return _features;\n            } 251205"];
603 [label="return _features; 251206"];
604 [label="param CSharpParseOptions(this) 251207"];
605 [label="param CSharpParseOptions(this) 251208"];
606 [label="param CSharpParseOptions(this) 251209"];
607 [label="param CSharpParseOptions(this) 251210"];
608 [label="_features 251211"];
609 [label="public LanguageVersion LanguageVersion { get; private set; } 251212"];
610 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251213"];
611 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251214"];
612 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251215"];
613 [label="SpecifiedLanguageVersion 251216"];
614 [label="LanguageVersion 251217"];
615 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 251218"];
616 [label="LanguageVersion.CSharp8 251219"];
617 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 251220"];
618 [label="param WithLanguageVersion(LanguageVersion version) 251221"];
619 [label="param WithLanguageVersion(this) 251222"];
620 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251223"];
621 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251224"];
622 [label="version.MapSpecifiedToEffectiveVersion() 251225"];
623 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251226"];
624 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251227"];
625 [label="return version; 251228"];
626 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251229"];
627 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251230"];
628 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251231"];
629 [label="param CSharpParseOptions(CSharpParseOptions other) 251232"];
630 [label="param CSharpParseOptions(this) 251233"];
631 [label="other.SpecifiedLanguageVersion 251234"];
632 [label="other.DocumentationMode 251235"];
633 [label="other.Kind 251236"];
634 [label="other.PreprocessorSymbols 251237"];
635 [label="other.Features 251238"];
636 [label="get\n            {\n                return _features;\n            } 251239"];
637 [label="return _features; 251240"];
638 [label="param CSharpParseOptions(this) 251241"];
639 [label="param CSharpParseOptions(this) 251242"];
640 [label="param CSharpParseOptions(this) 251243"];
641 [label="param CSharpParseOptions(this) 251244"];
642 [label="_features 251245"];
643 [label="public LanguageVersion LanguageVersion { get; private set; } 251246"];
644 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251247"];
645 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251248"];
646 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251249"];
647 [label="SpecifiedLanguageVersion 251250"];
648 [label="LanguageVersion 251251"];
649 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 251252"];
650 [label="LanguageVersion.CSharp9 251253"];
651 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 251254"];
652 [label="param WithLanguageVersion(LanguageVersion version) 251255"];
653 [label="param WithLanguageVersion(this) 251256"];
654 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251257"];
655 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251258"];
656 [label="version.MapSpecifiedToEffectiveVersion() 251259"];
657 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251260"];
658 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251261"];
659 [label="return version; 251262"];
660 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251263"];
661 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251264"];
662 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251265"];
663 [label="param CSharpParseOptions(CSharpParseOptions other) 251266"];
664 [label="param CSharpParseOptions(this) 251267"];
665 [label="other.SpecifiedLanguageVersion 251268"];
666 [label="other.DocumentationMode 251269"];
667 [label="other.Kind 251270"];
668 [label="other.PreprocessorSymbols 251271"];
669 [label="other.Features 251272"];
670 [label="get\n            {\n                return _features;\n            } 251273"];
671 [label="return _features; 251274"];
672 [label="param CSharpParseOptions(this) 251275"];
673 [label="param CSharpParseOptions(this) 251276"];
674 [label="param CSharpParseOptions(this) 251277"];
675 [label="param CSharpParseOptions(this) 251278"];
676 [label="_features 251279"];
677 [label="public LanguageVersion LanguageVersion { get; private set; } 251280"];
678 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251281"];
679 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251282"];
680 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251283"];
681 [label="SpecifiedLanguageVersion 251284"];
682 [label="LanguageVersion 251285"];
683 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 251286"];
684 [label="DocumentationMode.Diagnose 251287"];
685 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 251288"];
686 [label="param WithDocumentationMode(DocumentationMode documentationMode) 251289"];
687 [label="param WithDocumentationMode(this) 251290"];
688 [label="if (documentationMode == this.DocumentationMode)\n            {\n                return this;\n            } 251291"];
689 [label="return new CSharpParseOptions(this) { DocumentationMode = documentationMode }; 251292"];
690 [label="return new CSharpParseOptions(this) { DocumentationMode = documentationMode }; 251293"];
691 [label="new CSharpParseOptions(this) { DocumentationMode = documentationMode } 251294"];
692 [label="param CSharpParseOptions(CSharpParseOptions other) 251295"];
693 [label="param CSharpParseOptions(this) 251296"];
694 [label="other.SpecifiedLanguageVersion 251297"];
695 [label="other.DocumentationMode 251298"];
696 [label="other.Kind 251299"];
697 [label="other.PreprocessorSymbols 251300"];
698 [label="other.Features 251301"];
699 [label="get\n            {\n                return _features;\n            } 251302"];
700 [label="return _features; 251303"];
701 [label="param CSharpParseOptions(this) 251304"];
702 [label="param CSharpParseOptions(this) 251305"];
703 [label="param CSharpParseOptions(this) 251306"];
704 [label="param CSharpParseOptions(this) 251307"];
705 [label="_features 251308"];
706 [label="public LanguageVersion LanguageVersion { get; private set; } 251309"];
707 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251310"];
708 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251311"];
709 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251312"];
710 [label="DocumentationMode 251313"];
711 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 251314"];
712 [label="Regular 251315"];
713 [label="'UseLegacyStrongNameProvider' 251316"];
714 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 251317"];
715 [label="param WithFeature(this CSharpParseOptions options) 251318"];
716 [label="param WithFeature(string feature) 251319"];
717 [label="param WithFeature(string value = 'true') 251320"];
718 [label="options.Features 251321"];
719 [label="get\n            {\n                return _features;\n            } 251322"];
720 [label="return _features; 251323"];
721 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251324"];
722 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251325"];
723 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251326"];
724 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251327"];
725 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251328"];
726 [label="new[] { new KeyValuePair<string, string>(feature, value) } 251329"];
727 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251330"];
728 [label="options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })) 251331"];
729 [label="param WithFeatures(IEnumerable<KeyValuePair<string, string>>? features) 251332"];
730 [label="param WithFeatures(this) 251333"];
731 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251334"];
732 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251335"];
733 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251336"];
734 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251337"];
735 [label="new CSharpParseOptions(this) { _features = dictionary } 251338"];
736 [label="param CSharpParseOptions(CSharpParseOptions other) 251339"];
737 [label="param CSharpParseOptions(this) 251340"];
738 [label="other.SpecifiedLanguageVersion 251341"];
739 [label="other.DocumentationMode 251342"];
740 [label="other.Kind 251343"];
741 [label="other.PreprocessorSymbols 251344"];
742 [label="other.Features 251345"];
743 [label="get\n            {\n                return _features;\n            } 251346"];
744 [label="return _features; 251347"];
745 [label="param CSharpParseOptions(this) 251348"];
746 [label="param CSharpParseOptions(this) 251349"];
747 [label="param CSharpParseOptions(this) 251350"];
748 [label="param CSharpParseOptions(this) 251351"];
749 [label="_features 251352"];
750 [label="public LanguageVersion LanguageVersion { get; private set; } 251353"];
751 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251354"];
752 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251355"];
753 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251356"];
754 [label="_features 251357"];
755 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 251358"];
756 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 251359"];
757 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 251360"];
758 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 251361"];
759 [label="param RequiredVersion(this MessageID feature) 251362"];
760 [label="Debug.Assert(RequiredFeature(feature) == null); 251363"];
761 [label="RequiredFeature(feature) 251364"];
762 [label="param RequiredFeature(this MessageID feature) 251365"];
763 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 251366"];
764 [label="return null; 251367"];
765 [label="Debug.Assert(RequiredFeature(feature) == null); 251368"];
766 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 251369"];
767 [label="return LanguageVersion.CSharp7_3; 251370"];
768 [label="1 251371"];
769 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 251372"];
770 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 251373"];
771 [label="param WithLanguageVersion(LanguageVersion version) 251374"];
772 [label="param WithLanguageVersion(this) 251375"];
773 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251376"];
774 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251377"];
775 [label="version.MapSpecifiedToEffectiveVersion() 251378"];
776 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251379"];
777 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251380"];
778 [label="return version; 251381"];
779 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251382"];
780 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251383"];
781 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251384"];
782 [label="param CSharpParseOptions(CSharpParseOptions other) 251385"];
783 [label="param CSharpParseOptions(this) 251386"];
784 [label="other.SpecifiedLanguageVersion 251387"];
785 [label="other.DocumentationMode 251388"];
786 [label="other.Kind 251389"];
787 [label="other.PreprocessorSymbols 251390"];
788 [label="other.Features 251391"];
789 [label="get\n            {\n                return _features;\n            } 251392"];
790 [label="return _features; 251393"];
791 [label="param CSharpParseOptions(this) 251394"];
792 [label="param CSharpParseOptions(this) 251395"];
793 [label="param CSharpParseOptions(this) 251396"];
794 [label="param CSharpParseOptions(this) 251397"];
795 [label="_features 251398"];
796 [label="public LanguageVersion LanguageVersion { get; private set; } 251399"];
797 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251400"];
798 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251401"];
799 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251402"];
800 [label="SpecifiedLanguageVersion 251403"];
801 [label="LanguageVersion 251404"];
802 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 251405"];
803 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 251406"];
804 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 251407"];
805 [label="param RequiredVersion(this MessageID feature) 251408"];
806 [label="Debug.Assert(RequiredFeature(feature) == null); 251409"];
807 [label="RequiredFeature(feature) 251410"];
808 [label="param RequiredFeature(this MessageID feature) 251411"];
809 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 251412"];
810 [label="return null; 251413"];
811 [label="Debug.Assert(RequiredFeature(feature) == null); 251414"];
812 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 251415"];
813 [label="return LanguageVersion.CSharp9; 251416"];
814 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 251417"];
815 [label="param WithLanguageVersion(LanguageVersion version) 251418"];
816 [label="param WithLanguageVersion(this) 251419"];
817 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251420"];
818 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251421"];
819 [label="version.MapSpecifiedToEffectiveVersion() 251422"];
820 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251423"];
821 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251424"];
822 [label="return version; 251425"];
823 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251426"];
824 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251427"];
825 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251428"];
826 [label="param CSharpParseOptions(CSharpParseOptions other) 251429"];
827 [label="param CSharpParseOptions(this) 251430"];
828 [label="other.SpecifiedLanguageVersion 251431"];
829 [label="other.DocumentationMode 251432"];
830 [label="other.Kind 251433"];
831 [label="other.PreprocessorSymbols 251434"];
832 [label="other.Features 251435"];
833 [label="get\n            {\n                return _features;\n            } 251436"];
834 [label="return _features; 251437"];
835 [label="param CSharpParseOptions(this) 251438"];
836 [label="param CSharpParseOptions(this) 251439"];
837 [label="param CSharpParseOptions(this) 251440"];
838 [label="param CSharpParseOptions(this) 251441"];
839 [label="_features 251442"];
840 [label="public LanguageVersion LanguageVersion { get; private set; } 251443"];
841 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251444"];
842 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251445"];
843 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251446"];
844 [label="SpecifiedLanguageVersion 251447"];
845 [label="LanguageVersion 251448"];
846 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 251449"];
847 [label="LanguageVersion.CSharp8 251450"];
848 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 251451"];
849 [label="param WithLanguageVersion(LanguageVersion version) 251452"];
850 [label="param WithLanguageVersion(this) 251453"];
851 [label="if (version == this.SpecifiedLanguageVersion)\n            {\n                return this;\n            } 251454"];
852 [label="var effectiveLanguageVersion = version.MapSpecifiedToEffectiveVersion(); 251455"];
853 [label="version.MapSpecifiedToEffectiveVersion() 251456"];
854 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251457"];
855 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251458"];
856 [label="return version; 251459"];
857 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251460"];
858 [label="return new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion }; 251461"];
859 [label="new CSharpParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion } 251462"];
860 [label="param CSharpParseOptions(CSharpParseOptions other) 251463"];
861 [label="param CSharpParseOptions(this) 251464"];
862 [label="other.SpecifiedLanguageVersion 251465"];
863 [label="other.DocumentationMode 251466"];
864 [label="other.Kind 251467"];
865 [label="other.PreprocessorSymbols 251468"];
866 [label="other.Features 251469"];
867 [label="get\n            {\n                return _features;\n            } 251470"];
868 [label="return _features; 251471"];
869 [label="param CSharpParseOptions(this) 251472"];
870 [label="param CSharpParseOptions(this) 251473"];
871 [label="param CSharpParseOptions(this) 251474"];
872 [label="param CSharpParseOptions(this) 251475"];
873 [label="_features 251476"];
874 [label="public LanguageVersion LanguageVersion { get; private set; } 251477"];
875 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251478"];
876 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251479"];
877 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251480"];
878 [label="SpecifiedLanguageVersion 251481"];
879 [label="LanguageVersion 251482"];
880 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 251483"];
881 [label="RegularWithExtendedPartialMethods = RegularPreview 251484"];
882 [label="new SmallDictionary<string, string> { } 251485"];
883 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 251486"];
884 [label="kind: SourceCodeKind.Regular 251487"];
885 [label="documentationMode: DocumentationMode.None 251488"];
886 [label="languageVersion: LanguageVersion.Preview 251489"];
887 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 251490"];
888 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 251491"];
889 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 251492"];
890 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 251493"];
891 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 251494"];
892 [label="param CSharpParseOptions(this) 251495"];
893 [label="languageVersion 251496"];
894 [label="documentationMode 251497"];
895 [label="kind 251498"];
896 [label="preprocessorSymbols 251499"];
897 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 251500"];
898 [label="ImmutableDictionary<string, string>.Empty 251501"];
899 [label="param CSharpParseOptions(LanguageVersion languageVersion) 251502"];
900 [label="param CSharpParseOptions(DocumentationMode documentationMode) 251503"];
901 [label="param CSharpParseOptions(SourceCodeKind kind) 251504"];
902 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 251505"];
903 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 251506"];
904 [label="param CSharpParseOptions(this) 251507"];
905 [label="kind 251508"];
906 [label="documentationMode 251509"];
907 [label="param CSharpParseOptions(this) 251510"];
908 [label="_features 251511"];
909 [label="public LanguageVersion LanguageVersion { get; private set; } 251512"];
910 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251513"];
911 [label="this.SpecifiedLanguageVersion 251514"];
912 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 251515"];
913 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251516"];
914 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251517"];
915 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251518"];
916 [label="return version; 251519"];
917 [label="this.LanguageVersion 251520"];
918 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 251521"];
919 [label="this.PreprocessorSymbols 251522"];
920 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251523"];
921 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251524"];
922 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251525"];
923 [label="s_experimentalFeatures 251526"];
924 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 251527"];
925 [label="param WithFeatures(IEnumerable<KeyValuePair<string, string>>? features) 251528"];
926 [label="param WithFeatures(this) 251529"];
927 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251530"];
928 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251531"];
929 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251532"];
930 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251533"];
931 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251534"];
932 [label="new CSharpParseOptions(this) { _features = dictionary } 251535"];
933 [label="param CSharpParseOptions(CSharpParseOptions other) 251536"];
934 [label="param CSharpParseOptions(this) 251537"];
935 [label="other.SpecifiedLanguageVersion 251538"];
936 [label="other.DocumentationMode 251539"];
937 [label="other.Kind 251540"];
938 [label="other.PreprocessorSymbols 251541"];
939 [label="other.Features 251542"];
940 [label="get\n            {\n                return _features;\n            } 251543"];
941 [label="return _features; 251544"];
942 [label="param CSharpParseOptions(this) 251545"];
943 [label="param CSharpParseOptions(LanguageVersion languageVersion) 251546"];
944 [label="param CSharpParseOptions(DocumentationMode documentationMode) 251547"];
945 [label="param CSharpParseOptions(SourceCodeKind kind) 251548"];
946 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 251549"];
947 [label="param CSharpParseOptions(this) 251550"];
948 [label="param CSharpParseOptions(this) 251551"];
949 [label="param CSharpParseOptions(this) 251552"];
950 [label="_features 251553"];
951 [label="public LanguageVersion LanguageVersion { get; private set; } 251554"];
952 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251555"];
953 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 251556"];
954 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251557"];
955 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 251558"];
956 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 251559"];
957 [label="return version; 251560"];
958 [label="this.LanguageVersion 251561"];
959 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 251562"];
960 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251563"];
961 [label="_features 251564"];
962 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 251565"];
963 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 251566"];
964 [label="'testV7SwitchBinder' 251567"];
965 [label="'true' 251568"];
966 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 251569"];
967 [label="param WithFeatures(IEnumerable<KeyValuePair<string, string>>? features) 251570"];
968 [label="param WithFeatures(this) 251571"];
969 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251572"];
970 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251573"];
971 [label="ImmutableDictionary<string, string> dictionary =\n                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)\n                ?? ImmutableDictionary<string, string>.Empty; 251574"];
972 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251575"];
973 [label="return new CSharpParseOptions(this) { _features = dictionary }; 251576"];
974 [label="new CSharpParseOptions(this) { _features = dictionary } 251577"];
975 [label="param CSharpParseOptions(CSharpParseOptions other) 251578"];
976 [label="param CSharpParseOptions(this) 251579"];
977 [label="other.SpecifiedLanguageVersion 251580"];
978 [label="other.DocumentationMode 251581"];
979 [label="other.Kind 251582"];
980 [label="other.Features 251583"];
981 [label="get\n            {\n                return _features;\n            } 251584"];
982 [label="param CSharpParseOptions(this) 251585"];
983 [label="param CSharpParseOptions(this) 251586"];
984 [label="param CSharpParseOptions(this) 251587"];
985 [label="param CSharpParseOptions(this) 251588"];
986 [label="_features 251589"];
987 [label="public LanguageVersion LanguageVersion { get; private set; } 251590"];
988 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 251591"];
989 [label="languageVersion.MapSpecifiedToEffectiveVersion() 251592"];
990 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 251593"];
991 [label="_features 251594"];
992 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 251595"];
993 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 251596"];
994 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 251597"];
995 [label="RegularWithoutRecursivePatterns = Regular7_3 251598"];
996 [label="RegularWithRecursivePatterns = Regular8 251599"];
997 [label="RegularWithoutPatternCombinators = Regular8 251600"];
998 [label="RegularWithPatternCombinators = RegularPreview 251601"];
999 [label="OutputKind.DynamicallyLinkedLibrary 251602"];
1000 [label="OptimizationLevel.Release 251603"];
1001 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 251604"];
1002 [label="param CreateTestOptions(OutputKind outputKind) 251605"];
1003 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 251606"];
1004 [label="param CreateTestOptions(bool allowUnsafe = false) 251607"];
1005 [label="outputKind 251608"];
1006 [label="optimizationLevel: optimizationLevel 251609"];
1007 [label="warningLevel: Diagnostic.MaxWarningLevel 251610"];
1008 [label="allowUnsafe: allowUnsafe 251611"];
1009 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 251612"];
1010 [label="param CSharpCompilationOptions(OutputKind outputKind) 251613"];
1011 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 251614"];
1012 [label="param CSharpCompilationOptions(string? moduleName = null) 251615"];
1013 [label="param CSharpCompilationOptions(string? mainTypeName = null) 251616"];
1014 [label="param CSharpCompilationOptions(string? scriptClassName = null) 251617"];
1015 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 251618"];
1016 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 251619"];
1017 [label="param CSharpCompilationOptions(bool checkOverflow = false) 251620"];
1018 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 251621"];
1019 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 251622"];
1020 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 251623"];
1021 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 251624"];
1022 [label="param CSharpCompilationOptions(bool? delaySign = null) 251625"];
1023 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 251626"];
1024 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 251627"];
1025 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 251628"];
1026 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 251629"];
1027 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 251630"];
1028 [label="param CSharpCompilationOptions(bool deterministic = false) 251631"];
1029 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 251632"];
1030 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 251633"];
1031 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 251634"];
1032 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 251635"];
1033 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 251636"];
1034 [label="param CSharpCompilationOptions(bool publicSign = false) 251637"];
1035 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 251638"];
1036 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 251639"];
1037 [label="param CSharpCompilationOptions(this) 251640"];
1038 [label="outputKind 251641"];
1039 [label="reportSuppressedDiagnostics 251642"];
1040 [label="moduleName 251643"];
1041 [label="mainTypeName 251644"];
1042 [label="scriptClassName 251645"];
1043 [label="usings 251646"];
1044 [label="optimizationLevel 251647"];
1045 [label="checkOverflow 251648"];
1046 [label="allowUnsafe 251649"];
1047 [label="cryptoKeyContainer 251650"];
1048 [label="cryptoKeyFile 251651"];
1049 [label="cryptoPublicKey 251652"];
1050 [label="delaySign 251653"];
1051 [label="platform 251654"];
1052 [label="generalDiagnosticOption 251655"];
1053 [label="warningLevel 251656"];
1054 [label="specificDiagnosticOptions 251657"];
1055 [label="concurrentBuild 251658"];
1056 [label="deterministic 251659"];
1057 [label="default 251660"];
1058 [label="false 251661"];
1059 [label="xmlReferenceResolver 251662"];
1060 [label="sourceReferenceResolver 251663"];
1061 [label="null 251664"];
1062 [label="metadataReferenceResolver 251665"];
1063 [label="assemblyIdentityComparer 251666"];
1064 [label="strongNameProvider 251667"];
1065 [label="metadataImportOptions 251668"];
1066 [label="false 251669"];
1067 [label="publicSign 251670"];
1068 [label="BinderFlags.None 251671"];
1069 [label="nullableContextOptions 251672"];
1070 [label="param CSharpCompilationOptions(OutputKind outputKind) 251673"];
1071 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 251674"];
1072 [label="param CSharpCompilationOptions(string? moduleName) 251675"];
1073 [label="param CSharpCompilationOptions(string? mainTypeName) 251676"];
1074 [label="param CSharpCompilationOptions(string? scriptClassName) 251677"];
1075 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 251678"];
1076 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 251679"];
1077 [label="param CSharpCompilationOptions(bool checkOverflow) 251680"];
1078 [label="param CSharpCompilationOptions(bool allowUnsafe) 251681"];
1079 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 251682"];
1080 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 251683"];
1081 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 251684"];
1082 [label="param CSharpCompilationOptions(bool? delaySign) 251685"];
1083 [label="param CSharpCompilationOptions(Platform platform) 251686"];
1084 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 251687"];
1085 [label="param CSharpCompilationOptions(int warningLevel) 251688"];
1086 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 251689"];
1087 [label="param CSharpCompilationOptions(bool concurrentBuild) 251690"];
1088 [label="param CSharpCompilationOptions(bool deterministic) 251691"];
1089 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 251692"];
1090 [label="param CSharpCompilationOptions(bool debugPlusMode) 251693"];
1091 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 251694"];
1092 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 251695"];
1093 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 251696"];
1094 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 251697"];
1095 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 251698"];
1096 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 251699"];
1097 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 251700"];
1098 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 251701"];
1099 [label="param CSharpCompilationOptions(bool publicSign) 251702"];
1100 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 251703"];
1101 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 251704"];
1102 [label="param CSharpCompilationOptions(this) 251705"];
1103 [label="outputKind 251706"];
1104 [label="reportSuppressedDiagnostics 251707"];
1105 [label="moduleName 251708"];
1106 [label="mainTypeName 251709"];
1107 [label="scriptClassName 251710"];
1108 [label="cryptoKeyContainer 251711"];
1109 [label="cryptoKeyFile 251712"];
1110 [label="cryptoPublicKey 251713"];
1111 [label="delaySign 251714"];
1112 [label="publicSign 251715"];
1113 [label="optimizationLevel 251716"];
1114 [label="checkOverflow 251717"];
1115 [label="platform 251718"];
1116 [label="generalDiagnosticOption 251719"];
1117 [label="warningLevel 251720"];
1118 [label="specificDiagnosticOptions 251721"];
1119 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 251722"];
1120 [label="concurrentBuild 251723"];
1121 [label="deterministic 251724"];
1122 [label="currentLocalTime 251725"];
1123 [label="debugPlusMode 251726"];
1124 [label="xmlReferenceResolver 251727"];
1125 [label="sourceReferenceResolver 251728"];
1126 [label="syntaxTreeOptionsProvider 251729"];
1127 [label="metadataReferenceResolver 251730"];
1128 [label="assemblyIdentityComparer 251731"];
1129 [label="strongNameProvider 251732"];
1130 [label="metadataImportOptions 251733"];
1131 [label="referencesSupersedeLowerVersions 251734"];
1132 [label="param CSharpCompilationOptions(this) 251735"];
1133 [label="public bool AllowUnsafe { get; private set; } 251736"];
1134 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 251737"];
1135 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 251738"];
1136 [label="this.Usings = usings.AsImmutableOrEmpty(); 251739"];
1137 [label="this.Usings 251740"];
1138 [label="this.AllowUnsafe 251741"];
1139 [label="this.TopLevelBinderFlags 251742"];
1140 [label="this.NullableContextOptions 251743"];
1141 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 251744"];
1142 [label="OutputKind.ConsoleApplication 251745"];
1143 [label="OptimizationLevel.Release 251746"];
1144 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 251747"];
1145 [label="param CreateTestOptions(OutputKind outputKind) 251748"];
1146 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 251749"];
1147 [label="param CreateTestOptions(bool allowUnsafe = false) 251750"];
1148 [label="outputKind 251751"];
1149 [label="optimizationLevel: optimizationLevel 251752"];
1150 [label="warningLevel: Diagnostic.MaxWarningLevel 251753"];
1151 [label="allowUnsafe: allowUnsafe 251754"];
1152 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 251755"];
1153 [label="param CSharpCompilationOptions(OutputKind outputKind) 251756"];
1154 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 251757"];
1155 [label="param CSharpCompilationOptions(string? moduleName = null) 251758"];
1156 [label="param CSharpCompilationOptions(string? mainTypeName = null) 251759"];
1157 [label="param CSharpCompilationOptions(string? scriptClassName = null) 251760"];
1158 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 251761"];
1159 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 251762"];
1160 [label="param CSharpCompilationOptions(bool checkOverflow = false) 251763"];
1161 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 251764"];
1162 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 251765"];
1163 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 251766"];
1164 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 251767"];
1165 [label="param CSharpCompilationOptions(bool? delaySign = null) 251768"];
1166 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 251769"];
1167 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 251770"];
1168 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 251771"];
1169 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 251772"];
1170 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 251773"];
1171 [label="param CSharpCompilationOptions(bool deterministic = false) 251774"];
1172 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 251775"];
1173 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 251776"];
1174 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 251777"];
1175 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 251778"];
1176 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 251779"];
1177 [label="param CSharpCompilationOptions(bool publicSign = false) 251780"];
1178 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 251781"];
1179 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 251782"];
1180 [label="param CSharpCompilationOptions(this) 251783"];
1181 [label="outputKind 251784"];
1182 [label="reportSuppressedDiagnostics 251785"];
1183 [label="moduleName 251786"];
1184 [label="mainTypeName 251787"];
1185 [label="scriptClassName 251788"];
1186 [label="usings 251789"];
1187 [label="optimizationLevel 251790"];
1188 [label="checkOverflow 251791"];
1189 [label="allowUnsafe 251792"];
1190 [label="cryptoKeyContainer 251793"];
1191 [label="cryptoKeyFile 251794"];
1192 [label="cryptoPublicKey 251795"];
1193 [label="delaySign 251796"];
1194 [label="platform 251797"];
1195 [label="generalDiagnosticOption 251798"];
1196 [label="warningLevel 251799"];
1197 [label="specificDiagnosticOptions 251800"];
1198 [label="concurrentBuild 251801"];
1199 [label="deterministic 251802"];
1200 [label="default 251803"];
1201 [label="false 251804"];
1202 [label="xmlReferenceResolver 251805"];
1203 [label="sourceReferenceResolver 251806"];
1204 [label="null 251807"];
1205 [label="metadataReferenceResolver 251808"];
1206 [label="assemblyIdentityComparer 251809"];
1207 [label="strongNameProvider 251810"];
1208 [label="metadataImportOptions 251811"];
1209 [label="false 251812"];
1210 [label="publicSign 251813"];
1211 [label="BinderFlags.None 251814"];
1212 [label="nullableContextOptions 251815"];
1213 [label="param CSharpCompilationOptions(OutputKind outputKind) 251816"];
1214 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 251817"];
1215 [label="param CSharpCompilationOptions(string? moduleName) 251818"];
1216 [label="param CSharpCompilationOptions(string? mainTypeName) 251819"];
1217 [label="param CSharpCompilationOptions(string? scriptClassName) 251820"];
1218 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 251821"];
1219 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 251822"];
1220 [label="param CSharpCompilationOptions(bool checkOverflow) 251823"];
1221 [label="param CSharpCompilationOptions(bool allowUnsafe) 251824"];
1222 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 251825"];
1223 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 251826"];
1224 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 251827"];
1225 [label="param CSharpCompilationOptions(bool? delaySign) 251828"];
1226 [label="param CSharpCompilationOptions(Platform platform) 251829"];
1227 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 251830"];
1228 [label="param CSharpCompilationOptions(int warningLevel) 251831"];
1229 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 251832"];
1230 [label="param CSharpCompilationOptions(bool concurrentBuild) 251833"];
1231 [label="param CSharpCompilationOptions(bool deterministic) 251834"];
1232 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 251835"];
1233 [label="param CSharpCompilationOptions(bool debugPlusMode) 251836"];
1234 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 251837"];
1235 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 251838"];
1236 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 251839"];
1237 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 251840"];
1238 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 251841"];
1239 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 251842"];
1240 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 251843"];
1241 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 251844"];
1242 [label="param CSharpCompilationOptions(bool publicSign) 251845"];
1243 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 251846"];
1244 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 251847"];
1245 [label="param CSharpCompilationOptions(this) 251848"];
1246 [label="outputKind 251849"];
1247 [label="reportSuppressedDiagnostics 251850"];
1248 [label="moduleName 251851"];
1249 [label="mainTypeName 251852"];
1250 [label="scriptClassName 251853"];
1251 [label="cryptoKeyContainer 251854"];
1252 [label="cryptoKeyFile 251855"];
1253 [label="cryptoPublicKey 251856"];
1254 [label="delaySign 251857"];
1255 [label="publicSign 251858"];
1256 [label="optimizationLevel 251859"];
1257 [label="checkOverflow 251860"];
1258 [label="platform 251861"];
1259 [label="generalDiagnosticOption 251862"];
1260 [label="warningLevel 251863"];
1261 [label="specificDiagnosticOptions 251864"];
1262 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 251865"];
1263 [label="concurrentBuild 251866"];
1264 [label="deterministic 251867"];
1265 [label="currentLocalTime 251868"];
1266 [label="debugPlusMode 251869"];
1267 [label="xmlReferenceResolver 251870"];
1268 [label="sourceReferenceResolver 251871"];
1269 [label="syntaxTreeOptionsProvider 251872"];
1270 [label="metadataReferenceResolver 251873"];
1271 [label="assemblyIdentityComparer 251874"];
1272 [label="strongNameProvider 251875"];
1273 [label="metadataImportOptions 251876"];
1274 [label="referencesSupersedeLowerVersions 251877"];
1275 [label="param CSharpCompilationOptions(this) 251878"];
1276 [label="public bool AllowUnsafe { get; private set; } 251879"];
1277 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 251880"];
1278 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 251881"];
1279 [label="this.Usings = usings.AsImmutableOrEmpty(); 251882"];
1280 [label="this.Usings 251883"];
1281 [label="this.AllowUnsafe 251884"];
1282 [label="this.TopLevelBinderFlags 251885"];
1283 [label="this.NullableContextOptions 251886"];
1284 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 251887"];
1285 [label="true 251888"];
1286 [label="ReleaseDll.WithDebugPlusMode(true) 251889"];
1287 [label="param WithDebugPlusMode(bool debugPlusMode) 251890"];
1288 [label="param WithDebugPlusMode(this) 251891"];
1289 [label="if (debugPlusMode == this.DebugPlusMode)\n            {\n                return this;\n            } 251892"];
1290 [label="return new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode }; 251893"];
1291 [label="return new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode }; 251894"];
1292 [label="new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode } 251895"];
1293 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 251896"];
1294 [label="param CSharpCompilationOptions(this) 251897"];
1295 [label="other.OutputKind 251898"];
1296 [label="other.ModuleName 251899"];
1297 [label="other.MainTypeName 251900"];
1298 [label="other.ScriptClassName 251901"];
1299 [label="other.Usings 251902"];
1300 [label="other.OptimizationLevel 251903"];
1301 [label="other.CheckOverflow 251904"];
1302 [label="other.AllowUnsafe 251905"];
1303 [label="other.CryptoKeyContainer 251906"];
1304 [label="other.CryptoKeyFile 251907"];
1305 [label="other.CryptoPublicKey 251908"];
1306 [label="other.DelaySign 251909"];
1307 [label="other.Platform 251910"];
1308 [label="other.GeneralDiagnosticOption 251911"];
1309 [label="other.WarningLevel 251912"];
1310 [label="other.SpecificDiagnosticOptions 251913"];
1311 [label="other.ConcurrentBuild 251914"];
1312 [label="other.Deterministic 251915"];
1313 [label="other.CurrentLocalTime 251916"];
1314 [label="other.DebugPlusMode 251917"];
1315 [label="other.XmlReferenceResolver 251918"];
1316 [label="other.SourceReferenceResolver 251919"];
1317 [label="other.SyntaxTreeOptionsProvider 251920"];
1318 [label="other.MetadataReferenceResolver 251921"];
1319 [label="other.AssemblyIdentityComparer 251922"];
1320 [label="other.StrongNameProvider 251923"];
1321 [label="other.MetadataImportOptions 251924"];
1322 [label="other.ReferencesSupersedeLowerVersions 251925"];
1323 [label="other.ReportSuppressedDiagnostics 251926"];
1324 [label="other.PublicSign 251927"];
1325 [label="other.TopLevelBinderFlags 251928"];
1326 [label="other.NullableContextOptions 251929"];
1327 [label="param CSharpCompilationOptions(this) 251930"];
1328 [label="param CSharpCompilationOptions(OutputKind outputKind) 251931"];
1329 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 251932"];
1330 [label="param CSharpCompilationOptions(string? moduleName) 251933"];
1331 [label="param CSharpCompilationOptions(string? mainTypeName) 251934"];
1332 [label="param CSharpCompilationOptions(string? scriptClassName) 251935"];
1333 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 251936"];
1334 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 251937"];
1335 [label="param CSharpCompilationOptions(bool checkOverflow) 251938"];
1336 [label="param CSharpCompilationOptions(bool allowUnsafe) 251939"];
1337 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 251940"];
1338 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 251941"];
1339 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 251942"];
1340 [label="param CSharpCompilationOptions(bool? delaySign) 251943"];
1341 [label="param CSharpCompilationOptions(Platform platform) 251944"];
1342 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 251945"];
1343 [label="param CSharpCompilationOptions(int warningLevel) 251946"];
1344 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 251947"];
1345 [label="param CSharpCompilationOptions(bool concurrentBuild) 251948"];
1346 [label="param CSharpCompilationOptions(bool deterministic) 251949"];
1347 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 251950"];
1348 [label="param CSharpCompilationOptions(bool debugPlusMode) 251951"];
1349 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 251952"];
1350 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 251953"];
1351 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 251954"];
1352 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 251955"];
1353 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 251956"];
1354 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 251957"];
1355 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 251958"];
1356 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 251959"];
1357 [label="param CSharpCompilationOptions(bool publicSign) 251960"];
1358 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 251961"];
1359 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 251962"];
1360 [label="param CSharpCompilationOptions(this) 251963"];
1361 [label="param CSharpCompilationOptions(this) 251964"];
1362 [label="param CSharpCompilationOptions(this) 251965"];
1363 [label="public bool AllowUnsafe { get; private set; } 251966"];
1364 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 251967"];
1365 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 251968"];
1366 [label="this.Usings = usings.AsImmutableOrEmpty(); 251969"];
1367 [label="this.Usings 251970"];
1368 [label="this.AllowUnsafe 251971"];
1369 [label="DebugPlusMode 251972"];
1370 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 251973"];
1371 [label="true 251974"];
1372 [label="ReleaseExe.WithDebugPlusMode(true) 251975"];
1373 [label="param WithDebugPlusMode(bool debugPlusMode) 251976"];
1374 [label="param WithDebugPlusMode(this) 251977"];
1375 [label="if (debugPlusMode == this.DebugPlusMode)\n            {\n                return this;\n            } 251978"];
1376 [label="return new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode }; 251979"];
1377 [label="return new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode }; 251980"];
1378 [label="new CSharpCompilationOptions(this) { DebugPlusMode = debugPlusMode } 251981"];
1379 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 251982"];
1380 [label="param CSharpCompilationOptions(this) 251983"];
1381 [label="other.OutputKind 251984"];
1382 [label="other.ModuleName 251985"];
1383 [label="other.MainTypeName 251986"];
1384 [label="other.ScriptClassName 251987"];
1385 [label="other.Usings 251988"];
1386 [label="other.OptimizationLevel 251989"];
1387 [label="other.CheckOverflow 251990"];
1388 [label="other.AllowUnsafe 251991"];
1389 [label="other.CryptoKeyContainer 251992"];
1390 [label="other.CryptoKeyFile 251993"];
1391 [label="other.CryptoPublicKey 251994"];
1392 [label="other.DelaySign 251995"];
1393 [label="other.Platform 251996"];
1394 [label="other.GeneralDiagnosticOption 251997"];
1395 [label="other.WarningLevel 251998"];
1396 [label="other.SpecificDiagnosticOptions 251999"];
1397 [label="other.ConcurrentBuild 252000"];
1398 [label="other.Deterministic 252001"];
1399 [label="other.CurrentLocalTime 252002"];
1400 [label="other.DebugPlusMode 252003"];
1401 [label="other.XmlReferenceResolver 252004"];
1402 [label="other.SourceReferenceResolver 252005"];
1403 [label="other.SyntaxTreeOptionsProvider 252006"];
1404 [label="other.MetadataReferenceResolver 252007"];
1405 [label="other.AssemblyIdentityComparer 252008"];
1406 [label="other.StrongNameProvider 252009"];
1407 [label="other.MetadataImportOptions 252010"];
1408 [label="other.ReferencesSupersedeLowerVersions 252011"];
1409 [label="other.ReportSuppressedDiagnostics 252012"];
1410 [label="other.PublicSign 252013"];
1411 [label="other.TopLevelBinderFlags 252014"];
1412 [label="other.NullableContextOptions 252015"];
1413 [label="param CSharpCompilationOptions(this) 252016"];
1414 [label="param CSharpCompilationOptions(OutputKind outputKind) 252017"];
1415 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252018"];
1416 [label="param CSharpCompilationOptions(string? moduleName) 252019"];
1417 [label="param CSharpCompilationOptions(string? mainTypeName) 252020"];
1418 [label="param CSharpCompilationOptions(string? scriptClassName) 252021"];
1419 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252022"];
1420 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252023"];
1421 [label="param CSharpCompilationOptions(bool checkOverflow) 252024"];
1422 [label="param CSharpCompilationOptions(bool allowUnsafe) 252025"];
1423 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252026"];
1424 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252027"];
1425 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252028"];
1426 [label="param CSharpCompilationOptions(bool? delaySign) 252029"];
1427 [label="param CSharpCompilationOptions(Platform platform) 252030"];
1428 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252031"];
1429 [label="param CSharpCompilationOptions(int warningLevel) 252032"];
1430 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252033"];
1431 [label="param CSharpCompilationOptions(bool concurrentBuild) 252034"];
1432 [label="param CSharpCompilationOptions(bool deterministic) 252035"];
1433 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252036"];
1434 [label="param CSharpCompilationOptions(bool debugPlusMode) 252037"];
1435 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252038"];
1436 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252039"];
1437 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252040"];
1438 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252041"];
1439 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252042"];
1440 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252043"];
1441 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252044"];
1442 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252045"];
1443 [label="param CSharpCompilationOptions(bool publicSign) 252046"];
1444 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252047"];
1445 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252048"];
1446 [label="param CSharpCompilationOptions(this) 252049"];
1447 [label="param CSharpCompilationOptions(this) 252050"];
1448 [label="param CSharpCompilationOptions(this) 252051"];
1449 [label="public bool AllowUnsafe { get; private set; } 252052"];
1450 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252053"];
1451 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252054"];
1452 [label="this.Usings = usings.AsImmutableOrEmpty(); 252055"];
1453 [label="this.Usings 252056"];
1454 [label="this.AllowUnsafe 252057"];
1455 [label="DebugPlusMode 252058"];
1456 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 252059"];
1457 [label="OutputKind.DynamicallyLinkedLibrary 252060"];
1458 [label="OptimizationLevel.Debug 252061"];
1459 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 252062"];
1460 [label="param CreateTestOptions(OutputKind outputKind) 252063"];
1461 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252064"];
1462 [label="param CreateTestOptions(bool allowUnsafe = false) 252065"];
1463 [label="outputKind 252066"];
1464 [label="optimizationLevel: optimizationLevel 252067"];
1465 [label="warningLevel: Diagnostic.MaxWarningLevel 252068"];
1466 [label="allowUnsafe: allowUnsafe 252069"];
1467 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252070"];
1468 [label="param CSharpCompilationOptions(OutputKind outputKind) 252071"];
1469 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252072"];
1470 [label="param CSharpCompilationOptions(string? moduleName = null) 252073"];
1471 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252074"];
1472 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252075"];
1473 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252076"];
1474 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252077"];
1475 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252078"];
1476 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252079"];
1477 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252080"];
1478 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252081"];
1479 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252082"];
1480 [label="param CSharpCompilationOptions(bool? delaySign = null) 252083"];
1481 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252084"];
1482 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252085"];
1483 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252086"];
1484 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252087"];
1485 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252088"];
1486 [label="param CSharpCompilationOptions(bool deterministic = false) 252089"];
1487 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252090"];
1488 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252091"];
1489 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252092"];
1490 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252093"];
1491 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252094"];
1492 [label="param CSharpCompilationOptions(bool publicSign = false) 252095"];
1493 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252096"];
1494 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252097"];
1495 [label="param CSharpCompilationOptions(this) 252098"];
1496 [label="outputKind 252099"];
1497 [label="reportSuppressedDiagnostics 252100"];
1498 [label="moduleName 252101"];
1499 [label="mainTypeName 252102"];
1500 [label="scriptClassName 252103"];
1501 [label="usings 252104"];
1502 [label="optimizationLevel 252105"];
1503 [label="checkOverflow 252106"];
1504 [label="allowUnsafe 252107"];
1505 [label="cryptoKeyContainer 252108"];
1506 [label="cryptoKeyFile 252109"];
1507 [label="cryptoPublicKey 252110"];
1508 [label="delaySign 252111"];
1509 [label="platform 252112"];
1510 [label="generalDiagnosticOption 252113"];
1511 [label="warningLevel 252114"];
1512 [label="specificDiagnosticOptions 252115"];
1513 [label="concurrentBuild 252116"];
1514 [label="deterministic 252117"];
1515 [label="default 252118"];
1516 [label="false 252119"];
1517 [label="xmlReferenceResolver 252120"];
1518 [label="sourceReferenceResolver 252121"];
1519 [label="null 252122"];
1520 [label="metadataReferenceResolver 252123"];
1521 [label="assemblyIdentityComparer 252124"];
1522 [label="strongNameProvider 252125"];
1523 [label="metadataImportOptions 252126"];
1524 [label="false 252127"];
1525 [label="publicSign 252128"];
1526 [label="BinderFlags.None 252129"];
1527 [label="nullableContextOptions 252130"];
1528 [label="param CSharpCompilationOptions(OutputKind outputKind) 252131"];
1529 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252132"];
1530 [label="param CSharpCompilationOptions(string? moduleName) 252133"];
1531 [label="param CSharpCompilationOptions(string? mainTypeName) 252134"];
1532 [label="param CSharpCompilationOptions(string? scriptClassName) 252135"];
1533 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252136"];
1534 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252137"];
1535 [label="param CSharpCompilationOptions(bool checkOverflow) 252138"];
1536 [label="param CSharpCompilationOptions(bool allowUnsafe) 252139"];
1537 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252140"];
1538 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252141"];
1539 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252142"];
1540 [label="param CSharpCompilationOptions(bool? delaySign) 252143"];
1541 [label="param CSharpCompilationOptions(Platform platform) 252144"];
1542 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252145"];
1543 [label="param CSharpCompilationOptions(int warningLevel) 252146"];
1544 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252147"];
1545 [label="param CSharpCompilationOptions(bool concurrentBuild) 252148"];
1546 [label="param CSharpCompilationOptions(bool deterministic) 252149"];
1547 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252150"];
1548 [label="param CSharpCompilationOptions(bool debugPlusMode) 252151"];
1549 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252152"];
1550 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252153"];
1551 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252154"];
1552 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252155"];
1553 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252156"];
1554 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252157"];
1555 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252158"];
1556 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252159"];
1557 [label="param CSharpCompilationOptions(bool publicSign) 252160"];
1558 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252161"];
1559 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252162"];
1560 [label="param CSharpCompilationOptions(this) 252163"];
1561 [label="outputKind 252164"];
1562 [label="reportSuppressedDiagnostics 252165"];
1563 [label="moduleName 252166"];
1564 [label="mainTypeName 252167"];
1565 [label="scriptClassName 252168"];
1566 [label="cryptoKeyContainer 252169"];
1567 [label="cryptoKeyFile 252170"];
1568 [label="cryptoPublicKey 252171"];
1569 [label="delaySign 252172"];
1570 [label="publicSign 252173"];
1571 [label="optimizationLevel 252174"];
1572 [label="checkOverflow 252175"];
1573 [label="platform 252176"];
1574 [label="generalDiagnosticOption 252177"];
1575 [label="warningLevel 252178"];
1576 [label="specificDiagnosticOptions 252179"];
1577 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252180"];
1578 [label="concurrentBuild 252181"];
1579 [label="deterministic 252182"];
1580 [label="currentLocalTime 252183"];
1581 [label="debugPlusMode 252184"];
1582 [label="xmlReferenceResolver 252185"];
1583 [label="sourceReferenceResolver 252186"];
1584 [label="syntaxTreeOptionsProvider 252187"];
1585 [label="metadataReferenceResolver 252188"];
1586 [label="assemblyIdentityComparer 252189"];
1587 [label="strongNameProvider 252190"];
1588 [label="metadataImportOptions 252191"];
1589 [label="referencesSupersedeLowerVersions 252192"];
1590 [label="param CSharpCompilationOptions(this) 252193"];
1591 [label="public bool AllowUnsafe { get; private set; } 252194"];
1592 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252195"];
1593 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252196"];
1594 [label="this.Usings = usings.AsImmutableOrEmpty(); 252197"];
1595 [label="this.Usings 252198"];
1596 [label="this.AllowUnsafe 252199"];
1597 [label="this.TopLevelBinderFlags 252200"];
1598 [label="this.NullableContextOptions 252201"];
1599 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 252202"];
1600 [label="OutputKind.ConsoleApplication 252203"];
1601 [label="OptimizationLevel.Debug 252204"];
1602 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 252205"];
1603 [label="param CreateTestOptions(OutputKind outputKind) 252206"];
1604 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252207"];
1605 [label="param CreateTestOptions(bool allowUnsafe = false) 252208"];
1606 [label="outputKind 252209"];
1607 [label="optimizationLevel: optimizationLevel 252210"];
1608 [label="warningLevel: Diagnostic.MaxWarningLevel 252211"];
1609 [label="allowUnsafe: allowUnsafe 252212"];
1610 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252213"];
1611 [label="param CSharpCompilationOptions(OutputKind outputKind) 252214"];
1612 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252215"];
1613 [label="param CSharpCompilationOptions(string? moduleName = null) 252216"];
1614 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252217"];
1615 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252218"];
1616 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252219"];
1617 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252220"];
1618 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252221"];
1619 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252222"];
1620 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252223"];
1621 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252224"];
1622 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252225"];
1623 [label="param CSharpCompilationOptions(bool? delaySign = null) 252226"];
1624 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252227"];
1625 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252228"];
1626 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252229"];
1627 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252230"];
1628 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252231"];
1629 [label="param CSharpCompilationOptions(bool deterministic = false) 252232"];
1630 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252233"];
1631 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252234"];
1632 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252235"];
1633 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252236"];
1634 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252237"];
1635 [label="param CSharpCompilationOptions(bool publicSign = false) 252238"];
1636 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252239"];
1637 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252240"];
1638 [label="param CSharpCompilationOptions(this) 252241"];
1639 [label="outputKind 252242"];
1640 [label="reportSuppressedDiagnostics 252243"];
1641 [label="moduleName 252244"];
1642 [label="mainTypeName 252245"];
1643 [label="scriptClassName 252246"];
1644 [label="usings 252247"];
1645 [label="optimizationLevel 252248"];
1646 [label="checkOverflow 252249"];
1647 [label="allowUnsafe 252250"];
1648 [label="cryptoKeyContainer 252251"];
1649 [label="cryptoKeyFile 252252"];
1650 [label="cryptoPublicKey 252253"];
1651 [label="delaySign 252254"];
1652 [label="platform 252255"];
1653 [label="generalDiagnosticOption 252256"];
1654 [label="warningLevel 252257"];
1655 [label="specificDiagnosticOptions 252258"];
1656 [label="concurrentBuild 252259"];
1657 [label="deterministic 252260"];
1658 [label="default 252261"];
1659 [label="false 252262"];
1660 [label="xmlReferenceResolver 252263"];
1661 [label="sourceReferenceResolver 252264"];
1662 [label="null 252265"];
1663 [label="metadataReferenceResolver 252266"];
1664 [label="assemblyIdentityComparer 252267"];
1665 [label="strongNameProvider 252268"];
1666 [label="metadataImportOptions 252269"];
1667 [label="false 252270"];
1668 [label="publicSign 252271"];
1669 [label="BinderFlags.None 252272"];
1670 [label="nullableContextOptions 252273"];
1671 [label="param CSharpCompilationOptions(OutputKind outputKind) 252274"];
1672 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252275"];
1673 [label="param CSharpCompilationOptions(string? moduleName) 252276"];
1674 [label="param CSharpCompilationOptions(string? mainTypeName) 252277"];
1675 [label="param CSharpCompilationOptions(string? scriptClassName) 252278"];
1676 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252279"];
1677 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252280"];
1678 [label="param CSharpCompilationOptions(bool checkOverflow) 252281"];
1679 [label="param CSharpCompilationOptions(bool allowUnsafe) 252282"];
1680 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252283"];
1681 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252284"];
1682 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252285"];
1683 [label="param CSharpCompilationOptions(bool? delaySign) 252286"];
1684 [label="param CSharpCompilationOptions(Platform platform) 252287"];
1685 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252288"];
1686 [label="param CSharpCompilationOptions(int warningLevel) 252289"];
1687 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252290"];
1688 [label="param CSharpCompilationOptions(bool concurrentBuild) 252291"];
1689 [label="param CSharpCompilationOptions(bool deterministic) 252292"];
1690 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252293"];
1691 [label="param CSharpCompilationOptions(bool debugPlusMode) 252294"];
1692 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252295"];
1693 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252296"];
1694 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252297"];
1695 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252298"];
1696 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252299"];
1697 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252300"];
1698 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252301"];
1699 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252302"];
1700 [label="param CSharpCompilationOptions(bool publicSign) 252303"];
1701 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252304"];
1702 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252305"];
1703 [label="param CSharpCompilationOptions(this) 252306"];
1704 [label="outputKind 252307"];
1705 [label="reportSuppressedDiagnostics 252308"];
1706 [label="moduleName 252309"];
1707 [label="mainTypeName 252310"];
1708 [label="scriptClassName 252311"];
1709 [label="cryptoKeyContainer 252312"];
1710 [label="cryptoKeyFile 252313"];
1711 [label="cryptoPublicKey 252314"];
1712 [label="delaySign 252315"];
1713 [label="publicSign 252316"];
1714 [label="optimizationLevel 252317"];
1715 [label="checkOverflow 252318"];
1716 [label="platform 252319"];
1717 [label="generalDiagnosticOption 252320"];
1718 [label="warningLevel 252321"];
1719 [label="specificDiagnosticOptions 252322"];
1720 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252323"];
1721 [label="concurrentBuild 252324"];
1722 [label="deterministic 252325"];
1723 [label="currentLocalTime 252326"];
1724 [label="debugPlusMode 252327"];
1725 [label="xmlReferenceResolver 252328"];
1726 [label="sourceReferenceResolver 252329"];
1727 [label="syntaxTreeOptionsProvider 252330"];
1728 [label="metadataReferenceResolver 252331"];
1729 [label="assemblyIdentityComparer 252332"];
1730 [label="strongNameProvider 252333"];
1731 [label="metadataImportOptions 252334"];
1732 [label="referencesSupersedeLowerVersions 252335"];
1733 [label="param CSharpCompilationOptions(this) 252336"];
1734 [label="public bool AllowUnsafe { get; private set; } 252337"];
1735 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252338"];
1736 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252339"];
1737 [label="this.Usings = usings.AsImmutableOrEmpty(); 252340"];
1738 [label="this.Usings 252341"];
1739 [label="this.AllowUnsafe 252342"];
1740 [label="this.TopLevelBinderFlags 252343"];
1741 [label="this.NullableContextOptions 252344"];
1742 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 252345"];
1743 [label="OutputKind.WindowsRuntimeMetadata 252346"];
1744 [label="OptimizationLevel.Release 252347"];
1745 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 252348"];
1746 [label="param CreateTestOptions(OutputKind outputKind) 252349"];
1747 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252350"];
1748 [label="param CreateTestOptions(bool allowUnsafe = false) 252351"];
1749 [label="outputKind 252352"];
1750 [label="optimizationLevel: optimizationLevel 252353"];
1751 [label="warningLevel: Diagnostic.MaxWarningLevel 252354"];
1752 [label="allowUnsafe: allowUnsafe 252355"];
1753 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252356"];
1754 [label="param CSharpCompilationOptions(OutputKind outputKind) 252357"];
1755 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252358"];
1756 [label="param CSharpCompilationOptions(string? moduleName = null) 252359"];
1757 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252360"];
1758 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252361"];
1759 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252362"];
1760 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252363"];
1761 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252364"];
1762 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252365"];
1763 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252366"];
1764 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252367"];
1765 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252368"];
1766 [label="param CSharpCompilationOptions(bool? delaySign = null) 252369"];
1767 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252370"];
1768 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252371"];
1769 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252372"];
1770 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252373"];
1771 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252374"];
1772 [label="param CSharpCompilationOptions(bool deterministic = false) 252375"];
1773 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252376"];
1774 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252377"];
1775 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252378"];
1776 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252379"];
1777 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252380"];
1778 [label="param CSharpCompilationOptions(bool publicSign = false) 252381"];
1779 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252382"];
1780 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252383"];
1781 [label="param CSharpCompilationOptions(this) 252384"];
1782 [label="outputKind 252385"];
1783 [label="reportSuppressedDiagnostics 252386"];
1784 [label="moduleName 252387"];
1785 [label="mainTypeName 252388"];
1786 [label="scriptClassName 252389"];
1787 [label="usings 252390"];
1788 [label="optimizationLevel 252391"];
1789 [label="checkOverflow 252392"];
1790 [label="allowUnsafe 252393"];
1791 [label="cryptoKeyContainer 252394"];
1792 [label="cryptoKeyFile 252395"];
1793 [label="cryptoPublicKey 252396"];
1794 [label="delaySign 252397"];
1795 [label="platform 252398"];
1796 [label="generalDiagnosticOption 252399"];
1797 [label="warningLevel 252400"];
1798 [label="specificDiagnosticOptions 252401"];
1799 [label="concurrentBuild 252402"];
1800 [label="deterministic 252403"];
1801 [label="default 252404"];
1802 [label="false 252405"];
1803 [label="xmlReferenceResolver 252406"];
1804 [label="sourceReferenceResolver 252407"];
1805 [label="null 252408"];
1806 [label="metadataReferenceResolver 252409"];
1807 [label="assemblyIdentityComparer 252410"];
1808 [label="strongNameProvider 252411"];
1809 [label="metadataImportOptions 252412"];
1810 [label="false 252413"];
1811 [label="publicSign 252414"];
1812 [label="BinderFlags.None 252415"];
1813 [label="nullableContextOptions 252416"];
1814 [label="param CSharpCompilationOptions(OutputKind outputKind) 252417"];
1815 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252418"];
1816 [label="param CSharpCompilationOptions(string? moduleName) 252419"];
1817 [label="param CSharpCompilationOptions(string? mainTypeName) 252420"];
1818 [label="param CSharpCompilationOptions(string? scriptClassName) 252421"];
1819 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252422"];
1820 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252423"];
1821 [label="param CSharpCompilationOptions(bool checkOverflow) 252424"];
1822 [label="param CSharpCompilationOptions(bool allowUnsafe) 252425"];
1823 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252426"];
1824 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252427"];
1825 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252428"];
1826 [label="param CSharpCompilationOptions(bool? delaySign) 252429"];
1827 [label="param CSharpCompilationOptions(Platform platform) 252430"];
1828 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252431"];
1829 [label="param CSharpCompilationOptions(int warningLevel) 252432"];
1830 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252433"];
1831 [label="param CSharpCompilationOptions(bool concurrentBuild) 252434"];
1832 [label="param CSharpCompilationOptions(bool deterministic) 252435"];
1833 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252436"];
1834 [label="param CSharpCompilationOptions(bool debugPlusMode) 252437"];
1835 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252438"];
1836 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252439"];
1837 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252440"];
1838 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252441"];
1839 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252442"];
1840 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252443"];
1841 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252444"];
1842 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252445"];
1843 [label="param CSharpCompilationOptions(bool publicSign) 252446"];
1844 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252447"];
1845 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252448"];
1846 [label="param CSharpCompilationOptions(this) 252449"];
1847 [label="outputKind 252450"];
1848 [label="reportSuppressedDiagnostics 252451"];
1849 [label="moduleName 252452"];
1850 [label="mainTypeName 252453"];
1851 [label="scriptClassName 252454"];
1852 [label="cryptoKeyContainer 252455"];
1853 [label="cryptoKeyFile 252456"];
1854 [label="cryptoPublicKey 252457"];
1855 [label="delaySign 252458"];
1856 [label="publicSign 252459"];
1857 [label="optimizationLevel 252460"];
1858 [label="checkOverflow 252461"];
1859 [label="platform 252462"];
1860 [label="generalDiagnosticOption 252463"];
1861 [label="warningLevel 252464"];
1862 [label="specificDiagnosticOptions 252465"];
1863 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252466"];
1864 [label="concurrentBuild 252467"];
1865 [label="deterministic 252468"];
1866 [label="currentLocalTime 252469"];
1867 [label="debugPlusMode 252470"];
1868 [label="xmlReferenceResolver 252471"];
1869 [label="sourceReferenceResolver 252472"];
1870 [label="syntaxTreeOptionsProvider 252473"];
1871 [label="metadataReferenceResolver 252474"];
1872 [label="assemblyIdentityComparer 252475"];
1873 [label="strongNameProvider 252476"];
1874 [label="metadataImportOptions 252477"];
1875 [label="referencesSupersedeLowerVersions 252478"];
1876 [label="param CSharpCompilationOptions(this) 252479"];
1877 [label="public bool AllowUnsafe { get; private set; } 252480"];
1878 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252481"];
1879 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252482"];
1880 [label="this.Usings = usings.AsImmutableOrEmpty(); 252483"];
1881 [label="this.Usings 252484"];
1882 [label="this.AllowUnsafe 252485"];
1883 [label="this.TopLevelBinderFlags 252486"];
1884 [label="this.NullableContextOptions 252487"];
1885 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 252488"];
1886 [label="OutputKind.WindowsRuntimeMetadata 252489"];
1887 [label="OptimizationLevel.Debug 252490"];
1888 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 252491"];
1889 [label="param CreateTestOptions(OutputKind outputKind) 252492"];
1890 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252493"];
1891 [label="param CreateTestOptions(bool allowUnsafe = false) 252494"];
1892 [label="outputKind 252495"];
1893 [label="optimizationLevel: optimizationLevel 252496"];
1894 [label="warningLevel: Diagnostic.MaxWarningLevel 252497"];
1895 [label="allowUnsafe: allowUnsafe 252498"];
1896 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252499"];
1897 [label="param CSharpCompilationOptions(OutputKind outputKind) 252500"];
1898 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252501"];
1899 [label="param CSharpCompilationOptions(string? moduleName = null) 252502"];
1900 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252503"];
1901 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252504"];
1902 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252505"];
1903 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252506"];
1904 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252507"];
1905 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252508"];
1906 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252509"];
1907 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252510"];
1908 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252511"];
1909 [label="param CSharpCompilationOptions(bool? delaySign = null) 252512"];
1910 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252513"];
1911 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252514"];
1912 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252515"];
1913 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252516"];
1914 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252517"];
1915 [label="param CSharpCompilationOptions(bool deterministic = false) 252518"];
1916 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252519"];
1917 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252520"];
1918 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252521"];
1919 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252522"];
1920 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252523"];
1921 [label="param CSharpCompilationOptions(bool publicSign = false) 252524"];
1922 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252525"];
1923 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252526"];
1924 [label="param CSharpCompilationOptions(this) 252527"];
1925 [label="outputKind 252528"];
1926 [label="reportSuppressedDiagnostics 252529"];
1927 [label="moduleName 252530"];
1928 [label="mainTypeName 252531"];
1929 [label="scriptClassName 252532"];
1930 [label="usings 252533"];
1931 [label="optimizationLevel 252534"];
1932 [label="checkOverflow 252535"];
1933 [label="allowUnsafe 252536"];
1934 [label="cryptoKeyContainer 252537"];
1935 [label="cryptoKeyFile 252538"];
1936 [label="cryptoPublicKey 252539"];
1937 [label="delaySign 252540"];
1938 [label="platform 252541"];
1939 [label="generalDiagnosticOption 252542"];
1940 [label="warningLevel 252543"];
1941 [label="specificDiagnosticOptions 252544"];
1942 [label="concurrentBuild 252545"];
1943 [label="deterministic 252546"];
1944 [label="default 252547"];
1945 [label="false 252548"];
1946 [label="xmlReferenceResolver 252549"];
1947 [label="sourceReferenceResolver 252550"];
1948 [label="null 252551"];
1949 [label="metadataReferenceResolver 252552"];
1950 [label="assemblyIdentityComparer 252553"];
1951 [label="strongNameProvider 252554"];
1952 [label="metadataImportOptions 252555"];
1953 [label="false 252556"];
1954 [label="publicSign 252557"];
1955 [label="BinderFlags.None 252558"];
1956 [label="nullableContextOptions 252559"];
1957 [label="param CSharpCompilationOptions(OutputKind outputKind) 252560"];
1958 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252561"];
1959 [label="param CSharpCompilationOptions(string? moduleName) 252562"];
1960 [label="param CSharpCompilationOptions(string? mainTypeName) 252563"];
1961 [label="param CSharpCompilationOptions(string? scriptClassName) 252564"];
1962 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252565"];
1963 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252566"];
1964 [label="param CSharpCompilationOptions(bool checkOverflow) 252567"];
1965 [label="param CSharpCompilationOptions(bool allowUnsafe) 252568"];
1966 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252569"];
1967 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252570"];
1968 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252571"];
1969 [label="param CSharpCompilationOptions(bool? delaySign) 252572"];
1970 [label="param CSharpCompilationOptions(Platform platform) 252573"];
1971 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252574"];
1972 [label="param CSharpCompilationOptions(int warningLevel) 252575"];
1973 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252576"];
1974 [label="param CSharpCompilationOptions(bool concurrentBuild) 252577"];
1975 [label="param CSharpCompilationOptions(bool deterministic) 252578"];
1976 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252579"];
1977 [label="param CSharpCompilationOptions(bool debugPlusMode) 252580"];
1978 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252581"];
1979 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252582"];
1980 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252583"];
1981 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252584"];
1982 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252585"];
1983 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252586"];
1984 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252587"];
1985 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252588"];
1986 [label="param CSharpCompilationOptions(bool publicSign) 252589"];
1987 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252590"];
1988 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252591"];
1989 [label="param CSharpCompilationOptions(this) 252592"];
1990 [label="outputKind 252593"];
1991 [label="reportSuppressedDiagnostics 252594"];
1992 [label="moduleName 252595"];
1993 [label="mainTypeName 252596"];
1994 [label="scriptClassName 252597"];
1995 [label="cryptoKeyContainer 252598"];
1996 [label="cryptoKeyFile 252599"];
1997 [label="cryptoPublicKey 252600"];
1998 [label="delaySign 252601"];
1999 [label="publicSign 252602"];
2000 [label="optimizationLevel 252603"];
2001 [label="checkOverflow 252604"];
2002 [label="platform 252605"];
2003 [label="generalDiagnosticOption 252606"];
2004 [label="warningLevel 252607"];
2005 [label="specificDiagnosticOptions 252608"];
2006 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252609"];
2007 [label="concurrentBuild 252610"];
2008 [label="deterministic 252611"];
2009 [label="currentLocalTime 252612"];
2010 [label="debugPlusMode 252613"];
2011 [label="xmlReferenceResolver 252614"];
2012 [label="sourceReferenceResolver 252615"];
2013 [label="syntaxTreeOptionsProvider 252616"];
2014 [label="metadataReferenceResolver 252617"];
2015 [label="assemblyIdentityComparer 252618"];
2016 [label="strongNameProvider 252619"];
2017 [label="metadataImportOptions 252620"];
2018 [label="referencesSupersedeLowerVersions 252621"];
2019 [label="param CSharpCompilationOptions(this) 252622"];
2020 [label="public bool AllowUnsafe { get; private set; } 252623"];
2021 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252624"];
2022 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252625"];
2023 [label="this.Usings = usings.AsImmutableOrEmpty(); 252626"];
2024 [label="this.Usings 252627"];
2025 [label="this.AllowUnsafe 252628"];
2026 [label="this.TopLevelBinderFlags 252629"];
2027 [label="this.NullableContextOptions 252630"];
2028 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 252631"];
2029 [label="OutputKind.NetModule 252632"];
2030 [label="OptimizationLevel.Release 252633"];
2031 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 252634"];
2032 [label="param CreateTestOptions(OutputKind outputKind) 252635"];
2033 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252636"];
2034 [label="param CreateTestOptions(bool allowUnsafe = false) 252637"];
2035 [label="outputKind 252638"];
2036 [label="optimizationLevel: optimizationLevel 252639"];
2037 [label="warningLevel: Diagnostic.MaxWarningLevel 252640"];
2038 [label="allowUnsafe: allowUnsafe 252641"];
2039 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252642"];
2040 [label="param CSharpCompilationOptions(OutputKind outputKind) 252643"];
2041 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252644"];
2042 [label="param CSharpCompilationOptions(string? moduleName = null) 252645"];
2043 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252646"];
2044 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252647"];
2045 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252648"];
2046 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252649"];
2047 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252650"];
2048 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252651"];
2049 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252652"];
2050 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252653"];
2051 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252654"];
2052 [label="param CSharpCompilationOptions(bool? delaySign = null) 252655"];
2053 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252656"];
2054 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252657"];
2055 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252658"];
2056 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252659"];
2057 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252660"];
2058 [label="param CSharpCompilationOptions(bool deterministic = false) 252661"];
2059 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252662"];
2060 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252663"];
2061 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252664"];
2062 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252665"];
2063 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252666"];
2064 [label="param CSharpCompilationOptions(bool publicSign = false) 252667"];
2065 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252668"];
2066 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252669"];
2067 [label="param CSharpCompilationOptions(this) 252670"];
2068 [label="outputKind 252671"];
2069 [label="reportSuppressedDiagnostics 252672"];
2070 [label="moduleName 252673"];
2071 [label="mainTypeName 252674"];
2072 [label="scriptClassName 252675"];
2073 [label="usings 252676"];
2074 [label="optimizationLevel 252677"];
2075 [label="checkOverflow 252678"];
2076 [label="allowUnsafe 252679"];
2077 [label="cryptoKeyContainer 252680"];
2078 [label="cryptoKeyFile 252681"];
2079 [label="cryptoPublicKey 252682"];
2080 [label="delaySign 252683"];
2081 [label="platform 252684"];
2082 [label="generalDiagnosticOption 252685"];
2083 [label="warningLevel 252686"];
2084 [label="specificDiagnosticOptions 252687"];
2085 [label="concurrentBuild 252688"];
2086 [label="deterministic 252689"];
2087 [label="default 252690"];
2088 [label="false 252691"];
2089 [label="xmlReferenceResolver 252692"];
2090 [label="sourceReferenceResolver 252693"];
2091 [label="null 252694"];
2092 [label="metadataReferenceResolver 252695"];
2093 [label="assemblyIdentityComparer 252696"];
2094 [label="strongNameProvider 252697"];
2095 [label="metadataImportOptions 252698"];
2096 [label="false 252699"];
2097 [label="publicSign 252700"];
2098 [label="BinderFlags.None 252701"];
2099 [label="nullableContextOptions 252702"];
2100 [label="param CSharpCompilationOptions(OutputKind outputKind) 252703"];
2101 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252704"];
2102 [label="param CSharpCompilationOptions(string? moduleName) 252705"];
2103 [label="param CSharpCompilationOptions(string? mainTypeName) 252706"];
2104 [label="param CSharpCompilationOptions(string? scriptClassName) 252707"];
2105 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252708"];
2106 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252709"];
2107 [label="param CSharpCompilationOptions(bool checkOverflow) 252710"];
2108 [label="param CSharpCompilationOptions(bool allowUnsafe) 252711"];
2109 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252712"];
2110 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252713"];
2111 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252714"];
2112 [label="param CSharpCompilationOptions(bool? delaySign) 252715"];
2113 [label="param CSharpCompilationOptions(Platform platform) 252716"];
2114 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252717"];
2115 [label="param CSharpCompilationOptions(int warningLevel) 252718"];
2116 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252719"];
2117 [label="param CSharpCompilationOptions(bool concurrentBuild) 252720"];
2118 [label="param CSharpCompilationOptions(bool deterministic) 252721"];
2119 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252722"];
2120 [label="param CSharpCompilationOptions(bool debugPlusMode) 252723"];
2121 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252724"];
2122 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252725"];
2123 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252726"];
2124 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252727"];
2125 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252728"];
2126 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252729"];
2127 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252730"];
2128 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252731"];
2129 [label="param CSharpCompilationOptions(bool publicSign) 252732"];
2130 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252733"];
2131 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252734"];
2132 [label="param CSharpCompilationOptions(this) 252735"];
2133 [label="outputKind 252736"];
2134 [label="reportSuppressedDiagnostics 252737"];
2135 [label="moduleName 252738"];
2136 [label="mainTypeName 252739"];
2137 [label="scriptClassName 252740"];
2138 [label="cryptoKeyContainer 252741"];
2139 [label="cryptoKeyFile 252742"];
2140 [label="cryptoPublicKey 252743"];
2141 [label="delaySign 252744"];
2142 [label="publicSign 252745"];
2143 [label="optimizationLevel 252746"];
2144 [label="checkOverflow 252747"];
2145 [label="platform 252748"];
2146 [label="generalDiagnosticOption 252749"];
2147 [label="warningLevel 252750"];
2148 [label="specificDiagnosticOptions 252751"];
2149 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252752"];
2150 [label="concurrentBuild 252753"];
2151 [label="deterministic 252754"];
2152 [label="currentLocalTime 252755"];
2153 [label="debugPlusMode 252756"];
2154 [label="xmlReferenceResolver 252757"];
2155 [label="sourceReferenceResolver 252758"];
2156 [label="syntaxTreeOptionsProvider 252759"];
2157 [label="metadataReferenceResolver 252760"];
2158 [label="assemblyIdentityComparer 252761"];
2159 [label="strongNameProvider 252762"];
2160 [label="metadataImportOptions 252763"];
2161 [label="referencesSupersedeLowerVersions 252764"];
2162 [label="param CSharpCompilationOptions(this) 252765"];
2163 [label="public bool AllowUnsafe { get; private set; } 252766"];
2164 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252767"];
2165 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252768"];
2166 [label="this.Usings = usings.AsImmutableOrEmpty(); 252769"];
2167 [label="this.Usings 252770"];
2168 [label="this.AllowUnsafe 252771"];
2169 [label="this.TopLevelBinderFlags 252772"];
2170 [label="this.NullableContextOptions 252773"];
2171 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 252774"];
2172 [label="OutputKind.NetModule 252775"];
2173 [label="OptimizationLevel.Debug 252776"];
2174 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 252777"];
2175 [label="param CreateTestOptions(OutputKind outputKind) 252778"];
2176 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 252779"];
2177 [label="param CreateTestOptions(bool allowUnsafe = false) 252780"];
2178 [label="outputKind 252781"];
2179 [label="optimizationLevel: optimizationLevel 252782"];
2180 [label="warningLevel: Diagnostic.MaxWarningLevel 252783"];
2181 [label="allowUnsafe: allowUnsafe 252784"];
2182 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 252785"];
2183 [label="param CSharpCompilationOptions(OutputKind outputKind) 252786"];
2184 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 252787"];
2185 [label="param CSharpCompilationOptions(string? moduleName = null) 252788"];
2186 [label="param CSharpCompilationOptions(string? mainTypeName = null) 252789"];
2187 [label="param CSharpCompilationOptions(string? scriptClassName = null) 252790"];
2188 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 252791"];
2189 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 252792"];
2190 [label="param CSharpCompilationOptions(bool checkOverflow = false) 252793"];
2191 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 252794"];
2192 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 252795"];
2193 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 252796"];
2194 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 252797"];
2195 [label="param CSharpCompilationOptions(bool? delaySign = null) 252798"];
2196 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 252799"];
2197 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 252800"];
2198 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 252801"];
2199 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 252802"];
2200 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 252803"];
2201 [label="param CSharpCompilationOptions(bool deterministic = false) 252804"];
2202 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 252805"];
2203 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 252806"];
2204 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 252807"];
2205 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 252808"];
2206 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 252809"];
2207 [label="param CSharpCompilationOptions(bool publicSign = false) 252810"];
2208 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 252811"];
2209 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 252812"];
2210 [label="param CSharpCompilationOptions(this) 252813"];
2211 [label="outputKind 252814"];
2212 [label="reportSuppressedDiagnostics 252815"];
2213 [label="moduleName 252816"];
2214 [label="mainTypeName 252817"];
2215 [label="scriptClassName 252818"];
2216 [label="usings 252819"];
2217 [label="optimizationLevel 252820"];
2218 [label="checkOverflow 252821"];
2219 [label="allowUnsafe 252822"];
2220 [label="cryptoKeyContainer 252823"];
2221 [label="cryptoKeyFile 252824"];
2222 [label="cryptoPublicKey 252825"];
2223 [label="delaySign 252826"];
2224 [label="platform 252827"];
2225 [label="generalDiagnosticOption 252828"];
2226 [label="warningLevel 252829"];
2227 [label="specificDiagnosticOptions 252830"];
2228 [label="concurrentBuild 252831"];
2229 [label="deterministic 252832"];
2230 [label="default 252833"];
2231 [label="false 252834"];
2232 [label="xmlReferenceResolver 252835"];
2233 [label="sourceReferenceResolver 252836"];
2234 [label="null 252837"];
2235 [label="metadataReferenceResolver 252838"];
2236 [label="assemblyIdentityComparer 252839"];
2237 [label="strongNameProvider 252840"];
2238 [label="metadataImportOptions 252841"];
2239 [label="false 252842"];
2240 [label="publicSign 252843"];
2241 [label="BinderFlags.None 252844"];
2242 [label="nullableContextOptions 252845"];
2243 [label="param CSharpCompilationOptions(OutputKind outputKind) 252846"];
2244 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 252847"];
2245 [label="param CSharpCompilationOptions(string? moduleName) 252848"];
2246 [label="param CSharpCompilationOptions(string? mainTypeName) 252849"];
2247 [label="param CSharpCompilationOptions(string? scriptClassName) 252850"];
2248 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 252851"];
2249 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 252852"];
2250 [label="param CSharpCompilationOptions(bool checkOverflow) 252853"];
2251 [label="param CSharpCompilationOptions(bool allowUnsafe) 252854"];
2252 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 252855"];
2253 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 252856"];
2254 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 252857"];
2255 [label="param CSharpCompilationOptions(bool? delaySign) 252858"];
2256 [label="param CSharpCompilationOptions(Platform platform) 252859"];
2257 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 252860"];
2258 [label="param CSharpCompilationOptions(int warningLevel) 252861"];
2259 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 252862"];
2260 [label="param CSharpCompilationOptions(bool concurrentBuild) 252863"];
2261 [label="param CSharpCompilationOptions(bool deterministic) 252864"];
2262 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 252865"];
2263 [label="param CSharpCompilationOptions(bool debugPlusMode) 252866"];
2264 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 252867"];
2265 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 252868"];
2266 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 252869"];
2267 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 252870"];
2268 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 252871"];
2269 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 252872"];
2270 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 252873"];
2271 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 252874"];
2272 [label="param CSharpCompilationOptions(bool publicSign) 252875"];
2273 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 252876"];
2274 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 252877"];
2275 [label="param CSharpCompilationOptions(this) 252878"];
2276 [label="outputKind 252879"];
2277 [label="reportSuppressedDiagnostics 252880"];
2278 [label="moduleName 252881"];
2279 [label="mainTypeName 252882"];
2280 [label="scriptClassName 252883"];
2281 [label="cryptoKeyContainer 252884"];
2282 [label="cryptoKeyFile 252885"];
2283 [label="cryptoPublicKey 252886"];
2284 [label="delaySign 252887"];
2285 [label="publicSign 252888"];
2286 [label="optimizationLevel 252889"];
2287 [label="checkOverflow 252890"];
2288 [label="platform 252891"];
2289 [label="generalDiagnosticOption 252892"];
2290 [label="warningLevel 252893"];
2291 [label="specificDiagnosticOptions 252894"];
2292 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 252895"];
2293 [label="concurrentBuild 252896"];
2294 [label="deterministic 252897"];
2295 [label="currentLocalTime 252898"];
2296 [label="debugPlusMode 252899"];
2297 [label="xmlReferenceResolver 252900"];
2298 [label="sourceReferenceResolver 252901"];
2299 [label="syntaxTreeOptionsProvider 252902"];
2300 [label="metadataReferenceResolver 252903"];
2301 [label="assemblyIdentityComparer 252904"];
2302 [label="strongNameProvider 252905"];
2303 [label="metadataImportOptions 252906"];
2304 [label="referencesSupersedeLowerVersions 252907"];
2305 [label="param CSharpCompilationOptions(this) 252908"];
2306 [label="public bool AllowUnsafe { get; private set; } 252909"];
2307 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252910"];
2308 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252911"];
2309 [label="this.Usings = usings.AsImmutableOrEmpty(); 252912"];
2310 [label="this.Usings 252913"];
2311 [label="this.AllowUnsafe 252914"];
2312 [label="this.TopLevelBinderFlags 252915"];
2313 [label="this.NullableContextOptions 252916"];
2314 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 252917"];
2315 [label="true 252918"];
2316 [label="ReleaseDll.WithAllowUnsafe(true) 252919"];
2317 [label="param WithAllowUnsafe(bool enabled) 252920"];
2318 [label="param WithAllowUnsafe(this) 252921"];
2319 [label="if (enabled == this.AllowUnsafe)\n            {\n                return this;\n            } 252922"];
2320 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 252923"];
2321 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 252924"];
2322 [label="new CSharpCompilationOptions(this) { AllowUnsafe = enabled } 252925"];
2323 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 252926"];
2324 [label="param CSharpCompilationOptions(this) 252927"];
2325 [label="other.OutputKind 252928"];
2326 [label="other.ModuleName 252929"];
2327 [label="other.MainTypeName 252930"];
2328 [label="other.ScriptClassName 252931"];
2329 [label="other.Usings 252932"];
2330 [label="other.OptimizationLevel 252933"];
2331 [label="other.CheckOverflow 252934"];
2332 [label="other.AllowUnsafe 252935"];
2333 [label="other.CryptoKeyContainer 252936"];
2334 [label="other.CryptoKeyFile 252937"];
2335 [label="other.CryptoPublicKey 252938"];
2336 [label="other.DelaySign 252939"];
2337 [label="other.Platform 252940"];
2338 [label="other.GeneralDiagnosticOption 252941"];
2339 [label="other.WarningLevel 252942"];
2340 [label="other.SpecificDiagnosticOptions 252943"];
2341 [label="other.ConcurrentBuild 252944"];
2342 [label="other.Deterministic 252945"];
2343 [label="other.CurrentLocalTime 252946"];
2344 [label="other.DebugPlusMode 252947"];
2345 [label="other.XmlReferenceResolver 252948"];
2346 [label="other.SourceReferenceResolver 252949"];
2347 [label="other.SyntaxTreeOptionsProvider 252950"];
2348 [label="other.MetadataReferenceResolver 252951"];
2349 [label="other.AssemblyIdentityComparer 252952"];
2350 [label="other.StrongNameProvider 252953"];
2351 [label="other.MetadataImportOptions 252954"];
2352 [label="other.ReferencesSupersedeLowerVersions 252955"];
2353 [label="other.ReportSuppressedDiagnostics 252956"];
2354 [label="other.PublicSign 252957"];
2355 [label="other.TopLevelBinderFlags 252958"];
2356 [label="other.NullableContextOptions 252959"];
2357 [label="param CSharpCompilationOptions(this) 252960"];
2358 [label="param CSharpCompilationOptions(this) 252961"];
2359 [label="param CSharpCompilationOptions(this) 252962"];
2360 [label="param CSharpCompilationOptions(this) 252963"];
2361 [label="public bool AllowUnsafe { get; private set; } 252964"];
2362 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 252965"];
2363 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 252966"];
2364 [label="AllowUnsafe 252967"];
2365 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 252968"];
2366 [label="true 252969"];
2367 [label="ReleaseExe.WithAllowUnsafe(true) 252970"];
2368 [label="param WithAllowUnsafe(bool enabled) 252971"];
2369 [label="param WithAllowUnsafe(this) 252972"];
2370 [label="if (enabled == this.AllowUnsafe)\n            {\n                return this;\n            } 252973"];
2371 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 252974"];
2372 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 252975"];
2373 [label="new CSharpCompilationOptions(this) { AllowUnsafe = enabled } 252976"];
2374 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 252977"];
2375 [label="param CSharpCompilationOptions(this) 252978"];
2376 [label="other.OutputKind 252979"];
2377 [label="other.ModuleName 252980"];
2378 [label="other.MainTypeName 252981"];
2379 [label="other.ScriptClassName 252982"];
2380 [label="other.Usings 252983"];
2381 [label="other.OptimizationLevel 252984"];
2382 [label="other.CheckOverflow 252985"];
2383 [label="other.AllowUnsafe 252986"];
2384 [label="other.CryptoKeyContainer 252987"];
2385 [label="other.CryptoKeyFile 252988"];
2386 [label="other.CryptoPublicKey 252989"];
2387 [label="other.DelaySign 252990"];
2388 [label="other.Platform 252991"];
2389 [label="other.GeneralDiagnosticOption 252992"];
2390 [label="other.WarningLevel 252993"];
2391 [label="other.SpecificDiagnosticOptions 252994"];
2392 [label="other.ConcurrentBuild 252995"];
2393 [label="other.Deterministic 252996"];
2394 [label="other.CurrentLocalTime 252997"];
2395 [label="other.DebugPlusMode 252998"];
2396 [label="other.XmlReferenceResolver 252999"];
2397 [label="other.SourceReferenceResolver 253000"];
2398 [label="other.SyntaxTreeOptionsProvider 253001"];
2399 [label="other.MetadataReferenceResolver 253002"];
2400 [label="other.AssemblyIdentityComparer 253003"];
2401 [label="other.StrongNameProvider 253004"];
2402 [label="other.MetadataImportOptions 253005"];
2403 [label="other.ReferencesSupersedeLowerVersions 253006"];
2404 [label="other.ReportSuppressedDiagnostics 253007"];
2405 [label="other.PublicSign 253008"];
2406 [label="other.TopLevelBinderFlags 253009"];
2407 [label="other.NullableContextOptions 253010"];
2408 [label="param CSharpCompilationOptions(this) 253011"];
2409 [label="param CSharpCompilationOptions(this) 253012"];
2410 [label="param CSharpCompilationOptions(this) 253013"];
2411 [label="param CSharpCompilationOptions(this) 253014"];
2412 [label="public bool AllowUnsafe { get; private set; } 253015"];
2413 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253016"];
2414 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253017"];
2415 [label="AllowUnsafe 253018"];
2416 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 253019"];
2417 [label="true 253020"];
2418 [label="DebugDll.WithAllowUnsafe(true) 253021"];
2419 [label="param WithAllowUnsafe(bool enabled) 253022"];
2420 [label="param WithAllowUnsafe(this) 253023"];
2421 [label="if (enabled == this.AllowUnsafe)\n            {\n                return this;\n            } 253024"];
2422 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 253025"];
2423 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 253026"];
2424 [label="new CSharpCompilationOptions(this) { AllowUnsafe = enabled } 253027"];
2425 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253028"];
2426 [label="param CSharpCompilationOptions(this) 253029"];
2427 [label="other.OutputKind 253030"];
2428 [label="other.ModuleName 253031"];
2429 [label="other.MainTypeName 253032"];
2430 [label="other.ScriptClassName 253033"];
2431 [label="other.Usings 253034"];
2432 [label="other.OptimizationLevel 253035"];
2433 [label="other.CheckOverflow 253036"];
2434 [label="other.AllowUnsafe 253037"];
2435 [label="other.CryptoKeyContainer 253038"];
2436 [label="other.CryptoKeyFile 253039"];
2437 [label="other.CryptoPublicKey 253040"];
2438 [label="other.DelaySign 253041"];
2439 [label="other.Platform 253042"];
2440 [label="other.GeneralDiagnosticOption 253043"];
2441 [label="other.WarningLevel 253044"];
2442 [label="other.SpecificDiagnosticOptions 253045"];
2443 [label="other.ConcurrentBuild 253046"];
2444 [label="other.Deterministic 253047"];
2445 [label="other.CurrentLocalTime 253048"];
2446 [label="other.DebugPlusMode 253049"];
2447 [label="other.XmlReferenceResolver 253050"];
2448 [label="other.SourceReferenceResolver 253051"];
2449 [label="other.SyntaxTreeOptionsProvider 253052"];
2450 [label="other.MetadataReferenceResolver 253053"];
2451 [label="other.AssemblyIdentityComparer 253054"];
2452 [label="other.StrongNameProvider 253055"];
2453 [label="other.MetadataImportOptions 253056"];
2454 [label="other.ReferencesSupersedeLowerVersions 253057"];
2455 [label="other.ReportSuppressedDiagnostics 253058"];
2456 [label="other.PublicSign 253059"];
2457 [label="other.TopLevelBinderFlags 253060"];
2458 [label="other.NullableContextOptions 253061"];
2459 [label="param CSharpCompilationOptions(this) 253062"];
2460 [label="param CSharpCompilationOptions(OutputKind outputKind) 253063"];
2461 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 253064"];
2462 [label="param CSharpCompilationOptions(string? moduleName) 253065"];
2463 [label="param CSharpCompilationOptions(string? mainTypeName) 253066"];
2464 [label="param CSharpCompilationOptions(string? scriptClassName) 253067"];
2465 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 253068"];
2466 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 253069"];
2467 [label="param CSharpCompilationOptions(bool checkOverflow) 253070"];
2468 [label="param CSharpCompilationOptions(bool allowUnsafe) 253071"];
2469 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 253072"];
2470 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 253073"];
2471 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 253074"];
2472 [label="param CSharpCompilationOptions(bool? delaySign) 253075"];
2473 [label="param CSharpCompilationOptions(Platform platform) 253076"];
2474 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 253077"];
2475 [label="param CSharpCompilationOptions(int warningLevel) 253078"];
2476 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 253079"];
2477 [label="param CSharpCompilationOptions(bool concurrentBuild) 253080"];
2478 [label="param CSharpCompilationOptions(bool deterministic) 253081"];
2479 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 253082"];
2480 [label="param CSharpCompilationOptions(bool debugPlusMode) 253083"];
2481 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 253084"];
2482 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 253085"];
2483 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 253086"];
2484 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 253087"];
2485 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 253088"];
2486 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 253089"];
2487 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 253090"];
2488 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 253091"];
2489 [label="param CSharpCompilationOptions(bool publicSign) 253092"];
2490 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 253093"];
2491 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 253094"];
2492 [label="param CSharpCompilationOptions(this) 253095"];
2493 [label="param CSharpCompilationOptions(this) 253096"];
2494 [label="param CSharpCompilationOptions(this) 253097"];
2495 [label="public bool AllowUnsafe { get; private set; } 253098"];
2496 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253099"];
2497 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253100"];
2498 [label="this.Usings = usings.AsImmutableOrEmpty(); 253101"];
2499 [label="this.Usings 253102"];
2500 [label="this.AllowUnsafe 253103"];
2501 [label="AllowUnsafe 253104"];
2502 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 253105"];
2503 [label="true 253106"];
2504 [label="DebugExe.WithAllowUnsafe(true) 253107"];
2505 [label="param WithAllowUnsafe(bool enabled) 253108"];
2506 [label="param WithAllowUnsafe(this) 253109"];
2507 [label="if (enabled == this.AllowUnsafe)\n            {\n                return this;\n            } 253110"];
2508 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 253111"];
2509 [label="return new CSharpCompilationOptions(this) { AllowUnsafe = enabled }; 253112"];
2510 [label="new CSharpCompilationOptions(this) { AllowUnsafe = enabled } 253113"];
2511 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253114"];
2512 [label="param CSharpCompilationOptions(this) 253115"];
2513 [label="other.OutputKind 253116"];
2514 [label="other.ModuleName 253117"];
2515 [label="other.MainTypeName 253118"];
2516 [label="other.ScriptClassName 253119"];
2517 [label="other.Usings 253120"];
2518 [label="other.OptimizationLevel 253121"];
2519 [label="other.CheckOverflow 253122"];
2520 [label="other.AllowUnsafe 253123"];
2521 [label="other.CryptoKeyContainer 253124"];
2522 [label="other.CryptoKeyFile 253125"];
2523 [label="other.CryptoPublicKey 253126"];
2524 [label="other.DelaySign 253127"];
2525 [label="other.Platform 253128"];
2526 [label="other.GeneralDiagnosticOption 253129"];
2527 [label="other.WarningLevel 253130"];
2528 [label="other.SpecificDiagnosticOptions 253131"];
2529 [label="other.ConcurrentBuild 253132"];
2530 [label="other.Deterministic 253133"];
2531 [label="other.CurrentLocalTime 253134"];
2532 [label="other.DebugPlusMode 253135"];
2533 [label="other.XmlReferenceResolver 253136"];
2534 [label="other.SourceReferenceResolver 253137"];
2535 [label="other.SyntaxTreeOptionsProvider 253138"];
2536 [label="other.MetadataReferenceResolver 253139"];
2537 [label="other.AssemblyIdentityComparer 253140"];
2538 [label="other.StrongNameProvider 253141"];
2539 [label="other.MetadataImportOptions 253142"];
2540 [label="other.ReferencesSupersedeLowerVersions 253143"];
2541 [label="other.ReportSuppressedDiagnostics 253144"];
2542 [label="other.PublicSign 253145"];
2543 [label="other.TopLevelBinderFlags 253146"];
2544 [label="other.NullableContextOptions 253147"];
2545 [label="param CSharpCompilationOptions(this) 253148"];
2546 [label="param CSharpCompilationOptions(OutputKind outputKind) 253149"];
2547 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 253150"];
2548 [label="param CSharpCompilationOptions(string? moduleName) 253151"];
2549 [label="param CSharpCompilationOptions(string? mainTypeName) 253152"];
2550 [label="param CSharpCompilationOptions(string? scriptClassName) 253153"];
2551 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 253154"];
2552 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 253155"];
2553 [label="param CSharpCompilationOptions(bool checkOverflow) 253156"];
2554 [label="param CSharpCompilationOptions(bool allowUnsafe) 253157"];
2555 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 253158"];
2556 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 253159"];
2557 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 253160"];
2558 [label="param CSharpCompilationOptions(bool? delaySign) 253161"];
2559 [label="param CSharpCompilationOptions(Platform platform) 253162"];
2560 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 253163"];
2561 [label="param CSharpCompilationOptions(int warningLevel) 253164"];
2562 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 253165"];
2563 [label="param CSharpCompilationOptions(bool concurrentBuild) 253166"];
2564 [label="param CSharpCompilationOptions(bool deterministic) 253167"];
2565 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 253168"];
2566 [label="param CSharpCompilationOptions(bool debugPlusMode) 253169"];
2567 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 253170"];
2568 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 253171"];
2569 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 253172"];
2570 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 253173"];
2571 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 253174"];
2572 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 253175"];
2573 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 253176"];
2574 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 253177"];
2575 [label="param CSharpCompilationOptions(bool publicSign) 253178"];
2576 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 253179"];
2577 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 253180"];
2578 [label="param CSharpCompilationOptions(this) 253181"];
2579 [label="param CSharpCompilationOptions(this) 253182"];
2580 [label="param CSharpCompilationOptions(this) 253183"];
2581 [label="public bool AllowUnsafe { get; private set; } 253184"];
2582 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253185"];
2583 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253186"];
2584 [label="this.Usings = usings.AsImmutableOrEmpty(); 253187"];
2585 [label="this.Usings 253188"];
2586 [label="this.AllowUnsafe 253189"];
2587 [label="AllowUnsafe 253190"];
2588 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 253191"];
2589 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 253192"];
2590 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253193"];
2591 [label="param WithStrongNameProvider(StrongNameProvider? provider) 253194"];
2592 [label="param WithStrongNameProvider(this) 253195"];
2593 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253196"];
2594 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253197"];
2595 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253198"];
2596 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253199"];
2597 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253200"];
2598 [label="new CSharpCompilationOptions(this) { StrongNameProvider = provider } 253201"];
2599 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253202"];
2600 [label="param CSharpCompilationOptions(this) 253203"];
2601 [label="other.OutputKind 253204"];
2602 [label="other.ModuleName 253205"];
2603 [label="other.MainTypeName 253206"];
2604 [label="other.ScriptClassName 253207"];
2605 [label="other.Usings 253208"];
2606 [label="other.OptimizationLevel 253209"];
2607 [label="other.CheckOverflow 253210"];
2608 [label="other.AllowUnsafe 253211"];
2609 [label="other.CryptoKeyContainer 253212"];
2610 [label="other.CryptoKeyFile 253213"];
2611 [label="other.CryptoPublicKey 253214"];
2612 [label="other.DelaySign 253215"];
2613 [label="other.Platform 253216"];
2614 [label="other.GeneralDiagnosticOption 253217"];
2615 [label="other.WarningLevel 253218"];
2616 [label="other.SpecificDiagnosticOptions 253219"];
2617 [label="other.ConcurrentBuild 253220"];
2618 [label="other.Deterministic 253221"];
2619 [label="other.CurrentLocalTime 253222"];
2620 [label="other.DebugPlusMode 253223"];
2621 [label="other.XmlReferenceResolver 253224"];
2622 [label="other.SourceReferenceResolver 253225"];
2623 [label="other.SyntaxTreeOptionsProvider 253226"];
2624 [label="other.MetadataReferenceResolver 253227"];
2625 [label="other.AssemblyIdentityComparer 253228"];
2626 [label="other.StrongNameProvider 253229"];
2627 [label="other.MetadataImportOptions 253230"];
2628 [label="other.ReferencesSupersedeLowerVersions 253231"];
2629 [label="other.ReportSuppressedDiagnostics 253232"];
2630 [label="other.PublicSign 253233"];
2631 [label="other.TopLevelBinderFlags 253234"];
2632 [label="other.NullableContextOptions 253235"];
2633 [label="param CSharpCompilationOptions(this) 253236"];
2634 [label="param CSharpCompilationOptions(this) 253237"];
2635 [label="param CSharpCompilationOptions(this) 253238"];
2636 [label="public bool AllowUnsafe { get; private set; } 253239"];
2637 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253240"];
2638 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253241"];
2639 [label="StrongNameProvider 253242"];
2640 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253243"];
2641 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 253244"];
2642 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253245"];
2643 [label="param WithStrongNameProvider(StrongNameProvider? provider) 253246"];
2644 [label="param WithStrongNameProvider(this) 253247"];
2645 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253248"];
2646 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253249"];
2647 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253250"];
2648 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253251"];
2649 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253252"];
2650 [label="new CSharpCompilationOptions(this) { StrongNameProvider = provider } 253253"];
2651 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253254"];
2652 [label="param CSharpCompilationOptions(this) 253255"];
2653 [label="other.OutputKind 253256"];
2654 [label="other.ModuleName 253257"];
2655 [label="other.MainTypeName 253258"];
2656 [label="other.ScriptClassName 253259"];
2657 [label="other.Usings 253260"];
2658 [label="other.OptimizationLevel 253261"];
2659 [label="other.CheckOverflow 253262"];
2660 [label="other.AllowUnsafe 253263"];
2661 [label="other.CryptoKeyContainer 253264"];
2662 [label="other.CryptoKeyFile 253265"];
2663 [label="other.CryptoPublicKey 253266"];
2664 [label="other.DelaySign 253267"];
2665 [label="other.Platform 253268"];
2666 [label="other.GeneralDiagnosticOption 253269"];
2667 [label="other.WarningLevel 253270"];
2668 [label="other.SpecificDiagnosticOptions 253271"];
2669 [label="other.ConcurrentBuild 253272"];
2670 [label="other.Deterministic 253273"];
2671 [label="other.CurrentLocalTime 253274"];
2672 [label="other.DebugPlusMode 253275"];
2673 [label="other.XmlReferenceResolver 253276"];
2674 [label="other.SourceReferenceResolver 253277"];
2675 [label="other.SyntaxTreeOptionsProvider 253278"];
2676 [label="other.MetadataReferenceResolver 253279"];
2677 [label="other.AssemblyIdentityComparer 253280"];
2678 [label="other.StrongNameProvider 253281"];
2679 [label="other.MetadataImportOptions 253282"];
2680 [label="other.ReferencesSupersedeLowerVersions 253283"];
2681 [label="other.ReportSuppressedDiagnostics 253284"];
2682 [label="other.PublicSign 253285"];
2683 [label="other.TopLevelBinderFlags 253286"];
2684 [label="other.NullableContextOptions 253287"];
2685 [label="param CSharpCompilationOptions(this) 253288"];
2686 [label="param CSharpCompilationOptions(this) 253289"];
2687 [label="param CSharpCompilationOptions(this) 253290"];
2688 [label="public bool AllowUnsafe { get; private set; } 253291"];
2689 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253292"];
2690 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253293"];
2691 [label="StrongNameProvider 253294"];
2692 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253295"];
2693 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 253296"];
2694 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253297"];
2695 [label="param WithStrongNameProvider(StrongNameProvider? provider) 253298"];
2696 [label="param WithStrongNameProvider(this) 253299"];
2697 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253300"];
2698 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253301"];
2699 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253302"];
2700 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253303"];
2701 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253304"];
2702 [label="new CSharpCompilationOptions(this) { StrongNameProvider = provider } 253305"];
2703 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253306"];
2704 [label="param CSharpCompilationOptions(this) 253307"];
2705 [label="other.OutputKind 253308"];
2706 [label="other.ModuleName 253309"];
2707 [label="other.MainTypeName 253310"];
2708 [label="other.ScriptClassName 253311"];
2709 [label="other.Usings 253312"];
2710 [label="other.OptimizationLevel 253313"];
2711 [label="other.CheckOverflow 253314"];
2712 [label="other.AllowUnsafe 253315"];
2713 [label="other.CryptoKeyContainer 253316"];
2714 [label="other.CryptoKeyFile 253317"];
2715 [label="other.CryptoPublicKey 253318"];
2716 [label="other.DelaySign 253319"];
2717 [label="other.Platform 253320"];
2718 [label="other.GeneralDiagnosticOption 253321"];
2719 [label="other.WarningLevel 253322"];
2720 [label="other.SpecificDiagnosticOptions 253323"];
2721 [label="other.ConcurrentBuild 253324"];
2722 [label="other.Deterministic 253325"];
2723 [label="other.CurrentLocalTime 253326"];
2724 [label="other.DebugPlusMode 253327"];
2725 [label="other.XmlReferenceResolver 253328"];
2726 [label="other.SourceReferenceResolver 253329"];
2727 [label="other.SyntaxTreeOptionsProvider 253330"];
2728 [label="other.MetadataReferenceResolver 253331"];
2729 [label="other.AssemblyIdentityComparer 253332"];
2730 [label="other.StrongNameProvider 253333"];
2731 [label="other.MetadataImportOptions 253334"];
2732 [label="other.ReferencesSupersedeLowerVersions 253335"];
2733 [label="other.ReportSuppressedDiagnostics 253336"];
2734 [label="other.PublicSign 253337"];
2735 [label="other.TopLevelBinderFlags 253338"];
2736 [label="other.NullableContextOptions 253339"];
2737 [label="param CSharpCompilationOptions(this) 253340"];
2738 [label="param CSharpCompilationOptions(OutputKind outputKind) 253341"];
2739 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 253342"];
2740 [label="param CSharpCompilationOptions(string? moduleName) 253343"];
2741 [label="param CSharpCompilationOptions(string? mainTypeName) 253344"];
2742 [label="param CSharpCompilationOptions(string? scriptClassName) 253345"];
2743 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 253346"];
2744 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 253347"];
2745 [label="param CSharpCompilationOptions(bool checkOverflow) 253348"];
2746 [label="param CSharpCompilationOptions(bool allowUnsafe) 253349"];
2747 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 253350"];
2748 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 253351"];
2749 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 253352"];
2750 [label="param CSharpCompilationOptions(bool? delaySign) 253353"];
2751 [label="param CSharpCompilationOptions(Platform platform) 253354"];
2752 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 253355"];
2753 [label="param CSharpCompilationOptions(int warningLevel) 253356"];
2754 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 253357"];
2755 [label="param CSharpCompilationOptions(bool concurrentBuild) 253358"];
2756 [label="param CSharpCompilationOptions(bool deterministic) 253359"];
2757 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 253360"];
2758 [label="param CSharpCompilationOptions(bool debugPlusMode) 253361"];
2759 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 253362"];
2760 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 253363"];
2761 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 253364"];
2762 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 253365"];
2763 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 253366"];
2764 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 253367"];
2765 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 253368"];
2766 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 253369"];
2767 [label="param CSharpCompilationOptions(bool publicSign) 253370"];
2768 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 253371"];
2769 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 253372"];
2770 [label="param CSharpCompilationOptions(this) 253373"];
2771 [label="param CSharpCompilationOptions(this) 253374"];
2772 [label="param CSharpCompilationOptions(this) 253375"];
2773 [label="public bool AllowUnsafe { get; private set; } 253376"];
2774 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253377"];
2775 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253378"];
2776 [label="this.Usings = usings.AsImmutableOrEmpty(); 253379"];
2777 [label="this.Usings 253380"];
2778 [label="this.AllowUnsafe 253381"];
2779 [label="StrongNameProvider 253382"];
2780 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253383"];
2781 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 253384"];
2782 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253385"];
2783 [label="param WithStrongNameProvider(StrongNameProvider? provider) 253386"];
2784 [label="param WithStrongNameProvider(this) 253387"];
2785 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253388"];
2786 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253389"];
2787 [label="if (ReferenceEquals(provider, this.StrongNameProvider))\n            {\n                return this;\n            } 253390"];
2788 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253391"];
2789 [label="return new CSharpCompilationOptions(this) { StrongNameProvider = provider }; 253392"];
2790 [label="new CSharpCompilationOptions(this) { StrongNameProvider = provider } 253393"];
2791 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 253394"];
2792 [label="param CSharpCompilationOptions(this) 253395"];
2793 [label="other.OutputKind 253396"];
2794 [label="other.ModuleName 253397"];
2795 [label="other.MainTypeName 253398"];
2796 [label="other.ScriptClassName 253399"];
2797 [label="other.Usings 253400"];
2798 [label="other.OptimizationLevel 253401"];
2799 [label="other.CheckOverflow 253402"];
2800 [label="other.AllowUnsafe 253403"];
2801 [label="other.CryptoKeyContainer 253404"];
2802 [label="other.CryptoKeyFile 253405"];
2803 [label="other.CryptoPublicKey 253406"];
2804 [label="other.DelaySign 253407"];
2805 [label="other.Platform 253408"];
2806 [label="other.GeneralDiagnosticOption 253409"];
2807 [label="other.WarningLevel 253410"];
2808 [label="other.SpecificDiagnosticOptions 253411"];
2809 [label="other.ConcurrentBuild 253412"];
2810 [label="other.Deterministic 253413"];
2811 [label="other.CurrentLocalTime 253414"];
2812 [label="other.DebugPlusMode 253415"];
2813 [label="other.XmlReferenceResolver 253416"];
2814 [label="other.SourceReferenceResolver 253417"];
2815 [label="other.SyntaxTreeOptionsProvider 253418"];
2816 [label="other.MetadataReferenceResolver 253419"];
2817 [label="other.AssemblyIdentityComparer 253420"];
2818 [label="other.StrongNameProvider 253421"];
2819 [label="other.MetadataImportOptions 253422"];
2820 [label="other.ReferencesSupersedeLowerVersions 253423"];
2821 [label="other.ReportSuppressedDiagnostics 253424"];
2822 [label="other.PublicSign 253425"];
2823 [label="other.TopLevelBinderFlags 253426"];
2824 [label="other.NullableContextOptions 253427"];
2825 [label="param CSharpCompilationOptions(this) 253428"];
2826 [label="param CSharpCompilationOptions(this) 253429"];
2827 [label="param CSharpCompilationOptions(this) 253430"];
2828 [label="param CSharpCompilationOptions(this) 253431"];
2829 [label="public bool AllowUnsafe { get; private set; } 253432"];
2830 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 253433"];
2831 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 253434"];
2832 [label="StrongNameProvider 253435"];
2833 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 253436"];
2834 [label="DebugInformationFormat.Pdb 253437"];
2835 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 253438"];
2836 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 253439"];
2837 [label="options = TestOptions.Regular; 253440"];
2838 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 253441"];
2839 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 253442"];
2840 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 253443"];
2841 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 253444"];
2842 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 253445"];
2843 [label="'\\r\\n' 253446"];
2844 [label="CrLf = '\\r\\n' 253447"];
2845 [label="CrLf 253448"];
2846 [label="EndOfLine(CrLf) 253449"];
2847 [label="param EndOfLine(string text) 253450"];
2848 [label="param EndOfLine(bool elastic = false) 253451"];
2849 [label="SyntaxTrivia trivia = null; 253452"];
2850 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253453"];
2851 [label="elastic 253454"];
2852 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 253455"];
2853 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253456"];
2854 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253457"];
2855 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 253458"];
2856 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253459"];
2857 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253460"];
2858 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253461"];
2859 [label="param Create(SyntaxKind kind) 253462"];
2860 [label="param Create(string text) 253463"];
2861 [label="return new SyntaxTrivia(kind, text); 253464"];
2862 [label="return new SyntaxTrivia(kind, text); 253465"];
2863 [label="return new SyntaxTrivia(kind, text); 253466"];
2864 [label="new SyntaxTrivia(kind, text) 253467"];
2865 [label="param SyntaxTrivia(SyntaxKind kind) 253468"];
2866 [label="param SyntaxTrivia(string text) 253469"];
2867 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253470"];
2868 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253471"];
2869 [label="param SyntaxTrivia(this) 253472"];
2870 [label="kind 253473"];
2871 [label="diagnostics 253474"];
2872 [label="annotations 253475"];
2873 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 253476"];
2874 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 253477"];
2875 [label="text 253478"];
2876 [label="param SyntaxTrivia(this) 253479"];
2877 [label="param CSharpSyntaxNode(SyntaxKind kind) 253480"];
2878 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253481"];
2879 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253482"];
2880 [label="param CSharpSyntaxNode(int fullWidth) 253483"];
2881 [label="param CSharpSyntaxNode(this) 253484"];
2882 [label="kind 253485"];
2883 [label="diagnostics 253486"];
2884 [label="annotations 253487"];
2885 [label="fullWidth 253488"];
2886 [label="param CSharpSyntaxNode(this) 253489"];
2887 [label="param CSharpSyntaxNode(this) 253490"];
2888 [label="GreenStats.NoteGreen(this); 253491"];
2889 [label="GreenStats.NoteGreen(this); 253492"];
2890 [label="Text 253493"];
2891 [label="this.Text 253494"];
2892 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253495"];
2893 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253496"];
2894 [label="if (!elastic)\n            {\n                return trivia;\n            } 253497"];
2895 [label="return trivia; 253498"];
2896 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 253499"];
2897 [label="'\\n' 253500"];
2898 [label="EndOfLine('\\n') 253501"];
2899 [label="param EndOfLine(string text) 253502"];
2900 [label="param EndOfLine(bool elastic = false) 253503"];
2901 [label="SyntaxTrivia trivia = null; 253504"];
2902 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253505"];
2903 [label="elastic 253506"];
2904 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 253507"];
2905 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253508"];
2906 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253509"];
2907 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253510"];
2908 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253511"];
2909 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253512"];
2910 [label="param Create(SyntaxKind kind) 253513"];
2911 [label="param Create(string text) 253514"];
2912 [label="return new SyntaxTrivia(kind, text); 253515"];
2913 [label="return new SyntaxTrivia(kind, text); 253516"];
2914 [label="return new SyntaxTrivia(kind, text); 253517"];
2915 [label="new SyntaxTrivia(kind, text) 253518"];
2916 [label="param SyntaxTrivia(SyntaxKind kind) 253519"];
2917 [label="param SyntaxTrivia(string text) 253520"];
2918 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253521"];
2919 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253522"];
2920 [label="param SyntaxTrivia(this) 253523"];
2921 [label="kind 253524"];
2922 [label="diagnostics 253525"];
2923 [label="annotations 253526"];
2924 [label="text 253527"];
2925 [label="param SyntaxTrivia(this) 253528"];
2926 [label="param CSharpSyntaxNode(SyntaxKind kind) 253529"];
2927 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253530"];
2928 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253531"];
2929 [label="param CSharpSyntaxNode(int fullWidth) 253532"];
2930 [label="param CSharpSyntaxNode(this) 253533"];
2931 [label="kind 253534"];
2932 [label="diagnostics 253535"];
2933 [label="annotations 253536"];
2934 [label="fullWidth 253537"];
2935 [label="param CSharpSyntaxNode(this) 253538"];
2936 [label="param CSharpSyntaxNode(this) 253539"];
2937 [label="GreenStats.NoteGreen(this); 253540"];
2938 [label="GreenStats.NoteGreen(this); 253541"];
2939 [label="Text 253542"];
2940 [label="this.Text 253543"];
2941 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253544"];
2942 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253545"];
2943 [label="if (!elastic)\n            {\n                return trivia;\n            } 253546"];
2944 [label="return trivia; 253547"];
2945 [label="LineFeed = EndOfLine('\\n') 253548"];
2946 [label="'\\r' 253549"];
2947 [label="EndOfLine('\\r') 253550"];
2948 [label="param EndOfLine(string text) 253551"];
2949 [label="param EndOfLine(bool elastic = false) 253552"];
2950 [label="SyntaxTrivia trivia = null; 253553"];
2951 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253554"];
2952 [label="elastic 253555"];
2953 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 253556"];
2954 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253557"];
2955 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253558"];
2956 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253559"];
2957 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253560"];
2958 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253561"];
2959 [label="param Create(SyntaxKind kind) 253562"];
2960 [label="param Create(string text) 253563"];
2961 [label="return new SyntaxTrivia(kind, text); 253564"];
2962 [label="return new SyntaxTrivia(kind, text); 253565"];
2963 [label="return new SyntaxTrivia(kind, text); 253566"];
2964 [label="new SyntaxTrivia(kind, text) 253567"];
2965 [label="param SyntaxTrivia(SyntaxKind kind) 253568"];
2966 [label="param SyntaxTrivia(string text) 253569"];
2967 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253570"];
2968 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253571"];
2969 [label="param SyntaxTrivia(this) 253572"];
2970 [label="kind 253573"];
2971 [label="diagnostics 253574"];
2972 [label="annotations 253575"];
2973 [label="text 253576"];
2974 [label="param SyntaxTrivia(this) 253577"];
2975 [label="param CSharpSyntaxNode(SyntaxKind kind) 253578"];
2976 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253579"];
2977 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253580"];
2978 [label="param CSharpSyntaxNode(int fullWidth) 253581"];
2979 [label="param CSharpSyntaxNode(this) 253582"];
2980 [label="kind 253583"];
2981 [label="diagnostics 253584"];
2982 [label="annotations 253585"];
2983 [label="fullWidth 253586"];
2984 [label="param CSharpSyntaxNode(this) 253587"];
2985 [label="param CSharpSyntaxNode(this) 253588"];
2986 [label="GreenStats.NoteGreen(this); 253589"];
2987 [label="GreenStats.NoteGreen(this); 253590"];
2988 [label="Text 253591"];
2989 [label="this.Text 253592"];
2990 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253593"];
2991 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253594"];
2992 [label="if (!elastic)\n            {\n                return trivia;\n            } 253595"];
2993 [label="return trivia; 253596"];
2994 [label="CarriageReturn = EndOfLine('\\r') 253597"];
2995 [label="' ' 253598"];
2996 [label="Whitespace(' ') 253599"];
2997 [label="param Whitespace(string text) 253600"];
2998 [label="param Whitespace(bool elastic = false) 253601"];
2999 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253602"];
3000 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253603"];
3001 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 253604"];
3002 [label="param Create(SyntaxKind kind) 253605"];
3003 [label="param Create(string text) 253606"];
3004 [label="return new SyntaxTrivia(kind, text); 253607"];
3005 [label="return new SyntaxTrivia(kind, text); 253608"];
3006 [label="return new SyntaxTrivia(kind, text); 253609"];
3007 [label="new SyntaxTrivia(kind, text) 253610"];
3008 [label="param SyntaxTrivia(SyntaxKind kind) 253611"];
3009 [label="param SyntaxTrivia(string text) 253612"];
3010 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253613"];
3011 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253614"];
3012 [label="param SyntaxTrivia(this) 253615"];
3013 [label="kind 253616"];
3014 [label="diagnostics 253617"];
3015 [label="annotations 253618"];
3016 [label="text 253619"];
3017 [label="param SyntaxTrivia(this) 253620"];
3018 [label="param CSharpSyntaxNode(SyntaxKind kind) 253621"];
3019 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253622"];
3020 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253623"];
3021 [label="param CSharpSyntaxNode(int fullWidth) 253624"];
3022 [label="param CSharpSyntaxNode(this) 253625"];
3023 [label="kind 253626"];
3024 [label="diagnostics 253627"];
3025 [label="annotations 253628"];
3026 [label="fullWidth 253629"];
3027 [label="param CSharpSyntaxNode(this) 253630"];
3028 [label="param CSharpSyntaxNode(this) 253631"];
3029 [label="GreenStats.NoteGreen(this); 253632"];
3030 [label="GreenStats.NoteGreen(this); 253633"];
3031 [label="Text 253634"];
3032 [label="this.Text 253635"];
3033 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253636"];
3034 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253637"];
3035 [label="if (!elastic)\n            {\n                return trivia;\n            } 253638"];
3036 [label="return trivia; 253639"];
3037 [label="Space = Whitespace(' ') 253640"];
3038 [label="'\\t' 253641"];
3039 [label="Whitespace('\\t') 253642"];
3040 [label="param Whitespace(string text) 253643"];
3041 [label="param Whitespace(bool elastic = false) 253644"];
3042 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253645"];
3043 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253646"];
3044 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 253647"];
3045 [label="param Create(SyntaxKind kind) 253648"];
3046 [label="param Create(string text) 253649"];
3047 [label="return new SyntaxTrivia(kind, text); 253650"];
3048 [label="return new SyntaxTrivia(kind, text); 253651"];
3049 [label="return new SyntaxTrivia(kind, text); 253652"];
3050 [label="new SyntaxTrivia(kind, text) 253653"];
3051 [label="param SyntaxTrivia(SyntaxKind kind) 253654"];
3052 [label="param SyntaxTrivia(string text) 253655"];
3053 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253656"];
3054 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253657"];
3055 [label="param SyntaxTrivia(this) 253658"];
3056 [label="kind 253659"];
3057 [label="diagnostics 253660"];
3058 [label="annotations 253661"];
3059 [label="text 253662"];
3060 [label="param SyntaxTrivia(this) 253663"];
3061 [label="param CSharpSyntaxNode(SyntaxKind kind) 253664"];
3062 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253665"];
3063 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253666"];
3064 [label="param CSharpSyntaxNode(int fullWidth) 253667"];
3065 [label="param CSharpSyntaxNode(this) 253668"];
3066 [label="kind 253669"];
3067 [label="diagnostics 253670"];
3068 [label="annotations 253671"];
3069 [label="fullWidth 253672"];
3070 [label="param CSharpSyntaxNode(this) 253673"];
3071 [label="param CSharpSyntaxNode(this) 253674"];
3072 [label="GreenStats.NoteGreen(this); 253675"];
3073 [label="GreenStats.NoteGreen(this); 253676"];
3074 [label="Text 253677"];
3075 [label="this.Text 253678"];
3076 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253679"];
3077 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253680"];
3078 [label="if (!elastic)\n            {\n                return trivia;\n            } 253681"];
3079 [label="return trivia; 253682"];
3080 [label="Tab = Whitespace('\\t') 253683"];
3081 [label="CrLf 253684"];
3082 [label="true 253685"];
3083 [label="elastic: true 253686"];
3084 [label="EndOfLine(CrLf, elastic: true) 253687"];
3085 [label="param EndOfLine(string text) 253688"];
3086 [label="param EndOfLine(bool elastic = false) 253689"];
3087 [label="SyntaxTrivia trivia = null; 253690"];
3088 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253691"];
3089 [label="elastic 253692"];
3090 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 253693"];
3091 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253694"];
3092 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253695"];
3093 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253696"];
3094 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253697"];
3095 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253698"];
3096 [label="param Create(SyntaxKind kind) 253699"];
3097 [label="param Create(string text) 253700"];
3098 [label="return new SyntaxTrivia(kind, text); 253701"];
3099 [label="return new SyntaxTrivia(kind, text); 253702"];
3100 [label="return new SyntaxTrivia(kind, text); 253703"];
3101 [label="new SyntaxTrivia(kind, text) 253704"];
3102 [label="param SyntaxTrivia(SyntaxKind kind) 253705"];
3103 [label="param SyntaxTrivia(string text) 253706"];
3104 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253707"];
3105 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253708"];
3106 [label="param SyntaxTrivia(this) 253709"];
3107 [label="kind 253710"];
3108 [label="diagnostics 253711"];
3109 [label="annotations 253712"];
3110 [label="text 253713"];
3111 [label="param SyntaxTrivia(this) 253714"];
3112 [label="param CSharpSyntaxNode(SyntaxKind kind) 253715"];
3113 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253716"];
3114 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253717"];
3115 [label="param CSharpSyntaxNode(int fullWidth) 253718"];
3116 [label="param CSharpSyntaxNode(this) 253719"];
3117 [label="kind 253720"];
3118 [label="diagnostics 253721"];
3119 [label="annotations 253722"];
3120 [label="fullWidth 253723"];
3121 [label="param CSharpSyntaxNode(this) 253724"];
3122 [label="param CSharpSyntaxNode(this) 253725"];
3123 [label="GreenStats.NoteGreen(this); 253726"];
3124 [label="GreenStats.NoteGreen(this); 253727"];
3125 [label="Text 253728"];
3126 [label="this.Text 253729"];
3127 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253730"];
3128 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253731"];
3129 [label="if (!elastic)\n            {\n                return trivia;\n            } 253732"];
3130 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253733"];
3131 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253734"];
3132 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 253735"];
3133 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253736"];
3134 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 253737"];
3135 [label="param SetAnnotations(this) 253738"];
3136 [label="this.Kind 253739"];
3137 [label="get { return (SyntaxKind)this.RawKind; } 253740"];
3138 [label="return (SyntaxKind)this.RawKind; 253741"];
3139 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253742"];
3140 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253743"];
3141 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253744"];
3142 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253745"];
3143 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 253746"];
3144 [label="param SyntaxTrivia(SyntaxKind kind) 253747"];
3145 [label="param SyntaxTrivia(string text) 253748"];
3146 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253749"];
3147 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253750"];
3148 [label="param SyntaxTrivia(this) 253751"];
3149 [label="param SyntaxTrivia(this) 253752"];
3150 [label="param CSharpSyntaxNode(this) 253753"];
3151 [label="param CSharpSyntaxNode(this) 253754"];
3152 [label="param CSharpSyntaxNode(this) 253755"];
3153 [label="GreenStats.NoteGreen(this); 253756"];
3154 [label="Text 253757"];
3155 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253758"];
3156 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 253759"];
3157 [label="'\\n' 253760"];
3158 [label="true 253761"];
3159 [label="elastic: true 253762"];
3160 [label="EndOfLine('\\n', elastic: true) 253763"];
3161 [label="param EndOfLine(string text) 253764"];
3162 [label="param EndOfLine(bool elastic = false) 253765"];
3163 [label="SyntaxTrivia trivia = null; 253766"];
3164 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253767"];
3165 [label="elastic 253768"];
3166 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 253769"];
3167 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253770"];
3168 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253771"];
3169 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253772"];
3170 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253773"];
3171 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253774"];
3172 [label="param Create(SyntaxKind kind) 253775"];
3173 [label="param Create(string text) 253776"];
3174 [label="return new SyntaxTrivia(kind, text); 253777"];
3175 [label="return new SyntaxTrivia(kind, text); 253778"];
3176 [label="return new SyntaxTrivia(kind, text); 253779"];
3177 [label="new SyntaxTrivia(kind, text) 253780"];
3178 [label="param SyntaxTrivia(SyntaxKind kind) 253781"];
3179 [label="param SyntaxTrivia(string text) 253782"];
3180 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253783"];
3181 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253784"];
3182 [label="param SyntaxTrivia(this) 253785"];
3183 [label="kind 253786"];
3184 [label="diagnostics 253787"];
3185 [label="annotations 253788"];
3186 [label="text 253789"];
3187 [label="param SyntaxTrivia(this) 253790"];
3188 [label="param CSharpSyntaxNode(SyntaxKind kind) 253791"];
3189 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253792"];
3190 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253793"];
3191 [label="param CSharpSyntaxNode(int fullWidth) 253794"];
3192 [label="param CSharpSyntaxNode(this) 253795"];
3193 [label="kind 253796"];
3194 [label="diagnostics 253797"];
3195 [label="annotations 253798"];
3196 [label="fullWidth 253799"];
3197 [label="param CSharpSyntaxNode(this) 253800"];
3198 [label="param CSharpSyntaxNode(this) 253801"];
3199 [label="GreenStats.NoteGreen(this); 253802"];
3200 [label="GreenStats.NoteGreen(this); 253803"];
3201 [label="Text 253804"];
3202 [label="this.Text 253805"];
3203 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253806"];
3204 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253807"];
3205 [label="if (!elastic)\n            {\n                return trivia;\n            } 253808"];
3206 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253809"];
3207 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253810"];
3208 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 253811"];
3209 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253812"];
3210 [label="this.Kind 253813"];
3211 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253814"];
3212 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 253815"];
3213 [label="param SyntaxTrivia(this) 253816"];
3214 [label="param SyntaxTrivia(this) 253817"];
3215 [label="param CSharpSyntaxNode(this) 253818"];
3216 [label="param CSharpSyntaxNode(this) 253819"];
3217 [label="GreenStats.NoteGreen(this); 253820"];
3218 [label="Text 253821"];
3219 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253822"];
3220 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 253823"];
3221 [label="'\\r' 253824"];
3222 [label="true 253825"];
3223 [label="elastic: true 253826"];
3224 [label="EndOfLine('\\r', elastic: true) 253827"];
3225 [label="param EndOfLine(string text) 253828"];
3226 [label="param EndOfLine(bool elastic = false) 253829"];
3227 [label="SyntaxTrivia trivia = null; 253830"];
3228 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 253831"];
3229 [label="elastic 253832"];
3230 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 253833"];
3231 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253834"];
3232 [label="if (trivia != null)\n            {\n                return trivia;\n            } 253835"];
3233 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253836"];
3234 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253837"];
3235 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 253838"];
3236 [label="param Create(SyntaxKind kind) 253839"];
3237 [label="param Create(string text) 253840"];
3238 [label="return new SyntaxTrivia(kind, text); 253841"];
3239 [label="return new SyntaxTrivia(kind, text); 253842"];
3240 [label="return new SyntaxTrivia(kind, text); 253843"];
3241 [label="new SyntaxTrivia(kind, text) 253844"];
3242 [label="param SyntaxTrivia(SyntaxKind kind) 253845"];
3243 [label="param SyntaxTrivia(string text) 253846"];
3244 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253847"];
3245 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253848"];
3246 [label="param SyntaxTrivia(this) 253849"];
3247 [label="kind 253850"];
3248 [label="diagnostics 253851"];
3249 [label="annotations 253852"];
3250 [label="text 253853"];
3251 [label="param SyntaxTrivia(this) 253854"];
3252 [label="param CSharpSyntaxNode(SyntaxKind kind) 253855"];
3253 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253856"];
3254 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253857"];
3255 [label="param CSharpSyntaxNode(int fullWidth) 253858"];
3256 [label="param CSharpSyntaxNode(this) 253859"];
3257 [label="kind 253860"];
3258 [label="diagnostics 253861"];
3259 [label="annotations 253862"];
3260 [label="fullWidth 253863"];
3261 [label="param CSharpSyntaxNode(this) 253864"];
3262 [label="param CSharpSyntaxNode(this) 253865"];
3263 [label="GreenStats.NoteGreen(this); 253866"];
3264 [label="GreenStats.NoteGreen(this); 253867"];
3265 [label="Text 253868"];
3266 [label="this.Text 253869"];
3267 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253870"];
3268 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 253871"];
3269 [label="if (!elastic)\n            {\n                return trivia;\n            } 253872"];
3270 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253873"];
3271 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253874"];
3272 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 253875"];
3273 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253876"];
3274 [label="this.Kind 253877"];
3275 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253878"];
3276 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 253879"];
3277 [label="param SyntaxTrivia(this) 253880"];
3278 [label="param SyntaxTrivia(this) 253881"];
3279 [label="param CSharpSyntaxNode(this) 253882"];
3280 [label="param CSharpSyntaxNode(this) 253883"];
3281 [label="GreenStats.NoteGreen(this); 253884"];
3282 [label="Text 253885"];
3283 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253886"];
3284 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 253887"];
3285 [label="' ' 253888"];
3286 [label="true 253889"];
3287 [label="elastic: true 253890"];
3288 [label="Whitespace(' ', elastic: true) 253891"];
3289 [label="param Whitespace(string text) 253892"];
3290 [label="param Whitespace(bool elastic = false) 253893"];
3291 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253894"];
3292 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253895"];
3293 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 253896"];
3294 [label="param Create(SyntaxKind kind) 253897"];
3295 [label="param Create(string text) 253898"];
3296 [label="return new SyntaxTrivia(kind, text); 253899"];
3297 [label="return new SyntaxTrivia(kind, text); 253900"];
3298 [label="return new SyntaxTrivia(kind, text); 253901"];
3299 [label="new SyntaxTrivia(kind, text) 253902"];
3300 [label="param SyntaxTrivia(SyntaxKind kind) 253903"];
3301 [label="param SyntaxTrivia(string text) 253904"];
3302 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253905"];
3303 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253906"];
3304 [label="param SyntaxTrivia(this) 253907"];
3305 [label="kind 253908"];
3306 [label="diagnostics 253909"];
3307 [label="annotations 253910"];
3308 [label="text 253911"];
3309 [label="param SyntaxTrivia(this) 253912"];
3310 [label="param CSharpSyntaxNode(SyntaxKind kind) 253913"];
3311 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253914"];
3312 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253915"];
3313 [label="param CSharpSyntaxNode(int fullWidth) 253916"];
3314 [label="param CSharpSyntaxNode(this) 253917"];
3315 [label="kind 253918"];
3316 [label="diagnostics 253919"];
3317 [label="annotations 253920"];
3318 [label="fullWidth 253921"];
3319 [label="param CSharpSyntaxNode(this) 253922"];
3320 [label="param CSharpSyntaxNode(this) 253923"];
3321 [label="GreenStats.NoteGreen(this); 253924"];
3322 [label="GreenStats.NoteGreen(this); 253925"];
3323 [label="Text 253926"];
3324 [label="this.Text 253927"];
3325 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253928"];
3326 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253929"];
3327 [label="if (!elastic)\n            {\n                return trivia;\n            } 253930"];
3328 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253931"];
3329 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253932"];
3330 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 253933"];
3331 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253934"];
3332 [label="this.Kind 253935"];
3333 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253936"];
3334 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 253937"];
3335 [label="param SyntaxTrivia(this) 253938"];
3336 [label="param SyntaxTrivia(this) 253939"];
3337 [label="param CSharpSyntaxNode(this) 253940"];
3338 [label="param CSharpSyntaxNode(this) 253941"];
3339 [label="GreenStats.NoteGreen(this); 253942"];
3340 [label="Text 253943"];
3341 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253944"];
3342 [label="ElasticSpace = Whitespace(' ', elastic: true) 253945"];
3343 [label="'\\t' 253946"];
3344 [label="true 253947"];
3345 [label="elastic: true 253948"];
3346 [label="Whitespace('\\t', elastic: true) 253949"];
3347 [label="param Whitespace(string text) 253950"];
3348 [label="param Whitespace(bool elastic = false) 253951"];
3349 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253952"];
3350 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253953"];
3351 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 253954"];
3352 [label="param Create(SyntaxKind kind) 253955"];
3353 [label="param Create(string text) 253956"];
3354 [label="return new SyntaxTrivia(kind, text); 253957"];
3355 [label="return new SyntaxTrivia(kind, text); 253958"];
3356 [label="return new SyntaxTrivia(kind, text); 253959"];
3357 [label="new SyntaxTrivia(kind, text) 253960"];
3358 [label="param SyntaxTrivia(SyntaxKind kind) 253961"];
3359 [label="param SyntaxTrivia(string text) 253962"];
3360 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 253963"];
3361 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 253964"];
3362 [label="param SyntaxTrivia(this) 253965"];
3363 [label="kind 253966"];
3364 [label="diagnostics 253967"];
3365 [label="annotations 253968"];
3366 [label="text 253969"];
3367 [label="param SyntaxTrivia(this) 253970"];
3368 [label="param CSharpSyntaxNode(SyntaxKind kind) 253971"];
3369 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 253972"];
3370 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 253973"];
3371 [label="param CSharpSyntaxNode(int fullWidth) 253974"];
3372 [label="param CSharpSyntaxNode(this) 253975"];
3373 [label="kind 253976"];
3374 [label="diagnostics 253977"];
3375 [label="annotations 253978"];
3376 [label="fullWidth 253979"];
3377 [label="param CSharpSyntaxNode(this) 253980"];
3378 [label="param CSharpSyntaxNode(this) 253981"];
3379 [label="GreenStats.NoteGreen(this); 253982"];
3380 [label="GreenStats.NoteGreen(this); 253983"];
3381 [label="Text 253984"];
3382 [label="this.Text 253985"];
3383 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 253986"];
3384 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 253987"];
3385 [label="if (!elastic)\n            {\n                return trivia;\n            } 253988"];
3386 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253989"];
3387 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253990"];
3388 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 253991"];
3389 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 253992"];
3390 [label="this.Kind 253993"];
3391 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 253994"];
3392 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 253995"];
3393 [label="param SyntaxTrivia(this) 253996"];
3394 [label="param SyntaxTrivia(this) 253997"];
3395 [label="param CSharpSyntaxNode(this) 253998"];
3396 [label="param CSharpSyntaxNode(this) 253999"];
3397 [label="GreenStats.NoteGreen(this); 254000"];
3398 [label="Text 254001"];
3399 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 254002"];
3400 [label="ElasticTab = Whitespace('\\t', elastic: true) 254003"];
3401 [label="string.Empty 254004"];
3402 [label="true 254005"];
3403 [label="elastic: true 254006"];
3404 [label="Whitespace(string.Empty, elastic: true) 254007"];
3405 [label="param Whitespace(string text) 254008"];
3406 [label="param Whitespace(bool elastic = false) 254009"];
3407 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 254010"];
3408 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 254011"];
3409 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 254012"];
3410 [label="param Create(SyntaxKind kind) 254013"];
3411 [label="param Create(string text) 254014"];
3412 [label="return new SyntaxTrivia(kind, text); 254015"];
3413 [label="return new SyntaxTrivia(kind, text); 254016"];
3414 [label="return new SyntaxTrivia(kind, text); 254017"];
3415 [label="new SyntaxTrivia(kind, text) 254018"];
3416 [label="param SyntaxTrivia(SyntaxKind kind) 254019"];
3417 [label="param SyntaxTrivia(string text) 254020"];
3418 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 254021"];
3419 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 254022"];
3420 [label="param SyntaxTrivia(this) 254023"];
3421 [label="kind 254024"];
3422 [label="diagnostics 254025"];
3423 [label="annotations 254026"];
3424 [label="text 254027"];
3425 [label="param SyntaxTrivia(this) 254028"];
3426 [label="param CSharpSyntaxNode(SyntaxKind kind) 254029"];
3427 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 254030"];
3428 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 254031"];
3429 [label="param CSharpSyntaxNode(int fullWidth) 254032"];
3430 [label="param CSharpSyntaxNode(this) 254033"];
3431 [label="kind 254034"];
3432 [label="diagnostics 254035"];
3433 [label="annotations 254036"];
3434 [label="fullWidth 254037"];
3435 [label="param CSharpSyntaxNode(this) 254038"];
3436 [label="param CSharpSyntaxNode(this) 254039"];
3437 [label="GreenStats.NoteGreen(this); 254040"];
3438 [label="GreenStats.NoteGreen(this); 254041"];
3439 [label="Text 254042"];
3440 [label="this.Text 254043"];
3441 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 254044"];
3442 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 254045"];
3443 [label="if (!elastic)\n            {\n                return trivia;\n            } 254046"];
3444 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 254047"];
3445 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 254048"];
3446 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 254049"];
3447 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 254050"];
3448 [label="this.Kind 254051"];
3449 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 254052"];
3450 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 254053"];
3451 [label="param SyntaxTrivia(this) 254054"];
3452 [label="param SyntaxTrivia(this) 254055"];
3453 [label="param CSharpSyntaxNode(this) 254056"];
3454 [label="param CSharpSyntaxNode(this) 254057"];
3455 [label="GreenStats.NoteGreen(this); 254058"];
3456 [label="Text 254059"];
3457 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 254060"];
3458 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 254061"];
3459 [label="s_xmlCarriageReturnLineFeed 254062"];
3460 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 254063"];
3461 [label="param operator(SyntaxTrivia trivia) 254064"];
3462 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254065"];
3463 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254066"];
3464 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254067"];
3465 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 254068"];
3466 [label="param operator(SyntaxTrivia trivia) 254069"];
3467 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254070"];
3468 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254071"];
3469 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254072"];
3470 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 254073"];
3471 [label="param operator(SyntaxTrivia trivia) 254074"];
3472 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254075"];
3473 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254076"];
3474 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254077"];
3475 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 254078"];
3476 [label="param operator(SyntaxTrivia trivia) 254079"];
3477 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254080"];
3478 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254081"];
3479 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254082"];
3480 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 254083"];
3481 [label="param operator(SyntaxTrivia trivia) 254084"];
3482 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254085"];
3483 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254086"];
3484 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254087"];
3485 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 254088"];
3486 [label="param operator(SyntaxTrivia trivia) 254089"];
3487 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254090"];
3488 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254091"];
3489 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254092"];
3490 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 254093"];
3491 [label="param operator(SyntaxTrivia trivia) 254094"];
3492 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254095"];
3493 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254096"];
3494 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254097"];
3495 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 254098"];
3496 [label="param operator(SyntaxTrivia trivia) 254099"];
3497 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254100"];
3498 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254101"];
3499 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254102"];
3500 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 254103"];
3501 [label="param operator(SyntaxTrivia trivia) 254104"];
3502 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254105"];
3503 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254106"];
3504 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254107"];
3505 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 254108"];
3506 [label="param operator(SyntaxTrivia trivia) 254109"];
3507 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254110"];
3508 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254111"];
3509 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254112"];
3510 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 254113"];
3511 [label="param operator(SyntaxTrivia trivia) 254114"];
3512 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254115"];
3513 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254116"];
3514 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 254117"];
3515 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 254118"];
3516 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 254119"];
3517 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 254120"];
3518 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 254121"];
3519 [label="SyntaxFactory.ParseSyntaxTree(stringText, options, filename) 254122"];
3520 [label="param ParseSyntaxTree(SourceText text) 254123"];
3521 [label="param ParseSyntaxTree(ParseOptions? options = null) 254124"];
3522 [label="param ParseSyntaxTree(string path = '') 254125"];
3523 [label="param ParseSyntaxTree(CancellationToken cancellationToken = default) 254126"];
3524 [label="new DummySyntaxTree() 254127"];
3525 [label="param DummySyntaxTree(this) 254128"];
3526 [label="param CSharpSyntaxTree(this) 254129"];
3527 [label="_hasDirectives 254130"];
3528 [label="_lazyLineDirectiveMap 254131"];
3529 [label="_lazyPragmaWarningStateMap 254132"];
3530 [label="_lazyNullableContextStateMap 254133"];
3531 [label="_lazyIsGeneratedCode = GeneratedKind.Unknown 254134"];
3532 [label="_node 254135"];
3533 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 254136"];
3534 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 254137"];
3535 [label="SyntaxFactory.ParseCompilationUnit(string.Empty) 254138"];
3536 [label="param ParseCompilationUnit(string text) 254139"];
3537 [label="param ParseCompilationUnit(int offset = 0) 254140"];
3538 [label="param ParseCompilationUnit(CSharpParseOptions? options = null) 254141"];
3539 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 254142"];
3540 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 254143"];
3541 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 254144"];
3542 [label="MakeLexer(text, offset, options) 254145"];
3543 [label="param MakeLexer(string text) 254146"];
3544 [label="param MakeLexer(int offset) 254147"];
3545 [label="param MakeLexer(CSharpParseOptions? options = null) 254148"];
3546 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 254149"];
3547 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 254150"];
3548 [label="MakeSourceText(text, offset) 254151"];
3549 [label="param MakeSourceText(string text) 254152"];
3550 [label="param MakeSourceText(int offset) 254153"];
3551 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254154"];
3552 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254155"];
3553 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254156"];
3554 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254157"];
3555 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254158"];
3556 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 254159"];
3557 [label="8 254160"];
3558 [label="TriviaListInitialCapacity = 8 254161"];
3559 [label="TokensLexed 254162"];
3560 [label="'<<<<<<<' 254163"];
3561 [label="s_conflictMarkerLength = '<<<<<<<'.Length 254164"];
3562 [label="42 254165"];
3563 [label="MaxCachedTokenSize = 42 254166"];
3564 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254167"];
3565 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 254168"];
3566 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254169"];
3567 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254170"];
3568 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254171"];
3569 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254172"];
3570 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254173"];
3571 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254174"];
3572 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254175"];
3573 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 254176"];
3574 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254177"];
3575 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254178"];
3576 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254179"];
3577 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254180"];
3578 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254181"];
3579 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254182"];
3580 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254183"];
3581 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254184"];
3582 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254185"];
3583 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 254186"];
3584 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 254187"];
3585 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 254188"];
3586 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 254189"];
3587 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 254190"];
3588 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 254191"];
3589 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 254192"];
3590 [label="param Lexer(SourceText text) 254193"];
3591 [label="param Lexer(CSharpParseOptions options) 254194"];
3592 [label="param Lexer(bool allowPreprocessorDirectives = true) 254195"];
3593 [label="param Lexer(bool interpolationFollowedByColon = false) 254196"];
3594 [label="param Lexer(this) 254197"];
3595 [label="text 254198"];
3596 [label="param Lexer(this) 254199"];
3597 [label="param AbstractLexer(SourceText text) 254200"];
3598 [label="param AbstractLexer(this) 254201"];
3599 [label="TextWindow 254202"];
3600 [label="_errors 254203"];
3601 [label="InvalidCharacter = char.MaxValue 254204"];
3602 [label="2048 254205"];
3603 [label="DefaultWindowLength = 2048 254206"];
3604 [label="() => new char[DefaultWindowLength] 254207"];
3605 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 254208"];
3606 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 254209"];
3607 [label="this.TextWindow = new SlidingTextWindow(text); 254210"];
3608 [label="this.TextWindow = new SlidingTextWindow(text); 254211"];
3609 [label="new SlidingTextWindow(text) 254212"];
3610 [label="param SlidingTextWindow(SourceText text) 254213"];
3611 [label="param SlidingTextWindow(this) 254214"];
3612 [label="_text 254215"];
3613 [label="_basis 254216"];
3614 [label="_offset 254217"];
3615 [label="_textEnd 254218"];
3616 [label="_characterWindow 254219"];
3617 [label="_characterWindowCount 254220"];
3618 [label="_lexemeStart 254221"];
3619 [label="_strings 254222"];
3620 [label="_text 254223"];
3621 [label="_basis = 0; 254224"];
3622 [label="_basis 254225"];
3623 [label="_offset = 0; 254226"];
3624 [label="_offset 254227"];
3625 [label="_textEnd 254228"];
3626 [label="_strings = StringTable.GetInstance(); 254229"];
3627 [label="_strings 254230"];
3628 [label="_characterWindow = s_windowPool.Allocate(); 254231"];
3629 [label="_characterWindow 254232"];
3630 [label="_lexemeStart = 0; 254233"];
3631 [label="_lexemeStart 254234"];
3632 [label="this.TextWindow 254235"];
3633 [label="_options 254236"];
3634 [label="_mode 254237"];
3635 [label="_builder 254238"];
3636 [label="_identBuffer 254239"];
3637 [label="_identLen 254240"];
3638 [label="_cache 254241"];
3639 [label="_allowPreprocessorDirectives 254242"];
3640 [label="_interpolationFollowedByColon 254243"];
3641 [label="_xmlParser 254244"];
3642 [label="_badTokenCount 254245"];
3643 [label="10 254246"];
3644 [label="new SyntaxListBuilder(10) 254247"];
3645 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 254248"];
3646 [label="10 254249"];
3647 [label="new SyntaxListBuilder(10) 254250"];
3648 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 254251"];
3649 [label="_createWhitespaceTriviaFunction 254252"];
3650 [label="_createQuickTokenFunction 254253"];
3651 [label="Debug.Assert(options != null); 254254"];
3652 [label="Debug.Assert(options != null); 254255"];
3653 [label="_options 254256"];
3654 [label="_builder = new StringBuilder(); 254257"];
3655 [label="_builder 254258"];
3656 [label="_identBuffer = new char[32]; 254259"];
3657 [label="_identBuffer 254260"];
3658 [label="512 254261"];
3659 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 254262"];
3660 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 254263"];
3661 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 254264"];
3662 [label="10 254265"];
3663 [label="MaxKeywordLength = 10 254266"];
3664 [label="_cache = new LexerCache(); 254267"];
3665 [label="new LexerCache() 254268"];
3666 [label="param LexerCache(this) 254269"];
3667 [label="_triviaMap 254270"];
3668 [label="_tokenMap 254271"];
3669 [label="_keywordKindMap 254272"];
3670 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 254273"];
3671 [label="_triviaMap 254274"];
3672 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 254275"];
3673 [label="_tokenMap 254276"];
3674 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 254277"];
3675 [label="_keywordKindMap 254278"];
3676 [label="_cache 254279"];
3677 [label="_createQuickTokenFunction 254280"];
3678 [label="_allowPreprocessorDirectives 254281"];
3679 [label="_interpolationFollowedByColon 254282"];
3680 [label="using (var lexer = MakeLexer(text, offset, options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 254283"];
3681 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 254284"];
3682 [label="MakeParser(lexer) 254285"];
3683 [label="param MakeParser(InternalSyntax.Lexer lexer) 254286"];
3684 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 254287"];
3685 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 254288"];
3686 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 254289"];
3687 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 254290"];
3688 [label="param LanguageParser(Lexer lexer) 254291"];
3689 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 254292"];
3690 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 254293"];
3691 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 254294"];
3692 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 254295"];
3693 [label="param LanguageParser(this) 254296"];
3694 [label="() => new BlendedNode[32] 254297"];
3695 [label="2 254298"];
3696 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 254299"];
3697 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 254300"];
3698 [label="lexer 254301"];
3699 [label="lexerMode 254302"];
3700 [label="oldTree 254303"];
3701 [label="changes 254304"];
3702 [label="false 254305"];
3703 [label="true 254306"];
3704 [label="cancellationToken 254307"];
3705 [label="param LanguageParser(this) 254308"];
3706 [label="param SyntaxParser(Lexer lexer) 254309"];
3707 [label="param SyntaxParser(LexerMode mode) 254310"];
3708 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 254311"];
3709 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 254312"];
3710 [label="param SyntaxParser(bool allowModeReset) 254313"];
3711 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 254314"];
3712 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 254315"];
3713 [label="param SyntaxParser(this) 254316"];
3714 [label="lexer 254317"];
3715 [label="_isIncremental 254318"];
3716 [label="_allowModeReset 254319"];
3717 [label="_mode 254320"];
3718 [label="_currentToken 254321"];
3719 [label="_lexedTokens 254322"];
3720 [label="_prevTokenTrailingTrivia 254323"];
3721 [label="_firstToken 254324"];
3722 [label="_tokenOffset 254325"];
3723 [label="_tokenCount 254326"];
3724 [label="_resetCount 254327"];
3725 [label="_resetStart 254328"];
3726 [label="_blendedTokens 254329"];
3727 [label="this.lexer 254330"];
3728 [label="_mode 254331"];
3729 [label="_allowModeReset 254332"];
3730 [label="this.cancellationToken 254333"];
3731 [label="_currentNode = default(BlendedNode); 254334"];
3732 [label="_currentNode 254335"];
3733 [label="_isIncremental = oldTree != null; 254336"];
3734 [label="_isIncremental = oldTree != null; 254337"];
3735 [label="_isIncremental 254338"];
3736 [label="this.IsIncremental 254339"];
3737 [label="get\n            {\n                return _isIncremental;\n            } 254340"];
3738 [label="return _isIncremental; 254341"];
3739 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 254342"];
3740 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 254343"];
3741 [label="_firstBlender = default(Blender); 254344"];
3742 [label="_firstBlender 254345"];
3743 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 254346"];
3744 [label="_lexedTokens 254347"];
3745 [label="this.IsIncremental 254348"];
3746 [label="get\n            {\n                return _isIncremental;\n            } 254349"];
3747 [label="return _isIncremental; 254350"];
3748 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 254351"];
3749 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 254352"];
3750 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 254353"];
3751 [label="this.PreLex() 254354"];
3752 [label="param PreLex(this) 254355"];
3753 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 254356"];
3754 [label="this.lexer.TextWindow.Text 254357"];
3755 [label="=> _text 254358"];
3756 [label="_text 254359"];
3757 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 254360"];
3758 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 254361"];
3759 [label="_lexedTokens 254362"];
3760 [label="var lexer = this.lexer; 254363"];
3761 [label="var mode = _mode; 254364"];
3762 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 254365"];
3763 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 254366"];
3764 [label="var token = lexer.Lex(mode); 254367"];
3765 [label="lexer.Lex(mode) 254368"];
3766 [label="param Lex(LexerMode mode) 254369"];
3767 [label="param Lex(this) 254370"];
3768 [label="TokensLexed++; 254371"];
3769 [label="_mode 254372"];
3770 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 254373"];
3771 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 254374"];
3772 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 254375"];
3773 [label="param Start(this) 254376"];
3774 [label="TextWindow.Start() 254377"];
3775 [label="param Start(this) 254378"];
3776 [label="_lexemeStart 254379"];
3777 [label="TextWindow.Start(); 254380"];
3778 [label="_errors = null; 254381"];
3779 [label="_errors 254382"];
3780 [label="get\n            {\n                return _offset;\n            } 254383"];
3781 [label="return _offset; 254384"];
3782 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 254385"];
3783 [label="get\n            {\n                return _characterWindowCount;\n            } 254386"];
3784 [label="return _characterWindowCount; 254387"];
3785 [label="get\n            {\n                return _characterWindow;\n            } 254388"];
3786 [label="return _characterWindow; 254389"];
3787 [label="param AdvanceChar(int n) 254390"];
3788 [label="param AdvanceChar(this) 254391"];
3789 [label="_offset += n; 254392"];
3790 [label="_offset 254393"];
3791 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 254394"];
3792 [label="return _basis + _lexemeStart; 254395"];
3793 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 254396"];
3794 [label="param Reset(int position) 254397"];
3795 [label="param Reset(this) 254398"];
3796 [label="int relative = position - _basis; 254399"];
3797 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 254400"];
3798 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 254401"];
3799 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 254402"];
3800 [label="_offset 254403"];
3801 [label="this.LexSyntaxToken() 254404"];
3802 [label="param LexSyntaxToken(this) 254405"];
3803 [label="_leadingTriviaCache.Clear(); 254406"];
3804 [label="TextWindow.Position 254407"];
3805 [label="get\n            {\n                return _basis + _offset;\n            } 254408"];
3806 [label="return _basis + _offset; 254409"];
3807 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 254410"];
3808 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 254411"];
3809 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 254412"];
3810 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 254413"];
3811 [label="param LexSyntaxTrivia(bool afterFirstToken) 254414"];
3812 [label="param LexSyntaxTrivia(bool isTrailing) 254415"];
3813 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 254416"];
3814 [label="param LexSyntaxTrivia(this) 254417"];
3815 [label="bool onlyWhitespaceOnLine = !isTrailing; 254418"];
3816 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 254419"];
3817 [label="this.Start() 254420"];
3818 [label="param Start(this) 254421"];
3819 [label="TextWindow.Start() 254422"];
3820 [label="param Start(this) 254423"];
3821 [label="TextWindow.Start(); 254424"];
3822 [label="_errors = null; 254425"];
3823 [label="_errors 254426"];
3824 [label="this.Start(); 254427"];
3825 [label="TextWindow.PeekChar() 254428"];
3826 [label="param PeekChar(this) 254429"];
3827 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 254430"];
3828 [label="MoreChars() 254431"];
3829 [label="param MoreChars(this) 254432"];
3830 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 254433"];
3831 [label="this.Position 254434"];
3832 [label="get\n            {\n                return _basis + _offset;\n            } 254435"];
3833 [label="return _basis + _offset; 254436"];
3834 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 254437"];
3835 [label="return false; 254438"];
3836 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 254439"];
3837 [label="return InvalidCharacter; 254440"];
3838 [label="char ch = TextWindow.PeekChar(); 254441"];
3839 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254442"];
3840 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254443"];
3841 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254444"];
3842 [label="new SyntaxKindEqualityComparer() 254445"];
3843 [label="param SyntaxKindEqualityComparer(this) 254446"];
3844 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 254447"];
3845 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 254448"];
3846 [label="SyntaxFacts.IsWhitespace(ch) 254449"];
3847 [label="param IsWhitespace(char ch) 254450"];
3848 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254451"];
3849 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254452"];
3850 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254453"];
3851 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 254454"];
3852 [label="SyntaxFacts.IsNewLine(ch) 254455"];
3853 [label="param IsNewLine(char ch) 254456"];
3854 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 254457"];
3855 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 254458"];
3856 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 254459"];
3857 [label="return; 254460"];
3858 [label="var leading = _leadingTriviaCache; 254461"];
3859 [label="var tokenInfo = default(TokenInfo); 254462"];
3860 [label="this.Start() 254463"];
3861 [label="param Start(this) 254464"];
3862 [label="TextWindow.Start() 254465"];
3863 [label="param Start(this) 254466"];
3864 [label="TextWindow.Start(); 254467"];
3865 [label="_errors = null; 254468"];
3866 [label="_errors 254469"];
3867 [label="this.Start(); 254470"];
3868 [label="this.ScanSyntaxToken(ref tokenInfo); 254471"];
3869 [label="this.ScanSyntaxToken(ref tokenInfo); 254472"];
3870 [label="this.ScanSyntaxToken(ref tokenInfo); 254473"];
3871 [label="get\n            {\n                return _basis + _offset;\n            } 254474"];
3872 [label="return _basis + _offset; 254475"];
3873 [label="param PeekChar(this) 254476"];
3874 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 254477"];
3875 [label="MoreChars() 254478"];
3876 [label="param MoreChars(this) 254479"];
3877 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 254480"];
3878 [label="this.Position 254481"];
3879 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 254482"];
3880 [label="return false; 254483"];
3881 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 254484"];
3882 [label="return InvalidCharacter; 254485"];
3883 [label="param IsReallyAtEnd(this) 254486"];
3884 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 254487"];
3885 [label="Position 254488"];
3886 [label="get\n            {\n                return _basis + _offset;\n            } 254489"];
3887 [label="return _basis + _offset; 254490"];
3888 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 254491"];
3889 [label="ConsList<Directive>.Empty 254492"];
3890 [label="new DirectiveStack(ConsList<Directive>.Empty) 254493"];
3891 [label="param DirectiveStack(ConsList<Directive> directives) 254494"];
3892 [label="param DirectiveStack(this) 254495"];
3893 [label="_directives 254496"];
3894 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 254497"];
3895 [label="null 254498"];
3896 [label="new DirectiveStack(null) 254499"];
3897 [label="param DirectiveStack(ConsList<Directive> directives) 254500"];
3898 [label="param DirectiveStack(this) 254501"];
3899 [label="_directives 254502"];
3900 [label="Null = new DirectiveStack(null) 254503"];
3901 [label="param HasUnfinishedIf(this) 254504"];
3902 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 254505"];
3903 [label="GetPreviousIfElifElseOrRegion(_directives) 254506"];
3904 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 254507"];
3905 [label="var current = directives; 254508"];
3906 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 254509"];
3907 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 254510"];
3908 [label="return current; 254511"];
3909 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 254512"];
3910 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 254513"];
3911 [label="param HasUnfinishedRegion(this) 254514"];
3912 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 254515"];
3913 [label="GetPreviousIfElifElseOrRegion(_directives) 254516"];
3914 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 254517"];
3915 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 254518"];
3916 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 254519"];
3917 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 254520"];
3918 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 254521"];
3919 [label="var errors = this.GetErrors(GetFullWidth(leading)); 254522"];
3920 [label="GetFullWidth(leading) 254523"];
3921 [label="param GetFullWidth(SyntaxListBuilder builder) 254524"];
3922 [label="int width = 0; 254525"];
3923 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 254526"];
3924 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 254527"];
3925 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 254528"];
3926 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 254529"];
3927 [label="return width; 254530"];
3928 [label="var errors = this.GetErrors(GetFullWidth(leading)); 254531"];
3929 [label="this.GetErrors(GetFullWidth(leading)) 254532"];
3930 [label="param GetErrors(int leadingTriviaWidth) 254533"];
3931 [label="param GetErrors(this) 254534"];
3932 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 254535"];
3933 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 254536"];
3934 [label="return null; 254537"];
3935 [label="var errors = this.GetErrors(GetFullWidth(leading)); 254538"];
3936 [label="_trailingTriviaCache.Clear(); 254539"];
3937 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 254540"];
3938 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 254541"];
3939 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 254542"];
3940 [label="param LexSyntaxTrivia(bool afterFirstToken) 254543"];
3941 [label="param LexSyntaxTrivia(bool isTrailing) 254544"];
3942 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 254545"];
3943 [label="param LexSyntaxTrivia(this) 254546"];
3944 [label="bool onlyWhitespaceOnLine = !isTrailing; 254547"];
3945 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 254548"];
3946 [label="this.Start() 254549"];
3947 [label="param Start(this) 254550"];
3948 [label="TextWindow.Start() 254551"];
3949 [label="param Start(this) 254552"];
3950 [label="TextWindow.Start(); 254553"];
3951 [label="_errors = null; 254554"];
3952 [label="_errors 254555"];
3953 [label="this.Start(); 254556"];
3954 [label="TextWindow.PeekChar() 254557"];
3955 [label="param PeekChar(this) 254558"];
3956 [label="MoreChars() 254559"];
3957 [label="char ch = TextWindow.PeekChar(); 254560"];
3958 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254561"];
3959 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254562"];
3960 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 254563"];
3961 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 254564"];
3962 [label="SyntaxFacts.IsWhitespace(ch) 254565"];
3963 [label="param IsWhitespace(char ch) 254566"];
3964 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254567"];
3965 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254568"];
3966 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 254569"];
3967 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 254570"];
3968 [label="SyntaxFacts.IsNewLine(ch) 254571"];
3969 [label="param IsNewLine(char ch) 254572"];
3970 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 254573"];
3971 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 254574"];
3972 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 254575"];
3973 [label="return; 254576"];
3974 [label="var trailing = _trailingTriviaCache; 254577"];
3975 [label="return Create(ref tokenInfo, leading, trailing, errors); 254578"];
3976 [label="return Create(ref tokenInfo, leading, trailing, errors); 254579"];
3977 [label="return Create(ref tokenInfo, leading, trailing, errors); 254580"];
3978 [label="return Create(ref tokenInfo, leading, trailing, errors); 254581"];
3979 [label="Create(ref tokenInfo, leading, trailing, errors) 254582"];
3980 [label="param Create(ref TokenInfo info) 254583"];
3981 [label="param Create(SyntaxListBuilder leading) 254584"];
3982 [label="param Create(SyntaxListBuilder trailing) 254585"];
3983 [label="param Create(SyntaxDiagnosticInfo[] errors) 254586"];
3984 [label="param Create(this) 254587"];
3985 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 254588"];
3986 [label="var leadingNode = leading?.ToListNode(); 254589"];
3987 [label="var trailingNode = trailing?.ToListNode(); 254590"];
3988 [label="SyntaxToken token; 254591"];
3989 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 254592"];
3990 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 254593"];
3991 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 254594"];
3992 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 254595"];
3993 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 254596"];
3994 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 254597"];
3995 [label="param Token(GreenNode leading) 254598"];
3996 [label="param Token(SyntaxKind kind) 254599"];
3997 [label="param Token(GreenNode trailing) 254600"];
3998 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 254601"];
3999 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 254602"];
4000 [label="1 254603"];
4001 [label="(int)LastTokenWithWellKnownText + 1 254604"];
4002 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254605"];
4003 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254606"];
4004 [label="1 254607"];
4005 [label="(int)LastTokenWithWellKnownText + 1 254608"];
4006 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254609"];
4007 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254610"];
4008 [label="1 254611"];
4009 [label="(int)LastTokenWithWellKnownText + 1 254612"];
4010 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254613"];
4011 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254614"];
4012 [label="1 254615"];
4013 [label="(int)LastTokenWithWellKnownText + 1 254616"];
4014 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254617"];
4015 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 254618"];
4016 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 254619"];
4017 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 254620"];
4018 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 254621"];
4019 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 254622"];
4020 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 254623"];
4021 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 254624"];
4022 [label="new SyntaxToken(kind) 254625"];
4023 [label="param SyntaxToken(SyntaxKind kind) 254626"];
4024 [label="param SyntaxToken(this) 254627"];
4025 [label="kind 254628"];
4026 [label="param SyntaxToken(this) 254629"];
4027 [label="param CSharpSyntaxNode(SyntaxKind kind) 254630"];
4028 [label="param CSharpSyntaxNode(this) 254631"];
4029 [label="kind 254632"];
4030 [label="param CSharpSyntaxNode(this) 254633"];
4031 [label="param CSharpSyntaxNode(this) 254634"];
4032 [label="GreenStats.NoteGreen(this); 254635"];
4033 [label="GreenStats.NoteGreen(this); 254636"];
4034 [label="this.Text 254637"];
4035 [label="get { return SyntaxFacts.GetText(this.Kind); } 254638"];
4036 [label="this.Kind 254639"];
4037 [label="get { return (SyntaxKind)this.RawKind; } 254640"];
4038 [label="return (SyntaxKind)this.RawKind; 254641"];
4039 [label="return SyntaxFacts.GetText(this.Kind); 254642"];
4040 [label="SyntaxFacts.GetText(this.Kind) 254643"];
4041 [label="param GetText(SyntaxKind kind) 254644"];
4042 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254645"];
4043 [label="return '~'; 254646"];
4044 [label="FullWidth = this.Text.Length; 254647"];
4045 [label="FullWidth 254648"];
4046 [label="this.flags |= NodeFlags.IsNotMissing; 254649"];
4047 [label="this.flags 254650"];
4048 [label="s_tokensWithNoTrivia[(int)kind].Value 254651"];
4049 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 254652"];
4050 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 254653"];
4051 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 254654"];
4052 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 254655"];
4053 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 254656"];
4054 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 254657"];
4055 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254658"];
4056 [label="param SyntaxTokenWithTrivia(GreenNode leading) 254659"];
4057 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 254660"];
4058 [label="param SyntaxTokenWithTrivia(this) 254661"];
4059 [label="kind 254662"];
4060 [label="param SyntaxTokenWithTrivia(this) 254663"];
4061 [label="param SyntaxToken(SyntaxKind kind) 254664"];
4062 [label="param SyntaxToken(this) 254665"];
4063 [label="kind 254666"];
4064 [label="param SyntaxToken(this) 254667"];
4065 [label="param CSharpSyntaxNode(SyntaxKind kind) 254668"];
4066 [label="param CSharpSyntaxNode(this) 254669"];
4067 [label="kind 254670"];
4068 [label="param CSharpSyntaxNode(this) 254671"];
4069 [label="param CSharpSyntaxNode(this) 254672"];
4070 [label="GreenStats.NoteGreen(this); 254673"];
4071 [label="GreenStats.NoteGreen(this); 254674"];
4072 [label="this.Text 254675"];
4073 [label="get { return SyntaxFacts.GetText(this.Kind); } 254676"];
4074 [label="this.Kind 254677"];
4075 [label="get { return (SyntaxKind)this.RawKind; } 254678"];
4076 [label="return (SyntaxKind)this.RawKind; 254679"];
4077 [label="return SyntaxFacts.GetText(this.Kind); 254680"];
4078 [label="SyntaxFacts.GetText(this.Kind) 254681"];
4079 [label="param GetText(SyntaxKind kind) 254682"];
4080 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254683"];
4081 [label="return '~'; 254684"];
4082 [label="FullWidth = this.Text.Length; 254685"];
4083 [label="FullWidth 254686"];
4084 [label="this.flags |= NodeFlags.IsNotMissing; 254687"];
4085 [label="this.flags 254688"];
4086 [label="LeadingField 254689"];
4087 [label="TrailingField 254690"];
4088 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254691"];
4089 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254692"];
4090 [label="this.AdjustFlagsAndWidth(leading); 254693"];
4091 [label="this.AdjustFlagsAndWidth(leading); 254694"];
4092 [label="this.LeadingField 254695"];
4093 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254696"];
4094 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254697"];
4095 [label="this.AdjustFlagsAndWidth(trailing); 254698"];
4096 [label="this.AdjustFlagsAndWidth(trailing); 254699"];
4097 [label="this.TrailingField 254700"];
4098 [label="s_tokensWithElasticTrivia[(int)kind].Value 254701"];
4099 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 254702"];
4100 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 254703"];
4101 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 254704"];
4102 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 254705"];
4103 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 254706"];
4104 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254707"];
4105 [label="param SyntaxTokenWithTrivia(GreenNode leading) 254708"];
4106 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 254709"];
4107 [label="param SyntaxTokenWithTrivia(this) 254710"];
4108 [label="kind 254711"];
4109 [label="param SyntaxTokenWithTrivia(this) 254712"];
4110 [label="param SyntaxToken(SyntaxKind kind) 254713"];
4111 [label="param SyntaxToken(this) 254714"];
4112 [label="kind 254715"];
4113 [label="param SyntaxToken(this) 254716"];
4114 [label="param CSharpSyntaxNode(SyntaxKind kind) 254717"];
4115 [label="param CSharpSyntaxNode(this) 254718"];
4116 [label="kind 254719"];
4117 [label="param CSharpSyntaxNode(this) 254720"];
4118 [label="param CSharpSyntaxNode(this) 254721"];
4119 [label="GreenStats.NoteGreen(this); 254722"];
4120 [label="GreenStats.NoteGreen(this); 254723"];
4121 [label="this.Text 254724"];
4122 [label="get { return SyntaxFacts.GetText(this.Kind); } 254725"];
4123 [label="this.Kind 254726"];
4124 [label="get { return (SyntaxKind)this.RawKind; } 254727"];
4125 [label="return (SyntaxKind)this.RawKind; 254728"];
4126 [label="return SyntaxFacts.GetText(this.Kind); 254729"];
4127 [label="SyntaxFacts.GetText(this.Kind) 254730"];
4128 [label="param GetText(SyntaxKind kind) 254731"];
4129 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254732"];
4130 [label="return '~'; 254733"];
4131 [label="FullWidth = this.Text.Length; 254734"];
4132 [label="FullWidth 254735"];
4133 [label="this.flags |= NodeFlags.IsNotMissing; 254736"];
4134 [label="this.flags 254737"];
4135 [label="LeadingField 254738"];
4136 [label="TrailingField 254739"];
4137 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254740"];
4138 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254741"];
4139 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254742"];
4140 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254743"];
4141 [label="this.AdjustFlagsAndWidth(trailing); 254744"];
4142 [label="this.AdjustFlagsAndWidth(trailing); 254745"];
4143 [label="this.TrailingField 254746"];
4144 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 254747"];
4145 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 254748"];
4146 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 254749"];
4147 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 254750"];
4148 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 254751"];
4149 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 254752"];
4150 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254753"];
4151 [label="param SyntaxTokenWithTrivia(GreenNode leading) 254754"];
4152 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 254755"];
4153 [label="param SyntaxTokenWithTrivia(this) 254756"];
4154 [label="kind 254757"];
4155 [label="param SyntaxTokenWithTrivia(this) 254758"];
4156 [label="param SyntaxToken(SyntaxKind kind) 254759"];
4157 [label="param SyntaxToken(this) 254760"];
4158 [label="kind 254761"];
4159 [label="param SyntaxToken(this) 254762"];
4160 [label="param CSharpSyntaxNode(SyntaxKind kind) 254763"];
4161 [label="param CSharpSyntaxNode(this) 254764"];
4162 [label="kind 254765"];
4163 [label="param CSharpSyntaxNode(this) 254766"];
4164 [label="param CSharpSyntaxNode(this) 254767"];
4165 [label="GreenStats.NoteGreen(this); 254768"];
4166 [label="GreenStats.NoteGreen(this); 254769"];
4167 [label="this.Text 254770"];
4168 [label="get { return SyntaxFacts.GetText(this.Kind); } 254771"];
4169 [label="this.Kind 254772"];
4170 [label="get { return (SyntaxKind)this.RawKind; } 254773"];
4171 [label="return (SyntaxKind)this.RawKind; 254774"];
4172 [label="return SyntaxFacts.GetText(this.Kind); 254775"];
4173 [label="SyntaxFacts.GetText(this.Kind) 254776"];
4174 [label="param GetText(SyntaxKind kind) 254777"];
4175 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254778"];
4176 [label="return '~'; 254779"];
4177 [label="FullWidth = this.Text.Length; 254780"];
4178 [label="FullWidth 254781"];
4179 [label="this.flags |= NodeFlags.IsNotMissing; 254782"];
4180 [label="this.flags 254783"];
4181 [label="LeadingField 254784"];
4182 [label="TrailingField 254785"];
4183 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254786"];
4184 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 254787"];
4185 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254788"];
4186 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 254789"];
4187 [label="this.AdjustFlagsAndWidth(trailing); 254790"];
4188 [label="this.AdjustFlagsAndWidth(trailing); 254791"];
4189 [label="this.TrailingField 254792"];
4190 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 254793"];
4191 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 254794"];
4192 [label="param SyntaxToken(SyntaxKind kind) 254795"];
4193 [label="kind 254796"];
4194 [label="param CSharpSyntaxNode(SyntaxKind kind) 254797"];
4195 [label="kind 254798"];
4196 [label="param CSharpSyntaxNode(this) 254799"];
4197 [label="GreenStats.NoteGreen(this); 254800"];
4198 [label="return (SyntaxKind)this.RawKind; 254801"];
4199 [label="return SyntaxFacts.GetText(this.Kind); 254802"];
4200 [label="param GetText(SyntaxKind kind) 254803"];
4201 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254804"];
4202 [label="return '!'; 254805"];
4203 [label="FullWidth = this.Text.Length; 254806"];
4204 [label="FullWidth 254807"];
4205 [label="this.flags |= NodeFlags.IsNotMissing; 254808"];
4206 [label="this.flags 254809"];
4207 [label="s_tokensWithNoTrivia[(int)kind].Value 254810"];
4208 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 254811"];
4209 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254812"];
4210 [label="kind 254813"];
4211 [label="param SyntaxToken(SyntaxKind kind) 254814"];
4212 [label="kind 254815"];
4213 [label="param CSharpSyntaxNode(SyntaxKind kind) 254816"];
4214 [label="kind 254817"];
4215 [label="param CSharpSyntaxNode(this) 254818"];
4216 [label="GreenStats.NoteGreen(this); 254819"];
4217 [label="return (SyntaxKind)this.RawKind; 254820"];
4218 [label="return SyntaxFacts.GetText(this.Kind); 254821"];
4219 [label="param GetText(SyntaxKind kind) 254822"];
4220 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254823"];
4221 [label="return '!'; 254824"];
4222 [label="FullWidth = this.Text.Length; 254825"];
4223 [label="FullWidth 254826"];
4224 [label="this.flags |= NodeFlags.IsNotMissing; 254827"];
4225 [label="this.flags 254828"];
4226 [label="this.AdjustFlagsAndWidth(leading); 254829"];
4227 [label="s_tokensWithElasticTrivia[(int)kind].Value 254830"];
4228 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 254831"];
4229 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254832"];
4230 [label="kind 254833"];
4231 [label="param SyntaxToken(SyntaxKind kind) 254834"];
4232 [label="kind 254835"];
4233 [label="param CSharpSyntaxNode(SyntaxKind kind) 254836"];
4234 [label="kind 254837"];
4235 [label="param CSharpSyntaxNode(this) 254838"];
4236 [label="GreenStats.NoteGreen(this); 254839"];
4237 [label="return (SyntaxKind)this.RawKind; 254840"];
4238 [label="return SyntaxFacts.GetText(this.Kind); 254841"];
4239 [label="param GetText(SyntaxKind kind) 254842"];
4240 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254843"];
4241 [label="return '!'; 254844"];
4242 [label="FullWidth = this.Text.Length; 254845"];
4243 [label="FullWidth 254846"];
4244 [label="this.flags |= NodeFlags.IsNotMissing; 254847"];
4245 [label="this.flags 254848"];
4246 [label="this.AdjustFlagsAndWidth(trailing); 254849"];
4247 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 254850"];
4248 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 254851"];
4249 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 254852"];
4250 [label="kind 254853"];
4251 [label="param SyntaxToken(SyntaxKind kind) 254854"];
4252 [label="kind 254855"];
4253 [label="param CSharpSyntaxNode(SyntaxKind kind) 254856"];
4254 [label="kind 254857"];
4255 [label="param CSharpSyntaxNode(this) 254858"];
4256 [label="GreenStats.NoteGreen(this); 254859"];
4257 [label="return (SyntaxKind)this.RawKind; 254860"];
4258 [label="return SyntaxFacts.GetText(this.Kind); 254861"];
4259 [label="param GetText(SyntaxKind kind) 254862"];
4260 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 254863"];
4261 [label="return '!'; 254864"];
4262 [label="FullWidth = this.Text.Length; 254865"];
4263 [label="FullWidth 254866"];
4264 [label="this.flags |= NodeFlags.IsNotMissing; 254867"];
4265 [label="this.flags 254868"];
4266 [label="this.AdjustFlagsAndWidth(trailing); 254869"];
4267 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 254870"];
4268 [label="return '$'; 254871"];
4269 [label="FullWidth = this.Text.Length; 254872"];
4270 [label="FullWidth 254873"];
4271 [label="return '$'; 254874"];
4272 [label="FullWidth = this.Text.Length; 254875"];
4273 [label="FullWidth 254876"];
4274 [label="this.AdjustFlagsAndWidth(leading); 254877"];
4275 [label="return '$'; 254878"];
4276 [label="FullWidth = this.Text.Length; 254879"];
4277 [label="FullWidth 254880"];
4278 [label="this.AdjustFlagsAndWidth(trailing); 254881"];
4279 [label="return '$'; 254882"];
4280 [label="FullWidth = this.Text.Length; 254883"];
4281 [label="FullWidth 254884"];
4282 [label="this.AdjustFlagsAndWidth(trailing); 254885"];
4283 [label="return '%'; 254886"];
4284 [label="FullWidth = this.Text.Length; 254887"];
4285 [label="FullWidth 254888"];
4286 [label="return '%'; 254889"];
4287 [label="FullWidth = this.Text.Length; 254890"];
4288 [label="FullWidth 254891"];
4289 [label="this.AdjustFlagsAndWidth(leading); 254892"];
4290 [label="return '%'; 254893"];
4291 [label="FullWidth = this.Text.Length; 254894"];
4292 [label="FullWidth 254895"];
4293 [label="this.AdjustFlagsAndWidth(trailing); 254896"];
4294 [label="return '%'; 254897"];
4295 [label="FullWidth = this.Text.Length; 254898"];
4296 [label="FullWidth 254899"];
4297 [label="this.AdjustFlagsAndWidth(trailing); 254900"];
4298 [label="return '^'; 254901"];
4299 [label="FullWidth = this.Text.Length; 254902"];
4300 [label="FullWidth 254903"];
4301 [label="return '^'; 254904"];
4302 [label="FullWidth = this.Text.Length; 254905"];
4303 [label="FullWidth 254906"];
4304 [label="this.AdjustFlagsAndWidth(leading); 254907"];
4305 [label="return '^'; 254908"];
4306 [label="FullWidth = this.Text.Length; 254909"];
4307 [label="FullWidth 254910"];
4308 [label="this.AdjustFlagsAndWidth(trailing); 254911"];
4309 [label="return '^'; 254912"];
4310 [label="FullWidth = this.Text.Length; 254913"];
4311 [label="FullWidth 254914"];
4312 [label="this.AdjustFlagsAndWidth(trailing); 254915"];
4313 [label="return '&'; 254916"];
4314 [label="FullWidth = this.Text.Length; 254917"];
4315 [label="FullWidth 254918"];
4316 [label="return '&'; 254919"];
4317 [label="FullWidth = this.Text.Length; 254920"];
4318 [label="FullWidth 254921"];
4319 [label="this.AdjustFlagsAndWidth(leading); 254922"];
4320 [label="return '&'; 254923"];
4321 [label="FullWidth = this.Text.Length; 254924"];
4322 [label="FullWidth 254925"];
4323 [label="this.AdjustFlagsAndWidth(trailing); 254926"];
4324 [label="return '&'; 254927"];
4325 [label="FullWidth = this.Text.Length; 254928"];
4326 [label="FullWidth 254929"];
4327 [label="this.AdjustFlagsAndWidth(trailing); 254930"];
4328 [label="return '*'; 254931"];
4329 [label="FullWidth = this.Text.Length; 254932"];
4330 [label="FullWidth 254933"];
4331 [label="return '*'; 254934"];
4332 [label="FullWidth = this.Text.Length; 254935"];
4333 [label="FullWidth 254936"];
4334 [label="this.AdjustFlagsAndWidth(leading); 254937"];
4335 [label="return '*'; 254938"];
4336 [label="FullWidth = this.Text.Length; 254939"];
4337 [label="FullWidth 254940"];
4338 [label="this.AdjustFlagsAndWidth(trailing); 254941"];
4339 [label="return '*'; 254942"];
4340 [label="FullWidth = this.Text.Length; 254943"];
4341 [label="FullWidth 254944"];
4342 [label="this.AdjustFlagsAndWidth(trailing); 254945"];
4343 [label="return '('; 254946"];
4344 [label="FullWidth = this.Text.Length; 254947"];
4345 [label="FullWidth 254948"];
4346 [label="return '('; 254949"];
4347 [label="FullWidth = this.Text.Length; 254950"];
4348 [label="FullWidth 254951"];
4349 [label="this.AdjustFlagsAndWidth(leading); 254952"];
4350 [label="return '('; 254953"];
4351 [label="FullWidth = this.Text.Length; 254954"];
4352 [label="FullWidth 254955"];
4353 [label="this.AdjustFlagsAndWidth(trailing); 254956"];
4354 [label="return '('; 254957"];
4355 [label="FullWidth = this.Text.Length; 254958"];
4356 [label="FullWidth 254959"];
4357 [label="this.AdjustFlagsAndWidth(trailing); 254960"];
4358 [label="return ')'; 254961"];
4359 [label="FullWidth = this.Text.Length; 254962"];
4360 [label="FullWidth 254963"];
4361 [label="return ')'; 254964"];
4362 [label="FullWidth = this.Text.Length; 254965"];
4363 [label="FullWidth 254966"];
4364 [label="this.AdjustFlagsAndWidth(leading); 254967"];
4365 [label="return ')'; 254968"];
4366 [label="FullWidth = this.Text.Length; 254969"];
4367 [label="FullWidth 254970"];
4368 [label="this.AdjustFlagsAndWidth(trailing); 254971"];
4369 [label="return ')'; 254972"];
4370 [label="FullWidth = this.Text.Length; 254973"];
4371 [label="FullWidth 254974"];
4372 [label="this.AdjustFlagsAndWidth(trailing); 254975"];
4373 [label="return '-'; 254976"];
4374 [label="FullWidth = this.Text.Length; 254977"];
4375 [label="FullWidth 254978"];
4376 [label="return '-'; 254979"];
4377 [label="FullWidth = this.Text.Length; 254980"];
4378 [label="FullWidth 254981"];
4379 [label="this.AdjustFlagsAndWidth(leading); 254982"];
4380 [label="return '-'; 254983"];
4381 [label="FullWidth = this.Text.Length; 254984"];
4382 [label="FullWidth 254985"];
4383 [label="this.AdjustFlagsAndWidth(trailing); 254986"];
4384 [label="return '-'; 254987"];
4385 [label="FullWidth = this.Text.Length; 254988"];
4386 [label="FullWidth 254989"];
4387 [label="this.AdjustFlagsAndWidth(trailing); 254990"];
4388 [label="return '+'; 254991"];
4389 [label="FullWidth = this.Text.Length; 254992"];
4390 [label="FullWidth 254993"];
4391 [label="return '+'; 254994"];
4392 [label="FullWidth = this.Text.Length; 254995"];
4393 [label="FullWidth 254996"];
4394 [label="this.AdjustFlagsAndWidth(leading); 254997"];
4395 [label="return '+'; 254998"];
4396 [label="FullWidth = this.Text.Length; 254999"];
4397 [label="FullWidth 255000"];
4398 [label="this.AdjustFlagsAndWidth(trailing); 255001"];
4399 [label="return '+'; 255002"];
4400 [label="FullWidth = this.Text.Length; 255003"];
4401 [label="FullWidth 255004"];
4402 [label="this.AdjustFlagsAndWidth(trailing); 255005"];
4403 [label="return '='; 255006"];
4404 [label="FullWidth = this.Text.Length; 255007"];
4405 [label="FullWidth 255008"];
4406 [label="return '='; 255009"];
4407 [label="FullWidth = this.Text.Length; 255010"];
4408 [label="FullWidth 255011"];
4409 [label="this.AdjustFlagsAndWidth(leading); 255012"];
4410 [label="return '='; 255013"];
4411 [label="FullWidth = this.Text.Length; 255014"];
4412 [label="FullWidth 255015"];
4413 [label="this.AdjustFlagsAndWidth(trailing); 255016"];
4414 [label="return '='; 255017"];
4415 [label="FullWidth = this.Text.Length; 255018"];
4416 [label="FullWidth 255019"];
4417 [label="this.AdjustFlagsAndWidth(trailing); 255020"];
4418 [label="return '{'; 255021"];
4419 [label="FullWidth = this.Text.Length; 255022"];
4420 [label="FullWidth 255023"];
4421 [label="return '{'; 255024"];
4422 [label="FullWidth = this.Text.Length; 255025"];
4423 [label="FullWidth 255026"];
4424 [label="this.AdjustFlagsAndWidth(leading); 255027"];
4425 [label="return '{'; 255028"];
4426 [label="FullWidth = this.Text.Length; 255029"];
4427 [label="FullWidth 255030"];
4428 [label="this.AdjustFlagsAndWidth(trailing); 255031"];
4429 [label="return '{'; 255032"];
4430 [label="FullWidth = this.Text.Length; 255033"];
4431 [label="FullWidth 255034"];
4432 [label="this.AdjustFlagsAndWidth(trailing); 255035"];
4433 [label="return '}'; 255036"];
4434 [label="FullWidth = this.Text.Length; 255037"];
4435 [label="FullWidth 255038"];
4436 [label="return '}'; 255039"];
4437 [label="FullWidth = this.Text.Length; 255040"];
4438 [label="FullWidth 255041"];
4439 [label="this.AdjustFlagsAndWidth(leading); 255042"];
4440 [label="return '}'; 255043"];
4441 [label="FullWidth = this.Text.Length; 255044"];
4442 [label="FullWidth 255045"];
4443 [label="this.AdjustFlagsAndWidth(trailing); 255046"];
4444 [label="return '}'; 255047"];
4445 [label="FullWidth = this.Text.Length; 255048"];
4446 [label="FullWidth 255049"];
4447 [label="this.AdjustFlagsAndWidth(trailing); 255050"];
4448 [label="return '['; 255051"];
4449 [label="FullWidth = this.Text.Length; 255052"];
4450 [label="FullWidth 255053"];
4451 [label="return '['; 255054"];
4452 [label="FullWidth = this.Text.Length; 255055"];
4453 [label="FullWidth 255056"];
4454 [label="this.AdjustFlagsAndWidth(leading); 255057"];
4455 [label="return '['; 255058"];
4456 [label="FullWidth = this.Text.Length; 255059"];
4457 [label="FullWidth 255060"];
4458 [label="this.AdjustFlagsAndWidth(trailing); 255061"];
4459 [label="return '['; 255062"];
4460 [label="FullWidth = this.Text.Length; 255063"];
4461 [label="FullWidth 255064"];
4462 [label="this.AdjustFlagsAndWidth(trailing); 255065"];
4463 [label="return ']'; 255066"];
4464 [label="FullWidth = this.Text.Length; 255067"];
4465 [label="FullWidth 255068"];
4466 [label="return ']'; 255069"];
4467 [label="FullWidth = this.Text.Length; 255070"];
4468 [label="FullWidth 255071"];
4469 [label="this.AdjustFlagsAndWidth(leading); 255072"];
4470 [label="return ']'; 255073"];
4471 [label="FullWidth = this.Text.Length; 255074"];
4472 [label="FullWidth 255075"];
4473 [label="this.AdjustFlagsAndWidth(trailing); 255076"];
4474 [label="return ']'; 255077"];
4475 [label="FullWidth = this.Text.Length; 255078"];
4476 [label="FullWidth 255079"];
4477 [label="this.AdjustFlagsAndWidth(trailing); 255080"];
4478 [label="return '|'; 255081"];
4479 [label="FullWidth = this.Text.Length; 255082"];
4480 [label="FullWidth 255083"];
4481 [label="return '|'; 255084"];
4482 [label="FullWidth = this.Text.Length; 255085"];
4483 [label="FullWidth 255086"];
4484 [label="this.AdjustFlagsAndWidth(leading); 255087"];
4485 [label="return '|'; 255088"];
4486 [label="FullWidth = this.Text.Length; 255089"];
4487 [label="FullWidth 255090"];
4488 [label="this.AdjustFlagsAndWidth(trailing); 255091"];
4489 [label="return '|'; 255092"];
4490 [label="FullWidth = this.Text.Length; 255093"];
4491 [label="FullWidth 255094"];
4492 [label="this.AdjustFlagsAndWidth(trailing); 255095"];
4493 [label="return '\\\\'; 255096"];
4494 [label="FullWidth = this.Text.Length; 255097"];
4495 [label="FullWidth 255098"];
4496 [label="return '\\\\'; 255099"];
4497 [label="FullWidth = this.Text.Length; 255100"];
4498 [label="FullWidth 255101"];
4499 [label="this.AdjustFlagsAndWidth(leading); 255102"];
4500 [label="return '\\\\'; 255103"];
4501 [label="FullWidth = this.Text.Length; 255104"];
4502 [label="FullWidth 255105"];
4503 [label="this.AdjustFlagsAndWidth(trailing); 255106"];
4504 [label="return '\\\\'; 255107"];
4505 [label="FullWidth = this.Text.Length; 255108"];
4506 [label="FullWidth 255109"];
4507 [label="this.AdjustFlagsAndWidth(trailing); 255110"];
4508 [label="return ':'; 255111"];
4509 [label="FullWidth = this.Text.Length; 255112"];
4510 [label="FullWidth 255113"];
4511 [label="return ':'; 255114"];
4512 [label="FullWidth = this.Text.Length; 255115"];
4513 [label="FullWidth 255116"];
4514 [label="this.AdjustFlagsAndWidth(leading); 255117"];
4515 [label="return ':'; 255118"];
4516 [label="FullWidth = this.Text.Length; 255119"];
4517 [label="FullWidth 255120"];
4518 [label="this.AdjustFlagsAndWidth(trailing); 255121"];
4519 [label="return ':'; 255122"];
4520 [label="FullWidth = this.Text.Length; 255123"];
4521 [label="FullWidth 255124"];
4522 [label="this.AdjustFlagsAndWidth(trailing); 255125"];
4523 [label="return ';'; 255126"];
4524 [label="FullWidth = this.Text.Length; 255127"];
4525 [label="FullWidth 255128"];
4526 [label="return ';'; 255129"];
4527 [label="FullWidth = this.Text.Length; 255130"];
4528 [label="FullWidth 255131"];
4529 [label="this.AdjustFlagsAndWidth(leading); 255132"];
4530 [label="return ';'; 255133"];
4531 [label="FullWidth = this.Text.Length; 255134"];
4532 [label="FullWidth 255135"];
4533 [label="this.AdjustFlagsAndWidth(trailing); 255136"];
4534 [label="return ';'; 255137"];
4535 [label="FullWidth = this.Text.Length; 255138"];
4536 [label="FullWidth 255139"];
4537 [label="this.AdjustFlagsAndWidth(trailing); 255140"];
4538 [label="return '\\''; 255141"];
4539 [label="FullWidth = this.Text.Length; 255142"];
4540 [label="FullWidth 255143"];
4541 [label="return '\\''; 255144"];
4542 [label="FullWidth = this.Text.Length; 255145"];
4543 [label="FullWidth 255146"];
4544 [label="this.AdjustFlagsAndWidth(leading); 255147"];
4545 [label="return '\\''; 255148"];
4546 [label="FullWidth = this.Text.Length; 255149"];
4547 [label="FullWidth 255150"];
4548 [label="this.AdjustFlagsAndWidth(trailing); 255151"];
4549 [label="return '\\''; 255152"];
4550 [label="FullWidth = this.Text.Length; 255153"];
4551 [label="FullWidth 255154"];
4552 [label="this.AdjustFlagsAndWidth(trailing); 255155"];
4553 [label="return '''; 255156"];
4554 [label="FullWidth = this.Text.Length; 255157"];
4555 [label="FullWidth 255158"];
4556 [label="return '''; 255159"];
4557 [label="FullWidth = this.Text.Length; 255160"];
4558 [label="FullWidth 255161"];
4559 [label="this.AdjustFlagsAndWidth(leading); 255162"];
4560 [label="return '''; 255163"];
4561 [label="FullWidth = this.Text.Length; 255164"];
4562 [label="FullWidth 255165"];
4563 [label="this.AdjustFlagsAndWidth(trailing); 255166"];
4564 [label="return '''; 255167"];
4565 [label="FullWidth = this.Text.Length; 255168"];
4566 [label="FullWidth 255169"];
4567 [label="this.AdjustFlagsAndWidth(trailing); 255170"];
4568 [label="return '<'; 255171"];
4569 [label="FullWidth = this.Text.Length; 255172"];
4570 [label="FullWidth 255173"];
4571 [label="return '<'; 255174"];
4572 [label="FullWidth = this.Text.Length; 255175"];
4573 [label="FullWidth 255176"];
4574 [label="this.AdjustFlagsAndWidth(leading); 255177"];
4575 [label="return '<'; 255178"];
4576 [label="FullWidth = this.Text.Length; 255179"];
4577 [label="FullWidth 255180"];
4578 [label="this.AdjustFlagsAndWidth(trailing); 255181"];
4579 [label="return '<'; 255182"];
4580 [label="FullWidth = this.Text.Length; 255183"];
4581 [label="FullWidth 255184"];
4582 [label="this.AdjustFlagsAndWidth(trailing); 255185"];
4583 [label="return ','; 255186"];
4584 [label="FullWidth = this.Text.Length; 255187"];
4585 [label="FullWidth 255188"];
4586 [label="return ','; 255189"];
4587 [label="FullWidth = this.Text.Length; 255190"];
4588 [label="FullWidth 255191"];
4589 [label="this.AdjustFlagsAndWidth(leading); 255192"];
4590 [label="return ','; 255193"];
4591 [label="FullWidth = this.Text.Length; 255194"];
4592 [label="FullWidth 255195"];
4593 [label="this.AdjustFlagsAndWidth(trailing); 255196"];
4594 [label="return ','; 255197"];
4595 [label="FullWidth = this.Text.Length; 255198"];
4596 [label="FullWidth 255199"];
4597 [label="this.AdjustFlagsAndWidth(trailing); 255200"];
4598 [label="return '>'; 255201"];
4599 [label="FullWidth = this.Text.Length; 255202"];
4600 [label="FullWidth 255203"];
4601 [label="return '>'; 255204"];
4602 [label="FullWidth = this.Text.Length; 255205"];
4603 [label="FullWidth 255206"];
4604 [label="this.AdjustFlagsAndWidth(leading); 255207"];
4605 [label="return '>'; 255208"];
4606 [label="FullWidth = this.Text.Length; 255209"];
4607 [label="FullWidth 255210"];
4608 [label="this.AdjustFlagsAndWidth(trailing); 255211"];
4609 [label="return '>'; 255212"];
4610 [label="FullWidth = this.Text.Length; 255213"];
4611 [label="FullWidth 255214"];
4612 [label="this.AdjustFlagsAndWidth(trailing); 255215"];
4613 [label="return '.'; 255216"];
4614 [label="FullWidth = this.Text.Length; 255217"];
4615 [label="FullWidth 255218"];
4616 [label="return '.'; 255219"];
4617 [label="FullWidth = this.Text.Length; 255220"];
4618 [label="FullWidth 255221"];
4619 [label="this.AdjustFlagsAndWidth(leading); 255222"];
4620 [label="return '.'; 255223"];
4621 [label="FullWidth = this.Text.Length; 255224"];
4622 [label="FullWidth 255225"];
4623 [label="this.AdjustFlagsAndWidth(trailing); 255226"];
4624 [label="return '.'; 255227"];
4625 [label="FullWidth = this.Text.Length; 255228"];
4626 [label="FullWidth 255229"];
4627 [label="this.AdjustFlagsAndWidth(trailing); 255230"];
4628 [label="return '?'; 255231"];
4629 [label="FullWidth = this.Text.Length; 255232"];
4630 [label="FullWidth 255233"];
4631 [label="return '?'; 255234"];
4632 [label="FullWidth = this.Text.Length; 255235"];
4633 [label="FullWidth 255236"];
4634 [label="this.AdjustFlagsAndWidth(leading); 255237"];
4635 [label="return '?'; 255238"];
4636 [label="FullWidth = this.Text.Length; 255239"];
4637 [label="FullWidth 255240"];
4638 [label="this.AdjustFlagsAndWidth(trailing); 255241"];
4639 [label="return '?'; 255242"];
4640 [label="FullWidth = this.Text.Length; 255243"];
4641 [label="FullWidth 255244"];
4642 [label="this.AdjustFlagsAndWidth(trailing); 255245"];
4643 [label="return '#'; 255246"];
4644 [label="FullWidth = this.Text.Length; 255247"];
4645 [label="FullWidth 255248"];
4646 [label="return '#'; 255249"];
4647 [label="FullWidth = this.Text.Length; 255250"];
4648 [label="FullWidth 255251"];
4649 [label="this.AdjustFlagsAndWidth(leading); 255252"];
4650 [label="return '#'; 255253"];
4651 [label="FullWidth = this.Text.Length; 255254"];
4652 [label="FullWidth 255255"];
4653 [label="this.AdjustFlagsAndWidth(trailing); 255256"];
4654 [label="return '#'; 255257"];
4655 [label="FullWidth = this.Text.Length; 255258"];
4656 [label="FullWidth 255259"];
4657 [label="this.AdjustFlagsAndWidth(trailing); 255260"];
4658 [label="return '/'; 255261"];
4659 [label="FullWidth = this.Text.Length; 255262"];
4660 [label="FullWidth 255263"];
4661 [label="return '/'; 255264"];
4662 [label="FullWidth = this.Text.Length; 255265"];
4663 [label="FullWidth 255266"];
4664 [label="this.AdjustFlagsAndWidth(leading); 255267"];
4665 [label="return '/'; 255268"];
4666 [label="FullWidth = this.Text.Length; 255269"];
4667 [label="FullWidth 255270"];
4668 [label="this.AdjustFlagsAndWidth(trailing); 255271"];
4669 [label="return '/'; 255272"];
4670 [label="FullWidth = this.Text.Length; 255273"];
4671 [label="FullWidth 255274"];
4672 [label="this.AdjustFlagsAndWidth(trailing); 255275"];
4673 [label="return '..'; 255276"];
4674 [label="FullWidth = this.Text.Length; 255277"];
4675 [label="FullWidth 255278"];
4676 [label="return '..'; 255279"];
4677 [label="FullWidth = this.Text.Length; 255280"];
4678 [label="FullWidth 255281"];
4679 [label="this.AdjustFlagsAndWidth(leading); 255282"];
4680 [label="return '..'; 255283"];
4681 [label="FullWidth = this.Text.Length; 255284"];
4682 [label="FullWidth 255285"];
4683 [label="this.AdjustFlagsAndWidth(trailing); 255286"];
4684 [label="return '..'; 255287"];
4685 [label="FullWidth = this.Text.Length; 255288"];
4686 [label="FullWidth 255289"];
4687 [label="this.AdjustFlagsAndWidth(trailing); 255290"];
4688 [label="return string.Empty; 255291"];
4689 [label="FullWidth = this.Text.Length; 255292"];
4690 [label="FullWidth 255293"];
4691 [label="return string.Empty; 255294"];
4692 [label="FullWidth = this.Text.Length; 255295"];
4693 [label="FullWidth 255296"];
4694 [label="this.AdjustFlagsAndWidth(leading); 255297"];
4695 [label="return string.Empty; 255298"];
4696 [label="FullWidth = this.Text.Length; 255299"];
4697 [label="FullWidth 255300"];
4698 [label="this.AdjustFlagsAndWidth(trailing); 255301"];
4699 [label="return string.Empty; 255302"];
4700 [label="FullWidth = this.Text.Length; 255303"];
4701 [label="FullWidth 255304"];
4702 [label="this.AdjustFlagsAndWidth(trailing); 255305"];
4703 [label="return '/>'; 255306"];
4704 [label="FullWidth = this.Text.Length; 255307"];
4705 [label="FullWidth 255308"];
4706 [label="return '/>'; 255309"];
4707 [label="FullWidth = this.Text.Length; 255310"];
4708 [label="FullWidth 255311"];
4709 [label="this.AdjustFlagsAndWidth(leading); 255312"];
4710 [label="return '/>'; 255313"];
4711 [label="FullWidth = this.Text.Length; 255314"];
4712 [label="FullWidth 255315"];
4713 [label="this.AdjustFlagsAndWidth(trailing); 255316"];
4714 [label="return '/>'; 255317"];
4715 [label="FullWidth = this.Text.Length; 255318"];
4716 [label="FullWidth 255319"];
4717 [label="this.AdjustFlagsAndWidth(trailing); 255320"];
4718 [label="return '</'; 255321"];
4719 [label="FullWidth = this.Text.Length; 255322"];
4720 [label="FullWidth 255323"];
4721 [label="return '</'; 255324"];
4722 [label="FullWidth = this.Text.Length; 255325"];
4723 [label="FullWidth 255326"];
4724 [label="this.AdjustFlagsAndWidth(leading); 255327"];
4725 [label="return '</'; 255328"];
4726 [label="FullWidth = this.Text.Length; 255329"];
4727 [label="FullWidth 255330"];
4728 [label="this.AdjustFlagsAndWidth(trailing); 255331"];
4729 [label="return '</'; 255332"];
4730 [label="FullWidth = this.Text.Length; 255333"];
4731 [label="FullWidth 255334"];
4732 [label="this.AdjustFlagsAndWidth(trailing); 255335"];
4733 [label="return '<!--'; 255336"];
4734 [label="FullWidth = this.Text.Length; 255337"];
4735 [label="FullWidth 255338"];
4736 [label="return '<!--'; 255339"];
4737 [label="FullWidth = this.Text.Length; 255340"];
4738 [label="FullWidth 255341"];
4739 [label="this.AdjustFlagsAndWidth(leading); 255342"];
4740 [label="return '<!--'; 255343"];
4741 [label="FullWidth = this.Text.Length; 255344"];
4742 [label="FullWidth 255345"];
4743 [label="this.AdjustFlagsAndWidth(trailing); 255346"];
4744 [label="return '<!--'; 255347"];
4745 [label="FullWidth = this.Text.Length; 255348"];
4746 [label="FullWidth 255349"];
4747 [label="this.AdjustFlagsAndWidth(trailing); 255350"];
4748 [label="return '-->'; 255351"];
4749 [label="FullWidth = this.Text.Length; 255352"];
4750 [label="FullWidth 255353"];
4751 [label="return '-->'; 255354"];
4752 [label="FullWidth = this.Text.Length; 255355"];
4753 [label="FullWidth 255356"];
4754 [label="this.AdjustFlagsAndWidth(leading); 255357"];
4755 [label="return '-->'; 255358"];
4756 [label="FullWidth = this.Text.Length; 255359"];
4757 [label="FullWidth 255360"];
4758 [label="this.AdjustFlagsAndWidth(trailing); 255361"];
4759 [label="return '-->'; 255362"];
4760 [label="FullWidth = this.Text.Length; 255363"];
4761 [label="FullWidth 255364"];
4762 [label="this.AdjustFlagsAndWidth(trailing); 255365"];
4763 [label="return '<![CDATA['; 255366"];
4764 [label="FullWidth = this.Text.Length; 255367"];
4765 [label="FullWidth 255368"];
4766 [label="return '<![CDATA['; 255369"];
4767 [label="FullWidth = this.Text.Length; 255370"];
4768 [label="FullWidth 255371"];
4769 [label="this.AdjustFlagsAndWidth(leading); 255372"];
4770 [label="return '<![CDATA['; 255373"];
4771 [label="FullWidth = this.Text.Length; 255374"];
4772 [label="FullWidth 255375"];
4773 [label="this.AdjustFlagsAndWidth(trailing); 255376"];
4774 [label="return '<![CDATA['; 255377"];
4775 [label="FullWidth = this.Text.Length; 255378"];
4776 [label="FullWidth 255379"];
4777 [label="this.AdjustFlagsAndWidth(trailing); 255380"];
4778 [label="return ']]>'; 255381"];
4779 [label="FullWidth = this.Text.Length; 255382"];
4780 [label="FullWidth 255383"];
4781 [label="return ']]>'; 255384"];
4782 [label="FullWidth = this.Text.Length; 255385"];
4783 [label="FullWidth 255386"];
4784 [label="this.AdjustFlagsAndWidth(leading); 255387"];
4785 [label="return ']]>'; 255388"];
4786 [label="FullWidth = this.Text.Length; 255389"];
4787 [label="FullWidth 255390"];
4788 [label="this.AdjustFlagsAndWidth(trailing); 255391"];
4789 [label="return ']]>'; 255392"];
4790 [label="FullWidth = this.Text.Length; 255393"];
4791 [label="FullWidth 255394"];
4792 [label="this.AdjustFlagsAndWidth(trailing); 255395"];
4793 [label="return '<?'; 255396"];
4794 [label="FullWidth = this.Text.Length; 255397"];
4795 [label="FullWidth 255398"];
4796 [label="return '<?'; 255399"];
4797 [label="FullWidth = this.Text.Length; 255400"];
4798 [label="FullWidth 255401"];
4799 [label="this.AdjustFlagsAndWidth(leading); 255402"];
4800 [label="return '<?'; 255403"];
4801 [label="FullWidth = this.Text.Length; 255404"];
4802 [label="FullWidth 255405"];
4803 [label="this.AdjustFlagsAndWidth(trailing); 255406"];
4804 [label="return '<?'; 255407"];
4805 [label="FullWidth = this.Text.Length; 255408"];
4806 [label="FullWidth 255409"];
4807 [label="this.AdjustFlagsAndWidth(trailing); 255410"];
4808 [label="return '?>'; 255411"];
4809 [label="FullWidth = this.Text.Length; 255412"];
4810 [label="FullWidth 255413"];
4811 [label="return '?>'; 255414"];
4812 [label="FullWidth = this.Text.Length; 255415"];
4813 [label="FullWidth 255416"];
4814 [label="this.AdjustFlagsAndWidth(leading); 255417"];
4815 [label="return '?>'; 255418"];
4816 [label="FullWidth = this.Text.Length; 255419"];
4817 [label="FullWidth 255420"];
4818 [label="this.AdjustFlagsAndWidth(trailing); 255421"];
4819 [label="return '?>'; 255422"];
4820 [label="FullWidth = this.Text.Length; 255423"];
4821 [label="FullWidth 255424"];
4822 [label="this.AdjustFlagsAndWidth(trailing); 255425"];
4823 [label="return '||'; 255426"];
4824 [label="FullWidth = this.Text.Length; 255427"];
4825 [label="FullWidth 255428"];
4826 [label="return '||'; 255429"];
4827 [label="FullWidth = this.Text.Length; 255430"];
4828 [label="FullWidth 255431"];
4829 [label="this.AdjustFlagsAndWidth(leading); 255432"];
4830 [label="return '||'; 255433"];
4831 [label="FullWidth = this.Text.Length; 255434"];
4832 [label="FullWidth 255435"];
4833 [label="this.AdjustFlagsAndWidth(trailing); 255436"];
4834 [label="return '||'; 255437"];
4835 [label="FullWidth = this.Text.Length; 255438"];
4836 [label="FullWidth 255439"];
4837 [label="this.AdjustFlagsAndWidth(trailing); 255440"];
4838 [label="return '&&'; 255441"];
4839 [label="FullWidth = this.Text.Length; 255442"];
4840 [label="FullWidth 255443"];
4841 [label="return '&&'; 255444"];
4842 [label="FullWidth = this.Text.Length; 255445"];
4843 [label="FullWidth 255446"];
4844 [label="this.AdjustFlagsAndWidth(leading); 255447"];
4845 [label="return '&&'; 255448"];
4846 [label="FullWidth = this.Text.Length; 255449"];
4847 [label="FullWidth 255450"];
4848 [label="this.AdjustFlagsAndWidth(trailing); 255451"];
4849 [label="return '&&'; 255452"];
4850 [label="FullWidth = this.Text.Length; 255453"];
4851 [label="FullWidth 255454"];
4852 [label="this.AdjustFlagsAndWidth(trailing); 255455"];
4853 [label="return '--'; 255456"];
4854 [label="FullWidth = this.Text.Length; 255457"];
4855 [label="FullWidth 255458"];
4856 [label="return '--'; 255459"];
4857 [label="FullWidth = this.Text.Length; 255460"];
4858 [label="FullWidth 255461"];
4859 [label="this.AdjustFlagsAndWidth(leading); 255462"];
4860 [label="return '--'; 255463"];
4861 [label="FullWidth = this.Text.Length; 255464"];
4862 [label="FullWidth 255465"];
4863 [label="this.AdjustFlagsAndWidth(trailing); 255466"];
4864 [label="return '--'; 255467"];
4865 [label="FullWidth = this.Text.Length; 255468"];
4866 [label="FullWidth 255469"];
4867 [label="this.AdjustFlagsAndWidth(trailing); 255470"];
4868 [label="return '++'; 255471"];
4869 [label="FullWidth = this.Text.Length; 255472"];
4870 [label="FullWidth 255473"];
4871 [label="return '++'; 255474"];
4872 [label="FullWidth = this.Text.Length; 255475"];
4873 [label="FullWidth 255476"];
4874 [label="this.AdjustFlagsAndWidth(leading); 255477"];
4875 [label="return '++'; 255478"];
4876 [label="FullWidth = this.Text.Length; 255479"];
4877 [label="FullWidth 255480"];
4878 [label="this.AdjustFlagsAndWidth(trailing); 255481"];
4879 [label="return '++'; 255482"];
4880 [label="FullWidth = this.Text.Length; 255483"];
4881 [label="FullWidth 255484"];
4882 [label="this.AdjustFlagsAndWidth(trailing); 255485"];
4883 [label="return '::'; 255486"];
4884 [label="FullWidth = this.Text.Length; 255487"];
4885 [label="FullWidth 255488"];
4886 [label="return '::'; 255489"];
4887 [label="FullWidth = this.Text.Length; 255490"];
4888 [label="FullWidth 255491"];
4889 [label="this.AdjustFlagsAndWidth(leading); 255492"];
4890 [label="return '::'; 255493"];
4891 [label="FullWidth = this.Text.Length; 255494"];
4892 [label="FullWidth 255495"];
4893 [label="this.AdjustFlagsAndWidth(trailing); 255496"];
4894 [label="return '::'; 255497"];
4895 [label="FullWidth = this.Text.Length; 255498"];
4896 [label="FullWidth 255499"];
4897 [label="this.AdjustFlagsAndWidth(trailing); 255500"];
4898 [label="return '??'; 255501"];
4899 [label="FullWidth = this.Text.Length; 255502"];
4900 [label="FullWidth 255503"];
4901 [label="return '??'; 255504"];
4902 [label="FullWidth = this.Text.Length; 255505"];
4903 [label="FullWidth 255506"];
4904 [label="this.AdjustFlagsAndWidth(leading); 255507"];
4905 [label="return '??'; 255508"];
4906 [label="FullWidth = this.Text.Length; 255509"];
4907 [label="FullWidth 255510"];
4908 [label="this.AdjustFlagsAndWidth(trailing); 255511"];
4909 [label="return '??'; 255512"];
4910 [label="FullWidth = this.Text.Length; 255513"];
4911 [label="FullWidth 255514"];
4912 [label="this.AdjustFlagsAndWidth(trailing); 255515"];
4913 [label="return '->'; 255516"];
4914 [label="FullWidth = this.Text.Length; 255517"];
4915 [label="FullWidth 255518"];
4916 [label="return '->'; 255519"];
4917 [label="FullWidth = this.Text.Length; 255520"];
4918 [label="FullWidth 255521"];
4919 [label="this.AdjustFlagsAndWidth(leading); 255522"];
4920 [label="return '->'; 255523"];
4921 [label="FullWidth = this.Text.Length; 255524"];
4922 [label="FullWidth 255525"];
4923 [label="this.AdjustFlagsAndWidth(trailing); 255526"];
4924 [label="return '->'; 255527"];
4925 [label="FullWidth = this.Text.Length; 255528"];
4926 [label="FullWidth 255529"];
4927 [label="this.AdjustFlagsAndWidth(trailing); 255530"];
4928 [label="return '!='; 255531"];
4929 [label="FullWidth = this.Text.Length; 255532"];
4930 [label="FullWidth 255533"];
4931 [label="return '!='; 255534"];
4932 [label="FullWidth = this.Text.Length; 255535"];
4933 [label="FullWidth 255536"];
4934 [label="this.AdjustFlagsAndWidth(leading); 255537"];
4935 [label="return '!='; 255538"];
4936 [label="FullWidth = this.Text.Length; 255539"];
4937 [label="FullWidth 255540"];
4938 [label="this.AdjustFlagsAndWidth(trailing); 255541"];
4939 [label="return '!='; 255542"];
4940 [label="FullWidth = this.Text.Length; 255543"];
4941 [label="FullWidth 255544"];
4942 [label="this.AdjustFlagsAndWidth(trailing); 255545"];
4943 [label="return '=='; 255546"];
4944 [label="FullWidth = this.Text.Length; 255547"];
4945 [label="FullWidth 255548"];
4946 [label="return '=='; 255549"];
4947 [label="FullWidth = this.Text.Length; 255550"];
4948 [label="FullWidth 255551"];
4949 [label="this.AdjustFlagsAndWidth(leading); 255552"];
4950 [label="return '=='; 255553"];
4951 [label="FullWidth = this.Text.Length; 255554"];
4952 [label="FullWidth 255555"];
4953 [label="this.AdjustFlagsAndWidth(trailing); 255556"];
4954 [label="return '=='; 255557"];
4955 [label="FullWidth = this.Text.Length; 255558"];
4956 [label="FullWidth 255559"];
4957 [label="this.AdjustFlagsAndWidth(trailing); 255560"];
4958 [label="return '=>'; 255561"];
4959 [label="FullWidth = this.Text.Length; 255562"];
4960 [label="FullWidth 255563"];
4961 [label="return '=>'; 255564"];
4962 [label="FullWidth = this.Text.Length; 255565"];
4963 [label="FullWidth 255566"];
4964 [label="this.AdjustFlagsAndWidth(leading); 255567"];
4965 [label="return '=>'; 255568"];
4966 [label="FullWidth = this.Text.Length; 255569"];
4967 [label="FullWidth 255570"];
4968 [label="this.AdjustFlagsAndWidth(trailing); 255571"];
4969 [label="return '=>'; 255572"];
4970 [label="FullWidth = this.Text.Length; 255573"];
4971 [label="FullWidth 255574"];
4972 [label="this.AdjustFlagsAndWidth(trailing); 255575"];
4973 [label="return '<='; 255576"];
4974 [label="FullWidth = this.Text.Length; 255577"];
4975 [label="FullWidth 255578"];
4976 [label="return '<='; 255579"];
4977 [label="FullWidth = this.Text.Length; 255580"];
4978 [label="FullWidth 255581"];
4979 [label="this.AdjustFlagsAndWidth(leading); 255582"];
4980 [label="return '<='; 255583"];
4981 [label="FullWidth = this.Text.Length; 255584"];
4982 [label="FullWidth 255585"];
4983 [label="this.AdjustFlagsAndWidth(trailing); 255586"];
4984 [label="return '<='; 255587"];
4985 [label="FullWidth = this.Text.Length; 255588"];
4986 [label="FullWidth 255589"];
4987 [label="this.AdjustFlagsAndWidth(trailing); 255590"];
4988 [label="return '<<'; 255591"];
4989 [label="FullWidth = this.Text.Length; 255592"];
4990 [label="FullWidth 255593"];
4991 [label="return '<<'; 255594"];
4992 [label="FullWidth = this.Text.Length; 255595"];
4993 [label="FullWidth 255596"];
4994 [label="this.AdjustFlagsAndWidth(leading); 255597"];
4995 [label="return '<<'; 255598"];
4996 [label="FullWidth = this.Text.Length; 255599"];
4997 [label="FullWidth 255600"];
4998 [label="this.AdjustFlagsAndWidth(trailing); 255601"];
4999 [label="return '<<'; 255602"];
5000 [label="FullWidth = this.Text.Length; 255603"];
5001 [label="FullWidth 255604"];
5002 [label="this.AdjustFlagsAndWidth(trailing); 255605"];
5003 [label="return '<<='; 255606"];
5004 [label="FullWidth = this.Text.Length; 255607"];
5005 [label="FullWidth 255608"];
5006 [label="return '<<='; 255609"];
5007 [label="FullWidth = this.Text.Length; 255610"];
5008 [label="FullWidth 255611"];
5009 [label="this.AdjustFlagsAndWidth(leading); 255612"];
5010 [label="return '<<='; 255613"];
5011 [label="FullWidth = this.Text.Length; 255614"];
5012 [label="FullWidth 255615"];
5013 [label="this.AdjustFlagsAndWidth(trailing); 255616"];
5014 [label="return '<<='; 255617"];
5015 [label="FullWidth = this.Text.Length; 255618"];
5016 [label="FullWidth 255619"];
5017 [label="this.AdjustFlagsAndWidth(trailing); 255620"];
5018 [label="return '>='; 255621"];
5019 [label="FullWidth = this.Text.Length; 255622"];
5020 [label="FullWidth 255623"];
5021 [label="return '>='; 255624"];
5022 [label="FullWidth = this.Text.Length; 255625"];
5023 [label="FullWidth 255626"];
5024 [label="this.AdjustFlagsAndWidth(leading); 255627"];
5025 [label="return '>='; 255628"];
5026 [label="FullWidth = this.Text.Length; 255629"];
5027 [label="FullWidth 255630"];
5028 [label="this.AdjustFlagsAndWidth(trailing); 255631"];
5029 [label="return '>='; 255632"];
5030 [label="FullWidth = this.Text.Length; 255633"];
5031 [label="FullWidth 255634"];
5032 [label="this.AdjustFlagsAndWidth(trailing); 255635"];
5033 [label="return '>>'; 255636"];
5034 [label="FullWidth = this.Text.Length; 255637"];
5035 [label="FullWidth 255638"];
5036 [label="return '>>'; 255639"];
5037 [label="FullWidth = this.Text.Length; 255640"];
5038 [label="FullWidth 255641"];
5039 [label="this.AdjustFlagsAndWidth(leading); 255642"];
5040 [label="return '>>'; 255643"];
5041 [label="FullWidth = this.Text.Length; 255644"];
5042 [label="FullWidth 255645"];
5043 [label="this.AdjustFlagsAndWidth(trailing); 255646"];
5044 [label="return '>>'; 255647"];
5045 [label="FullWidth = this.Text.Length; 255648"];
5046 [label="FullWidth 255649"];
5047 [label="this.AdjustFlagsAndWidth(trailing); 255650"];
5048 [label="return '>>='; 255651"];
5049 [label="FullWidth = this.Text.Length; 255652"];
5050 [label="FullWidth 255653"];
5051 [label="return '>>='; 255654"];
5052 [label="FullWidth = this.Text.Length; 255655"];
5053 [label="FullWidth 255656"];
5054 [label="this.AdjustFlagsAndWidth(leading); 255657"];
5055 [label="return '>>='; 255658"];
5056 [label="FullWidth = this.Text.Length; 255659"];
5057 [label="FullWidth 255660"];
5058 [label="this.AdjustFlagsAndWidth(trailing); 255661"];
5059 [label="return '>>='; 255662"];
5060 [label="FullWidth = this.Text.Length; 255663"];
5061 [label="FullWidth 255664"];
5062 [label="this.AdjustFlagsAndWidth(trailing); 255665"];
5063 [label="return '/='; 255666"];
5064 [label="FullWidth = this.Text.Length; 255667"];
5065 [label="FullWidth 255668"];
5066 [label="return '/='; 255669"];
5067 [label="FullWidth = this.Text.Length; 255670"];
5068 [label="FullWidth 255671"];
5069 [label="this.AdjustFlagsAndWidth(leading); 255672"];
5070 [label="return '/='; 255673"];
5071 [label="FullWidth = this.Text.Length; 255674"];
5072 [label="FullWidth 255675"];
5073 [label="this.AdjustFlagsAndWidth(trailing); 255676"];
5074 [label="return '/='; 255677"];
5075 [label="FullWidth = this.Text.Length; 255678"];
5076 [label="FullWidth 255679"];
5077 [label="this.AdjustFlagsAndWidth(trailing); 255680"];
5078 [label="return '*='; 255681"];
5079 [label="FullWidth = this.Text.Length; 255682"];
5080 [label="FullWidth 255683"];
5081 [label="return '*='; 255684"];
5082 [label="FullWidth = this.Text.Length; 255685"];
5083 [label="FullWidth 255686"];
5084 [label="this.AdjustFlagsAndWidth(leading); 255687"];
5085 [label="return '*='; 255688"];
5086 [label="FullWidth = this.Text.Length; 255689"];
5087 [label="FullWidth 255690"];
5088 [label="this.AdjustFlagsAndWidth(trailing); 255691"];
5089 [label="return '*='; 255692"];
5090 [label="FullWidth = this.Text.Length; 255693"];
5091 [label="FullWidth 255694"];
5092 [label="this.AdjustFlagsAndWidth(trailing); 255695"];
5093 [label="return '|='; 255696"];
5094 [label="FullWidth = this.Text.Length; 255697"];
5095 [label="FullWidth 255698"];
5096 [label="return '|='; 255699"];
5097 [label="FullWidth = this.Text.Length; 255700"];
5098 [label="FullWidth 255701"];
5099 [label="this.AdjustFlagsAndWidth(leading); 255702"];
5100 [label="return '|='; 255703"];
5101 [label="FullWidth = this.Text.Length; 255704"];
5102 [label="FullWidth 255705"];
5103 [label="this.AdjustFlagsAndWidth(trailing); 255706"];
5104 [label="return '|='; 255707"];
5105 [label="FullWidth = this.Text.Length; 255708"];
5106 [label="FullWidth 255709"];
5107 [label="this.AdjustFlagsAndWidth(trailing); 255710"];
5108 [label="return '&='; 255711"];
5109 [label="FullWidth = this.Text.Length; 255712"];
5110 [label="FullWidth 255713"];
5111 [label="return '&='; 255714"];
5112 [label="FullWidth = this.Text.Length; 255715"];
5113 [label="FullWidth 255716"];
5114 [label="this.AdjustFlagsAndWidth(leading); 255717"];
5115 [label="return '&='; 255718"];
5116 [label="FullWidth = this.Text.Length; 255719"];
5117 [label="FullWidth 255720"];
5118 [label="this.AdjustFlagsAndWidth(trailing); 255721"];
5119 [label="return '&='; 255722"];
5120 [label="FullWidth = this.Text.Length; 255723"];
5121 [label="FullWidth 255724"];
5122 [label="this.AdjustFlagsAndWidth(trailing); 255725"];
5123 [label="return '+='; 255726"];
5124 [label="FullWidth = this.Text.Length; 255727"];
5125 [label="FullWidth 255728"];
5126 [label="return '+='; 255729"];
5127 [label="FullWidth = this.Text.Length; 255730"];
5128 [label="FullWidth 255731"];
5129 [label="this.AdjustFlagsAndWidth(leading); 255732"];
5130 [label="return '+='; 255733"];
5131 [label="FullWidth = this.Text.Length; 255734"];
5132 [label="FullWidth 255735"];
5133 [label="this.AdjustFlagsAndWidth(trailing); 255736"];
5134 [label="return '+='; 255737"];
5135 [label="FullWidth = this.Text.Length; 255738"];
5136 [label="FullWidth 255739"];
5137 [label="this.AdjustFlagsAndWidth(trailing); 255740"];
5138 [label="return '-='; 255741"];
5139 [label="FullWidth = this.Text.Length; 255742"];
5140 [label="FullWidth 255743"];
5141 [label="return '-='; 255744"];
5142 [label="FullWidth = this.Text.Length; 255745"];
5143 [label="FullWidth 255746"];
5144 [label="this.AdjustFlagsAndWidth(leading); 255747"];
5145 [label="return '-='; 255748"];
5146 [label="FullWidth = this.Text.Length; 255749"];
5147 [label="FullWidth 255750"];
5148 [label="this.AdjustFlagsAndWidth(trailing); 255751"];
5149 [label="return '-='; 255752"];
5150 [label="FullWidth = this.Text.Length; 255753"];
5151 [label="FullWidth 255754"];
5152 [label="this.AdjustFlagsAndWidth(trailing); 255755"];
5153 [label="return '^='; 255756"];
5154 [label="FullWidth = this.Text.Length; 255757"];
5155 [label="FullWidth 255758"];
5156 [label="return '^='; 255759"];
5157 [label="FullWidth = this.Text.Length; 255760"];
5158 [label="FullWidth 255761"];
5159 [label="this.AdjustFlagsAndWidth(leading); 255762"];
5160 [label="return '^='; 255763"];
5161 [label="FullWidth = this.Text.Length; 255764"];
5162 [label="FullWidth 255765"];
5163 [label="this.AdjustFlagsAndWidth(trailing); 255766"];
5164 [label="return '^='; 255767"];
5165 [label="FullWidth = this.Text.Length; 255768"];
5166 [label="FullWidth 255769"];
5167 [label="this.AdjustFlagsAndWidth(trailing); 255770"];
5168 [label="return '%='; 255771"];
5169 [label="FullWidth = this.Text.Length; 255772"];
5170 [label="FullWidth 255773"];
5171 [label="return '%='; 255774"];
5172 [label="FullWidth = this.Text.Length; 255775"];
5173 [label="FullWidth 255776"];
5174 [label="this.AdjustFlagsAndWidth(leading); 255777"];
5175 [label="return '%='; 255778"];
5176 [label="FullWidth = this.Text.Length; 255779"];
5177 [label="FullWidth 255780"];
5178 [label="this.AdjustFlagsAndWidth(trailing); 255781"];
5179 [label="return '%='; 255782"];
5180 [label="FullWidth = this.Text.Length; 255783"];
5181 [label="FullWidth 255784"];
5182 [label="this.AdjustFlagsAndWidth(trailing); 255785"];
5183 [label="return '??='; 255786"];
5184 [label="FullWidth = this.Text.Length; 255787"];
5185 [label="FullWidth 255788"];
5186 [label="return '??='; 255789"];
5187 [label="FullWidth = this.Text.Length; 255790"];
5188 [label="FullWidth 255791"];
5189 [label="this.AdjustFlagsAndWidth(leading); 255792"];
5190 [label="return '??='; 255793"];
5191 [label="FullWidth = this.Text.Length; 255794"];
5192 [label="FullWidth 255795"];
5193 [label="this.AdjustFlagsAndWidth(trailing); 255796"];
5194 [label="return '??='; 255797"];
5195 [label="FullWidth = this.Text.Length; 255798"];
5196 [label="FullWidth 255799"];
5197 [label="this.AdjustFlagsAndWidth(trailing); 255800"];
5198 [label="return 'bool'; 255801"];
5199 [label="FullWidth = this.Text.Length; 255802"];
5200 [label="FullWidth 255803"];
5201 [label="return 'bool'; 255804"];
5202 [label="FullWidth = this.Text.Length; 255805"];
5203 [label="FullWidth 255806"];
5204 [label="this.AdjustFlagsAndWidth(leading); 255807"];
5205 [label="return 'bool'; 255808"];
5206 [label="FullWidth = this.Text.Length; 255809"];
5207 [label="FullWidth 255810"];
5208 [label="this.AdjustFlagsAndWidth(trailing); 255811"];
5209 [label="return 'bool'; 255812"];
5210 [label="FullWidth = this.Text.Length; 255813"];
5211 [label="FullWidth 255814"];
5212 [label="this.AdjustFlagsAndWidth(trailing); 255815"];
5213 [label="return 'byte'; 255816"];
5214 [label="FullWidth = this.Text.Length; 255817"];
5215 [label="FullWidth 255818"];
5216 [label="return 'byte'; 255819"];
5217 [label="FullWidth = this.Text.Length; 255820"];
5218 [label="FullWidth 255821"];
5219 [label="this.AdjustFlagsAndWidth(leading); 255822"];
5220 [label="return 'byte'; 255823"];
5221 [label="FullWidth = this.Text.Length; 255824"];
5222 [label="FullWidth 255825"];
5223 [label="this.AdjustFlagsAndWidth(trailing); 255826"];
5224 [label="return 'byte'; 255827"];
5225 [label="FullWidth = this.Text.Length; 255828"];
5226 [label="FullWidth 255829"];
5227 [label="this.AdjustFlagsAndWidth(trailing); 255830"];
5228 [label="return 'sbyte'; 255831"];
5229 [label="FullWidth = this.Text.Length; 255832"];
5230 [label="FullWidth 255833"];
5231 [label="return 'sbyte'; 255834"];
5232 [label="FullWidth = this.Text.Length; 255835"];
5233 [label="FullWidth 255836"];
5234 [label="this.AdjustFlagsAndWidth(leading); 255837"];
5235 [label="return 'sbyte'; 255838"];
5236 [label="FullWidth = this.Text.Length; 255839"];
5237 [label="FullWidth 255840"];
5238 [label="this.AdjustFlagsAndWidth(trailing); 255841"];
5239 [label="return 'sbyte'; 255842"];
5240 [label="FullWidth = this.Text.Length; 255843"];
5241 [label="FullWidth 255844"];
5242 [label="this.AdjustFlagsAndWidth(trailing); 255845"];
5243 [label="return 'short'; 255846"];
5244 [label="FullWidth = this.Text.Length; 255847"];
5245 [label="FullWidth 255848"];
5246 [label="return 'short'; 255849"];
5247 [label="FullWidth = this.Text.Length; 255850"];
5248 [label="FullWidth 255851"];
5249 [label="this.AdjustFlagsAndWidth(leading); 255852"];
5250 [label="return 'short'; 255853"];
5251 [label="FullWidth = this.Text.Length; 255854"];
5252 [label="FullWidth 255855"];
5253 [label="this.AdjustFlagsAndWidth(trailing); 255856"];
5254 [label="return 'short'; 255857"];
5255 [label="FullWidth = this.Text.Length; 255858"];
5256 [label="FullWidth 255859"];
5257 [label="this.AdjustFlagsAndWidth(trailing); 255860"];
5258 [label="return 'ushort'; 255861"];
5259 [label="FullWidth = this.Text.Length; 255862"];
5260 [label="FullWidth 255863"];
5261 [label="return 'ushort'; 255864"];
5262 [label="FullWidth = this.Text.Length; 255865"];
5263 [label="FullWidth 255866"];
5264 [label="this.AdjustFlagsAndWidth(leading); 255867"];
5265 [label="return 'ushort'; 255868"];
5266 [label="FullWidth = this.Text.Length; 255869"];
5267 [label="FullWidth 255870"];
5268 [label="this.AdjustFlagsAndWidth(trailing); 255871"];
5269 [label="return 'ushort'; 255872"];
5270 [label="FullWidth = this.Text.Length; 255873"];
5271 [label="FullWidth 255874"];
5272 [label="this.AdjustFlagsAndWidth(trailing); 255875"];
5273 [label="return 'int'; 255876"];
5274 [label="FullWidth = this.Text.Length; 255877"];
5275 [label="FullWidth 255878"];
5276 [label="return 'int'; 255879"];
5277 [label="FullWidth = this.Text.Length; 255880"];
5278 [label="FullWidth 255881"];
5279 [label="this.AdjustFlagsAndWidth(leading); 255882"];
5280 [label="return 'int'; 255883"];
5281 [label="FullWidth = this.Text.Length; 255884"];
5282 [label="FullWidth 255885"];
5283 [label="this.AdjustFlagsAndWidth(trailing); 255886"];
5284 [label="return 'int'; 255887"];
5285 [label="FullWidth = this.Text.Length; 255888"];
5286 [label="FullWidth 255889"];
5287 [label="this.AdjustFlagsAndWidth(trailing); 255890"];
5288 [label="return 'uint'; 255891"];
5289 [label="FullWidth = this.Text.Length; 255892"];
5290 [label="FullWidth 255893"];
5291 [label="return 'uint'; 255894"];
5292 [label="FullWidth = this.Text.Length; 255895"];
5293 [label="FullWidth 255896"];
5294 [label="this.AdjustFlagsAndWidth(leading); 255897"];
5295 [label="return 'uint'; 255898"];
5296 [label="FullWidth = this.Text.Length; 255899"];
5297 [label="FullWidth 255900"];
5298 [label="this.AdjustFlagsAndWidth(trailing); 255901"];
5299 [label="return 'uint'; 255902"];
5300 [label="FullWidth = this.Text.Length; 255903"];
5301 [label="FullWidth 255904"];
5302 [label="this.AdjustFlagsAndWidth(trailing); 255905"];
5303 [label="return 'long'; 255906"];
5304 [label="FullWidth = this.Text.Length; 255907"];
5305 [label="FullWidth 255908"];
5306 [label="return 'long'; 255909"];
5307 [label="FullWidth = this.Text.Length; 255910"];
5308 [label="FullWidth 255911"];
5309 [label="this.AdjustFlagsAndWidth(leading); 255912"];
5310 [label="return 'long'; 255913"];
5311 [label="FullWidth = this.Text.Length; 255914"];
5312 [label="FullWidth 255915"];
5313 [label="this.AdjustFlagsAndWidth(trailing); 255916"];
5314 [label="return 'long'; 255917"];
5315 [label="FullWidth = this.Text.Length; 255918"];
5316 [label="FullWidth 255919"];
5317 [label="this.AdjustFlagsAndWidth(trailing); 255920"];
5318 [label="return 'ulong'; 255921"];
5319 [label="FullWidth = this.Text.Length; 255922"];
5320 [label="FullWidth 255923"];
5321 [label="return 'ulong'; 255924"];
5322 [label="FullWidth = this.Text.Length; 255925"];
5323 [label="FullWidth 255926"];
5324 [label="this.AdjustFlagsAndWidth(leading); 255927"];
5325 [label="return 'ulong'; 255928"];
5326 [label="FullWidth = this.Text.Length; 255929"];
5327 [label="FullWidth 255930"];
5328 [label="this.AdjustFlagsAndWidth(trailing); 255931"];
5329 [label="return 'ulong'; 255932"];
5330 [label="FullWidth = this.Text.Length; 255933"];
5331 [label="FullWidth 255934"];
5332 [label="this.AdjustFlagsAndWidth(trailing); 255935"];
5333 [label="return 'double'; 255936"];
5334 [label="FullWidth = this.Text.Length; 255937"];
5335 [label="FullWidth 255938"];
5336 [label="return 'double'; 255939"];
5337 [label="FullWidth = this.Text.Length; 255940"];
5338 [label="FullWidth 255941"];
5339 [label="this.AdjustFlagsAndWidth(leading); 255942"];
5340 [label="return 'double'; 255943"];
5341 [label="FullWidth = this.Text.Length; 255944"];
5342 [label="FullWidth 255945"];
5343 [label="this.AdjustFlagsAndWidth(trailing); 255946"];
5344 [label="return 'double'; 255947"];
5345 [label="FullWidth = this.Text.Length; 255948"];
5346 [label="FullWidth 255949"];
5347 [label="this.AdjustFlagsAndWidth(trailing); 255950"];
5348 [label="return 'float'; 255951"];
5349 [label="FullWidth = this.Text.Length; 255952"];
5350 [label="FullWidth 255953"];
5351 [label="return 'float'; 255954"];
5352 [label="FullWidth = this.Text.Length; 255955"];
5353 [label="FullWidth 255956"];
5354 [label="this.AdjustFlagsAndWidth(leading); 255957"];
5355 [label="return 'float'; 255958"];
5356 [label="FullWidth = this.Text.Length; 255959"];
5357 [label="FullWidth 255960"];
5358 [label="this.AdjustFlagsAndWidth(trailing); 255961"];
5359 [label="return 'float'; 255962"];
5360 [label="FullWidth = this.Text.Length; 255963"];
5361 [label="FullWidth 255964"];
5362 [label="this.AdjustFlagsAndWidth(trailing); 255965"];
5363 [label="return 'decimal'; 255966"];
5364 [label="FullWidth = this.Text.Length; 255967"];
5365 [label="FullWidth 255968"];
5366 [label="return 'decimal'; 255969"];
5367 [label="FullWidth = this.Text.Length; 255970"];
5368 [label="FullWidth 255971"];
5369 [label="this.AdjustFlagsAndWidth(leading); 255972"];
5370 [label="return 'decimal'; 255973"];
5371 [label="FullWidth = this.Text.Length; 255974"];
5372 [label="FullWidth 255975"];
5373 [label="this.AdjustFlagsAndWidth(trailing); 255976"];
5374 [label="return 'decimal'; 255977"];
5375 [label="FullWidth = this.Text.Length; 255978"];
5376 [label="FullWidth 255979"];
5377 [label="this.AdjustFlagsAndWidth(trailing); 255980"];
5378 [label="return 'string'; 255981"];
5379 [label="FullWidth = this.Text.Length; 255982"];
5380 [label="FullWidth 255983"];
5381 [label="return 'string'; 255984"];
5382 [label="FullWidth = this.Text.Length; 255985"];
5383 [label="FullWidth 255986"];
5384 [label="this.AdjustFlagsAndWidth(leading); 255987"];
5385 [label="return 'string'; 255988"];
5386 [label="FullWidth = this.Text.Length; 255989"];
5387 [label="FullWidth 255990"];
5388 [label="this.AdjustFlagsAndWidth(trailing); 255991"];
5389 [label="return 'string'; 255992"];
5390 [label="FullWidth = this.Text.Length; 255993"];
5391 [label="FullWidth 255994"];
5392 [label="this.AdjustFlagsAndWidth(trailing); 255995"];
5393 [label="return 'char'; 255996"];
5394 [label="FullWidth = this.Text.Length; 255997"];
5395 [label="FullWidth 255998"];
5396 [label="return 'char'; 255999"];
5397 [label="FullWidth = this.Text.Length; 256000"];
5398 [label="FullWidth 256001"];
5399 [label="this.AdjustFlagsAndWidth(leading); 256002"];
5400 [label="return 'char'; 256003"];
5401 [label="FullWidth = this.Text.Length; 256004"];
5402 [label="FullWidth 256005"];
5403 [label="this.AdjustFlagsAndWidth(trailing); 256006"];
5404 [label="return 'char'; 256007"];
5405 [label="FullWidth = this.Text.Length; 256008"];
5406 [label="FullWidth 256009"];
5407 [label="this.AdjustFlagsAndWidth(trailing); 256010"];
5408 [label="return 'void'; 256011"];
5409 [label="FullWidth = this.Text.Length; 256012"];
5410 [label="FullWidth 256013"];
5411 [label="return 'void'; 256014"];
5412 [label="FullWidth = this.Text.Length; 256015"];
5413 [label="FullWidth 256016"];
5414 [label="this.AdjustFlagsAndWidth(leading); 256017"];
5415 [label="return 'void'; 256018"];
5416 [label="FullWidth = this.Text.Length; 256019"];
5417 [label="FullWidth 256020"];
5418 [label="this.AdjustFlagsAndWidth(trailing); 256021"];
5419 [label="return 'void'; 256022"];
5420 [label="FullWidth = this.Text.Length; 256023"];
5421 [label="FullWidth 256024"];
5422 [label="this.AdjustFlagsAndWidth(trailing); 256025"];
5423 [label="return 'object'; 256026"];
5424 [label="FullWidth = this.Text.Length; 256027"];
5425 [label="FullWidth 256028"];
5426 [label="return 'object'; 256029"];
5427 [label="FullWidth = this.Text.Length; 256030"];
5428 [label="FullWidth 256031"];
5429 [label="this.AdjustFlagsAndWidth(leading); 256032"];
5430 [label="return 'object'; 256033"];
5431 [label="FullWidth = this.Text.Length; 256034"];
5432 [label="FullWidth 256035"];
5433 [label="this.AdjustFlagsAndWidth(trailing); 256036"];
5434 [label="return 'object'; 256037"];
5435 [label="FullWidth = this.Text.Length; 256038"];
5436 [label="FullWidth 256039"];
5437 [label="this.AdjustFlagsAndWidth(trailing); 256040"];
5438 [label="return 'typeof'; 256041"];
5439 [label="FullWidth = this.Text.Length; 256042"];
5440 [label="FullWidth 256043"];
5441 [label="return 'typeof'; 256044"];
5442 [label="FullWidth = this.Text.Length; 256045"];
5443 [label="FullWidth 256046"];
5444 [label="this.AdjustFlagsAndWidth(leading); 256047"];
5445 [label="return 'typeof'; 256048"];
5446 [label="FullWidth = this.Text.Length; 256049"];
5447 [label="FullWidth 256050"];
5448 [label="this.AdjustFlagsAndWidth(trailing); 256051"];
5449 [label="return 'typeof'; 256052"];
5450 [label="FullWidth = this.Text.Length; 256053"];
5451 [label="FullWidth 256054"];
5452 [label="this.AdjustFlagsAndWidth(trailing); 256055"];
5453 [label="return 'sizeof'; 256056"];
5454 [label="FullWidth = this.Text.Length; 256057"];
5455 [label="FullWidth 256058"];
5456 [label="return 'sizeof'; 256059"];
5457 [label="FullWidth = this.Text.Length; 256060"];
5458 [label="FullWidth 256061"];
5459 [label="this.AdjustFlagsAndWidth(leading); 256062"];
5460 [label="return 'sizeof'; 256063"];
5461 [label="FullWidth = this.Text.Length; 256064"];
5462 [label="FullWidth 256065"];
5463 [label="this.AdjustFlagsAndWidth(trailing); 256066"];
5464 [label="return 'sizeof'; 256067"];
5465 [label="FullWidth = this.Text.Length; 256068"];
5466 [label="FullWidth 256069"];
5467 [label="this.AdjustFlagsAndWidth(trailing); 256070"];
5468 [label="return 'null'; 256071"];
5469 [label="FullWidth = this.Text.Length; 256072"];
5470 [label="FullWidth 256073"];
5471 [label="return 'null'; 256074"];
5472 [label="FullWidth = this.Text.Length; 256075"];
5473 [label="FullWidth 256076"];
5474 [label="this.AdjustFlagsAndWidth(leading); 256077"];
5475 [label="return 'null'; 256078"];
5476 [label="FullWidth = this.Text.Length; 256079"];
5477 [label="FullWidth 256080"];
5478 [label="this.AdjustFlagsAndWidth(trailing); 256081"];
5479 [label="return 'null'; 256082"];
5480 [label="FullWidth = this.Text.Length; 256083"];
5481 [label="FullWidth 256084"];
5482 [label="this.AdjustFlagsAndWidth(trailing); 256085"];
5483 [label="return 'true'; 256086"];
5484 [label="FullWidth = this.Text.Length; 256087"];
5485 [label="FullWidth 256088"];
5486 [label="return 'true'; 256089"];
5487 [label="FullWidth = this.Text.Length; 256090"];
5488 [label="FullWidth 256091"];
5489 [label="this.AdjustFlagsAndWidth(leading); 256092"];
5490 [label="return 'true'; 256093"];
5491 [label="FullWidth = this.Text.Length; 256094"];
5492 [label="FullWidth 256095"];
5493 [label="this.AdjustFlagsAndWidth(trailing); 256096"];
5494 [label="return 'true'; 256097"];
5495 [label="FullWidth = this.Text.Length; 256098"];
5496 [label="FullWidth 256099"];
5497 [label="this.AdjustFlagsAndWidth(trailing); 256100"];
5498 [label="return 'false'; 256101"];
5499 [label="FullWidth = this.Text.Length; 256102"];
5500 [label="FullWidth 256103"];
5501 [label="return 'false'; 256104"];
5502 [label="FullWidth = this.Text.Length; 256105"];
5503 [label="FullWidth 256106"];
5504 [label="this.AdjustFlagsAndWidth(leading); 256107"];
5505 [label="return 'false'; 256108"];
5506 [label="FullWidth = this.Text.Length; 256109"];
5507 [label="FullWidth 256110"];
5508 [label="this.AdjustFlagsAndWidth(trailing); 256111"];
5509 [label="return 'false'; 256112"];
5510 [label="FullWidth = this.Text.Length; 256113"];
5511 [label="FullWidth 256114"];
5512 [label="this.AdjustFlagsAndWidth(trailing); 256115"];
5513 [label="return 'if'; 256116"];
5514 [label="FullWidth = this.Text.Length; 256117"];
5515 [label="FullWidth 256118"];
5516 [label="return 'if'; 256119"];
5517 [label="FullWidth = this.Text.Length; 256120"];
5518 [label="FullWidth 256121"];
5519 [label="this.AdjustFlagsAndWidth(leading); 256122"];
5520 [label="return 'if'; 256123"];
5521 [label="FullWidth = this.Text.Length; 256124"];
5522 [label="FullWidth 256125"];
5523 [label="this.AdjustFlagsAndWidth(trailing); 256126"];
5524 [label="return 'if'; 256127"];
5525 [label="FullWidth = this.Text.Length; 256128"];
5526 [label="FullWidth 256129"];
5527 [label="this.AdjustFlagsAndWidth(trailing); 256130"];
5528 [label="return 'else'; 256131"];
5529 [label="FullWidth = this.Text.Length; 256132"];
5530 [label="FullWidth 256133"];
5531 [label="return 'else'; 256134"];
5532 [label="FullWidth = this.Text.Length; 256135"];
5533 [label="FullWidth 256136"];
5534 [label="this.AdjustFlagsAndWidth(leading); 256137"];
5535 [label="return 'else'; 256138"];
5536 [label="FullWidth = this.Text.Length; 256139"];
5537 [label="FullWidth 256140"];
5538 [label="this.AdjustFlagsAndWidth(trailing); 256141"];
5539 [label="return 'else'; 256142"];
5540 [label="FullWidth = this.Text.Length; 256143"];
5541 [label="FullWidth 256144"];
5542 [label="this.AdjustFlagsAndWidth(trailing); 256145"];
5543 [label="return 'while'; 256146"];
5544 [label="FullWidth = this.Text.Length; 256147"];
5545 [label="FullWidth 256148"];
5546 [label="return 'while'; 256149"];
5547 [label="FullWidth = this.Text.Length; 256150"];
5548 [label="FullWidth 256151"];
5549 [label="this.AdjustFlagsAndWidth(leading); 256152"];
5550 [label="return 'while'; 256153"];
5551 [label="FullWidth = this.Text.Length; 256154"];
5552 [label="FullWidth 256155"];
5553 [label="this.AdjustFlagsAndWidth(trailing); 256156"];
5554 [label="return 'while'; 256157"];
5555 [label="FullWidth = this.Text.Length; 256158"];
5556 [label="FullWidth 256159"];
5557 [label="this.AdjustFlagsAndWidth(trailing); 256160"];
5558 [label="return 'for'; 256161"];
5559 [label="FullWidth = this.Text.Length; 256162"];
5560 [label="FullWidth 256163"];
5561 [label="return 'for'; 256164"];
5562 [label="FullWidth = this.Text.Length; 256165"];
5563 [label="FullWidth 256166"];
5564 [label="this.AdjustFlagsAndWidth(leading); 256167"];
5565 [label="return 'for'; 256168"];
5566 [label="FullWidth = this.Text.Length; 256169"];
5567 [label="FullWidth 256170"];
5568 [label="this.AdjustFlagsAndWidth(trailing); 256171"];
5569 [label="return 'for'; 256172"];
5570 [label="FullWidth = this.Text.Length; 256173"];
5571 [label="FullWidth 256174"];
5572 [label="this.AdjustFlagsAndWidth(trailing); 256175"];
5573 [label="return 'foreach'; 256176"];
5574 [label="FullWidth = this.Text.Length; 256177"];
5575 [label="FullWidth 256178"];
5576 [label="return 'foreach'; 256179"];
5577 [label="FullWidth = this.Text.Length; 256180"];
5578 [label="FullWidth 256181"];
5579 [label="this.AdjustFlagsAndWidth(leading); 256182"];
5580 [label="return 'foreach'; 256183"];
5581 [label="FullWidth = this.Text.Length; 256184"];
5582 [label="FullWidth 256185"];
5583 [label="this.AdjustFlagsAndWidth(trailing); 256186"];
5584 [label="return 'foreach'; 256187"];
5585 [label="FullWidth = this.Text.Length; 256188"];
5586 [label="FullWidth 256189"];
5587 [label="this.AdjustFlagsAndWidth(trailing); 256190"];
5588 [label="return 'do'; 256191"];
5589 [label="FullWidth = this.Text.Length; 256192"];
5590 [label="FullWidth 256193"];
5591 [label="return 'do'; 256194"];
5592 [label="FullWidth = this.Text.Length; 256195"];
5593 [label="FullWidth 256196"];
5594 [label="this.AdjustFlagsAndWidth(leading); 256197"];
5595 [label="return 'do'; 256198"];
5596 [label="FullWidth = this.Text.Length; 256199"];
5597 [label="FullWidth 256200"];
5598 [label="this.AdjustFlagsAndWidth(trailing); 256201"];
5599 [label="return 'do'; 256202"];
5600 [label="FullWidth = this.Text.Length; 256203"];
5601 [label="FullWidth 256204"];
5602 [label="this.AdjustFlagsAndWidth(trailing); 256205"];
5603 [label="return 'switch'; 256206"];
5604 [label="FullWidth = this.Text.Length; 256207"];
5605 [label="FullWidth 256208"];
5606 [label="return 'switch'; 256209"];
5607 [label="FullWidth = this.Text.Length; 256210"];
5608 [label="FullWidth 256211"];
5609 [label="this.AdjustFlagsAndWidth(leading); 256212"];
5610 [label="return 'switch'; 256213"];
5611 [label="FullWidth = this.Text.Length; 256214"];
5612 [label="FullWidth 256215"];
5613 [label="this.AdjustFlagsAndWidth(trailing); 256216"];
5614 [label="return 'switch'; 256217"];
5615 [label="FullWidth = this.Text.Length; 256218"];
5616 [label="FullWidth 256219"];
5617 [label="this.AdjustFlagsAndWidth(trailing); 256220"];
5618 [label="return 'case'; 256221"];
5619 [label="FullWidth = this.Text.Length; 256222"];
5620 [label="FullWidth 256223"];
5621 [label="return 'case'; 256224"];
5622 [label="FullWidth = this.Text.Length; 256225"];
5623 [label="FullWidth 256226"];
5624 [label="this.AdjustFlagsAndWidth(leading); 256227"];
5625 [label="return 'case'; 256228"];
5626 [label="FullWidth = this.Text.Length; 256229"];
5627 [label="FullWidth 256230"];
5628 [label="this.AdjustFlagsAndWidth(trailing); 256231"];
5629 [label="return 'case'; 256232"];
5630 [label="FullWidth = this.Text.Length; 256233"];
5631 [label="FullWidth 256234"];
5632 [label="this.AdjustFlagsAndWidth(trailing); 256235"];
5633 [label="return 'default'; 256236"];
5634 [label="FullWidth = this.Text.Length; 256237"];
5635 [label="FullWidth 256238"];
5636 [label="return 'default'; 256239"];
5637 [label="FullWidth = this.Text.Length; 256240"];
5638 [label="FullWidth 256241"];
5639 [label="this.AdjustFlagsAndWidth(leading); 256242"];
5640 [label="return 'default'; 256243"];
5641 [label="FullWidth = this.Text.Length; 256244"];
5642 [label="FullWidth 256245"];
5643 [label="this.AdjustFlagsAndWidth(trailing); 256246"];
5644 [label="return 'default'; 256247"];
5645 [label="FullWidth = this.Text.Length; 256248"];
5646 [label="FullWidth 256249"];
5647 [label="this.AdjustFlagsAndWidth(trailing); 256250"];
5648 [label="return 'try'; 256251"];
5649 [label="FullWidth = this.Text.Length; 256252"];
5650 [label="FullWidth 256253"];
5651 [label="return 'try'; 256254"];
5652 [label="FullWidth = this.Text.Length; 256255"];
5653 [label="FullWidth 256256"];
5654 [label="this.AdjustFlagsAndWidth(leading); 256257"];
5655 [label="return 'try'; 256258"];
5656 [label="FullWidth = this.Text.Length; 256259"];
5657 [label="FullWidth 256260"];
5658 [label="this.AdjustFlagsAndWidth(trailing); 256261"];
5659 [label="return 'try'; 256262"];
5660 [label="FullWidth = this.Text.Length; 256263"];
5661 [label="FullWidth 256264"];
5662 [label="this.AdjustFlagsAndWidth(trailing); 256265"];
5663 [label="return 'catch'; 256266"];
5664 [label="FullWidth = this.Text.Length; 256267"];
5665 [label="FullWidth 256268"];
5666 [label="return 'catch'; 256269"];
5667 [label="FullWidth = this.Text.Length; 256270"];
5668 [label="FullWidth 256271"];
5669 [label="this.AdjustFlagsAndWidth(leading); 256272"];
5670 [label="return 'catch'; 256273"];
5671 [label="FullWidth = this.Text.Length; 256274"];
5672 [label="FullWidth 256275"];
5673 [label="this.AdjustFlagsAndWidth(trailing); 256276"];
5674 [label="return 'catch'; 256277"];
5675 [label="FullWidth = this.Text.Length; 256278"];
5676 [label="FullWidth 256279"];
5677 [label="this.AdjustFlagsAndWidth(trailing); 256280"];
5678 [label="return 'finally'; 256281"];
5679 [label="FullWidth = this.Text.Length; 256282"];
5680 [label="FullWidth 256283"];
5681 [label="return 'finally'; 256284"];
5682 [label="FullWidth = this.Text.Length; 256285"];
5683 [label="FullWidth 256286"];
5684 [label="this.AdjustFlagsAndWidth(leading); 256287"];
5685 [label="return 'finally'; 256288"];
5686 [label="FullWidth = this.Text.Length; 256289"];
5687 [label="FullWidth 256290"];
5688 [label="this.AdjustFlagsAndWidth(trailing); 256291"];
5689 [label="return 'finally'; 256292"];
5690 [label="FullWidth = this.Text.Length; 256293"];
5691 [label="FullWidth 256294"];
5692 [label="this.AdjustFlagsAndWidth(trailing); 256295"];
5693 [label="return 'lock'; 256296"];
5694 [label="FullWidth = this.Text.Length; 256297"];
5695 [label="FullWidth 256298"];
5696 [label="return 'lock'; 256299"];
5697 [label="FullWidth = this.Text.Length; 256300"];
5698 [label="FullWidth 256301"];
5699 [label="this.AdjustFlagsAndWidth(leading); 256302"];
5700 [label="return 'lock'; 256303"];
5701 [label="FullWidth = this.Text.Length; 256304"];
5702 [label="FullWidth 256305"];
5703 [label="this.AdjustFlagsAndWidth(trailing); 256306"];
5704 [label="return 'lock'; 256307"];
5705 [label="FullWidth = this.Text.Length; 256308"];
5706 [label="FullWidth 256309"];
5707 [label="this.AdjustFlagsAndWidth(trailing); 256310"];
5708 [label="return 'goto'; 256311"];
5709 [label="FullWidth = this.Text.Length; 256312"];
5710 [label="FullWidth 256313"];
5711 [label="return 'goto'; 256314"];
5712 [label="FullWidth = this.Text.Length; 256315"];
5713 [label="FullWidth 256316"];
5714 [label="this.AdjustFlagsAndWidth(leading); 256317"];
5715 [label="return 'goto'; 256318"];
5716 [label="FullWidth = this.Text.Length; 256319"];
5717 [label="FullWidth 256320"];
5718 [label="this.AdjustFlagsAndWidth(trailing); 256321"];
5719 [label="return 'goto'; 256322"];
5720 [label="FullWidth = this.Text.Length; 256323"];
5721 [label="FullWidth 256324"];
5722 [label="this.AdjustFlagsAndWidth(trailing); 256325"];
5723 [label="return 'break'; 256326"];
5724 [label="FullWidth = this.Text.Length; 256327"];
5725 [label="FullWidth 256328"];
5726 [label="return 'break'; 256329"];
5727 [label="FullWidth = this.Text.Length; 256330"];
5728 [label="FullWidth 256331"];
5729 [label="this.AdjustFlagsAndWidth(leading); 256332"];
5730 [label="return 'break'; 256333"];
5731 [label="FullWidth = this.Text.Length; 256334"];
5732 [label="FullWidth 256335"];
5733 [label="this.AdjustFlagsAndWidth(trailing); 256336"];
5734 [label="return 'break'; 256337"];
5735 [label="FullWidth = this.Text.Length; 256338"];
5736 [label="FullWidth 256339"];
5737 [label="this.AdjustFlagsAndWidth(trailing); 256340"];
5738 [label="return 'continue'; 256341"];
5739 [label="FullWidth = this.Text.Length; 256342"];
5740 [label="FullWidth 256343"];
5741 [label="return 'continue'; 256344"];
5742 [label="FullWidth = this.Text.Length; 256345"];
5743 [label="FullWidth 256346"];
5744 [label="this.AdjustFlagsAndWidth(leading); 256347"];
5745 [label="return 'continue'; 256348"];
5746 [label="FullWidth = this.Text.Length; 256349"];
5747 [label="FullWidth 256350"];
5748 [label="this.AdjustFlagsAndWidth(trailing); 256351"];
5749 [label="return 'continue'; 256352"];
5750 [label="FullWidth = this.Text.Length; 256353"];
5751 [label="FullWidth 256354"];
5752 [label="this.AdjustFlagsAndWidth(trailing); 256355"];
5753 [label="return 'return'; 256356"];
5754 [label="FullWidth = this.Text.Length; 256357"];
5755 [label="FullWidth 256358"];
5756 [label="return 'return'; 256359"];
5757 [label="FullWidth = this.Text.Length; 256360"];
5758 [label="FullWidth 256361"];
5759 [label="this.AdjustFlagsAndWidth(leading); 256362"];
5760 [label="return 'return'; 256363"];
5761 [label="FullWidth = this.Text.Length; 256364"];
5762 [label="FullWidth 256365"];
5763 [label="this.AdjustFlagsAndWidth(trailing); 256366"];
5764 [label="return 'return'; 256367"];
5765 [label="FullWidth = this.Text.Length; 256368"];
5766 [label="FullWidth 256369"];
5767 [label="this.AdjustFlagsAndWidth(trailing); 256370"];
5768 [label="return 'throw'; 256371"];
5769 [label="FullWidth = this.Text.Length; 256372"];
5770 [label="FullWidth 256373"];
5771 [label="return 'throw'; 256374"];
5772 [label="FullWidth = this.Text.Length; 256375"];
5773 [label="FullWidth 256376"];
5774 [label="this.AdjustFlagsAndWidth(leading); 256377"];
5775 [label="return 'throw'; 256378"];
5776 [label="FullWidth = this.Text.Length; 256379"];
5777 [label="FullWidth 256380"];
5778 [label="this.AdjustFlagsAndWidth(trailing); 256381"];
5779 [label="return 'throw'; 256382"];
5780 [label="FullWidth = this.Text.Length; 256383"];
5781 [label="FullWidth 256384"];
5782 [label="this.AdjustFlagsAndWidth(trailing); 256385"];
5783 [label="return 'public'; 256386"];
5784 [label="FullWidth = this.Text.Length; 256387"];
5785 [label="FullWidth 256388"];
5786 [label="return 'public'; 256389"];
5787 [label="FullWidth = this.Text.Length; 256390"];
5788 [label="FullWidth 256391"];
5789 [label="this.AdjustFlagsAndWidth(leading); 256392"];
5790 [label="return 'public'; 256393"];
5791 [label="FullWidth = this.Text.Length; 256394"];
5792 [label="FullWidth 256395"];
5793 [label="this.AdjustFlagsAndWidth(trailing); 256396"];
5794 [label="return 'public'; 256397"];
5795 [label="FullWidth = this.Text.Length; 256398"];
5796 [label="FullWidth 256399"];
5797 [label="this.AdjustFlagsAndWidth(trailing); 256400"];
5798 [label="return 'private'; 256401"];
5799 [label="FullWidth = this.Text.Length; 256402"];
5800 [label="FullWidth 256403"];
5801 [label="return 'private'; 256404"];
5802 [label="FullWidth = this.Text.Length; 256405"];
5803 [label="FullWidth 256406"];
5804 [label="this.AdjustFlagsAndWidth(leading); 256407"];
5805 [label="return 'private'; 256408"];
5806 [label="FullWidth = this.Text.Length; 256409"];
5807 [label="FullWidth 256410"];
5808 [label="this.AdjustFlagsAndWidth(trailing); 256411"];
5809 [label="return 'private'; 256412"];
5810 [label="FullWidth = this.Text.Length; 256413"];
5811 [label="FullWidth 256414"];
5812 [label="this.AdjustFlagsAndWidth(trailing); 256415"];
5813 [label="return 'internal'; 256416"];
5814 [label="FullWidth = this.Text.Length; 256417"];
5815 [label="FullWidth 256418"];
5816 [label="return 'internal'; 256419"];
5817 [label="FullWidth = this.Text.Length; 256420"];
5818 [label="FullWidth 256421"];
5819 [label="this.AdjustFlagsAndWidth(leading); 256422"];
5820 [label="return 'internal'; 256423"];
5821 [label="FullWidth = this.Text.Length; 256424"];
5822 [label="FullWidth 256425"];
5823 [label="this.AdjustFlagsAndWidth(trailing); 256426"];
5824 [label="return 'internal'; 256427"];
5825 [label="FullWidth = this.Text.Length; 256428"];
5826 [label="FullWidth 256429"];
5827 [label="this.AdjustFlagsAndWidth(trailing); 256430"];
5828 [label="return 'protected'; 256431"];
5829 [label="FullWidth = this.Text.Length; 256432"];
5830 [label="FullWidth 256433"];
5831 [label="return 'protected'; 256434"];
5832 [label="FullWidth = this.Text.Length; 256435"];
5833 [label="FullWidth 256436"];
5834 [label="this.AdjustFlagsAndWidth(leading); 256437"];
5835 [label="return 'protected'; 256438"];
5836 [label="FullWidth = this.Text.Length; 256439"];
5837 [label="FullWidth 256440"];
5838 [label="this.AdjustFlagsAndWidth(trailing); 256441"];
5839 [label="return 'protected'; 256442"];
5840 [label="FullWidth = this.Text.Length; 256443"];
5841 [label="FullWidth 256444"];
5842 [label="this.AdjustFlagsAndWidth(trailing); 256445"];
5843 [label="return 'static'; 256446"];
5844 [label="FullWidth = this.Text.Length; 256447"];
5845 [label="FullWidth 256448"];
5846 [label="return 'static'; 256449"];
5847 [label="FullWidth = this.Text.Length; 256450"];
5848 [label="FullWidth 256451"];
5849 [label="this.AdjustFlagsAndWidth(leading); 256452"];
5850 [label="return 'static'; 256453"];
5851 [label="FullWidth = this.Text.Length; 256454"];
5852 [label="FullWidth 256455"];
5853 [label="this.AdjustFlagsAndWidth(trailing); 256456"];
5854 [label="return 'static'; 256457"];
5855 [label="FullWidth = this.Text.Length; 256458"];
5856 [label="FullWidth 256459"];
5857 [label="this.AdjustFlagsAndWidth(trailing); 256460"];
5858 [label="return 'readonly'; 256461"];
5859 [label="FullWidth = this.Text.Length; 256462"];
5860 [label="FullWidth 256463"];
5861 [label="return 'readonly'; 256464"];
5862 [label="FullWidth = this.Text.Length; 256465"];
5863 [label="FullWidth 256466"];
5864 [label="this.AdjustFlagsAndWidth(leading); 256467"];
5865 [label="return 'readonly'; 256468"];
5866 [label="FullWidth = this.Text.Length; 256469"];
5867 [label="FullWidth 256470"];
5868 [label="this.AdjustFlagsAndWidth(trailing); 256471"];
5869 [label="return 'readonly'; 256472"];
5870 [label="FullWidth = this.Text.Length; 256473"];
5871 [label="FullWidth 256474"];
5872 [label="this.AdjustFlagsAndWidth(trailing); 256475"];
5873 [label="return 'sealed'; 256476"];
5874 [label="FullWidth = this.Text.Length; 256477"];
5875 [label="FullWidth 256478"];
5876 [label="return 'sealed'; 256479"];
5877 [label="FullWidth = this.Text.Length; 256480"];
5878 [label="FullWidth 256481"];
5879 [label="this.AdjustFlagsAndWidth(leading); 256482"];
5880 [label="return 'sealed'; 256483"];
5881 [label="FullWidth = this.Text.Length; 256484"];
5882 [label="FullWidth 256485"];
5883 [label="this.AdjustFlagsAndWidth(trailing); 256486"];
5884 [label="return 'sealed'; 256487"];
5885 [label="FullWidth = this.Text.Length; 256488"];
5886 [label="FullWidth 256489"];
5887 [label="this.AdjustFlagsAndWidth(trailing); 256490"];
5888 [label="return 'const'; 256491"];
5889 [label="FullWidth = this.Text.Length; 256492"];
5890 [label="FullWidth 256493"];
5891 [label="return 'const'; 256494"];
5892 [label="FullWidth = this.Text.Length; 256495"];
5893 [label="FullWidth 256496"];
5894 [label="this.AdjustFlagsAndWidth(leading); 256497"];
5895 [label="return 'const'; 256498"];
5896 [label="FullWidth = this.Text.Length; 256499"];
5897 [label="FullWidth 256500"];
5898 [label="this.AdjustFlagsAndWidth(trailing); 256501"];
5899 [label="return 'const'; 256502"];
5900 [label="FullWidth = this.Text.Length; 256503"];
5901 [label="FullWidth 256504"];
5902 [label="this.AdjustFlagsAndWidth(trailing); 256505"];
5903 [label="return 'fixed'; 256506"];
5904 [label="FullWidth = this.Text.Length; 256507"];
5905 [label="FullWidth 256508"];
5906 [label="return 'fixed'; 256509"];
5907 [label="FullWidth = this.Text.Length; 256510"];
5908 [label="FullWidth 256511"];
5909 [label="this.AdjustFlagsAndWidth(leading); 256512"];
5910 [label="return 'fixed'; 256513"];
5911 [label="FullWidth = this.Text.Length; 256514"];
5912 [label="FullWidth 256515"];
5913 [label="this.AdjustFlagsAndWidth(trailing); 256516"];
5914 [label="return 'fixed'; 256517"];
5915 [label="FullWidth = this.Text.Length; 256518"];
5916 [label="FullWidth 256519"];
5917 [label="this.AdjustFlagsAndWidth(trailing); 256520"];
5918 [label="return 'stackalloc'; 256521"];
5919 [label="FullWidth = this.Text.Length; 256522"];
5920 [label="FullWidth 256523"];
5921 [label="return 'stackalloc'; 256524"];
5922 [label="FullWidth = this.Text.Length; 256525"];
5923 [label="FullWidth 256526"];
5924 [label="this.AdjustFlagsAndWidth(leading); 256527"];
5925 [label="return 'stackalloc'; 256528"];
5926 [label="FullWidth = this.Text.Length; 256529"];
5927 [label="FullWidth 256530"];
5928 [label="this.AdjustFlagsAndWidth(trailing); 256531"];
5929 [label="return 'stackalloc'; 256532"];
5930 [label="FullWidth = this.Text.Length; 256533"];
5931 [label="FullWidth 256534"];
5932 [label="this.AdjustFlagsAndWidth(trailing); 256535"];
5933 [label="return 'volatile'; 256536"];
5934 [label="FullWidth = this.Text.Length; 256537"];
5935 [label="FullWidth 256538"];
5936 [label="return 'volatile'; 256539"];
5937 [label="FullWidth = this.Text.Length; 256540"];
5938 [label="FullWidth 256541"];
5939 [label="this.AdjustFlagsAndWidth(leading); 256542"];
5940 [label="return 'volatile'; 256543"];
5941 [label="FullWidth = this.Text.Length; 256544"];
5942 [label="FullWidth 256545"];
5943 [label="this.AdjustFlagsAndWidth(trailing); 256546"];
5944 [label="return 'volatile'; 256547"];
5945 [label="FullWidth = this.Text.Length; 256548"];
5946 [label="FullWidth 256549"];
5947 [label="this.AdjustFlagsAndWidth(trailing); 256550"];
5948 [label="return 'new'; 256551"];
5949 [label="FullWidth = this.Text.Length; 256552"];
5950 [label="FullWidth 256553"];
5951 [label="return 'new'; 256554"];
5952 [label="FullWidth = this.Text.Length; 256555"];
5953 [label="FullWidth 256556"];
5954 [label="this.AdjustFlagsAndWidth(leading); 256557"];
5955 [label="return 'new'; 256558"];
5956 [label="FullWidth = this.Text.Length; 256559"];
5957 [label="FullWidth 256560"];
5958 [label="this.AdjustFlagsAndWidth(trailing); 256561"];
5959 [label="return 'new'; 256562"];
5960 [label="FullWidth = this.Text.Length; 256563"];
5961 [label="FullWidth 256564"];
5962 [label="this.AdjustFlagsAndWidth(trailing); 256565"];
5963 [label="return 'override'; 256566"];
5964 [label="FullWidth = this.Text.Length; 256567"];
5965 [label="FullWidth 256568"];
5966 [label="return 'override'; 256569"];
5967 [label="FullWidth = this.Text.Length; 256570"];
5968 [label="FullWidth 256571"];
5969 [label="this.AdjustFlagsAndWidth(leading); 256572"];
5970 [label="return 'override'; 256573"];
5971 [label="FullWidth = this.Text.Length; 256574"];
5972 [label="FullWidth 256575"];
5973 [label="this.AdjustFlagsAndWidth(trailing); 256576"];
5974 [label="return 'override'; 256577"];
5975 [label="FullWidth = this.Text.Length; 256578"];
5976 [label="FullWidth 256579"];
5977 [label="this.AdjustFlagsAndWidth(trailing); 256580"];
5978 [label="return 'abstract'; 256581"];
5979 [label="FullWidth = this.Text.Length; 256582"];
5980 [label="FullWidth 256583"];
5981 [label="return 'abstract'; 256584"];
5982 [label="FullWidth = this.Text.Length; 256585"];
5983 [label="FullWidth 256586"];
5984 [label="this.AdjustFlagsAndWidth(leading); 256587"];
5985 [label="return 'abstract'; 256588"];
5986 [label="FullWidth = this.Text.Length; 256589"];
5987 [label="FullWidth 256590"];
5988 [label="this.AdjustFlagsAndWidth(trailing); 256591"];
5989 [label="return 'abstract'; 256592"];
5990 [label="FullWidth = this.Text.Length; 256593"];
5991 [label="FullWidth 256594"];
5992 [label="this.AdjustFlagsAndWidth(trailing); 256595"];
5993 [label="return 'virtual'; 256596"];
5994 [label="FullWidth = this.Text.Length; 256597"];
5995 [label="FullWidth 256598"];
5996 [label="return 'virtual'; 256599"];
5997 [label="FullWidth = this.Text.Length; 256600"];
5998 [label="FullWidth 256601"];
5999 [label="this.AdjustFlagsAndWidth(leading); 256602"];
6000 [label="return 'virtual'; 256603"];
6001 [label="FullWidth = this.Text.Length; 256604"];
6002 [label="FullWidth 256605"];
6003 [label="this.AdjustFlagsAndWidth(trailing); 256606"];
6004 [label="return 'virtual'; 256607"];
6005 [label="FullWidth = this.Text.Length; 256608"];
6006 [label="FullWidth 256609"];
6007 [label="this.AdjustFlagsAndWidth(trailing); 256610"];
6008 [label="return 'event'; 256611"];
6009 [label="FullWidth = this.Text.Length; 256612"];
6010 [label="FullWidth 256613"];
6011 [label="return 'event'; 256614"];
6012 [label="FullWidth = this.Text.Length; 256615"];
6013 [label="FullWidth 256616"];
6014 [label="this.AdjustFlagsAndWidth(leading); 256617"];
6015 [label="return 'event'; 256618"];
6016 [label="FullWidth = this.Text.Length; 256619"];
6017 [label="FullWidth 256620"];
6018 [label="this.AdjustFlagsAndWidth(trailing); 256621"];
6019 [label="return 'event'; 256622"];
6020 [label="FullWidth = this.Text.Length; 256623"];
6021 [label="FullWidth 256624"];
6022 [label="this.AdjustFlagsAndWidth(trailing); 256625"];
6023 [label="return 'extern'; 256626"];
6024 [label="FullWidth = this.Text.Length; 256627"];
6025 [label="FullWidth 256628"];
6026 [label="return 'extern'; 256629"];
6027 [label="FullWidth = this.Text.Length; 256630"];
6028 [label="FullWidth 256631"];
6029 [label="this.AdjustFlagsAndWidth(leading); 256632"];
6030 [label="return 'extern'; 256633"];
6031 [label="FullWidth = this.Text.Length; 256634"];
6032 [label="FullWidth 256635"];
6033 [label="this.AdjustFlagsAndWidth(trailing); 256636"];
6034 [label="return 'extern'; 256637"];
6035 [label="FullWidth = this.Text.Length; 256638"];
6036 [label="FullWidth 256639"];
6037 [label="this.AdjustFlagsAndWidth(trailing); 256640"];
6038 [label="return 'ref'; 256641"];
6039 [label="FullWidth = this.Text.Length; 256642"];
6040 [label="FullWidth 256643"];
6041 [label="return 'ref'; 256644"];
6042 [label="FullWidth = this.Text.Length; 256645"];
6043 [label="FullWidth 256646"];
6044 [label="this.AdjustFlagsAndWidth(leading); 256647"];
6045 [label="return 'ref'; 256648"];
6046 [label="FullWidth = this.Text.Length; 256649"];
6047 [label="FullWidth 256650"];
6048 [label="this.AdjustFlagsAndWidth(trailing); 256651"];
6049 [label="return 'ref'; 256652"];
6050 [label="FullWidth = this.Text.Length; 256653"];
6051 [label="FullWidth 256654"];
6052 [label="this.AdjustFlagsAndWidth(trailing); 256655"];
6053 [label="return 'out'; 256656"];
6054 [label="FullWidth = this.Text.Length; 256657"];
6055 [label="FullWidth 256658"];
6056 [label="return 'out'; 256659"];
6057 [label="FullWidth = this.Text.Length; 256660"];
6058 [label="FullWidth 256661"];
6059 [label="this.AdjustFlagsAndWidth(leading); 256662"];
6060 [label="return 'out'; 256663"];
6061 [label="FullWidth = this.Text.Length; 256664"];
6062 [label="FullWidth 256665"];
6063 [label="this.AdjustFlagsAndWidth(trailing); 256666"];
6064 [label="return 'out'; 256667"];
6065 [label="FullWidth = this.Text.Length; 256668"];
6066 [label="FullWidth 256669"];
6067 [label="this.AdjustFlagsAndWidth(trailing); 256670"];
6068 [label="return 'in'; 256671"];
6069 [label="FullWidth = this.Text.Length; 256672"];
6070 [label="FullWidth 256673"];
6071 [label="return 'in'; 256674"];
6072 [label="FullWidth = this.Text.Length; 256675"];
6073 [label="FullWidth 256676"];
6074 [label="this.AdjustFlagsAndWidth(leading); 256677"];
6075 [label="return 'in'; 256678"];
6076 [label="FullWidth = this.Text.Length; 256679"];
6077 [label="FullWidth 256680"];
6078 [label="this.AdjustFlagsAndWidth(trailing); 256681"];
6079 [label="return 'in'; 256682"];
6080 [label="FullWidth = this.Text.Length; 256683"];
6081 [label="FullWidth 256684"];
6082 [label="this.AdjustFlagsAndWidth(trailing); 256685"];
6083 [label="return 'is'; 256686"];
6084 [label="FullWidth = this.Text.Length; 256687"];
6085 [label="FullWidth 256688"];
6086 [label="return 'is'; 256689"];
6087 [label="FullWidth = this.Text.Length; 256690"];
6088 [label="FullWidth 256691"];
6089 [label="this.AdjustFlagsAndWidth(leading); 256692"];
6090 [label="return 'is'; 256693"];
6091 [label="FullWidth = this.Text.Length; 256694"];
6092 [label="FullWidth 256695"];
6093 [label="this.AdjustFlagsAndWidth(trailing); 256696"];
6094 [label="return 'is'; 256697"];
6095 [label="FullWidth = this.Text.Length; 256698"];
6096 [label="FullWidth 256699"];
6097 [label="this.AdjustFlagsAndWidth(trailing); 256700"];
6098 [label="return 'as'; 256701"];
6099 [label="FullWidth = this.Text.Length; 256702"];
6100 [label="FullWidth 256703"];
6101 [label="return 'as'; 256704"];
6102 [label="FullWidth = this.Text.Length; 256705"];
6103 [label="FullWidth 256706"];
6104 [label="this.AdjustFlagsAndWidth(leading); 256707"];
6105 [label="return 'as'; 256708"];
6106 [label="FullWidth = this.Text.Length; 256709"];
6107 [label="FullWidth 256710"];
6108 [label="this.AdjustFlagsAndWidth(trailing); 256711"];
6109 [label="return 'as'; 256712"];
6110 [label="FullWidth = this.Text.Length; 256713"];
6111 [label="FullWidth 256714"];
6112 [label="this.AdjustFlagsAndWidth(trailing); 256715"];
6113 [label="return 'params'; 256716"];
6114 [label="FullWidth = this.Text.Length; 256717"];
6115 [label="FullWidth 256718"];
6116 [label="return 'params'; 256719"];
6117 [label="FullWidth = this.Text.Length; 256720"];
6118 [label="FullWidth 256721"];
6119 [label="this.AdjustFlagsAndWidth(leading); 256722"];
6120 [label="return 'params'; 256723"];
6121 [label="FullWidth = this.Text.Length; 256724"];
6122 [label="FullWidth 256725"];
6123 [label="this.AdjustFlagsAndWidth(trailing); 256726"];
6124 [label="return 'params'; 256727"];
6125 [label="FullWidth = this.Text.Length; 256728"];
6126 [label="FullWidth 256729"];
6127 [label="this.AdjustFlagsAndWidth(trailing); 256730"];
6128 [label="return '__arglist'; 256731"];
6129 [label="FullWidth = this.Text.Length; 256732"];
6130 [label="FullWidth 256733"];
6131 [label="return '__arglist'; 256734"];
6132 [label="FullWidth = this.Text.Length; 256735"];
6133 [label="FullWidth 256736"];
6134 [label="this.AdjustFlagsAndWidth(leading); 256737"];
6135 [label="return '__arglist'; 256738"];
6136 [label="FullWidth = this.Text.Length; 256739"];
6137 [label="FullWidth 256740"];
6138 [label="this.AdjustFlagsAndWidth(trailing); 256741"];
6139 [label="return '__arglist'; 256742"];
6140 [label="FullWidth = this.Text.Length; 256743"];
6141 [label="FullWidth 256744"];
6142 [label="this.AdjustFlagsAndWidth(trailing); 256745"];
6143 [label="return '__makeref'; 256746"];
6144 [label="FullWidth = this.Text.Length; 256747"];
6145 [label="FullWidth 256748"];
6146 [label="return '__makeref'; 256749"];
6147 [label="FullWidth = this.Text.Length; 256750"];
6148 [label="FullWidth 256751"];
6149 [label="this.AdjustFlagsAndWidth(leading); 256752"];
6150 [label="return '__makeref'; 256753"];
6151 [label="FullWidth = this.Text.Length; 256754"];
6152 [label="FullWidth 256755"];
6153 [label="this.AdjustFlagsAndWidth(trailing); 256756"];
6154 [label="return '__makeref'; 256757"];
6155 [label="FullWidth = this.Text.Length; 256758"];
6156 [label="FullWidth 256759"];
6157 [label="this.AdjustFlagsAndWidth(trailing); 256760"];
6158 [label="return '__reftype'; 256761"];
6159 [label="FullWidth = this.Text.Length; 256762"];
6160 [label="FullWidth 256763"];
6161 [label="return '__reftype'; 256764"];
6162 [label="FullWidth = this.Text.Length; 256765"];
6163 [label="FullWidth 256766"];
6164 [label="this.AdjustFlagsAndWidth(leading); 256767"];
6165 [label="return '__reftype'; 256768"];
6166 [label="FullWidth = this.Text.Length; 256769"];
6167 [label="FullWidth 256770"];
6168 [label="this.AdjustFlagsAndWidth(trailing); 256771"];
6169 [label="return '__reftype'; 256772"];
6170 [label="FullWidth = this.Text.Length; 256773"];
6171 [label="FullWidth 256774"];
6172 [label="this.AdjustFlagsAndWidth(trailing); 256775"];
6173 [label="return '__refvalue'; 256776"];
6174 [label="FullWidth = this.Text.Length; 256777"];
6175 [label="FullWidth 256778"];
6176 [label="return '__refvalue'; 256779"];
6177 [label="FullWidth = this.Text.Length; 256780"];
6178 [label="FullWidth 256781"];
6179 [label="this.AdjustFlagsAndWidth(leading); 256782"];
6180 [label="return '__refvalue'; 256783"];
6181 [label="FullWidth = this.Text.Length; 256784"];
6182 [label="FullWidth 256785"];
6183 [label="this.AdjustFlagsAndWidth(trailing); 256786"];
6184 [label="return '__refvalue'; 256787"];
6185 [label="FullWidth = this.Text.Length; 256788"];
6186 [label="FullWidth 256789"];
6187 [label="this.AdjustFlagsAndWidth(trailing); 256790"];
6188 [label="return 'this'; 256791"];
6189 [label="FullWidth = this.Text.Length; 256792"];
6190 [label="FullWidth 256793"];
6191 [label="return 'this'; 256794"];
6192 [label="FullWidth = this.Text.Length; 256795"];
6193 [label="FullWidth 256796"];
6194 [label="this.AdjustFlagsAndWidth(leading); 256797"];
6195 [label="return 'this'; 256798"];
6196 [label="FullWidth = this.Text.Length; 256799"];
6197 [label="FullWidth 256800"];
6198 [label="this.AdjustFlagsAndWidth(trailing); 256801"];
6199 [label="return 'this'; 256802"];
6200 [label="FullWidth = this.Text.Length; 256803"];
6201 [label="FullWidth 256804"];
6202 [label="this.AdjustFlagsAndWidth(trailing); 256805"];
6203 [label="return 'base'; 256806"];
6204 [label="FullWidth = this.Text.Length; 256807"];
6205 [label="FullWidth 256808"];
6206 [label="return 'base'; 256809"];
6207 [label="FullWidth = this.Text.Length; 256810"];
6208 [label="FullWidth 256811"];
6209 [label="this.AdjustFlagsAndWidth(leading); 256812"];
6210 [label="return 'base'; 256813"];
6211 [label="FullWidth = this.Text.Length; 256814"];
6212 [label="FullWidth 256815"];
6213 [label="this.AdjustFlagsAndWidth(trailing); 256816"];
6214 [label="return 'base'; 256817"];
6215 [label="FullWidth = this.Text.Length; 256818"];
6216 [label="FullWidth 256819"];
6217 [label="this.AdjustFlagsAndWidth(trailing); 256820"];
6218 [label="return 'namespace'; 256821"];
6219 [label="FullWidth = this.Text.Length; 256822"];
6220 [label="FullWidth 256823"];
6221 [label="return 'namespace'; 256824"];
6222 [label="FullWidth = this.Text.Length; 256825"];
6223 [label="FullWidth 256826"];
6224 [label="this.AdjustFlagsAndWidth(leading); 256827"];
6225 [label="return 'namespace'; 256828"];
6226 [label="FullWidth = this.Text.Length; 256829"];
6227 [label="FullWidth 256830"];
6228 [label="this.AdjustFlagsAndWidth(trailing); 256831"];
6229 [label="return 'namespace'; 256832"];
6230 [label="FullWidth = this.Text.Length; 256833"];
6231 [label="FullWidth 256834"];
6232 [label="this.AdjustFlagsAndWidth(trailing); 256835"];
6233 [label="return 'using'; 256836"];
6234 [label="FullWidth = this.Text.Length; 256837"];
6235 [label="FullWidth 256838"];
6236 [label="return 'using'; 256839"];
6237 [label="FullWidth = this.Text.Length; 256840"];
6238 [label="FullWidth 256841"];
6239 [label="this.AdjustFlagsAndWidth(leading); 256842"];
6240 [label="return 'using'; 256843"];
6241 [label="FullWidth = this.Text.Length; 256844"];
6242 [label="FullWidth 256845"];
6243 [label="this.AdjustFlagsAndWidth(trailing); 256846"];
6244 [label="return 'using'; 256847"];
6245 [label="FullWidth = this.Text.Length; 256848"];
6246 [label="FullWidth 256849"];
6247 [label="this.AdjustFlagsAndWidth(trailing); 256850"];
6248 [label="return 'class'; 256851"];
6249 [label="FullWidth = this.Text.Length; 256852"];
6250 [label="FullWidth 256853"];
6251 [label="return 'class'; 256854"];
6252 [label="FullWidth = this.Text.Length; 256855"];
6253 [label="FullWidth 256856"];
6254 [label="this.AdjustFlagsAndWidth(leading); 256857"];
6255 [label="return 'class'; 256858"];
6256 [label="FullWidth = this.Text.Length; 256859"];
6257 [label="FullWidth 256860"];
6258 [label="this.AdjustFlagsAndWidth(trailing); 256861"];
6259 [label="return 'class'; 256862"];
6260 [label="FullWidth = this.Text.Length; 256863"];
6261 [label="FullWidth 256864"];
6262 [label="this.AdjustFlagsAndWidth(trailing); 256865"];
6263 [label="return 'struct'; 256866"];
6264 [label="FullWidth = this.Text.Length; 256867"];
6265 [label="FullWidth 256868"];
6266 [label="return 'struct'; 256869"];
6267 [label="FullWidth = this.Text.Length; 256870"];
6268 [label="FullWidth 256871"];
6269 [label="this.AdjustFlagsAndWidth(leading); 256872"];
6270 [label="return 'struct'; 256873"];
6271 [label="FullWidth = this.Text.Length; 256874"];
6272 [label="FullWidth 256875"];
6273 [label="this.AdjustFlagsAndWidth(trailing); 256876"];
6274 [label="return 'struct'; 256877"];
6275 [label="FullWidth = this.Text.Length; 256878"];
6276 [label="FullWidth 256879"];
6277 [label="this.AdjustFlagsAndWidth(trailing); 256880"];
6278 [label="return 'interface'; 256881"];
6279 [label="FullWidth = this.Text.Length; 256882"];
6280 [label="FullWidth 256883"];
6281 [label="return 'interface'; 256884"];
6282 [label="FullWidth = this.Text.Length; 256885"];
6283 [label="FullWidth 256886"];
6284 [label="this.AdjustFlagsAndWidth(leading); 256887"];
6285 [label="return 'interface'; 256888"];
6286 [label="FullWidth = this.Text.Length; 256889"];
6287 [label="FullWidth 256890"];
6288 [label="this.AdjustFlagsAndWidth(trailing); 256891"];
6289 [label="return 'interface'; 256892"];
6290 [label="FullWidth = this.Text.Length; 256893"];
6291 [label="FullWidth 256894"];
6292 [label="this.AdjustFlagsAndWidth(trailing); 256895"];
6293 [label="return 'enum'; 256896"];
6294 [label="FullWidth = this.Text.Length; 256897"];
6295 [label="FullWidth 256898"];
6296 [label="return 'enum'; 256899"];
6297 [label="FullWidth = this.Text.Length; 256900"];
6298 [label="FullWidth 256901"];
6299 [label="this.AdjustFlagsAndWidth(leading); 256902"];
6300 [label="return 'enum'; 256903"];
6301 [label="FullWidth = this.Text.Length; 256904"];
6302 [label="FullWidth 256905"];
6303 [label="this.AdjustFlagsAndWidth(trailing); 256906"];
6304 [label="return 'enum'; 256907"];
6305 [label="FullWidth = this.Text.Length; 256908"];
6306 [label="FullWidth 256909"];
6307 [label="this.AdjustFlagsAndWidth(trailing); 256910"];
6308 [label="return 'delegate'; 256911"];
6309 [label="FullWidth = this.Text.Length; 256912"];
6310 [label="FullWidth 256913"];
6311 [label="return 'delegate'; 256914"];
6312 [label="FullWidth = this.Text.Length; 256915"];
6313 [label="FullWidth 256916"];
6314 [label="this.AdjustFlagsAndWidth(leading); 256917"];
6315 [label="return 'delegate'; 256918"];
6316 [label="FullWidth = this.Text.Length; 256919"];
6317 [label="FullWidth 256920"];
6318 [label="this.AdjustFlagsAndWidth(trailing); 256921"];
6319 [label="return 'delegate'; 256922"];
6320 [label="FullWidth = this.Text.Length; 256923"];
6321 [label="FullWidth 256924"];
6322 [label="this.AdjustFlagsAndWidth(trailing); 256925"];
6323 [label="return 'checked'; 256926"];
6324 [label="FullWidth = this.Text.Length; 256927"];
6325 [label="FullWidth 256928"];
6326 [label="return 'checked'; 256929"];
6327 [label="FullWidth = this.Text.Length; 256930"];
6328 [label="FullWidth 256931"];
6329 [label="this.AdjustFlagsAndWidth(leading); 256932"];
6330 [label="return 'checked'; 256933"];
6331 [label="FullWidth = this.Text.Length; 256934"];
6332 [label="FullWidth 256935"];
6333 [label="this.AdjustFlagsAndWidth(trailing); 256936"];
6334 [label="return 'checked'; 256937"];
6335 [label="FullWidth = this.Text.Length; 256938"];
6336 [label="FullWidth 256939"];
6337 [label="this.AdjustFlagsAndWidth(trailing); 256940"];
6338 [label="return 'unchecked'; 256941"];
6339 [label="FullWidth = this.Text.Length; 256942"];
6340 [label="FullWidth 256943"];
6341 [label="return 'unchecked'; 256944"];
6342 [label="FullWidth = this.Text.Length; 256945"];
6343 [label="FullWidth 256946"];
6344 [label="this.AdjustFlagsAndWidth(leading); 256947"];
6345 [label="return 'unchecked'; 256948"];
6346 [label="FullWidth = this.Text.Length; 256949"];
6347 [label="FullWidth 256950"];
6348 [label="this.AdjustFlagsAndWidth(trailing); 256951"];
6349 [label="return 'unchecked'; 256952"];
6350 [label="FullWidth = this.Text.Length; 256953"];
6351 [label="FullWidth 256954"];
6352 [label="this.AdjustFlagsAndWidth(trailing); 256955"];
6353 [label="return 'unsafe'; 256956"];
6354 [label="FullWidth = this.Text.Length; 256957"];
6355 [label="FullWidth 256958"];
6356 [label="return 'unsafe'; 256959"];
6357 [label="FullWidth = this.Text.Length; 256960"];
6358 [label="FullWidth 256961"];
6359 [label="this.AdjustFlagsAndWidth(leading); 256962"];
6360 [label="return 'unsafe'; 256963"];
6361 [label="FullWidth = this.Text.Length; 256964"];
6362 [label="FullWidth 256965"];
6363 [label="this.AdjustFlagsAndWidth(trailing); 256966"];
6364 [label="return 'unsafe'; 256967"];
6365 [label="FullWidth = this.Text.Length; 256968"];
6366 [label="FullWidth 256969"];
6367 [label="this.AdjustFlagsAndWidth(trailing); 256970"];
6368 [label="return 'operator'; 256971"];
6369 [label="FullWidth = this.Text.Length; 256972"];
6370 [label="FullWidth 256973"];
6371 [label="return 'operator'; 256974"];
6372 [label="FullWidth = this.Text.Length; 256975"];
6373 [label="FullWidth 256976"];
6374 [label="this.AdjustFlagsAndWidth(leading); 256977"];
6375 [label="return 'operator'; 256978"];
6376 [label="FullWidth = this.Text.Length; 256979"];
6377 [label="FullWidth 256980"];
6378 [label="this.AdjustFlagsAndWidth(trailing); 256981"];
6379 [label="return 'operator'; 256982"];
6380 [label="FullWidth = this.Text.Length; 256983"];
6381 [label="FullWidth 256984"];
6382 [label="this.AdjustFlagsAndWidth(trailing); 256985"];
6383 [label="return 'explicit'; 256986"];
6384 [label="FullWidth = this.Text.Length; 256987"];
6385 [label="FullWidth 256988"];
6386 [label="return 'explicit'; 256989"];
6387 [label="FullWidth = this.Text.Length; 256990"];
6388 [label="FullWidth 256991"];
6389 [label="this.AdjustFlagsAndWidth(leading); 256992"];
6390 [label="return 'explicit'; 256993"];
6391 [label="FullWidth = this.Text.Length; 256994"];
6392 [label="FullWidth 256995"];
6393 [label="this.AdjustFlagsAndWidth(trailing); 256996"];
6394 [label="return 'explicit'; 256997"];
6395 [label="FullWidth = this.Text.Length; 256998"];
6396 [label="FullWidth 256999"];
6397 [label="this.AdjustFlagsAndWidth(trailing); 257000"];
6398 [label="return 'implicit'; 257001"];
6399 [label="FullWidth = this.Text.Length; 257002"];
6400 [label="FullWidth 257003"];
6401 [label="return 'implicit'; 257004"];
6402 [label="FullWidth = this.Text.Length; 257005"];
6403 [label="FullWidth 257006"];
6404 [label="this.AdjustFlagsAndWidth(leading); 257007"];
6405 [label="return 'implicit'; 257008"];
6406 [label="FullWidth = this.Text.Length; 257009"];
6407 [label="FullWidth 257010"];
6408 [label="this.AdjustFlagsAndWidth(trailing); 257011"];
6409 [label="return 'implicit'; 257012"];
6410 [label="FullWidth = this.Text.Length; 257013"];
6411 [label="FullWidth 257014"];
6412 [label="this.AdjustFlagsAndWidth(trailing); 257015"];
6413 [label="return 'yield'; 257016"];
6414 [label="FullWidth = this.Text.Length; 257017"];
6415 [label="FullWidth 257018"];
6416 [label="return 'yield'; 257019"];
6417 [label="FullWidth = this.Text.Length; 257020"];
6418 [label="FullWidth 257021"];
6419 [label="this.AdjustFlagsAndWidth(leading); 257022"];
6420 [label="return 'yield'; 257023"];
6421 [label="FullWidth = this.Text.Length; 257024"];
6422 [label="FullWidth 257025"];
6423 [label="this.AdjustFlagsAndWidth(trailing); 257026"];
6424 [label="return 'yield'; 257027"];
6425 [label="FullWidth = this.Text.Length; 257028"];
6426 [label="FullWidth 257029"];
6427 [label="this.AdjustFlagsAndWidth(trailing); 257030"];
6428 [label="return 'partial'; 257031"];
6429 [label="FullWidth = this.Text.Length; 257032"];
6430 [label="FullWidth 257033"];
6431 [label="return 'partial'; 257034"];
6432 [label="FullWidth = this.Text.Length; 257035"];
6433 [label="FullWidth 257036"];
6434 [label="this.AdjustFlagsAndWidth(leading); 257037"];
6435 [label="return 'partial'; 257038"];
6436 [label="FullWidth = this.Text.Length; 257039"];
6437 [label="FullWidth 257040"];
6438 [label="this.AdjustFlagsAndWidth(trailing); 257041"];
6439 [label="return 'partial'; 257042"];
6440 [label="FullWidth = this.Text.Length; 257043"];
6441 [label="FullWidth 257044"];
6442 [label="this.AdjustFlagsAndWidth(trailing); 257045"];
6443 [label="return 'alias'; 257046"];
6444 [label="FullWidth = this.Text.Length; 257047"];
6445 [label="FullWidth 257048"];
6446 [label="return 'alias'; 257049"];
6447 [label="FullWidth = this.Text.Length; 257050"];
6448 [label="FullWidth 257051"];
6449 [label="this.AdjustFlagsAndWidth(leading); 257052"];
6450 [label="return 'alias'; 257053"];
6451 [label="FullWidth = this.Text.Length; 257054"];
6452 [label="FullWidth 257055"];
6453 [label="this.AdjustFlagsAndWidth(trailing); 257056"];
6454 [label="return 'alias'; 257057"];
6455 [label="FullWidth = this.Text.Length; 257058"];
6456 [label="FullWidth 257059"];
6457 [label="this.AdjustFlagsAndWidth(trailing); 257060"];
6458 [label="return 'global'; 257061"];
6459 [label="FullWidth = this.Text.Length; 257062"];
6460 [label="FullWidth 257063"];
6461 [label="return 'global'; 257064"];
6462 [label="FullWidth = this.Text.Length; 257065"];
6463 [label="FullWidth 257066"];
6464 [label="this.AdjustFlagsAndWidth(leading); 257067"];
6465 [label="return 'global'; 257068"];
6466 [label="FullWidth = this.Text.Length; 257069"];
6467 [label="FullWidth 257070"];
6468 [label="this.AdjustFlagsAndWidth(trailing); 257071"];
6469 [label="return 'global'; 257072"];
6470 [label="FullWidth = this.Text.Length; 257073"];
6471 [label="FullWidth 257074"];
6472 [label="this.AdjustFlagsAndWidth(trailing); 257075"];
6473 [label="return 'assembly'; 257076"];
6474 [label="FullWidth = this.Text.Length; 257077"];
6475 [label="FullWidth 257078"];
6476 [label="return 'assembly'; 257079"];
6477 [label="FullWidth = this.Text.Length; 257080"];
6478 [label="FullWidth 257081"];
6479 [label="this.AdjustFlagsAndWidth(leading); 257082"];
6480 [label="return 'assembly'; 257083"];
6481 [label="FullWidth = this.Text.Length; 257084"];
6482 [label="FullWidth 257085"];
6483 [label="this.AdjustFlagsAndWidth(trailing); 257086"];
6484 [label="return 'assembly'; 257087"];
6485 [label="FullWidth = this.Text.Length; 257088"];
6486 [label="FullWidth 257089"];
6487 [label="this.AdjustFlagsAndWidth(trailing); 257090"];
6488 [label="return 'module'; 257091"];
6489 [label="FullWidth = this.Text.Length; 257092"];
6490 [label="FullWidth 257093"];
6491 [label="return 'module'; 257094"];
6492 [label="FullWidth = this.Text.Length; 257095"];
6493 [label="FullWidth 257096"];
6494 [label="this.AdjustFlagsAndWidth(leading); 257097"];
6495 [label="return 'module'; 257098"];
6496 [label="FullWidth = this.Text.Length; 257099"];
6497 [label="FullWidth 257100"];
6498 [label="this.AdjustFlagsAndWidth(trailing); 257101"];
6499 [label="return 'module'; 257102"];
6500 [label="FullWidth = this.Text.Length; 257103"];
6501 [label="FullWidth 257104"];
6502 [label="this.AdjustFlagsAndWidth(trailing); 257105"];
6503 [label="return 'type'; 257106"];
6504 [label="FullWidth = this.Text.Length; 257107"];
6505 [label="FullWidth 257108"];
6506 [label="return 'type'; 257109"];
6507 [label="FullWidth = this.Text.Length; 257110"];
6508 [label="FullWidth 257111"];
6509 [label="this.AdjustFlagsAndWidth(leading); 257112"];
6510 [label="return 'type'; 257113"];
6511 [label="FullWidth = this.Text.Length; 257114"];
6512 [label="FullWidth 257115"];
6513 [label="this.AdjustFlagsAndWidth(trailing); 257116"];
6514 [label="return 'type'; 257117"];
6515 [label="FullWidth = this.Text.Length; 257118"];
6516 [label="FullWidth 257119"];
6517 [label="this.AdjustFlagsAndWidth(trailing); 257120"];
6518 [label="return 'field'; 257121"];
6519 [label="FullWidth = this.Text.Length; 257122"];
6520 [label="FullWidth 257123"];
6521 [label="return 'field'; 257124"];
6522 [label="FullWidth = this.Text.Length; 257125"];
6523 [label="FullWidth 257126"];
6524 [label="this.AdjustFlagsAndWidth(leading); 257127"];
6525 [label="return 'field'; 257128"];
6526 [label="FullWidth = this.Text.Length; 257129"];
6527 [label="FullWidth 257130"];
6528 [label="this.AdjustFlagsAndWidth(trailing); 257131"];
6529 [label="return 'field'; 257132"];
6530 [label="FullWidth = this.Text.Length; 257133"];
6531 [label="FullWidth 257134"];
6532 [label="this.AdjustFlagsAndWidth(trailing); 257135"];
6533 [label="return 'method'; 257136"];
6534 [label="FullWidth = this.Text.Length; 257137"];
6535 [label="FullWidth 257138"];
6536 [label="return 'method'; 257139"];
6537 [label="FullWidth = this.Text.Length; 257140"];
6538 [label="FullWidth 257141"];
6539 [label="this.AdjustFlagsAndWidth(leading); 257142"];
6540 [label="return 'method'; 257143"];
6541 [label="FullWidth = this.Text.Length; 257144"];
6542 [label="FullWidth 257145"];
6543 [label="this.AdjustFlagsAndWidth(trailing); 257146"];
6544 [label="return 'method'; 257147"];
6545 [label="FullWidth = this.Text.Length; 257148"];
6546 [label="FullWidth 257149"];
6547 [label="this.AdjustFlagsAndWidth(trailing); 257150"];
6548 [label="return 'param'; 257151"];
6549 [label="FullWidth = this.Text.Length; 257152"];
6550 [label="FullWidth 257153"];
6551 [label="return 'param'; 257154"];
6552 [label="FullWidth = this.Text.Length; 257155"];
6553 [label="FullWidth 257156"];
6554 [label="this.AdjustFlagsAndWidth(leading); 257157"];
6555 [label="return 'param'; 257158"];
6556 [label="FullWidth = this.Text.Length; 257159"];
6557 [label="FullWidth 257160"];
6558 [label="this.AdjustFlagsAndWidth(trailing); 257161"];
6559 [label="return 'param'; 257162"];
6560 [label="FullWidth = this.Text.Length; 257163"];
6561 [label="FullWidth 257164"];
6562 [label="this.AdjustFlagsAndWidth(trailing); 257165"];
6563 [label="return 'property'; 257166"];
6564 [label="FullWidth = this.Text.Length; 257167"];
6565 [label="FullWidth 257168"];
6566 [label="return 'property'; 257169"];
6567 [label="FullWidth = this.Text.Length; 257170"];
6568 [label="FullWidth 257171"];
6569 [label="this.AdjustFlagsAndWidth(leading); 257172"];
6570 [label="return 'property'; 257173"];
6571 [label="FullWidth = this.Text.Length; 257174"];
6572 [label="FullWidth 257175"];
6573 [label="this.AdjustFlagsAndWidth(trailing); 257176"];
6574 [label="return 'property'; 257177"];
6575 [label="FullWidth = this.Text.Length; 257178"];
6576 [label="FullWidth 257179"];
6577 [label="this.AdjustFlagsAndWidth(trailing); 257180"];
6578 [label="return 'typevar'; 257181"];
6579 [label="FullWidth = this.Text.Length; 257182"];
6580 [label="FullWidth 257183"];
6581 [label="return 'typevar'; 257184"];
6582 [label="FullWidth = this.Text.Length; 257185"];
6583 [label="FullWidth 257186"];
6584 [label="this.AdjustFlagsAndWidth(leading); 257187"];
6585 [label="return 'typevar'; 257188"];
6586 [label="FullWidth = this.Text.Length; 257189"];
6587 [label="FullWidth 257190"];
6588 [label="this.AdjustFlagsAndWidth(trailing); 257191"];
6589 [label="return 'typevar'; 257192"];
6590 [label="FullWidth = this.Text.Length; 257193"];
6591 [label="FullWidth 257194"];
6592 [label="this.AdjustFlagsAndWidth(trailing); 257195"];
6593 [label="return 'get'; 257196"];
6594 [label="FullWidth = this.Text.Length; 257197"];
6595 [label="FullWidth 257198"];
6596 [label="return 'get'; 257199"];
6597 [label="FullWidth = this.Text.Length; 257200"];
6598 [label="FullWidth 257201"];
6599 [label="this.AdjustFlagsAndWidth(leading); 257202"];
6600 [label="return 'get'; 257203"];
6601 [label="FullWidth = this.Text.Length; 257204"];
6602 [label="FullWidth 257205"];
6603 [label="this.AdjustFlagsAndWidth(trailing); 257206"];
6604 [label="return 'get'; 257207"];
6605 [label="FullWidth = this.Text.Length; 257208"];
6606 [label="FullWidth 257209"];
6607 [label="this.AdjustFlagsAndWidth(trailing); 257210"];
6608 [label="return 'set'; 257211"];
6609 [label="FullWidth = this.Text.Length; 257212"];
6610 [label="FullWidth 257213"];
6611 [label="return 'set'; 257214"];
6612 [label="FullWidth = this.Text.Length; 257215"];
6613 [label="FullWidth 257216"];
6614 [label="this.AdjustFlagsAndWidth(leading); 257217"];
6615 [label="return 'set'; 257218"];
6616 [label="FullWidth = this.Text.Length; 257219"];
6617 [label="FullWidth 257220"];
6618 [label="this.AdjustFlagsAndWidth(trailing); 257221"];
6619 [label="return 'set'; 257222"];
6620 [label="FullWidth = this.Text.Length; 257223"];
6621 [label="FullWidth 257224"];
6622 [label="this.AdjustFlagsAndWidth(trailing); 257225"];
6623 [label="return 'add'; 257226"];
6624 [label="FullWidth = this.Text.Length; 257227"];
6625 [label="FullWidth 257228"];
6626 [label="return 'add'; 257229"];
6627 [label="FullWidth = this.Text.Length; 257230"];
6628 [label="FullWidth 257231"];
6629 [label="this.AdjustFlagsAndWidth(leading); 257232"];
6630 [label="return 'add'; 257233"];
6631 [label="FullWidth = this.Text.Length; 257234"];
6632 [label="FullWidth 257235"];
6633 [label="this.AdjustFlagsAndWidth(trailing); 257236"];
6634 [label="return 'add'; 257237"];
6635 [label="FullWidth = this.Text.Length; 257238"];
6636 [label="FullWidth 257239"];
6637 [label="this.AdjustFlagsAndWidth(trailing); 257240"];
6638 [label="return 'remove'; 257241"];
6639 [label="FullWidth = this.Text.Length; 257242"];
6640 [label="FullWidth 257243"];
6641 [label="return 'remove'; 257244"];
6642 [label="FullWidth = this.Text.Length; 257245"];
6643 [label="FullWidth 257246"];
6644 [label="this.AdjustFlagsAndWidth(leading); 257247"];
6645 [label="return 'remove'; 257248"];
6646 [label="FullWidth = this.Text.Length; 257249"];
6647 [label="FullWidth 257250"];
6648 [label="this.AdjustFlagsAndWidth(trailing); 257251"];
6649 [label="return 'remove'; 257252"];
6650 [label="FullWidth = this.Text.Length; 257253"];
6651 [label="FullWidth 257254"];
6652 [label="this.AdjustFlagsAndWidth(trailing); 257255"];
6653 [label="return 'where'; 257256"];
6654 [label="FullWidth = this.Text.Length; 257257"];
6655 [label="FullWidth 257258"];
6656 [label="return 'where'; 257259"];
6657 [label="FullWidth = this.Text.Length; 257260"];
6658 [label="FullWidth 257261"];
6659 [label="this.AdjustFlagsAndWidth(leading); 257262"];
6660 [label="return 'where'; 257263"];
6661 [label="FullWidth = this.Text.Length; 257264"];
6662 [label="FullWidth 257265"];
6663 [label="this.AdjustFlagsAndWidth(trailing); 257266"];
6664 [label="return 'where'; 257267"];
6665 [label="FullWidth = this.Text.Length; 257268"];
6666 [label="FullWidth 257269"];
6667 [label="this.AdjustFlagsAndWidth(trailing); 257270"];
6668 [label="return 'from'; 257271"];
6669 [label="FullWidth = this.Text.Length; 257272"];
6670 [label="FullWidth 257273"];
6671 [label="return 'from'; 257274"];
6672 [label="FullWidth = this.Text.Length; 257275"];
6673 [label="FullWidth 257276"];
6674 [label="this.AdjustFlagsAndWidth(leading); 257277"];
6675 [label="return 'from'; 257278"];
6676 [label="FullWidth = this.Text.Length; 257279"];
6677 [label="FullWidth 257280"];
6678 [label="this.AdjustFlagsAndWidth(trailing); 257281"];
6679 [label="return 'from'; 257282"];
6680 [label="FullWidth = this.Text.Length; 257283"];
6681 [label="FullWidth 257284"];
6682 [label="this.AdjustFlagsAndWidth(trailing); 257285"];
6683 [label="return 'group'; 257286"];
6684 [label="FullWidth = this.Text.Length; 257287"];
6685 [label="FullWidth 257288"];
6686 [label="return 'group'; 257289"];
6687 [label="FullWidth = this.Text.Length; 257290"];
6688 [label="FullWidth 257291"];
6689 [label="this.AdjustFlagsAndWidth(leading); 257292"];
6690 [label="return 'group'; 257293"];
6691 [label="FullWidth = this.Text.Length; 257294"];
6692 [label="FullWidth 257295"];
6693 [label="this.AdjustFlagsAndWidth(trailing); 257296"];
6694 [label="return 'group'; 257297"];
6695 [label="FullWidth = this.Text.Length; 257298"];
6696 [label="FullWidth 257299"];
6697 [label="this.AdjustFlagsAndWidth(trailing); 257300"];
6698 [label="return 'join'; 257301"];
6699 [label="FullWidth = this.Text.Length; 257302"];
6700 [label="FullWidth 257303"];
6701 [label="return 'join'; 257304"];
6702 [label="FullWidth = this.Text.Length; 257305"];
6703 [label="FullWidth 257306"];
6704 [label="this.AdjustFlagsAndWidth(leading); 257307"];
6705 [label="return 'join'; 257308"];
6706 [label="FullWidth = this.Text.Length; 257309"];
6707 [label="FullWidth 257310"];
6708 [label="this.AdjustFlagsAndWidth(trailing); 257311"];
6709 [label="return 'join'; 257312"];
6710 [label="FullWidth = this.Text.Length; 257313"];
6711 [label="FullWidth 257314"];
6712 [label="this.AdjustFlagsAndWidth(trailing); 257315"];
6713 [label="return 'into'; 257316"];
6714 [label="FullWidth = this.Text.Length; 257317"];
6715 [label="FullWidth 257318"];
6716 [label="return 'into'; 257319"];
6717 [label="FullWidth = this.Text.Length; 257320"];
6718 [label="FullWidth 257321"];
6719 [label="this.AdjustFlagsAndWidth(leading); 257322"];
6720 [label="return 'into'; 257323"];
6721 [label="FullWidth = this.Text.Length; 257324"];
6722 [label="FullWidth 257325"];
6723 [label="this.AdjustFlagsAndWidth(trailing); 257326"];
6724 [label="return 'into'; 257327"];
6725 [label="FullWidth = this.Text.Length; 257328"];
6726 [label="FullWidth 257329"];
6727 [label="this.AdjustFlagsAndWidth(trailing); 257330"];
6728 [label="return 'let'; 257331"];
6729 [label="FullWidth = this.Text.Length; 257332"];
6730 [label="FullWidth 257333"];
6731 [label="return 'let'; 257334"];
6732 [label="FullWidth = this.Text.Length; 257335"];
6733 [label="FullWidth 257336"];
6734 [label="this.AdjustFlagsAndWidth(leading); 257337"];
6735 [label="return 'let'; 257338"];
6736 [label="FullWidth = this.Text.Length; 257339"];
6737 [label="FullWidth 257340"];
6738 [label="this.AdjustFlagsAndWidth(trailing); 257341"];
6739 [label="return 'let'; 257342"];
6740 [label="FullWidth = this.Text.Length; 257343"];
6741 [label="FullWidth 257344"];
6742 [label="this.AdjustFlagsAndWidth(trailing); 257345"];
6743 [label="return 'by'; 257346"];
6744 [label="FullWidth = this.Text.Length; 257347"];
6745 [label="FullWidth 257348"];
6746 [label="return 'by'; 257349"];
6747 [label="FullWidth = this.Text.Length; 257350"];
6748 [label="FullWidth 257351"];
6749 [label="this.AdjustFlagsAndWidth(leading); 257352"];
6750 [label="return 'by'; 257353"];
6751 [label="FullWidth = this.Text.Length; 257354"];
6752 [label="FullWidth 257355"];
6753 [label="this.AdjustFlagsAndWidth(trailing); 257356"];
6754 [label="return 'by'; 257357"];
6755 [label="FullWidth = this.Text.Length; 257358"];
6756 [label="FullWidth 257359"];
6757 [label="this.AdjustFlagsAndWidth(trailing); 257360"];
6758 [label="return 'select'; 257361"];
6759 [label="FullWidth = this.Text.Length; 257362"];
6760 [label="FullWidth 257363"];
6761 [label="return 'select'; 257364"];
6762 [label="FullWidth = this.Text.Length; 257365"];
6763 [label="FullWidth 257366"];
6764 [label="this.AdjustFlagsAndWidth(leading); 257367"];
6765 [label="return 'select'; 257368"];
6766 [label="FullWidth = this.Text.Length; 257369"];
6767 [label="FullWidth 257370"];
6768 [label="this.AdjustFlagsAndWidth(trailing); 257371"];
6769 [label="return 'select'; 257372"];
6770 [label="FullWidth = this.Text.Length; 257373"];
6771 [label="FullWidth 257374"];
6772 [label="this.AdjustFlagsAndWidth(trailing); 257375"];
6773 [label="return 'orderby'; 257376"];
6774 [label="FullWidth = this.Text.Length; 257377"];
6775 [label="FullWidth 257378"];
6776 [label="return 'orderby'; 257379"];
6777 [label="FullWidth = this.Text.Length; 257380"];
6778 [label="FullWidth 257381"];
6779 [label="this.AdjustFlagsAndWidth(leading); 257382"];
6780 [label="return 'orderby'; 257383"];
6781 [label="FullWidth = this.Text.Length; 257384"];
6782 [label="FullWidth 257385"];
6783 [label="this.AdjustFlagsAndWidth(trailing); 257386"];
6784 [label="return 'orderby'; 257387"];
6785 [label="FullWidth = this.Text.Length; 257388"];
6786 [label="FullWidth 257389"];
6787 [label="this.AdjustFlagsAndWidth(trailing); 257390"];
6788 [label="return 'on'; 257391"];
6789 [label="FullWidth = this.Text.Length; 257392"];
6790 [label="FullWidth 257393"];
6791 [label="return 'on'; 257394"];
6792 [label="FullWidth = this.Text.Length; 257395"];
6793 [label="FullWidth 257396"];
6794 [label="this.AdjustFlagsAndWidth(leading); 257397"];
6795 [label="return 'on'; 257398"];
6796 [label="FullWidth = this.Text.Length; 257399"];
6797 [label="FullWidth 257400"];
6798 [label="this.AdjustFlagsAndWidth(trailing); 257401"];
6799 [label="return 'on'; 257402"];
6800 [label="FullWidth = this.Text.Length; 257403"];
6801 [label="FullWidth 257404"];
6802 [label="this.AdjustFlagsAndWidth(trailing); 257405"];
6803 [label="return 'equals'; 257406"];
6804 [label="FullWidth = this.Text.Length; 257407"];
6805 [label="FullWidth 257408"];
6806 [label="return 'equals'; 257409"];
6807 [label="FullWidth = this.Text.Length; 257410"];
6808 [label="FullWidth 257411"];
6809 [label="this.AdjustFlagsAndWidth(leading); 257412"];
6810 [label="return 'equals'; 257413"];
6811 [label="FullWidth = this.Text.Length; 257414"];
6812 [label="FullWidth 257415"];
6813 [label="this.AdjustFlagsAndWidth(trailing); 257416"];
6814 [label="return 'equals'; 257417"];
6815 [label="FullWidth = this.Text.Length; 257418"];
6816 [label="FullWidth 257419"];
6817 [label="this.AdjustFlagsAndWidth(trailing); 257420"];
6818 [label="return 'ascending'; 257421"];
6819 [label="FullWidth = this.Text.Length; 257422"];
6820 [label="FullWidth 257423"];
6821 [label="return 'ascending'; 257424"];
6822 [label="FullWidth = this.Text.Length; 257425"];
6823 [label="FullWidth 257426"];
6824 [label="this.AdjustFlagsAndWidth(leading); 257427"];
6825 [label="return 'ascending'; 257428"];
6826 [label="FullWidth = this.Text.Length; 257429"];
6827 [label="FullWidth 257430"];
6828 [label="this.AdjustFlagsAndWidth(trailing); 257431"];
6829 [label="return 'ascending'; 257432"];
6830 [label="FullWidth = this.Text.Length; 257433"];
6831 [label="FullWidth 257434"];
6832 [label="this.AdjustFlagsAndWidth(trailing); 257435"];
6833 [label="return 'descending'; 257436"];
6834 [label="FullWidth = this.Text.Length; 257437"];
6835 [label="FullWidth 257438"];
6836 [label="return 'descending'; 257439"];
6837 [label="FullWidth = this.Text.Length; 257440"];
6838 [label="FullWidth 257441"];
6839 [label="this.AdjustFlagsAndWidth(leading); 257442"];
6840 [label="return 'descending'; 257443"];
6841 [label="FullWidth = this.Text.Length; 257444"];
6842 [label="FullWidth 257445"];
6843 [label="this.AdjustFlagsAndWidth(trailing); 257446"];
6844 [label="return 'descending'; 257447"];
6845 [label="FullWidth = this.Text.Length; 257448"];
6846 [label="FullWidth 257449"];
6847 [label="this.AdjustFlagsAndWidth(trailing); 257450"];
6848 [label="return 'nameof'; 257451"];
6849 [label="FullWidth = this.Text.Length; 257452"];
6850 [label="FullWidth 257453"];
6851 [label="return 'nameof'; 257454"];
6852 [label="FullWidth = this.Text.Length; 257455"];
6853 [label="FullWidth 257456"];
6854 [label="this.AdjustFlagsAndWidth(leading); 257457"];
6855 [label="return 'nameof'; 257458"];
6856 [label="FullWidth = this.Text.Length; 257459"];
6857 [label="FullWidth 257460"];
6858 [label="this.AdjustFlagsAndWidth(trailing); 257461"];
6859 [label="return 'nameof'; 257462"];
6860 [label="FullWidth = this.Text.Length; 257463"];
6861 [label="FullWidth 257464"];
6862 [label="this.AdjustFlagsAndWidth(trailing); 257465"];
6863 [label="return 'async'; 257466"];
6864 [label="FullWidth = this.Text.Length; 257467"];
6865 [label="FullWidth 257468"];
6866 [label="return 'async'; 257469"];
6867 [label="FullWidth = this.Text.Length; 257470"];
6868 [label="FullWidth 257471"];
6869 [label="this.AdjustFlagsAndWidth(leading); 257472"];
6870 [label="return 'async'; 257473"];
6871 [label="FullWidth = this.Text.Length; 257474"];
6872 [label="FullWidth 257475"];
6873 [label="this.AdjustFlagsAndWidth(trailing); 257476"];
6874 [label="return 'async'; 257477"];
6875 [label="FullWidth = this.Text.Length; 257478"];
6876 [label="FullWidth 257479"];
6877 [label="this.AdjustFlagsAndWidth(trailing); 257480"];
6878 [label="return 'await'; 257481"];
6879 [label="FullWidth = this.Text.Length; 257482"];
6880 [label="FullWidth 257483"];
6881 [label="return 'await'; 257484"];
6882 [label="FullWidth = this.Text.Length; 257485"];
6883 [label="FullWidth 257486"];
6884 [label="this.AdjustFlagsAndWidth(leading); 257487"];
6885 [label="return 'await'; 257488"];
6886 [label="FullWidth = this.Text.Length; 257489"];
6887 [label="FullWidth 257490"];
6888 [label="this.AdjustFlagsAndWidth(trailing); 257491"];
6889 [label="return 'await'; 257492"];
6890 [label="FullWidth = this.Text.Length; 257493"];
6891 [label="FullWidth 257494"];
6892 [label="this.AdjustFlagsAndWidth(trailing); 257495"];
6893 [label="return 'when'; 257496"];
6894 [label="FullWidth = this.Text.Length; 257497"];
6895 [label="FullWidth 257498"];
6896 [label="return 'when'; 257499"];
6897 [label="FullWidth = this.Text.Length; 257500"];
6898 [label="FullWidth 257501"];
6899 [label="this.AdjustFlagsAndWidth(leading); 257502"];
6900 [label="return 'when'; 257503"];
6901 [label="FullWidth = this.Text.Length; 257504"];
6902 [label="FullWidth 257505"];
6903 [label="this.AdjustFlagsAndWidth(trailing); 257506"];
6904 [label="return 'when'; 257507"];
6905 [label="FullWidth = this.Text.Length; 257508"];
6906 [label="FullWidth 257509"];
6907 [label="this.AdjustFlagsAndWidth(trailing); 257510"];
6908 [label="return 'or'; 257511"];
6909 [label="FullWidth = this.Text.Length; 257512"];
6910 [label="FullWidth 257513"];
6911 [label="return 'or'; 257514"];
6912 [label="FullWidth = this.Text.Length; 257515"];
6913 [label="FullWidth 257516"];
6914 [label="this.AdjustFlagsAndWidth(leading); 257517"];
6915 [label="return 'or'; 257518"];
6916 [label="FullWidth = this.Text.Length; 257519"];
6917 [label="FullWidth 257520"];
6918 [label="this.AdjustFlagsAndWidth(trailing); 257521"];
6919 [label="return 'or'; 257522"];
6920 [label="FullWidth = this.Text.Length; 257523"];
6921 [label="FullWidth 257524"];
6922 [label="this.AdjustFlagsAndWidth(trailing); 257525"];
6923 [label="return 'and'; 257526"];
6924 [label="FullWidth = this.Text.Length; 257527"];
6925 [label="FullWidth 257528"];
6926 [label="return 'and'; 257529"];
6927 [label="FullWidth = this.Text.Length; 257530"];
6928 [label="FullWidth 257531"];
6929 [label="this.AdjustFlagsAndWidth(leading); 257532"];
6930 [label="return 'and'; 257533"];
6931 [label="FullWidth = this.Text.Length; 257534"];
6932 [label="FullWidth 257535"];
6933 [label="this.AdjustFlagsAndWidth(trailing); 257536"];
6934 [label="return 'and'; 257537"];
6935 [label="FullWidth = this.Text.Length; 257538"];
6936 [label="FullWidth 257539"];
6937 [label="this.AdjustFlagsAndWidth(trailing); 257540"];
6938 [label="return 'not'; 257541"];
6939 [label="FullWidth = this.Text.Length; 257542"];
6940 [label="FullWidth 257543"];
6941 [label="return 'not'; 257544"];
6942 [label="FullWidth = this.Text.Length; 257545"];
6943 [label="FullWidth 257546"];
6944 [label="this.AdjustFlagsAndWidth(leading); 257547"];
6945 [label="return 'not'; 257548"];
6946 [label="FullWidth = this.Text.Length; 257549"];
6947 [label="FullWidth 257550"];
6948 [label="this.AdjustFlagsAndWidth(trailing); 257551"];
6949 [label="return 'not'; 257552"];
6950 [label="FullWidth = this.Text.Length; 257553"];
6951 [label="FullWidth 257554"];
6952 [label="this.AdjustFlagsAndWidth(trailing); 257555"];
6953 [label="return 'data'; 257556"];
6954 [label="FullWidth = this.Text.Length; 257557"];
6955 [label="FullWidth 257558"];
6956 [label="return 'data'; 257559"];
6957 [label="FullWidth = this.Text.Length; 257560"];
6958 [label="FullWidth 257561"];
6959 [label="this.AdjustFlagsAndWidth(leading); 257562"];
6960 [label="return 'data'; 257563"];
6961 [label="FullWidth = this.Text.Length; 257564"];
6962 [label="FullWidth 257565"];
6963 [label="this.AdjustFlagsAndWidth(trailing); 257566"];
6964 [label="return 'data'; 257567"];
6965 [label="FullWidth = this.Text.Length; 257568"];
6966 [label="FullWidth 257569"];
6967 [label="this.AdjustFlagsAndWidth(trailing); 257570"];
6968 [label="return 'with'; 257571"];
6969 [label="FullWidth = this.Text.Length; 257572"];
6970 [label="FullWidth 257573"];
6971 [label="return 'with'; 257574"];
6972 [label="FullWidth = this.Text.Length; 257575"];
6973 [label="FullWidth 257576"];
6974 [label="this.AdjustFlagsAndWidth(leading); 257577"];
6975 [label="return 'with'; 257578"];
6976 [label="FullWidth = this.Text.Length; 257579"];
6977 [label="FullWidth 257580"];
6978 [label="this.AdjustFlagsAndWidth(trailing); 257581"];
6979 [label="return 'with'; 257582"];
6980 [label="FullWidth = this.Text.Length; 257583"];
6981 [label="FullWidth 257584"];
6982 [label="this.AdjustFlagsAndWidth(trailing); 257585"];
6983 [label="return 'init'; 257586"];
6984 [label="FullWidth = this.Text.Length; 257587"];
6985 [label="FullWidth 257588"];
6986 [label="return 'init'; 257589"];
6987 [label="FullWidth = this.Text.Length; 257590"];
6988 [label="FullWidth 257591"];
6989 [label="this.AdjustFlagsAndWidth(leading); 257592"];
6990 [label="return 'init'; 257593"];
6991 [label="FullWidth = this.Text.Length; 257594"];
6992 [label="FullWidth 257595"];
6993 [label="this.AdjustFlagsAndWidth(trailing); 257596"];
6994 [label="return 'init'; 257597"];
6995 [label="FullWidth = this.Text.Length; 257598"];
6996 [label="FullWidth 257599"];
6997 [label="this.AdjustFlagsAndWidth(trailing); 257600"];
6998 [label="return 'record'; 257601"];
6999 [label="FullWidth = this.Text.Length; 257602"];
7000 [label="FullWidth 257603"];
7001 [label="return 'record'; 257604"];
7002 [label="FullWidth = this.Text.Length; 257605"];
7003 [label="FullWidth 257606"];
7004 [label="this.AdjustFlagsAndWidth(leading); 257607"];
7005 [label="return 'record'; 257608"];
7006 [label="FullWidth = this.Text.Length; 257609"];
7007 [label="FullWidth 257610"];
7008 [label="this.AdjustFlagsAndWidth(trailing); 257611"];
7009 [label="return 'record'; 257612"];
7010 [label="FullWidth = this.Text.Length; 257613"];
7011 [label="FullWidth 257614"];
7012 [label="this.AdjustFlagsAndWidth(trailing); 257615"];
7013 [label="return 'managed'; 257616"];
7014 [label="FullWidth = this.Text.Length; 257617"];
7015 [label="FullWidth 257618"];
7016 [label="return 'managed'; 257619"];
7017 [label="FullWidth = this.Text.Length; 257620"];
7018 [label="FullWidth 257621"];
7019 [label="this.AdjustFlagsAndWidth(leading); 257622"];
7020 [label="return 'managed'; 257623"];
7021 [label="FullWidth = this.Text.Length; 257624"];
7022 [label="FullWidth 257625"];
7023 [label="this.AdjustFlagsAndWidth(trailing); 257626"];
7024 [label="return 'managed'; 257627"];
7025 [label="FullWidth = this.Text.Length; 257628"];
7026 [label="FullWidth 257629"];
7027 [label="this.AdjustFlagsAndWidth(trailing); 257630"];
7028 [label="return 'unmanaged'; 257631"];
7029 [label="FullWidth = this.Text.Length; 257632"];
7030 [label="FullWidth 257633"];
7031 [label="return 'unmanaged'; 257634"];
7032 [label="FullWidth = this.Text.Length; 257635"];
7033 [label="FullWidth 257636"];
7034 [label="this.AdjustFlagsAndWidth(leading); 257637"];
7035 [label="return 'unmanaged'; 257638"];
7036 [label="FullWidth = this.Text.Length; 257639"];
7037 [label="FullWidth 257640"];
7038 [label="this.AdjustFlagsAndWidth(trailing); 257641"];
7039 [label="return 'unmanaged'; 257642"];
7040 [label="FullWidth = this.Text.Length; 257643"];
7041 [label="FullWidth 257644"];
7042 [label="this.AdjustFlagsAndWidth(trailing); 257645"];
7043 [label="return 'elif'; 257646"];
7044 [label="FullWidth = this.Text.Length; 257647"];
7045 [label="FullWidth 257648"];
7046 [label="return 'elif'; 257649"];
7047 [label="FullWidth = this.Text.Length; 257650"];
7048 [label="FullWidth 257651"];
7049 [label="this.AdjustFlagsAndWidth(leading); 257652"];
7050 [label="return 'elif'; 257653"];
7051 [label="FullWidth = this.Text.Length; 257654"];
7052 [label="FullWidth 257655"];
7053 [label="this.AdjustFlagsAndWidth(trailing); 257656"];
7054 [label="return 'elif'; 257657"];
7055 [label="FullWidth = this.Text.Length; 257658"];
7056 [label="FullWidth 257659"];
7057 [label="this.AdjustFlagsAndWidth(trailing); 257660"];
7058 [label="return 'endif'; 257661"];
7059 [label="FullWidth = this.Text.Length; 257662"];
7060 [label="FullWidth 257663"];
7061 [label="return 'endif'; 257664"];
7062 [label="FullWidth = this.Text.Length; 257665"];
7063 [label="FullWidth 257666"];
7064 [label="this.AdjustFlagsAndWidth(leading); 257667"];
7065 [label="return 'endif'; 257668"];
7066 [label="FullWidth = this.Text.Length; 257669"];
7067 [label="FullWidth 257670"];
7068 [label="this.AdjustFlagsAndWidth(trailing); 257671"];
7069 [label="return 'endif'; 257672"];
7070 [label="FullWidth = this.Text.Length; 257673"];
7071 [label="FullWidth 257674"];
7072 [label="this.AdjustFlagsAndWidth(trailing); 257675"];
7073 [label="return 'region'; 257676"];
7074 [label="FullWidth = this.Text.Length; 257677"];
7075 [label="FullWidth 257678"];
7076 [label="return 'region'; 257679"];
7077 [label="FullWidth = this.Text.Length; 257680"];
7078 [label="FullWidth 257681"];
7079 [label="this.AdjustFlagsAndWidth(leading); 257682"];
7080 [label="return 'region'; 257683"];
7081 [label="FullWidth = this.Text.Length; 257684"];
7082 [label="FullWidth 257685"];
7083 [label="this.AdjustFlagsAndWidth(trailing); 257686"];
7084 [label="return 'region'; 257687"];
7085 [label="FullWidth = this.Text.Length; 257688"];
7086 [label="FullWidth 257689"];
7087 [label="this.AdjustFlagsAndWidth(trailing); 257690"];
7088 [label="return 'endregion'; 257691"];
7089 [label="FullWidth = this.Text.Length; 257692"];
7090 [label="FullWidth 257693"];
7091 [label="return 'endregion'; 257694"];
7092 [label="FullWidth = this.Text.Length; 257695"];
7093 [label="FullWidth 257696"];
7094 [label="this.AdjustFlagsAndWidth(leading); 257697"];
7095 [label="return 'endregion'; 257698"];
7096 [label="FullWidth = this.Text.Length; 257699"];
7097 [label="FullWidth 257700"];
7098 [label="this.AdjustFlagsAndWidth(trailing); 257701"];
7099 [label="return 'endregion'; 257702"];
7100 [label="FullWidth = this.Text.Length; 257703"];
7101 [label="FullWidth 257704"];
7102 [label="this.AdjustFlagsAndWidth(trailing); 257705"];
7103 [label="return 'define'; 257706"];
7104 [label="FullWidth = this.Text.Length; 257707"];
7105 [label="FullWidth 257708"];
7106 [label="return 'define'; 257709"];
7107 [label="FullWidth = this.Text.Length; 257710"];
7108 [label="FullWidth 257711"];
7109 [label="this.AdjustFlagsAndWidth(leading); 257712"];
7110 [label="return 'define'; 257713"];
7111 [label="FullWidth = this.Text.Length; 257714"];
7112 [label="FullWidth 257715"];
7113 [label="this.AdjustFlagsAndWidth(trailing); 257716"];
7114 [label="return 'define'; 257717"];
7115 [label="FullWidth = this.Text.Length; 257718"];
7116 [label="FullWidth 257719"];
7117 [label="this.AdjustFlagsAndWidth(trailing); 257720"];
7118 [label="return 'undef'; 257721"];
7119 [label="FullWidth = this.Text.Length; 257722"];
7120 [label="FullWidth 257723"];
7121 [label="return 'undef'; 257724"];
7122 [label="FullWidth = this.Text.Length; 257725"];
7123 [label="FullWidth 257726"];
7124 [label="this.AdjustFlagsAndWidth(leading); 257727"];
7125 [label="return 'undef'; 257728"];
7126 [label="FullWidth = this.Text.Length; 257729"];
7127 [label="FullWidth 257730"];
7128 [label="this.AdjustFlagsAndWidth(trailing); 257731"];
7129 [label="return 'undef'; 257732"];
7130 [label="FullWidth = this.Text.Length; 257733"];
7131 [label="FullWidth 257734"];
7132 [label="this.AdjustFlagsAndWidth(trailing); 257735"];
7133 [label="return 'warning'; 257736"];
7134 [label="FullWidth = this.Text.Length; 257737"];
7135 [label="FullWidth 257738"];
7136 [label="return 'warning'; 257739"];
7137 [label="FullWidth = this.Text.Length; 257740"];
7138 [label="FullWidth 257741"];
7139 [label="this.AdjustFlagsAndWidth(leading); 257742"];
7140 [label="return 'warning'; 257743"];
7141 [label="FullWidth = this.Text.Length; 257744"];
7142 [label="FullWidth 257745"];
7143 [label="this.AdjustFlagsAndWidth(trailing); 257746"];
7144 [label="return 'warning'; 257747"];
7145 [label="FullWidth = this.Text.Length; 257748"];
7146 [label="FullWidth 257749"];
7147 [label="this.AdjustFlagsAndWidth(trailing); 257750"];
7148 [label="return 'error'; 257751"];
7149 [label="FullWidth = this.Text.Length; 257752"];
7150 [label="FullWidth 257753"];
7151 [label="return 'error'; 257754"];
7152 [label="FullWidth = this.Text.Length; 257755"];
7153 [label="FullWidth 257756"];
7154 [label="this.AdjustFlagsAndWidth(leading); 257757"];
7155 [label="return 'error'; 257758"];
7156 [label="FullWidth = this.Text.Length; 257759"];
7157 [label="FullWidth 257760"];
7158 [label="this.AdjustFlagsAndWidth(trailing); 257761"];
7159 [label="return 'error'; 257762"];
7160 [label="FullWidth = this.Text.Length; 257763"];
7161 [label="FullWidth 257764"];
7162 [label="this.AdjustFlagsAndWidth(trailing); 257765"];
7163 [label="return 'line'; 257766"];
7164 [label="FullWidth = this.Text.Length; 257767"];
7165 [label="FullWidth 257768"];
7166 [label="return 'line'; 257769"];
7167 [label="FullWidth = this.Text.Length; 257770"];
7168 [label="FullWidth 257771"];
7169 [label="this.AdjustFlagsAndWidth(leading); 257772"];
7170 [label="return 'line'; 257773"];
7171 [label="FullWidth = this.Text.Length; 257774"];
7172 [label="FullWidth 257775"];
7173 [label="this.AdjustFlagsAndWidth(trailing); 257776"];
7174 [label="return 'line'; 257777"];
7175 [label="FullWidth = this.Text.Length; 257778"];
7176 [label="FullWidth 257779"];
7177 [label="this.AdjustFlagsAndWidth(trailing); 257780"];
7178 [label="return 'pragma'; 257781"];
7179 [label="FullWidth = this.Text.Length; 257782"];
7180 [label="FullWidth 257783"];
7181 [label="return 'pragma'; 257784"];
7182 [label="FullWidth = this.Text.Length; 257785"];
7183 [label="FullWidth 257786"];
7184 [label="this.AdjustFlagsAndWidth(leading); 257787"];
7185 [label="return 'pragma'; 257788"];
7186 [label="FullWidth = this.Text.Length; 257789"];
7187 [label="FullWidth 257790"];
7188 [label="this.AdjustFlagsAndWidth(trailing); 257791"];
7189 [label="return 'pragma'; 257792"];
7190 [label="FullWidth = this.Text.Length; 257793"];
7191 [label="FullWidth 257794"];
7192 [label="this.AdjustFlagsAndWidth(trailing); 257795"];
7193 [label="return 'hidden'; 257796"];
7194 [label="FullWidth = this.Text.Length; 257797"];
7195 [label="FullWidth 257798"];
7196 [label="return 'hidden'; 257799"];
7197 [label="FullWidth = this.Text.Length; 257800"];
7198 [label="FullWidth 257801"];
7199 [label="this.AdjustFlagsAndWidth(leading); 257802"];
7200 [label="return 'hidden'; 257803"];
7201 [label="FullWidth = this.Text.Length; 257804"];
7202 [label="FullWidth 257805"];
7203 [label="this.AdjustFlagsAndWidth(trailing); 257806"];
7204 [label="return 'hidden'; 257807"];
7205 [label="FullWidth = this.Text.Length; 257808"];
7206 [label="FullWidth 257809"];
7207 [label="this.AdjustFlagsAndWidth(trailing); 257810"];
7208 [label="return 'checksum'; 257811"];
7209 [label="FullWidth = this.Text.Length; 257812"];
7210 [label="FullWidth 257813"];
7211 [label="return 'checksum'; 257814"];
7212 [label="FullWidth = this.Text.Length; 257815"];
7213 [label="FullWidth 257816"];
7214 [label="this.AdjustFlagsAndWidth(leading); 257817"];
7215 [label="return 'checksum'; 257818"];
7216 [label="FullWidth = this.Text.Length; 257819"];
7217 [label="FullWidth 257820"];
7218 [label="this.AdjustFlagsAndWidth(trailing); 257821"];
7219 [label="return 'checksum'; 257822"];
7220 [label="FullWidth = this.Text.Length; 257823"];
7221 [label="FullWidth 257824"];
7222 [label="this.AdjustFlagsAndWidth(trailing); 257825"];
7223 [label="return 'disable'; 257826"];
7224 [label="FullWidth = this.Text.Length; 257827"];
7225 [label="FullWidth 257828"];
7226 [label="return 'disable'; 257829"];
7227 [label="FullWidth = this.Text.Length; 257830"];
7228 [label="FullWidth 257831"];
7229 [label="this.AdjustFlagsAndWidth(leading); 257832"];
7230 [label="return 'disable'; 257833"];
7231 [label="FullWidth = this.Text.Length; 257834"];
7232 [label="FullWidth 257835"];
7233 [label="this.AdjustFlagsAndWidth(trailing); 257836"];
7234 [label="return 'disable'; 257837"];
7235 [label="FullWidth = this.Text.Length; 257838"];
7236 [label="FullWidth 257839"];
7237 [label="this.AdjustFlagsAndWidth(trailing); 257840"];
7238 [label="return 'restore'; 257841"];
7239 [label="FullWidth = this.Text.Length; 257842"];
7240 [label="FullWidth 257843"];
7241 [label="return 'restore'; 257844"];
7242 [label="FullWidth = this.Text.Length; 257845"];
7243 [label="FullWidth 257846"];
7244 [label="this.AdjustFlagsAndWidth(leading); 257847"];
7245 [label="return 'restore'; 257848"];
7246 [label="FullWidth = this.Text.Length; 257849"];
7247 [label="FullWidth 257850"];
7248 [label="this.AdjustFlagsAndWidth(trailing); 257851"];
7249 [label="return 'restore'; 257852"];
7250 [label="FullWidth = this.Text.Length; 257853"];
7251 [label="FullWidth 257854"];
7252 [label="this.AdjustFlagsAndWidth(trailing); 257855"];
7253 [label="return 'r'; 257856"];
7254 [label="FullWidth = this.Text.Length; 257857"];
7255 [label="FullWidth 257858"];
7256 [label="return 'r'; 257859"];
7257 [label="FullWidth = this.Text.Length; 257860"];
7258 [label="FullWidth 257861"];
7259 [label="this.AdjustFlagsAndWidth(leading); 257862"];
7260 [label="return 'r'; 257863"];
7261 [label="FullWidth = this.Text.Length; 257864"];
7262 [label="FullWidth 257865"];
7263 [label="this.AdjustFlagsAndWidth(trailing); 257866"];
7264 [label="return 'r'; 257867"];
7265 [label="FullWidth = this.Text.Length; 257868"];
7266 [label="FullWidth 257869"];
7267 [label="this.AdjustFlagsAndWidth(trailing); 257870"];
7268 [label="return '$\\''; 257871"];
7269 [label="FullWidth = this.Text.Length; 257872"];
7270 [label="FullWidth 257873"];
7271 [label="return '$\\''; 257874"];
7272 [label="FullWidth = this.Text.Length; 257875"];
7273 [label="FullWidth 257876"];
7274 [label="this.AdjustFlagsAndWidth(leading); 257877"];
7275 [label="return '$\\''; 257878"];
7276 [label="FullWidth = this.Text.Length; 257879"];
7277 [label="FullWidth 257880"];
7278 [label="this.AdjustFlagsAndWidth(trailing); 257881"];
7279 [label="return '$\\''; 257882"];
7280 [label="FullWidth = this.Text.Length; 257883"];
7281 [label="FullWidth 257884"];
7282 [label="this.AdjustFlagsAndWidth(trailing); 257885"];
7283 [label="return '\\''; 257886"];
7284 [label="FullWidth = this.Text.Length; 257887"];
7285 [label="FullWidth 257888"];
7286 [label="return '\\''; 257889"];
7287 [label="FullWidth = this.Text.Length; 257890"];
7288 [label="FullWidth 257891"];
7289 [label="this.AdjustFlagsAndWidth(leading); 257892"];
7290 [label="return '\\''; 257893"];
7291 [label="FullWidth = this.Text.Length; 257894"];
7292 [label="FullWidth 257895"];
7293 [label="this.AdjustFlagsAndWidth(trailing); 257896"];
7294 [label="return '\\''; 257897"];
7295 [label="FullWidth = this.Text.Length; 257898"];
7296 [label="FullWidth 257899"];
7297 [label="this.AdjustFlagsAndWidth(trailing); 257900"];
7298 [label="return '$@\\''; 257901"];
7299 [label="FullWidth = this.Text.Length; 257902"];
7300 [label="FullWidth 257903"];
7301 [label="return '$@\\''; 257904"];
7302 [label="FullWidth = this.Text.Length; 257905"];
7303 [label="FullWidth 257906"];
7304 [label="this.AdjustFlagsAndWidth(leading); 257907"];
7305 [label="return '$@\\''; 257908"];
7306 [label="FullWidth = this.Text.Length; 257909"];
7307 [label="FullWidth 257910"];
7308 [label="this.AdjustFlagsAndWidth(trailing); 257911"];
7309 [label="return '$@\\''; 257912"];
7310 [label="FullWidth = this.Text.Length; 257913"];
7311 [label="FullWidth 257914"];
7312 [label="this.AdjustFlagsAndWidth(trailing); 257915"];
7313 [label="return 'load'; 257916"];
7314 [label="FullWidth = this.Text.Length; 257917"];
7315 [label="FullWidth 257918"];
7316 [label="return 'load'; 257919"];
7317 [label="FullWidth = this.Text.Length; 257920"];
7318 [label="FullWidth 257921"];
7319 [label="this.AdjustFlagsAndWidth(leading); 257922"];
7320 [label="return 'load'; 257923"];
7321 [label="FullWidth = this.Text.Length; 257924"];
7322 [label="FullWidth 257925"];
7323 [label="this.AdjustFlagsAndWidth(trailing); 257926"];
7324 [label="return 'load'; 257927"];
7325 [label="FullWidth = this.Text.Length; 257928"];
7326 [label="FullWidth 257929"];
7327 [label="this.AdjustFlagsAndWidth(trailing); 257930"];
7328 [label="return 'nullable'; 257931"];
7329 [label="FullWidth = this.Text.Length; 257932"];
7330 [label="FullWidth 257933"];
7331 [label="return 'nullable'; 257934"];
7332 [label="FullWidth = this.Text.Length; 257935"];
7333 [label="FullWidth 257936"];
7334 [label="this.AdjustFlagsAndWidth(leading); 257937"];
7335 [label="return 'nullable'; 257938"];
7336 [label="FullWidth = this.Text.Length; 257939"];
7337 [label="FullWidth 257940"];
7338 [label="this.AdjustFlagsAndWidth(trailing); 257941"];
7339 [label="return 'nullable'; 257942"];
7340 [label="FullWidth = this.Text.Length; 257943"];
7341 [label="FullWidth 257944"];
7342 [label="this.AdjustFlagsAndWidth(trailing); 257945"];
7343 [label="return 'enable'; 257946"];
7344 [label="FullWidth = this.Text.Length; 257947"];
7345 [label="FullWidth 257948"];
7346 [label="return 'enable'; 257949"];
7347 [label="FullWidth = this.Text.Length; 257950"];
7348 [label="FullWidth 257951"];
7349 [label="this.AdjustFlagsAndWidth(leading); 257952"];
7350 [label="return 'enable'; 257953"];
7351 [label="FullWidth = this.Text.Length; 257954"];
7352 [label="FullWidth 257955"];
7353 [label="this.AdjustFlagsAndWidth(trailing); 257956"];
7354 [label="return 'enable'; 257957"];
7355 [label="FullWidth = this.Text.Length; 257958"];
7356 [label="FullWidth 257959"];
7357 [label="this.AdjustFlagsAndWidth(trailing); 257960"];
7358 [label="return 'warnings'; 257961"];
7359 [label="FullWidth = this.Text.Length; 257962"];
7360 [label="FullWidth 257963"];
7361 [label="return 'warnings'; 257964"];
7362 [label="FullWidth = this.Text.Length; 257965"];
7363 [label="FullWidth 257966"];
7364 [label="this.AdjustFlagsAndWidth(leading); 257967"];
7365 [label="return 'warnings'; 257968"];
7366 [label="FullWidth = this.Text.Length; 257969"];
7367 [label="FullWidth 257970"];
7368 [label="this.AdjustFlagsAndWidth(trailing); 257971"];
7369 [label="return 'warnings'; 257972"];
7370 [label="FullWidth = this.Text.Length; 257973"];
7371 [label="FullWidth 257974"];
7372 [label="this.AdjustFlagsAndWidth(trailing); 257975"];
7373 [label="return 'annotations'; 257976"];
7374 [label="FullWidth = this.Text.Length; 257977"];
7375 [label="FullWidth 257978"];
7376 [label="return 'annotations'; 257979"];
7377 [label="FullWidth = this.Text.Length; 257980"];
7378 [label="FullWidth 257981"];
7379 [label="this.AdjustFlagsAndWidth(leading); 257982"];
7380 [label="return 'annotations'; 257983"];
7381 [label="FullWidth = this.Text.Length; 257984"];
7382 [label="FullWidth 257985"];
7383 [label="this.AdjustFlagsAndWidth(trailing); 257986"];
7384 [label="return 'annotations'; 257987"];
7385 [label="FullWidth = this.Text.Length; 257988"];
7386 [label="FullWidth 257989"];
7387 [label="this.AdjustFlagsAndWidth(trailing); 257990"];
7388 [label="return 'var'; 257991"];
7389 [label="FullWidth = this.Text.Length; 257992"];
7390 [label="FullWidth 257993"];
7391 [label="return 'var'; 257994"];
7392 [label="FullWidth = this.Text.Length; 257995"];
7393 [label="FullWidth 257996"];
7394 [label="this.AdjustFlagsAndWidth(leading); 257997"];
7395 [label="return 'var'; 257998"];
7396 [label="FullWidth = this.Text.Length; 257999"];
7397 [label="FullWidth 258000"];
7398 [label="this.AdjustFlagsAndWidth(trailing); 258001"];
7399 [label="return 'var'; 258002"];
7400 [label="FullWidth = this.Text.Length; 258003"];
7401 [label="FullWidth 258004"];
7402 [label="this.AdjustFlagsAndWidth(trailing); 258005"];
7403 [label="return '_'; 258006"];
7404 [label="FullWidth = this.Text.Length; 258007"];
7405 [label="FullWidth 258008"];
7406 [label="return '_'; 258009"];
7407 [label="FullWidth = this.Text.Length; 258010"];
7408 [label="FullWidth 258011"];
7409 [label="this.AdjustFlagsAndWidth(leading); 258012"];
7410 [label="return '_'; 258013"];
7411 [label="FullWidth = this.Text.Length; 258014"];
7412 [label="FullWidth 258015"];
7413 [label="this.AdjustFlagsAndWidth(trailing); 258016"];
7414 [label="return '_'; 258017"];
7415 [label="FullWidth = this.Text.Length; 258018"];
7416 [label="FullWidth 258019"];
7417 [label="this.AdjustFlagsAndWidth(trailing); 258020"];
7418 [label="return SyntaxToken.Create(kind, leading, trailing); 258021"];
7419 [label="return SyntaxToken.Create(kind, leading, trailing); 258022"];
7420 [label="return SyntaxToken.Create(kind, leading, trailing); 258023"];
7421 [label="SyntaxToken.Create(kind, leading, trailing) 258024"];
7422 [label="param Create(SyntaxKind kind) 258025"];
7423 [label="param Create(GreenNode leading) 258026"];
7424 [label="param Create(GreenNode trailing) 258027"];
7425 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 258028"];
7426 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 258029"];
7427 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 258030"];
7428 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 258031"];
7429 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 258032"];
7430 [label="return s_tokensWithNoTrivia[(int)kind].Value; 258033"];
7431 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258034"];
7432 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258035"];
7433 [label="return token; 258036"];
7434 [label="this.AddLexedToken(token); 258037"];
7435 [label="this.AddLexedToken(token) 258038"];
7436 [label="param AddLexedToken(SyntaxToken token) 258039"];
7437 [label="param AddLexedToken(this) 258040"];
7438 [label="Debug.Assert(token != null); 258041"];
7439 [label="Debug.Assert(token != null); 258042"];
7440 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 258043"];
7441 [label="_lexedTokens[_tokenCount].Value = token; 258044"];
7442 [label="_lexedTokens[_tokenCount].Value 258045"];
7443 [label="_tokenCount 258046"];
7444 [label="this.AddLexedToken(token); 258047"];
7445 [label="token.Kind 258048"];
7446 [label="get { return (SyntaxKind)this.RawKind; } 258049"];
7447 [label="return (SyntaxKind)this.RawKind; 258050"];
7448 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 258051"];
7449 [label="this.PreLex(); 258052"];
7450 [label="new SyntaxListPool() 258053"];
7451 [label="_pool = new SyntaxListPool() 258054"];
7452 [label="_syntaxFactoryContext 258055"];
7453 [label="_syntaxFactory 258056"];
7454 [label="_recursionDepth 258057"];
7455 [label="_termState 258058"];
7456 [label="_isInTry 258059"];
7457 [label="_checkedTopLevelStatementsFeatureAvailability 258060"];
7458 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 258061"];
7459 [label="_syntaxFactoryContext 258062"];
7460 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 258063"];
7461 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 258064"];
7462 [label="_syntaxFactory 258065"];
7463 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseCompilationUnit();\n                return (CompilationUnitSyntax)node.CreateRed();\n            } 258066"];
7464 [label="parser.ParseCompilationUnit() 258067"];
7465 [label="param ParseCompilationUnit(this) 258068"];
7466 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 258069"];
7467 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 258070"];
7468 [label="ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))) 258071"];
7469 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 258072"];
7470 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 258073"];
7471 [label="param ParseWithStackGuard(this) 258074"];
7472 [label="Debug.Assert(_recursionDepth == 0); 258075"];
7473 [label="Debug.Assert(_recursionDepth == 0); 258076"];
7474 [label="return parseFunc(); 258077"];
7475 [label="return parseFunc(); 258078"];
7476 [label="param ParseCompilationUnitCore(this) 258079"];
7477 [label="SyntaxToken tmp = null; 258080"];
7478 [label="SyntaxListBuilder initialBadNodes = null; 258081"];
7479 [label="var body = new NamespaceBodyBuilder(_pool); 258082"];
7480 [label="var body = new NamespaceBodyBuilder(_pool); 258083"];
7481 [label="new NamespaceBodyBuilder(_pool) 258084"];
7482 [label="param NamespaceBodyBuilder(SyntaxListPool pool) 258085"];
7483 [label="param NamespaceBodyBuilder(this) 258086"];
7484 [label="Externs = pool.Allocate<ExternAliasDirectiveSyntax>(); 258087"];
7485 [label="Externs 258088"];
7486 [label="Usings = pool.Allocate<UsingDirectiveSyntax>(); 258089"];
7487 [label="Usings 258090"];
7488 [label="Attributes = pool.Allocate<AttributeListSyntax>(); 258091"];
7489 [label="Attributes 258092"];
7490 [label="Members = pool.Allocate<MemberDeclarationSyntax>(); 258093"];
7491 [label="Members 258094"];
7492 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258095"];
7493 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258096"];
7494 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258097"];
7495 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258098"];
7496 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258099"];
7497 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 258100"];
7498 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 258101"];
7499 [label="return _syntaxFactoryContext.IsInAsync; 258102"];
7500 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 258103"];
7501 [label="this.FetchCurrentToken() 258104"];
7502 [label="param FetchCurrentToken(this) 258105"];
7503 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 258106"];
7504 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 258107"];
7505 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 258108"];
7506 [label="return _lexedTokens[_tokenOffset]; 258109"];
7507 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 258110"];
7508 [label="_currentToken 258111"];
7509 [label="get { return (SyntaxKind)this.RawKind; } 258112"];
7510 [label="return (SyntaxKind)this.RawKind; 258113"];
7511 [label="param AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers) 258114"];
7512 [label="param AddIncompleteMembers(ref NamespaceBodyBuilder body) 258115"];
7513 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 258116"];
7514 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 258117"];
7515 [label="var eof = this.EatToken(SyntaxKind.EndOfFileToken); 258118"];
7516 [label="this.EatToken(SyntaxKind.EndOfFileToken) 258119"];
7517 [label="param EatToken(SyntaxKind kind) 258120"];
7518 [label="param EatToken(this) 258121"];
7519 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 258122"];
7520 [label="SyntaxFacts.IsAnyToken(kind) 258123"];
7521 [label="param IsAnyToken(SyntaxKind kind) 258124"];
7522 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 258125"];
7523 [label="return true; 258126"];
7524 [label="this.CurrentToken 258127"];
7525 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 258128"];
7526 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 258129"];
7527 [label="var ct = this.CurrentToken; 258130"];
7528 [label="ct.Kind 258131"];
7529 [label="get { return (SyntaxKind)this.RawKind; } 258132"];
7530 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 258133"];
7531 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 258134"];
7532 [label="MoveToNextToken() 258135"];
7533 [label="param MoveToNextToken(this) 258136"];
7534 [label="_currentToken.GetTrailingTrivia() 258137"];
7535 [label="param GetTrailingTrivia(this) 258138"];
7536 [label="return null; 258139"];
7537 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 258140"];
7538 [label="_prevTokenTrailingTrivia 258141"];
7539 [label="_currentToken = null; 258142"];
7540 [label="_currentToken 258143"];
7541 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 258144"];
7542 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 258145"];
7543 [label="_tokenOffset 258146"];
7544 [label="MoveToNextToken(); 258147"];
7545 [label="return ct; 258148"];
7546 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 258149"];
7547 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 258150"];
7548 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 258151"];
7549 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 258152"];
7550 [label="param CSharpSyntaxNode(SyntaxKind kind) 258153"];
7551 [label="param CSharpSyntaxNode(this) 258154"];
7552 [label="kind 258155"];
7553 [label="param CSharpSyntaxNode(this) 258156"];
7554 [label="param CSharpSyntaxNode(this) 258157"];
7555 [label="GreenStats.NoteGreen(this); 258158"];
7556 [label="GreenStats.NoteGreen(this); 258159"];
7557 [label="param SetFactoryContext(SyntaxFactoryContext context) 258160"];
7558 [label="param SetFactoryContext(this) 258161"];
7559 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 258162"];
7560 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 258163"];
7561 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 258164"];
7562 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 258165"];
7563 [label="return result; 258166"];
7564 [label="body.Free(_pool); 258167"];
7565 [label="body.Free(_pool) 258168"];
7566 [label="param Free(SyntaxListPool pool) 258169"];
7567 [label="param Free(this) 258170"];
7568 [label="pool.Free(Members); 258171"];
7569 [label="pool.Free(Members); 258172"];
7570 [label="pool.Free(Attributes); 258173"];
7571 [label="pool.Free(Attributes); 258174"];
7572 [label="pool.Free(Usings); 258175"];
7573 [label="pool.Free(Usings); 258176"];
7574 [label="pool.Free(Externs); 258177"];
7575 [label="pool.Free(Externs); 258178"];
7576 [label="body.Free(_pool); 258179"];
7577 [label="return parseFunc(); 258180"];
7578 [label="var node = parser.ParseCompilationUnit(); 258181"];
7579 [label="return (CompilationUnitSyntax)node.CreateRed(); 258182"];
7580 [label="return (CompilationUnitSyntax)node.CreateRed(); 258183"];
7581 [label="return (CompilationUnitSyntax)node.CreateRed(); 258184"];
7582 [label="param CSharpSyntaxNode(GreenNode green) 258185"];
7583 [label="param CSharpSyntaxNode(SyntaxNode? parent) 258186"];
7584 [label="param CSharpSyntaxNode(int position) 258187"];
7585 [label="param CSharpSyntaxNode(this) 258188"];
7586 [label="green 258189"];
7587 [label="parent 258190"];
7588 [label="position 258191"];
7589 [label="param CSharpSyntaxNode(this) 258192"];
7590 [label="param CSharpSyntaxNode(this) 258193"];
7591 [label="_node = this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)); 258194"];
7592 [label="this.CloneNodeAsRoot(SyntaxFactory.ParseCompilationUnit(string.Empty)) 258195"];
7593 [label="param CloneNodeAsRoot(T node) 258196"];
7594 [label="param CloneNodeAsRoot(this) 258197"];
7595 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 258198"];
7596 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 258199"];
7597 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 258200"];
7598 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 258201"];
7599 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 258202"];
7600 [label="param CSharpSyntaxNode(this) 258203"];
7601 [label="_node 258204"];
7602 [label="Dummy = new DummySyntaxTree() 258205"];
7603 [label="return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken); 258206"];
7604 [label="return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken); 258207"];
7605 [label="return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken); 258208"];
7606 [label="return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken); 258209"];
7607 [label="CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken) 258210"];
7608 [label="param ParseText(SourceText text) 258211"];
7609 [label="param ParseText(CSharpParseOptions? options = null) 258212"];
7610 [label="param ParseText(string path = '') 258213"];
7611 [label="param ParseText(CancellationToken cancellationToken = default) 258214"];
7612 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 258215"];
7613 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 258216"];
7614 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 258217"];
7615 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 258218"];
7616 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 258219"];
7617 [label="ParseText(text, options, path, diagnosticOptions: null, cancellationToken) 258220"];
7618 [label="param ParseText(SourceText text) 258221"];
7619 [label="param ParseText(CSharpParseOptions? options) 258222"];
7620 [label="param ParseText(string path) 258223"];
7621 [label="param ParseText(ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions) 258224"];
7622 [label="param ParseText(CancellationToken cancellationToken) 258225"];
7623 [label="text 258226"];
7624 [label="options 258227"];
7625 [label="path 258228"];
7626 [label="diagnosticOptions 258229"];
7627 [label="null 258230"];
7628 [label="isGeneratedCode: null 258231"];
7629 [label="cancellationToken 258232"];
7630 [label="ParseText(text, options, path, diagnosticOptions, isGeneratedCode: null, cancellationToken) 258233"];
7631 [label="param ParseText(SourceText text) 258234"];
7632 [label="param ParseText(CSharpParseOptions? options) 258235"];
7633 [label="param ParseText(string path) 258236"];
7634 [label="param ParseText(ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions) 258237"];
7635 [label="param ParseText(bool? isGeneratedCode) 258238"];
7636 [label="param ParseText(CancellationToken cancellationToken) 258239"];
7637 [label="if (text == null)\n            {\n                throw new ArgumentNullException(nameof(text));\n            } 258240"];
7638 [label="if (text == null)\n            {\n                throw new ArgumentNullException(nameof(text));\n            } 258241"];
7639 [label="options = options ?? CSharpParseOptions.Default; 258242"];
7640 [label="using var lexer = new InternalSyntax.Lexer(text, options); 258243"];
7641 [label="using var lexer = new InternalSyntax.Lexer(text, options); 258244"];
7642 [label="using var lexer = new InternalSyntax.Lexer(text, options); 258245"];
7643 [label="new InternalSyntax.Lexer(text, options) 258246"];
7644 [label="param Lexer(SourceText text) 258247"];
7645 [label="param Lexer(CSharpParseOptions options) 258248"];
7646 [label="param Lexer(bool allowPreprocessorDirectives = true) 258249"];
7647 [label="param Lexer(bool interpolationFollowedByColon = false) 258250"];
7648 [label="param Lexer(this) 258251"];
7649 [label="text 258252"];
7650 [label="param Lexer(this) 258253"];
7651 [label="param AbstractLexer(SourceText text) 258254"];
7652 [label="param AbstractLexer(this) 258255"];
7653 [label="TextWindow 258256"];
7654 [label="_errors 258257"];
7655 [label="this.TextWindow = new SlidingTextWindow(text); 258258"];
7656 [label="this.TextWindow = new SlidingTextWindow(text); 258259"];
7657 [label="new SlidingTextWindow(text) 258260"];
7658 [label="param SlidingTextWindow(SourceText text) 258261"];
7659 [label="param SlidingTextWindow(this) 258262"];
7660 [label="_text 258263"];
7661 [label="_basis 258264"];
7662 [label="_offset 258265"];
7663 [label="_textEnd 258266"];
7664 [label="_characterWindow 258267"];
7665 [label="_characterWindowCount 258268"];
7666 [label="_lexemeStart 258269"];
7667 [label="_strings 258270"];
7668 [label="_text 258271"];
7669 [label="_basis = 0; 258272"];
7670 [label="_basis 258273"];
7671 [label="_offset = 0; 258274"];
7672 [label="_offset 258275"];
7673 [label="_textEnd 258276"];
7674 [label="_strings = StringTable.GetInstance(); 258277"];
7675 [label="_strings 258278"];
7676 [label="_characterWindow = s_windowPool.Allocate(); 258279"];
7677 [label="_lexemeStart = 0; 258280"];
7678 [label="_lexemeStart 258281"];
7679 [label="this.TextWindow 258282"];
7680 [label="_options 258283"];
7681 [label="_mode 258284"];
7682 [label="_builder 258285"];
7683 [label="_identBuffer 258286"];
7684 [label="_identLen 258287"];
7685 [label="_cache 258288"];
7686 [label="_allowPreprocessorDirectives 258289"];
7687 [label="_interpolationFollowedByColon 258290"];
7688 [label="_xmlParser 258291"];
7689 [label="_badTokenCount 258292"];
7690 [label="10 258293"];
7691 [label="new SyntaxListBuilder(10) 258294"];
7692 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 258295"];
7693 [label="10 258296"];
7694 [label="new SyntaxListBuilder(10) 258297"];
7695 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 258298"];
7696 [label="_createWhitespaceTriviaFunction 258299"];
7697 [label="_createQuickTokenFunction 258300"];
7698 [label="Debug.Assert(options != null); 258301"];
7699 [label="Debug.Assert(options != null); 258302"];
7700 [label="_options 258303"];
7701 [label="_builder = new StringBuilder(); 258304"];
7702 [label="_builder 258305"];
7703 [label="_identBuffer = new char[32]; 258306"];
7704 [label="_identBuffer 258307"];
7705 [label="_cache = new LexerCache(); 258308"];
7706 [label="new LexerCache() 258309"];
7707 [label="param LexerCache(this) 258310"];
7708 [label="_triviaMap 258311"];
7709 [label="_tokenMap 258312"];
7710 [label="_keywordKindMap 258313"];
7711 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 258314"];
7712 [label="_triviaMap 258315"];
7713 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 258316"];
7714 [label="_tokenMap 258317"];
7715 [label="_cache 258318"];
7716 [label="_createQuickTokenFunction 258319"];
7717 [label="_allowPreprocessorDirectives 258320"];
7718 [label="_interpolationFollowedByColon 258321"];
7719 [label="using var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, cancellationToken: cancellationToken); 258322"];
7720 [label="using var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, cancellationToken: cancellationToken); 258323"];
7721 [label="using var parser = new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, cancellationToken: cancellationToken); 258324"];
7722 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null, cancellationToken: cancellationToken) 258325"];
7723 [label="param LanguageParser(Lexer lexer) 258326"];
7724 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 258327"];
7725 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 258328"];
7726 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 258329"];
7727 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 258330"];
7728 [label="param LanguageParser(this) 258331"];
7729 [label="lexer 258332"];
7730 [label="lexerMode 258333"];
7731 [label="oldTree 258334"];
7732 [label="changes 258335"];
7733 [label="false 258336"];
7734 [label="true 258337"];
7735 [label="cancellationToken 258338"];
7736 [label="param LanguageParser(this) 258339"];
7737 [label="param SyntaxParser(Lexer lexer) 258340"];
7738 [label="param SyntaxParser(LexerMode mode) 258341"];
7739 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 258342"];
7740 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 258343"];
7741 [label="param SyntaxParser(bool allowModeReset) 258344"];
7742 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 258345"];
7743 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 258346"];
7744 [label="param SyntaxParser(this) 258347"];
7745 [label="lexer 258348"];
7746 [label="_isIncremental 258349"];
7747 [label="_allowModeReset 258350"];
7748 [label="_mode 258351"];
7749 [label="_currentToken 258352"];
7750 [label="_lexedTokens 258353"];
7751 [label="_prevTokenTrailingTrivia 258354"];
7752 [label="_firstToken 258355"];
7753 [label="_tokenOffset 258356"];
7754 [label="_tokenCount 258357"];
7755 [label="_resetCount 258358"];
7756 [label="_resetStart 258359"];
7757 [label="_blendedTokens 258360"];
7758 [label="this.lexer 258361"];
7759 [label="_mode 258362"];
7760 [label="_allowModeReset 258363"];
7761 [label="this.cancellationToken 258364"];
7762 [label="_currentNode = default(BlendedNode); 258365"];
7763 [label="_currentNode 258366"];
7764 [label="_isIncremental = oldTree != null; 258367"];
7765 [label="_isIncremental = oldTree != null; 258368"];
7766 [label="_isIncremental 258369"];
7767 [label="this.IsIncremental 258370"];
7768 [label="get\n            {\n                return _isIncremental;\n            } 258371"];
7769 [label="return _isIncremental; 258372"];
7770 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 258373"];
7771 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 258374"];
7772 [label="_firstBlender = default(Blender); 258375"];
7773 [label="_firstBlender 258376"];
7774 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 258377"];
7775 [label="_lexedTokens 258378"];
7776 [label="this.IsIncremental 258379"];
7777 [label="get\n            {\n                return _isIncremental;\n            } 258380"];
7778 [label="return _isIncremental; 258381"];
7779 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 258382"];
7780 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 258383"];
7781 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 258384"];
7782 [label="this.PreLex() 258385"];
7783 [label="param PreLex(this) 258386"];
7784 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 258387"];
7785 [label="this.lexer.TextWindow.Text 258388"];
7786 [label="=> _text 258389"];
7787 [label="_text 258390"];
7788 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 258391"];
7789 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 258392"];
7790 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 258393"];
7791 [label="_lexedTokens 258394"];
7792 [label="var lexer = this.lexer; 258395"];
7793 [label="var mode = _mode; 258396"];
7794 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 258397"];
7795 [label="var token = lexer.Lex(mode); 258398"];
7796 [label="TokensLexed++; 258399"];
7797 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 258400"];
7798 [label="TextWindow.Start(); 258401"];
7799 [label="TextWindow.Position 258402"];
7800 [label="get\n            {\n                return _basis + _offset;\n            } 258403"];
7801 [label="param LexSyntaxTrivia(bool afterFirstToken) 258404"];
7802 [label="param LexSyntaxTrivia(bool isTrailing) 258405"];
7803 [label="bool onlyWhitespaceOnLine = !isTrailing; 258406"];
7804 [label="this.Start(); 258407"];
7805 [label="TextWindow.PeekChar() 258408"];
7806 [label="param PeekChar(this) 258409"];
7807 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 258410"];
7808 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 258411"];
7809 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 258412"];
7810 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 258413"];
7811 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 258414"];
7812 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 258415"];
7813 [label="_characterWindowCount += amountToRead; 258416"];
7814 [label="_characterWindowCount 258417"];
7815 [label="return amountToRead > 0; 258418"];
7816 [label="return amountToRead > 0; 258419"];
7817 [label="return _characterWindow[_offset]; 258420"];
7818 [label="char ch = TextWindow.PeekChar(); 258421"];
7819 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258422"];
7820 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258423"];
7821 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258424"];
7822 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 258425"];
7823 [label="this.ScanEndOfLine() 258426"];
7824 [label="param ScanEndOfLine(this) 258427"];
7825 [label="char ch; 258428"];
7826 [label="TextWindow.PeekChar() 258429"];
7827 [label="param PeekChar(this) 258430"];
7828 [label="switch (ch = TextWindow.PeekChar())\n            {\n                case '\\r':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '\\n')\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.CarriageReturnLineFeed;\n                    }\n\n                    return SyntaxFactory.CarriageReturn;\n                case '\\n':\n                    TextWindow.AdvanceChar();\n                    return SyntaxFactory.LineFeed;\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.EndOfLine(ch.ToString());\n                    }\n\n                    return null;\n            } 258431"];
7829 [label="TextWindow.AdvanceChar() 258432"];
7830 [label="param AdvanceChar(this) 258433"];
7831 [label="_offset 258434"];
7832 [label="TextWindow.AdvanceChar(); 258435"];
7833 [label="TextWindow.PeekChar() 258436"];
7834 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 258437"];
7835 [label="return _characterWindow[_offset]; 258438"];
7836 [label="if (TextWindow.PeekChar() == '\\n')\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.CarriageReturnLineFeed;\n                    } 258439"];
7837 [label="if (TextWindow.PeekChar() == '\\n')\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.CarriageReturnLineFeed;\n                    } 258440"];
7838 [label="TextWindow.AdvanceChar() 258441"];
7839 [label="TextWindow.AdvanceChar(); 258442"];
7840 [label="return SyntaxFactory.CarriageReturnLineFeed; 258443"];
7841 [label="this.AddTrivia(this.ScanEndOfLine(), ref triviaList); 258444"];
7842 [label="this.AddTrivia(this.ScanEndOfLine(), ref triviaList); 258445"];
7843 [label="this.AddTrivia(this.ScanEndOfLine(), ref triviaList) 258446"];
7844 [label="param AddTrivia(CSharpSyntaxNode trivia) 258447"];
7845 [label="param AddTrivia(ref SyntaxListBuilder list) 258448"];
7846 [label="param AddTrivia(this) 258449"];
7847 [label="this.HasErrors 258450"];
7848 [label="get { return _errors != null; } 258451"];
7849 [label="return _errors != null; 258452"];
7850 [label="return _errors != null; 258453"];
7851 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258454"];
7852 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258455"];
7853 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258456"];
7854 [label="list.Add(trivia); 258457"];
7855 [label="list.Add(trivia); 258458"];
7856 [label="this.AddTrivia(this.ScanEndOfLine(), ref triviaList); 258459"];
7857 [label="if (isTrailing)\n                        {\n                            return;\n                        } 258460"];
7858 [label="onlyWhitespaceOnLine = true; 258461"];
7859 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258462"];
7860 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258463"];
7861 [label="return; 258464"];
7862 [label="this.Start(); 258465"];
7863 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 258466"];
7864 [label="param ScanIdentifierOrKeyword(this) 258467"];
7865 [label="info.ContextualKind 258468"];
7866 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 258469"];
7867 [label="this.ScanIdentifier(ref info) 258470"];
7868 [label="param ScanIdentifier(ref TokenInfo info) 258471"];
7869 [label="param ScanIdentifier(this) 258472"];
7870 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 258473"];
7871 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 258474"];
7872 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 258475"];
7873 [label="param Intern(char[] array) 258476"];
7874 [label="param Intern(int start) 258477"];
7875 [label="param Intern(int length) 258478"];
7876 [label="param Intern(this) 258479"];
7877 [label="return _strings.Add(array, start, length); 258480"];
7878 [label="return _strings.Add(array, start, length); 258481"];
7879 [label="return _strings.Add(array, start, length); 258482"];
7880 [label="return _strings.Add(array, start, length); 258483"];
7881 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 258484"];
7882 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 258485"];
7883 [label="this.ModeIs(LexerMode.Directive) 258486"];
7884 [label="param ModeIs(LexerMode mode) 258487"];
7885 [label="param ModeIs(this) 258488"];
7886 [label="return ModeOf(_mode) == mode; 258489"];
7887 [label="ModeOf(_mode) 258490"];
7888 [label="param ModeOf(LexerMode mode) 258491"];
7889 [label="return mode & LexerMode.MaskLexMode; 258492"];
7890 [label="return ModeOf(_mode) == mode; 258493"];
7891 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 258494"];
7892 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 258495"];
7893 [label="param TryGetKeywordKind(string key) 258496"];
7894 [label="param TryGetKeywordKind(out SyntaxKind kind) 258497"];
7895 [label="param TryGetKeywordKind(this) 258498"];
7896 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 258499"];
7897 [label="kind = _keywordKindMap.GetOrMakeValue(key); 258500"];
7898 [label="kind = _keywordKindMap.GetOrMakeValue(key); 258501"];
7899 [label="kind = _keywordKindMap.GetOrMakeValue(key); 258502"];
7900 [label="param GetKeywordKind(string text) 258503"];
7901 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 258504"];
7902 [label="return SyntaxKind.NamespaceKeyword; 258505"];
7903 [label="return kind != SyntaxKind.None; 258506"];
7904 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 258507"];
7905 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 258508"];
7906 [label="param IsContextualKeyword(SyntaxKind kind) 258509"];
7907 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 258510"];
7908 [label="return false; 258511"];
7909 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 258512"];
7910 [label="return true; 258513"];
7911 [label="this.ScanSyntaxToken(ref tokenInfo); 258514"];
7912 [label="var errors = this.GetErrors(GetFullWidth(leading)); 258515"];
7913 [label="GetFullWidth(leading) 258516"];
7914 [label="param GetFullWidth(SyntaxListBuilder builder) 258517"];
7915 [label="int width = 0; 258518"];
7916 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 258519"];
7917 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 258520"];
7918 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 258521"];
7919 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 258522"];
7920 [label="width += builder[i].FullWidth; 258523"];
7921 [label="width += builder[i].FullWidth; 258524"];
7922 [label="return width; 258525"];
7923 [label="this.GetErrors(GetFullWidth(leading)) 258526"];
7924 [label="param GetErrors(int leadingTriviaWidth) 258527"];
7925 [label="param GetErrors(this) 258528"];
7926 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258529"];
7927 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258530"];
7928 [label="return null; 258531"];
7929 [label="param LexSyntaxTrivia(bool afterFirstToken) 258532"];
7930 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258533"];
7931 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 258534"];
7932 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 258535"];
7933 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 258536"];
7934 [label="return _offset - _lexemeStart; 258537"];
7935 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 258538"];
7936 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 258539"];
7937 [label="param AddTrivia(CSharpSyntaxNode trivia) 258540"];
7938 [label="param AddTrivia(ref SyntaxListBuilder list) 258541"];
7939 [label="param AddTrivia(this) 258542"];
7940 [label="this.HasErrors 258543"];
7941 [label="get { return _errors != null; } 258544"];
7942 [label="return _errors != null; 258545"];
7943 [label="return _errors != null; 258546"];
7944 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258547"];
7945 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258548"];
7946 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258549"];
7947 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258550"];
7948 [label="return; 258551"];
7949 [label="param Create(ref TokenInfo info) 258552"];
7950 [label="param Create(SyntaxDiagnosticInfo[] errors) 258553"];
7951 [label="param Create(this) 258554"];
7952 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258555"];
7953 [label="SyntaxToken token; 258556"];
7954 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 258557"];
7955 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 258558"];
7956 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 258559"];
7957 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 258560"];
7958 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 258561"];
7959 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 258562"];
7960 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 258563"];
7961 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 258564"];
7962 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 258565"];
7963 [label="param Token(GreenNode leading) 258566"];
7964 [label="param Token(SyntaxKind kind) 258567"];
7965 [label="param Token(GreenNode trailing) 258568"];
7966 [label="return SyntaxToken.Create(kind, leading, trailing); 258569"];
7967 [label="return SyntaxToken.Create(kind, leading, trailing); 258570"];
7968 [label="return SyntaxToken.Create(kind, leading, trailing); 258571"];
7969 [label="SyntaxToken.Create(kind, leading, trailing) 258572"];
7970 [label="param Create(SyntaxKind kind) 258573"];
7971 [label="param Create(GreenNode leading) 258574"];
7972 [label="param Create(GreenNode trailing) 258575"];
7973 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 258576"];
7974 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 258577"];
7975 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 258578"];
7976 [label="if (leading == SyntaxFactory.ElasticZeroSpace && trailing == SyntaxFactory.ElasticZeroSpace)\n            {\n                return s_tokensWithElasticTrivia[(int)kind].Value;\n            } 258579"];
7977 [label="return new SyntaxTokenWithTrivia(kind, leading, trailing); 258580"];
7978 [label="return new SyntaxTokenWithTrivia(kind, leading, trailing); 258581"];
7979 [label="return new SyntaxTokenWithTrivia(kind, leading, trailing); 258582"];
7980 [label="return new SyntaxTokenWithTrivia(kind, leading, trailing); 258583"];
7981 [label="new SyntaxTokenWithTrivia(kind, leading, trailing) 258584"];
7982 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 258585"];
7983 [label="param SyntaxTokenWithTrivia(GreenNode leading) 258586"];
7984 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 258587"];
7985 [label="param SyntaxTokenWithTrivia(this) 258588"];
7986 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 258589"];
7987 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 258590"];
7988 [label="this.AdjustFlagsAndWidth(leading); 258591"];
7989 [label="this.AdjustFlagsAndWidth(leading); 258592"];
7990 [label="this.LeadingField 258593"];
7991 [label="this.AdjustFlagsAndWidth(trailing); 258594"];
7992 [label="return SyntaxToken.Create(kind, leading, trailing); 258595"];
7993 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 258596"];
7994 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258597"];
7995 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258598"];
7996 [label="return token; 258599"];
7997 [label="this.AddLexedToken(token); 258600"];
7998 [label="this.AddLexedToken(token) 258601"];
7999 [label="param AddLexedToken(SyntaxToken token) 258602"];
8000 [label="param AddLexedToken(this) 258603"];
8001 [label="Debug.Assert(token != null); 258604"];
8002 [label="Debug.Assert(token != null); 258605"];
8003 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 258606"];
8004 [label="_lexedTokens[_tokenCount].Value = token; 258607"];
8005 [label="_lexedTokens[_tokenCount].Value 258608"];
8006 [label="_tokenCount 258609"];
8007 [label="this.AddLexedToken(token); 258610"];
8008 [label="token.Kind 258611"];
8009 [label="get { return (SyntaxKind)this.RawKind; } 258612"];
8010 [label="return (SyntaxKind)this.RawKind; 258613"];
8011 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 258614"];
8012 [label="TextWindow.Start(); 258615"];
8013 [label="get\n            {\n                return _lexemeStart;\n            } 258616"];
8014 [label="return _lexemeStart; 258617"];
8015 [label="param LookupToken(char[] textBuffer) 258618"];
8016 [label="param LookupToken(int keyStart) 258619"];
8017 [label="param LookupToken(int keyLength) 258620"];
8018 [label="param LookupToken(int hashCode) 258621"];
8019 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 258622"];
8020 [label="param LookupToken(this) 258623"];
8021 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258624"];
8022 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258625"];
8023 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258626"];
8024 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258627"];
8025 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258628"];
8026 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 258629"];
8027 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 258630"];
8028 [label="value = createTokenFunction(); 258631"];
8029 [label="value = createTokenFunction(); 258632"];
8030 [label="param CreateQuickToken(this) 258633"];
8031 [label="TextWindow.Width 258634"];
8032 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 258635"];
8033 [label="var quickWidth = TextWindow.Width; 258636"];
8034 [label="TextWindow.LexemeStartPosition 258637"];
8035 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 258638"];
8036 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 258639"];
8037 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 258640"];
8038 [label="param Reset(int position) 258641"];
8039 [label="param Reset(this) 258642"];
8040 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 258643"];
8041 [label="this.LexSyntaxToken() 258644"];
8042 [label="param LexSyntaxToken(this) 258645"];
8043 [label="_leadingTriviaCache.Clear(); 258646"];
8044 [label="TextWindow.Position 258647"];
8045 [label="get\n            {\n                return _basis + _offset;\n            } 258648"];
8046 [label="param LexSyntaxTrivia(bool afterFirstToken) 258649"];
8047 [label="param LexSyntaxTrivia(bool isTrailing) 258650"];
8048 [label="bool onlyWhitespaceOnLine = !isTrailing; 258651"];
8049 [label="TextWindow.Start(); 258652"];
8050 [label="this.Start(); 258653"];
8051 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258654"];
8052 [label="return; 258655"];
8053 [label="this.Start(); 258656"];
8054 [label="param TryGetKeywordKind(out SyntaxKind kind) 258657"];
8055 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 258658"];
8056 [label="return SyntaxKind.None; 258659"];
8057 [label="param GetContextualKeywordKind(string text) 258660"];
8058 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 258661"];
8059 [label="return SyntaxKind.None; 258662"];
8060 [label="kind = _keywordKindMap.GetOrMakeValue(key); 258663"];
8061 [label="return kind != SyntaxKind.None; 258664"];
8062 [label="info.Kind 258665"];
8063 [label="info.ContextualKind 258666"];
8064 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 258667"];
8065 [label="this.ScanSyntaxToken(ref tokenInfo); 258668"];
8066 [label="int width = 0; 258669"];
8067 [label="return width; 258670"];
8068 [label="this.GetErrors(GetFullWidth(leading)) 258671"];
8069 [label="param GetErrors(int leadingTriviaWidth) 258672"];
8070 [label="param GetErrors(this) 258673"];
8071 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258674"];
8072 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258675"];
8073 [label="return null; 258676"];
8074 [label="param LexSyntaxTrivia(bool afterFirstToken) 258677"];
8075 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258678"];
8076 [label="char ch; 258679"];
8077 [label="TextWindow.AdvanceChar(); 258680"];
8078 [label="TextWindow.AdvanceChar(); 258681"];
8079 [label="param AddTrivia(this) 258682"];
8080 [label="this.HasErrors 258683"];
8081 [label="get { return _errors != null; } 258684"];
8082 [label="return _errors != null; 258685"];
8083 [label="return _errors != null; 258686"];
8084 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258687"];
8085 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258688"];
8086 [label="if (isTrailing)\n                        {\n                            return;\n                        } 258689"];
8087 [label="return; 258690"];
8088 [label="param Create(SyntaxDiagnosticInfo[] errors) 258691"];
8089 [label="param Create(this) 258692"];
8090 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258693"];
8091 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258694"];
8092 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258695"];
8093 [label="SyntaxToken token; 258696"];
8094 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 258697"];
8095 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 258698"];
8096 [label="param Identifier(SyntaxKind contextualKind) 258699"];
8097 [label="param Identifier(GreenNode leading) 258700"];
8098 [label="param Identifier(string text) 258701"];
8099 [label="param Identifier(string valueText) 258702"];
8100 [label="param Identifier(GreenNode trailing) 258703"];
8101 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 258704"];
8102 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 258705"];
8103 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 258706"];
8104 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 258707"];
8105 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 258708"];
8106 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 258709"];
8107 [label="param Identifier(SyntaxKind contextualKind) 258710"];
8108 [label="param Identifier(GreenNode leading) 258711"];
8109 [label="param Identifier(string text) 258712"];
8110 [label="param Identifier(string valueText) 258713"];
8111 [label="param Identifier(GreenNode trailing) 258714"];
8112 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 258715"];
8113 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 258716"];
8114 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 258717"];
8115 [label="return Identifier(leading, text, trailing); 258718"];
8116 [label="return Identifier(leading, text, trailing); 258719"];
8117 [label="return Identifier(leading, text, trailing); 258720"];
8118 [label="Identifier(leading, text, trailing) 258721"];
8119 [label="param Identifier(GreenNode leading) 258722"];
8120 [label="param Identifier(string text) 258723"];
8121 [label="param Identifier(GreenNode trailing) 258724"];
8122 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 258725"];
8123 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 258726"];
8124 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 258727"];
8125 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 258728"];
8126 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrailingTrivia), r => new SyntaxIdentifierWithTrailingTrivia(r)); 258729"];
8127 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 258730"];
8128 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 258731"];
8129 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 258732"];
8130 [label="new SyntaxIdentifierWithTrailingTrivia(text, trailing) 258733"];
8131 [label="param SyntaxIdentifierWithTrailingTrivia(string text) 258734"];
8132 [label="param SyntaxIdentifierWithTrailingTrivia(GreenNode trailing) 258735"];
8133 [label="param SyntaxIdentifierWithTrailingTrivia(this) 258736"];
8134 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 258737"];
8135 [label="text 258738"];
8136 [label="param SyntaxIdentifierWithTrailingTrivia(this) 258739"];
8137 [label="param SyntaxIdentifier(string text) 258740"];
8138 [label="param SyntaxIdentifier(this) 258741"];
8139 [label="SyntaxKind.IdentifierToken 258742"];
8140 [label="text 258743"];
8141 [label="param SyntaxIdentifier(this) 258744"];
8142 [label="param SyntaxToken(SyntaxKind kind) 258745"];
8143 [label="param SyntaxToken(int fullWidth) 258746"];
8144 [label="param SyntaxToken(this) 258747"];
8145 [label="kind 258748"];
8146 [label="fullWidth 258749"];
8147 [label="param SyntaxToken(this) 258750"];
8148 [label="param CSharpSyntaxNode(SyntaxKind kind) 258751"];
8149 [label="param CSharpSyntaxNode(int fullWidth) 258752"];
8150 [label="param CSharpSyntaxNode(this) 258753"];
8151 [label="kind 258754"];
8152 [label="fullWidth 258755"];
8153 [label="param CSharpSyntaxNode(this) 258756"];
8154 [label="param CSharpSyntaxNode(this) 258757"];
8155 [label="GreenStats.NoteGreen(this); 258758"];
8156 [label="GreenStats.NoteGreen(this); 258759"];
8157 [label="this.flags |= NodeFlags.IsNotMissing; 258760"];
8158 [label="this.flags 258761"];
8159 [label="TextField 258762"];
8160 [label="this.TextField 258763"];
8161 [label="_trailing 258764"];
8162 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 258765"];
8163 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 258766"];
8164 [label="this.AdjustFlagsAndWidth(trailing); 258767"];
8165 [label="this.AdjustFlagsAndWidth(trailing); 258768"];
8166 [label="_trailing 258769"];
8167 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258770"];
8168 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258771"];
8169 [label="return token; 258772"];
8170 [label="var token = this.LexSyntaxToken(); 258773"];
8171 [label="Debug.Assert(quickWidth == token.FullWidth); 258774"];
8172 [label="return token; 258775"];
8173 [label="value = createTokenFunction(); 258776"];
8174 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258777"];
8175 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258778"];
8176 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258779"];
8177 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258780"];
8178 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258781"];
8179 [label="return value; 258782"];
8180 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 258783"];
8181 [label="this.AddLexedToken(token); 258784"];
8182 [label="param AddLexedToken(SyntaxToken token) 258785"];
8183 [label="Debug.Assert(token != null); 258786"];
8184 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 258787"];
8185 [label="_lexedTokens[_tokenCount].Value = token; 258788"];
8186 [label="_lexedTokens[_tokenCount].Value 258789"];
8187 [label="get { return (SyntaxKind)this.RawKind; } 258790"];
8188 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 258791"];
8189 [label="TextWindow.Start(); 258792"];
8190 [label="TextWindow.Width 258793"];
8191 [label="var quickWidth = TextWindow.Width; 258794"];
8192 [label="TextWindow.Position 258795"];
8193 [label="param LexSyntaxTrivia(bool afterFirstToken) 258796"];
8194 [label="param LexSyntaxTrivia(bool isTrailing) 258797"];
8195 [label="bool onlyWhitespaceOnLine = !isTrailing; 258798"];
8196 [label="this.Start(); 258799"];
8197 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258800"];
8198 [label="return; 258801"];
8199 [label="this.Start(); 258802"];
8200 [label="int width = 0; 258803"];
8201 [label="return width; 258804"];
8202 [label="this.GetErrors(GetFullWidth(leading)) 258805"];
8203 [label="param GetErrors(int leadingTriviaWidth) 258806"];
8204 [label="param GetErrors(this) 258807"];
8205 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258808"];
8206 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258809"];
8207 [label="return null; 258810"];
8208 [label="param LexSyntaxTrivia(bool afterFirstToken) 258811"];
8209 [label="param LexSyntaxTrivia(bool isTrailing) 258812"];
8210 [label="bool onlyWhitespaceOnLine = !isTrailing; 258813"];
8211 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258814"];
8212 [label="char ch; 258815"];
8213 [label="TextWindow.AdvanceChar(); 258816"];
8214 [label="TextWindow.AdvanceChar(); 258817"];
8215 [label="param AddTrivia(this) 258818"];
8216 [label="this.HasErrors 258819"];
8217 [label="get { return _errors != null; } 258820"];
8218 [label="return _errors != null; 258821"];
8219 [label="return _errors != null; 258822"];
8220 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258823"];
8221 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258824"];
8222 [label="if (isTrailing)\n                        {\n                            return;\n                        } 258825"];
8223 [label="return; 258826"];
8224 [label="param Create(SyntaxDiagnosticInfo[] errors) 258827"];
8225 [label="param Create(this) 258828"];
8226 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258829"];
8227 [label="SyntaxToken token; 258830"];
8228 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 258831"];
8229 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 258832"];
8230 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 258833"];
8231 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 258834"];
8232 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 258835"];
8233 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 258836"];
8234 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 258837"];
8235 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 258838"];
8236 [label="if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 258839"];
8237 [label="return s_tokensWithSingleTrailingCRLF[(int)kind].Value; 258840"];
8238 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258841"];
8239 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258842"];
8240 [label="Debug.Assert(quickWidth == token.FullWidth); 258843"];
8241 [label="this.AddLexedToken(token); 258844"];
8242 [label="param AddLexedToken(SyntaxToken token) 258845"];
8243 [label="Debug.Assert(token != null); 258846"];
8244 [label="_lexedTokens[_tokenCount].Value 258847"];
8245 [label="get { return (SyntaxKind)this.RawKind; } 258848"];
8246 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 258849"];
8247 [label="TextWindow.Start(); 258850"];
8248 [label="TextWindow.Width 258851"];
8249 [label="var quickWidth = TextWindow.Width; 258852"];
8250 [label="param LexSyntaxTrivia(bool afterFirstToken) 258853"];
8251 [label="param LexSyntaxTrivia(bool isTrailing) 258854"];
8252 [label="bool onlyWhitespaceOnLine = !isTrailing; 258855"];
8253 [label="this.Start(); 258856"];
8254 [label="param LookupTrivia(char[] textBuffer) 258857"];
8255 [label="param LookupTrivia(int keyStart) 258858"];
8256 [label="param LookupTrivia(int keyLength) 258859"];
8257 [label="param LookupTrivia(int hashCode) 258860"];
8258 [label="param LookupTrivia(Func<SyntaxTrivia> createTriviaFunction) 258861"];
8259 [label="param LookupTrivia(this) 258862"];
8260 [label="var value = _triviaMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258863"];
8261 [label="var value = _triviaMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258864"];
8262 [label="var value = _triviaMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258865"];
8263 [label="var value = _triviaMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258866"];
8264 [label="var value = _triviaMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 258867"];
8265 [label="if (value == null)\n            {\n                value = createTriviaFunction();\n                _triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            } 258868"];
8266 [label="if (value == null)\n            {\n                value = createTriviaFunction();\n                _triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            } 258869"];
8267 [label="value = createTriviaFunction(); 258870"];
8268 [label="value = createTriviaFunction(); 258871"];
8269 [label="param CreateWhitespaceTrivia(this) 258872"];
8270 [label="return SyntaxFactory.Whitespace(TextWindow.GetText(intern: true)); 258873"];
8271 [label="TextWindow.GetText(intern: true) 258874"];
8272 [label="param GetText(bool intern) 258875"];
8273 [label="param GetText(this) 258876"];
8274 [label="this.LexemeStartPosition 258877"];
8275 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 258878"];
8276 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 258879"];
8277 [label="this.Width 258880"];
8278 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 258881"];
8279 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 258882"];
8280 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 258883"];
8281 [label="this.GetText(this.LexemeStartPosition, this.Width, intern) 258884"];
8282 [label="param GetText(int position) 258885"];
8283 [label="param GetText(int length) 258886"];
8284 [label="param GetText(bool intern) 258887"];
8285 [label="param GetText(this) 258888"];
8286 [label="int offset = position - _basis; 258889"];
8287 [label="switch (length)\n            {\n                case 0:\n                    return string.Empty;\n\n                case 1:\n                    if (_characterWindow[offset] == ' ')\n                    {\n                        return ' ';\n                    }\n                    if (_characterWindow[offset] == '\\n')\n                    {\n                        return '\\n';\n                    }\n                    break;\n\n                case 2:\n                    char firstChar = _characterWindow[offset];\n                    if (firstChar == '\\r' && _characterWindow[offset + 1] == '\\n')\n                    {\n                        return '\\r\\n';\n                    }\n                    if (firstChar == '/' && _characterWindow[offset + 1] == '/')\n                    {\n                        return '//';\n                    }\n                    break;\n\n                case 3:\n                    if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')\n                    {\n                        return '// ';\n                    }\n                    break;\n            } 258890"];
8288 [label="char firstChar = _characterWindow[offset]; 258891"];
8289 [label="if (firstChar == '\\r' && _characterWindow[offset + 1] == '\\n')\n                    {\n                        return '\\r\\n';\n                    } 258892"];
8290 [label="if (firstChar == '\\r' && _characterWindow[offset + 1] == '\\n')\n                    {\n                        return '\\r\\n';\n                    } 258893"];
8291 [label="if (firstChar == '/' && _characterWindow[offset + 1] == '/')\n                    {\n                        return '//';\n                    } 258894"];
8292 [label="if (firstChar == '/' && _characterWindow[offset + 1] == '/')\n                    {\n                        return '//';\n                    } 258895"];
8293 [label="if (intern)\n            {\n                return this.Intern(_characterWindow, offset, length);\n            }\n            else\n            {\n                return new string(_characterWindow, offset, length);\n            } 258896"];
8294 [label="return this.Intern(_characterWindow, offset, length); 258897"];
8295 [label="return this.Intern(_characterWindow, offset, length); 258898"];
8296 [label="return this.Intern(_characterWindow, offset, length); 258899"];
8297 [label="this.Intern(_characterWindow, offset, length) 258900"];
8298 [label="param Intern(char[] array) 258901"];
8299 [label="param Intern(int start) 258902"];
8300 [label="param Intern(int length) 258903"];
8301 [label="param Intern(this) 258904"];
8302 [label="return _strings.Add(array, start, length); 258905"];
8303 [label="SyntaxFactory.Whitespace(TextWindow.GetText(intern: true)) 258906"];
8304 [label="param Whitespace(string text) 258907"];
8305 [label="param Whitespace(bool elastic = false) 258908"];
8306 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 258909"];
8307 [label="_triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258910"];
8308 [label="_triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258911"];
8309 [label="_triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258912"];
8310 [label="_triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258913"];
8311 [label="_triviaMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 258914"];
8312 [label="return value; 258915"];
8313 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 258916"];
8314 [label="param AddTrivia(this) 258917"];
8315 [label="this.HasErrors 258918"];
8316 [label="get { return _errors != null; } 258919"];
8317 [label="return _errors != null; 258920"];
8318 [label="return _errors != null; 258921"];
8319 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258922"];
8320 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258923"];
8321 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258924"];
8322 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258925"];
8323 [label="return; 258926"];
8324 [label="this.Start(); 258927"];
8325 [label="param TryGetKeywordKind(out SyntaxKind kind) 258928"];
8326 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 258929"];
8327 [label="return SyntaxKind.ClassKeyword; 258930"];
8328 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 258931"];
8329 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 258932"];
8330 [label="param IsContextualKeyword(SyntaxKind kind) 258933"];
8331 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 258934"];
8332 [label="return false; 258935"];
8333 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 258936"];
8334 [label="int width = 0; 258937"];
8335 [label="width += builder[i].FullWidth; 258938"];
8336 [label="return width; 258939"];
8337 [label="this.GetErrors(GetFullWidth(leading)) 258940"];
8338 [label="param GetErrors(int leadingTriviaWidth) 258941"];
8339 [label="param GetErrors(this) 258942"];
8340 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258943"];
8341 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258944"];
8342 [label="return null; 258945"];
8343 [label="param AddTrivia(this) 258946"];
8344 [label="this.HasErrors 258947"];
8345 [label="get { return _errors != null; } 258948"];
8346 [label="return _errors != null; 258949"];
8347 [label="return _errors != null; 258950"];
8348 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258951"];
8349 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 258952"];
8350 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 258953"];
8351 [label="return; 258954"];
8352 [label="param Create(SyntaxDiagnosticInfo[] errors) 258955"];
8353 [label="param Create(this) 258956"];
8354 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258957"];
8355 [label="SyntaxToken token; 258958"];
8356 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 258959"];
8357 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 258960"];
8358 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 258961"];
8359 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 258962"];
8360 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 258963"];
8361 [label="if (leading == SyntaxFactory.ElasticZeroSpace && trailing == SyntaxFactory.ElasticZeroSpace)\n            {\n                return s_tokensWithElasticTrivia[(int)kind].Value;\n            } 258964"];
8362 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258965"];
8363 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 258966"];
8364 [label="Debug.Assert(quickWidth == token.FullWidth); 258967"];
8365 [label="this.AddLexedToken(token); 258968"];
8366 [label="param AddLexedToken(SyntaxToken token) 258969"];
8367 [label="Debug.Assert(token != null); 258970"];
8368 [label="_lexedTokens[_tokenCount].Value 258971"];
8369 [label="get { return (SyntaxKind)this.RawKind; } 258972"];
8370 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 258973"];
8371 [label="TextWindow.Start(); 258974"];
8372 [label="var quickWidth = TextWindow.Width; 258975"];
8373 [label="param LexSyntaxTrivia(bool afterFirstToken) 258976"];
8374 [label="param LexSyntaxTrivia(bool isTrailing) 258977"];
8375 [label="bool onlyWhitespaceOnLine = !isTrailing; 258978"];
8376 [label="this.Start(); 258979"];
8377 [label="this.Start(); 258980"];
8378 [label="param TryGetKeywordKind(out SyntaxKind kind) 258981"];
8379 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 258982"];
8380 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 258983"];
8381 [label="int width = 0; 258984"];
8382 [label="return width; 258985"];
8383 [label="this.GetErrors(GetFullWidth(leading)) 258986"];
8384 [label="param GetErrors(int leadingTriviaWidth) 258987"];
8385 [label="param GetErrors(this) 258988"];
8386 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258989"];
8387 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 258990"];
8388 [label="return null; 258991"];
8389 [label="param AddTrivia(this) 258992"];
8390 [label="get { return _errors != null; } 258993"];
8391 [label="return _errors != null; 258994"];
8392 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 258995"];
8393 [label="param Create(SyntaxDiagnosticInfo[] errors) 258996"];
8394 [label="param Create(this) 258997"];
8395 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258998"];
8396 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 258999"];
8397 [label="SyntaxToken token; 259000"];
8398 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259001"];
8399 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259002"];
8400 [label="Debug.Assert(quickWidth == token.FullWidth); 259003"];
8401 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 259004"];
8402 [label="Debug.Assert(quickWidth == token.FullWidth); 259005"];
8403 [label="this.AddLexedToken(token); 259006"];
8404 [label="param AddLexedToken(SyntaxToken token) 259007"];
8405 [label="Debug.Assert(token != null); 259008"];
8406 [label="_lexedTokens[_tokenCount].Value 259009"];
8407 [label="get { return (SyntaxKind)this.RawKind; } 259010"];
8408 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 259011"];
8409 [label="TextWindow.Start(); 259012"];
8410 [label="var quickWidth = TextWindow.Width; 259013"];
8411 [label="param LexSyntaxTrivia(bool afterFirstToken) 259014"];
8412 [label="param LexSyntaxTrivia(bool isTrailing) 259015"];
8413 [label="bool onlyWhitespaceOnLine = !isTrailing; 259016"];
8414 [label="this.Start(); 259017"];
8415 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 259018"];
8416 [label="return; 259019"];
8417 [label="this.Start(); 259020"];
8418 [label="int width = 0; 259021"];
8419 [label="return width; 259022"];
8420 [label="this.GetErrors(GetFullWidth(leading)) 259023"];
8421 [label="param GetErrors(int leadingTriviaWidth) 259024"];
8422 [label="param GetErrors(this) 259025"];
8423 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259026"];
8424 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259027"];
8425 [label="return null; 259028"];
8426 [label="char ch; 259029"];
8427 [label="TextWindow.AdvanceChar(); 259030"];
8428 [label="TextWindow.AdvanceChar(); 259031"];
8429 [label="param AddTrivia(this) 259032"];
8430 [label="this.HasErrors 259033"];
8431 [label="get { return _errors != null; } 259034"];
8432 [label="return _errors != null; 259035"];
8433 [label="return _errors != null; 259036"];
8434 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 259037"];
8435 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 259038"];
8436 [label="if (isTrailing)\n                        {\n                            return;\n                        } 259039"];
8437 [label="return; 259040"];
8438 [label="param Create(SyntaxDiagnosticInfo[] errors) 259041"];
8439 [label="param Create(this) 259042"];
8440 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 259043"];
8441 [label="SyntaxToken token; 259044"];
8442 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 259045"];
8443 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 259046"];
8444 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 259047"];
8445 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 259048"];
8446 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 259049"];
8447 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259050"];
8448 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259051"];
8449 [label="Debug.Assert(quickWidth == token.FullWidth); 259052"];
8450 [label="param TryGetKeywordKind(out SyntaxKind kind) 259053"];
8451 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 259054"];
8452 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 259055"];
8453 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 259056"];
8454 [label="return Identifier(text); 259057"];
8455 [label="Identifier(text) 259058"];
8456 [label="param Identifier(string text) 259059"];
8457 [label="return new SyntaxIdentifier(text); 259060"];
8458 [label="return new SyntaxIdentifier(text); 259061"];
8459 [label="new SyntaxIdentifier(text) 259062"];
8460 [label="param SyntaxIdentifier(string text) 259063"];
8461 [label="param SyntaxIdentifier(this) 259064"];
8462 [label="return Identifier(text); 259065"];
8463 [label="Debug.Assert(quickWidth == token.FullWidth); 259066"];
8464 [label="this.AddLexedToken(token); 259067"];
8465 [label="param AddLexedToken(SyntaxToken token) 259068"];
8466 [label="Debug.Assert(token != null); 259069"];
8467 [label="_lexedTokens[_tokenCount].Value 259070"];
8468 [label="get { return (SyntaxKind)this.RawKind; } 259071"];
8469 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 259072"];
8470 [label="TextWindow.Start(); 259073"];
8471 [label="var quickWidth = TextWindow.Width; 259074"];
8472 [label="param LexSyntaxTrivia(bool afterFirstToken) 259075"];
8473 [label="param LexSyntaxTrivia(bool isTrailing) 259076"];
8474 [label="bool onlyWhitespaceOnLine = !isTrailing; 259077"];
8475 [label="this.Start(); 259078"];
8476 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 259079"];
8477 [label="return; 259080"];
8478 [label="this.Start(); 259081"];
8479 [label="int width = 0; 259082"];
8480 [label="return width; 259083"];
8481 [label="this.GetErrors(GetFullWidth(leading)) 259084"];
8482 [label="param GetErrors(int leadingTriviaWidth) 259085"];
8483 [label="param GetErrors(this) 259086"];
8484 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259087"];
8485 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259088"];
8486 [label="return null; 259089"];
8487 [label="param Create(SyntaxDiagnosticInfo[] errors) 259090"];
8488 [label="param Create(this) 259091"];
8489 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 259092"];
8490 [label="SyntaxToken token; 259093"];
8491 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 259094"];
8492 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 259095"];
8493 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 259096"];
8494 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 259097"];
8495 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 259098"];
8496 [label="return s_tokensWithNoTrivia[(int)kind].Value; 259099"];
8497 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259100"];
8498 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259101"];
8499 [label="Debug.Assert(quickWidth == token.FullWidth); 259102"];
8500 [label="this.AddLexedToken(token); 259103"];
8501 [label="param AddLexedToken(SyntaxToken token) 259104"];
8502 [label="Debug.Assert(token != null); 259105"];
8503 [label="_lexedTokens[_tokenCount].Value 259106"];
8504 [label="get { return (SyntaxKind)this.RawKind; } 259107"];
8505 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 259108"];
8506 [label="TextWindow.Start(); 259109"];
8507 [label="var quickWidth = TextWindow.Width; 259110"];
8508 [label="param LexSyntaxTrivia(bool afterFirstToken) 259111"];
8509 [label="param LexSyntaxTrivia(bool isTrailing) 259112"];
8510 [label="bool onlyWhitespaceOnLine = !isTrailing; 259113"];
8511 [label="this.Start(); 259114"];
8512 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 259115"];
8513 [label="return; 259116"];
8514 [label="this.Start(); 259117"];
8515 [label="int width = 0; 259118"];
8516 [label="return width; 259119"];
8517 [label="this.GetErrors(GetFullWidth(leading)) 259120"];
8518 [label="param GetErrors(int leadingTriviaWidth) 259121"];
8519 [label="param GetErrors(this) 259122"];
8520 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259123"];
8521 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 259124"];
8522 [label="return null; 259125"];
8523 [label="param AddTrivia(this) 259126"];
8524 [label="this.HasErrors 259127"];
8525 [label="get { return _errors != null; } 259128"];
8526 [label="return _errors != null; 259129"];
8527 [label="return _errors != null; 259130"];
8528 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 259131"];
8529 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 259132"];
8530 [label="param Create(SyntaxDiagnosticInfo[] errors) 259133"];
8531 [label="param Create(this) 259134"];
8532 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 259135"];
8533 [label="SyntaxToken token; 259136"];
8534 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 259137"];
8535 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 259138"];
8536 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 259139"];
8537 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 259140"];
8538 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 259141"];
8539 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259142"];
8540 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 259143"];
8541 [label="Debug.Assert(quickWidth == token.FullWidth); 259144"];
8542 [label="char ch; 259145"];
8543 [label="TextWindow.AdvanceChar(); 259146"];
8544 [label="TextWindow.AdvanceChar(); 259147"];
8545 [label="if (isTrailing)\n                        {\n                            return;\n                        } 259148"];
8546 [label="return; 259149"];
8547 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 259150"];
8548 [label="SyntaxFacts.IsWhitespace(ch) 259151"];
8549 [label="param IsWhitespace(char ch) 259152"];
8550 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 259153"];
8551 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 259154"];
8552 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 259155"];
8553 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 259156"];
8554 [label="SyntaxFacts.IsNewLine(ch) 259157"];
8555 [label="param IsNewLine(char ch) 259158"];
8556 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 259159"];
8557 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 259160"];
8558 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 259161"];
8559 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 259162"];
8560 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 259163"];
8561 [label="param Token(GreenNode leading) 259164"];
8562 [label="param Token(SyntaxKind kind) 259165"];
8563 [label="param Token(GreenNode trailing) 259166"];
8564 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 259167"];
8565 [label="this.AddLexedToken(token); 259168"];
8566 [label="param AddLexedToken(SyntaxToken token) 259169"];
8567 [label="Debug.Assert(token != null); 259170"];
8568 [label="_lexedTokens[_tokenCount].Value 259171"];
8569 [label="get { return (SyntaxKind)this.RawKind; } 259172"];
8570 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 259173"];
8571 [label="this.PreLex(); 259174"];
8572 [label="new SyntaxListPool() 259175"];
8573 [label="_pool = new SyntaxListPool() 259176"];
8574 [label="_syntaxFactoryContext 259177"];
8575 [label="_syntaxFactory 259178"];
8576 [label="_recursionDepth 259179"];
8577 [label="_termState 259180"];
8578 [label="_isInTry 259181"];
8579 [label="_checkedTopLevelStatementsFeatureAvailability 259182"];
8580 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 259183"];
8581 [label="_syntaxFactoryContext 259184"];
8582 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 259185"];
8583 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 259186"];
8584 [label="_syntaxFactory 259187"];
8585 [label="parser.ParseCompilationUnit() 259188"];
8586 [label="param ParseCompilationUnit(this) 259189"];
8587 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 259190"];
8588 [label="return ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))); 259191"];
8589 [label="ParseWithStackGuard(\n                ParseCompilationUnitCore,\n                () => SyntaxFactory.CompilationUnit(\n                        new SyntaxList<ExternAliasDirectiveSyntax>(),\n                        new SyntaxList<UsingDirectiveSyntax>(),\n                        new SyntaxList<AttributeListSyntax>(),\n                        new SyntaxList<MemberDeclarationSyntax>(),\n                        SyntaxFactory.Token(SyntaxKind.EndOfFileToken))) 259192"];
8590 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 259193"];
8591 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 259194"];
8592 [label="param ParseWithStackGuard(this) 259195"];
8593 [label="Debug.Assert(_recursionDepth == 0); 259196"];
8594 [label="Debug.Assert(_recursionDepth == 0); 259197"];
8595 [label="return parseFunc(); 259198"];
8596 [label="return parseFunc(); 259199"];
8597 [label="param ParseCompilationUnitCore(this) 259200"];
8598 [label="SyntaxToken tmp = null; 259201"];
8599 [label="SyntaxListBuilder initialBadNodes = null; 259202"];
8600 [label="var body = new NamespaceBodyBuilder(_pool); 259203"];
8601 [label="var body = new NamespaceBodyBuilder(_pool); 259204"];
8602 [label="new NamespaceBodyBuilder(_pool) 259205"];
8603 [label="param NamespaceBodyBuilder(SyntaxListPool pool) 259206"];
8604 [label="param NamespaceBodyBuilder(this) 259207"];
8605 [label="Externs = pool.Allocate<ExternAliasDirectiveSyntax>(); 259208"];
8606 [label="Externs 259209"];
8607 [label="Usings = pool.Allocate<UsingDirectiveSyntax>(); 259210"];
8608 [label="Usings 259211"];
8609 [label="Attributes = pool.Allocate<AttributeListSyntax>(); 259212"];
8610 [label="Attributes 259213"];
8611 [label="Members = pool.Allocate<MemberDeclarationSyntax>(); 259214"];
8612 [label="Members 259215"];
8613 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259216"];
8614 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259217"];
8615 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259218"];
8616 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259219"];
8617 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259220"];
8618 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 259221"];
8619 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 259222"];
8620 [label="return _syntaxFactoryContext.IsInAsync; 259223"];
8621 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259224"];
8622 [label="this.FetchCurrentToken() 259225"];
8623 [label="param FetchCurrentToken(this) 259226"];
8624 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259227"];
8625 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259228"];
8626 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259229"];
8627 [label="return _lexedTokens[_tokenOffset]; 259230"];
8628 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259231"];
8629 [label="_currentToken 259232"];
8630 [label="get { return (SyntaxKind)this.RawKind; } 259233"];
8631 [label="return (SyntaxKind)this.RawKind; 259234"];
8632 [label="param AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers) 259235"];
8633 [label="param AddIncompleteMembers(ref NamespaceBodyBuilder body) 259236"];
8634 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 259237"];
8635 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 259238"];
8636 [label="param ParseNamespaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists) 259239"];
8637 [label="param ParseNamespaceDeclaration(SyntaxListBuilder modifiers) 259240"];
8638 [label="param ParseNamespaceDeclaration(this) 259241"];
8639 [label="_recursionDepth 259242"];
8640 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 259243"];
8641 [label="var result = ParseNamespaceDeclarationCore(attributeLists, modifiers); 259244"];
8642 [label="var result = ParseNamespaceDeclarationCore(attributeLists, modifiers); 259245"];
8643 [label="ParseNamespaceDeclarationCore(attributeLists, modifiers) 259246"];
8644 [label="param ParseNamespaceDeclarationCore(SyntaxList<AttributeListSyntax> attributeLists) 259247"];
8645 [label="param ParseNamespaceDeclarationCore(SyntaxListBuilder modifiers) 259248"];
8646 [label="param ParseNamespaceDeclarationCore(this) 259249"];
8647 [label="this.CurrentToken 259250"];
8648 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259251"];
8649 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259252"];
8650 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.NamespaceKeyword); 259253"];
8651 [label="this.CurrentToken.Kind 259254"];
8652 [label="get { return (SyntaxKind)this.RawKind; } 259255"];
8653 [label="var namespaceToken = this.EatToken(SyntaxKind.NamespaceKeyword); 259256"];
8654 [label="this.EatToken(SyntaxKind.NamespaceKeyword) 259257"];
8655 [label="param EatToken(SyntaxKind kind) 259258"];
8656 [label="param EatToken(this) 259259"];
8657 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 259260"];
8658 [label="SyntaxFacts.IsAnyToken(kind) 259261"];
8659 [label="param IsAnyToken(SyntaxKind kind) 259262"];
8660 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 259263"];
8661 [label="return true; 259264"];
8662 [label="this.CurrentToken 259265"];
8663 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259266"];
8664 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259267"];
8665 [label="var ct = this.CurrentToken; 259268"];
8666 [label="ct.Kind 259269"];
8667 [label="get { return (SyntaxKind)this.RawKind; } 259270"];
8668 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 259271"];
8669 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 259272"];
8670 [label="MoveToNextToken() 259273"];
8671 [label="param MoveToNextToken(this) 259274"];
8672 [label="_currentToken.GetTrailingTrivia() 259275"];
8673 [label="param GetTrailingTrivia(this) 259276"];
8674 [label="return this.TrailingField; 259277"];
8675 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 259278"];
8676 [label="_prevTokenTrailingTrivia 259279"];
8677 [label="_currentToken = null; 259280"];
8678 [label="_currentToken 259281"];
8679 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259282"];
8680 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259283"];
8681 [label="_tokenOffset 259284"];
8682 [label="MoveToNextToken(); 259285"];
8683 [label="return ct; 259286"];
8684 [label="IsScript 259287"];
8685 [label="get { return Options.Kind == SourceCodeKind.Script; } 259288"];
8686 [label="Options 259289"];
8687 [label="get { return this.lexer.Options; } 259290"];
8688 [label="this.lexer.Options 259291"];
8689 [label="get { return _options; } 259292"];
8690 [label="return _options; 259293"];
8691 [label="return this.lexer.Options; 259294"];
8692 [label="return Options.Kind == SourceCodeKind.Script; 259295"];
8693 [label="if (IsScript)\n            {\n                namespaceToken = this.AddError(namespaceToken, ErrorCode.ERR_NamespaceNotAllowedInScript);\n            } 259296"];
8694 [label="var name = this.ParseQualifiedName(); 259297"];
8695 [label="this.ParseQualifiedName() 259298"];
8696 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 259299"];
8697 [label="param ParseQualifiedName(this) 259300"];
8698 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 259301"];
8699 [label="this.ParseAliasQualifiedName(options) 259302"];
8700 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 259303"];
8701 [label="param ParseAliasQualifiedName(this) 259304"];
8702 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 259305"];
8703 [label="this.ParseSimpleName(allowedParts) 259306"];
8704 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 259307"];
8705 [label="param ParseSimpleName(this) 259308"];
8706 [label="var id = this.ParseIdentifierName(); 259309"];
8707 [label="this.ParseIdentifierName() 259310"];
8708 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259311"];
8709 [label="param ParseIdentifierName(this) 259312"];
8710 [label="this.IsIncrementalAndFactoryContextMatches 259313"];
8711 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 259314"];
8712 [label="base.IsIncremental 259315"];
8713 [label="get\n            {\n                return _isIncremental;\n            } 259316"];
8714 [label="return _isIncremental; 259317"];
8715 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 259318"];
8716 [label="return false; 259319"];
8717 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 259320"];
8718 [label="var tk = ParseIdentifierToken(code); 259321"];
8719 [label="ParseIdentifierToken(code) 259322"];
8720 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259323"];
8721 [label="param ParseIdentifierToken(this) 259324"];
8722 [label="this.CurrentToken 259325"];
8723 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259326"];
8724 [label="this.FetchCurrentToken() 259327"];
8725 [label="param FetchCurrentToken(this) 259328"];
8726 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259329"];
8727 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259330"];
8728 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259331"];
8729 [label="return _lexedTokens[_tokenOffset]; 259332"];
8730 [label="var ctk = this.CurrentToken.Kind; 259333"];
8731 [label="this.CurrentToken.Kind 259334"];
8732 [label="get { return (SyntaxKind)this.RawKind; } 259335"];
8733 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 259336"];
8734 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 259337"];
8735 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 259338"];
8736 [label="this.CurrentToken 259339"];
8737 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259340"];
8738 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 259341"];
8739 [label="this.CurrentToken.ContextualKind 259342"];
8740 [label="get\n            {\n                return this.Kind;\n            } 259343"];
8741 [label="this.Kind 259344"];
8742 [label="get { return (SyntaxKind)this.RawKind; } 259345"];
8743 [label="return this.Kind; 259346"];
8744 [label="return false; 259347"];
8745 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259348"];
8746 [label="IsCurrentTokenQueryKeywordInQuery() 259349"];
8747 [label="param IsCurrentTokenQueryKeywordInQuery(this) 259350"];
8748 [label="this.IsInQuery 259351"];
8749 [label="get { return _syntaxFactoryContext.IsInQuery; } 259352"];
8750 [label="return _syntaxFactoryContext.IsInQuery; 259353"];
8751 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 259354"];
8752 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259355"];
8753 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259356"];
8754 [label="this.EatToken() 259357"];
8755 [label="param EatToken(this) 259358"];
8756 [label="this.CurrentToken 259359"];
8757 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259360"];
8758 [label="var ct = this.CurrentToken; 259361"];
8759 [label="MoveToNextToken() 259362"];
8760 [label="param MoveToNextToken(this) 259363"];
8761 [label="param GetTrailingTrivia(this) 259364"];
8762 [label="return _trailing; 259365"];
8763 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259366"];
8764 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259367"];
8765 [label="MoveToNextToken(); 259368"];
8766 [label="return ct; 259369"];
8767 [label="SyntaxToken identifierToken = this.EatToken(); 259370"];
8768 [label="this.IsInAsync 259371"];
8769 [label="return _syntaxFactoryContext.IsInAsync; 259372"];
8770 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 259373"];
8771 [label="return identifierToken; 259374"];
8772 [label="var tk = ParseIdentifierToken(code); 259375"];
8773 [label="return SyntaxFactory.IdentifierName(tk); 259376"];
8774 [label="return SyntaxFactory.IdentifierName(tk); 259377"];
8775 [label="param CSharpSyntaxNode(SyntaxKind kind) 259378"];
8776 [label="param CSharpSyntaxNode(this) 259379"];
8777 [label="kind 259380"];
8778 [label="param CSharpSyntaxNode(this) 259381"];
8779 [label="param CSharpSyntaxNode(this) 259382"];
8780 [label="GreenStats.NoteGreen(this); 259383"];
8781 [label="GreenStats.NoteGreen(this); 259384"];
8782 [label="var id = this.ParseIdentifierName(); 259385"];
8783 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 259386"];
8784 [label="SimpleNameSyntax name = id; 259387"];
8785 [label="this.CurrentToken 259388"];
8786 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259389"];
8787 [label="this.FetchCurrentToken() 259390"];
8788 [label="param FetchCurrentToken(this) 259391"];
8789 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259392"];
8790 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259393"];
8791 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259394"];
8792 [label="return _lexedTokens[_tokenOffset]; 259395"];
8793 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 259396"];
8794 [label="this.CurrentToken.Kind 259397"];
8795 [label="get { return (SyntaxKind)this.RawKind; } 259398"];
8796 [label="return name; 259399"];
8797 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 259400"];
8798 [label="this.CurrentToken 259401"];
8799 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259402"];
8800 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259403"];
8801 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 259404"];
8802 [label="this.CurrentToken.Kind 259405"];
8803 [label="get { return (SyntaxKind)this.RawKind; } 259406"];
8804 [label="return name; 259407"];
8805 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 259408"];
8806 [label="this.IsDotOrColonColon() 259409"];
8807 [label="param IsDotOrColonColon(this) 259410"];
8808 [label="this.CurrentToken 259411"];
8809 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259412"];
8810 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259413"];
8811 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259414"];
8812 [label="this.CurrentToken.Kind 259415"];
8813 [label="get { return (SyntaxKind)this.RawKind; } 259416"];
8814 [label="this.CurrentToken 259417"];
8815 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259418"];
8816 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259419"];
8817 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259420"];
8818 [label="this.CurrentToken.Kind 259421"];
8819 [label="get { return (SyntaxKind)this.RawKind; } 259422"];
8820 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259423"];
8821 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259424"];
8822 [label="this.CurrentToken 259425"];
8823 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259426"];
8824 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259427"];
8825 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259428"];
8826 [label="this.CurrentToken.Kind 259429"];
8827 [label="get { return (SyntaxKind)this.RawKind; } 259430"];
8828 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259431"];
8829 [label="return name; 259432"];
8830 [label="var name = this.ParseQualifiedName(); 259433"];
8831 [label="SyntaxToken openBrace; 259434"];
8832 [label="this.CurrentToken 259435"];
8833 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259436"];
8834 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259437"];
8835 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || IsPossibleNamespaceMemberDeclaration())\n            {\n                //either we see the brace we expect here or we see something that could come after a brace\n                //so we insert a missing one\n                openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n            }\n            else\n            {\n                //the next character is neither the brace we expect, nor a token that could follow the expected\n                //brace so we assume it's a mistake and replace it with a missing brace \n                openBrace = this.EatTokenWithPrejudice(SyntaxKind.OpenBraceToken);\n                openBrace = this.ConvertToMissingWithTrailingTrivia(openBrace, SyntaxKind.OpenBraceToken);\n            } 259438"];
8836 [label="this.CurrentToken.Kind 259439"];
8837 [label="get { return (SyntaxKind)this.RawKind; } 259440"];
8838 [label="openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 259441"];
8839 [label="this.EatToken(SyntaxKind.OpenBraceToken) 259442"];
8840 [label="param EatToken(SyntaxKind kind) 259443"];
8841 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 259444"];
8842 [label="SyntaxFacts.IsAnyToken(kind) 259445"];
8843 [label="param IsAnyToken(SyntaxKind kind) 259446"];
8844 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 259447"];
8845 [label="return true; 259448"];
8846 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259449"];
8847 [label="MoveToNextToken(); 259450"];
8848 [label="return ct; 259451"];
8849 [label="var body = new NamespaceBodyBuilder(_pool); 259452"];
8850 [label="var body = new NamespaceBodyBuilder(_pool); 259453"];
8851 [label="new NamespaceBodyBuilder(_pool) 259454"];
8852 [label="param NamespaceBodyBuilder(SyntaxListPool pool) 259455"];
8853 [label="param NamespaceBodyBuilder(this) 259456"];
8854 [label="Externs = pool.Allocate<ExternAliasDirectiveSyntax>(); 259457"];
8855 [label="SyntaxListBuilder initialBadNodes = null; 259458"];
8856 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259459"];
8857 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259460"];
8858 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259461"];
8859 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259462"];
8860 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259463"];
8861 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259464"];
8862 [label="this.FetchCurrentToken() 259465"];
8863 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259466"];
8864 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259467"];
8865 [label="param ParseMemberDeclaration(SyntaxKind parentKind) 259468"];
8866 [label="param ParseMemberDeclaration(this) 259469"];
8867 [label="_recursionDepth 259470"];
8868 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 259471"];
8869 [label="var result = ParseMemberDeclarationCore(parentKind); 259472"];
8870 [label="var result = ParseMemberDeclarationCore(parentKind); 259473"];
8871 [label="var result = ParseMemberDeclarationCore(parentKind); 259474"];
8872 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 259475"];
8873 [label="base.IsIncremental 259476"];
8874 [label="get\n            {\n                return _isIncremental;\n            } 259477"];
8875 [label="return _isIncremental; 259478"];
8876 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 259479"];
8877 [label="return false; 259480"];
8878 [label="param ParseAttributeDeclarations(this) 259481"];
8879 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 259482"];
8880 [label="var saveTerm = _termState; 259483"];
8881 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 259484"];
8882 [label="_termState 259485"];
8883 [label="this.IsPossibleAttributeDeclaration() 259486"];
8884 [label="param IsPossibleAttributeDeclaration(this) 259487"];
8885 [label="this.CurrentToken 259488"];
8886 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259489"];
8887 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259490"];
8888 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 259491"];
8889 [label="this.CurrentToken.Kind 259492"];
8890 [label="get { return (SyntaxKind)this.RawKind; } 259493"];
8891 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 259494"];
8892 [label="_termState 259495"];
8893 [label="return attributes.ToList(); 259496"];
8894 [label="_pool.Free(attributes); 259497"];
8895 [label="_pool.Free(attributes); 259498"];
8896 [label="param ParseModifiers(SyntaxListBuilder tokens) 259499"];
8897 [label="param ParseModifiers(bool forAccessors) 259500"];
8898 [label="param ParseModifiers(this) 259501"];
8899 [label="while (true)\n            {\n                var newMod = GetModifier(this.CurrentToken);\n                if (newMod == DeclarationModifiers.None)\n                {\n                    break;\n                }\n\n                SyntaxToken modTok;\n                switch (newMod)\n                {\n                    case DeclarationModifiers.Partial:\n                        var nextToken = PeekToken(1);\n                        var isPartialType = this.IsPartialType();\n                        var isPartialMember = this.IsPartialMember();\n                        if (isPartialType || isPartialMember)\n                        {\n                            // Standard legal cases.\n                            modTok = ConvertToKeyword(this.EatToken());\n                            modTok = CheckFeatureAvailability(modTok,\n                                isPartialType ? MessageID.IDS_FeaturePartialTypes : MessageID.IDS_FeaturePartialMethod);\n                        }\n                        else if (nextToken.Kind == SyntaxKind.NamespaceKeyword)\n                        {\n                            // Error reported in binding\n                            modTok = ConvertToKeyword(this.EatToken());\n                        }\n                        else if (\n                            nextToken.Kind == SyntaxKind.EnumKeyword ||\n                            nextToken.Kind == SyntaxKind.DelegateKeyword ||\n                            (IsPossibleStartOfTypeDeclaration(nextToken.Kind) && GetModifier(nextToken) != DeclarationModifiers.None))\n                        {\n                            // Misplaced partial\n                            // TODO(https://github.com/dotnet/roslyn/issues/22439):\n                            // We should consider moving this check into binding, but avoid holding on to trees\n                            modTok = AddError(ConvertToKeyword(this.EatToken()), ErrorCode.ERR_PartialMisplaced);\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                        break;\n\n                    case DeclarationModifiers.Ref:\n                        // 'ref' is only a modifier if used on a ref struct\n                        // it must be either immediately before the 'struct'\n                        // keyword, or immediately before 'partial struct' if\n                        // this is a partial ref struct declaration\n                        {\n                            var next = PeekToken(1);\n                            if (next.Kind == SyntaxKind.StructKeyword ||\n                                (next.ContextualKind == SyntaxKind.PartialKeyword &&\n                                 PeekToken(2).Kind == SyntaxKind.StructKeyword))\n                            {\n                                modTok = this.EatToken();\n                                modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureRefStructs);\n                            }\n                            else if (forAccessors && this.IsPossibleAccessorModifier())\n                            {\n                                // Accept ref as a modifier for properties and event accessors, to produce an error later during binding.\n                                modTok = this.EatToken();\n                            }\n                            else\n                            {\n                                return;\n                            }\n                            break;\n                        }\n\n                    case DeclarationModifiers.Async:\n                        if (!ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: false))\n                        {\n                            return;\n                        }\n\n                        modTok = ConvertToKeyword(this.EatToken());\n                        modTok = CheckFeatureAvailability(modTok, MessageID.IDS_FeatureAsync);\n                        break;\n\n                    case DeclarationModifiers.Data:\n                        return;\n\n                    default:\n                        modTok = this.EatToken();\n                        break;\n                }\n\n                tokens.Add(modTok);\n            } 259502"];
8900 [label="this.CurrentToken 259503"];
8901 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259504"];
8902 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259505"];
8903 [label="var newMod = GetModifier(this.CurrentToken); 259506"];
8904 [label="GetModifier(this.CurrentToken) 259507"];
8905 [label="param GetModifier(SyntaxToken token) 259508"];
8906 [label="token.Kind 259509"];
8907 [label="get { return (SyntaxKind)this.RawKind; } 259510"];
8908 [label="token.ContextualKind 259511"];
8909 [label="get\n            {\n                return this.Kind;\n            } 259512"];
8910 [label="this.Kind 259513"];
8911 [label="get { return (SyntaxKind)this.RawKind; } 259514"];
8912 [label="return this.Kind; 259515"];
8913 [label="GetModifier(token.Kind, token.ContextualKind) 259516"];
8914 [label="if (newMod == DeclarationModifiers.None)\n                {\n                    break;\n                } 259517"];
8915 [label="param IsTypeDeclarationStart(this) 259518"];
8916 [label="this.CurrentToken 259519"];
8917 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259520"];
8918 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259521"];
8919 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.DelegateKeyword when !IsFunctionPointerStart():\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.StructKeyword:\n                    return true;\n\n                case SyntaxKind.IdentifierToken:\n                    if (CurrentToken.ContextualKind == SyntaxKind.RecordKeyword)\n                    {\n                        // This is an unusual use of LangVersion. Normally we only produce errors when the langversion\n                        // does not support a feature, but in this case we are effectively making a language breaking\n                        // change to consider 'record' a type declaration in all ambiguous cases. To avoid breaking\n                        // older code that is not using C# 9 we conditionally parse based on langversion\n                        return IsFeatureEnabled(MessageID.IDS_FeatureRecords);\n                    }\n                    return false;\n\n                default:\n                    return false;\n            } 259522"];
8920 [label="this.CurrentToken.Kind 259523"];
8921 [label="get { return (SyntaxKind)this.RawKind; } 259524"];
8922 [label="return true; 259525"];
8923 [label="param ParseTypeDeclaration(SyntaxList<AttributeListSyntax> attributes) 259526"];
8924 [label="param ParseTypeDeclaration(SyntaxListBuilder modifiers) 259527"];
8925 [label="param ParseTypeDeclaration(this) 259528"];
8926 [label="IsInAsync 259529"];
8927 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 259530"];
8928 [label="return _syntaxFactoryContext.IsInAsync; 259531"];
8929 [label="Debug.Assert(!IsInAsync); 259532"];
8930 [label="cancellationToken.ThrowIfCancellationRequested(); 259533"];
8931 [label="this.CurrentToken 259534"];
8932 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259535"];
8933 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259536"];
8934 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.ClassKeyword:\n                    // report use of 'static class' if feature is unsupported \n                    CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses);\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.StructKeyword:\n                    // report use of 'readonly struct' if feature is unsupported\n                    CheckForVersionSpecificModifiers(modifiers, SyntaxKind.ReadOnlyKeyword, MessageID.IDS_FeatureReadOnlyStructs);\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.InterfaceKeyword:\n                    return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseDelegateDeclaration(attributes, modifiers);\n\n                case SyntaxKind.EnumKeyword:\n                    return this.ParseEnumDeclaration(attributes, modifiers);\n\n                case SyntaxKind.IdentifierToken:\n                    Debug.Assert(CurrentToken.ContextualKind == SyntaxKind.RecordKeyword);\n                    return ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.CurrentToken.Kind);\n            } 259537"];
8935 [label="this.CurrentToken.Kind 259538"];
8936 [label="get { return (SyntaxKind)this.RawKind; } 259539"];
8937 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses); 259540"];
8938 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses); 259541"];
8939 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses) 259542"];
8940 [label="param CheckForVersionSpecificModifiers(SyntaxListBuilder modifiers) 259543"];
8941 [label="param CheckForVersionSpecificModifiers(SyntaxKind kind) 259544"];
8942 [label="param CheckForVersionSpecificModifiers(MessageID feature) 259545"];
8943 [label="param CheckForVersionSpecificModifiers(this) 259546"];
8944 [label="for (int i = 0, n = modifiers.Count; i < n; i++)\n            {\n                if (modifiers[i].RawKind == (int)kind)\n                {\n                    modifiers[i] = CheckFeatureAvailability(modifiers[i], feature);\n                }\n            } 259547"];
8945 [label="for (int i = 0, n = modifiers.Count; i < n; i++)\n            {\n                if (modifiers[i].RawKind == (int)kind)\n                {\n                    modifiers[i] = CheckFeatureAvailability(modifiers[i], feature);\n                }\n            } 259548"];
8946 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses); 259549"];
8947 [label="return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers); 259550"];
8948 [label="return this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers); 259551"];
8949 [label="this.ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers) 259552"];
8950 [label="param ParseClassOrStructOrInterfaceDeclaration(SyntaxList<AttributeListSyntax> attributes) 259553"];
8951 [label="param ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder modifiers) 259554"];
8952 [label="param ParseClassOrStructOrInterfaceDeclaration(this) 259555"];
8953 [label="this.CurrentToken 259556"];
8954 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259557"];
8955 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.StructKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword ||\n                CurrentToken.ContextualKind == SyntaxKind.RecordKeyword); 259558"];
8956 [label="this.CurrentToken.Kind 259559"];
8957 [label="get { return (SyntaxKind)this.RawKind; } 259560"];
8958 [label="IsInAsync 259561"];
8959 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 259562"];
8960 [label="Debug.Assert(!IsInAsync); 259563"];
8961 [label="this.EatToken() 259564"];
8962 [label="param EatToken(this) 259565"];
8963 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259566"];
8964 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259567"];
8965 [label="MoveToNextToken(); 259568"];
8966 [label="var keyword = ConvertToKeyword(this.EatToken()); 259569"];
8967 [label="ConvertToKeyword(this.EatToken()) 259570"];
8968 [label="param ConvertToKeyword(SyntaxToken token) 259571"];
8969 [label="token.Kind 259572"];
8970 [label="get { return (SyntaxKind)this.RawKind; } 259573"];
8971 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259574"];
8972 [label="token.ContextualKind 259575"];
8973 [label="get\n            {\n                return this.Kind;\n            } 259576"];
8974 [label="this.Kind 259577"];
8975 [label="get { return (SyntaxKind)this.RawKind; } 259578"];
8976 [label="return this.Kind; 259579"];
8977 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259580"];
8978 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259581"];
8979 [label="return token; 259582"];
8980 [label="var outerSaveTerm = _termState; 259583"];
8981 [label="keyword.Kind 259584"];
8982 [label="get { return (SyntaxKind)this.RawKind; } 259585"];
8983 [label="if (keyword.Kind == SyntaxKind.RecordKeyword)\n            {\n                _termState |= TerminatorState.IsEndOfRecordSignature;\n            } 259586"];
8984 [label="var saveTerm = _termState; 259587"];
8985 [label="_termState |= TerminatorState.IsPossibleAggregateClauseStartOrStop; 259588"];
8986 [label="_termState 259589"];
8987 [label="var name = this.ParseIdentifierToken(); 259590"];
8988 [label="this.ParseIdentifierToken() 259591"];
8989 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259592"];
8990 [label="param ParseIdentifierToken(this) 259593"];
8991 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259594"];
8992 [label="return _lexedTokens[_tokenOffset]; 259595"];
8993 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 259596"];
8994 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 259597"];
8995 [label="this.CurrentToken 259598"];
8996 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259599"];
8997 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 259600"];
8998 [label="this.CurrentToken.ContextualKind 259601"];
8999 [label="get\n            {\n                return this.Kind;\n            } 259602"];
9000 [label="this.Kind 259603"];
9001 [label="get { return (SyntaxKind)this.RawKind; } 259604"];
9002 [label="return this.Kind; 259605"];
9003 [label="return false; 259606"];
9004 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259607"];
9005 [label="IsCurrentTokenQueryKeywordInQuery() 259608"];
9006 [label="param IsCurrentTokenQueryKeywordInQuery(this) 259609"];
9007 [label="this.IsInQuery 259610"];
9008 [label="get { return _syntaxFactoryContext.IsInQuery; } 259611"];
9009 [label="return _syntaxFactoryContext.IsInQuery; 259612"];
9010 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 259613"];
9011 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259614"];
9012 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259615"];
9013 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259616"];
9014 [label="MoveToNextToken(); 259617"];
9015 [label="this.IsInAsync 259618"];
9016 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 259619"];
9017 [label="var name = this.ParseIdentifierToken(); 259620"];
9018 [label="this.ParseTypeParameterList() 259621"];
9019 [label="param ParseTypeParameterList(this) 259622"];
9020 [label="this.CurrentToken 259623"];
9021 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259624"];
9022 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259625"];
9023 [label="return _lexedTokens[_tokenOffset]; 259626"];
9024 [label="if (this.CurrentToken.Kind != SyntaxKind.LessThanToken)\n            {\n                return null;\n            } 259627"];
9025 [label="this.CurrentToken.Kind 259628"];
9026 [label="get { return (SyntaxKind)this.RawKind; } 259629"];
9027 [label="return null; 259630"];
9028 [label="var typeParameters = this.ParseTypeParameterList(); 259631"];
9029 [label="keyword.Kind 259632"];
9030 [label="get { return (SyntaxKind)this.RawKind; } 259633"];
9031 [label="var paramList = keyword.Kind == SyntaxKind.RecordKeyword && CurrentToken.Kind == SyntaxKind.OpenParenToken\n                ? ParseParenthesizedParameterList() : null; 259634"];
9032 [label="keyword.Kind == SyntaxKind.RecordKeyword && CurrentToken.Kind == SyntaxKind.OpenParenToken 259635"];
9033 [label="var baseList = this.ParseBaseList(keyword, paramList is object); 259636"];
9034 [label="var baseList = this.ParseBaseList(keyword, paramList is object); 259637"];
9035 [label="this.ParseBaseList(keyword, paramList is object) 259638"];
9036 [label="param ParseBaseList(SyntaxToken typeKeyword) 259639"];
9037 [label="param ParseBaseList(bool haveParameters) 259640"];
9038 [label="param ParseBaseList(this) 259641"];
9039 [label="this.CurrentToken 259642"];
9040 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259643"];
9041 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259644"];
9042 [label="if (this.CurrentToken.Kind != SyntaxKind.ColonToken)\n            {\n                return null;\n            } 259645"];
9043 [label="this.CurrentToken.Kind 259646"];
9044 [label="get { return (SyntaxKind)this.RawKind; } 259647"];
9045 [label="return null; 259648"];
9046 [label="var baseList = this.ParseBaseList(keyword, paramList is object); 259649"];
9047 [label="_termState 259650"];
9048 [label="bool parseMembers = true; 259651"];
9049 [label="SyntaxListBuilder<MemberDeclarationSyntax> members = default(SyntaxListBuilder<MemberDeclarationSyntax>); 259652"];
9050 [label="var constraints = default(SyntaxListBuilder<TypeParameterConstraintClauseSyntax>); 259653"];
9051 [label="this.CurrentToken 259654"];
9052 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259655"];
9053 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259656"];
9054 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = _pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(constraints);\n                } 259657"];
9055 [label="this.CurrentToken.ContextualKind 259658"];
9056 [label="get\n            {\n                return this.Kind;\n            } 259659"];
9057 [label="this.Kind 259660"];
9058 [label="get { return (SyntaxKind)this.RawKind; } 259661"];
9059 [label="return this.Kind; 259662"];
9060 [label="_termState 259663"];
9061 [label="SyntaxToken semicolon; 259664"];
9062 [label="SyntaxToken? openBrace; 259665"];
9063 [label="SyntaxToken? closeBrace; 259666"];
9064 [label="keyword.Kind 259667"];
9065 [label="get { return (SyntaxKind)this.RawKind; } 259668"];
9066 [label="if (!(keyword.Kind == SyntaxKind.RecordKeyword) || CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    openBrace = this.EatToken(SyntaxKind.OpenBraceToken);\n\n                    // ignore members if missing type name or missing open curly\n                    if (name.IsMissing || openBrace.IsMissing)\n                    {\n                        parseMembers = false;\n                    }\n\n                    // even if we saw a { or think we should parse members bail out early since\n                    // we know namespaces can't be nested inside types\n                    if (parseMembers)\n                    {\n                        members = _pool.Allocate<MemberDeclarationSyntax>();\n\n                        while (true)\n                        {\n                            SyntaxKind kind = this.CurrentToken.Kind;\n\n                            if (CanStartMember(kind))\n                            {\n                                // This token can start a member -- go parse it\n                                var saveTerm2 = _termState;\n                                _termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                                var member = this.ParseMemberDeclaration(keyword.Kind);\n                                if (member != null)\n                                {\n                                    // statements are accepted here, a semantic error will be reported later\n                                    members.Add(member);\n                                }\n                                else\n                                {\n                                    // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                    this.SkipBadMemberListTokens(ref openBrace, members);\n                                }\n\n                                _termState = saveTerm2;\n                            }\n                            else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            }\n                        }\n                    }\n\n                    if (openBrace.IsMissing)\n                    {\n                        closeBrace = SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken);\n                        closeBrace = WithAdditionalDiagnostics(closeBrace, this.GetExpectedTokenError(SyntaxKind.CloseBraceToken, this.CurrentToken.Kind));\n                    }\n                    else\n                    {\n                        closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                    }\n                    semicolon = TryEatToken(SyntaxKind.SemicolonToken);\n                }\n                else\n                {\n                    semicolon = CheckFeatureAvailability(EatToken(SyntaxKind.SemicolonToken), MessageID.IDS_FeatureRecords);\n                    openBrace = null;\n                    closeBrace = null;\n                } 259669"];
9067 [label="openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 259670"];
9068 [label="this.EatToken(SyntaxKind.OpenBraceToken) 259671"];
9069 [label="param EatToken(SyntaxKind kind) 259672"];
9070 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 259673"];
9071 [label="SyntaxFacts.IsAnyToken(kind) 259674"];
9072 [label="param IsAnyToken(SyntaxKind kind) 259675"];
9073 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 259676"];
9074 [label="return true; 259677"];
9075 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259678"];
9076 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 259679"];
9077 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259680"];
9078 [label="MoveToNextToken(); 259681"];
9079 [label="if (name.IsMissing || openBrace.IsMissing)\n                    {\n                        parseMembers = false;\n                    } 259682"];
9080 [label="if (parseMembers)\n                    {\n                        members = _pool.Allocate<MemberDeclarationSyntax>();\n\n                        while (true)\n                        {\n                            SyntaxKind kind = this.CurrentToken.Kind;\n\n                            if (CanStartMember(kind))\n                            {\n                                // This token can start a member -- go parse it\n                                var saveTerm2 = _termState;\n                                _termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                                var member = this.ParseMemberDeclaration(keyword.Kind);\n                                if (member != null)\n                                {\n                                    // statements are accepted here, a semantic error will be reported later\n                                    members.Add(member);\n                                }\n                                else\n                                {\n                                    // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                    this.SkipBadMemberListTokens(ref openBrace, members);\n                                }\n\n                                _termState = saveTerm2;\n                            }\n                            else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            }\n                        }\n                    } 259683"];
9081 [label="members = _pool.Allocate<MemberDeclarationSyntax>(); 259684"];
9082 [label="while (true)\n                        {\n                            SyntaxKind kind = this.CurrentToken.Kind;\n\n                            if (CanStartMember(kind))\n                            {\n                                // This token can start a member -- go parse it\n                                var saveTerm2 = _termState;\n                                _termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                                var member = this.ParseMemberDeclaration(keyword.Kind);\n                                if (member != null)\n                                {\n                                    // statements are accepted here, a semantic error will be reported later\n                                    members.Add(member);\n                                }\n                                else\n                                {\n                                    // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                    this.SkipBadMemberListTokens(ref openBrace, members);\n                                }\n\n                                _termState = saveTerm2;\n                            }\n                            else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            }\n                        } 259685"];
9083 [label="this.CurrentToken 259686"];
9084 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259687"];
9085 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259688"];
9086 [label="SyntaxKind kind = this.CurrentToken.Kind; 259689"];
9087 [label="this.CurrentToken.Kind 259690"];
9088 [label="get { return (SyntaxKind)this.RawKind; } 259691"];
9089 [label="if (CanStartMember(kind))\n                            {\n                                // This token can start a member -- go parse it\n                                var saveTerm2 = _termState;\n                                _termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                                var member = this.ParseMemberDeclaration(keyword.Kind);\n                                if (member != null)\n                                {\n                                    // statements are accepted here, a semantic error will be reported later\n                                    members.Add(member);\n                                }\n                                else\n                                {\n                                    // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                    this.SkipBadMemberListTokens(ref openBrace, members);\n                                }\n\n                                _termState = saveTerm2;\n                            }\n                            else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            } 259692"];
9090 [label="CanStartMember(kind) 259693"];
9091 [label="param CanStartMember(SyntaxKind kind) 259694"];
9092 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.EventKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.OverrideKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.VirtualKeyword:\n                case SyntaxKind.VoidKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.TildeToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.ImplicitKeyword:\n                case SyntaxKind.ExplicitKeyword:\n                case SyntaxKind.OpenParenToken:    //tuple\n                case SyntaxKind.RefKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 259695"];
9093 [label="return false; 259696"];
9094 [label="if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            } 259697"];
9095 [label="if (openBrace.IsMissing)\n                    {\n                        closeBrace = SyntaxFactory.MissingToken(SyntaxKind.CloseBraceToken);\n                        closeBrace = WithAdditionalDiagnostics(closeBrace, this.GetExpectedTokenError(SyntaxKind.CloseBraceToken, this.CurrentToken.Kind));\n                    }\n                    else\n                    {\n                        closeBrace = this.EatToken(SyntaxKind.CloseBraceToken);\n                    } 259698"];
9096 [label="closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 259699"];
9097 [label="this.EatToken(SyntaxKind.CloseBraceToken) 259700"];
9098 [label="param EatToken(SyntaxKind kind) 259701"];
9099 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 259702"];
9100 [label="SyntaxFacts.IsAnyToken(kind) 259703"];
9101 [label="param IsAnyToken(SyntaxKind kind) 259704"];
9102 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 259705"];
9103 [label="return true; 259706"];
9104 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259707"];
9105 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 259708"];
9106 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259709"];
9107 [label="MoveToNextToken(); 259710"];
9108 [label="semicolon = TryEatToken(SyntaxKind.SemicolonToken); 259711"];
9109 [label="TryEatToken(SyntaxKind.SemicolonToken) 259712"];
9110 [label="param TryEatToken(SyntaxKind kind) 259713"];
9111 [label="=> this.CurrentToken.Kind == kind ? this.EatToken() : null 259714"];
9112 [label="this.CurrentToken 259715"];
9113 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259716"];
9114 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259717"];
9115 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259718"];
9116 [label="return _lexedTokens[_tokenOffset]; 259719"];
9117 [label="this.CurrentToken.Kind 259720"];
9118 [label="get { return (SyntaxKind)this.RawKind; } 259721"];
9119 [label="this.CurrentToken.Kind == kind 259722"];
9120 [label="null 259723"];
9121 [label="this.CurrentToken.Kind == kind ? this.EatToken() : null 259724"];
9122 [label="var modifiersList = (SyntaxList<SyntaxToken>)modifiers.ToList(); 259725"];
9123 [label="var membersList = (SyntaxList<MemberDeclarationSyntax>)members; 259726"];
9124 [label="var constraintsList = (SyntaxList<TypeParameterConstraintClauseSyntax>)constraints; 259727"];
9125 [label="keyword.Kind 259728"];
9126 [label="get { return (SyntaxKind)this.RawKind; } 259729"];
9127 [label="return (SyntaxKind)this.RawKind; 259730"];
9128 [label="switch (keyword.Kind)\n                {\n                    case SyntaxKind.ClassKeyword:\n                        RoslynDebug.Assert(paramList is null);\n                        RoslynDebug.Assert(openBrace != null);\n                        RoslynDebug.Assert(closeBrace != null);\n                        return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.StructKeyword:\n                        RoslynDebug.Assert(paramList is null);\n                        RoslynDebug.Assert(openBrace != null);\n                        RoslynDebug.Assert(closeBrace != null);\n                        return _syntaxFactory.StructDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.InterfaceKeyword:\n                        RoslynDebug.Assert(paramList is null);\n                        RoslynDebug.Assert(openBrace != null);\n                        RoslynDebug.Assert(closeBrace != null);\n                        return _syntaxFactory.InterfaceDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon);\n\n                    case SyntaxKind.RecordKeyword:\n                        return _syntaxFactory.RecordDeclaration(\n                            attributes,\n                            modifiers.ToList(),\n                            keyword,\n                            name,\n                            typeParameters,\n                            paramList,\n                            baseList,\n                            constraints,\n                            openBrace,\n                            members,\n                            closeBrace,\n                            semicolon);\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(keyword.Kind);\n                } 259731"];
9129 [label="RoslynDebug.Assert(paramList is null); 259732"];
9130 [label="RoslynDebug.Assert(openBrace != null); 259733"];
9131 [label="RoslynDebug.Assert(closeBrace != null); 259734"];
9132 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259735"];
9133 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259736"];
9134 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259737"];
9135 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259738"];
9136 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259739"];
9137 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259740"];
9138 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259741"];
9139 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259742"];
9140 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259743"];
9141 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259744"];
9142 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259745"];
9143 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259746"];
9144 [label="return _syntaxFactory.ClassDeclaration(\n                            attributes,\n                            modifiersList,\n                            keyword,\n                            name,\n                            typeParameters,\n                            baseList,\n                            constraintsList,\n                            openBrace,\n                            membersList,\n                            closeBrace,\n                            semicolon); 259747"];
9145 [label="param SetFactoryContext(SyntaxFactoryContext context) 259748"];
9146 [label="param SetFactoryContext(this) 259749"];
9147 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 259750"];
9148 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 259751"];
9149 [label="if (!members.IsNull)\n                {\n                    _pool.Free(members);\n                } 259752"];
9150 [label="_pool.Free(members); 259753"];
9151 [label="_pool.Free(members); 259754"];
9152 [label="if (!constraints.IsNull)\n                {\n                    _pool.Free(constraints);\n                } 259755"];
9153 [label="_recursionDepth 259756"];
9154 [label="return result; 259757"];
9155 [label="this.ParseNamespaceBody(ref openBrace, ref body, ref initialBadNodes, SyntaxKind.NamespaceDeclaration); 259758"];
9156 [label="param AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers) 259759"];
9157 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 259760"];
9158 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 259761"];
9159 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 259762"];
9160 [label="param IsPossibleAttributeDeclaration(this) 259763"];
9161 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259764"];
9162 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 259765"];
9163 [label="get { return (SyntaxKind)this.RawKind; } 259766"];
9164 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 259767"];
9165 [label="param ParseModifiers(SyntaxListBuilder tokens) 259768"];
9166 [label="param ParseModifiers(bool forAccessors) 259769"];
9167 [label="param ParseModifiers(this) 259770"];
9168 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259771"];
9169 [label="var newMod = GetModifier(this.CurrentToken); 259772"];
9170 [label="param GetModifier(SyntaxToken token) 259773"];
9171 [label="get { return (SyntaxKind)this.RawKind; } 259774"];
9172 [label="get\n            {\n                return this.Kind;\n            } 259775"];
9173 [label="get { return (SyntaxKind)this.RawKind; } 259776"];
9174 [label="return this.Kind; 259777"];
9175 [label="GetModifier(token.Kind, token.ContextualKind) 259778"];
9176 [label="if (newMod == DeclarationModifiers.None)\n                {\n                    break;\n                } 259779"];
9177 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 259780"];
9178 [label="Debug.Assert(!IsInAsync); 259781"];
9179 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses); 259782"];
9180 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses); 259783"];
9181 [label="CheckForVersionSpecificModifiers(modifiers, SyntaxKind.StaticKeyword, MessageID.IDS_FeatureStaticClasses) 259784"];
9182 [label="param CheckForVersionSpecificModifiers(SyntaxListBuilder modifiers) 259785"];
9183 [label="param CheckForVersionSpecificModifiers(SyntaxKind kind) 259786"];
9184 [label="param CheckForVersionSpecificModifiers(MessageID feature) 259787"];
9185 [label="param CheckForVersionSpecificModifiers(this) 259788"];
9186 [label="for (int i = 0, n = modifiers.Count; i < n; i++)\n            {\n                if (modifiers[i].RawKind == (int)kind)\n                {\n                    modifiers[i] = CheckFeatureAvailability(modifiers[i], feature);\n                }\n            } 259789"];
9187 [label="for (int i = 0, n = modifiers.Count; i < n; i++)\n            {\n                if (modifiers[i].RawKind == (int)kind)\n                {\n                    modifiers[i] = CheckFeatureAvailability(modifiers[i], feature);\n                }\n            } 259790"];
9188 [label="this.CurrentToken 259791"];
9189 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.StructKeyword ||\n                this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword ||\n                CurrentToken.ContextualKind == SyntaxKind.RecordKeyword); 259792"];
9190 [label="this.CurrentToken.Kind 259793"];
9191 [label="get { return (SyntaxKind)this.RawKind; } 259794"];
9192 [label="IsInAsync 259795"];
9193 [label="Debug.Assert(!IsInAsync); 259796"];
9194 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259797"];
9195 [label="MoveToNextToken(); 259798"];
9196 [label="token.Kind 259799"];
9197 [label="get { return (SyntaxKind)this.RawKind; } 259800"];
9198 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259801"];
9199 [label="token.ContextualKind 259802"];
9200 [label="get\n            {\n                return this.Kind;\n            } 259803"];
9201 [label="this.Kind 259804"];
9202 [label="get { return (SyntaxKind)this.RawKind; } 259805"];
9203 [label="return this.Kind; 259806"];
9204 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259807"];
9205 [label="if (token.Kind != token.ContextualKind)\n            {\n                var kw = token.IsMissing\n                        ? SyntaxFactory.MissingToken(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node)\n                        : SyntaxFactory.Token(token.LeadingTrivia.Node, token.ContextualKind, token.TrailingTrivia.Node);\n                var d = token.GetDiagnostics();\n                if (d != null && d.Length > 0)\n                {\n                    kw = kw.WithDiagnosticsGreen(d);\n                }\n\n                return kw;\n            } 259808"];
9206 [label="keyword.Kind 259809"];
9207 [label="get { return (SyntaxKind)this.RawKind; } 259810"];
9208 [label="if (keyword.Kind == SyntaxKind.RecordKeyword)\n            {\n                _termState |= TerminatorState.IsEndOfRecordSignature;\n            } 259811"];
9209 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259812"];
9210 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259813"];
9211 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 259814"];
9212 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 259815"];
9213 [label="this.CurrentToken 259816"];
9214 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259817"];
9215 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 259818"];
9216 [label="this.CurrentToken.ContextualKind 259819"];
9217 [label="get\n            {\n                return this.Kind;\n            } 259820"];
9218 [label="this.Kind 259821"];
9219 [label="get { return (SyntaxKind)this.RawKind; } 259822"];
9220 [label="return this.Kind; 259823"];
9221 [label="return false; 259824"];
9222 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259825"];
9223 [label="IsCurrentTokenQueryKeywordInQuery() 259826"];
9224 [label="param IsCurrentTokenQueryKeywordInQuery(this) 259827"];
9225 [label="this.IsInQuery 259828"];
9226 [label="get { return _syntaxFactoryContext.IsInQuery; } 259829"];
9227 [label="return _syntaxFactoryContext.IsInQuery; 259830"];
9228 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 259831"];
9229 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259832"];
9230 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259833"];
9231 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259834"];
9232 [label="MoveToNextToken(); 259835"];
9233 [label="this.IsInAsync 259836"];
9234 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 259837"];
9235 [label="keyword.Kind 259838"];
9236 [label="get { return (SyntaxKind)this.RawKind; } 259839"];
9237 [label="var paramList = keyword.Kind == SyntaxKind.RecordKeyword && CurrentToken.Kind == SyntaxKind.OpenParenToken\n                ? ParseParenthesizedParameterList() : null; 259840"];
9238 [label="keyword.Kind == SyntaxKind.RecordKeyword && CurrentToken.Kind == SyntaxKind.OpenParenToken 259841"];
9239 [label="param ParseBaseList(SyntaxToken typeKeyword) 259842"];
9240 [label="param ParseBaseList(bool haveParameters) 259843"];
9241 [label="this.EatToken() 259844"];
9242 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259845"];
9243 [label="param GetTrailingTrivia(this) 259846"];
9244 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259847"];
9245 [label="_tokenOffset 259848"];
9246 [label="MoveToNextToken(); 259849"];
9247 [label="var colon = this.EatToken(); 259850"];
9248 [label="var list = _pool.AllocateSeparated<BaseTypeSyntax>(); 259851"];
9249 [label="TypeSyntax firstType = this.ParseType(); 259852"];
9250 [label="this.ParseType() 259853"];
9251 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 259854"];
9252 [label="param ParseType(this) 259855"];
9253 [label="this.CurrentToken 259856"];
9254 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259857"];
9255 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259858"];
9256 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 259859"];
9257 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 259860"];
9258 [label="this.CurrentToken.Kind 259861"];
9259 [label="get { return (SyntaxKind)this.RawKind; } 259862"];
9260 [label="return ParseTypeCore(mode); 259863"];
9261 [label="return ParseTypeCore(mode); 259864"];
9262 [label="return ParseTypeCore(mode); 259865"];
9263 [label="param ParseUnderlyingType(ParseTypeMode mode) 259866"];
9264 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 259867"];
9265 [label="param ParseUnderlyingType(this) 259868"];
9266 [label="this.CurrentToken 259869"];
9267 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259870"];
9268 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 259871"];
9269 [label="this.CurrentToken.Kind 259872"];
9270 [label="get { return (SyntaxKind)this.RawKind; } 259873"];
9271 [label="IsPredefinedType(this.CurrentToken.Kind) 259874"];
9272 [label="param IsPredefinedType(SyntaxKind keyword) 259875"];
9273 [label="return SyntaxFacts.IsPredefinedType(keyword); 259876"];
9274 [label="SyntaxFacts.IsPredefinedType(keyword) 259877"];
9275 [label="param IsPredefinedType(SyntaxKind kind) 259878"];
9276 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 259879"];
9277 [label="return false; 259880"];
9278 [label="IsTrueIdentifier() 259881"];
9279 [label="param IsTrueIdentifier(this) 259882"];
9280 [label="this.CurrentToken 259883"];
9281 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259884"];
9282 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 259885"];
9283 [label="this.CurrentToken.Kind 259886"];
9284 [label="get { return (SyntaxKind)this.RawKind; } 259887"];
9285 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 259888"];
9286 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 259889"];
9287 [label="this.CurrentToken 259890"];
9288 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259891"];
9289 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 259892"];
9290 [label="this.CurrentToken.ContextualKind 259893"];
9291 [label="get\n            {\n                return this.Kind;\n            } 259894"];
9292 [label="this.Kind 259895"];
9293 [label="get { return (SyntaxKind)this.RawKind; } 259896"];
9294 [label="return this.Kind; 259897"];
9295 [label="return false; 259898"];
9296 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 259899"];
9297 [label="IsCurrentTokenQueryKeywordInQuery() 259900"];
9298 [label="param IsCurrentTokenQueryKeywordInQuery(this) 259901"];
9299 [label="this.IsInQuery 259902"];
9300 [label="get { return _syntaxFactoryContext.IsInQuery; } 259903"];
9301 [label="return _syntaxFactoryContext.IsInQuery; 259904"];
9302 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 259905"];
9303 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 259906"];
9304 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 259907"];
9305 [label="IsCurrentTokenWhereOfConstraintClause() 259908"];
9306 [label="param IsCurrentTokenWhereOfConstraintClause(this) 259909"];
9307 [label="this.CurrentToken 259910"];
9308 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259911"];
9309 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 259912"];
9310 [label="this.CurrentToken.ContextualKind 259913"];
9311 [label="get\n            {\n                return this.Kind;\n            } 259914"];
9312 [label="this.Kind 259915"];
9313 [label="get { return (SyntaxKind)this.RawKind; } 259916"];
9314 [label="return this.Kind; 259917"];
9315 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 259918"];
9316 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 259919"];
9317 [label="return true; 259920"];
9318 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 259921"];
9319 [label="return this.ParseQualifiedName(options); 259922"];
9320 [label="this.ParseQualifiedName(options) 259923"];
9321 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 259924"];
9322 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 259925"];
9323 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 259926"];
9324 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 259927"];
9325 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 259928"];
9326 [label="var id = this.ParseIdentifierName(); 259929"];
9327 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259930"];
9328 [label="this.IsIncrementalAndFactoryContextMatches 259931"];
9329 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 259932"];
9330 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 259933"];
9331 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 259934"];
9332 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 259935"];
9333 [label="this.CurrentToken 259936"];
9334 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259937"];
9335 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 259938"];
9336 [label="this.CurrentToken.ContextualKind 259939"];
9337 [label="get\n            {\n                return this.Kind;\n            } 259940"];
9338 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259941"];
9339 [label="IsCurrentTokenQueryKeywordInQuery() 259942"];
9340 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259943"];
9341 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 259944"];
9342 [label="param GetTrailingTrivia(this) 259945"];
9343 [label="return null; 259946"];
9344 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 259947"];
9345 [label="MoveToNextToken(); 259948"];
9346 [label="this.IsInAsync 259949"];
9347 [label="return _syntaxFactoryContext.IsInAsync; 259950"];
9348 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 259951"];
9349 [label="var id = this.ParseIdentifierName(); 259952"];
9350 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 259953"];
9351 [label="SimpleNameSyntax name = id; 259954"];
9352 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 259955"];
9353 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 259956"];
9354 [label="this.CurrentToken.Kind 259957"];
9355 [label="get { return (SyntaxKind)this.RawKind; } 259958"];
9356 [label="return name; 259959"];
9357 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 259960"];
9358 [label="this.CurrentToken 259961"];
9359 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259962"];
9360 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 259963"];
9361 [label="this.CurrentToken.Kind 259964"];
9362 [label="get { return (SyntaxKind)this.RawKind; } 259965"];
9363 [label="return name; 259966"];
9364 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 259967"];
9365 [label="this.IsDotOrColonColon() 259968"];
9366 [label="param IsDotOrColonColon(this) 259969"];
9367 [label="this.CurrentToken 259970"];
9368 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259971"];
9369 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259972"];
9370 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259973"];
9371 [label="this.CurrentToken.Kind 259974"];
9372 [label="get { return (SyntaxKind)this.RawKind; } 259975"];
9373 [label="this.CurrentToken 259976"];
9374 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 259977"];
9375 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259978"];
9376 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259979"];
9377 [label="this.CurrentToken.Kind 259980"];
9378 [label="get { return (SyntaxKind)this.RawKind; } 259981"];
9379 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 259982"];
9380 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259983"];
9381 [label="this.CurrentToken 259984"];
9382 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 259985"];
9383 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259986"];
9384 [label="this.CurrentToken.Kind 259987"];
9385 [label="get { return (SyntaxKind)this.RawKind; } 259988"];
9386 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 259989"];
9387 [label="return name; 259990"];
9388 [label="return this.ParseQualifiedName(options); 259991"];
9389 [label="param IsMakingProgress(ref int lastTokenPosition) 259992"];
9390 [label="param IsMakingProgress(bool assertIfFalse = true) 259993"];
9391 [label="param IsMakingProgress(this) 259994"];
9392 [label="CurrentTokenPosition 259995"];
9393 [label="=> _firstToken + _tokenOffset 259996"];
9394 [label="_firstToken + _tokenOffset 259997"];
9395 [label="var pos = CurrentTokenPosition; 259998"];
9396 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 259999"];
9397 [label="lastTokenPosition = pos; 260000"];
9398 [label="return true; 260001"];
9399 [label="return ParseTypeCore(mode); 260002"];
9400 [label="param ParseArrayRankSpecifier(out bool sawNonOmittedSize) 260003"];
9401 [label="param ParseArrayRankSpecifier(this) 260004"];
9402 [label="sawNonOmittedSize = false; 260005"];
9403 [label="bool sawOmittedSize = false; 260006"];
9404 [label="var open = this.EatToken(SyntaxKind.OpenBracketToken); 260007"];
9405 [label="this.EatToken(SyntaxKind.OpenBracketToken) 260008"];
9406 [label="param EatToken(SyntaxKind kind) 260009"];
9407 [label="param EatToken(this) 260010"];
9408 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 260011"];
9409 [label="SyntaxFacts.IsAnyToken(kind) 260012"];
9410 [label="param IsAnyToken(SyntaxKind kind) 260013"];
9411 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 260014"];
9412 [label="return true; 260015"];
9413 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 260016"];
9414 [label="param GetTrailingTrivia(this) 260017"];
9415 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 260018"];
9416 [label="MoveToNextToken(); 260019"];
9417 [label="var list = _pool.AllocateSeparated<ExpressionSyntax>(); 260020"];
9418 [label="var omittedArraySizeExpressionInstance = _syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken)); 260021"];
9419 [label="SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken) 260022"];
9420 [label="param Token(SyntaxKind kind) 260023"];
9421 [label="return SyntaxToken.Create(kind); 260024"];
9422 [label="SyntaxToken.Create(kind) 260025"];
9423 [label="param Create(SyntaxKind kind) 260026"];
9424 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, null, null);\n            } 260027"];
9425 [label="return s_tokensWithNoTrivia[(int)kind].Value; 260028"];
9426 [label="var omittedArraySizeExpressionInstance = _syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken)); 260029"];
9427 [label="var omittedArraySizeExpressionInstance = _syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken)); 260030"];
9428 [label="param TryGetNode(int kind) 260031"];
9429 [label="param TryGetNode(GreenNode child1) 260032"];
9430 [label="param TryGetNode(SyntaxFactoryContext context) 260033"];
9431 [label="param TryGetNode(out int hash) 260034"];
9432 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260035"];
9433 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260036"];
9434 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260037"];
9435 [label="GetNodeFlags(context) 260038"];
9436 [label="param GetNodeFlags(SyntaxFactoryContext context) 260039"];
9437 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 260040"];
9438 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 260041"];
9439 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 260042"];
9440 [label="return flags; 260043"];
9441 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260044"];
9442 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260045"];
9443 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260046"];
9444 [label="param SetFactoryContext(SyntaxFactoryContext context) 260047"];
9445 [label="param SetFactoryContext(this) 260048"];
9446 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260049"];
9447 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260050"];
9448 [label="int lastTokenPosition = -1; 260051"];
9449 [label="while (IsMakingProgress(ref lastTokenPosition) && this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpressionCore();\n                        sawNonOmittedSize = true;\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                } 260052"];
9450 [label="while (IsMakingProgress(ref lastTokenPosition) && this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpressionCore();\n                        sawNonOmittedSize = true;\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                } 260053"];
9451 [label="IsMakingProgress(ref lastTokenPosition) 260054"];
9452 [label="param IsMakingProgress(ref int lastTokenPosition) 260055"];
9453 [label="param IsMakingProgress(bool assertIfFalse = true) 260056"];
9454 [label="param IsMakingProgress(this) 260057"];
9455 [label="CurrentTokenPosition 260058"];
9456 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 260059"];
9457 [label="return true; 260060"];
9458 [label="this.CurrentToken 260061"];
9459 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 260062"];
9460 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 260063"];
9461 [label="while (IsMakingProgress(ref lastTokenPosition) && this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpressionCore();\n                        sawNonOmittedSize = true;\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                } 260064"];
9462 [label="this.CurrentToken.Kind 260065"];
9463 [label="get { return (SyntaxKind)this.RawKind; } 260066"];
9464 [label="while (IsMakingProgress(ref lastTokenPosition) && this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                    {\n                        // NOTE: trivia will be attached to comma, not omitted array size\n                        sawOmittedSize = true;\n                        list.Add(omittedArraySizeExpressionInstance);\n                        list.AddSeparator(this.EatToken());\n                    }\n                    else if (this.IsPossibleExpression())\n                    {\n                        var size = this.ParseExpressionCore();\n                        sawNonOmittedSize = true;\n                        list.Add(size);\n\n                        if (this.CurrentToken.Kind != SyntaxKind.CloseBracketToken)\n                        {\n                            list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        }\n                    }\n                    else if (this.SkipBadArrayRankSpecifierTokens(ref open, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                } 260067"];
9465 [label="if (((list.Count & 1) == 0))\n                {\n                    sawOmittedSize = true;\n                    list.Add(omittedArraySizeExpressionInstance);\n                } 260068"];
9466 [label="if (((list.Count & 1) == 0))\n                {\n                    sawOmittedSize = true;\n                    list.Add(omittedArraySizeExpressionInstance);\n                } 260069"];
9467 [label="sawOmittedSize = true; 260070"];
9468 [label="list.Add(omittedArraySizeExpressionInstance); 260071"];
9469 [label="if (sawOmittedSize && sawNonOmittedSize)\n                {\n                    for (int i = 0; i < list.Count; i++)\n                    {\n                        if (list[i].RawKind == (int)SyntaxKind.OmittedArraySizeExpression)\n                        {\n                            int width = list[i].Width;\n                            int offset = list[i].GetLeadingTriviaWidth();\n                            list[i] = this.AddError(this.CreateMissingIdentifierName(), offset, width, ErrorCode.ERR_ValueExpected);\n                        }\n                    }\n                } 260072"];
9470 [label="var close = this.EatToken(SyntaxKind.CloseBracketToken); 260073"];
9471 [label="this.EatToken(SyntaxKind.CloseBracketToken) 260074"];
9472 [label="param EatToken(SyntaxKind kind) 260075"];
9473 [label="param EatToken(this) 260076"];
9474 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 260077"];
9475 [label="SyntaxFacts.IsAnyToken(kind) 260078"];
9476 [label="param IsAnyToken(SyntaxKind kind) 260079"];
9477 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 260080"];
9478 [label="return true; 260081"];
9479 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 260082"];
9480 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 260083"];
9481 [label="MoveToNextToken(); 260084"];
9482 [label="return _syntaxFactory.ArrayRankSpecifier(open, list, close); 260085"];
9483 [label="return _syntaxFactory.ArrayRankSpecifier(open, list, close); 260086"];
9484 [label="return _syntaxFactory.ArrayRankSpecifier(open, list, close); 260087"];
9485 [label="return _syntaxFactory.ArrayRankSpecifier(open, list, close); 260088"];
9486 [label="return _syntaxFactory.ArrayRankSpecifier(open, list, close); 260089"];
9487 [label="param TryGetNode(int kind) 260090"];
9488 [label="param TryGetNode(GreenNode child1) 260091"];
9489 [label="param TryGetNode(GreenNode child2) 260092"];
9490 [label="param TryGetNode(GreenNode child3) 260093"];
9491 [label="param TryGetNode(SyntaxFactoryContext context) 260094"];
9492 [label="param TryGetNode(out int hash) 260095"];
9493 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260096"];
9494 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260097"];
9495 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260098"];
9496 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260099"];
9497 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260100"];
9498 [label="GetNodeFlags(context) 260101"];
9499 [label="param GetNodeFlags(SyntaxFactoryContext context) 260102"];
9500 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 260103"];
9501 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 260104"];
9502 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 260105"];
9503 [label="return flags; 260106"];
9504 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260107"];
9505 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260108"];
9506 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 260109"];
9507 [label="param SetFactoryContext(SyntaxFactoryContext context) 260110"];
9508 [label="param SetFactoryContext(this) 260111"];
9509 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260112"];
9510 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260113"];
9511 [label="_pool.Free(list); 260114"];
9512 [label="_pool.Free(list); 260115"];
9513 [label="return ParseTypeCore(mode); 260116"];
9514 [label="param FetchCurrentToken(this) 260117"];
9515 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 260118"];
9516 [label="param TryGetNode(int kind) 260119"];
9517 [label="param TryGetNode(GreenNode child1) 260120"];
9518 [label="param TryGetNode(GreenNode child2) 260121"];
9519 [label="param TryGetNode(SyntaxFactoryContext context) 260122"];
9520 [label="param TryGetNode(out int hash) 260123"];
9521 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260124"];
9522 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260125"];
9523 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260126"];
9524 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260127"];
9525 [label="GetNodeFlags(context) 260128"];
9526 [label="param GetNodeFlags(SyntaxFactoryContext context) 260129"];
9527 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 260130"];
9528 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 260131"];
9529 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 260132"];
9530 [label="return flags; 260133"];
9531 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260134"];
9532 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260135"];
9533 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260136"];
9534 [label="param CSharpSyntaxNode(this) 260137"];
9535 [label="param SetFactoryContext(SyntaxFactoryContext context) 260138"];
9536 [label="param SetFactoryContext(this) 260139"];
9537 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260140"];
9538 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260141"];
9539 [label="param IsMakingProgress(ref int lastTokenPosition) 260142"];
9540 [label="param IsMakingProgress(bool assertIfFalse = true) 260143"];
9541 [label="param IsMakingProgress(this) 260144"];
9542 [label="=> _firstToken + _tokenOffset 260145"];
9543 [label="_firstToken + _tokenOffset 260146"];
9544 [label="var pos = CurrentTokenPosition; 260147"];
9545 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 260148"];
9546 [label="lastTokenPosition = pos; 260149"];
9547 [label="return true; 260150"];
9548 [label="return ParseTypeCore(mode); 260151"];
9549 [label="return ParseTypeCore(mode); 260152"];
9550 [label="ArgumentListSyntax argumentList = null; 260153"];
9551 [label="this.CurrentToken 260154"];
9552 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 260155"];
9553 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenParenToken)\n                {\n                    argumentList = this.ParseParenthesizedArgumentList();\n\n                    if (typeKeyword.Kind != SyntaxKind.RecordKeyword || !haveParameters)\n                    {\n                        argumentList = this.AddErrorToFirstToken(argumentList, ErrorCode.ERR_UnexpectedArgumentList);\n                    }\n                } 260156"];
9554 [label="this.CurrentToken.Kind 260157"];
9555 [label="get { return (SyntaxKind)this.RawKind; } 260158"];
9556 [label="argumentList is object 260159"];
9557 [label="list.Add(argumentList is object ? _syntaxFactory.PrimaryConstructorBaseType(firstType, argumentList) : (BaseTypeSyntax)_syntaxFactory.SimpleBaseType(firstType)); 260160"];
9558 [label="list.Add(argumentList is object ? _syntaxFactory.PrimaryConstructorBaseType(firstType, argumentList) : (BaseTypeSyntax)_syntaxFactory.SimpleBaseType(firstType)); 260161"];
9559 [label="param TryGetNode(SyntaxFactoryContext context) 260162"];
9560 [label="GetNodeFlags(context) 260163"];
9561 [label="param GetNodeFlags(SyntaxFactoryContext context) 260164"];
9562 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 260165"];
9563 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 260166"];
9564 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 260167"];
9565 [label="return flags; 260168"];
9566 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 260169"];
9567 [label="param SetFactoryContext(SyntaxFactoryContext context) 260170"];
9568 [label="param SetFactoryContext(this) 260171"];
9569 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260172"];
9570 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260173"];
9571 [label="while (true)\n                {\n                    if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken ||\n                        ((_termState & TerminatorState.IsEndOfRecordSignature) != 0 && this.CurrentToken.Kind == SyntaxKind.SemicolonToken) ||\n                        this.IsCurrentTokenWhereOfConstraintClause())\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                    {\n                        list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        list.Add(_syntaxFactory.SimpleBaseType(this.ParseType()));\n                        continue;\n                    }\n                    else if (this.SkipBadBaseListTokens(ref colon, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    }\n                } 260174"];
9572 [label="this.CurrentToken 260175"];
9573 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 260176"];
9574 [label="if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken ||\n                        ((_termState & TerminatorState.IsEndOfRecordSignature) != 0 && this.CurrentToken.Kind == SyntaxKind.SemicolonToken) ||\n                        this.IsCurrentTokenWhereOfConstraintClause())\n                    {\n                        break;\n                    }\n                    else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.IsPossibleType())\n                    {\n                        list.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                        list.Add(_syntaxFactory.SimpleBaseType(this.ParseType()));\n                        continue;\n                    }\n                    else if (this.SkipBadBaseListTokens(ref colon, list, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                    {\n                        break;\n                    } 260177"];
9575 [label="this.CurrentToken.Kind 260178"];
9576 [label="get { return (SyntaxKind)this.RawKind; } 260179"];
9577 [label="return _syntaxFactory.BaseList(colon, list); 260180"];
9578 [label="return _syntaxFactory.BaseList(colon, list); 260181"];
9579 [label="return _syntaxFactory.BaseList(colon, list); 260182"];
9580 [label="return _syntaxFactory.BaseList(colon, list); 260183"];
9581 [label="param TryGetNode(SyntaxFactoryContext context) 260184"];
9582 [label="GetNodeFlags(context) 260185"];
9583 [label="param GetNodeFlags(SyntaxFactoryContext context) 260186"];
9584 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 260187"];
9585 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 260188"];
9586 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 260189"];
9587 [label="return flags; 260190"];
9588 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 260191"];
9589 [label="param SetFactoryContext(SyntaxFactoryContext context) 260192"];
9590 [label="param SetFactoryContext(this) 260193"];
9591 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260194"];
9592 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260195"];
9593 [label="_pool.Free(list); 260196"];
9594 [label="_pool.Free(list); 260197"];
9595 [label="SyntaxListBuilder<MemberDeclarationSyntax> members = default(SyntaxListBuilder<MemberDeclarationSyntax>); 260198"];
9596 [label="this.CurrentToken 260199"];
9597 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 260200"];
9598 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword)\n                {\n                    constraints = _pool.Allocate<TypeParameterConstraintClauseSyntax>();\n                    this.ParseTypeParameterConstraintClauses(constraints);\n                } 260201"];
9599 [label="this.CurrentToken.ContextualKind 260202"];
9600 [label="get\n            {\n                return this.Kind;\n            } 260203"];
9601 [label="this.Kind 260204"];
9602 [label="SyntaxToken semicolon; 260205"];
9603 [label="SyntaxToken? openBrace; 260206"];
9604 [label="SyntaxToken? closeBrace; 260207"];
9605 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 260208"];
9606 [label="SyntaxFacts.IsAnyToken(kind) 260209"];
9607 [label="param IsAnyToken(SyntaxKind kind) 260210"];
9608 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 260211"];
9609 [label="return true; 260212"];
9610 [label="param GetTrailingTrivia(this) 260213"];
9611 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 260214"];
9612 [label="MoveToNextToken(); 260215"];
9613 [label="if (name.IsMissing || openBrace.IsMissing)\n                    {\n                        parseMembers = false;\n                    } 260216"];
9614 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 260217"];
9615 [label="SyntaxKind kind = this.CurrentToken.Kind; 260218"];
9616 [label="this.CurrentToken.Kind 260219"];
9617 [label="get { return (SyntaxKind)this.RawKind; } 260220"];
9618 [label="if (CanStartMember(kind))\n                            {\n                                // This token can start a member -- go parse it\n                                var saveTerm2 = _termState;\n                                _termState |= TerminatorState.IsPossibleMemberStartOrStop;\n\n                                var member = this.ParseMemberDeclaration(keyword.Kind);\n                                if (member != null)\n                                {\n                                    // statements are accepted here, a semantic error will be reported later\n                                    members.Add(member);\n                                }\n                                else\n                                {\n                                    // we get here if we couldn't parse the lookahead as a statement or a declaration (we haven't consumed any tokens):\n                                    this.SkipBadMemberListTokens(ref openBrace, members);\n                                }\n\n                                _termState = saveTerm2;\n                            }\n                            else if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            } 260221"];
9619 [label="CanStartMember(kind) 260222"];
9620 [label="param CanStartMember(SyntaxKind kind) 260223"];
9621 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ClassKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.DelegateKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.EnumKeyword:\n                case SyntaxKind.EventKeyword:\n                case SyntaxKind.ExternKeyword:\n                case SyntaxKind.FixedKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.InterfaceKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.NewKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.OverrideKeyword:\n                case SyntaxKind.PrivateKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.SealedKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.StructKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.VirtualKeyword:\n                case SyntaxKind.VoidKeyword:\n                case SyntaxKind.VolatileKeyword:\n                case SyntaxKind.IdentifierToken:\n                case SyntaxKind.TildeToken:\n                case SyntaxKind.OpenBracketToken:\n                case SyntaxKind.ImplicitKeyword:\n                case SyntaxKind.ExplicitKeyword:\n                case SyntaxKind.OpenParenToken:    //tuple\n                case SyntaxKind.RefKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 260224"];
9622 [label="return false; 260225"];
9623 [label="if (kind == SyntaxKind.CloseBraceToken || kind == SyntaxKind.EndOfFileToken || this.IsTerminator())\n                            {\n                                // This marks the end of members of this class\n                                break;\n                            }\n                            else\n                            {\n                                // Error -- try to sync up with intended reality\n                                this.SkipBadMemberListTokens(ref openBrace, members);\n                            } 260226"];
9624 [label="RoslynDebug.Assert(paramList is null); 260227"];
9625 [label="RoslynDebug.Assert(openBrace != null); 260228"];
9626 [label="RoslynDebug.Assert(closeBrace != null); 260229"];
9627 [label="param SetFactoryContext(SyntaxFactoryContext context) 260230"];
9628 [label="param SetFactoryContext(this) 260231"];
9629 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260232"];
9630 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260233"];
9631 [label="if (!constraints.IsNull)\n                {\n                    _pool.Free(constraints);\n                } 260234"];
9632 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 260235"];
9633 [label="var closeBrace = this.EatToken(SyntaxKind.CloseBraceToken); 260236"];
9634 [label="this.EatToken(SyntaxKind.CloseBraceToken) 260237"];
9635 [label="param EatToken(SyntaxKind kind) 260238"];
9636 [label="param EatToken(this) 260239"];
9637 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 260240"];
9638 [label="SyntaxFacts.IsAnyToken(kind) 260241"];
9639 [label="param IsAnyToken(SyntaxKind kind) 260242"];
9640 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 260243"];
9641 [label="return true; 260244"];
9642 [label="this.CurrentToken 260245"];
9643 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 260246"];
9644 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 260247"];
9645 [label="ct.Kind 260248"];
9646 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 260249"];
9647 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 260250"];
9648 [label="MoveToNextToken(); 260251"];
9649 [label="var semicolon = this.TryEatToken(SyntaxKind.SemicolonToken); 260252"];
9650 [label="this.TryEatToken(SyntaxKind.SemicolonToken) 260253"];
9651 [label="param TryEatToken(SyntaxKind kind) 260254"];
9652 [label="=> this.CurrentToken.Kind == kind ? this.EatToken() : null 260255"];
9653 [label="this.CurrentToken 260256"];
9654 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 260257"];
9655 [label="this.FetchCurrentToken() 260258"];
9656 [label="param FetchCurrentToken(this) 260259"];
9657 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 260260"];
9658 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 260261"];
9659 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 260262"];
9660 [label="return _lexedTokens[_tokenOffset]; 260263"];
9661 [label="this.CurrentToken.Kind 260264"];
9662 [label="this.CurrentToken.Kind == kind 260265"];
9663 [label="Debug.Assert(initialBadNodes == null); 260266"];
9664 [label="Debug.Assert(initialBadNodes == null); 260267"];
9665 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260268"];
9666 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260269"];
9667 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260270"];
9668 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260271"];
9669 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260272"];
9670 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260273"];
9671 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260274"];
9672 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260275"];
9673 [label="return _syntaxFactory.NamespaceDeclaration(\n                    attributeLists, modifiers.ToList(),\n                    namespaceToken, name, openBrace, body.Externs, body.Usings, body.Members, closeBrace, semicolon); 260276"];
9674 [label="param CSharpSyntaxNode(this) 260277"];
9675 [label="GreenStats.NoteGreen(this); 260278"];
9676 [label="param SetFactoryContext(SyntaxFactoryContext context) 260279"];
9677 [label="param SetFactoryContext(this) 260280"];
9678 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260281"];
9679 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260282"];
9680 [label="body.Free(_pool); 260283"];
9681 [label="body.Free(_pool) 260284"];
9682 [label="param Free(SyntaxListPool pool) 260285"];
9683 [label="param Free(this) 260286"];
9684 [label="pool.Free(Members); 260287"];
9685 [label="pool.Free(Members); 260288"];
9686 [label="pool.Free(Attributes); 260289"];
9687 [label="pool.Free(Attributes); 260290"];
9688 [label="pool.Free(Usings); 260291"];
9689 [label="pool.Free(Usings); 260292"];
9690 [label="pool.Free(Externs); 260293"];
9691 [label="pool.Free(Externs); 260294"];
9692 [label="body.Free(_pool); 260295"];
9693 [label="_recursionDepth 260296"];
9694 [label="return result; 260297"];
9695 [label="this.ParseNamespaceBody(ref tmp, ref body, ref initialBadNodes, SyntaxKind.CompilationUnit); 260298"];
9696 [label="get { return (SyntaxKind)this.RawKind; } 260299"];
9697 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 260300"];
9698 [label="param AddIncompleteMembers(ref SyntaxListBuilder<MemberDeclarationSyntax> incompleteMembers) 260301"];
9699 [label="if (incompleteMembers.Count > 0)\n            {\n                body.Members.AddRange(incompleteMembers);\n                incompleteMembers.Clear();\n            } 260302"];
9700 [label="var eof = this.EatToken(SyntaxKind.EndOfFileToken); 260303"];
9701 [label="this.EatToken(SyntaxKind.EndOfFileToken) 260304"];
9702 [label="param EatToken(SyntaxKind kind) 260305"];
9703 [label="param EatToken(this) 260306"];
9704 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 260307"];
9705 [label="SyntaxFacts.IsAnyToken(kind) 260308"];
9706 [label="param IsAnyToken(SyntaxKind kind) 260309"];
9707 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 260310"];
9708 [label="return true; 260311"];
9709 [label="this.CurrentToken 260312"];
9710 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 260313"];
9711 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 260314"];
9712 [label="ct.Kind 260315"];
9713 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 260316"];
9714 [label="param GetTrailingTrivia(this) 260317"];
9715 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 260318"];
9716 [label="MoveToNextToken(); 260319"];
9717 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 260320"];
9718 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 260321"];
9719 [label="var result = _syntaxFactory.CompilationUnit(body.Externs, body.Usings, body.Attributes, body.Members, eof); 260322"];
9720 [label="param CSharpSyntaxNode(this) 260323"];
9721 [label="GreenStats.NoteGreen(this); 260324"];
9722 [label="param SetFactoryContext(SyntaxFactoryContext context) 260325"];
9723 [label="param SetFactoryContext(this) 260326"];
9724 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 260327"];
9725 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 260328"];
9726 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 260329"];
9727 [label="if (initialBadNodes != null)\n                {\n                    // attach initial bad nodes as leading trivia on first token\n                    result = AddLeadingSkippedSyntax(result, initialBadNodes.ToListNode());\n                    _pool.Free(initialBadNodes);\n                } 260330"];
9728 [label="return result; 260331"];
9729 [label="body.Free(_pool); 260332"];
9730 [label="body.Free(_pool) 260333"];
9731 [label="param Free(SyntaxListPool pool) 260334"];
9732 [label="param Free(this) 260335"];
9733 [label="body.Free(_pool); 260336"];
9734 [label="return parseFunc(); 260337"];
9735 [label="var compilationUnit = (CompilationUnitSyntax)parser.ParseCompilationUnit().CreateRed(); 260338"];
9736 [label="var compilationUnit = (CompilationUnitSyntax)parser.ParseCompilationUnit().CreateRed(); 260339"];
9737 [label="param CSharpSyntaxNode(GreenNode green) 260340"];
9738 [label="param CSharpSyntaxNode(SyntaxNode? parent) 260341"];
9739 [label="param CSharpSyntaxNode(int position) 260342"];
9740 [label="param CSharpSyntaxNode(this) 260343"];
9741 [label="green 260344"];
9742 [label="parent 260345"];
9743 [label="position 260346"];
9744 [label="param CSharpSyntaxNode(this) 260347"];
9745 [label="param CSharpSyntaxNode(this) 260348"];
9746 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260349"];
9747 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260350"];
9748 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260351"];
9749 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260352"];
9750 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260353"];
9751 [label="parser.Directives 260354"];
9752 [label="get { return lexer.Directives; } 260355"];
9753 [label="lexer.Directives 260356"];
9754 [label="get { return _directives; } 260357"];
9755 [label="return _directives; 260358"];
9756 [label="return lexer.Directives; 260359"];
9757 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260360"];
9758 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260361"];
9759 [label="var tree = new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true); 260362"];
9760 [label="new ParsedSyntaxTree(\n                text,\n                text.Encoding,\n                text.ChecksumAlgorithm,\n                path,\n                options,\n                compilationUnit,\n                parser.Directives,\n                diagnosticOptions: diagnosticOptions,\n                cloneRoot: true) 260363"];
9761 [label="param ParsedSyntaxTree(SourceText? textOpt) 260364"];
9762 [label="param ParsedSyntaxTree(Encoding? encodingOpt) 260365"];
9763 [label="param ParsedSyntaxTree(SourceHashAlgorithm checksumAlgorithm) 260366"];
9764 [label="param ParsedSyntaxTree(string path) 260367"];
9765 [label="param ParsedSyntaxTree(CSharpParseOptions options) 260368"];
9766 [label="param ParsedSyntaxTree(CSharpSyntaxNode root) 260369"];
9767 [label="param ParsedSyntaxTree(Syntax.InternalSyntax.DirectiveStack directives) 260370"];
9768 [label="param ParsedSyntaxTree(ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions) 260371"];
9769 [label="param ParsedSyntaxTree(bool cloneRoot) 260372"];
9770 [label="param ParsedSyntaxTree(this) 260373"];
9771 [label="param ParsedSyntaxTree(this) 260374"];
9772 [label="param CSharpSyntaxTree(this) 260375"];
9773 [label="param CSharpSyntaxTree(this) 260376"];
9774 [label="_hasDirectives 260377"];
9775 [label="_lazyLineDirectiveMap 260378"];
9776 [label="_lazyPragmaWarningStateMap 260379"];
9777 [label="_lazyNullableContextStateMap 260380"];
9778 [label="_lazyIsGeneratedCode = GeneratedKind.Unknown 260381"];
9779 [label="_options 260382"];
9780 [label="_path 260383"];
9781 [label="_root 260384"];
9782 [label="_hasCompilationUnitRoot 260385"];
9783 [label="_encodingOpt 260386"];
9784 [label="_checksumAlgorithm 260387"];
9785 [label="_diagnosticOptions 260388"];
9786 [label="_lazyText 260389"];
9787 [label="Debug.Assert(root != null); 260390"];
9788 [label="Debug.Assert(root != null); 260391"];
9789 [label="Debug.Assert(options != null); 260392"];
9790 [label="Debug.Assert(options != null); 260393"];
9791 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 260394"];
9792 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 260395"];
9793 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 260396"];
9794 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 260397"];
9795 [label="Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm); 260398"];
9796 [label="_lazyText 260399"];
9797 [label="_encodingOpt = encodingOpt ?? textOpt?.Encoding; 260400"];
9798 [label="_encodingOpt 260401"];
9799 [label="_checksumAlgorithm 260402"];
9800 [label="_options 260403"];
9801 [label="_path = path ?? string.Empty; 260404"];
9802 [label="_path 260405"];
9803 [label="cloneRoot 260406"];
9804 [label="_root = cloneRoot ? this.CloneNodeAsRoot(root) : root; 260407"];
9805 [label="this.CloneNodeAsRoot(root) 260408"];
9806 [label="param CloneNodeAsRoot(T node) 260409"];
9807 [label="param CloneNodeAsRoot(this) 260410"];
9808 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 260411"];
9809 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 260412"];
9810 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 260413"];
9811 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 260414"];
9812 [label="return CSharpSyntaxNode.CloneNodeAsRoot(node, this); 260415"];
9813 [label="param CSharpSyntaxNode(this) 260416"];
9814 [label="_root 260417"];
9815 [label="root.Kind() 260418"];
9816 [label="param Kind(this) 260419"];
9817 [label="return (SyntaxKind)this.Green.RawKind; 260420"];
9818 [label="_hasCompilationUnitRoot = root.Kind() == SyntaxKind.CompilationUnit; 260421"];
9819 [label="_hasCompilationUnitRoot 260422"];
9820 [label="_diagnosticOptions = diagnosticOptions ?? EmptyDiagnosticOptions; 260423"];
9821 [label="_diagnosticOptions = diagnosticOptions ?? EmptyDiagnosticOptions; 260424"];
9822 [label="_diagnosticOptions 260425"];
9823 [label="this.SetDirectiveStack(directives); 260426"];
9824 [label="this.SetDirectiveStack(directives) 260427"];
9825 [label="param SetDirectiveStack(InternalSyntax.DirectiveStack directives) 260428"];
9826 [label="param SetDirectiveStack(this) 260429"];
9827 [label="_directives 260430"];
9828 [label="_hasDirectives = true; 260431"];
9829 [label="_hasDirectives 260432"];
9830 [label="this.SetDirectiveStack(directives); 260433"];
9831 [label="tree.VerifySource(); 260434"];
9832 [label="tree.VerifySource(); 260435"];
9833 [label="tree.VerifySource(); 260436"];
9834 [label="param GetRootCore(CancellationToken cancellationToken) 260437"];
9835 [label="param GetRootCore(this) 260438"];
9836 [label="return this.GetRoot(cancellationToken); 260439"];
9837 [label="this.GetRoot(cancellationToken) 260440"];
9838 [label="param GetRoot(CancellationToken cancellationToken) 260441"];
9839 [label="param GetRoot(this) 260442"];
9840 [label="return _root; 260443"];
9841 [label="return this.GetRoot(cancellationToken); 260444"];
9842 [label="param GetText(CancellationToken cancellationToken) 260445"];
9843 [label="param GetText(this) 260446"];
9844 [label="if (_lazyText == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyText, this.GetRoot(cancellationToken).GetText(_encodingOpt, _checksumAlgorithm), null);\n                } 260447"];
9845 [label="if (_lazyText == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyText, this.GetRoot(cancellationToken).GetText(_encodingOpt, _checksumAlgorithm), null);\n                } 260448"];
9846 [label="return _lazyText; 260449"];
9847 [label="=> true 260450"];
9848 [label="true 260451"];
9849 [label="tree.VerifySource(); 260452"];
9850 [label="param WriteTokenTo(System.IO.TextWriter writer) 260453"];
9851 [label="param WriteTokenTo(bool leading) 260454"];
9852 [label="param WriteTokenTo(bool trailing) 260455"];
9853 [label="param WriteTokenTo(this) 260456"];
9854 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 260457"];
9855 [label="this.GetLeadingTrivia() 260458"];
9856 [label="param GetLeadingTrivia(this) 260459"];
9857 [label="return this.LeadingField; 260460"];
9858 [label="var trivia = this.GetLeadingTrivia(); 260461"];
9859 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260462"];
9860 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260463"];
9861 [label="trivia.WriteTo(writer, true, true); 260464"];
9862 [label="trivia.WriteTo(writer, true, true); 260465"];
9863 [label="=> true 260466"];
9864 [label="true 260467"];
9865 [label="trivia.WriteTo(writer, true, true); 260468"];
9866 [label="param WriteTriviaTo(System.IO.TextWriter writer) 260469"];
9867 [label="param WriteTriviaTo(this) 260470"];
9868 [label="writer.Write(Text); 260471"];
9869 [label="writer.Write(Text); 260472"];
9870 [label="this.Text 260473"];
9871 [label="get { return SyntaxFacts.GetText(this.Kind); } 260474"];
9872 [label="this.Kind 260475"];
9873 [label="return (SyntaxKind)this.RawKind; 260476"];
9874 [label="SyntaxFacts.GetText(this.Kind) 260477"];
9875 [label="writer.Write(this.Text); 260478"];
9876 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 260479"];
9877 [label="this.GetTrailingTrivia() 260480"];
9878 [label="param GetTrailingTrivia(this) 260481"];
9879 [label="return this.TrailingField; 260482"];
9880 [label="var trivia = this.GetTrailingTrivia(); 260483"];
9881 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260484"];
9882 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260485"];
9883 [label="trivia.WriteTo(writer, true, true); 260486"];
9884 [label="trivia.WriteTo(writer, true, true); 260487"];
9885 [label="=> true 260488"];
9886 [label="param GetLeadingTrivia(this) 260489"];
9887 [label="return null; 260490"];
9888 [label="var trivia = this.GetLeadingTrivia(); 260491"];
9889 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260492"];
9890 [label="get { return this.TextField; } 260493"];
9891 [label="return this.TextField; 260494"];
9892 [label="param GetTrailingTrivia(this) 260495"];
9893 [label="=> true 260496"];
9894 [label="param GetTrailingTrivia(this) 260497"];
9895 [label="var trivia = this.GetTrailingTrivia(); 260498"];
9896 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 260499"];
9897 [label="return tree; 260500"];
9898 [label="return ParseText(text, options, path, diagnosticOptions: null, cancellationToken); 260501"];
9899 [label="return CSharpSyntaxTree.ParseText(text, (CSharpParseOptions?)options, path, cancellationToken); 260502"];
9900 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 260503"];
9901 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 260504"];
9902 [label="param CheckSerializable(SyntaxTree tree) 260505"];
9903 [label="var stream = new MemoryStream(); 260506"];
9904 [label="var root = tree.GetRoot(); 260507"];
9905 [label="var root = tree.GetRoot(); 260508"];
9906 [label="param GetRootCore(CancellationToken cancellationToken) 260509"];
9907 [label="this.GetRoot(cancellationToken) 260510"];
9908 [label="param GetRoot(CancellationToken cancellationToken) 260511"];
9909 [label="root.SerializeTo(stream); 260512"];
9910 [label="root.SerializeTo(stream); 260513"];
9911 [label="root.SerializeTo(stream); 260514"];
9912 [label="=> base.ShouldReuseInSerialization &&\n                                                             FullWidth < Lexer.MaxCachedTokenSize 260515"];
9913 [label="FullWidth < Lexer.MaxCachedTokenSize 260516"];
9914 [label="base.ShouldReuseInSerialization &&\n                                                             FullWidth < Lexer.MaxCachedTokenSize 260517"];
9915 [label="param WriteTo(ObjectWriter writer) 260518"];
9916 [label="param WriteTo(this) 260519"];
9917 [label="base.WriteTo(writer); 260520"];
9918 [label="base.WriteTo(writer); 260521"];
9919 [label="writer.WriteValue(this.LeadingField); 260522"];
9920 [label="writer.WriteValue(this.LeadingField); 260523"];
9921 [label="=> this.Kind == SyntaxKind.WhitespaceTrivia &&\n                                                             FullWidth < Lexer.MaxCachedTokenSize 260524"];
9922 [label="this.Kind 260525"];
9923 [label="get { return (SyntaxKind)this.RawKind; } 260526"];
9924 [label="this.Kind == SyntaxKind.WhitespaceTrivia 260527"];
9925 [label="this.Kind == SyntaxKind.WhitespaceTrivia &&\n                                                             FullWidth < Lexer.MaxCachedTokenSize 260528"];
9926 [label="param WriteTo(ObjectWriter writer) 260529"];
9927 [label="param WriteTo(this) 260530"];
9928 [label="base.WriteTo(writer); 260531"];
9929 [label="base.WriteTo(writer); 260532"];
9930 [label="writer.WriteString(this.Text); 260533"];
9931 [label="writer.WriteValue(this.TrailingField); 260534"];
9932 [label="writer.WriteValue(this.TrailingField); 260535"];
9933 [label="this.Kind 260536"];
9934 [label="FullWidth < Lexer.MaxCachedTokenSize 260537"];
9935 [label="param WriteTo(ObjectWriter writer) 260538"];
9936 [label="param WriteTo(this) 260539"];
9937 [label="base.WriteTo(writer); 260540"];
9938 [label="base.WriteTo(writer) 260541"];
9939 [label="param WriteTo(ObjectWriter writer) 260542"];
9940 [label="param WriteTo(this) 260543"];
9941 [label="base.WriteTo(writer); 260544"];
9942 [label="base.WriteTo(writer); 260545"];
9943 [label="writer.WriteString(this.TextField); 260546"];
9944 [label="base.WriteTo(writer); 260547"];
9945 [label="writer.WriteValue(_trailing); 260548"];
9946 [label="writer.WriteValue(_trailing); 260549"];
9947 [label="this.Kind 260550"];
9948 [label="param WriteTo(ObjectWriter writer) 260551"];
9949 [label="param WriteTo(this) 260552"];
9950 [label="base.WriteTo(writer); 260553"];
9951 [label="stream.Position = 0; 260554"];
9952 [label="stream.Position 260555"];
9953 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 260556"];
9954 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 260557"];
9955 [label="CSharpSyntaxNode.DeserializeFrom(stream) 260558"];
9956 [label="param DeserializeFrom(Stream stream) 260559"];
9957 [label="param DeserializeFrom(CancellationToken cancellationToken = default) 260560"];
9958 [label="if (stream == null)\n            {\n                throw new ArgumentNullException(nameof(stream));\n            } 260561"];
9959 [label="if (stream == null)\n            {\n                throw new ArgumentNullException(nameof(stream));\n            } 260562"];
9960 [label="if (!stream.CanRead)\n            {\n                throw new InvalidOperationException(CodeAnalysisResources.TheStreamCannotBeReadFrom);\n            } 260563"];
9961 [label="using var reader = ObjectReader.TryGetReader(stream, leaveOpen: true, cancellationToken); 260564"];
9962 [label="using var reader = ObjectReader.TryGetReader(stream, leaveOpen: true, cancellationToken); 260565"];
9963 [label="using var reader = ObjectReader.TryGetReader(stream, leaveOpen: true, cancellationToken); 260566"];
9964 [label="using var reader = ObjectReader.TryGetReader(stream, leaveOpen: true, cancellationToken); 260567"];
9965 [label="if (reader == null)\n            {\n                throw new ArgumentException(CodeAnalysisResources.Stream_contains_invalid_data, nameof(stream));\n            } 260568"];
9966 [label="if (reader == null)\n            {\n                throw new ArgumentException(CodeAnalysisResources.Stream_contains_invalid_data, nameof(stream));\n            } 260569"];
9967 [label="var root = (Syntax.InternalSyntax.CSharpSyntaxNode)reader.ReadValue(); 260570"];
9968 [label="var root = (Syntax.InternalSyntax.CSharpSyntaxNode)reader.ReadValue(); 260571"];
9969 [label="param CSharpSyntaxNode(ObjectReader reader) 260572"];
9970 [label="param CSharpSyntaxNode(this) 260573"];
9971 [label="reader 260574"];
9972 [label="param CSharpSyntaxNode(this) 260575"];
9973 [label="param CSharpSyntaxNode(this) 260576"];
9974 [label="param SyntaxTokenWithTrivia(ObjectReader reader) 260577"];
9975 [label="param SyntaxTokenWithTrivia(this) 260578"];
9976 [label="reader 260579"];
9977 [label="param SyntaxTokenWithTrivia(this) 260580"];
9978 [label="param SyntaxToken(ObjectReader reader) 260581"];
9979 [label="param SyntaxToken(this) 260582"];
9980 [label="reader 260583"];
9981 [label="param SyntaxToken(this) 260584"];
9982 [label="param CSharpSyntaxNode(ObjectReader reader) 260585"];
9983 [label="param CSharpSyntaxNode(this) 260586"];
9984 [label="reader 260587"];
9985 [label="param CSharpSyntaxNode(this) 260588"];
9986 [label="param CSharpSyntaxNode(this) 260589"];
9987 [label="this.Text 260590"];
9988 [label="get { return SyntaxFacts.GetText(this.Kind); } 260591"];
9989 [label="this.Kind 260592"];
9990 [label="return (SyntaxKind)this.RawKind; 260593"];
9991 [label="SyntaxFacts.GetText(this.Kind) 260594"];
9992 [label="var text = this.Text; 260595"];
9993 [label="if (text != null)\n            {\n                FullWidth = text.Length;\n            } 260596"];
9994 [label="if (text != null)\n            {\n                FullWidth = text.Length;\n            } 260597"];
9995 [label="FullWidth 260598"];
9996 [label="this.flags |= NodeFlags.IsNotMissing; 260599"];
9997 [label="this.flags 260600"];
9998 [label="var leading = (GreenNode)reader.ReadValue(); 260601"];
9999 [label="var leading = (GreenNode)reader.ReadValue(); 260602"];
10000 [label="var leading = (GreenNode)reader.ReadValue(); 260603"];
10001 [label="param SyntaxTrivia(ObjectReader reader) 260604"];
10002 [label="param SyntaxTrivia(this) 260605"];
10003 [label="reader 260606"];
10004 [label="param SyntaxTrivia(this) 260607"];
10005 [label="param CSharpSyntaxNode(ObjectReader reader) 260608"];
10006 [label="param CSharpSyntaxNode(this) 260609"];
10007 [label="param CSharpSyntaxNode(this) 260610"];
10008 [label="this.Text = reader.ReadString(); 260611"];
10009 [label="this.Text 260612"];
10010 [label="this.FullWidth 260613"];
10011 [label="this.Kind 260614"];
10012 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 260615"];
10013 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 260616"];
10014 [label="this.AdjustFlagsAndWidth(leading); 260617"];
10015 [label="this.LeadingField 260618"];
10016 [label="var trailing = (GreenNode)reader.ReadValue(); 260619"];
10017 [label="var trailing = (GreenNode)reader.ReadValue(); 260620"];
10018 [label="var trailing = (GreenNode)reader.ReadValue(); 260621"];
10019 [label="param SyntaxTrivia(this) 260622"];
10020 [label="param SyntaxTrivia(this) 260623"];
10021 [label="param CSharpSyntaxNode(this) 260624"];
10022 [label="param CSharpSyntaxNode(this) 260625"];
10023 [label="this.Kind 260626"];
10024 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 260627"];
10025 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 260628"];
10026 [label="this.AdjustFlagsAndWidth(trailing); 260629"];
10027 [label="this.TrailingField 260630"];
10028 [label="var root = (Syntax.InternalSyntax.CSharpSyntaxNode)reader.ReadValue(); 260631"];
10029 [label="param SyntaxIdentifierWithTrailingTrivia(ObjectReader reader) 260632"];
10030 [label="param SyntaxIdentifierWithTrailingTrivia(this) 260633"];
10031 [label="reader 260634"];
10032 [label="param SyntaxIdentifierWithTrailingTrivia(this) 260635"];
10033 [label="param SyntaxIdentifier(ObjectReader reader) 260636"];
10034 [label="param SyntaxIdentifier(this) 260637"];
10035 [label="reader 260638"];
10036 [label="param SyntaxIdentifier(this) 260639"];
10037 [label="param SyntaxToken(ObjectReader reader) 260640"];
10038 [label="param SyntaxToken(this) 260641"];
10039 [label="reader 260642"];
10040 [label="param SyntaxToken(this) 260643"];
10041 [label="param CSharpSyntaxNode(ObjectReader reader) 260644"];
10042 [label="param CSharpSyntaxNode(this) 260645"];
10043 [label="reader 260646"];
10044 [label="param CSharpSyntaxNode(this) 260647"];
10045 [label="param CSharpSyntaxNode(this) 260648"];
10046 [label="this.Text 260649"];
10047 [label="get { return this.TextField; } 260650"];
10048 [label="if (text != null)\n            {\n                FullWidth = text.Length;\n            } 260651"];
10049 [label="this.TextField = reader.ReadString(); 260652"];
10050 [label="this.TextField 260653"];
10051 [label="this.FullWidth 260654"];
10052 [label="var trailing = (GreenNode)reader.ReadValue(); 260655"];
10053 [label="var trailing = (GreenNode)reader.ReadValue(); 260656"];
10054 [label="var trailing = (GreenNode)reader.ReadValue(); 260657"];
10055 [label="param SyntaxTrivia(this) 260658"];
10056 [label="param SyntaxTrivia(this) 260659"];
10057 [label="param CSharpSyntaxNode(this) 260660"];
10058 [label="param CSharpSyntaxNode(this) 260661"];
10059 [label="this.Kind 260662"];
10060 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 260663"];
10061 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 260664"];
10062 [label="this.AdjustFlagsAndWidth(trailing); 260665"];
10063 [label="_trailing 260666"];
10064 [label="var root = (Syntax.InternalSyntax.CSharpSyntaxNode)reader.ReadValue(); 260667"];
10065 [label="param SyntaxIdentifier(ObjectReader reader) 260668"];
10066 [label="param SyntaxIdentifier(this) 260669"];
10067 [label="reader 260670"];
10068 [label="param SyntaxIdentifier(this) 260671"];
10069 [label="param SyntaxToken(ObjectReader reader) 260672"];
10070 [label="param SyntaxToken(this) 260673"];
10071 [label="reader 260674"];
10072 [label="param SyntaxToken(this) 260675"];
10073 [label="param CSharpSyntaxNode(ObjectReader reader) 260676"];
10074 [label="param CSharpSyntaxNode(this) 260677"];
10075 [label="reader 260678"];
10076 [label="param CSharpSyntaxNode(this) 260679"];
10077 [label="this.Text 260680"];
10078 [label="get { return this.TextField; } 260681"];
10079 [label="if (text != null)\n            {\n                FullWidth = text.Length;\n            } 260682"];
10080 [label="param SyntaxToken(ObjectReader reader) 260683"];
10081 [label="param SyntaxToken(this) 260684"];
10082 [label="reader 260685"];
10083 [label="param SyntaxToken(this) 260686"];
10084 [label="param CSharpSyntaxNode(ObjectReader reader) 260687"];
10085 [label="param CSharpSyntaxNode(this) 260688"];
10086 [label="reader 260689"];
10087 [label="param CSharpSyntaxNode(this) 260690"];
10088 [label="this.Text 260691"];
10089 [label="get { return SyntaxFacts.GetText(this.Kind); } 260692"];
10090 [label="this.Kind 260693"];
10091 [label="SyntaxFacts.GetText(this.Kind) 260694"];
10092 [label="if (text != null)\n            {\n                FullWidth = text.Length;\n            } 260695"];
10093 [label="return root.CreateRed(); 260696"];
10094 [label="return root.CreateRed(); 260697"];
10095 [label="param CSharpSyntaxNode(this) 260698"];
10096 [label="return tree; 260699"];
10097 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 260700"];
10098 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 260701"];
10099 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 260702"];
10100 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 260703"];
10101 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 260704"];
10102 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 260705"];
10103 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 260706"];
10104 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 260707"];
10105 [label="this.GetRoot(cancellationToken) 260708"];
10106 [label="param GetRoot(CancellationToken cancellationToken) 260709"];
10107 [label="param CSharpSyntaxNode(this) 260710"];
10108 [label="=> true 260711"];
10109 [label="true 260712"];
10110 [label="hasTopLevelStatements 260713"];
10111 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 260714"];
10112 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 260715"];
10113 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 260716"];
10114 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 260717"];
10115 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 260718"];
10116 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 260719"];
10117 [label="param ValidateIOperations(Func<Compilation> createCompilation) 260720"];
10118 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 260721"];
10119 [label="return; 260722"];
10120 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 260723"];
10121 [label="var compilation = createCompilationLambda(); 260724"];
10122 [label="var compilation = createCompilationLambda(); 260725"];
10123 [label="return Guid.NewGuid().ToString('D'); 260726"];
10124 [label="var compilation = createCompilationLambda(); 260727"];
10125 [label="OutputKind.ConsoleApplication 260728"];
10126 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 260729"];
10127 [label="param CSharpCompilationOptions(OutputKind outputKind) 260730"];
10128 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 260731"];
10129 [label="param CSharpCompilationOptions(string? moduleName = null) 260732"];
10130 [label="param CSharpCompilationOptions(string? mainTypeName = null) 260733"];
10131 [label="param CSharpCompilationOptions(string? scriptClassName = null) 260734"];
10132 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 260735"];
10133 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 260736"];
10134 [label="param CSharpCompilationOptions(bool checkOverflow = false) 260737"];
10135 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 260738"];
10136 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 260739"];
10137 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 260740"];
10138 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 260741"];
10139 [label="param CSharpCompilationOptions(bool? delaySign = null) 260742"];
10140 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 260743"];
10141 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 260744"];
10142 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 260745"];
10143 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 260746"];
10144 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 260747"];
10145 [label="param CSharpCompilationOptions(bool deterministic = false) 260748"];
10146 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 260749"];
10147 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 260750"];
10148 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 260751"];
10149 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 260752"];
10150 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 260753"];
10151 [label="param CSharpCompilationOptions(bool publicSign = false) 260754"];
10152 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 260755"];
10153 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 260756"];
10154 [label="param CSharpCompilationOptions(this) 260757"];
10155 [label="outputKind 260758"];
10156 [label="reportSuppressedDiagnostics 260759"];
10157 [label="moduleName 260760"];
10158 [label="mainTypeName 260761"];
10159 [label="scriptClassName 260762"];
10160 [label="usings 260763"];
10161 [label="optimizationLevel 260764"];
10162 [label="checkOverflow 260765"];
10163 [label="allowUnsafe 260766"];
10164 [label="cryptoKeyContainer 260767"];
10165 [label="cryptoKeyFile 260768"];
10166 [label="cryptoPublicKey 260769"];
10167 [label="delaySign 260770"];
10168 [label="platform 260771"];
10169 [label="generalDiagnosticOption 260772"];
10170 [label="warningLevel 260773"];
10171 [label="specificDiagnosticOptions 260774"];
10172 [label="concurrentBuild 260775"];
10173 [label="deterministic 260776"];
10174 [label="default 260777"];
10175 [label="false 260778"];
10176 [label="xmlReferenceResolver 260779"];
10177 [label="sourceReferenceResolver 260780"];
10178 [label="null 260781"];
10179 [label="metadataReferenceResolver 260782"];
10180 [label="assemblyIdentityComparer 260783"];
10181 [label="strongNameProvider 260784"];
10182 [label="metadataImportOptions 260785"];
10183 [label="false 260786"];
10184 [label="publicSign 260787"];
10185 [label="BinderFlags.None 260788"];
10186 [label="nullableContextOptions 260789"];
10187 [label="param CSharpCompilationOptions(OutputKind outputKind) 260790"];
10188 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 260791"];
10189 [label="param CSharpCompilationOptions(string? moduleName) 260792"];
10190 [label="param CSharpCompilationOptions(string? mainTypeName) 260793"];
10191 [label="param CSharpCompilationOptions(string? scriptClassName) 260794"];
10192 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 260795"];
10193 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 260796"];
10194 [label="param CSharpCompilationOptions(bool checkOverflow) 260797"];
10195 [label="param CSharpCompilationOptions(bool allowUnsafe) 260798"];
10196 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 260799"];
10197 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 260800"];
10198 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 260801"];
10199 [label="param CSharpCompilationOptions(bool? delaySign) 260802"];
10200 [label="param CSharpCompilationOptions(Platform platform) 260803"];
10201 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 260804"];
10202 [label="param CSharpCompilationOptions(int warningLevel) 260805"];
10203 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 260806"];
10204 [label="param CSharpCompilationOptions(bool concurrentBuild) 260807"];
10205 [label="param CSharpCompilationOptions(bool deterministic) 260808"];
10206 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 260809"];
10207 [label="param CSharpCompilationOptions(bool debugPlusMode) 260810"];
10208 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 260811"];
10209 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 260812"];
10210 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 260813"];
10211 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 260814"];
10212 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 260815"];
10213 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 260816"];
10214 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 260817"];
10215 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 260818"];
10216 [label="param CSharpCompilationOptions(bool publicSign) 260819"];
10217 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 260820"];
10218 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 260821"];
10219 [label="param CSharpCompilationOptions(this) 260822"];
10220 [label="outputKind 260823"];
10221 [label="reportSuppressedDiagnostics 260824"];
10222 [label="moduleName 260825"];
10223 [label="mainTypeName 260826"];
10224 [label="scriptClassName 260827"];
10225 [label="cryptoKeyContainer 260828"];
10226 [label="cryptoKeyFile 260829"];
10227 [label="cryptoPublicKey 260830"];
10228 [label="delaySign 260831"];
10229 [label="publicSign 260832"];
10230 [label="optimizationLevel 260833"];
10231 [label="checkOverflow 260834"];
10232 [label="platform 260835"];
10233 [label="generalDiagnosticOption 260836"];
10234 [label="warningLevel 260837"];
10235 [label="specificDiagnosticOptions 260838"];
10236 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 260839"];
10237 [label="concurrentBuild 260840"];
10238 [label="deterministic 260841"];
10239 [label="currentLocalTime 260842"];
10240 [label="debugPlusMode 260843"];
10241 [label="xmlReferenceResolver 260844"];
10242 [label="sourceReferenceResolver 260845"];
10243 [label="syntaxTreeOptionsProvider 260846"];
10244 [label="metadataReferenceResolver 260847"];
10245 [label="assemblyIdentityComparer 260848"];
10246 [label="strongNameProvider 260849"];
10247 [label="metadataImportOptions 260850"];
10248 [label="referencesSupersedeLowerVersions 260851"];
10249 [label="param CSharpCompilationOptions(this) 260852"];
10250 [label="public bool AllowUnsafe { get; private set; } 260853"];
10251 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 260854"];
10252 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 260855"];
10253 [label="this.Usings = usings.AsImmutableOrEmpty(); 260856"];
10254 [label="this.Usings 260857"];
10255 [label="this.AllowUnsafe 260858"];
10256 [label="this.TopLevelBinderFlags 260859"];
10257 [label="this.NullableContextOptions 260860"];
10258 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 260861"];
10259 [label="OutputKind.DynamicallyLinkedLibrary 260862"];
10260 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 260863"];
10261 [label="param CSharpCompilationOptions(OutputKind outputKind) 260864"];
10262 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics = false) 260865"];
10263 [label="param CSharpCompilationOptions(string? moduleName = null) 260866"];
10264 [label="param CSharpCompilationOptions(string? mainTypeName = null) 260867"];
10265 [label="param CSharpCompilationOptions(string? scriptClassName = null) 260868"];
10266 [label="param CSharpCompilationOptions(IEnumerable<string>? usings = null) 260869"];
10267 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel = OptimizationLevel.Debug) 260870"];
10268 [label="param CSharpCompilationOptions(bool checkOverflow = false) 260871"];
10269 [label="param CSharpCompilationOptions(bool allowUnsafe = false) 260872"];
10270 [label="param CSharpCompilationOptions(string? cryptoKeyContainer = null) 260873"];
10271 [label="param CSharpCompilationOptions(string? cryptoKeyFile = null) 260874"];
10272 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey = default) 260875"];
10273 [label="param CSharpCompilationOptions(bool? delaySign = null) 260876"];
10274 [label="param CSharpCompilationOptions(Platform platform = Platform.AnyCpu) 260877"];
10275 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default) 260878"];
10276 [label="param CSharpCompilationOptions(int warningLevel = Diagnostic.DefaultWarningLevel) 260879"];
10277 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null) 260880"];
10278 [label="param CSharpCompilationOptions(bool concurrentBuild = true) 260881"];
10279 [label="param CSharpCompilationOptions(bool deterministic = false) 260882"];
10280 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver = null) 260883"];
10281 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver = null) 260884"];
10282 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver = null) 260885"];
10283 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer = null) 260886"];
10284 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider = null) 260887"];
10285 [label="param CSharpCompilationOptions(bool publicSign = false) 260888"];
10286 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public) 260889"];
10287 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 260890"];
10288 [label="param CSharpCompilationOptions(this) 260891"];
10289 [label="outputKind 260892"];
10290 [label="reportSuppressedDiagnostics 260893"];
10291 [label="moduleName 260894"];
10292 [label="mainTypeName 260895"];
10293 [label="scriptClassName 260896"];
10294 [label="usings 260897"];
10295 [label="optimizationLevel 260898"];
10296 [label="checkOverflow 260899"];
10297 [label="allowUnsafe 260900"];
10298 [label="cryptoKeyContainer 260901"];
10299 [label="cryptoKeyFile 260902"];
10300 [label="cryptoPublicKey 260903"];
10301 [label="delaySign 260904"];
10302 [label="platform 260905"];
10303 [label="generalDiagnosticOption 260906"];
10304 [label="warningLevel 260907"];
10305 [label="specificDiagnosticOptions 260908"];
10306 [label="concurrentBuild 260909"];
10307 [label="deterministic 260910"];
10308 [label="default 260911"];
10309 [label="false 260912"];
10310 [label="xmlReferenceResolver 260913"];
10311 [label="sourceReferenceResolver 260914"];
10312 [label="null 260915"];
10313 [label="metadataReferenceResolver 260916"];
10314 [label="assemblyIdentityComparer 260917"];
10315 [label="strongNameProvider 260918"];
10316 [label="metadataImportOptions 260919"];
10317 [label="false 260920"];
10318 [label="publicSign 260921"];
10319 [label="BinderFlags.None 260922"];
10320 [label="nullableContextOptions 260923"];
10321 [label="param CSharpCompilationOptions(OutputKind outputKind) 260924"];
10322 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 260925"];
10323 [label="param CSharpCompilationOptions(string? moduleName) 260926"];
10324 [label="param CSharpCompilationOptions(string? mainTypeName) 260927"];
10325 [label="param CSharpCompilationOptions(string? scriptClassName) 260928"];
10326 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 260929"];
10327 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 260930"];
10328 [label="param CSharpCompilationOptions(bool checkOverflow) 260931"];
10329 [label="param CSharpCompilationOptions(bool allowUnsafe) 260932"];
10330 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 260933"];
10331 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 260934"];
10332 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 260935"];
10333 [label="param CSharpCompilationOptions(bool? delaySign) 260936"];
10334 [label="param CSharpCompilationOptions(Platform platform) 260937"];
10335 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 260938"];
10336 [label="param CSharpCompilationOptions(int warningLevel) 260939"];
10337 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 260940"];
10338 [label="param CSharpCompilationOptions(bool concurrentBuild) 260941"];
10339 [label="param CSharpCompilationOptions(bool deterministic) 260942"];
10340 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 260943"];
10341 [label="param CSharpCompilationOptions(bool debugPlusMode) 260944"];
10342 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 260945"];
10343 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 260946"];
10344 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 260947"];
10345 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 260948"];
10346 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 260949"];
10347 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 260950"];
10348 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 260951"];
10349 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 260952"];
10350 [label="param CSharpCompilationOptions(bool publicSign) 260953"];
10351 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 260954"];
10352 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 260955"];
10353 [label="param CSharpCompilationOptions(this) 260956"];
10354 [label="outputKind 260957"];
10355 [label="reportSuppressedDiagnostics 260958"];
10356 [label="moduleName 260959"];
10357 [label="mainTypeName 260960"];
10358 [label="scriptClassName 260961"];
10359 [label="cryptoKeyContainer 260962"];
10360 [label="cryptoKeyFile 260963"];
10361 [label="cryptoPublicKey 260964"];
10362 [label="delaySign 260965"];
10363 [label="publicSign 260966"];
10364 [label="optimizationLevel 260967"];
10365 [label="checkOverflow 260968"];
10366 [label="platform 260969"];
10367 [label="generalDiagnosticOption 260970"];
10368 [label="warningLevel 260971"];
10369 [label="specificDiagnosticOptions 260972"];
10370 [label="specificDiagnosticOptions.ToImmutableDictionaryOrEmpty() 260973"];
10371 [label="concurrentBuild 260974"];
10372 [label="deterministic 260975"];
10373 [label="currentLocalTime 260976"];
10374 [label="debugPlusMode 260977"];
10375 [label="xmlReferenceResolver 260978"];
10376 [label="sourceReferenceResolver 260979"];
10377 [label="syntaxTreeOptionsProvider 260980"];
10378 [label="metadataReferenceResolver 260981"];
10379 [label="assemblyIdentityComparer 260982"];
10380 [label="strongNameProvider 260983"];
10381 [label="metadataImportOptions 260984"];
10382 [label="referencesSupersedeLowerVersions 260985"];
10383 [label="param CSharpCompilationOptions(this) 260986"];
10384 [label="public bool AllowUnsafe { get; private set; } 260987"];
10385 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 260988"];
10386 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 260989"];
10387 [label="this.Usings = usings.AsImmutableOrEmpty(); 260990"];
10388 [label="this.Usings 260991"];
10389 [label="this.AllowUnsafe 260992"];
10390 [label="this.TopLevelBinderFlags 260993"];
10391 [label="this.NullableContextOptions 260994"];
10392 [label="true 260995"];
10393 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 260996"];
10394 [label="param WithReferencesSupersedeLowerVersions(bool value) 260997"];
10395 [label="param WithReferencesSupersedeLowerVersions(this) 260998"];
10396 [label="if (value == this.ReferencesSupersedeLowerVersions)\n            {\n                return this;\n            } 260999"];
10397 [label="return new CSharpCompilationOptions(this) { ReferencesSupersedeLowerVersions = value }; 261000"];
10398 [label="return new CSharpCompilationOptions(this) { ReferencesSupersedeLowerVersions = value }; 261001"];
10399 [label="new CSharpCompilationOptions(this) { ReferencesSupersedeLowerVersions = value } 261002"];
10400 [label="param CSharpCompilationOptions(CSharpCompilationOptions other) 261003"];
10401 [label="param CSharpCompilationOptions(this) 261004"];
10402 [label="other.OutputKind 261005"];
10403 [label="other.ModuleName 261006"];
10404 [label="other.MainTypeName 261007"];
10405 [label="other.ScriptClassName 261008"];
10406 [label="other.Usings 261009"];
10407 [label="other.OptimizationLevel 261010"];
10408 [label="other.CheckOverflow 261011"];
10409 [label="other.AllowUnsafe 261012"];
10410 [label="other.CryptoKeyContainer 261013"];
10411 [label="other.CryptoKeyFile 261014"];
10412 [label="other.CryptoPublicKey 261015"];
10413 [label="other.DelaySign 261016"];
10414 [label="other.Platform 261017"];
10415 [label="other.GeneralDiagnosticOption 261018"];
10416 [label="other.WarningLevel 261019"];
10417 [label="other.SpecificDiagnosticOptions 261020"];
10418 [label="other.ConcurrentBuild 261021"];
10419 [label="other.Deterministic 261022"];
10420 [label="other.CurrentLocalTime 261023"];
10421 [label="other.DebugPlusMode 261024"];
10422 [label="other.XmlReferenceResolver 261025"];
10423 [label="other.SourceReferenceResolver 261026"];
10424 [label="other.SyntaxTreeOptionsProvider 261027"];
10425 [label="other.MetadataReferenceResolver 261028"];
10426 [label="other.AssemblyIdentityComparer 261029"];
10427 [label="other.StrongNameProvider 261030"];
10428 [label="other.MetadataImportOptions 261031"];
10429 [label="other.ReferencesSupersedeLowerVersions 261032"];
10430 [label="other.ReportSuppressedDiagnostics 261033"];
10431 [label="other.PublicSign 261034"];
10432 [label="other.TopLevelBinderFlags 261035"];
10433 [label="other.NullableContextOptions 261036"];
10434 [label="param CSharpCompilationOptions(this) 261037"];
10435 [label="param CSharpCompilationOptions(OutputKind outputKind) 261038"];
10436 [label="param CSharpCompilationOptions(bool reportSuppressedDiagnostics) 261039"];
10437 [label="param CSharpCompilationOptions(string? moduleName) 261040"];
10438 [label="param CSharpCompilationOptions(string? mainTypeName) 261041"];
10439 [label="param CSharpCompilationOptions(string? scriptClassName) 261042"];
10440 [label="param CSharpCompilationOptions(IEnumerable<string>? usings) 261043"];
10441 [label="param CSharpCompilationOptions(OptimizationLevel optimizationLevel) 261044"];
10442 [label="param CSharpCompilationOptions(bool checkOverflow) 261045"];
10443 [label="param CSharpCompilationOptions(bool allowUnsafe) 261046"];
10444 [label="param CSharpCompilationOptions(string? cryptoKeyContainer) 261047"];
10445 [label="param CSharpCompilationOptions(string? cryptoKeyFile) 261048"];
10446 [label="param CSharpCompilationOptions(ImmutableArray<byte> cryptoPublicKey) 261049"];
10447 [label="param CSharpCompilationOptions(bool? delaySign) 261050"];
10448 [label="param CSharpCompilationOptions(Platform platform) 261051"];
10449 [label="param CSharpCompilationOptions(ReportDiagnostic generalDiagnosticOption) 261052"];
10450 [label="param CSharpCompilationOptions(int warningLevel) 261053"];
10451 [label="param CSharpCompilationOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) 261054"];
10452 [label="param CSharpCompilationOptions(bool concurrentBuild) 261055"];
10453 [label="param CSharpCompilationOptions(bool deterministic) 261056"];
10454 [label="param CSharpCompilationOptions(DateTime currentLocalTime) 261057"];
10455 [label="param CSharpCompilationOptions(bool debugPlusMode) 261058"];
10456 [label="param CSharpCompilationOptions(XmlReferenceResolver? xmlReferenceResolver) 261059"];
10457 [label="param CSharpCompilationOptions(SourceReferenceResolver? sourceReferenceResolver) 261060"];
10458 [label="param CSharpCompilationOptions(SyntaxTreeOptionsProvider? syntaxTreeOptionsProvider) 261061"];
10459 [label="param CSharpCompilationOptions(MetadataReferenceResolver? metadataReferenceResolver) 261062"];
10460 [label="param CSharpCompilationOptions(AssemblyIdentityComparer? assemblyIdentityComparer) 261063"];
10461 [label="param CSharpCompilationOptions(StrongNameProvider? strongNameProvider) 261064"];
10462 [label="param CSharpCompilationOptions(MetadataImportOptions metadataImportOptions) 261065"];
10463 [label="param CSharpCompilationOptions(bool referencesSupersedeLowerVersions) 261066"];
10464 [label="param CSharpCompilationOptions(bool publicSign) 261067"];
10465 [label="param CSharpCompilationOptions(BinderFlags topLevelBinderFlags) 261068"];
10466 [label="param CSharpCompilationOptions(NullableContextOptions nullableContextOptions) 261069"];
10467 [label="param CSharpCompilationOptions(this) 261070"];
10468 [label="param CSharpCompilationOptions(this) 261071"];
10469 [label="param CSharpCompilationOptions(this) 261072"];
10470 [label="public bool AllowUnsafe { get; private set; } 261073"];
10471 [label="internal BinderFlags TopLevelBinderFlags { get; private set; } 261074"];
10472 [label="public override NullableContextOptions NullableContextOptions { get; protected set; } 261075"];
10473 [label="this.Usings = usings.AsImmutableOrEmpty(); 261076"];
10474 [label="this.Usings 261077"];
10475 [label="this.AllowUnsafe 261078"];
10476 [label="ReferencesSupersedeLowerVersions 261079"];
10477 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 261080"];
10478 [label="param Create(string? assemblyName) 261081"];
10479 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 261082"];
10480 [label="param Create(IEnumerable<MetadataReference>? references = null) 261083"];
10481 [label="param Create(CSharpCompilationOptions? options = null) 261084"];
10482 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 261085"];
10483 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 261086"];
10484 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 261087"];
10485 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 261088"];
10486 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 261089"];
10487 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 261090"];
10488 [label="param Create(string? assemblyName) 261091"];
10489 [label="param Create(CSharpCompilationOptions options) 261092"];
10490 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 261093"];
10491 [label="param Create(IEnumerable<MetadataReference>? references) 261094"];
10492 [label="param Create(CSharpCompilation? previousSubmission) 261095"];
10493 [label="param Create(Type? returnType) 261096"];
10494 [label="param Create(Type? hostObjectType) 261097"];
10495 [label="param Create(bool isSubmission) 261098"];
10496 [label="RoslynDebug.Assert(options != null); 261099"];
10497 [label="RoslynDebug.Assert(options != null); 261100"];
10498 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 261101"];
10499 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 261102"];
10500 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 261103"];
10501 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261104"];
10502 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261105"];
10503 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261106"];
10504 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261107"];
10505 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261108"];
10506 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261109"];
10507 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261110"];
10508 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261111"];
10509 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261112"];
10510 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261113"];
10511 [label="new MessageProvider() 261114"];
10512 [label="param MessageProvider(this) 261115"];
10513 [label="Instance = new MessageProvider() 261116"];
10514 [label="ObjectBinder.RegisterTypeReader(typeof(MessageProvider), r => Instance); 261117"];
10515 [label="ObjectBinder.RegisterTypeReader(typeof(MessageProvider), r => Instance); 261118"];
10516 [label="ObjectBinder.RegisterTypeReader(typeof(MessageProvider), r => Instance); 261119"];
10517 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 261120"];
10518 [label="new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null) 261121"];
10519 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 261122"];
10520 [label="param SyntaxAndDeclarationManager(string scriptClassName) 261123"];
10521 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 261124"];
10522 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 261125"];
10523 [label="param SyntaxAndDeclarationManager(bool isSubmission) 261126"];
10524 [label="param SyntaxAndDeclarationManager(State state) 261127"];
10525 [label="param SyntaxAndDeclarationManager(this) 261128"];
10526 [label="externalSyntaxTrees 261129"];
10527 [label="scriptClassName 261130"];
10528 [label="resolver 261131"];
10529 [label="messageProvider 261132"];
10530 [label="isSubmission 261133"];
10531 [label="param SyntaxAndDeclarationManager(this) 261134"];
10532 [label="param SyntaxAndDeclarationManager(this) 261135"];
10533 [label="_lazyState 261136"];
10534 [label="_lazyState 261137"];
10535 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 261138"];
10536 [label="param CSharpCompilation(string? assemblyName) 261139"];
10537 [label="param CSharpCompilation(CSharpCompilationOptions options) 261140"];
10538 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 261141"];
10539 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 261142"];
10540 [label="param CSharpCompilation(Type? submissionReturnType) 261143"];
10541 [label="param CSharpCompilation(Type? hostObjectType) 261144"];
10542 [label="param CSharpCompilation(bool isSubmission) 261145"];
10543 [label="param CSharpCompilation(ReferenceManager? referenceManager) 261146"];
10544 [label="param CSharpCompilation(bool reuseReferenceManager) 261147"];
10545 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 261148"];
10546 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 261149"];
10547 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 261150"];
10548 [label="param CSharpCompilation(this) 261151"];
10549 [label="assemblyName 261152"];
10550 [label="options 261153"];
10551 [label="references 261154"];
10552 [label="previousSubmission 261155"];
10553 [label="submissionReturnType 261156"];
10554 [label="hostObjectType 261157"];
10555 [label="isSubmission 261158"];
10556 [label="referenceManager 261159"];
10557 [label="reuseReferenceManager 261160"];
10558 [label="syntaxAndDeclarations 261161"];
10559 [label="syntaxAndDeclarations.ExternalSyntaxTrees 261162"];
10560 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 261163"];
10561 [label="semanticModelProvider 261164"];
10562 [label="eventQueue 261165"];
10563 [label="param CSharpCompilation(this) 261166"];
10564 [label="param CSharpCompilation(string? assemblyName) 261167"];
10565 [label="param CSharpCompilation(CSharpCompilationOptions options) 261168"];
10566 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 261169"];
10567 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 261170"];
10568 [label="param CSharpCompilation(Type? submissionReturnType) 261171"];
10569 [label="param CSharpCompilation(Type? hostObjectType) 261172"];
10570 [label="param CSharpCompilation(bool isSubmission) 261173"];
10571 [label="param CSharpCompilation(ReferenceManager? referenceManager) 261174"];
10572 [label="param CSharpCompilation(bool reuseReferenceManager) 261175"];
10573 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 261176"];
10574 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 261177"];
10575 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 261178"];
10576 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 261179"];
10577 [label="param CSharpCompilation(this) 261180"];
10578 [label="assemblyName 261181"];
10579 [label="references 261182"];
10580 [label="features 261183"];
10581 [label="isSubmission 261184"];
10582 [label="semanticModelProvider 261185"];
10583 [label="eventQueue 261186"];
10584 [label="param CSharpCompilation(this) 261187"];
10585 [label="param CSharpCompilation(this) 261188"];
10586 [label="_options 261189"];
10587 [label="_globalImports 261190"];
10588 [label="_previousSubmissionImports 261191"];
10589 [label="_globalNamespaceAlias 261192"];
10590 [label="_scriptClass 261193"];
10591 [label="_lazyHostObjectTypeSymbol 261194"];
10592 [label="_lazyImportInfos 261195"];
10593 [label="_conversions 261196"];
10594 [label="_anonymousTypeManager 261197"];
10595 [label="_lazyGlobalNamespace 261198"];
10596 [label="builtInOperators 261199"];
10597 [label="_lazyAssemblySymbol 261200"];
10598 [label="_referenceManager 261201"];
10599 [label="_syntaxAndDeclarations 261202"];
10600 [label="_lazyEntryPoint 261203"];
10601 [label="_lazyEmitNullablePublicOnly 261204"];
10602 [label="_lazyCompilationUnitCompletedTrees 261205"];
10603 [label="NullableAnalysisData 261206"];
10604 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 261207"];
10605 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 261208"];
10606 [label="_externAliasTargets 261209"];
10607 [label="_moduleInitializerMethods 261210"];
10608 [label="_binderFactories 261211"];
10609 [label="_ignoreAccessibilityBinderFactories 261212"];
10610 [label="_lazyDeclarationDiagnostics 261213"];
10611 [label="_declarationDiagnosticsFrozen 261214"];
10612 [label="new DiagnosticBag() 261215"];
10613 [label="_additionalCodegenWarnings = new DiagnosticBag() 261216"];
10614 [label="WellKnownMemberSignatureComparer 261217"];
10615 [label="_lazyWellKnownTypes 261218"];
10616 [label="_lazyWellKnownTypeMembers 261219"];
10617 [label="_usesNullableAttributes 261220"];
10618 [label="_needsGeneratedAttributes 261221"];
10619 [label="_needsGeneratedAttributes_IsFrozen 261222"];
10620 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 261223"];
10621 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 261224"];
10622 [label="new WellKnownMembersSignatureComparer(this) 261225"];
10623 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 261226"];
10624 [label="param WellKnownMembersSignatureComparer(this) 261227"];
10625 [label="new SpecialMembersSignatureComparer() 261228"];
10626 [label="param SpecialMembersSignatureComparer(this) 261229"];
10627 [label="Instance = new SpecialMembersSignatureComparer() 261230"];
10628 [label="param WellKnownMembersSignatureComparer(this) 261231"];
10629 [label="param SpecialMembersSignatureComparer(this) 261232"];
10630 [label="param SpecialMembersSignatureComparer(this) 261233"];
10631 [label="_compilation 261234"];
10632 [label="_compilation 261235"];
10633 [label="WellKnownMemberSignatureComparer 261236"];
10634 [label="_options 261237"];
10635 [label="this.builtInOperators = new BuiltInOperators(this); 261238"];
10636 [label="this.builtInOperators = new BuiltInOperators(this); 261239"];
10637 [label="new BuiltInOperators(this) 261240"];
10638 [label="param BuiltInOperators(CSharpCompilation compilation) 261241"];
10639 [label="param BuiltInOperators(this) 261242"];
10640 [label="_compilation 261243"];
10641 [label="_builtInUnaryOperators 261244"];
10642 [label="_builtInOperators 261245"];
10643 [label="_compilation 261246"];
10644 [label="this.builtInOperators 261247"];
10645 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 261248"];
10646 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 261249"];
10647 [label="_scriptClass 261250"];
10648 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 261251"];
10649 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 261252"];
10650 [label="_globalImports 261253"];
10651 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 261254"];
10652 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 261255"];
10653 [label="_previousSubmissionImports 261256"];
10654 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 261257"];
10655 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 261258"];
10656 [label="_globalNamespaceAlias 261259"];
10657 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 261260"];
10658 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 261261"];
10659 [label="new AnonymousTypeManager(this) 261262"];
10660 [label="param AnonymousTypeManager(CSharpCompilation compilation) 261263"];
10661 [label="param AnonymousTypeManager(this) 261264"];
10662 [label="param AnonymousTypeManager(this) 261265"];
10663 [label="public CSharpCompilation Compilation { get; } 261266"];
10664 [label="_lazyAnonymousTypeTemplates 261267"];
10665 [label="_lazySynthesizedDelegates 261268"];
10666 [label="new ConcurrentDictionary<Location, bool>() 261269"];
10667 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 261270"];
10668 [label="Debug.Assert(compilation != null); 261271"];
10669 [label="Debug.Assert(compilation != null); 261272"];
10670 [label="this.Compilation 261273"];
10671 [label="_anonymousTypeManager 261274"];
10672 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 261275"];
10673 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 261276"];
10674 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 261277"];
10675 [label="LanguageVersion? result = null; 261278"];
10676 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 261279"];
10677 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 261280"];
10678 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 261281"];
10679 [label="LanguageVersion.Default.MapSpecifiedToEffectiveVersion() 261282"];
10680 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 261283"];
10681 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 261284"];
10682 [label="return LanguageVersion.CSharp9; 261285"];
10683 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 261286"];
10684 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 261287"];
10685 [label="this.LanguageVersion 261288"];
10686 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 261289"];
10687 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261290"];
10688 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261291"];
10689 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261292"];
10690 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261293"];
10691 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261294"];
10692 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261295"];
10693 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 261296"];
10694 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 261297"];
10695 [label="this.Options 261298"];
10696 [label="get\n            {\n                return _options;\n            } 261299"];
10697 [label="return _options; 261300"];
10698 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 261301"];
10699 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 261302"];
10700 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 261303"];
10701 [label="param ReferenceManager(string simpleAssemblyName) 261304"];
10702 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 261305"];
10703 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 261306"];
10704 [label="param ReferenceManager(this) 261307"];
10705 [label="simpleAssemblyName 261308"];
10706 [label="identityComparer 261309"];
10707 [label="observedMetadata 261310"];
10708 [label="param ReferenceManager(this) 261311"];
10709 [label="param ReferenceManager(this) 261312"];
10710 [label="_referenceManager 261313"];
10711 [label="_syntaxAndDeclarations 261314"];
10712 [label="Debug.Assert(_lazyAssemblySymbol is null); 261315"];
10713 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 261316"];
10714 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 261317"];
10715 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 261318"];
10716 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 261319"];
10717 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 261320"];
10718 [label="compilation.AddSyntaxTrees(syntaxTrees) 261321"];
10719 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 261322"];
10720 [label="param AddSyntaxTrees(this) 261323"];
10721 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 261324"];
10722 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 261325"];
10723 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 261326"];
10724 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 261327"];
10725 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 261328"];
10726 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 261329"];
10727 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 261330"];
10728 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 261331"];
10729 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 261332"];
10730 [label="bool reuseReferenceManager = true; 261333"];
10731 [label="int i = 0; 261334"];
10732 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 261335"];
10733 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 261336"];
10734 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 261337"];
10735 [label="tree.HasCompilationUnitRoot 261338"];
10736 [label="get\n                {\n                    return _hasCompilationUnitRoot;\n                } 261339"];
10737 [label="return _hasCompilationUnitRoot; 261340"];
10738 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 261341"];
10739 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 261342"];
10740 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 261343"];
10741 [label="externalSyntaxTrees.Add(tree); 261344"];
10742 [label="externalSyntaxTrees.Add(tree); 261345"];
10743 [label="tree.HasReferenceOrLoadDirectives 261346"];
10744 [label="get\n            {\n                Debug.Assert(HasCompilationUnitRoot);\n\n                if (Options.Kind == SourceCodeKind.Script)\n                {\n                    var compilationUnitRoot = GetCompilationUnitRoot();\n                    return compilationUnitRoot.GetReferenceDirectives().Count > 0 || compilationUnitRoot.GetLoadDirectives().Count > 0;\n                }\n\n                return false;\n            } 261347"];
10745 [label="HasCompilationUnitRoot 261348"];
10746 [label="get\n                {\n                    return _hasCompilationUnitRoot;\n                } 261349"];
10747 [label="return _hasCompilationUnitRoot; 261350"];
10748 [label="Debug.Assert(HasCompilationUnitRoot); 261351"];
10749 [label="Options 261352"];
10750 [label="get\n                {\n                    return _options;\n                } 261353"];
10751 [label="return _options; 261354"];
10752 [label="if (Options.Kind == SourceCodeKind.Script)\n                {\n                    var compilationUnitRoot = GetCompilationUnitRoot();\n                    return compilationUnitRoot.GetReferenceDirectives().Count > 0 || compilationUnitRoot.GetLoadDirectives().Count > 0;\n                } 261355"];
10753 [label="return false; 261356"];
10754 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 261357"];
10755 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 261358"];
10756 [label="i++; 261359"];
10757 [label="externalSyntaxTrees.Free(); 261360"];
10758 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 261361"];
10759 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 261362"];
10760 [label="syntaxAndDeclarations.AddSyntaxTrees(trees) 261363"];
10761 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 261364"];
10762 [label="param AddSyntaxTrees(this) 261365"];
10763 [label="var scriptClassName = this.ScriptClassName; 261366"];
10764 [label="var resolver = this.Resolver; 261367"];
10765 [label="var messageProvider = this.MessageProvider; 261368"];
10766 [label="var isSubmission = this.IsSubmission; 261369"];
10767 [label="var state = _lazyState; 261370"];
10768 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 261371"];
10769 [label="var newExternalSyntaxTrees = this.ExternalSyntaxTrees.AddRange(trees); 261372"];
10770 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 261373"];
10771 [label="if (state == null)\n            {\n                return this.WithExternalSyntaxTrees(newExternalSyntaxTrees);\n            } 261374"];
10772 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 261375"];
10773 [label="this.WithExternalSyntaxTrees(newExternalSyntaxTrees) 261376"];
10774 [label="param WithExternalSyntaxTrees(ImmutableArray<SyntaxTree> trees) 261377"];
10775 [label="param WithExternalSyntaxTrees(this) 261378"];
10776 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 261379"];
10777 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 261380"];
10778 [label="return new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null); 261381"];
10779 [label="new SyntaxAndDeclarationManager(trees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission, state: null) 261382"];
10780 [label="param SyntaxAndDeclarationManager(ImmutableArray<SyntaxTree> externalSyntaxTrees) 261383"];
10781 [label="param SyntaxAndDeclarationManager(string scriptClassName) 261384"];
10782 [label="param SyntaxAndDeclarationManager(SourceReferenceResolver resolver) 261385"];
10783 [label="param SyntaxAndDeclarationManager(CommonMessageProvider messageProvider) 261386"];
10784 [label="param SyntaxAndDeclarationManager(bool isSubmission) 261387"];
10785 [label="param SyntaxAndDeclarationManager(State state) 261388"];
10786 [label="param SyntaxAndDeclarationManager(this) 261389"];
10787 [label="param SyntaxAndDeclarationManager(this) 261390"];
10788 [label="return this.WithExternalSyntaxTrees(newExternalSyntaxTrees); 261391"];
10789 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 261392"];
10790 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 261393"];
10791 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 261394"];
10792 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 261395"];
10793 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 261396"];
10794 [label="param Update(ReferenceManager referenceManager) 261397"];
10795 [label="param Update(bool reuseReferenceManager) 261398"];
10796 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 261399"];
10797 [label="param Update(this) 261400"];
10798 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261401"];
10799 [label="this.PreviousSubmission 261402"];
10800 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 261403"];
10801 [label="ScriptCompilationInfo 261404"];
10802 [label="ScriptCompilationInfo?.PreviousScriptCompilation 261405"];
10803 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261406"];
10804 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261407"];
10805 [label="this.SubmissionReturnType 261408"];
10806 [label="=> ScriptCompilationInfo 261409"];
10807 [label="ScriptCompilationInfo 261410"];
10808 [label="this.HostObjectType 261411"];
10809 [label="=> ScriptCompilationInfo 261412"];
10810 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261413"];
10811 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261414"];
10812 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261415"];
10813 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 261416"];
10814 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 261417"];
10815 [label="param CSharpCompilation(string? assemblyName) 261418"];
10816 [label="param CSharpCompilation(CSharpCompilationOptions options) 261419"];
10817 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 261420"];
10818 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 261421"];
10819 [label="param CSharpCompilation(Type? submissionReturnType) 261422"];
10820 [label="param CSharpCompilation(Type? hostObjectType) 261423"];
10821 [label="param CSharpCompilation(bool isSubmission) 261424"];
10822 [label="param CSharpCompilation(ReferenceManager? referenceManager) 261425"];
10823 [label="param CSharpCompilation(bool reuseReferenceManager) 261426"];
10824 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 261427"];
10825 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 261428"];
10826 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 261429"];
10827 [label="param CSharpCompilation(this) 261430"];
10828 [label="previousSubmission 261431"];
10829 [label="submissionReturnType 261432"];
10830 [label="hostObjectType 261433"];
10831 [label="syntaxAndDeclarations.ExternalSyntaxTrees 261434"];
10832 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 261435"];
10833 [label="get\n            {\n                return this.Options;\n            } 261436"];
10834 [label="this.Options 261437"];
10835 [label="get\n                {\n                    return _options;\n                } 261438"];
10836 [label="return _options; 261439"];
10837 [label="return this.Options; 261440"];
10838 [label="eventQueue 261441"];
10839 [label="param CSharpCompilation(this) 261442"];
10840 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 261443"];
10841 [label="param CSharpCompilation(Type? submissionReturnType) 261444"];
10842 [label="param CSharpCompilation(Type? hostObjectType) 261445"];
10843 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 261446"];
10844 [label="param CSharpCompilation(this) 261447"];
10845 [label="eventQueue 261448"];
10846 [label="param CSharpCompilation(this) 261449"];
10847 [label="_options 261450"];
10848 [label="_globalImports 261451"];
10849 [label="_previousSubmissionImports 261452"];
10850 [label="_globalNamespaceAlias 261453"];
10851 [label="_scriptClass 261454"];
10852 [label="_lazyHostObjectTypeSymbol 261455"];
10853 [label="_lazyImportInfos 261456"];
10854 [label="_conversions 261457"];
10855 [label="_anonymousTypeManager 261458"];
10856 [label="_lazyGlobalNamespace 261459"];
10857 [label="builtInOperators 261460"];
10858 [label="_lazyAssemblySymbol 261461"];
10859 [label="_referenceManager 261462"];
10860 [label="_syntaxAndDeclarations 261463"];
10861 [label="_lazyEntryPoint 261464"];
10862 [label="_lazyEmitNullablePublicOnly 261465"];
10863 [label="_lazyCompilationUnitCompletedTrees 261466"];
10864 [label="NullableAnalysisData 261467"];
10865 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 261468"];
10866 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 261469"];
10867 [label="_externAliasTargets 261470"];
10868 [label="_moduleInitializerMethods 261471"];
10869 [label="_binderFactories 261472"];
10870 [label="_ignoreAccessibilityBinderFactories 261473"];
10871 [label="_lazyDeclarationDiagnostics 261474"];
10872 [label="_declarationDiagnosticsFrozen 261475"];
10873 [label="new DiagnosticBag() 261476"];
10874 [label="_additionalCodegenWarnings = new DiagnosticBag() 261477"];
10875 [label="WellKnownMemberSignatureComparer 261478"];
10876 [label="_lazyWellKnownTypes 261479"];
10877 [label="_lazyWellKnownTypeMembers 261480"];
10878 [label="_usesNullableAttributes 261481"];
10879 [label="_needsGeneratedAttributes 261482"];
10880 [label="_needsGeneratedAttributes_IsFrozen 261483"];
10881 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 261484"];
10882 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 261485"];
10883 [label="new WellKnownMembersSignatureComparer(this) 261486"];
10884 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 261487"];
10885 [label="param WellKnownMembersSignatureComparer(this) 261488"];
10886 [label="param WellKnownMembersSignatureComparer(this) 261489"];
10887 [label="param SpecialMembersSignatureComparer(this) 261490"];
10888 [label="param SpecialMembersSignatureComparer(this) 261491"];
10889 [label="_compilation 261492"];
10890 [label="_compilation 261493"];
10891 [label="WellKnownMemberSignatureComparer 261494"];
10892 [label="this.builtInOperators = new BuiltInOperators(this); 261495"];
10893 [label="this.builtInOperators = new BuiltInOperators(this); 261496"];
10894 [label="new BuiltInOperators(this) 261497"];
10895 [label="param BuiltInOperators(CSharpCompilation compilation) 261498"];
10896 [label="param BuiltInOperators(this) 261499"];
10897 [label="_compilation 261500"];
10898 [label="_builtInUnaryOperators 261501"];
10899 [label="_builtInOperators 261502"];
10900 [label="_compilation 261503"];
10901 [label="this.builtInOperators 261504"];
10902 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 261505"];
10903 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 261506"];
10904 [label="new AnonymousTypeManager(this) 261507"];
10905 [label="param AnonymousTypeManager(CSharpCompilation compilation) 261508"];
10906 [label="param AnonymousTypeManager(this) 261509"];
10907 [label="param AnonymousTypeManager(this) 261510"];
10908 [label="public CSharpCompilation Compilation { get; } 261511"];
10909 [label="_lazyAnonymousTypeTemplates 261512"];
10910 [label="_lazySynthesizedDelegates 261513"];
10911 [label="new ConcurrentDictionary<Location, bool>() 261514"];
10912 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 261515"];
10913 [label="Debug.Assert(compilation != null); 261516"];
10914 [label="Debug.Assert(compilation != null); 261517"];
10915 [label="this.Compilation 261518"];
10916 [label="_anonymousTypeManager 261519"];
10917 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 261520"];
10918 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 261521"];
10919 [label="LanguageVersion? result = null; 261522"];
10920 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 261523"];
10921 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 261524"];
10922 [label="tree.Options 261525"];
10923 [label="get\n            {\n                return this.Options;\n            } 261526"];
10924 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 261527"];
10925 [label="result = version; 261528"];
10926 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 261529"];
10927 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261530"];
10928 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261531"];
10929 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261532"];
10930 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261533"];
10931 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261534"];
10932 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 261535"];
10933 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 261536"];
10934 [label="referenceManager.AssertCanReuseForCompilation(this); 261537"];
10935 [label="referenceManager.AssertCanReuseForCompilation(this); 261538"];
10936 [label="_referenceManager 261539"];
10937 [label="Debug.Assert(_lazyAssemblySymbol is null); 261540"];
10938 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 261541"];
10939 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 261542"];
10940 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 261543"];
10941 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 261544"];
10942 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 261545"];
10943 [label="return compilation; 261546"];
10944 [label="var compilation = createCompilationLambda(); 261547"];
10945 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 261548"];
10946 [label="IsNullableEnabled(compilation) 261549"];
10947 [label="param IsNullableEnabled(CSharpCompilation compilation) 261550"];
10948 [label="compilation.SyntaxTrees 261551"];
10949 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 261552"];
10950 [label="_syntaxAndDeclarations.GetLazyState() 261553"];
10951 [label="param GetLazyState(this) 261554"];
10952 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 261555"];
10953 [label="if (_lazyState == null)\n            {\n                Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null);\n            } 261556"];
10954 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 261557"];
10955 [label="CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission) 261558"];
10956 [label="param CreateState(ImmutableArray<SyntaxTree> externalSyntaxTrees) 261559"];
10957 [label="param CreateState(string scriptClassName) 261560"];
10958 [label="param CreateState(SourceReferenceResolver resolver) 261561"];
10959 [label="param CreateState(CommonMessageProvider messageProvider) 261562"];
10960 [label="param CreateState(bool isSubmission) 261563"];
10961 [label="var treesBuilder = ArrayBuilder<SyntaxTree>.GetInstance(); 261564"];
10962 [label="var ordinalMapBuilder = PooledDictionary<SyntaxTree, int>.GetInstance(); 261565"];
10963 [label="var loadDirectiveMapBuilder = PooledDictionary<SyntaxTree, ImmutableArray<LoadDirective>>.GetInstance(); 261566"];
10964 [label="var loadedSyntaxTreeMapBuilder = PooledDictionary<string, SyntaxTree>.GetInstance(); 261567"];
10965 [label="var declMapBuilder = PooledDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>>.GetInstance(); 261568"];
10966 [label="allOlderRootDeclarations: ImmutableSetWithInsertionOrder<RootSingleNamespaceDeclaration>.Empty 261569"];
10967 [label="null 261570"];
10968 [label="latestLazyRootDeclaration: null 261571"];
10969 [label="null 261572"];
10970 [label="cache: null 261573"];
10971 [label="new DeclarationTable(\n            allOlderRootDeclarations: ImmutableSetWithInsertionOrder<RootSingleNamespaceDeclaration>.Empty,\n            latestLazyRootDeclaration: null,\n            cache: null) 261574"];
10972 [label="param DeclarationTable(ImmutableSetWithInsertionOrder<RootSingleNamespaceDeclaration> allOlderRootDeclarations) 261575"];
10973 [label="param DeclarationTable(Lazy<RootSingleNamespaceDeclaration> latestLazyRootDeclaration) 261576"];
10974 [label="param DeclarationTable(Cache cache) 261577"];
10975 [label="param DeclarationTable(this) 261578"];
10976 [label="_allOlderRootDeclarations 261579"];
10977 [label="_latestLazyRootDeclaration 261580"];
10978 [label="_cache 261581"];
10979 [label="_mergedRoot 261582"];
10980 [label="_typeNames 261583"];
10981 [label="_namespaceNames 261584"];
10982 [label="_referenceDirectives 261585"];
10983 [label="_allOlderRootDeclarations 261586"];
10984 [label="_latestLazyRootDeclaration 261587"];
10985 [label="_cache = cache ?? new Cache(this); 261588"];
10986 [label="_cache = cache ?? new Cache(this); 261589"];
10987 [label="new Cache(this) 261590"];
10988 [label="param Cache(DeclarationTable table) 261591"];
10989 [label="param Cache(this) 261592"];
10990 [label="MergedRoot 261593"];
10991 [label="TypeNames 261594"];
10992 [label="NamespaceNames 261595"];
10993 [label="ReferenceDirectives 261596"];
10994 [label="this.MergedRoot = new Lazy<MergedNamespaceDeclaration>(\n                    () => MergedNamespaceDeclaration.Create(table._allOlderRootDeclarations.InInsertionOrder.AsImmutable<SingleNamespaceDeclaration>())); 261597"];
10995 [label="this.MergedRoot 261598"];
10996 [label="this.TypeNames = new Lazy<ISet<string>>(\n                    () => GetTypeNames(this.MergedRoot.Value)); 261599"];
10997 [label="this.TypeNames 261600"];
10998 [label="this.NamespaceNames = new Lazy<ISet<string>>(\n                    () => GetNamespaceNames(this.MergedRoot.Value)); 261601"];
10999 [label="this.NamespaceNames 261602"];
11000 [label="this.ReferenceDirectives = new Lazy<ImmutableArray<ReferenceDirective>>(\n                    () => MergedRoot.Value.Declarations.OfType<RootSingleNamespaceDeclaration>().SelectMany(r => r.ReferenceDirectives).AsImmutable()); 261603"];
11001 [label="this.ReferenceDirectives 261604"];
11002 [label="_cache = cache ?? new Cache(this); 261605"];
11003 [label="_cache 261606"];
11004 [label="_typeNames = new Lazy<ICollection<string>>(GetMergedTypeNames); 261607"];
11005 [label="_typeNames 261608"];
11006 [label="_namespaceNames = new Lazy<ICollection<string>>(GetMergedNamespaceNames); 261609"];
11007 [label="_namespaceNames 261610"];
11008 [label="_referenceDirectives = new Lazy<ICollection<ReferenceDirective>>(GetMergedReferenceDirectives); 261611"];
11009 [label="_referenceDirectives 261612"];
11010 [label="Empty = new DeclarationTable(\n            allOlderRootDeclarations: ImmutableSetWithInsertionOrder<RootSingleNamespaceDeclaration>.Empty,\n            latestLazyRootDeclaration: null,\n            cache: null) 261613"];
11011 [label="d => d.Kind == DeclarationKind.Namespace 261614"];
11012 [label="s_isNamespacePredicate = d => d.Kind == DeclarationKind.Namespace 261615"];
11013 [label="d => d.Kind != DeclarationKind.Namespace 261616"];
11014 [label="s_isTypePredicate = d => d.Kind != DeclarationKind.Namespace 261617"];
11015 [label="var declTable = DeclarationTable.Empty; 261618"];
11016 [label="foreach (var tree in externalSyntaxTrees)\n            {\n                AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable);\n            } 261619"];
11017 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261620"];
11018 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261621"];
11019 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261622"];
11020 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261623"];
11021 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261624"];
11022 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261625"];
11023 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261626"];
11024 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261627"];
11025 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261628"];
11026 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261629"];
11027 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable); 261630"];
11028 [label="AppendAllSyntaxTrees(\n                    treesBuilder,\n                    tree,\n                    scriptClassName,\n                    resolver,\n                    messageProvider,\n                    isSubmission,\n                    ordinalMapBuilder,\n                    loadDirectiveMapBuilder,\n                    loadedSyntaxTreeMapBuilder,\n                    declMapBuilder,\n                    ref declTable) 261631"];
11029 [label="param AppendAllSyntaxTrees(ArrayBuilder<SyntaxTree> treesBuilder) 261632"];
11030 [label="param AppendAllSyntaxTrees(SyntaxTree tree) 261633"];
11031 [label="param AppendAllSyntaxTrees(string scriptClassName) 261634"];
11032 [label="param AppendAllSyntaxTrees(SourceReferenceResolver resolver) 261635"];
11033 [label="param AppendAllSyntaxTrees(CommonMessageProvider messageProvider) 261636"];
11034 [label="param AppendAllSyntaxTrees(bool isSubmission) 261637"];
11035 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, int> ordinalMapBuilder) 261638"];
11036 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMapBuilder) 261639"];
11037 [label="param AppendAllSyntaxTrees(IDictionary<string, SyntaxTree> loadedSyntaxTreeMapBuilder) 261640"];
11038 [label="param AppendAllSyntaxTrees(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 261641"];
11039 [label="param AppendAllSyntaxTrees(ref DeclarationTable declTable) 261642"];
11040 [label="var sourceCodeKind = tree.Options.Kind; 261643"];
11041 [label="tree.Options 261644"];
11042 [label="get\n            {\n                return this.Options;\n            } 261645"];
11043 [label="if (sourceCodeKind == SourceCodeKind.Script)\n            {\n                AppendAllLoadedSyntaxTrees(treesBuilder, tree, scriptClassName, resolver, messageProvider, isSubmission, ordinalMapBuilder, loadDirectiveMapBuilder, loadedSyntaxTreeMapBuilder, declMapBuilder, ref declTable);\n            } 261646"];
11044 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261647"];
11045 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261648"];
11046 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261649"];
11047 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261650"];
11048 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261651"];
11049 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable) 261652"];
11050 [label="param AddSyntaxTreeToDeclarationMapAndTable(SyntaxTree tree) 261653"];
11051 [label="param AddSyntaxTreeToDeclarationMapAndTable(string scriptClassName) 261654"];
11052 [label="param AddSyntaxTreeToDeclarationMapAndTable(bool isSubmission) 261655"];
11053 [label="param AddSyntaxTreeToDeclarationMapAndTable(IDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> declMapBuilder) 261656"];
11054 [label="param AddSyntaxTreeToDeclarationMapAndTable(ref DeclarationTable declTable) 261657"];
11055 [label="var lazyRoot = new Lazy<RootSingleNamespaceDeclaration>(() => DeclarationTreeBuilder.ForTree(tree, scriptClassName, isSubmission)); 261658"];
11056 [label="var lazyRoot = new Lazy<RootSingleNamespaceDeclaration>(() => DeclarationTreeBuilder.ForTree(tree, scriptClassName, isSubmission)); 261659"];
11057 [label="declMapBuilder.Add(tree, lazyRoot); 261660"];
11058 [label="declMapBuilder.Add(tree, lazyRoot); 261661"];
11059 [label="declMapBuilder.Add(tree, lazyRoot); 261662"];
11060 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 261663"];
11061 [label="declTable.AddRootDeclaration(lazyRoot) 261664"];
11062 [label="param AddRootDeclaration(Lazy<RootSingleNamespaceDeclaration> lazyRootDeclaration) 261665"];
11063 [label="param AddRootDeclaration(this) 261666"];
11064 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache);\n            }\n            else\n            {\n                // we already had a 'latest' item.  This means we're hearing about a change to a\n                // different tree.  Realize the old latest item, add it to the 'oldest' collection\n                // and don't reuse the cache.\n                return new DeclarationTable(_allOlderRootDeclarations.Add(_latestLazyRootDeclaration.Value), lazyRootDeclaration, cache: null);\n            } 261667"];
11065 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache);\n            }\n            else\n            {\n                // we already had a 'latest' item.  This means we're hearing about a change to a\n                // different tree.  Realize the old latest item, add it to the 'oldest' collection\n                // and don't reuse the cache.\n                return new DeclarationTable(_allOlderRootDeclarations.Add(_latestLazyRootDeclaration.Value), lazyRootDeclaration, cache: null);\n            } 261668"];
11066 [label="return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache); 261669"];
11067 [label="return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache); 261670"];
11068 [label="return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache); 261671"];
11069 [label="return new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache); 261672"];
11070 [label="new DeclarationTable(_allOlderRootDeclarations, lazyRootDeclaration, _cache) 261673"];
11071 [label="param DeclarationTable(ImmutableSetWithInsertionOrder<RootSingleNamespaceDeclaration> allOlderRootDeclarations) 261674"];
11072 [label="param DeclarationTable(Lazy<RootSingleNamespaceDeclaration> latestLazyRootDeclaration) 261675"];
11073 [label="param DeclarationTable(Cache cache) 261676"];
11074 [label="param DeclarationTable(this) 261677"];
11075 [label="_allOlderRootDeclarations 261678"];
11076 [label="_latestLazyRootDeclaration 261679"];
11077 [label="_cache 261680"];
11078 [label="_mergedRoot 261681"];
11079 [label="_typeNames 261682"];
11080 [label="_namespaceNames 261683"];
11081 [label="_referenceDirectives 261684"];
11082 [label="_typeNames = new Lazy<ICollection<string>>(GetMergedTypeNames); 261685"];
11083 [label="_typeNames 261686"];
11084 [label="_namespaceNames = new Lazy<ICollection<string>>(GetMergedNamespaceNames); 261687"];
11085 [label="_namespaceNames 261688"];
11086 [label="_referenceDirectives = new Lazy<ICollection<ReferenceDirective>>(GetMergedReferenceDirectives); 261689"];
11087 [label="_referenceDirectives 261690"];
11088 [label="declTable = declTable.AddRootDeclaration(lazyRoot); 261691"];
11089 [label="AddSyntaxTreeToDeclarationMapAndTable(tree, scriptClassName, isSubmission, declMapBuilder, ref declTable); 261692"];
11090 [label="treesBuilder.Add(tree); 261693"];
11091 [label="treesBuilder.Add(tree); 261694"];
11092 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 261695"];
11093 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 261696"];
11094 [label="ordinalMapBuilder.Add(tree, ordinalMapBuilder.Count); 261697"];
11095 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261698"];
11096 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261699"];
11097 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261700"];
11098 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261701"];
11099 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261702"];
11100 [label="return new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable); 261703"];
11101 [label="new State(\n                treesBuilder.ToImmutableAndFree(),\n                ordinalMapBuilder.ToImmutableDictionaryAndFree(),\n                loadDirectiveMapBuilder.ToImmutableDictionaryAndFree(),\n                loadedSyntaxTreeMapBuilder.ToImmutableDictionaryAndFree(),\n                declMapBuilder.ToImmutableDictionaryAndFree(),\n                declTable) 261704"];
11102 [label="param State(ImmutableArray<SyntaxTree> syntaxTrees) 261705"];
11103 [label="param State(ImmutableDictionary<SyntaxTree, int> syntaxTreeOrdinalMap) 261706"];
11104 [label="param State(ImmutableDictionary<SyntaxTree, ImmutableArray<LoadDirective>> loadDirectiveMap) 261707"];
11105 [label="param State(ImmutableDictionary<string, SyntaxTree> loadedSyntaxTreeMap) 261708"];
11106 [label="param State(ImmutableDictionary<SyntaxTree, Lazy<RootSingleNamespaceDeclaration>> rootNamespaces) 261709"];
11107 [label="param State(DeclarationTable declarationTable) 261710"];
11108 [label="param State(this) 261711"];
11109 [label="OrdinalMap 261712"];
11110 [label="LoadDirectiveMap 261713"];
11111 [label="LoadedSyntaxTreeMap 261714"];
11112 [label="RootNamespaces 261715"];
11113 [label="DeclarationTable 261716"];
11114 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 261717"];
11115 [label="Debug.Assert(syntaxTrees.All(tree => syntaxTrees[syntaxTreeOrdinalMap[tree]] == tree)); 261718"];
11116 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 261719"];
11117 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 261720"];
11118 [label="Debug.Assert(syntaxTrees.SetEquals(rootNamespaces.Keys.AsImmutable(), EqualityComparer<SyntaxTree>.Default)); 261721"];
11119 [label="this.SyntaxTrees 261722"];
11120 [label="this.OrdinalMap 261723"];
11121 [label="this.LoadDirectiveMap 261724"];
11122 [label="this.LoadedSyntaxTreeMap 261725"];
11123 [label="this.RootNamespaces 261726"];
11124 [label="this.DeclarationTable 261727"];
11125 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 261728"];
11126 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 261729"];
11127 [label="Interlocked.CompareExchange(ref _lazyState, CreateState(this.ExternalSyntaxTrees, this.ScriptClassName, this.Resolver, this.MessageProvider, this.IsSubmission), null); 261730"];
11128 [label="return _lazyState; 261731"];
11129 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 261732"];
11130 [label="var trees = compilation.SyntaxTrees; 261733"];
11131 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 261734"];
11132 [label="var options = (CSharpParseOptions)trees[0].Options; 261735"];
11133 [label="var options = (CSharpParseOptions)trees[0].Options; 261736"];
11134 [label="trees[0].Options 261737"];
11135 [label="get\n            {\n                return this.Options;\n            } 261738"];
11136 [label="this.Options 261739"];
11137 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 261740"];
11138 [label="options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes) 261741"];
11139 [label="param IsFeatureEnabled(MessageID feature) 261742"];
11140 [label="param IsFeatureEnabled(this) 261743"];
11141 [label="string? featureFlag = feature.RequiredFeature(); 261744"];
11142 [label="feature.RequiredFeature() 261745"];
11143 [label="param RequiredFeature(this MessageID feature) 261746"];
11144 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 261747"];
11145 [label="return null; 261748"];
11146 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 261749"];
11147 [label="if (featureFlag != null)\n            {\n                return Features.ContainsKey(featureFlag);\n            } 261750"];
11148 [label="LanguageVersion availableVersion = LanguageVersion; 261751"];
11149 [label="LanguageVersion requiredVersion = feature.RequiredVersion(); 261752"];
11150 [label="feature.RequiredVersion() 261753"];
11151 [label="param RequiredVersion(this MessageID feature) 261754"];
11152 [label="Debug.Assert(RequiredFeature(feature) == null); 261755"];
11153 [label="RequiredFeature(feature) 261756"];
11154 [label="param RequiredFeature(this MessageID feature) 261757"];
11155 [label="switch (feature)\n            {\n                default:\n                    return null;\n            } 261758"];
11156 [label="return null; 261759"];
11157 [label="Debug.Assert(RequiredFeature(feature) == null); 261760"];
11158 [label="switch (feature)\n            {\n                // C# preview features.\n                case MessageID.IDS_FeatureMixedDeclarationsAndExpressionsInDeconstruction:\n                    return LanguageVersion.Preview;\n                // C# 9.0 features.\n                case MessageID.IDS_FeatureLambdaDiscardParameters: // semantic check\n                case MessageID.IDS_FeatureFunctionPointers:\n                case MessageID.IDS_FeatureLocalFunctionAttributes: // syntax check\n                case MessageID.IDS_FeatureExternLocalFunctions: // syntax check\n                case MessageID.IDS_FeatureImplicitObjectCreation: // syntax check\n                case MessageID.IDS_FeatureMemberNotNull:\n                case MessageID.IDS_FeatureAndPattern:\n                case MessageID.IDS_FeatureNotPattern:\n                case MessageID.IDS_FeatureOrPattern:\n                case MessageID.IDS_FeatureParenthesizedPattern:\n                case MessageID.IDS_FeatureTypePattern:\n                case MessageID.IDS_FeatureRelationalPattern:\n                case MessageID.IDS_FeatureExtensionGetEnumerator: // semantic check\n                case MessageID.IDS_FeatureExtensionGetAsyncEnumerator: // semantic check\n                case MessageID.IDS_FeatureNativeInt:\n                case MessageID.IDS_FeatureExtendedPartialMethods: // semantic check\n                case MessageID.IDS_TopLevelStatements:\n                case MessageID.IDS_FeatureInitOnlySetters: // semantic check\n                case MessageID.IDS_FeatureRecords:\n                case MessageID.IDS_FeatureTargetTypedConditional:  // semantic check\n                case MessageID.IDS_FeatureCovariantReturnsForOverrides: // semantic check\n                case MessageID.IDS_FeatureStaticAnonymousFunction: // syntax check\n                case MessageID.IDS_FeatureModuleInitializers: // semantic check on method attribute\n                case MessageID.IDS_FeatureDefaultTypeParameterConstraint:\n                    return LanguageVersion.CSharp9;\n\n                case MessageID.IDS_FeatureVarianceSafetyForStaticInterfaceMembers: //semantic check\n                case MessageID.IDS_FeatureConstantInterpolatedStrings: //semantic check\n                    return LanguageVersion.Preview;\n\n                // C# 8.0 features.\n                case MessageID.IDS_FeatureAltInterpolatedVerbatimStrings:\n                case MessageID.IDS_FeatureCoalesceAssignmentExpression:\n                case MessageID.IDS_FeatureUnconstrainedTypeParameterInNullCoalescingOperator:\n                case MessageID.IDS_FeatureNullableReferenceTypes: // syntax and semantic check\n                case MessageID.IDS_FeatureIndexOperator: // semantic check\n                case MessageID.IDS_FeatureRangeOperator: // semantic check\n                case MessageID.IDS_FeatureAsyncStreams:\n                case MessageID.IDS_FeatureRecursivePatterns:\n                case MessageID.IDS_FeatureUsingDeclarations:\n                case MessageID.IDS_FeatureStaticLocalFunctions:\n                case MessageID.IDS_FeatureNameShadowingInNestedFunctions:\n                case MessageID.IDS_FeatureUnmanagedConstructedTypes: // semantic check\n                case MessageID.IDS_FeatureObsoleteOnPropertyAccessor:\n                case MessageID.IDS_FeatureReadOnlyMembers:\n                case MessageID.IDS_DefaultInterfaceImplementation: // semantic check\n                case MessageID.IDS_OverrideWithConstraints: // semantic check\n                case MessageID.IDS_FeatureNestedStackalloc: // semantic check\n                case MessageID.IDS_FeatureNotNullGenericTypeConstraint:// semantic check\n                case MessageID.IDS_FeatureSwitchExpression:\n                case MessageID.IDS_FeatureAsyncUsing:\n                case MessageID.IDS_FeatureNullPointerConstantPattern: //semantic check\n                    return LanguageVersion.CSharp8;\n\n                // C# 7.3 features.\n                case MessageID.IDS_FeatureAttributesOnBackingFields: // semantic check\n                case MessageID.IDS_FeatureImprovedOverloadCandidates: // semantic check\n                case MessageID.IDS_FeatureTupleEquality: // semantic check\n                case MessageID.IDS_FeatureRefReassignment:\n                case MessageID.IDS_FeatureRefFor:\n                case MessageID.IDS_FeatureRefForEach:\n                case MessageID.IDS_FeatureEnumGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureDelegateGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureUnmanagedGenericTypeConstraint: // semantic check\n                case MessageID.IDS_FeatureStackAllocInitializer:\n                case MessageID.IDS_FeatureExpressionVariablesInQueriesAndInitializers: // semantic check\n                case MessageID.IDS_FeatureExtensibleFixedStatement:  // semantic check\n                case MessageID.IDS_FeatureIndexingMovableFixedBuffers: //semantic check\n                    return LanguageVersion.CSharp7_3;\n\n                // C# 7.2 features.\n                case MessageID.IDS_FeatureNonTrailingNamedArguments: // semantic check\n                case MessageID.IDS_FeatureLeadingDigitSeparator:\n                case MessageID.IDS_FeaturePrivateProtected:\n                case MessageID.IDS_FeatureReadOnlyReferences:\n                case MessageID.IDS_FeatureRefStructs:\n                case MessageID.IDS_FeatureReadOnlyStructs:\n                case MessageID.IDS_FeatureRefExtensionMethods:\n                case MessageID.IDS_FeatureRefConditional:\n                    return LanguageVersion.CSharp7_2;\n\n                // C# 7.1 features.\n                case MessageID.IDS_FeatureAsyncMain:\n                case MessageID.IDS_FeatureDefaultLiteral:\n                case MessageID.IDS_FeatureInferredTupleNames:\n                case MessageID.IDS_FeatureGenericPatternMatching:\n                    return LanguageVersion.CSharp7_1;\n\n                // C# 7 features.\n                case MessageID.IDS_FeatureBinaryLiteral:\n                case MessageID.IDS_FeatureDigitSeparator:\n                case MessageID.IDS_FeatureLocalFunctions:\n                case MessageID.IDS_FeatureRefLocalsReturns:\n                case MessageID.IDS_FeaturePatternMatching:\n                case MessageID.IDS_FeatureThrowExpression:\n                case MessageID.IDS_FeatureTuples:\n                case MessageID.IDS_FeatureOutVar:\n                case MessageID.IDS_FeatureExpressionBodiedAccessor:\n                case MessageID.IDS_FeatureExpressionBodiedDeOrConstructor:\n                case MessageID.IDS_FeatureDiscards:\n                    return LanguageVersion.CSharp7;\n\n                // C# 6 features.\n                case MessageID.IDS_FeatureExceptionFilter:\n                case MessageID.IDS_FeatureAutoPropertyInitializer:\n                case MessageID.IDS_FeatureNullPropagatingOperator:\n                case MessageID.IDS_FeatureExpressionBodiedMethod:\n                case MessageID.IDS_FeatureExpressionBodiedProperty:\n                case MessageID.IDS_FeatureExpressionBodiedIndexer:\n                case MessageID.IDS_FeatureNameof:\n                case MessageID.IDS_FeatureDictionaryInitializer:\n                case MessageID.IDS_FeatureUsingStatic:\n                case MessageID.IDS_FeatureInterpolatedStrings:\n                case MessageID.IDS_AwaitInCatchAndFinally:\n                case MessageID.IDS_FeatureReadonlyAutoImplementedProperties:\n                    return LanguageVersion.CSharp6;\n\n                // C# 5 features.\n                case MessageID.IDS_FeatureAsync:\n                    return LanguageVersion.CSharp5;\n\n                // C# 4 features.\n                case MessageID.IDS_FeatureDynamic: // Checked in the binder.\n                case MessageID.IDS_FeatureTypeVariance:\n                case MessageID.IDS_FeatureNamedArgument:\n                case MessageID.IDS_FeatureOptionalParameter:\n                    return LanguageVersion.CSharp4;\n\n                // C# 3 features.\n                case MessageID.IDS_FeatureImplicitArray:\n                case MessageID.IDS_FeatureAnonymousTypes:\n                case MessageID.IDS_FeatureObjectInitializer:\n                case MessageID.IDS_FeatureCollectionInitializer:\n                case MessageID.IDS_FeatureLambda:\n                case MessageID.IDS_FeatureQueryExpression:\n                case MessageID.IDS_FeatureExtensionMethod:\n                case MessageID.IDS_FeaturePartialMethod:\n                case MessageID.IDS_FeatureImplicitLocal: // Checked in the binder.\n                case MessageID.IDS_FeatureAutoImplementedProperties:\n                    return LanguageVersion.CSharp3;\n\n                // C# 2 features.\n                case MessageID.IDS_FeatureGenerics: // Also affects crefs.\n                case MessageID.IDS_FeatureAnonDelegates:\n                case MessageID.IDS_FeatureGlobalNamespace: // Also affects crefs.\n                case MessageID.IDS_FeatureFixedBuffer:\n                case MessageID.IDS_FeatureStaticClasses:\n                case MessageID.IDS_FeaturePartialTypes:\n                case MessageID.IDS_FeaturePropertyAccessorMods:\n                case MessageID.IDS_FeatureExternAlias:\n                case MessageID.IDS_FeatureIterators:\n                case MessageID.IDS_FeatureDefault:\n                case MessageID.IDS_FeatureNullable:\n                case MessageID.IDS_FeaturePragma: // Checked in the directive parser.\n                case MessageID.IDS_FeatureSwitchOnBool: // Checked in the binder.\n                    return LanguageVersion.CSharp2;\n\n                // Special C# 2 feature: only a warning in C# 1.\n                case MessageID.IDS_FeatureModuleAttrLoc:\n                    return LanguageVersion.CSharp1;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(feature);\n            } 261761"];
11159 [label="return LanguageVersion.CSharp8; 261762"];
11160 [label="return availableVersion >= requiredVersion; 261763"];
11161 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 261764"];
11162 [label="return compilation; 261765"];
11163 [label="comp.GlobalNamespace 261766"];
11164 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 261767"];
11165 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 261768"];
11166 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 261769"];
11167 [label="GetAllUnaliasedModules(modules); 261770"];
11168 [label="GetAllUnaliasedModules(modules) 261771"];
11169 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 261772"];
11170 [label="param GetAllUnaliasedModules(this) 261773"];
11171 [label="Assembly 261774"];
11172 [label="get\n            {\n                return SourceAssembly;\n            } 261775"];
11173 [label="SourceAssembly 261776"];
11174 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 261777"];
11175 [label="GetBoundReferenceManager() 261778"];
11176 [label="param GetBoundReferenceManager(this) 261779"];
11177 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 261780"];
11178 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 261781"];
11179 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 261782"];
11180 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 261783"];
11181 [label="param CreateSourceAssemblyForCompilation(this) 261784"];
11182 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 261785"];
11183 [label="CreateAndSetSourceAssemblyFullBind(compilation) 261786"];
11184 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 261787"];
11185 [label="param CreateAndSetSourceAssemblyFullBind(this) 261788"];
11186 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 261789"];
11187 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 261790"];
11188 [label="compilation.Options 261791"];
11189 [label="get\n            {\n                return _options;\n            } 261792"];
11190 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 261793"];
11191 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 261794"];
11192 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 261795"];
11193 [label="boundReferenceDirectives 261796"];
11194 [label="ImmutableArray<AssemblyData> referencedAssemblies; 261797"];
11195 [label="referencedAssemblies 261798"];
11196 [label="ImmutableArray<PEModule> modules; 261799"];
11197 [label="modules 261800"];
11198 [label="ImmutableArray<MetadataReference> explicitReferences; 261801"];
11199 [label="explicitReferences 261802"];
11200 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261803"];
11201 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261804"];
11202 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261805"];
11203 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261806"];
11204 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261807"];
11205 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261808"];
11206 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261809"];
11207 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261810"];
11208 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261811"];
11209 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 261812"];
11210 [label="get { return this.Declarations.ReferenceDirectives; } 261813"];
11211 [label="this.Declarations 261814"];
11212 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 261815"];
11213 [label="_syntaxAndDeclarations.GetLazyState() 261816"];
11214 [label="param GetLazyState(this) 261817"];
11215 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 261818"];
11216 [label="return this.Declarations.ReferenceDirectives; 261819"];
11217 [label="this.Declarations.ReferenceDirectives 261820"];
11218 [label="get\n            {\n                return _referenceDirectives.Value;\n            } 261821"];
11219 [label="return _referenceDirectives.Value; 261822"];
11220 [label="_referenceDirectives.Value 261823"];
11221 [label="param GetMergedReferenceDirectives(this) 261824"];
11222 [label="var cachedReferenceDirectives = _cache.ReferenceDirectives.Value; 261825"];
11223 [label="_cache.ReferenceDirectives.Value 261826"];
11224 [label="param Create(ImmutableArray<SingleNamespaceDeclaration> declarations) 261827"];
11225 [label="return new MergedNamespaceDeclaration(declarations); 261828"];
11226 [label="return new MergedNamespaceDeclaration(declarations); 261829"];
11227 [label="new MergedNamespaceDeclaration(declarations) 261830"];
11228 [label="param MergedNamespaceDeclaration(ImmutableArray<SingleNamespaceDeclaration> declarations) 261831"];
11229 [label="param MergedNamespaceDeclaration(this) 261832"];
11230 [label="declarations.IsEmpty 261833"];
11231 [label="string.Empty 261834"];
11232 [label="param MergedNamespaceDeclaration(this) 261835"];
11233 [label="param MergedNamespaceOrTypeDeclaration(string name) 261836"];
11234 [label="param MergedNamespaceOrTypeDeclaration(this) 261837"];
11235 [label="name 261838"];
11236 [label="param MergedNamespaceOrTypeDeclaration(this) 261839"];
11237 [label="param Declaration(string name) 261840"];
11238 [label="param Declaration(this) 261841"];
11239 [label="name 261842"];
11240 [label="this.name 261843"];
11241 [label="_declarations 261844"];
11242 [label="var cachedReferenceDirectives = _cache.ReferenceDirectives.Value; 261845"];
11243 [label="var cachedReferenceDirectives = _cache.ReferenceDirectives.Value; 261846"];
11244 [label="get { return _declarations; } 261847"];
11245 [label="return _declarations; 261848"];
11246 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return cachedReferenceDirectives;\n            }\n            else\n            {\n                return UnionCollection<ReferenceDirective>.Create(cachedReferenceDirectives, _latestLazyRootDeclaration.Value.ReferenceDirectives);\n            } 261849"];
11247 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return cachedReferenceDirectives;\n            }\n            else\n            {\n                return UnionCollection<ReferenceDirective>.Create(cachedReferenceDirectives, _latestLazyRootDeclaration.Value.ReferenceDirectives);\n            } 261850"];
11248 [label="() => ImmutableHashSet.CreateBuilder<string>() 261851"];
11249 [label="new ObjectPool<ImmutableHashSet<string>.Builder>(() => ImmutableHashSet.CreateBuilder<string>()) 261852"];
11250 [label="s_memberNameBuilderPool =\n            new ObjectPool<ImmutableHashSet<string>.Builder>(() => ImmutableHashSet.CreateBuilder<string>()) 261853"];
11251 [label="return UnionCollection<ReferenceDirective>.Create(cachedReferenceDirectives, _latestLazyRootDeclaration.Value.ReferenceDirectives); 261854"];
11252 [label="return UnionCollection<ReferenceDirective>.Create(cachedReferenceDirectives, _latestLazyRootDeclaration.Value.ReferenceDirectives); 261855"];
11253 [label="_latestLazyRootDeclaration.Value 261856"];
11254 [label="param ForTree(SyntaxTree syntaxTree) 261857"];
11255 [label="param ForTree(string scriptClassName) 261858"];
11256 [label="param ForTree(bool isSubmission) 261859"];
11257 [label="var builder = new DeclarationTreeBuilder(syntaxTree, scriptClassName, isSubmission); 261860"];
11258 [label="var builder = new DeclarationTreeBuilder(syntaxTree, scriptClassName, isSubmission); 261861"];
11259 [label="var builder = new DeclarationTreeBuilder(syntaxTree, scriptClassName, isSubmission); 261862"];
11260 [label="var builder = new DeclarationTreeBuilder(syntaxTree, scriptClassName, isSubmission); 261863"];
11261 [label="new DeclarationTreeBuilder(syntaxTree, scriptClassName, isSubmission) 261864"];
11262 [label="param DeclarationTreeBuilder(SyntaxTree syntaxTree) 261865"];
11263 [label="param DeclarationTreeBuilder(string scriptClassName) 261866"];
11264 [label="param DeclarationTreeBuilder(bool isSubmission) 261867"];
11265 [label="param DeclarationTreeBuilder(this) 261868"];
11266 [label="param DeclarationTreeBuilder(this) 261869"];
11267 [label="param CSharpSyntaxVisitor(this) 261870"];
11268 [label="_syntaxTree 261871"];
11269 [label="_scriptClassName 261872"];
11270 [label="_isSubmission 261873"];
11271 [label="_syntaxTree 261874"];
11272 [label="_scriptClassName 261875"];
11273 [label="_isSubmission 261876"];
11274 [label="return (RootSingleNamespaceDeclaration)builder.Visit(syntaxTree.GetRoot()); 261877"];
11275 [label="return (RootSingleNamespaceDeclaration)builder.Visit(syntaxTree.GetRoot()); 261878"];
11276 [label="param GetRoot(CancellationToken cancellationToken) 261879"];
11277 [label="builder.Visit(syntaxTree.GetRoot()) 261880"];
11278 [label="param Visit(SyntaxNode? node) 261881"];
11279 [label="param Visit(this) 261882"];
11280 [label="if (node != null)\n            {\n                return ((CSharpSyntaxNode)node).Accept(this);\n            } 261883"];
11281 [label="if (node != null)\n            {\n                return ((CSharpSyntaxNode)node).Accept(this);\n            } 261884"];
11282 [label="return ((CSharpSyntaxNode)node).Accept(this); 261885"];
11283 [label="return ((CSharpSyntaxNode)node).Accept(this); 261886"];
11284 [label="return ((CSharpSyntaxNode)node).Accept(this); 261887"];
11285 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 261888"];
11286 [label="param VisitCompilationUnit(this) 261889"];
11287 [label="if (_syntaxTree.Options.Kind != SourceCodeKind.Regular)\n            {\n                return CreateScriptRootDeclaration(compilationUnit);\n            } 261890"];
11288 [label="_syntaxTree.Options 261891"];
11289 [label="get\n            {\n                return this.Options;\n            } 261892"];
11290 [label="var children = VisitNamespaceChildren(compilationUnit, compilationUnit.Members, ((Syntax.InternalSyntax.CompilationUnitSyntax)(compilationUnit.Green)).Members); 261893"];
11291 [label="var children = VisitNamespaceChildren(compilationUnit, compilationUnit.Members, ((Syntax.InternalSyntax.CompilationUnitSyntax)(compilationUnit.Green)).Members); 261894"];
11292 [label="VisitNamespaceChildren(compilationUnit, compilationUnit.Members, ((Syntax.InternalSyntax.CompilationUnitSyntax)(compilationUnit.Green)).Members) 261895"];
11293 [label="param VisitNamespaceChildren(CSharpSyntaxNode node) 261896"];
11294 [label="param VisitNamespaceChildren(SyntaxList<MemberDeclarationSyntax> members) 261897"];
11295 [label="param VisitNamespaceChildren(CoreInternalSyntax.SyntaxList<Syntax.InternalSyntax.MemberDeclarationSyntax> internalMembers) 261898"];
11296 [label="param VisitNamespaceChildren(this) 261899"];
11297 [label="node.Kind() 261900"];
11298 [label="param Kind(this) 261901"];
11299 [label="return (SyntaxKind)this.Green.RawKind; 261902"];
11300 [label="Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); 261903"];
11301 [label="node.Kind() 261904"];
11302 [label="param Kind(this) 261905"];
11303 [label="return (SyntaxKind)this.Green.RawKind; 261906"];
11304 [label="Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); 261907"];
11305 [label="Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); 261908"];
11306 [label="_syntaxTree.Options 261909"];
11307 [label="get\n            {\n                return this.Options;\n            } 261910"];
11308 [label="Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); 261911"];
11309 [label="Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); 261912"];
11310 [label="if (members.Count == 0)\n            {\n                return ImmutableArray<SingleNamespaceOrTypeDeclaration>.Empty;\n            } 261913"];
11311 [label="if (members.Count == 0)\n            {\n                return ImmutableArray<SingleNamespaceOrTypeDeclaration>.Empty;\n            } 261914"];
11312 [label="bool hasGlobalMembers = false; 261915"];
11313 [label="node.Kind() 261916"];
11314 [label="param Kind(this) 261917"];
11315 [label="return (SyntaxKind)this.Green.RawKind; 261918"];
11316 [label="bool acceptSimpleProgram = node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular; 261919"];
11317 [label="bool acceptSimpleProgram = node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular; 261920"];
11318 [label="_syntaxTree.Options 261921"];
11319 [label="get\n            {\n                return this.Options;\n            } 261922"];
11320 [label="bool acceptSimpleProgram = node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular; 261923"];
11321 [label="bool hasAwaitExpressions = false; 261924"];
11322 [label="bool isIterator = false; 261925"];
11323 [label="bool hasReturnWithExpression = false; 261926"];
11324 [label="GlobalStatementSyntax firstGlobalStatement = null; 261927"];
11325 [label="var childrenBuilder = ArrayBuilder<SingleNamespaceOrTypeDeclaration>.GetInstance(); 261928"];
11326 [label="foreach (var member in members)\n            {\n                SingleNamespaceOrTypeDeclaration namespaceOrType = Visit(member);\n                if (namespaceOrType != null)\n                {\n                    childrenBuilder.Add(namespaceOrType);\n                }\n                else if (acceptSimpleProgram && member.IsKind(SyntaxKind.GlobalStatement))\n                {\n                    var global = (GlobalStatementSyntax)member;\n                    // LAFHIS\n                    if (firstGlobalStatement == null)\n                        firstGlobalStatement = global;\n                    var topLevelStatement = global.Statement;\n\n                    if (!hasAwaitExpressions)\n                    {\n                        hasAwaitExpressions = SyntaxFacts.HasAwaitOperations(topLevelStatement);\n                    }\n\n                    if (!isIterator)\n                    {\n                        isIterator = SyntaxFacts.HasYieldOperations(topLevelStatement);\n                    }\n\n                    if (!hasReturnWithExpression)\n                    {\n                        hasReturnWithExpression = SyntaxFacts.HasReturnWithExpression(topLevelStatement);\n                    }\n                }\n                else if (!hasGlobalMembers && member.Kind() != SyntaxKind.IncompleteMember)\n                {\n                    hasGlobalMembers = true;\n                }\n            } 261929"];
11327 [label="SingleNamespaceOrTypeDeclaration namespaceOrType = Visit(member); 261930"];
11328 [label="Visit(member) 261931"];
11329 [label="param Visit(SyntaxNode? node) 261932"];
11330 [label="param Visit(this) 261933"];
11331 [label="return ((CSharpSyntaxNode)node).Accept(this); 261934"];
11332 [label="return ((CSharpSyntaxNode)node).Accept(this); 261935"];
11333 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) 261936"];
11334 [label="param VisitNamespaceDeclaration(this) 261937"];
11335 [label="var children = VisitNamespaceChildren(node, node.Members, node.Green.Members); 261938"];
11336 [label="var children = VisitNamespaceChildren(node, node.Members, node.Green.Members); 261939"];
11337 [label="node.Green 261940"];
11338 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 261941"];
11339 [label="return (InternalSyntax.NamespaceDeclarationSyntax)base.Green; 261942"];
11340 [label="var children = VisitNamespaceChildren(node, node.Members, node.Green.Members); 261943"];
11341 [label="VisitNamespaceChildren(node, node.Members, node.Green.Members) 261944"];
11342 [label="param VisitNamespaceChildren(CSharpSyntaxNode node) 261945"];
11343 [label="param VisitNamespaceChildren(SyntaxList<MemberDeclarationSyntax> members) 261946"];
11344 [label="param VisitNamespaceChildren(CoreInternalSyntax.SyntaxList<Syntax.InternalSyntax.MemberDeclarationSyntax> internalMembers) 261947"];
11345 [label="param VisitNamespaceChildren(this) 261948"];
11346 [label="node.Kind() 261949"];
11347 [label="param Kind(this) 261950"];
11348 [label="if (members.Count == 0)\n            {\n                return ImmutableArray<SingleNamespaceOrTypeDeclaration>.Empty;\n            } 261951"];
11349 [label="if (members.Count == 0)\n            {\n                return ImmutableArray<SingleNamespaceOrTypeDeclaration>.Empty;\n            } 261952"];
11350 [label="bool hasGlobalMembers = false; 261953"];
11351 [label="node.Kind() 261954"];
11352 [label="param Kind(this) 261955"];
11353 [label="bool hasAwaitExpressions = false; 261956"];
11354 [label="bool isIterator = false; 261957"];
11355 [label="bool hasReturnWithExpression = false; 261958"];
11356 [label="GlobalStatementSyntax firstGlobalStatement = null; 261959"];
11357 [label="var childrenBuilder = ArrayBuilder<SingleNamespaceOrTypeDeclaration>.GetInstance(); 261960"];
11358 [label="param Visit(this) 261961"];
11359 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 261962"];
11360 [label="param VisitClassDeclaration(this) 261963"];
11361 [label="return VisitTypeDeclaration(node, DeclarationKind.Class); 261964"];
11362 [label="return VisitTypeDeclaration(node, DeclarationKind.Class); 261965"];
11363 [label="VisitTypeDeclaration(node, DeclarationKind.Class) 261966"];
11364 [label="param VisitTypeDeclaration(TypeDeclarationSyntax node) 261967"];
11365 [label="param VisitTypeDeclaration(DeclarationKind kind) 261968"];
11366 [label="param VisitTypeDeclaration(this) 261969"];
11367 [label="SingleTypeDeclaration.TypeDeclarationFlags declFlags = node.AttributeLists.Any() ?\n                SingleTypeDeclaration.TypeDeclarationFlags.HasAnyAttributes :\n                SingleTypeDeclaration.TypeDeclarationFlags.None; 261970"];
11368 [label="node.AttributeLists.Any() 261971"];
11369 [label="if (node.BaseList != null)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasBaseDeclarations;\n            } 261972"];
11370 [label="if (node.BaseList != null)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasBaseDeclarations;\n            } 261973"];
11371 [label="var diagnostics = DiagnosticBag.GetInstance(); 261974"];
11372 [label="node.Arity 261975"];
11373 [label="get\n            {\n                return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count;\n            } 261976"];
11374 [label="return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count; 261977"];
11375 [label="return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count; 261978"];
11376 [label="this.TypeParameterList == null 261979"];
11377 [label="if (node.Arity == 0)\n            {\n                Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics);\n            } 261980"];
11378 [label="if (node.Arity == 0)\n            {\n                Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics);\n            } 261981"];
11379 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 261982"];
11380 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 261983"];
11381 [label="SymbolDisplayCompilerInternalOptions.None 261984"];
11382 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 261985"];
11383 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 261986"];
11384 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 261987"];
11385 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 261988"];
11386 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics) 261989"];
11387 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 261990"];
11388 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 261991"];
11389 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 261992"];
11390 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 261993"];
11391 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 261994"];
11392 [label="var memberNames = GetNonTypeMemberNames(((Syntax.InternalSyntax.TypeDeclarationSyntax)(node.Green)).Members,\n                                                    ref declFlags); 261995"];
11393 [label="var memberNames = GetNonTypeMemberNames(((Syntax.InternalSyntax.TypeDeclarationSyntax)(node.Green)).Members,\n                                                    ref declFlags); 261996"];
11394 [label="var memberNames = GetNonTypeMemberNames(((Syntax.InternalSyntax.TypeDeclarationSyntax)(node.Green)).Members,\n                                                    ref declFlags); 261997"];
11395 [label="GetNonTypeMemberNames(((Syntax.InternalSyntax.TypeDeclarationSyntax)(node.Green)).Members,\n                                                    ref declFlags) 261998"];
11396 [label="param GetNonTypeMemberNames(CoreInternalSyntax.SyntaxList<Syntax.InternalSyntax.MemberDeclarationSyntax> members) 261999"];
11397 [label="param GetNonTypeMemberNames(ref SingleTypeDeclaration.TypeDeclarationFlags declFlags) 262000"];
11398 [label="param GetNonTypeMemberNames(bool skipGlobalStatements = false) 262001"];
11399 [label="bool anyMethodHadExtensionSyntax = false; 262002"];
11400 [label="bool anyMemberHasAttributes = false; 262003"];
11401 [label="bool anyNonTypeMembers = false; 262004"];
11402 [label="var memberNameBuilder = s_memberNameBuilderPool.Allocate(); 262005"];
11403 [label="foreach (var member in members)\n            {\n                AddNonTypeMemberNames(member, memberNameBuilder, ref anyNonTypeMembers, skipGlobalStatements);\n\n                // Check to see if any method contains a 'this' modifier on its first parameter.\n                // This data is used to determine if a type needs to have its members materialized\n                // as part of extension method lookup.\n                if (!anyMethodHadExtensionSyntax && CheckMethodMemberForExtensionSyntax(member))\n                {\n                    anyMethodHadExtensionSyntax = true;\n                }\n\n                if (!anyMemberHasAttributes && CheckMemberForAttributes(member))\n                {\n                    anyMemberHasAttributes = true;\n                }\n            } 262006"];
11404 [label="if (anyMethodHadExtensionSyntax)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.AnyMemberHasExtensionMethodSyntax;\n            } 262007"];
11405 [label="if (anyMemberHasAttributes)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.AnyMemberHasAttributes;\n            } 262008"];
11406 [label="if (anyNonTypeMembers)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262009"];
11407 [label="return ToImmutableAndFree(memberNameBuilder); 262010"];
11408 [label="ToImmutableAndFree(memberNameBuilder) 262011"];
11409 [label="param ToImmutableAndFree(ImmutableHashSet<string>.Builder builder) 262012"];
11410 [label="var result = builder.ToImmutable(); 262013"];
11411 [label="builder.Clear(); 262014"];
11412 [label="s_memberNameBuilderPool.Free(builder); 262015"];
11413 [label="s_memberNameBuilderPool.Free(builder); 262016"];
11414 [label="return result; 262017"];
11415 [label="var memberNames = GetNonTypeMemberNames(((Syntax.InternalSyntax.TypeDeclarationSyntax)(node.Green)).Members,\n                                                    ref declFlags); 262018"];
11416 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262019"];
11417 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262020"];
11418 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262021"];
11419 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262022"];
11420 [label="var modifiers = node.Modifiers.ToDeclarationModifiers(diagnostics: diagnostics); 262023"];
11421 [label="node.Modifiers 262024"];
11422 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 262025"];
11423 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 262026"];
11424 [label="var result = DeclarationModifiers.None; 262027"];
11425 [label="bool seenNoDuplicates = true; 262028"];
11426 [label="bool seenNoAccessibilityDuplicates = true; 262029"];
11427 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 262030"];
11428 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 262031"];
11429 [label="return result; 262032"];
11430 [label="var modifiers = node.Modifiers.ToDeclarationModifiers(diagnostics: diagnostics); 262033"];
11431 [label="var modifiers = node.Modifiers.ToDeclarationModifiers(diagnostics: diagnostics); 262034"];
11432 [label="var modifiers = node.Modifiers.ToDeclarationModifiers(diagnostics: diagnostics); 262035"];
11433 [label="var modifiers = node.Modifiers.ToDeclarationModifiers(diagnostics: diagnostics); 262036"];
11434 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262037"];
11435 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262038"];
11436 [label="node.Identifier 262039"];
11437 [label="=> true 262040"];
11438 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262041"];
11439 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262042"];
11440 [label="param GetValueText(this) 262043"];
11441 [label="this.ValueText 262044"];
11442 [label="get { return this.TextField; } 262045"];
11443 [label="return this.TextField; 262046"];
11444 [label="return this.ValueText; 262047"];
11445 [label="get\n            {\n                return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count;\n            } 262048"];
11446 [label="return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count; 262049"];
11447 [label="return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count; 262050"];
11448 [label="this.TypeParameterList == null 262051"];
11449 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262052"];
11450 [label="node.Arity 262053"];
11451 [label="param GetReference(SyntaxNode node) 262054"];
11452 [label="param GetReference(this) 262055"];
11453 [label="return new SimpleSyntaxReference(node); 262056"];
11454 [label="return new SimpleSyntaxReference(node); 262057"];
11455 [label="new SimpleSyntaxReference(node) 262058"];
11456 [label="param SimpleSyntaxReference(SyntaxNode node) 262059"];
11457 [label="param SimpleSyntaxReference(this) 262060"];
11458 [label="param SimpleSyntaxReference(this) 262061"];
11459 [label="_node 262062"];
11460 [label="_node 262063"];
11461 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262064"];
11462 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262065"];
11463 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262066"];
11464 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262067"];
11465 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262068"];
11466 [label="node.Identifier 262069"];
11467 [label="=> true 262070"];
11468 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262071"];
11469 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262072"];
11470 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262073"];
11471 [label="get\n            {\n                return this.SyntaxTree;\n            } 262074"];
11472 [label="this.SyntaxTree 262075"];
11473 [label="get\n            {\n                var result = this._syntaxTree ?? ComputeSyntaxTree(this);\n                Debug.Assert(result != null);\n                return result;\n            } 262076"];
11474 [label="var result = this._syntaxTree ?? ComputeSyntaxTree(this); 262077"];
11475 [label="ComputeSyntaxTree(this) 262078"];
11476 [label="param ComputeSyntaxTree(CSharpSyntaxNode node) 262079"];
11477 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 262080"];
11478 [label="SyntaxTree? tree = null; 262081"];
11479 [label="while (true)\n            {\n                tree = node._syntaxTree;\n                if (tree != null)\n                {\n                    break;\n                }\n\n                var parent = node.Parent;\n                if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                }\n\n                tree = parent._syntaxTree;\n                if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                }\n\n                (nodes ?? (nodes = ArrayBuilder<CSharpSyntaxNode>.GetInstance())).Add(node);\n                node = parent;\n            } 262082"];
11480 [label="tree = node._syntaxTree; 262083"];
11481 [label="if (tree != null)\n                {\n                    break;\n                } 262084"];
11482 [label="if (tree != null)\n                {\n                    break;\n                } 262085"];
11483 [label="node.Parent 262086"];
11484 [label="get\n            {\n                return (CSharpSyntaxNode?)base.Parent;\n            } 262087"];
11485 [label="return (CSharpSyntaxNode?)base.Parent; 262088"];
11486 [label="var parent = node.Parent; 262089"];
11487 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262090"];
11488 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262091"];
11489 [label="tree = parent._syntaxTree; 262092"];
11490 [label="if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                } 262093"];
11491 [label="if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                } 262094"];
11492 [label="(nodes ?? (nodes = ArrayBuilder<CSharpSyntaxNode>.GetInstance())).Add(node); 262095"];
11493 [label="(nodes ?? (nodes = ArrayBuilder<CSharpSyntaxNode>.GetInstance())).Add(node); 262096"];
11494 [label="node = parent; 262097"];
11495 [label="tree = node._syntaxTree; 262098"];
11496 [label="if (tree != null)\n                {\n                    break;\n                } 262099"];
11497 [label="return (CSharpSyntaxNode?)base.Parent; 262100"];
11498 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262101"];
11499 [label="tree = parent._syntaxTree; 262102"];
11500 [label="if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                } 262103"];
11501 [label="node._syntaxTree 262104"];
11502 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 262105"];
11503 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 262106"];
11504 [label="Debug.Assert(tree != null); 262107"];
11505 [label="Debug.Assert(tree != null); 262108"];
11506 [label="foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                } 262109"];
11507 [label="foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                } 262110"];
11508 [label="var existingTree = n._syntaxTree; 262111"];
11509 [label="if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    } 262112"];
11510 [label="if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    } 262113"];
11511 [label="n._syntaxTree 262114"];
11512 [label="nodes.Free(); 262115"];
11513 [label="return tree; 262116"];
11514 [label="var result = this._syntaxTree ?? ComputeSyntaxTree(this); 262117"];
11515 [label="Debug.Assert(result != null); 262118"];
11516 [label="Debug.Assert(result != null); 262119"];
11517 [label="return result; 262120"];
11518 [label="return this.SyntaxTree; 262121"];
11519 [label="param GetLeadingTriviaWidth(this) 262122"];
11520 [label="this.GetLeadingTrivia() 262123"];
11521 [label="param GetLeadingTrivia(this) 262124"];
11522 [label="return null; 262125"];
11523 [label="var leading = this.GetLeadingTrivia(); 262126"];
11524 [label="return leading != null ? leading.FullWidth : 0; 262127"];
11525 [label="return leading != null ? leading.FullWidth : 0; 262128"];
11526 [label="leading != null 262129"];
11527 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262130"];
11528 [label="get { return this.Text.Length; } 262131"];
11529 [label="this.Text 262132"];
11530 [label="get { return this.TextField; } 262133"];
11531 [label="return this.TextField; 262134"];
11532 [label="return this.Text.Length; 262135"];
11533 [label="return new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262136"];
11534 [label="VisitTypeChildren(node) 262137"];
11535 [label="param VisitTypeChildren(TypeDeclarationSyntax node) 262138"];
11536 [label="param VisitTypeChildren(this) 262139"];
11537 [label="if (node.Members.Count == 0)\n            {\n                return ImmutableArray<SingleTypeDeclaration>.Empty;\n            } 262140"];
11538 [label="if (node.Members.Count == 0)\n            {\n                return ImmutableArray<SingleTypeDeclaration>.Empty;\n            } 262141"];
11539 [label="return ImmutableArray<SingleTypeDeclaration>.Empty; 262142"];
11540 [label="new SingleTypeDeclaration(\n                kind: kind,\n                name: node.Identifier.ValueText,\n                modifiers: modifiers,\n                arity: node.Arity,\n                declFlags: declFlags,\n                syntaxReference: _syntaxTree.GetReference(node),\n                nameLocation: new SourceLocation(node.Identifier),\n                memberNames: memberNames,\n                children: VisitTypeChildren(node),\n                diagnostics: diagnostics.ToReadOnlyAndFree()) 262143"];
11541 [label="param SingleTypeDeclaration(DeclarationKind kind) 262144"];
11542 [label="param SingleTypeDeclaration(string name) 262145"];
11543 [label="param SingleTypeDeclaration(int arity) 262146"];
11544 [label="param SingleTypeDeclaration(DeclarationModifiers modifiers) 262147"];
11545 [label="param SingleTypeDeclaration(TypeDeclarationFlags declFlags) 262148"];
11546 [label="param SingleTypeDeclaration(SyntaxReference syntaxReference) 262149"];
11547 [label="param SingleTypeDeclaration(SourceLocation nameLocation) 262150"];
11548 [label="param SingleTypeDeclaration(ImmutableHashSet<string> memberNames) 262151"];
11549 [label="param SingleTypeDeclaration(ImmutableArray<SingleTypeDeclaration> children) 262152"];
11550 [label="param SingleTypeDeclaration(ImmutableArray<Diagnostic> diagnostics) 262153"];
11551 [label="param SingleTypeDeclaration(this) 262154"];
11552 [label="name 262155"];
11553 [label="syntaxReference 262156"];
11554 [label="nameLocation 262157"];
11555 [label="diagnostics 262158"];
11556 [label="param SingleTypeDeclaration(this) 262159"];
11557 [label="param SingleNamespaceOrTypeDeclaration(string name) 262160"];
11558 [label="param SingleNamespaceOrTypeDeclaration(SyntaxReference syntaxReference) 262161"];
11559 [label="param SingleNamespaceOrTypeDeclaration(SourceLocation nameLocation) 262162"];
11560 [label="param SingleNamespaceOrTypeDeclaration(ImmutableArray<Diagnostic> diagnostics) 262163"];
11561 [label="param SingleNamespaceOrTypeDeclaration(this) 262164"];
11562 [label="name 262165"];
11563 [label="param SingleNamespaceOrTypeDeclaration(this) 262166"];
11564 [label="param Declaration(string name) 262167"];
11565 [label="name 262168"];
11566 [label="_syntaxReference 262169"];
11567 [label="_nameLocation 262170"];
11568 [label="_syntaxReference 262171"];
11569 [label="_nameLocation 262172"];
11570 [label="Diagnostics 262173"];
11571 [label="_kind 262174"];
11572 [label="_flags 262175"];
11573 [label="_arity 262176"];
11574 [label="_modifiers 262177"];
11575 [label="public ImmutableHashSet<string> MemberNames { get; } 262178"];
11576 [label="Debug.Assert(kind != DeclarationKind.Namespace); 262179"];
11577 [label="_kind 262180"];
11578 [label="_arity 262181"];
11579 [label="_modifiers 262182"];
11580 [label="MemberNames 262183"];
11581 [label="_children 262184"];
11582 [label="_flags 262185"];
11583 [label="return VisitTypeDeclaration(node, DeclarationKind.Class); 262186"];
11584 [label="return ((CSharpSyntaxNode)node).Accept(this); 262187"];
11585 [label="if (namespaceOrType != null)\n                {\n                    childrenBuilder.Add(namespaceOrType);\n                }\n                else if (acceptSimpleProgram && member.IsKind(SyntaxKind.GlobalStatement))\n                {\n                    var global = (GlobalStatementSyntax)member;\n                    // LAFHIS\n                    if (firstGlobalStatement == null)\n                        firstGlobalStatement = global;\n                    var topLevelStatement = global.Statement;\n\n                    if (!hasAwaitExpressions)\n                    {\n                        hasAwaitExpressions = SyntaxFacts.HasAwaitOperations(topLevelStatement);\n                    }\n\n                    if (!isIterator)\n                    {\n                        isIterator = SyntaxFacts.HasYieldOperations(topLevelStatement);\n                    }\n\n                    if (!hasReturnWithExpression)\n                    {\n                        hasReturnWithExpression = SyntaxFacts.HasReturnWithExpression(topLevelStatement);\n                    }\n                }\n                else if (!hasGlobalMembers && member.Kind() != SyntaxKind.IncompleteMember)\n                {\n                    hasGlobalMembers = true;\n                } 262188"];
11586 [label="if (namespaceOrType != null)\n                {\n                    childrenBuilder.Add(namespaceOrType);\n                }\n                else if (acceptSimpleProgram && member.IsKind(SyntaxKind.GlobalStatement))\n                {\n                    var global = (GlobalStatementSyntax)member;\n                    // LAFHIS\n                    if (firstGlobalStatement == null)\n                        firstGlobalStatement = global;\n                    var topLevelStatement = global.Statement;\n\n                    if (!hasAwaitExpressions)\n                    {\n                        hasAwaitExpressions = SyntaxFacts.HasAwaitOperations(topLevelStatement);\n                    }\n\n                    if (!isIterator)\n                    {\n                        isIterator = SyntaxFacts.HasYieldOperations(topLevelStatement);\n                    }\n\n                    if (!hasReturnWithExpression)\n                    {\n                        hasReturnWithExpression = SyntaxFacts.HasReturnWithExpression(topLevelStatement);\n                    }\n                }\n                else if (!hasGlobalMembers && member.Kind() != SyntaxKind.IncompleteMember)\n                {\n                    hasGlobalMembers = true;\n                } 262189"];
11587 [label="childrenBuilder.Add(namespaceOrType); 262190"];
11588 [label="childrenBuilder.Add(namespaceOrType); 262191"];
11589 [label="if (node.BaseList != null)\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasBaseDeclarations;\n            } 262192"];
11590 [label="node.BaseList 262193"];
11591 [label="param CSharpSyntaxNode(GreenNode green) 262194"];
11592 [label="param CSharpSyntaxNode(SyntaxNode? parent) 262195"];
11593 [label="param CSharpSyntaxNode(int position) 262196"];
11594 [label="param CSharpSyntaxNode(this) 262197"];
11595 [label="declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasBaseDeclarations; 262198"];
11596 [label="get\n            {\n                return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count;\n            } 262199"];
11597 [label="return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count; 262200"];
11598 [label="if (node.Arity == 0)\n            {\n                Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics);\n            } 262201"];
11599 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 262202"];
11600 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 262203"];
11601 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics) 262204"];
11602 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 262205"];
11603 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 262206"];
11604 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 262207"];
11605 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 262208"];
11606 [label="Symbol.ReportErrorIfHasConstraints(node.ConstraintClauses, diagnostics); 262209"];
11607 [label="param GetNonTypeMemberNames(CoreInternalSyntax.SyntaxList<Syntax.InternalSyntax.MemberDeclarationSyntax> members) 262210"];
11608 [label="foreach (var member in members)\n            {\n                AddNonTypeMemberNames(member, memberNameBuilder, ref anyNonTypeMembers, skipGlobalStatements);\n\n                // Check to see if any method contains a 'this' modifier on its first parameter.\n                // This data is used to determine if a type needs to have its members materialized\n                // as part of extension method lookup.\n                if (!anyMethodHadExtensionSyntax && CheckMethodMemberForExtensionSyntax(member))\n                {\n                    anyMethodHadExtensionSyntax = true;\n                }\n\n                if (!anyMemberHasAttributes && CheckMemberForAttributes(member))\n                {\n                    anyMemberHasAttributes = true;\n                }\n            } 262211"];
11609 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262212"];
11610 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262213"];
11611 [label="if (((declFlags & SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers) == 0) &&\n                node is RecordDeclarationSyntax { ParameterList: { } })\n            {\n                declFlags |= SingleTypeDeclaration.TypeDeclarationFlags.HasAnyNontypeMembers;\n            } 262214"];
11612 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 262215"];
11613 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 262216"];
11614 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 262217"];
11615 [label="=> true 262218"];
11616 [label="param GetReference(this) 262219"];
11617 [label="=> true 262220"];
11618 [label="tree = node._syntaxTree; 262221"];
11619 [label="if (tree != null)\n                {\n                    break;\n                } 262222"];
11620 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262223"];
11621 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 262224"];
11622 [label="Debug.Assert(result != null); 262225"];
11623 [label="param GetLeadingTriviaWidth(this) 262226"];
11624 [label="param GetLeadingTrivia(this) 262227"];
11625 [label="param VisitTypeChildren(this) 262228"];
11626 [label="if (firstGlobalStatement is object)\n            {\n                childrenBuilder.Add(CreateSimpleProgram(firstGlobalStatement, hasAwaitExpressions, isIterator, hasReturnWithExpression));\n            } 262229"];
11627 [label="if (hasGlobalMembers)\n            {\n                //The implicit class is not static and has no extensions\n                SingleTypeDeclaration.TypeDeclarationFlags declFlags = SingleTypeDeclaration.TypeDeclarationFlags.None;\n                var memberNames = GetNonTypeMemberNames(internalMembers, ref declFlags, skipGlobalStatements: acceptSimpleProgram);\n                var container = _syntaxTree.GetReference(node);\n\n                childrenBuilder.Add(CreateImplicitClass(memberNames, container, declFlags));\n            } 262230"];
11628 [label="return childrenBuilder.ToImmutableAndFree(); 262231"];
11629 [label="bool hasUsings = node.Usings.Any(); 262232"];
11630 [label="bool hasExterns = node.Externs.Any(); 262233"];
11631 [label="NameSyntax name = node.Name; 262234"];
11632 [label="node.Name 262235"];
11633 [label="param CSharpSyntaxNode(GreenNode green) 262236"];
11634 [label="param CSharpSyntaxNode(SyntaxNode? parent) 262237"];
11635 [label="param CSharpSyntaxNode(int position) 262238"];
11636 [label="param CSharpSyntaxNode(this) 262239"];
11637 [label="CSharpSyntaxNode currentNode = node; 262240"];
11638 [label="QualifiedNameSyntax dotted; 262241"];
11639 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n            {\n                var ns = SingleNamespaceDeclaration.Create(\n                    name: dotted.Right.Identifier.ValueText,\n                    hasUsings: hasUsings,\n                    hasExternAliases: hasExterns,\n                    syntaxReference: _syntaxTree.GetReference(currentNode),\n                    nameLocation: new SourceLocation(dotted.Right),\n                    children: children,\n                    diagnostics: ImmutableArray<Diagnostic>.Empty);\n\n                var nsDeclaration = new[] { ns };\n                children = nsDeclaration.AsImmutableOrNull<SingleNamespaceOrTypeDeclaration>();\n                currentNode = name = dotted.Left;\n                hasUsings = false;\n                hasExterns = false;\n            } 262242"];
11640 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n            {\n                var ns = SingleNamespaceDeclaration.Create(\n                    name: dotted.Right.Identifier.ValueText,\n                    hasUsings: hasUsings,\n                    hasExternAliases: hasExterns,\n                    syntaxReference: _syntaxTree.GetReference(currentNode),\n                    nameLocation: new SourceLocation(dotted.Right),\n                    children: children,\n                    diagnostics: ImmutableArray<Diagnostic>.Empty);\n\n                var nsDeclaration = new[] { ns };\n                children = nsDeclaration.AsImmutableOrNull<SingleNamespaceOrTypeDeclaration>();\n                currentNode = name = dotted.Left;\n                hasUsings = false;\n                hasExterns = false;\n            } 262243"];
11641 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n            {\n                var ns = SingleNamespaceDeclaration.Create(\n                    name: dotted.Right.Identifier.ValueText,\n                    hasUsings: hasUsings,\n                    hasExternAliases: hasExterns,\n                    syntaxReference: _syntaxTree.GetReference(currentNode),\n                    nameLocation: new SourceLocation(dotted.Right),\n                    children: children,\n                    diagnostics: ImmutableArray<Diagnostic>.Empty);\n\n                var nsDeclaration = new[] { ns };\n                children = nsDeclaration.AsImmutableOrNull<SingleNamespaceOrTypeDeclaration>();\n                currentNode = name = dotted.Left;\n                hasUsings = false;\n                hasExterns = false;\n            } 262244"];
11642 [label="var diagnostics = DiagnosticBag.GetInstance(); 262245"];
11643 [label="if (ContainsGeneric(node.Name))\n            {\n                // We're not allowed to have generics.\n                diagnostics.Add(ErrorCode.ERR_UnexpectedGenericName, node.Name.GetLocation());\n            } 262246"];
11644 [label="ContainsGeneric(node.Name) 262247"];
11645 [label="param ContainsGeneric(NameSyntax name) 262248"];
11646 [label="name.Kind() 262249"];
11647 [label="param Kind(this) 262250"];
11648 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName:\n                    return true;\n                case SyntaxKind.AliasQualifiedName:\n                    return ContainsGeneric(((AliasQualifiedNameSyntax)name).Name);\n                case SyntaxKind.QualifiedName:\n                    var qualifiedName = (QualifiedNameSyntax)name;\n                    return ContainsGeneric(qualifiedName.Left) || ContainsGeneric(qualifiedName.Right);\n            } 262251"];
11649 [label="return false; 262252"];
11650 [label="if (ContainsGeneric(node.Name))\n            {\n                // We're not allowed to have generics.\n                diagnostics.Add(ErrorCode.ERR_UnexpectedGenericName, node.Name.GetLocation());\n            } 262253"];
11651 [label="if (ContainsAlias(node.Name))\n            {\n                diagnostics.Add(ErrorCode.ERR_UnexpectedAliasedName, node.Name.GetLocation());\n            } 262254"];
11652 [label="ContainsAlias(node.Name) 262255"];
11653 [label="param ContainsAlias(NameSyntax name) 262256"];
11654 [label="name.Kind() 262257"];
11655 [label="param Kind(this) 262258"];
11656 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName:\n                    return false;\n                case SyntaxKind.AliasQualifiedName:\n                    return true;\n                case SyntaxKind.QualifiedName:\n                    var qualifiedName = (QualifiedNameSyntax)name;\n                    return ContainsAlias(qualifiedName.Left);\n            } 262259"];
11657 [label="return false; 262260"];
11658 [label="if (ContainsAlias(node.Name))\n            {\n                diagnostics.Add(ErrorCode.ERR_UnexpectedAliasedName, node.Name.GetLocation());\n            } 262261"];
11659 [label="if (node.AttributeLists.Count > 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_BadModifiersOnNamespace, node.AttributeLists[0].GetLocation());\n            } 262262"];
11660 [label="if (node.AttributeLists.Count > 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_BadModifiersOnNamespace, node.AttributeLists[0].GetLocation());\n            } 262263"];
11661 [label="if (node.Modifiers.Count > 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_BadModifiersOnNamespace, node.Modifiers[0].GetLocation());\n            } 262264"];
11662 [label="node.Modifiers 262265"];
11663 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 262266"];
11664 [label="return (InternalSyntax.NamespaceDeclarationSyntax)base.Green; 262267"];
11665 [label="if (node.Modifiers.Count > 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_BadModifiersOnNamespace, node.Modifiers[0].GetLocation());\n            } 262268"];
11666 [label="name.GetUnqualifiedName() 262269"];
11667 [label="param GetUnqualifiedName(this) 262270"];
11668 [label="return this; 262271"];
11669 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262272"];
11670 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262273"];
11671 [label="name.GetUnqualifiedName().Identifier 262274"];
11672 [label="=> true 262275"];
11673 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262276"];
11674 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262277"];
11675 [label="param GetValueText(this) 262278"];
11676 [label="this.ValueText 262279"];
11677 [label="param GetReference(SyntaxNode node) 262280"];
11678 [label="param GetReference(this) 262281"];
11679 [label="return new SimpleSyntaxReference(node); 262282"];
11680 [label="new SimpleSyntaxReference(node) 262283"];
11681 [label="param SimpleSyntaxReference(this) 262284"];
11682 [label="param SimpleSyntaxReference(this) 262285"];
11683 [label="_node 262286"];
11684 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262287"];
11685 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262288"];
11686 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262289"];
11687 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262290"];
11688 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262291"];
11689 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262292"];
11690 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262293"];
11691 [label="this.SyntaxTree 262294"];
11692 [label="ComputeSyntaxTree(this) 262295"];
11693 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 262296"];
11694 [label="SyntaxTree? tree = null; 262297"];
11695 [label="while (true)\n            {\n                tree = node._syntaxTree;\n                if (tree != null)\n                {\n                    break;\n                }\n\n                var parent = node.Parent;\n                if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                }\n\n                tree = parent._syntaxTree;\n                if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                }\n\n                (nodes ?? (nodes = ArrayBuilder<CSharpSyntaxNode>.GetInstance())).Add(node);\n                node = parent;\n            } 262298"];
11696 [label="tree = node._syntaxTree; 262299"];
11697 [label="if (tree != null)\n                {\n                    break;\n                } 262300"];
11698 [label="if (tree != null)\n                {\n                    break;\n                } 262301"];
11699 [label="node.Parent 262302"];
11700 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262303"];
11701 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 262304"];
11702 [label="if (tree != null)\n                {\n                    node._syntaxTree = tree;\n                    break;\n                } 262305"];
11703 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 262306"];
11704 [label="if (nodes != null)\n            {\n                Debug.Assert(tree != null);\n\n                foreach (var n in nodes)\n                {\n                    var existingTree = n._syntaxTree;\n                    if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    }\n                    n._syntaxTree = tree;\n                }\n\n                nodes.Free();\n            } 262307"];
11705 [label="Debug.Assert(result != null); 262308"];
11706 [label="Debug.Assert(result != null); 262309"];
11707 [label="param GetLeadingTriviaWidth(this) 262310"];
11708 [label="this.GetLeadingTrivia() 262311"];
11709 [label="param GetLeadingTrivia(this) 262312"];
11710 [label="return null; 262313"];
11711 [label="var leading = this.GetLeadingTrivia(); 262314"];
11712 [label="return leading != null ? leading.FullWidth : 0; 262315"];
11713 [label="return leading != null ? leading.FullWidth : 0; 262316"];
11714 [label="leading != null 262317"];
11715 [label="param GetTrailingTriviaWidth(this) 262318"];
11716 [label="this.GetTrailingTrivia() 262319"];
11717 [label="param GetTrailingTrivia(this) 262320"];
11718 [label="var trailing = this.GetTrailingTrivia(); 262321"];
11719 [label="return trailing != null ? trailing.FullWidth : 0; 262322"];
11720 [label="return trailing != null ? trailing.FullWidth : 0; 262323"];
11721 [label="trailing != null 262324"];
11722 [label="trailing.FullWidth 262325"];
11723 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262326"];
11724 [label="return SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()); 262327"];
11725 [label="SingleNamespaceDeclaration.Create(\n                name: name.GetUnqualifiedName().Identifier.ValueText,\n                hasUsings: hasUsings,\n                hasExternAliases: hasExterns,\n                syntaxReference: _syntaxTree.GetReference(currentNode),\n                nameLocation: new SourceLocation(name),\n                children: children,\n                diagnostics: diagnostics.ToReadOnlyAndFree()) 262328"];
11726 [label="param Create(string name) 262329"];
11727 [label="param Create(bool hasUsings) 262330"];
11728 [label="param Create(bool hasExternAliases) 262331"];
11729 [label="param Create(SyntaxReference syntaxReference) 262332"];
11730 [label="param Create(SourceLocation nameLocation) 262333"];
11731 [label="param Create(ImmutableArray<SingleNamespaceOrTypeDeclaration> children) 262334"];
11732 [label="param Create(ImmutableArray<Diagnostic> diagnostics) 262335"];
11733 [label="if (!hasUsings && !hasExternAliases)\n            {\n                return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics);\n            }\n            else\n            {\n                return new SingleNamespaceDeclarationEx(\n                    name, hasUsings, hasExternAliases, syntaxReference, nameLocation, children, diagnostics);\n            } 262336"];
11734 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262337"];
11735 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262338"];
11736 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262339"];
11737 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262340"];
11738 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262341"];
11739 [label="return new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics); 262342"];
11740 [label="new SingleNamespaceDeclaration(\n                    name, syntaxReference, nameLocation, children, diagnostics) 262343"];
11741 [label="param SingleNamespaceDeclaration(string name) 262344"];
11742 [label="param SingleNamespaceDeclaration(SyntaxReference syntaxReference) 262345"];
11743 [label="param SingleNamespaceDeclaration(SourceLocation nameLocation) 262346"];
11744 [label="param SingleNamespaceDeclaration(ImmutableArray<SingleNamespaceOrTypeDeclaration> children) 262347"];
11745 [label="param SingleNamespaceDeclaration(ImmutableArray<Diagnostic> diagnostics) 262348"];
11746 [label="param SingleNamespaceDeclaration(this) 262349"];
11747 [label="name 262350"];
11748 [label="syntaxReference 262351"];
11749 [label="nameLocation 262352"];
11750 [label="diagnostics 262353"];
11751 [label="param SingleNamespaceDeclaration(this) 262354"];
11752 [label="param SingleNamespaceOrTypeDeclaration(string name) 262355"];
11753 [label="param SingleNamespaceOrTypeDeclaration(SyntaxReference syntaxReference) 262356"];
11754 [label="param SingleNamespaceOrTypeDeclaration(SourceLocation nameLocation) 262357"];
11755 [label="param SingleNamespaceOrTypeDeclaration(ImmutableArray<Diagnostic> diagnostics) 262358"];
11756 [label="name 262359"];
11757 [label="_syntaxReference 262360"];
11758 [label="_nameLocation 262361"];
11759 [label="_children 262362"];
11760 [label="return ((CSharpSyntaxNode)node).Accept(this); 262363"];
11761 [label="if (namespaceOrType != null)\n                {\n                    childrenBuilder.Add(namespaceOrType);\n                }\n                else if (acceptSimpleProgram && member.IsKind(SyntaxKind.GlobalStatement))\n                {\n                    var global = (GlobalStatementSyntax)member;\n                    // LAFHIS\n                    if (firstGlobalStatement == null)\n                        firstGlobalStatement = global;\n                    var topLevelStatement = global.Statement;\n\n                    if (!hasAwaitExpressions)\n                    {\n                        hasAwaitExpressions = SyntaxFacts.HasAwaitOperations(topLevelStatement);\n                    }\n\n                    if (!isIterator)\n                    {\n                        isIterator = SyntaxFacts.HasYieldOperations(topLevelStatement);\n                    }\n\n                    if (!hasReturnWithExpression)\n                    {\n                        hasReturnWithExpression = SyntaxFacts.HasReturnWithExpression(topLevelStatement);\n                    }\n                }\n                else if (!hasGlobalMembers && member.Kind() != SyntaxKind.IncompleteMember)\n                {\n                    hasGlobalMembers = true;\n                } 262364"];
11762 [label="if (firstGlobalStatement is object)\n            {\n                childrenBuilder.Add(CreateSimpleProgram(firstGlobalStatement, hasAwaitExpressions, isIterator, hasReturnWithExpression));\n            } 262365"];
11763 [label="if (hasGlobalMembers)\n            {\n                //The implicit class is not static and has no extensions\n                SingleTypeDeclaration.TypeDeclarationFlags declFlags = SingleTypeDeclaration.TypeDeclarationFlags.None;\n                var memberNames = GetNonTypeMemberNames(internalMembers, ref declFlags, skipGlobalStatements: acceptSimpleProgram);\n                var container = _syntaxTree.GetReference(node);\n\n                childrenBuilder.Add(CreateImplicitClass(memberNames, container, declFlags));\n            } 262366"];
11764 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262367"];
11765 [label="compilationUnit.Usings 262368"];
11766 [label="param GetReference(SyntaxNode node) 262369"];
11767 [label="param GetReference(this) 262370"];
11768 [label="return new SimpleSyntaxReference(node); 262371"];
11769 [label="new SimpleSyntaxReference(node) 262372"];
11770 [label="param SimpleSyntaxReference(this) 262373"];
11771 [label="param SimpleSyntaxReference(this) 262374"];
11772 [label="_node 262375"];
11773 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262376"];
11774 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262377"];
11775 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262378"];
11776 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262379"];
11777 [label="compilationUnit.AttributeLists 262380"];
11778 [label="param RootSingleNamespaceDeclaration(bool hasUsings) 262381"];
11779 [label="param RootSingleNamespaceDeclaration(bool hasExternAliases) 262382"];
11780 [label="param RootSingleNamespaceDeclaration(SyntaxReference treeNode) 262383"];
11781 [label="param RootSingleNamespaceDeclaration(ImmutableArray<SingleNamespaceOrTypeDeclaration> children) 262384"];
11782 [label="param RootSingleNamespaceDeclaration(ImmutableArray<ReferenceDirective> referenceDirectives) 262385"];
11783 [label="param RootSingleNamespaceDeclaration(bool hasAssemblyAttributes) 262386"];
11784 [label="param RootSingleNamespaceDeclaration(this) 262387"];
11785 [label="string.Empty 262388"];
11786 [label="treeNode 262389"];
11787 [label="treeNode 262390"];
11788 [label="new SourceLocation(treeNode) 262391"];
11789 [label="new SourceLocation(treeNode) 262392"];
11790 [label="get\n            {\n                return _node.SyntaxTree;\n            } 262393"];
11791 [label="return _node.SyntaxTree; 262394"];
11792 [label="_node.SyntaxTree 262395"];
11793 [label="get\n            {\n                return this.SyntaxTree;\n            } 262396"];
11794 [label="this.SyntaxTree 262397"];
11795 [label="Debug.Assert(result != null); 262398"];
11796 [label="Debug.Assert(result != null); 262399"];
11797 [label="get\n            {\n                return _node.Span;\n            } 262400"];
11798 [label="return _node.Span; 262401"];
11799 [label="_node.Span 262402"];
11800 [label="param GetLeadingTriviaWidth(this) 262403"];
11801 [label="this.GetLeadingTrivia() 262404"];
11802 [label="return leading != null ? leading.FullWidth : 0; 262405"];
11803 [label="leading.FullWidth 262406"];
11804 [label="param GetTrailingTriviaWidth(this) 262407"];
11805 [label="this.GetTrailingTrivia() 262408"];
11806 [label="param GetTrailingTrivia(this) 262409"];
11807 [label="var trailing = this.GetTrailingTrivia(); 262410"];
11808 [label="return trailing != null ? trailing.FullWidth : 0; 262411"];
11809 [label="return trailing != null ? trailing.FullWidth : 0; 262412"];
11810 [label="trailing != null 262413"];
11811 [label="return _node.Span; 262414"];
11812 [label="children 262415"];
11813 [label="ImmutableArray<Diagnostic>.Empty 262416"];
11814 [label="param RootSingleNamespaceDeclaration(this) 262417"];
11815 [label="param SingleNamespaceDeclaration(string name) 262418"];
11816 [label="param SingleNamespaceDeclaration(SyntaxReference syntaxReference) 262419"];
11817 [label="param SingleNamespaceDeclaration(SourceLocation nameLocation) 262420"];
11818 [label="param SingleNamespaceDeclaration(ImmutableArray<SingleNamespaceOrTypeDeclaration> children) 262421"];
11819 [label="param SingleNamespaceDeclaration(ImmutableArray<Diagnostic> diagnostics) 262422"];
11820 [label="name 262423"];
11821 [label="diagnostics 262424"];
11822 [label="param SingleNamespaceDeclaration(this) 262425"];
11823 [label="param SingleNamespaceOrTypeDeclaration(string name) 262426"];
11824 [label="param SingleNamespaceOrTypeDeclaration(ImmutableArray<Diagnostic> diagnostics) 262427"];
11825 [label="name 262428"];
11826 [label="param SingleNamespaceOrTypeDeclaration(this) 262429"];
11827 [label="param Declaration(string name) 262430"];
11828 [label="name 262431"];
11829 [label="this.name 262432"];
11830 [label="_syntaxReference 262433"];
11831 [label="_nameLocation 262434"];
11832 [label="Diagnostics 262435"];
11833 [label="_hasAssemblyAttributes 262436"];
11834 [label="_hasUsings 262437"];
11835 [label="_hasExternAliases 262438"];
11836 [label="Debug.Assert(!referenceDirectives.IsDefault); 262439"];
11837 [label="_referenceDirectives 262440"];
11838 [label="_hasAssemblyAttributes 262441"];
11839 [label="_hasUsings 262442"];
11840 [label="_hasExternAliases 262443"];
11841 [label="return new RootSingleNamespaceDeclaration(\n                hasUsings: compilationUnit.Usings.Any(),\n                hasExternAliases: compilationUnit.Externs.Any(),\n                treeNode: _syntaxTree.GetReference(compilationUnit),\n                children: children,\n                referenceDirectives: ImmutableArray<ReferenceDirective>.Empty,\n                hasAssemblyAttributes: compilationUnit.AttributeLists.Any()); 262444"];
11842 [label="_latestLazyRootDeclaration.Value.ReferenceDirectives 262445"];
11843 [label="get\n            {\n                return _referenceDirectives;\n            } 262446"];
11844 [label="return _referenceDirectives; 262447"];
11845 [label="get { return _options; } 262448"];
11846 [label="return _options; 262449"];
11847 [label="get { return CSharp.MessageProvider.Instance; } 262450"];
11848 [label="return CSharp.MessageProvider.Instance; 262451"];
11849 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 262452"];
11850 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 262453"];
11851 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 262454"];
11852 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 262455"];
11853 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 262456"];
11854 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 262457"];
11855 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 262458"];
11856 [label="param CreateAssemblyDataForFile(this) 262459"];
11857 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262460"];
11858 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262461"];
11859 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262462"];
11860 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262463"];
11861 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262464"];
11862 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262465"];
11863 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 262466"];
11864 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 262467"];
11865 [label="param AssemblyDataForFile(PEAssembly assembly) 262468"];
11866 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 262469"];
11867 [label="param AssemblyDataForFile(bool embedInteropTypes) 262470"];
11868 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 262471"];
11869 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 262472"];
11870 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 262473"];
11871 [label="param AssemblyDataForFile(this) 262474"];
11872 [label="assembly.Identity 262475"];
11873 [label="assembly.AssemblyReferences 262476"];
11874 [label="embedInteropTypes 262477"];
11875 [label="param AssemblyDataForFile(this) 262478"];
11876 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 262479"];
11877 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 262480"];
11878 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 262481"];
11879 [label="param AssemblyDataForMetadataOrCompilation(this) 262482"];
11880 [label="param AssemblyDataForMetadataOrCompilation(this) 262483"];
11881 [label="_assemblies 262484"];
11882 [label="_identity 262485"];
11883 [label="_embedInteropTypes 262486"];
11884 [label="RoslynDebug.Assert(identity != null); 262487"];
11885 [label="RoslynDebug.Assert(identity != null); 262488"];
11886 [label="Debug.Assert(!referencedAssemblies.IsDefault); 262489"];
11887 [label="_embedInteropTypes 262490"];
11888 [label="_identity 262491"];
11889 [label="_referencedAssemblies 262492"];
11890 [label="Assembly 262493"];
11891 [label="CachedSymbols 262494"];
11892 [label="DocumentationProvider 262495"];
11893 [label="_compilationImportOptions 262496"];
11894 [label="_sourceAssemblySimpleName 262497"];
11895 [label="_internalsVisibleComputed 262498"];
11896 [label="_internalsPotentiallyVisibleToCompilation 262499"];
11897 [label="RoslynDebug.Assert(documentationProvider != null); 262500"];
11898 [label="RoslynDebug.Assert(documentationProvider != null); 262501"];
11899 [label="RoslynDebug.Assert(cachedSymbols != null); 262502"];
11900 [label="RoslynDebug.Assert(cachedSymbols != null); 262503"];
11901 [label="CachedSymbols 262504"];
11902 [label="Assembly 262505"];
11903 [label="DocumentationProvider 262506"];
11904 [label="_compilationImportOptions 262507"];
11905 [label="_sourceAssemblySimpleName 262508"];
11906 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 262509"];
11907 [label="RoslynDebug.Assert(identity != null); 262510"];
11908 [label="Debug.Assert(!referencedAssemblies.IsDefault); 262511"];
11909 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 262512"];
11910 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 262513"];
11911 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 262514"];
11912 [label="get\n                    {\n                        return _identity;\n                    } 262515"];
11913 [label="return _identity; 262516"];
11914 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 262517"];
11915 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 262518"];
11916 [label="bool hasCircularReference; 262519"];
11917 [label="int corLibraryIndex; 262520"];
11918 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 262521"];
11919 [label="implicitlyResolvedReferences 262522"];
11920 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 262523"];
11921 [label="implicitlyResolvedReferenceMap 262524"];
11922 [label="ImmutableArray<AssemblyData> allAssemblyData; 262525"];
11923 [label="allAssemblyData 262526"];
11924 [label="var temp1 = compilation.ScriptCompilationInfo; 262527"];
11925 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 262528"];
11926 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 262529"];
11927 [label="temp1 != null 262530"];
11928 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 262531"];
11929 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 262532"];
11930 [label="temp2 != null 262533"];
11931 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 262534"];
11932 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 262535"];
11933 [label="temp3 != null 262536"];
11934 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 262537"];
11935 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 262538"];
11936 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262539"];
11937 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262540"];
11938 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262541"];
11939 [label="compilation.Options 262542"];
11940 [label="get\n            {\n                return _options;\n            } 262543"];
11941 [label="return _options; 262544"];
11942 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262545"];
11943 [label="compilation.Options 262546"];
11944 [label="get\n            {\n                return _options;\n            } 262547"];
11945 [label="return _options; 262548"];
11946 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262549"];
11947 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262550"];
11948 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262551"];
11949 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262552"];
11950 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262553"];
11951 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262554"];
11952 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262555"];
11953 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262556"];
11954 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262557"];
11955 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262558"];
11956 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262559"];
11957 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 262560"];
11958 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 262561"];
11959 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 262562"];
11960 [label="param BindAssemblyReferences(this) 262563"];
11961 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 262564"];
11962 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 262565"];
11963 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 262566"];
11964 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 262567"];
11965 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 262568"];
11966 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 262569"];
11967 [label="return _embedInteropTypes; 262570"];
11968 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 262571"];
11969 [label="return _referencedAssemblies; 262572"];
11970 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 262573"];
11971 [label="return Assembly.ContainsNoPiaLocalTypes(); 262574"];
11972 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 262575"];
11973 [label="return Assembly.DeclaresTheObjectClass; 262576"];
11974 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 262577"];
11975 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 262578"];
11976 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 262579"];
11977 [label="_assemblies = new List<AssemblySymbol>(); 262580"];
11978 [label="_assemblies 262581"];
11979 [label="AddAvailableSymbols(_assemblies); 262582"];
11980 [label="AddAvailableSymbols(_assemblies) 262583"];
11981 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 262584"];
11982 [label="param AddAvailableSymbols(this) 262585"];
11983 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 262586"];
11984 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 262587"];
11985 [label="AddAvailableSymbols(_assemblies); 262588"];
11986 [label="return _assemblies; 262589"];
11987 [label="AddAvailableSymbols(_assemblies); 262590"];
11988 [label="AddAvailableSymbols(_assemblies) 262591"];
11989 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 262592"];
11990 [label="param AddAvailableSymbols(this) 262593"];
11991 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 262594"];
11992 [label="AddAvailableSymbols(_assemblies); 262595"];
11993 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 262596"];
11994 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 262597"];
11995 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 262598"];
11996 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 262599"];
11997 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 262600"];
11998 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 262601"];
11999 [label="aliasesOfReferencedAssemblies 262602"];
12000 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262603"];
12001 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262604"];
12002 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262605"];
12003 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262606"];
12004 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262607"];
12005 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262608"];
12006 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262609"];
12007 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262610"];
12008 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262611"];
12009 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 262612"];
12010 [label="var newSymbols = new List<int>(); 262613"];
12011 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 262614"];
12012 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 262615"];
12013 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 262616"];
12014 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 262617"];
12015 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 262618"];
12016 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 262619"];
12017 [label="param CreateAssemblySymbol(this) 262620"];
12018 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 262621"];
12019 [label="this.IsLinked 262622"];
12020 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 262623"];
12021 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 262624"];
12022 [label="this.EffectiveImportOptions 262625"];
12023 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 262626"];
12024 [label="InternalsMayBeVisibleToCompilation 262627"];
12025 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 262628"];
12026 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 262629"];
12027 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 262630"];
12028 [label="_internalsPotentiallyVisibleToCompilation 262631"];
12029 [label="_internalsVisibleComputed = true; 262632"];
12030 [label="_internalsVisibleComputed 262633"];
12031 [label="return _internalsPotentiallyVisibleToCompilation; 262634"];
12032 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 262635"];
12033 [label="return _compilationImportOptions; 262636"];
12034 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 262637"];
12035 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 262638"];
12036 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 262639"];
12037 [label="param PEAssemblySymbol(PEAssembly assembly) 262640"];
12038 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 262641"];
12039 [label="param PEAssemblySymbol(bool isLinked) 262642"];
12040 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 262643"];
12041 [label="param PEAssemblySymbol(this) 262644"];
12042 [label="param PEAssemblySymbol(this) 262645"];
12043 [label="param MetadataOrSourceAssemblySymbol(this) 262646"];
12044 [label="param MetadataOrSourceAssemblySymbol(this) 262647"];
12045 [label="param NonMissingAssemblySymbol(this) 262648"];
12046 [label="new char[] { '+' } 262649"];
12047 [label="'+' 262650"];
12048 [label="new char[] { '+' } 262651"];
12049 [label="s_nestedTypeNameSeparators = new char[] { '+' } 262652"];
12050 [label="param NonMissingAssemblySymbol(this) 262653"];
12051 [label="param AssemblySymbol(this) 262654"];
12052 [label="param AssemblySymbol(this) 262655"];
12053 [label="param Symbol(this) 262656"];
12054 [label="_lazyISymbol 262657"];
12055 [label="_corLibrary 262658"];
12056 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 262659"];
12057 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 262660"];
12058 [label="_globalNamespace 262661"];
12059 [label="_lazySpecialTypes 262662"];
12060 [label="_cachedSpecialTypes 262663"];
12061 [label="_lazyNativeIntegerTypes 262664"];
12062 [label="_lazyTypeNames 262665"];
12063 [label="_lazyNamespaceNames 262666"];
12064 [label="_lazySpecialTypeMembers 262667"];
12065 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 262668"];
12066 [label="_assembly 262669"];
12067 [label="_documentationProvider 262670"];
12068 [label="_isLinked 262671"];
12069 [label="Debug.Assert(assembly != null); 262672"];
12070 [label="Debug.Assert(assembly != null); 262673"];
12071 [label="Debug.Assert(documentationProvider != null); 262674"];
12072 [label="Debug.Assert(documentationProvider != null); 262675"];
12073 [label="_assembly 262676"];
12074 [label="_documentationProvider 262677"];
12075 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 262678"];
12076 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 262679"];
12077 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 262680"];
12078 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 262681"];
12079 [label="31 262682"];
12080 [label="DefaultTypeMapCapacity = 31 262683"];
12081 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 262684"];
12082 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 262685"];
12083 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 262686"];
12084 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 262687"];
12085 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 262688"];
12086 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 262689"];
12087 [label="param PEModuleSymbol(PEModule module) 262690"];
12088 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 262691"];
12089 [label="param PEModuleSymbol(int ordinal) 262692"];
12090 [label="param PEModuleSymbol(this) 262693"];
12091 [label="assemblySymbol 262694"];
12092 [label="module 262695"];
12093 [label="importOptions 262696"];
12094 [label="ordinal 262697"];
12095 [label="param PEModuleSymbol(this) 262698"];
12096 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 262699"];
12097 [label="param PEModuleSymbol(PEModule module) 262700"];
12098 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 262701"];
12099 [label="param PEModuleSymbol(int ordinal) 262702"];
12100 [label="param PEModuleSymbol(this) 262703"];
12101 [label="param PEModuleSymbol(this) 262704"];
12102 [label="param NonMissingModuleSymbol(this) 262705"];
12103 [label="param NonMissingModuleSymbol(this) 262706"];
12104 [label="param ModuleSymbol(this) 262707"];
12105 [label="param ModuleSymbol(this) 262708"];
12106 [label="param Symbol(this) 262709"];
12107 [label="_lazyISymbol 262710"];
12108 [label="_moduleReferences 262711"];
12109 [label="_assemblySymbol 262712"];
12110 [label="_ordinal 262713"];
12111 [label="_module 262714"];
12112 [label="_globalNamespace 262715"];
12113 [label="_lazySystemTypeSymbol 262716"];
12114 [label="_lazyEventRegistrationTokenSymbol 262717"];
12115 [label="_lazyEventRegistrationTokenTableSymbol 262718"];
12116 [label="2 262719"];
12117 [label="concurrencyLevel: 2 262720"];
12118 [label="capacity: DefaultTypeMapCapacity 262721"];
12119 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 262722"];
12120 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 262723"];
12121 [label="2 262724"];
12122 [label="concurrencyLevel: 2 262725"];
12123 [label="capacity: DefaultTypeMapCapacity 262726"];
12124 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 262727"];
12125 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 262728"];
12126 [label="ImportOptions 262729"];
12127 [label="_lazyTypeNames 262730"];
12128 [label="_lazyNamespaceNames 262731"];
12129 [label="_lazyNullableMemberMetadata 262732"];
12130 [label="Debug.Assert((object)assemblySymbol != null); 262733"];
12131 [label="Debug.Assert((object)assemblySymbol != null); 262734"];
12132 [label="Debug.Assert(module != null); 262735"];
12133 [label="Debug.Assert(module != null); 262736"];
12134 [label="_assemblySymbol 262737"];
12135 [label="_ordinal 262738"];
12136 [label="_module 262739"];
12137 [label="this.ImportOptions 262740"];
12138 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 262741"];
12139 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 262742"];
12140 [label="new PEGlobalNamespaceSymbol(this) 262743"];
12141 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 262744"];
12142 [label="param PEGlobalNamespaceSymbol(this) 262745"];
12143 [label="param PEGlobalNamespaceSymbol(this) 262746"];
12144 [label="param PENamespaceSymbol(this) 262747"];
12145 [label="param PENamespaceSymbol(this) 262748"];
12146 [label="param NamespaceSymbol(this) 262749"];
12147 [label="param NamespaceSymbol(this) 262750"];
12148 [label="param NamespaceOrTypeSymbol(this) 262751"];
12149 [label="param NamespaceOrTypeSymbol(this) 262752"];
12150 [label="param Symbol(this) 262753"];
12151 [label="_lazyISymbol 262754"];
12152 [label="_lazyAdapter 262755"];
12153 [label="_lazyQualifiedName 262756"];
12154 [label="lazyNamespaces 262757"];
12155 [label="lazyTypes 262758"];
12156 [label="_lazyNoPiaLocalTypes 262759"];
12157 [label="_moduleSymbol 262760"];
12158 [label="Debug.Assert((object)moduleSymbol != null); 262761"];
12159 [label="Debug.Assert((object)moduleSymbol != null); 262762"];
12160 [label="_moduleSymbol 262763"];
12161 [label="_globalNamespace 262764"];
12162 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 262765"];
12163 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 262766"];
12164 [label="this.MetadataLocation 262767"];
12165 [label="Debug.Assert(ordinal >= 0); 262768"];
12166 [label="Debug.Assert(ordinal >= 0); 262769"];
12167 [label="modules[i] 262770"];
12168 [label="_modules = modules.AsImmutableOrNull(); 262771"];
12169 [label="_modules = modules.AsImmutableOrNull(); 262772"];
12170 [label="_modules 262773"];
12171 [label="_isLinked 262774"];
12172 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 262775"];
12173 [label="bound.AssemblySymbol 262776"];
12174 [label="newSymbols.Add(i); 262777"];
12175 [label="newSymbols.Add(i); 262778"];
12176 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 262779"];
12177 [label="allAssemblyData[i].IsLinked 262780"];
12178 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 262781"];
12179 [label="bound.AssemblySymbol.IsLinked 262782"];
12180 [label="get\n            {\n                return _isLinked;\n            } 262783"];
12181 [label="return _isLinked; 262784"];
12182 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 262785"];
12183 [label="return _internalsPotentiallyVisibleToCompilation; 262786"];
12184 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 262787"];
12185 [label="_assembly 262788"];
12186 [label="_documentationProvider 262789"];
12187 [label="Debug.Assert(assembly != null); 262790"];
12188 [label="Debug.Assert(documentationProvider != null); 262791"];
12189 [label="_assemblySymbol 262792"];
12190 [label="_ordinal 262793"];
12191 [label="_module 262794"];
12192 [label="_globalNamespace 262795"];
12193 [label="ImportOptions 262796"];
12194 [label="Debug.Assert((object)assemblySymbol != null); 262797"];
12195 [label="Debug.Assert(module != null); 262798"];
12196 [label="_moduleSymbol 262799"];
12197 [label="Debug.Assert((object)moduleSymbol != null); 262800"];
12198 [label="Debug.Assert(ordinal >= 0); 262801"];
12199 [label="bound.AssemblySymbol 262802"];
12200 [label="newSymbols.Add(i); 262803"];
12201 [label="newSymbols.Add(i); 262804"];
12202 [label="allAssemblyData[i].IsLinked 262805"];
12203 [label="bound.AssemblySymbol.IsLinked 262806"];
12204 [label="get\n            {\n                return _isLinked;\n            } 262807"];
12205 [label="return _isLinked; 262808"];
12206 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 262809"];
12207 [label="_assembly 262810"];
12208 [label="_documentationProvider 262811"];
12209 [label="_assemblySymbol 262812"];
12210 [label="_ordinal 262813"];
12211 [label="_module 262814"];
12212 [label="_globalNamespace 262815"];
12213 [label="ImportOptions 262816"];
12214 [label="Debug.Assert((object)assemblySymbol != null); 262817"];
12215 [label="Debug.Assert(module != null); 262818"];
12216 [label="_moduleSymbol 262819"];
12217 [label="Debug.Assert((object)moduleSymbol != null); 262820"];
12218 [label="Debug.Assert(ordinal >= 0); 262821"];
12219 [label="bound.AssemblySymbol 262822"];
12220 [label="newSymbols.Add(i); 262823"];
12221 [label="get\n            {\n                return _isLinked;\n            } 262824"];
12222 [label="return _isLinked; 262825"];
12223 [label="return _internalsPotentiallyVisibleToCompilation; 262826"];
12224 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 262827"];
12225 [label="_assembly 262828"];
12226 [label="_documentationProvider 262829"];
12227 [label="Debug.Assert(assembly != null); 262830"];
12228 [label="Debug.Assert(documentationProvider != null); 262831"];
12229 [label="Debug.Assert(ordinal >= 0); 262832"];
12230 [label="bound.AssemblySymbol 262833"];
12231 [label="newSymbols.Add(i); 262834"];
12232 [label="newSymbols.Add(i); 262835"];
12233 [label="bound.AssemblySymbol.IsLinked 262836"];
12234 [label="get\n            {\n                return _isLinked;\n            } 262837"];
12235 [label="return _isLinked; 262838"];
12236 [label="newSymbols.Add(i); 262839"];
12237 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 262840"];
12238 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 262841"];
12239 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 262842"];
12240 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 262843"];
12241 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 262844"];
12242 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 262845"];
12243 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 262846"];
12244 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 262847"];
12245 [label="param SourceAssemblySymbol(string assemblySimpleName) 262848"];
12246 [label="param SourceAssemblySymbol(string moduleName) 262849"];
12247 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 262850"];
12248 [label="param SourceAssemblySymbol(this) 262851"];
12249 [label="param SourceAssemblySymbol(this) 262852"];
12250 [label="param MetadataOrSourceAssemblySymbol(this) 262853"];
12251 [label="param MetadataOrSourceAssemblySymbol(this) 262854"];
12252 [label="param NonMissingAssemblySymbol(this) 262855"];
12253 [label="param NonMissingAssemblySymbol(this) 262856"];
12254 [label="param AssemblySymbol(this) 262857"];
12255 [label="param AssemblySymbol(this) 262858"];
12256 [label="param Symbol(this) 262859"];
12257 [label="_lazyISymbol 262860"];
12258 [label="_corLibrary 262861"];
12259 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 262862"];
12260 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 262863"];
12261 [label="_globalNamespace 262864"];
12262 [label="_lazySpecialTypes 262865"];
12263 [label="_cachedSpecialTypes 262866"];
12264 [label="_lazyNativeIntegerTypes 262867"];
12265 [label="_lazyTypeNames 262868"];
12266 [label="_lazyNamespaceNames 262869"];
12267 [label="_lazySpecialTypeMembers 262870"];
12268 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 262871"];
12269 [label="_compilation 262872"];
12270 [label="lazyAssemblyIdentity 262873"];
12271 [label="_assemblySimpleName 262874"];
12272 [label="_lazyStrongNameKeys 262875"];
12273 [label="_lazySourceAttributesBag 262876"];
12274 [label="_lazyNetModuleAttributesBag 262877"];
12275 [label="_lazyForwardedTypesFromSource 262878"];
12276 [label="_lazyOmittedAttributeIndices 262879"];
12277 [label="_lazyContainsExtensionMethods 262880"];
12278 [label="new ConcurrentDictionary<FieldSymbol, bool>() 262881"];
12279 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 262882"];
12280 [label="new ConcurrentSet<FieldSymbol>() 262883"];
12281 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 262884"];
12282 [label="new ConcurrentSet<TypeSymbol>() 262885"];
12283 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 262886"];
12284 [label="_optimisticallyGrantedInternalsAccess 262887"];
12285 [label="_lazyInternalsVisibleToMap 262888"];
12286 [label="Debug.Assert(compilation != null); 262889"];
12287 [label="Debug.Assert(compilation != null); 262890"];
12288 [label="Debug.Assert(assemblySimpleName != null); 262891"];
12289 [label="Debug.Assert(assemblySimpleName != null); 262892"];
12290 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 262893"];
12291 [label="Debug.Assert(!netModules.IsDefault); 262894"];
12292 [label="_compilation 262895"];
12293 [label="_assemblySimpleName 262896"];
12294 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 262897"];
12295 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 262898"];
12296 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 262899"];
12297 [label="compilation.Declarations 262900"];
12298 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 262901"];
12299 [label="_syntaxAndDeclarations.GetLazyState() 262902"];
12300 [label="param GetLazyState(this) 262903"];
12301 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 262904"];
12302 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 262905"];
12303 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 262906"];
12304 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 262907"];
12305 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 262908"];
12306 [label="param SourceModuleSymbol(DeclarationTable declarations) 262909"];
12307 [label="param SourceModuleSymbol(string moduleName) 262910"];
12308 [label="param SourceModuleSymbol(this) 262911"];
12309 [label="param SourceModuleSymbol(this) 262912"];
12310 [label="param NonMissingModuleSymbol(this) 262913"];
12311 [label="param NonMissingModuleSymbol(this) 262914"];
12312 [label="param ModuleSymbol(this) 262915"];
12313 [label="param ModuleSymbol(this) 262916"];
12314 [label="param Symbol(this) 262917"];
12315 [label="_lazyISymbol 262918"];
12316 [label="_moduleReferences 262919"];
12317 [label="_assemblySymbol 262920"];
12318 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 262921"];
12319 [label="_sources 262922"];
12320 [label="_lazyCustomAttributesBag 262923"];
12321 [label="_globalNamespace 262924"];
12322 [label="_hasBadAttributes 262925"];
12323 [label="_name 262926"];
12324 [label="Debug.Assert((object)assemblySymbol != null); 262927"];
12325 [label="Debug.Assert((object)assemblySymbol != null); 262928"];
12326 [label="_assemblySymbol 262929"];
12327 [label="_sources 262930"];
12328 [label="_name 262931"];
12329 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 262932"];
12330 [label="compilation.Options 262933"];
12331 [label="get\n            {\n                return _options;\n            } 262934"];
12332 [label="return _options; 262935"];
12333 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 262936"];
12334 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 262937"];
12335 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 262938"];
12336 [label="_modules = moduleBuilder.ToImmutableAndFree(); 262939"];
12337 [label="_modules 262940"];
12338 [label="compilation.Options 262941"];
12339 [label="get\n            {\n                return _options;\n            } 262942"];
12340 [label="return _options; 262943"];
12341 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 262944"];
12342 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 262945"];
12343 [label="AssemblySymbol? corLibrary; 262946"];
12344 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 262947"];
12345 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 262948"];
12346 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 262949"];
12347 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 262950"];
12348 [label="assemblySymbol.SetCorLibrary(corLibrary); 262951"];
12349 [label="assemblySymbol.SetCorLibrary(corLibrary) 262952"];
12350 [label="param SetCorLibrary(AssemblySymbol corLibrary) 262953"];
12351 [label="param SetCorLibrary(this) 262954"];
12352 [label="Debug.Assert((object)_corLibrary == null); 262955"];
12353 [label="Debug.Assert((object)_corLibrary == null); 262956"];
12354 [label="_corLibrary 262957"];
12355 [label="assemblySymbol.SetCorLibrary(corLibrary); 262958"];
12356 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 262959"];
12357 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 262960"];
12358 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 262961"];
12359 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 262962"];
12360 [label="moduleReferences 262963"];
12361 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262964"];
12362 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262965"];
12363 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262966"];
12364 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262967"];
12365 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262968"];
12366 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 262969"];
12367 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 262970"];
12368 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 262971"];
12369 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 262972"];
12370 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 262973"];
12371 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 262974"];
12372 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 262975"];
12373 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 262976"];
12374 [label="sourceAssembly.Modules 262977"];
12375 [label="get\n            {\n                return _modules;\n            } 262978"];
12376 [label="return _modules; 262979"];
12377 [label="var moduleSymbols = sourceAssembly.Modules; 262980"];
12378 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 262981"];
12379 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 262982"];
12380 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 262983"];
12381 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 262984"];
12382 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 262985"];
12383 [label="(moduleSymbols.Length > 1) 262986"];
12384 [label="int refsUsed = 0; 262987"];
12385 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 262988"];
12386 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 262989"];
12387 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 262990"];
12388 [label="(moduleIndex == 0) 262991"];
12389 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 262992"];
12390 [label="var identities = new AssemblyIdentity[refsCount]; 262993"];
12391 [label="var symbols = new AssemblySymbol[refsCount]; 262994"];
12392 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 262995"];
12393 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 262996"];
12394 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 262997"];
12395 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 262998"];
12396 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 262999"];
12397 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263000"];
12398 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263001"];
12399 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263002"];
12400 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263003"];
12401 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 263004"];
12402 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 263005"];
12403 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263006"];
12404 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263007"];
12405 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263008"];
12406 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 263009"];
12407 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 263010"];
12408 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 263011"];
12409 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 263012"];
12410 [label="Debug.Assert(referenceBinding.IsBound); 263013"];
12411 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263014"];
12412 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 263015"];
12413 [label="Debug.Assert(assembly is object); 263016"];
12414 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263017"];
12415 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263018"];
12416 [label="return assembly; 263019"];
12417 [label="symbols[k] 263020"];
12418 [label="identities[k] 263021"];
12419 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263022"];
12420 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 263023"];
12421 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 263024"];
12422 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 263025"];
12423 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263026"];
12424 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263027"];
12425 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 263028"];
12426 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 263029"];
12427 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 263030"];
12428 [label="Debug.Assert(referenceBinding.IsBound); 263031"];
12429 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263032"];
12430 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 263033"];
12431 [label="Debug.Assert(assembly is object); 263034"];
12432 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263035"];
12433 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263036"];
12434 [label="return assembly; 263037"];
12435 [label="symbols[k] 263038"];
12436 [label="identities[k] 263039"];
12437 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263040"];
12438 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263041"];
12439 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263042"];
12440 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263043"];
12441 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263044"];
12442 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 263045"];
12443 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 263046"];
12444 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 263047"];
12445 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 263048"];
12446 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 263049"];
12447 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 263050"];
12448 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 263051"];
12449 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263052"];
12450 [label="param SetReferences(this) 263053"];
12451 [label="Debug.Assert(moduleReferences != null); 263054"];
12452 [label="Debug.Assert(moduleReferences != null); 263055"];
12453 [label="AssertReferencesUninitialized() 263056"];
12454 [label="param AssertReferencesUninitialized(this) 263057"];
12455 [label="Debug.Assert(_moduleReferences == null); 263058"];
12456 [label="Debug.Assert(_moduleReferences == null); 263059"];
12457 [label="AssertReferencesUninitialized(); 263060"];
12458 [label="_moduleReferences 263061"];
12459 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 263062"];
12460 [label="refsUsed += refsCount; 263063"];
12461 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 263064"];
12462 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 263065"];
12463 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 263066"];
12464 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 263067"];
12465 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 263068"];
12466 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 263069"];
12467 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 263070"];
12468 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 263071"];
12469 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 263072"];
12470 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 263073"];
12471 [label="param InitializeNewSymbols(List<int> newSymbols) 263074"];
12472 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 263075"];
12473 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 263076"];
12474 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 263077"];
12475 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 263078"];
12476 [label="Debug.Assert(newSymbols.Count > 0); 263079"];
12477 [label="Debug.Assert(newSymbols.Count > 0); 263080"];
12478 [label="sourceAssembly.CorLibrary 263081"];
12479 [label="get\n            {\n                return _corLibrary;\n            } 263082"];
12480 [label="return _corLibrary; 263083"];
12481 [label="var corLibrary = sourceAssembly.CorLibrary; 263084"];
12482 [label="RoslynDebug.Assert((object)corLibrary != null); 263085"];
12483 [label="RoslynDebug.Assert((object)corLibrary != null); 263086"];
12484 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 263087"];
12485 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 263088"];
12486 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 263089"];
12487 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 263090"];
12488 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 263091"];
12489 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263092"];
12490 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263093"];
12491 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263094"];
12492 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263095"];
12493 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263096"];
12494 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 263097"];
12495 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 263098"];
12496 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 263099"];
12497 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 263100"];
12498 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 263101"];
12499 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 263102"];
12500 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263103"];
12501 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263104"];
12502 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 263105"];
12503 [label="portableExecutableAssemblySymbol.Modules 263106"];
12504 [label="get\n            {\n                return _modules;\n            } 263107"];
12505 [label="return _modules; 263108"];
12506 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 263109"];
12507 [label="int moduleCount = modules.Length; 263110"];
12508 [label="int refsUsed = 0; 263111"];
12509 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 263112"];
12510 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 263113"];
12511 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 263114"];
12512 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 263115"];
12513 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 263116"];
12514 [label="fileData.AssemblyReferences 263117"];
12515 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 263118"];
12516 [label="return _referencedAssemblies; 263119"];
12517 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263120"];
12518 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263121"];
12519 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263122"];
12520 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263123"];
12521 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263124"];
12522 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 263125"];
12523 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 263126"];
12524 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 263127"];
12525 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 263128"];
12526 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263129"];
12527 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263130"];
12528 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263131"];
12529 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263132"];
12530 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263133"];
12531 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 263134"];
12532 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 263135"];
12533 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 263136"];
12534 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 263137"];
12535 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 263138"];
12536 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263139"];
12537 [label="param SetReferences(this) 263140"];
12538 [label="Debug.Assert(moduleReferences != null); 263141"];
12539 [label="Debug.Assert(moduleReferences != null); 263142"];
12540 [label="AssertReferencesUninitialized() 263143"];
12541 [label="param AssertReferencesUninitialized(this) 263144"];
12542 [label="Debug.Assert(_moduleReferences == null); 263145"];
12543 [label="Debug.Assert(_moduleReferences == null); 263146"];
12544 [label="AssertReferencesUninitialized(); 263147"];
12545 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 263148"];
12546 [label="refsUsed += moduleReferenceCount; 263149"];
12547 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263150"];
12548 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263151"];
12549 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263152"];
12550 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 263153"];
12551 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 263154"];
12552 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263155"];
12553 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263156"];
12554 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 263157"];
12555 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 263158"];
12556 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 263159"];
12557 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263160"];
12558 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263161"];
12559 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 263162"];
12560 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 263163"];
12561 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 263164"];
12562 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 263165"];
12563 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 263166"];
12564 [label="Debug.Assert(referenceBinding.IsBound); 263167"];
12565 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263168"];
12566 [label="Debug.Assert(assembly is object); 263169"];
12567 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263170"];
12568 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263171"];
12569 [label="symbols[k] 263172"];
12570 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 263173"];
12571 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 263174"];
12572 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 263175"];
12573 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 263176"];
12574 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 263177"];
12575 [label="MissingAssemblySymbol? missingAssembly; 263178"];
12576 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 263179"];
12577 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 263180"];
12578 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 263181"];
12579 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 263182"];
12580 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 263183"];
12581 [label="new MissingAssemblySymbol(assemblyIdentity) 263184"];
12582 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 263185"];
12583 [label="param MissingAssemblySymbol(this) 263186"];
12584 [label="param MissingAssemblySymbol(this) 263187"];
12585 [label="identity 263188"];
12586 [label="moduleSymbol 263189"];
12587 [label="Debug.Assert(identity != null); 263190"];
12588 [label="Debug.Assert(identity != null); 263191"];
12589 [label="this.identity 263192"];
12590 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 263193"];
12591 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 263194"];
12592 [label="new MissingModuleSymbol(this, 0) 263195"];
12593 [label="param MissingModuleSymbol(AssemblySymbol assembly) 263196"];
12594 [label="param MissingModuleSymbol(int ordinal) 263197"];
12595 [label="param MissingModuleSymbol(this) 263198"];
12596 [label="param MissingModuleSymbol(this) 263199"];
12597 [label="assembly 263200"];
12598 [label="ordinal 263201"];
12599 [label="globalNamespace 263202"];
12600 [label="Debug.Assert((object)assembly != null); 263203"];
12601 [label="Debug.Assert((object)assembly != null); 263204"];
12602 [label="Debug.Assert(ordinal >= -1); 263205"];
12603 [label="Debug.Assert(ordinal >= -1); 263206"];
12604 [label="this.assembly 263207"];
12605 [label="this.ordinal 263208"];
12606 [label="globalNamespace = new MissingNamespaceSymbol(this); 263209"];
12607 [label="globalNamespace = new MissingNamespaceSymbol(this); 263210"];
12608 [label="new MissingNamespaceSymbol(this) 263211"];
12609 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 263212"];
12610 [label="param MissingNamespaceSymbol(this) 263213"];
12611 [label="param MissingNamespaceSymbol(this) 263214"];
12612 [label="_name 263215"];
12613 [label="_containingSymbol 263216"];
12614 [label="Debug.Assert((object)containingModule != null); 263217"];
12615 [label="Debug.Assert((object)containingModule != null); 263218"];
12616 [label="_containingSymbol 263219"];
12617 [label="_name 263220"];
12618 [label="globalNamespace 263221"];
12619 [label="moduleSymbol 263222"];
12620 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 263223"];
12621 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 263224"];
12622 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 263225"];
12623 [label="return missingAssembly; 263226"];
12624 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 263227"];
12625 [label="symbols[k] 263228"];
12626 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 263229"];
12627 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 263230"];
12628 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 263231"];
12629 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 263232"];
12630 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263233"];
12631 [label="Debug.Assert(moduleReferences != null); 263234"];
12632 [label="Debug.Assert(moduleReferences != null); 263235"];
12633 [label="AssertReferencesUninitialized() 263236"];
12634 [label="param AssertReferencesUninitialized(this) 263237"];
12635 [label="Debug.Assert(_moduleReferences == null); 263238"];
12636 [label="Debug.Assert(_moduleReferences == null); 263239"];
12637 [label="AssertReferencesUninitialized(); 263240"];
12638 [label="refsUsed += moduleReferenceCount; 263241"];
12639 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263242"];
12640 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 263243"];
12641 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263244"];
12642 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263245"];
12643 [label="Debug.Assert(referenceBinding.IsBound); 263246"];
12644 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263247"];
12645 [label="Debug.Assert(assembly is object); 263248"];
12646 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263249"];
12647 [label="return missingAssembly; 263250"];
12648 [label="identity 263251"];
12649 [label="moduleSymbol 263252"];
12650 [label="Debug.Assert(identity != null); 263253"];
12651 [label="Debug.Assert(identity != null); 263254"];
12652 [label="assembly 263255"];
12653 [label="ordinal 263256"];
12654 [label="globalNamespace 263257"];
12655 [label="Debug.Assert((object)assembly != null); 263258"];
12656 [label="Debug.Assert((object)assembly != null); 263259"];
12657 [label="Debug.Assert(ordinal >= -1); 263260"];
12658 [label="Debug.Assert(ordinal >= -1); 263261"];
12659 [label="_name 263262"];
12660 [label="_containingSymbol 263263"];
12661 [label="Debug.Assert((object)containingModule != null); 263264"];
12662 [label="Debug.Assert((object)containingModule != null); 263265"];
12663 [label="identity 263266"];
12664 [label="moduleSymbol 263267"];
12665 [label="Debug.Assert(identity != null); 263268"];
12666 [label="assembly 263269"];
12667 [label="ordinal 263270"];
12668 [label="globalNamespace 263271"];
12669 [label="Debug.Assert((object)assembly != null); 263272"];
12670 [label="Debug.Assert(ordinal >= -1); 263273"];
12671 [label="_name 263274"];
12672 [label="_containingSymbol 263275"];
12673 [label="Debug.Assert((object)containingModule != null); 263276"];
12674 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263277"];
12675 [label="Debug.Assert(moduleReferences != null); 263278"];
12676 [label="Debug.Assert(moduleReferences != null); 263279"];
12677 [label="AssertReferencesUninitialized() 263280"];
12678 [label="param AssertReferencesUninitialized(this) 263281"];
12679 [label="Debug.Assert(_moduleReferences == null); 263282"];
12680 [label="Debug.Assert(_moduleReferences == null); 263283"];
12681 [label="AssertReferencesUninitialized(); 263284"];
12682 [label="refsUsed += moduleReferenceCount; 263285"];
12683 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263286"];
12684 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 263287"];
12685 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263288"];
12686 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263289"];
12687 [label="Debug.Assert(referenceBinding.IsBound); 263290"];
12688 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263291"];
12689 [label="Debug.Assert(assembly is object); 263292"];
12690 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 263293"];
12691 [label="if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    } 263294"];
12692 [label="unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>(); 263295"];
12693 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 263296"];
12694 [label="unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity)); 263297"];
12695 [label="identity 263298"];
12696 [label="moduleSymbol 263299"];
12697 [label="Debug.Assert(identity != null); 263300"];
12698 [label="assembly 263301"];
12699 [label="ordinal 263302"];
12700 [label="globalNamespace 263303"];
12701 [label="Debug.Assert((object)assembly != null); 263304"];
12702 [label="Debug.Assert(ordinal >= -1); 263305"];
12703 [label="_name 263306"];
12704 [label="_containingSymbol 263307"];
12705 [label="Debug.Assert((object)containingModule != null); 263308"];
12706 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263309"];
12707 [label="Debug.Assert(moduleReferences != null); 263310"];
12708 [label="Debug.Assert(moduleReferences != null); 263311"];
12709 [label="AssertReferencesUninitialized() 263312"];
12710 [label="param AssertReferencesUninitialized(this) 263313"];
12711 [label="Debug.Assert(_moduleReferences == null); 263314"];
12712 [label="Debug.Assert(_moduleReferences == null); 263315"];
12713 [label="AssertReferencesUninitialized(); 263316"];
12714 [label="refsUsed += moduleReferenceCount; 263317"];
12715 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 263318"];
12716 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 263319"];
12717 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263320"];
12718 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263321"];
12719 [label="Debug.Assert(referenceBinding.IsBound); 263322"];
12720 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 263323"];
12721 [label="Debug.Assert(assembly is object); 263324"];
12722 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 263325"];
12723 [label="Debug.Assert(moduleReferences != null); 263326"];
12724 [label="AssertReferencesUninitialized() 263327"];
12725 [label="param AssertReferencesUninitialized(this) 263328"];
12726 [label="Debug.Assert(_moduleReferences == null); 263329"];
12727 [label="Debug.Assert(_moduleReferences == null); 263330"];
12728 [label="AssertReferencesUninitialized(); 263331"];
12729 [label="refsUsed += moduleReferenceCount; 263332"];
12730 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 263333"];
12731 [label="sourceAssembly.Modules 263334"];
12732 [label="get\n            {\n                return _modules;\n            } 263335"];
12733 [label="return _modules; 263336"];
12734 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 263337"];
12735 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 263338"];
12736 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 263339"];
12737 [label="param GetReferencedAssemblySymbols(this) 263340"];
12738 [label="AssertReferencesInitialized() 263341"];
12739 [label="param AssertReferencesInitialized(this) 263342"];
12740 [label="Debug.Assert(_moduleReferences != null); 263343"];
12741 [label="Debug.Assert(_moduleReferences != null); 263344"];
12742 [label="AssertReferencesInitialized(); 263345"];
12743 [label="return _moduleReferences.Symbols; 263346"];
12744 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 263347"];
12745 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 263348"];
12746 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263349"];
12747 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263350"];
12748 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 263351"];
12749 [label="assemblies[i].ContainsNoPiaLocalTypes 263352"];
12750 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 263353"];
12751 [label="linkedReferencedAssembliesBuilder.Clear(); 263354"];
12752 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 263355"];
12753 [label="assemblies[i].IsLinked 263356"];
12754 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 263357"];
12755 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 263358"];
12756 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 263359"];
12757 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 263360"];
12758 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 263361"];
12759 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 263362"];
12760 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 263363"];
12761 [label="param SetCorLibrary(AssemblySymbol corLibrary) 263364"];
12762 [label="param SetCorLibrary(this) 263365"];
12763 [label="Debug.Assert((object)_corLibrary == null); 263366"];
12764 [label="Debug.Assert((object)_corLibrary == null); 263367"];
12765 [label="_corLibrary 263368"];
12766 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 263369"];
12767 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 263370"];
12768 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263371"];
12769 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263372"];
12770 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 263373"];
12771 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 263374"];
12772 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 263375"];
12773 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 263376"];
12774 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 263377"];
12775 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 263378"];
12776 [label="Debug.Assert((object)_corLibrary == null); 263379"];
12777 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 263380"];
12778 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 263381"];
12779 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 263382"];
12780 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 263383"];
12781 [label="Debug.Assert((object)_corLibrary == null); 263384"];
12782 [label="linkedReferencedAssembliesBuilder.Free(); 263385"];
12783 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 263386"];
12784 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 263387"];
12785 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 263388"];
12786 [label="missingAssembly.SetCorLibrary(corLibrary); 263389"];
12787 [label="missingAssembly.SetCorLibrary(corLibrary) 263390"];
12788 [label="param SetCorLibrary(AssemblySymbol corLibrary) 263391"];
12789 [label="Debug.Assert((object)_corLibrary == null); 263392"];
12790 [label="missingAssembly.SetCorLibrary(corLibrary); 263393"];
12791 [label="Debug.Assert((object)_corLibrary == null); 263394"];
12792 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 263395"];
12793 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 263396"];
12794 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 263397"];
12795 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 263398"];
12796 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 263399"];
12797 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 263400"];
12798 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 263401"];
12799 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 263402"];
12800 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 263403"];
12801 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 263404"];
12802 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 263405"];
12803 [label="ref BoundInputAssembly current = ref bindingResult[i]; 263406"];
12804 [label="Debug.Assert(current.AssemblySymbol is object); 263407"];
12805 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 263408"];
12806 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 263409"];
12807 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 263410"];
12808 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 263411"];
12809 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 263412"];
12810 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 263413"];
12811 [label="Debug.Assert(current.AssemblySymbol is object); 263414"];
12812 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 263415"];
12813 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263416"];
12814 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263417"];
12815 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263418"];
12816 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263419"];
12817 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263420"];
12818 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263421"];
12819 [label="ReferenceEquals(corLibrary, assemblySymbol) 263422"];
12820 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263423"];
12821 [label="assemblySymbol.SourceModule 263424"];
12822 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 263425"];
12823 [label="this.Modules 263426"];
12824 [label="get\n            {\n                return _modules;\n            } 263427"];
12825 [label="return _modules; 263428"];
12826 [label="return (SourceModuleSymbol)this.Modules[0]; 263429"];
12827 [label="return (SourceModuleSymbol)this.Modules[0]; 263430"];
12828 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 263431"];
12829 [label="param GetReferencedAssemblySymbols(this) 263432"];
12830 [label="AssertReferencesInitialized() 263433"];
12831 [label="param AssertReferencesInitialized(this) 263434"];
12832 [label="Debug.Assert(_moduleReferences != null); 263435"];
12833 [label="Debug.Assert(_moduleReferences != null); 263436"];
12834 [label="AssertReferencesInitialized(); 263437"];
12835 [label="return _moduleReferences.Symbols; 263438"];
12836 [label="assemblySymbol.SourceModule 263439"];
12837 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 263440"];
12838 [label="this.Modules 263441"];
12839 [label="get\n            {\n                return _modules;\n            } 263442"];
12840 [label="return _modules; 263443"];
12841 [label="return (SourceModuleSymbol)this.Modules[0]; 263444"];
12842 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 263445"];
12843 [label="param GetUnifiedAssemblies(this) 263446"];
12844 [label="AssertReferencesInitialized() 263447"];
12845 [label="param AssertReferencesInitialized(this) 263448"];
12846 [label="Debug.Assert(_moduleReferences != null); 263449"];
12847 [label="Debug.Assert(_moduleReferences != null); 263450"];
12848 [label="AssertReferencesInitialized(); 263451"];
12849 [label="return _moduleReferences.UnifiedAssemblies; 263452"];
12850 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 263453"];
12851 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 263454"];
12852 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 263455"];
12853 [label="compilation._referenceManager 263456"];
12854 [label="compilation._lazyAssemblySymbol 263457"];
12855 [label="return true; 263458"];
12856 [label="resolutionDiagnostics.Free(); 263459"];
12857 [label="assemblyReferencesBySimpleName.Free(); 263460"];
12858 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 263461"];
12859 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 263462"];
12860 [label="AssertBound(); 263463"];
12861 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 263464"];
12862 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 263465"];
12863 [label="Debug.Assert(_lazyAssemblySymbol is object); 263466"];
12864 [label="return _referenceManager; 263467"];
12865 [label="GetBoundReferenceManager(); 263468"];
12866 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 263469"];
12867 [label="return _lazyAssemblySymbol; 263470"];
12868 [label="return SourceAssembly; 263471"];
12869 [label="modules.AddRange(Assembly.Modules); 263472"];
12870 [label="Assembly.Modules 263473"];
12871 [label="get\n            {\n                return _modules;\n            } 263474"];
12872 [label="modules.AddRange(Assembly.Modules); 263475"];
12873 [label="GetBoundReferenceManager() 263476"];
12874 [label="param GetBoundReferenceManager(this) 263477"];
12875 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 263478"];
12876 [label="return _referenceManager; 263479"];
12877 [label="var referenceManager = GetBoundReferenceManager(); 263480"];
12878 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 263481"];
12879 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 263482"];
12880 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 263483"];
12881 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 263484"];
12882 [label="referenceManager.ReferencedAssemblies[i].Modules 263485"];
12883 [label="get\n            {\n                return _modules;\n            } 263486"];
12884 [label="GetAllUnaliasedModules(modules); 263487"];
12885 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 263488"];
12886 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 263489"];
12887 [label="new NamespaceExtent(this) 263490"];
12888 [label="param NamespaceExtent(CSharpCompilation compilation) 263491"];
12889 [label="param NamespaceExtent(this) 263492"];
12890 [label="_kind 263493"];
12891 [label="_symbolOrCompilation 263494"];
12892 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 263495"];
12893 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 263496"];
12894 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 263497"];
12895 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 263498"];
12896 [label="var diagnostics = DiagnosticBag.GetInstance(); 263499"];
12897 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 263500"];
12898 [label="DeclaringCompilation 263501"];
12899 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 263502"];
12900 [label="_assemblySymbol.DeclaringCompilation 263503"];
12901 [label="get\n            {\n                return _compilation;\n            } 263504"];
12902 [label="return _compilation; 263505"];
12903 [label="return _assemblySymbol.DeclaringCompilation; 263506"];
12904 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 263507"];
12905 [label="DeclaringCompilation.MergedRootDeclaration 263508"];
12906 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 263509"];
12907 [label="Declarations 263510"];
12908 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 263511"];
12909 [label="return Declarations.GetMergedRoot(this); 263512"];
12910 [label="return Declarations.GetMergedRoot(this); 263513"];
12911 [label="Declarations.GetMergedRoot(this) 263514"];
12912 [label="param GetMergedRoot(CSharpCompilation compilation) 263515"];
12913 [label="param GetMergedRoot(this) 263516"];
12914 [label="compilation.Declarations 263517"];
12915 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 263518"];
12916 [label="Debug.Assert(compilation.Declarations == this); 263519"];
12917 [label="Debug.Assert(compilation.Declarations == this); 263520"];
12918 [label="if (_mergedRoot == null)\n            {\n                Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null);\n            } 263521"];
12919 [label="if (_mergedRoot == null)\n            {\n                Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null);\n            } 263522"];
12920 [label="Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null); 263523"];
12921 [label="Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null); 263524"];
12922 [label="CalculateMergedRoot(compilation) 263525"];
12923 [label="param CalculateMergedRoot(CSharpCompilation compilation) 263526"];
12924 [label="param CalculateMergedRoot(this) 263527"];
12925 [label="var oldRoot = _cache.MergedRoot.Value; 263528"];
12926 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return oldRoot;\n            }\n            else if (oldRoot == null)\n            {\n                return MergedNamespaceDeclaration.Create(_latestLazyRootDeclaration.Value);\n            }\n            else\n            {\n                var oldRootDeclarations = oldRoot.Declarations;\n                var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1);\n                builder.AddRange(oldRootDeclarations);\n                builder.Add(_latestLazyRootDeclaration.Value);\n                // Sort the root namespace declarations to match the order of SyntaxTrees.\n                if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                }\n                return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree());\n            } 263529"];
12927 [label="if (_latestLazyRootDeclaration == null)\n            {\n                return oldRoot;\n            }\n            else if (oldRoot == null)\n            {\n                return MergedNamespaceDeclaration.Create(_latestLazyRootDeclaration.Value);\n            }\n            else\n            {\n                var oldRootDeclarations = oldRoot.Declarations;\n                var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1);\n                builder.AddRange(oldRootDeclarations);\n                builder.Add(_latestLazyRootDeclaration.Value);\n                // Sort the root namespace declarations to match the order of SyntaxTrees.\n                if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                }\n                return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree());\n            } 263530"];
12928 [label="if (oldRoot == null)\n            {\n                return MergedNamespaceDeclaration.Create(_latestLazyRootDeclaration.Value);\n            }\n            else\n            {\n                var oldRootDeclarations = oldRoot.Declarations;\n                var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1);\n                builder.AddRange(oldRootDeclarations);\n                builder.Add(_latestLazyRootDeclaration.Value);\n                // Sort the root namespace declarations to match the order of SyntaxTrees.\n                if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                }\n                return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree());\n            } 263531"];
12929 [label="if (oldRoot == null)\n            {\n                return MergedNamespaceDeclaration.Create(_latestLazyRootDeclaration.Value);\n            }\n            else\n            {\n                var oldRootDeclarations = oldRoot.Declarations;\n                var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1);\n                builder.AddRange(oldRootDeclarations);\n                builder.Add(_latestLazyRootDeclaration.Value);\n                // Sort the root namespace declarations to match the order of SyntaxTrees.\n                if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                }\n                return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree());\n            } 263532"];
12930 [label="oldRoot.Declarations 263533"];
12931 [label="var oldRootDeclarations = oldRoot.Declarations; 263534"];
12932 [label="var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1); 263535"];
12933 [label="var builder = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(oldRootDeclarations.Length + 1); 263536"];
12934 [label="builder.AddRange(oldRootDeclarations); 263537"];
12935 [label="builder.AddRange(oldRootDeclarations); 263538"];
12936 [label="builder.Add(_latestLazyRootDeclaration.Value); 263539"];
12937 [label="if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                } 263540"];
12938 [label="if (compilation != null)\n                {\n                    builder.Sort(new RootNamespaceLocationComparer(compilation));\n                } 263541"];
12939 [label="builder.Sort(new RootNamespaceLocationComparer(compilation)); 263542"];
12940 [label="builder.Sort(new RootNamespaceLocationComparer(compilation)); 263543"];
12941 [label="new RootNamespaceLocationComparer(compilation) 263544"];
12942 [label="param RootNamespaceLocationComparer(CSharpCompilation compilation) 263545"];
12943 [label="param RootNamespaceLocationComparer(this) 263546"];
12944 [label="_compilation 263547"];
12945 [label="_compilation 263548"];
12946 [label="builder.Sort(new RootNamespaceLocationComparer(compilation)); 263549"];
12947 [label="return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree()); 263550"];
12948 [label="MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree()) 263551"];
12949 [label="param Create(ImmutableArray<SingleNamespaceDeclaration> declarations) 263552"];
12950 [label="0 263553"];
12951 [label="declarations[0] 263554"];
12952 [label="declarations[0].Name 263555"];
12953 [label="get\n            {\n                return this.name;\n            } 263556"];
12954 [label="return this.name; 263557"];
12955 [label="name 263558"];
12956 [label="return MergedNamespaceDeclaration.Create(builder.ToImmutableAndFree()); 263559"];
12957 [label="Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null); 263560"];
12958 [label="Interlocked.CompareExchange(ref _mergedRoot, CalculateMergedRoot(compilation), null); 263561"];
12959 [label="return _mergedRoot; 263562"];
12960 [label="0x1 263563"];
12961 [label="LazyAllMembersIsSorted = 0x1 263564"];
12962 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 263565"];
12963 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 263566"];
12964 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 263567"];
12965 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 263568"];
12966 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 263569"];
12967 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 263570"];
12968 [label="param SourceNamespaceSymbol(Symbol container) 263571"];
12969 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 263572"];
12970 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 263573"];
12971 [label="param SourceNamespaceSymbol(this) 263574"];
12972 [label="param SourceNamespaceSymbol(this) 263575"];
12973 [label="_module 263576"];
12974 [label="_container 263577"];
12975 [label="_mergedDeclaration 263578"];
12976 [label="_nameToMembersMap 263579"];
12977 [label="_nameToTypeMembersMap 263580"];
12978 [label="_flags 263581"];
12979 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 263582"];
12980 [label="1 263583"];
12981 [label="_treeOrdinal 263584"];
12982 [label="0 263585"];
12983 [label="_position 263586"];
12984 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 263587"];
12985 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 263588"];
12986 [label="1 263589"];
12987 [label="_treeOrdinal 263590"];
12988 [label="1 263591"];
12989 [label="_position 263592"];
12990 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 263593"];
12991 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 263594"];
12992 [label="_treeOrdinal 263595"];
12993 [label="1 263596"];
12994 [label="int.MaxValue - 1 263597"];
12995 [label="_position 263598"];
12996 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 263599"];
12997 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 263600"];
12998 [label="_treeOrdinal 263601"];
12999 [label="_position 263602"];
13000 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 263603"];
13001 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 263604"];
13002 [label="Debug.Assert(mergedDeclaration != null); 263605"];
13003 [label="Debug.Assert(mergedDeclaration != null); 263606"];
13004 [label="_module 263607"];
13005 [label="_container 263608"];
13006 [label="_mergedDeclaration 263609"];
13007 [label="mergedDeclaration.Declarations 263610"];
13008 [label="get { return _declarations; } 263611"];
13009 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 263612"];
13010 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 263613"];
13011 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 263614"];
13012 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 263615"];
13013 [label="diagnostics.Free(); 263616"];
13014 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 263617"];
13015 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 263618"];
13016 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 263619"];
13017 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 263620"];
13018 [label="return _globalNamespace; 263621"];
13019 [label="param GetHashCode(this) 263622"];
13020 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 263623"];
13021 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 263624"];
13022 [label="get { return _globalNamespace; } 263625"];
13023 [label="return _globalNamespace; 263626"];
13024 [label="MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)) 263627"];
13025 [label="param Create(NamespaceExtent extent) 263628"];
13026 [label="param Create(NamespaceSymbol containingNamespace) 263629"];
13027 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 263630"];
13028 [label="param Create(string nameOpt = null) 263631"];
13029 [label="Debug.Assert(namespacesToMerge.Length != 0); 263632"];
13030 [label="Debug.Assert(namespacesToMerge.Length != 0); 263633"];
13031 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 263634"];
13032 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 263635"];
13033 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 263636"];
13034 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 263637"];
13035 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 263638"];
13036 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 263639"];
13037 [label="new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt) 263640"];
13038 [label="param MergedNamespaceSymbol(NamespaceExtent extent) 263641"];
13039 [label="param MergedNamespaceSymbol(NamespaceSymbol containingNamespace) 263642"];
13040 [label="param MergedNamespaceSymbol(ImmutableArray<NamespaceSymbol> namespacesToMerge) 263643"];
13041 [label="param MergedNamespaceSymbol(string nameOpt) 263644"];
13042 [label="param MergedNamespaceSymbol(this) 263645"];
13043 [label="param MergedNamespaceSymbol(this) 263646"];
13044 [label="_containingNamespace 263647"];
13045 [label="_nameOpt 263648"];
13046 [label="_cachedLookup 263649"];
13047 [label="_extent 263650"];
13048 [label="_namespacesToMerge 263651"];
13049 [label="_containingNamespace 263652"];
13050 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 263653"];
13051 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 263654"];
13052 [label="_cachedLookup 263655"];
13053 [label="_nameOpt 263656"];
13054 [label="foreach (NamespaceSymbol ns in namespacesToMerge)\n            {\n                Debug.Assert(ns.ConstituentNamespaces.Length == 1);\n            } 263657"];
13055 [label="ns.ConstituentNamespaces 263658"];
13056 [label="get\n            {\n                return ImmutableArray.Create(this);\n            } 263659"];
13057 [label="return ImmutableArray.Create(this); 263660"];
13058 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 263661"];
13059 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 263662"];
13060 [label="modules.Free(); 263663"];
13061 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 263664"];
13062 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 263665"];
13063 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 263666"];
13064 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 263667"];
13065 [label="return _lazyGlobalNamespace; 263668"];
13066 [label="var global = comp.GlobalNamespace; 263669"];
13067 [label="var ns1 = global.GetMembers('NS').Single() as NamespaceSymbol; 263670"];
13068 [label="global.GetMembers('NS') 263671"];
13069 [label="param GetMembers(string name) 263672"];
13070 [label="param GetMembers(this) 263673"];
13071 [label="return _cachedLookup[name]; 263674"];
13072 [label="_cachedLookup 263675"];
13073 [label="param SlowGetChildrenOfName(string name) 263676"];
13074 [label="param SlowGetChildrenOfName(this) 263677"];
13075 [label="ArrayBuilder<NamespaceSymbol> namespaceSymbols = null; 263678"];
13076 [label="var otherSymbols = ArrayBuilder<Symbol>.GetInstance(); 263679"];
13077 [label="foreach (NamespaceSymbol namespaceSymbol in _namespacesToMerge)\n            {\n                foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                }\n            } 263680"];
13078 [label="foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                } 263681"];
13079 [label="namespaceSymbol.GetMembers(name) 263682"];
13080 [label="param GetMembers(string name) 263683"];
13081 [label="param GetMembers(this) 263684"];
13082 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 263685"];
13083 [label="members 263686"];
13084 [label="this.GetNameToMembersMap() 263687"];
13085 [label="param GetNameToMembersMap(this) 263688"];
13086 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 263689"];
13087 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 263690"];
13088 [label="var diagnostics = DiagnosticBag.GetInstance(); 263691"];
13089 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 263692"];
13090 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 263693"];
13091 [label="MakeNameToMembersMap(diagnostics) 263694"];
13092 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 263695"];
13093 [label="param MakeNameToMembersMap(this) 263696"];
13094 [label="_mergedDeclaration.Children 263697"];
13095 [label="get\n            {\n                if (_lazyChildren.IsDefault)\n                {\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyChildren, MakeChildren());\n                }\n\n                return _lazyChildren;\n            } 263698"];
13096 [label="if (_lazyChildren.IsDefault)\n                {\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyChildren, MakeChildren());\n                } 263699"];
13097 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyChildren, MakeChildren()); 263700"];
13098 [label="MakeChildren() 263701"];
13099 [label="param MakeChildren(this) 263702"];
13100 [label="ArrayBuilder<SingleNamespaceDeclaration> namespaces = null; 263703"];
13101 [label="ArrayBuilder<SingleTypeDeclaration> types = null; 263704"];
13102 [label="bool allNamespacesHaveSameName = true; 263705"];
13103 [label="bool allTypesHaveSameIdentity = true; 263706"];
13104 [label="foreach (var decl in _declarations)\n            {\n                foreach (var child in decl.Children)\n                {\n                    // it is either a type (more likely)\n                    var asType = child as SingleTypeDeclaration;\n                    if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    }\n\n                    // or it is a namespace\n                    var asNamespace = child as SingleNamespaceDeclaration;\n                    if (asNamespace != null)\n                    {\n                        // handle namespace\n                        if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        }\n\n                        namespaces.Add(asNamespace);\n                        continue;\n                    }\n\n                    // Not sure if we can get here, perhaps, if we have errors, \n                    // but we care only about types and namespaces anyways.\n                }\n            } 263707"];
13105 [label="decl.Children 263708"];
13106 [label="get\n            {\n                return this.GetNamespaceOrTypeDeclarationChildren();\n            } 263709"];
13107 [label="this.GetNamespaceOrTypeDeclarationChildren() 263710"];
13108 [label="param GetNamespaceOrTypeDeclarationChildren(this) 263711"];
13109 [label="return _children; 263712"];
13110 [label="return this.GetNamespaceOrTypeDeclarationChildren(); 263713"];
13111 [label="foreach (var child in decl.Children)\n                {\n                    // it is either a type (more likely)\n                    var asType = child as SingleTypeDeclaration;\n                    if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    }\n\n                    // or it is a namespace\n                    var asNamespace = child as SingleNamespaceDeclaration;\n                    if (asNamespace != null)\n                    {\n                        // handle namespace\n                        if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        }\n\n                        namespaces.Add(asNamespace);\n                        continue;\n                    }\n\n                    // Not sure if we can get here, perhaps, if we have errors, \n                    // but we care only about types and namespaces anyways.\n                } 263714"];
13112 [label="var asType = child as SingleTypeDeclaration; 263715"];
13113 [label="if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    } 263716"];
13114 [label="if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    } 263717"];
13115 [label="var asNamespace = child as SingleNamespaceDeclaration; 263718"];
13116 [label="if (asNamespace != null)\n                    {\n                        // handle namespace\n                        if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        }\n\n                        namespaces.Add(asNamespace);\n                        continue;\n                    } 263719"];
13117 [label="if (asNamespace != null)\n                    {\n                        // handle namespace\n                        if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        }\n\n                        namespaces.Add(asNamespace);\n                        continue;\n                    } 263720"];
13118 [label="if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        } 263721"];
13119 [label="if (namespaces == null)\n                        {\n                            namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance();\n                        }\n                        else if (allNamespacesHaveSameName && !asNamespace.Name.Equals(namespaces[0].Name))\n                        {\n                            allNamespacesHaveSameName = false;\n                        } 263722"];
13120 [label="namespaces = ArrayBuilder<SingleNamespaceDeclaration>.GetInstance(); 263723"];
13121 [label="namespaces.Add(asNamespace); 263724"];
13122 [label="namespaces.Add(asNamespace); 263725"];
13123 [label="var children = ArrayBuilder<MergedNamespaceOrTypeDeclaration>.GetInstance(); 263726"];
13124 [label="if (namespaces != null)\n            {\n                if (allNamespacesHaveSameName)\n                {\n                    children.Add(MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var namespaceGroups = namespaces.ToDictionary(n => n.Name, StringOrdinalComparer.Instance);\n                    namespaces.Free();\n\n                    foreach (var namespaceGroup in namespaceGroups.Values)\n                    {\n                        children.Add(MergedNamespaceDeclaration.Create(namespaceGroup));\n                    }\n                }\n            } 263727"];
13125 [label="if (allNamespacesHaveSameName)\n                {\n                    children.Add(MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var namespaceGroups = namespaces.ToDictionary(n => n.Name, StringOrdinalComparer.Instance);\n                    namespaces.Free();\n\n                    foreach (var namespaceGroup in namespaceGroups.Values)\n                    {\n                        children.Add(MergedNamespaceDeclaration.Create(namespaceGroup));\n                    }\n                } 263728"];
13126 [label="children.Add(MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree())); 263729"];
13127 [label="MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree()) 263730"];
13128 [label="param Create(ImmutableArray<SingleNamespaceDeclaration> declarations) 263731"];
13129 [label="name 263732"];
13130 [label="children.Add(MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree())); 263733"];
13131 [label="children.Add(MergedNamespaceDeclaration.Create(namespaces.ToImmutableAndFree())); 263734"];
13132 [label="if (types != null)\n            {\n                if (allTypesHaveSameIdentity)\n                {\n                    children.Add(new MergedTypeDeclaration(types.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var typeGroups = types.ToDictionary(t => t.Identity);\n                    types.Free();\n\n                    foreach (var typeGroup in typeGroups.Values)\n                    {\n                        children.Add(new MergedTypeDeclaration(typeGroup));\n                    }\n                }\n            } 263735"];
13133 [label="if (types != null)\n            {\n                if (allTypesHaveSameIdentity)\n                {\n                    children.Add(new MergedTypeDeclaration(types.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var typeGroups = types.ToDictionary(t => t.Identity);\n                    types.Free();\n\n                    foreach (var typeGroup in typeGroups.Values)\n                    {\n                        children.Add(new MergedTypeDeclaration(typeGroup));\n                    }\n                }\n            } 263736"];
13134 [label="return children.ToImmutableAndFree(); 263737"];
13135 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyChildren, MakeChildren()); 263738"];
13136 [label="return _lazyChildren; 263739"];
13137 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 263740"];
13138 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 263741"];
13139 [label="new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length) 263742"];
13140 [label="param NameToSymbolMapBuilder(int capacity) 263743"];
13141 [label="param NameToSymbolMapBuilder(this) 263744"];
13142 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 263745"];
13143 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 263746"];
13144 [label="_dictionary 263747"];
13145 [label="_mergedDeclaration.Children 263748"];
13146 [label="get\n            {\n                if (_lazyChildren.IsDefault)\n                {\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyChildren, MakeChildren());\n                }\n\n                return _lazyChildren;\n            } 263749"];
13147 [label="return _lazyChildren; 263750"];
13148 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 263751"];
13149 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 263752"];
13150 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 263753"];
13151 [label="BuildSymbol(declaration, diagnostics) 263754"];
13152 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 263755"];
13153 [label="param BuildSymbol(DiagnosticBag diagnostics) 263756"];
13154 [label="param BuildSymbol(this) 263757"];
13155 [label="declaration.Kind 263758"];
13156 [label="get\n            {\n                return DeclarationKind.Namespace;\n            } 263759"];
13157 [label="return DeclarationKind.Namespace; 263760"];
13158 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 263761"];
13159 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 263762"];
13160 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 263763"];
13161 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 263764"];
13162 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 263765"];
13163 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 263766"];
13164 [label="new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics) 263767"];
13165 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 263768"];
13166 [label="param SourceNamespaceSymbol(Symbol container) 263769"];
13167 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 263770"];
13168 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 263771"];
13169 [label="param SourceNamespaceSymbol(this) 263772"];
13170 [label="_module 263773"];
13171 [label="_container 263774"];
13172 [label="_mergedDeclaration 263775"];
13173 [label="Debug.Assert(mergedDeclaration != null); 263776"];
13174 [label="Debug.Assert(mergedDeclaration != null); 263777"];
13175 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 263778"];
13176 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 263779"];
13177 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 263780"];
13178 [label="param Add(NamespaceOrTypeSymbol symbol) 263781"];
13179 [label="param Add(this) 263782"];
13180 [label="symbol.Name 263783"];
13181 [label="=> _mergedDeclaration.Name 263784"];
13182 [label="_mergedDeclaration.Name 263785"];
13183 [label="get\n            {\n                return this.name;\n            } 263786"];
13184 [label="return this.name; 263787"];
13185 [label="string name = symbol.Name; 263788"];
13186 [label="object item; 263789"];
13187 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 263790"];
13188 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 263791"];
13189 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 263792"];
13190 [label="_dictionary 263793"];
13191 [label="builder.CreateMap() 263794"];
13192 [label="param CreateMap(this) 263795"];
13193 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 263796"];
13194 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 263797"];
13195 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 263798"];
13196 [label="object value = kvp.Value; 263799"];
13197 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 263800"];
13198 [label="members 263801"];
13199 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 263802"];
13200 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 263803"];
13201 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 263804"];
13202 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 263805"];
13203 [label="symbol.Kind 263806"];
13204 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 263807"];
13205 [label="return SymbolKind.Namespace; 263808"];
13206 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 263809"];
13207 [label="symbol.Kind == SymbolKind.Namespace 263810"];
13208 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 263811"];
13209 [label="result.Add(kvp.Key, members); 263812"];
13210 [label="result.Add(kvp.Key, members); 263813"];
13211 [label="result.Add(kvp.Key, members); 263814"];
13212 [label="return result; 263815"];
13213 [label="var result = builder.CreateMap(); 263816"];
13214 [label="CheckMembers(this, result, diagnostics); 263817"];
13215 [label="CheckMembers(this, result, diagnostics); 263818"];
13216 [label="CheckMembers(this, result, diagnostics); 263819"];
13217 [label="CheckMembers(this, result, diagnostics) 263820"];
13218 [label="param CheckMembers(NamespaceSymbol @namespace) 263821"];
13219 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 263822"];
13220 [label="param CheckMembers(DiagnosticBag diagnostics) 263823"];
13221 [label="var memberOfArity = new Symbol[10]; 263824"];
13222 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 263825"];
13223 [label="@namespace.ContainingAssembly 263826"];
13224 [label="=> _module.ContainingAssembly 263827"];
13225 [label="_module.ContainingAssembly 263828"];
13226 [label="get\n            {\n                return _assemblySymbol;\n            } 263829"];
13227 [label="return _assemblySymbol; 263830"];
13228 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 263831"];
13229 [label="@namespace.ContainingAssembly.Modules 263832"];
13230 [label="get\n            {\n                return _modules;\n            } 263833"];
13231 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 263834"];
13232 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 263835"];
13233 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 263836"];
13234 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 263837"];
13235 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 263838"];
13236 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 263839"];
13237 [label="var nts = symbol as NamedTypeSymbol; 263840"];
13238 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 263841"];
13239 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 263842"];
13240 [label="((object)nts != null) 263843"];
13241 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 263844"];
13242 [label="var other = memberOfArity[arity]; 263845"];
13243 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 263846"];
13244 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 263847"];
13245 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 263848"];
13246 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 263849"];
13247 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 263850"];
13248 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 263851"];
13249 [label="memberOfArity[arity] 263852"];
13250 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 263853"];
13251 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 263854"];
13252 [label="CheckMembers(this, result, diagnostics); 263855"];
13253 [label="return result; 263856"];
13254 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 263857"];
13255 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 263858"];
13256 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 263859"];
13257 [label="this.DeclaringCompilation 263860"];
13258 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 263861"];
13259 [label="this.Kind 263862"];
13260 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 263863"];
13261 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 263864"];
13262 [label="this.ContainingModule 263865"];
13263 [label="get\n            {\n                return _module;\n            } 263866"];
13264 [label="return _module; 263867"];
13265 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 263868"];
13266 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 263869"];
13267 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 263870"];
13268 [label="(object)sourceModuleSymbol == null 263871"];
13269 [label="sourceModuleSymbol.DeclaringCompilation 263872"];
13270 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 263873"];
13271 [label="this.DeclaringCompilation.DeclarationDiagnostics 263874"];
13272 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 263875"];
13273 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 263876"];
13274 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 263877"];
13275 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 263878"];
13276 [label="var diagnostics = new DiagnosticBag(); 263879"];
13277 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 263880"];
13278 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 263881"];
13279 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 263882"];
13280 [label="return _lazyDeclarationDiagnostics; 263883"];
13281 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 263884"];
13282 [label="RegisterDeclaredCorTypes() 263885"];
13283 [label="param RegisterDeclaredCorTypes(this) 263886"];
13284 [label="ContainingAssembly 263887"];
13285 [label="=> _module.ContainingAssembly 263888"];
13286 [label="_module.ContainingAssembly 263889"];
13287 [label="get\n            {\n                return _assemblySymbol;\n            } 263890"];
13288 [label="return _assemblySymbol; 263891"];
13289 [label="AssemblySymbol containingAssembly = ContainingAssembly; 263892"];
13290 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 263893"];
13291 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 263894"];
13292 [label="this.CorLibrary 263895"];
13293 [label="get\n            {\n                return _corLibrary;\n            } 263896"];
13294 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 263897"];
13295 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 263898"];
13296 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 263899"];
13297 [label="RegisterDeclaredCorTypes(); 263900"];
13298 [label="DeclaringCompilation 263901"];
13299 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 263902"];
13300 [label="this.Kind 263903"];
13301 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 263904"];
13302 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 263905"];
13303 [label="this.ContainingModule 263906"];
13304 [label="get\n            {\n                return _module;\n            } 263907"];
13305 [label="return _module; 263908"];
13306 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 263909"];
13307 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 263910"];
13308 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 263911"];
13309 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 263912"];
13310 [label="param SymbolDeclaredEvent(Symbol symbol) 263913"];
13311 [label="param SymbolDeclaredEvent(this) 263914"];
13312 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 263915"];
13313 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 263916"];
13314 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 263917"];
13315 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 263918"];
13316 [label="param NotePartComplete(CompletionPart part) 263919"];
13317 [label="param NotePartComplete(this) 263920"];
13318 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 263921"];
13319 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 263922"];
13320 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 263923"];
13321 [label="Debug.Assert(wasSetThisThread); 263924"];
13322 [label="diagnostics.Free(); 263925"];
13323 [label="return _nameToMembersMap; 263926"];
13324 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 263927"];
13325 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 263928"];
13326 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 263929"];
13327 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 263930"];
13328 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 263931"];
13329 [label="childSymbol.Kind 263932"];
13330 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 263933"];
13331 [label="if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    } 263934"];
13332 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 263935"];
13333 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 263936"];
13334 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 263937"];
13335 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 263938"];
13336 [label="param GetMembers(string name) 263939"];
13337 [label="param GetMembers(this) 263940"];
13338 [label="EnsureAllMembersLoaded() 263941"];
13339 [label="param EnsureAllMembersLoaded(this) 263942"];
13340 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 263943"];
13341 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 263944"];
13342 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 263945"];
13343 [label="_moduleSymbol.Module 263946"];
13344 [label="get\n            {\n                return _module;\n            } 263947"];
13345 [label="return _module; 263948"];
13346 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 263949"];
13347 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 263950"];
13348 [label="LoadAllMembers(groups); 263951"];
13349 [label="LoadAllMembers(groups) 263952"];
13350 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 263953"];
13351 [label="param LoadAllMembers(this) 263954"];
13352 [label="Debug.Assert(typesByNS != null); 263955"];
13353 [label="Debug.Assert(typesByNS != null); 263956"];
13354 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 263957"];
13355 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 263958"];
13356 [label="this.IsGlobalNamespace 263959"];
13357 [label="get\n            {\n                return true;\n            } 263960"];
13358 [label="return true; 263961"];
13359 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 263962"];
13360 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263963"];
13361 [label="isGlobalNamespace 263964"];
13362 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263965"];
13363 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263966"];
13364 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263967"];
13365 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263968"];
13366 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263969"];
13367 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 263970"];
13368 [label="LazyInitializeNamespaces(nestedNamespaces); 263971"];
13369 [label="LazyInitializeNamespaces(nestedNamespaces) 263972"];
13370 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 263973"];
13371 [label="param LazyInitializeNamespaces(this) 263974"];
13372 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 263975"];
13373 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 263976"];
13374 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 263977"];
13375 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 263978"];
13376 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 263979"];
13377 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 263980"];
13378 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 263981"];
13379 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 263982"];
13380 [label="param PENestedNamespaceSymbol(string name) 263983"];
13381 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 263984"];
13382 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 263985"];
13383 [label="param PENestedNamespaceSymbol(this) 263986"];
13384 [label="param PENestedNamespaceSymbol(this) 263987"];
13385 [label="_containingNamespaceSymbol 263988"];
13386 [label="_name 263989"];
13387 [label="_typesByNS 263990"];
13388 [label="Debug.Assert(name != null); 263991"];
13389 [label="Debug.Assert(name != null); 263992"];
13390 [label="Debug.Assert((object)containingNamespace != null); 263993"];
13391 [label="Debug.Assert((object)containingNamespace != null); 263994"];
13392 [label="Debug.Assert(typesByNS != null); 263995"];
13393 [label="Debug.Assert(typesByNS != null); 263996"];
13394 [label="_containingNamespaceSymbol 263997"];
13395 [label="_name 263998"];
13396 [label="_typesByNS 263999"];
13397 [label="c.Name 264000"];
13398 [label="get\n            {\n                return _name;\n            } 264001"];
13399 [label="return _name; 264002"];
13400 [label="namespaces.Add(c.Name, c); 264003"];
13401 [label="namespaces.Add(c.Name, c); 264004"];
13402 [label="namespaces.Add(c.Name, c); 264005"];
13403 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 264006"];
13404 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 264007"];
13405 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 264008"];
13406 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 264009"];
13407 [label="LazyInitializeNamespaces(nestedNamespaces); 264010"];
13408 [label="LazyInitializeTypes(nestedTypes); 264011"];
13409 [label="LazyInitializeTypes(nestedTypes) 264012"];
13410 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 264013"];
13411 [label="param LazyInitializeTypes(this) 264014"];
13412 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 264015"];
13413 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 264016"];
13414 [label="ContainingPEModule 264017"];
13415 [label="get\n            {\n                return _moduleSymbol;\n            } 264018"];
13416 [label="return _moduleSymbol; 264019"];
13417 [label="var moduleSymbol = ContainingPEModule; 264020"];
13418 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 264021"];
13419 [label="moduleSymbol.Module 264022"];
13420 [label="get\n            {\n                return _module;\n            } 264023"];
13421 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 264024"];
13422 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 264025"];
13423 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 264026"];
13424 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 264027"];
13425 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 264028"];
13426 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 264029"];
13427 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264030"];
13428 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264031"];
13429 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264032"];
13430 [label="EmptyComparer.Instance 264033"];
13431 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 264034"];
13432 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 264035"];
13433 [label="new UncommonProperties() 264036"];
13434 [label="param UncommonProperties(this) 264037"];
13435 [label="lazyEnumUnderlyingType 264038"];
13436 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 264039"];
13437 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 264040"];
13438 [label="lazyContainsExtensionMethods 264041"];
13439 [label="lazyIsByRefLike 264042"];
13440 [label="lazyIsReadOnly 264043"];
13441 [label="lazyDefaultMemberName 264044"];
13442 [label="new UnsupportedMetadataTypeSymbol() 264045"];
13443 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 264046"];
13444 [label="param UnsupportedMetadataTypeSymbol(this) 264047"];
13445 [label="param ErrorTypeSymbol(this) 264048"];
13446 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 264049"];
13447 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 264050"];
13448 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 264051"];
13449 [label="type => !type.HasType 264052"];
13450 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 264053"];
13451 [label="type => type.HasType && type.Type.IsErrorType() 264054"];
13452 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 264055"];
13453 [label="8 264056"];
13454 [label="ValueTupleRestPosition = 8 264057"];
13455 [label="1 264058"];
13456 [label="ValueTupleRestPosition - 1 264059"];
13457 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 264060"];
13458 [label="'ValueTuple' 264061"];
13459 [label="ValueTupleTypeName = 'ValueTuple' 264062"];
13460 [label="'Rest' 264063"];
13461 [label="ValueTupleRestFieldName = 'Rest' 264064"];
13462 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 264065"];
13463 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 264066"];
13464 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 264067"];
13465 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 264068"];
13466 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264069"];
13467 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 264070"];
13468 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 264071"];
13469 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 264072"];
13470 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 264073"];
13471 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 264074"];
13472 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 264075"];
13473 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 264076"];
13474 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 264077"];
13475 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264078"];
13476 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264079"];
13477 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264080"];
13478 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264081"];
13479 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264082"];
13480 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264083"];
13481 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264084"];
13482 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264085"];
13483 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 264086"];
13484 [label="tupleData 264087"];
13485 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 264088"];
13486 [label="param NamedTypeSymbol(this) 264089"];
13487 [label="'<invalid-global-code>' 264090"];
13488 [label="ImplicitTypeName = '<invalid-global-code>' 264091"];
13489 [label="0 264092"];
13490 [label="TypeCompareKind.ConsiderEverything 264093"];
13491 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 264094"];
13492 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264095"];
13493 [label="param SymbolEqualityComparer(this) 264096"];
13494 [label="_comparison 264097"];
13495 [label="_comparison 264098"];
13496 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 264099"];
13497 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 264100"];
13498 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264101"];
13499 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264102"];
13500 [label="param SymbolEqualityComparer(this) 264103"];
13501 [label="_comparison 264104"];
13502 [label="_comparison 264105"];
13503 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264106"];
13504 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 264107"];
13505 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264108"];
13506 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264109"];
13507 [label="param SymbolEqualityComparer(this) 264110"];
13508 [label="_comparison 264111"];
13509 [label="_comparison 264112"];
13510 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264113"];
13511 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 264114"];
13512 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264115"];
13513 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264116"];
13514 [label="param SymbolEqualityComparer(this) 264117"];
13515 [label="_comparison 264118"];
13516 [label="_comparison 264119"];
13517 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264120"];
13518 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 264121"];
13519 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 264122"];
13520 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264123"];
13521 [label="param SymbolEqualityComparer(this) 264124"];
13522 [label="_comparison 264125"];
13523 [label="_comparison 264126"];
13524 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 264127"];
13525 [label="TypeCompareKind.AllIgnoreOptions 264128"];
13526 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 264129"];
13527 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264130"];
13528 [label="param SymbolEqualityComparer(this) 264131"];
13529 [label="_comparison 264132"];
13530 [label="_comparison 264133"];
13531 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 264134"];
13532 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 264135"];
13533 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 264136"];
13534 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264137"];
13535 [label="param SymbolEqualityComparer(this) 264138"];
13536 [label="_comparison 264139"];
13537 [label="_comparison 264140"];
13538 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 264141"];
13539 [label="TypeCompareKind.CLRSignatureCompareOptions 264142"];
13540 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 264143"];
13541 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 264144"];
13542 [label="param SymbolEqualityComparer(this) 264145"];
13543 [label="_comparison 264146"];
13544 [label="_comparison 264147"];
13545 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 264148"];
13546 [label="SymbolEqualityComparer.CLRSignature 264149"];
13547 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 264150"];
13548 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 264151"];
13549 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 264152"];
13550 [label="new InterfaceInfo() 264153"];
13551 [label="param InterfaceInfo(this) 264154"];
13552 [label="interfacesAndTheirBaseInterfaces 264155"];
13553 [label="_implementationForInterfaceMemberMap 264156"];
13554 [label="explicitInterfaceImplementationMap 264157"];
13555 [label="s_noInterfaces = new InterfaceInfo() 264158"];
13556 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 264159"];
13557 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 264160"];
13558 [label="param TypeSymbol(this) 264161"];
13559 [label="param NamespaceOrTypeSymbol(this) 264162"];
13560 [label="param Symbol(this) 264163"];
13561 [label="_lazyISymbol 264164"];
13562 [label="_lazyAbstractMembers 264165"];
13563 [label="_lazyInterfaceInfo 264166"];
13564 [label="_lazyAdapter 264167"];
13565 [label="_hasNoBaseCycles 264168"];
13566 [label="_lazyTupleData 264169"];
13567 [label="_lazyTupleData 264170"];
13568 [label="_mrEx 264171"];
13569 [label="_mrEx 264172"];
13570 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 264173"];
13571 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 264174"];
13572 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 264175"];
13573 [label="s_noUncommonProperties = new UncommonProperties() 264176"];
13574 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264177"];
13575 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 264178"];
13576 [label="param Create(PEModuleSymbol moduleSymbol) 264179"];
13577 [label="param Create(PENamespaceSymbol containingNamespace) 264180"];
13578 [label="param Create(TypeDefinitionHandle handle) 264181"];
13579 [label="param Create(string emittedNamespaceName) 264182"];
13580 [label="GenericParameterHandleCollection genericParameterHandles; 264183"];
13581 [label="genericParameterHandles 264184"];
13582 [label="ushort arity; 264185"];
13583 [label="BadImageFormatException mrEx = null; 264186"];
13584 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264187"];
13585 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264188"];
13586 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264189"];
13587 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264190"];
13588 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264191"];
13589 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 264192"];
13590 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 264193"];
13591 [label="param GetGenericInfo(TypeDefinitionHandle handle) 264194"];
13592 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 264195"];
13593 [label="param GetGenericInfo(out ushort arity) 264196"];
13594 [label="param GetGenericInfo(out BadImageFormatException mrEx) 264197"];
13595 [label="moduleSymbol.Module 264198"];
13596 [label="get\n            {\n                return _module;\n            } 264199"];
13597 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 264200"];
13598 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 264201"];
13599 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 264202"];
13600 [label="arity = (ushort)genericParameterHandles.Count; 264203"];
13601 [label="mrEx = null; 264204"];
13602 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 264205"];
13603 [label="bool mangleName; 264206"];
13604 [label="PENamedTypeSymbol result; 264207"];
13605 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 264208"];
13606 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 264209"];
13607 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264210"];
13608 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264211"];
13609 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264212"];
13610 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264213"];
13611 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264214"];
13612 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 264215"];
13613 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 264216"];
13614 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 264217"];
13615 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 264218"];
13616 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 264219"];
13617 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 264220"];
13618 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 264221"];
13619 [label="param PENamedTypeSymbolNonGeneric(this) 264222"];
13620 [label="moduleSymbol 264223"];
13621 [label="container 264224"];
13622 [label="handle 264225"];
13623 [label="emittedNamespaceName 264226"];
13624 [label="0 264227"];
13625 [label="mangleName 264228"];
13626 [label="param PENamedTypeSymbolNonGeneric(this) 264229"];
13627 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 264230"];
13628 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 264231"];
13629 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 264232"];
13630 [label="param PENamedTypeSymbol(string emittedNamespaceName) 264233"];
13631 [label="param PENamedTypeSymbol(ushort arity) 264234"];
13632 [label="param PENamedTypeSymbol(out bool mangleName) 264235"];
13633 [label="param PENamedTypeSymbol(this) 264236"];
13634 [label="param PENamedTypeSymbol(this) 264237"];
13635 [label="param NamedTypeSymbol(this) 264238"];
13636 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 264239"];
13637 [label="param NamedTypeSymbol(this) 264240"];
13638 [label="param TypeSymbol(this) 264241"];
13639 [label="param TypeSymbol(this) 264242"];
13640 [label="_lazyAbstractMembers 264243"];
13641 [label="_lazyInterfaceInfo 264244"];
13642 [label="_lazyAdapter 264245"];
13643 [label="_hasNoBaseCycles 264246"];
13644 [label="_lazyTupleData 264247"];
13645 [label="_lazyTupleData 264248"];
13646 [label="_container 264249"];
13647 [label="_name 264250"];
13648 [label="_flags 264251"];
13649 [label="_corTypeId 264252"];
13650 [label="_lazyMemberNames 264253"];
13651 [label="_lazyMembersByName 264254"];
13652 [label="_lazyNestedTypes 264255"];
13653 [label="_lazyKind 264256"];
13654 [label="_lazyNullableContextValue 264257"];
13655 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 264258"];
13656 [label="default(ImmutableArray<NamedTypeSymbol>) 264259"];
13657 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 264260"];
13658 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 264261"];
13659 [label="default(ImmutableArray<NamedTypeSymbol>) 264262"];
13660 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 264263"];
13661 [label="_lazyDocComment 264264"];
13662 [label="0 264265"];
13663 [label="new CSDiagnosticInfo(0) 264266"];
13664 [label="param CSDiagnosticInfo(ErrorCode code) 264267"];
13665 [label="param CSDiagnosticInfo(this) 264268"];
13666 [label="code 264269"];
13667 [label="Array.Empty<object>() 264270"];
13668 [label="ImmutableArray<Symbol>.Empty 264271"];
13669 [label="ImmutableArray<Location>.Empty 264272"];
13670 [label="param CSDiagnosticInfo(ErrorCode code) 264273"];
13671 [label="param CSDiagnosticInfo(object[] args) 264274"];
13672 [label="param CSDiagnosticInfo(ImmutableArray<Symbol> symbols) 264275"];
13673 [label="param CSDiagnosticInfo(ImmutableArray<Location> additionalLocations) 264276"];
13674 [label="param CSDiagnosticInfo(this) 264277"];
13675 [label="code 264278"];
13676 [label="args 264279"];
13677 [label="symbols 264280"];
13678 [label="param DiagnosticInfoWithSymbols(ErrorCode errorCode) 264281"];
13679 [label="param DiagnosticInfoWithSymbols(object[] arguments) 264282"];
13680 [label="param DiagnosticInfoWithSymbols(ImmutableArray<Symbol> symbols) 264283"];
13681 [label="param DiagnosticInfoWithSymbols(this) 264284"];
13682 [label="CSharp.MessageProvider.Instance 264285"];
13683 [label="errorCode 264286"];
13684 [label="arguments 264287"];
13685 [label="param DiagnosticInfoWithSymbols(this) 264288"];
13686 [label="param GetSeverity(int code) 264289"];
13687 [label="param GetSeverity(this) 264290"];
13688 [label="'_Title' 264291"];
13689 [label="s_titleSuffix = '_Title' 264292"];
13690 [label="'_Description' 264293"];
13691 [label="s_descriptionSuffix = '_Description' 264294"];
13692 [label="CreateCategoriesMap 264295"];
13693 [label="new Lazy<ImmutableDictionary<ErrorCode, string>>(CreateCategoriesMap) 264296"];
13694 [label="s_categoriesMap = new Lazy<ImmutableDictionary<ErrorCode, string>>(CreateCategoriesMap) 264297"];
13695 [label="NullableWarnings 264298"];
13696 [label="s_resourceManager 264299"];
13697 [label="ImmutableHashSet<string>.Builder nullableWarnings = ImmutableHashSet.CreateBuilder<string>(); 264300"];
13698 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceAssignment)); 264301"];
13699 [label="GetId(ErrorCode.WRN_NullReferenceAssignment) 264302"];
13700 [label="param GetId(ErrorCode errorCode) 264303"];
13701 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264304"];
13702 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264305"];
13703 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264306"];
13704 [label="get\n            {\n                return 'CS';\n            } 264307"];
13705 [label="return 'CS'; 264308"];
13706 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264309"];
13707 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceAssignment)); 264310"];
13708 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceReceiver)); 264311"];
13709 [label="GetId(ErrorCode.WRN_NullReferenceReceiver) 264312"];
13710 [label="param GetId(ErrorCode errorCode) 264313"];
13711 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264314"];
13712 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264315"];
13713 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264316"];
13714 [label="get\n            {\n                return 'CS';\n            } 264317"];
13715 [label="return 'CS'; 264318"];
13716 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceReceiver)); 264319"];
13717 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceReturn)); 264320"];
13718 [label="GetId(ErrorCode.WRN_NullReferenceReturn) 264321"];
13719 [label="param GetId(ErrorCode errorCode) 264322"];
13720 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264323"];
13721 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264324"];
13722 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264325"];
13723 [label="get\n            {\n                return 'CS';\n            } 264326"];
13724 [label="return 'CS'; 264327"];
13725 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceReturn)); 264328"];
13726 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceArgument)); 264329"];
13727 [label="GetId(ErrorCode.WRN_NullReferenceArgument) 264330"];
13728 [label="param GetId(ErrorCode errorCode) 264331"];
13729 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264332"];
13730 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264333"];
13731 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264334"];
13732 [label="get\n            {\n                return 'CS';\n            } 264335"];
13733 [label="return 'CS'; 264336"];
13734 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceArgument)); 264337"];
13735 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_UninitializedNonNullableField)); 264338"];
13736 [label="GetId(ErrorCode.WRN_UninitializedNonNullableField) 264339"];
13737 [label="param GetId(ErrorCode errorCode) 264340"];
13738 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264341"];
13739 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264342"];
13740 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264343"];
13741 [label="get\n            {\n                return 'CS';\n            } 264344"];
13742 [label="return 'CS'; 264345"];
13743 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_UninitializedNonNullableField)); 264346"];
13744 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInAssignment)); 264347"];
13745 [label="GetId(ErrorCode.WRN_NullabilityMismatchInAssignment) 264348"];
13746 [label="param GetId(ErrorCode errorCode) 264349"];
13747 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264350"];
13748 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264351"];
13749 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264352"];
13750 [label="get\n            {\n                return 'CS';\n            } 264353"];
13751 [label="return 'CS'; 264354"];
13752 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInAssignment)); 264355"];
13753 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInArgument)); 264356"];
13754 [label="GetId(ErrorCode.WRN_NullabilityMismatchInArgument) 264357"];
13755 [label="param GetId(ErrorCode errorCode) 264358"];
13756 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264359"];
13757 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264360"];
13758 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264361"];
13759 [label="get\n            {\n                return 'CS';\n            } 264362"];
13760 [label="return 'CS'; 264363"];
13761 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInArgument)); 264364"];
13762 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInArgumentForOutput)); 264365"];
13763 [label="GetId(ErrorCode.WRN_NullabilityMismatchInArgumentForOutput) 264366"];
13764 [label="param GetId(ErrorCode errorCode) 264367"];
13765 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264368"];
13766 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264369"];
13767 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264370"];
13768 [label="get\n            {\n                return 'CS';\n            } 264371"];
13769 [label="return 'CS'; 264372"];
13770 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInArgumentForOutput)); 264373"];
13771 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate)); 264374"];
13772 [label="GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate) 264375"];
13773 [label="param GetId(ErrorCode errorCode) 264376"];
13774 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264377"];
13775 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264378"];
13776 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264379"];
13777 [label="get\n            {\n                return 'CS';\n            } 264380"];
13778 [label="return 'CS'; 264381"];
13779 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate)); 264382"];
13780 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate)); 264383"];
13781 [label="GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate) 264384"];
13782 [label="param GetId(ErrorCode errorCode) 264385"];
13783 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264386"];
13784 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264387"];
13785 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264388"];
13786 [label="get\n            {\n                return 'CS';\n            } 264389"];
13787 [label="return 'CS'; 264390"];
13788 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate)); 264391"];
13789 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullAsNonNullable)); 264392"];
13790 [label="GetId(ErrorCode.WRN_NullAsNonNullable) 264393"];
13791 [label="param GetId(ErrorCode errorCode) 264394"];
13792 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264395"];
13793 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264396"];
13794 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264397"];
13795 [label="get\n            {\n                return 'CS';\n            } 264398"];
13796 [label="return 'CS'; 264399"];
13797 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullAsNonNullable)); 264400"];
13798 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullableValueTypeMayBeNull)); 264401"];
13799 [label="GetId(ErrorCode.WRN_NullableValueTypeMayBeNull) 264402"];
13800 [label="param GetId(ErrorCode errorCode) 264403"];
13801 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264404"];
13802 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264405"];
13803 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264406"];
13804 [label="get\n            {\n                return 'CS';\n            } 264407"];
13805 [label="return 'CS'; 264408"];
13806 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullableValueTypeMayBeNull)); 264409"];
13807 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint)); 264410"];
13808 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint) 264411"];
13809 [label="param GetId(ErrorCode errorCode) 264412"];
13810 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264413"];
13811 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264414"];
13812 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264415"];
13813 [label="get\n            {\n                return 'CS';\n            } 264416"];
13814 [label="return 'CS'; 264417"];
13815 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint)); 264418"];
13816 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint)); 264419"];
13817 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint) 264420"];
13818 [label="param GetId(ErrorCode errorCode) 264421"];
13819 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264422"];
13820 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264423"];
13821 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264424"];
13822 [label="get\n            {\n                return 'CS';\n            } 264425"];
13823 [label="return 'CS'; 264426"];
13824 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint)); 264427"];
13825 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterNotNullConstraint)); 264428"];
13826 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterNotNullConstraint) 264429"];
13827 [label="param GetId(ErrorCode errorCode) 264430"];
13828 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264431"];
13829 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264432"];
13830 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264433"];
13831 [label="get\n            {\n                return 'CS';\n            } 264434"];
13832 [label="return 'CS'; 264435"];
13833 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeParameterNotNullConstraint)); 264436"];
13834 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ThrowPossibleNull)); 264437"];
13835 [label="GetId(ErrorCode.WRN_ThrowPossibleNull) 264438"];
13836 [label="param GetId(ErrorCode errorCode) 264439"];
13837 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264440"];
13838 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264441"];
13839 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264442"];
13840 [label="get\n            {\n                return 'CS';\n            } 264443"];
13841 [label="return 'CS'; 264444"];
13842 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ThrowPossibleNull)); 264445"];
13843 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_UnboxPossibleNull)); 264446"];
13844 [label="GetId(ErrorCode.WRN_UnboxPossibleNull) 264447"];
13845 [label="param GetId(ErrorCode errorCode) 264448"];
13846 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264449"];
13847 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264450"];
13848 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264451"];
13849 [label="get\n            {\n                return 'CS';\n            } 264452"];
13850 [label="return 'CS'; 264453"];
13851 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_UnboxPossibleNull)); 264454"];
13852 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNull)); 264455"];
13853 [label="GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNull) 264456"];
13854 [label="param GetId(ErrorCode errorCode) 264457"];
13855 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264458"];
13856 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264459"];
13857 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264460"];
13858 [label="get\n            {\n                return 'CS';\n            } 264461"];
13859 [label="return 'CS'; 264462"];
13860 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNull)); 264463"];
13861 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNullWithWhen)); 264464"];
13862 [label="GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNullWithWhen) 264465"];
13863 [label="param GetId(ErrorCode errorCode) 264466"];
13864 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264467"];
13865 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264468"];
13866 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264469"];
13867 [label="get\n            {\n                return 'CS';\n            } 264470"];
13868 [label="return 'CS'; 264471"];
13869 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_SwitchExpressionNotExhaustiveForNullWithWhen)); 264472"];
13870 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ConvertingNullableToNonNullable)); 264473"];
13871 [label="GetId(ErrorCode.WRN_ConvertingNullableToNonNullable) 264474"];
13872 [label="param GetId(ErrorCode errorCode) 264475"];
13873 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264476"];
13874 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264477"];
13875 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264478"];
13876 [label="get\n            {\n                return 'CS';\n            } 264479"];
13877 [label="return 'CS'; 264480"];
13878 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ConvertingNullableToNonNullable)); 264481"];
13879 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DisallowNullAttributeForbidsMaybeNullAssignment)); 264482"];
13880 [label="GetId(ErrorCode.WRN_DisallowNullAttributeForbidsMaybeNullAssignment) 264483"];
13881 [label="param GetId(ErrorCode errorCode) 264484"];
13882 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264485"];
13883 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264486"];
13884 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264487"];
13885 [label="get\n            {\n                return 'CS';\n            } 264488"];
13886 [label="return 'CS'; 264489"];
13887 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DisallowNullAttributeForbidsMaybeNullAssignment)); 264490"];
13888 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterConditionallyDisallowsNull)); 264491"];
13889 [label="GetId(ErrorCode.WRN_ParameterConditionallyDisallowsNull) 264492"];
13890 [label="param GetId(ErrorCode errorCode) 264493"];
13891 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264494"];
13892 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264495"];
13893 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264496"];
13894 [label="get\n            {\n                return 'CS';\n            } 264497"];
13895 [label="return 'CS'; 264498"];
13896 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterConditionallyDisallowsNull)); 264499"];
13897 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ShouldNotReturn)); 264500"];
13898 [label="GetId(ErrorCode.WRN_ShouldNotReturn) 264501"];
13899 [label="param GetId(ErrorCode errorCode) 264502"];
13900 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264503"];
13901 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264504"];
13902 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264505"];
13903 [label="get\n            {\n                return 'CS';\n            } 264506"];
13904 [label="return 'CS'; 264507"];
13905 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ShouldNotReturn)); 264508"];
13906 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride)); 264509"];
13907 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride) 264510"];
13908 [label="param GetId(ErrorCode errorCode) 264511"];
13909 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264512"];
13910 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264513"];
13911 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264514"];
13912 [label="get\n            {\n                return 'CS';\n            } 264515"];
13913 [label="return 'CS'; 264516"];
13914 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride)); 264517"];
13915 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride)); 264518"];
13916 [label="GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride) 264519"];
13917 [label="param GetId(ErrorCode errorCode) 264520"];
13918 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264521"];
13919 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264522"];
13920 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264523"];
13921 [label="get\n            {\n                return 'CS';\n            } 264524"];
13922 [label="return 'CS'; 264525"];
13923 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride)); 264526"];
13924 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnPartial)); 264527"];
13925 [label="GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnPartial) 264528"];
13926 [label="param GetId(ErrorCode errorCode) 264529"];
13927 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264530"];
13928 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264531"];
13929 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264532"];
13930 [label="get\n            {\n                return 'CS';\n            } 264533"];
13931 [label="return 'CS'; 264534"];
13932 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnPartial)); 264535"];
13933 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride)); 264536"];
13934 [label="GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride) 264537"];
13935 [label="param GetId(ErrorCode errorCode) 264538"];
13936 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264539"];
13937 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264540"];
13938 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264541"];
13939 [label="get\n            {\n                return 'CS';\n            } 264542"];
13940 [label="return 'CS'; 264543"];
13941 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride)); 264544"];
13942 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial)); 264545"];
13943 [label="GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial) 264546"];
13944 [label="param GetId(ErrorCode errorCode) 264547"];
13945 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264548"];
13946 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264549"];
13947 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264550"];
13948 [label="get\n            {\n                return 'CS';\n            } 264551"];
13949 [label="return 'CS'; 264552"];
13950 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial)); 264553"];
13951 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation)); 264554"];
13952 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation) 264555"];
13953 [label="param GetId(ErrorCode errorCode) 264556"];
13954 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264557"];
13955 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264558"];
13956 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264559"];
13957 [label="get\n            {\n                return 'CS';\n            } 264560"];
13958 [label="return 'CS'; 264561"];
13959 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation)); 264562"];
13960 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation)); 264563"];
13961 [label="GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation) 264564"];
13962 [label="param GetId(ErrorCode errorCode) 264565"];
13963 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264566"];
13964 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264567"];
13965 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264568"];
13966 [label="get\n            {\n                return 'CS';\n            } 264569"];
13967 [label="return 'CS'; 264570"];
13968 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation)); 264571"];
13969 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation)); 264572"];
13970 [label="GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation) 264573"];
13971 [label="param GetId(ErrorCode errorCode) 264574"];
13972 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264575"];
13973 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264576"];
13974 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264577"];
13975 [label="get\n            {\n                return 'CS';\n            } 264578"];
13976 [label="return 'CS'; 264579"];
13977 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation)); 264580"];
13978 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation)); 264581"];
13979 [label="GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation) 264582"];
13980 [label="param GetId(ErrorCode errorCode) 264583"];
13981 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264584"];
13982 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264585"];
13983 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264586"];
13984 [label="get\n            {\n                return 'CS';\n            } 264587"];
13985 [label="return 'CS'; 264588"];
13986 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation)); 264589"];
13987 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation)); 264590"];
13988 [label="GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation) 264591"];
13989 [label="param GetId(ErrorCode errorCode) 264592"];
13990 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264593"];
13991 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264594"];
13992 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264595"];
13993 [label="get\n            {\n                return 'CS';\n            } 264596"];
13994 [label="return 'CS'; 264597"];
13995 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation)); 264598"];
13996 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation)); 264599"];
13997 [label="GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation) 264600"];
13998 [label="param GetId(ErrorCode errorCode) 264601"];
13999 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264602"];
14000 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264603"];
14001 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264604"];
14002 [label="get\n            {\n                return 'CS';\n            } 264605"];
14003 [label="return 'CS'; 264606"];
14004 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation)); 264607"];
14005 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation)); 264608"];
14006 [label="GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation) 264609"];
14007 [label="param GetId(ErrorCode errorCode) 264610"];
14008 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264611"];
14009 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264612"];
14010 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264613"];
14011 [label="get\n            {\n                return 'CS';\n            } 264614"];
14012 [label="return 'CS'; 264615"];
14013 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation)); 264616"];
14014 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface)); 264617"];
14015 [label="GetId(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface) 264618"];
14016 [label="param GetId(ErrorCode errorCode) 264619"];
14017 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264620"];
14018 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264621"];
14019 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264622"];
14020 [label="get\n            {\n                return 'CS';\n            } 264623"];
14021 [label="return 'CS'; 264624"];
14022 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface)); 264625"];
14023 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase)); 264626"];
14024 [label="GetId(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase) 264627"];
14025 [label="param GetId(ErrorCode errorCode) 264628"];
14026 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264629"];
14027 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264630"];
14028 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264631"];
14029 [label="get\n            {\n                return 'CS';\n            } 264632"];
14030 [label="return 'CS'; 264633"];
14031 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase)); 264634"];
14032 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList)); 264635"];
14033 [label="GetId(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList) 264636"];
14034 [label="param GetId(ErrorCode errorCode) 264637"];
14035 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264638"];
14036 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264639"];
14037 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264640"];
14038 [label="get\n            {\n                return 'CS';\n            } 264641"];
14039 [label="return 'CS'; 264642"];
14040 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList)); 264643"];
14041 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnPartialImplementation)); 264644"];
14042 [label="GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnPartialImplementation) 264645"];
14043 [label="param GetId(ErrorCode errorCode) 264646"];
14044 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264647"];
14045 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264648"];
14046 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264649"];
14047 [label="get\n            {\n                return 'CS';\n            } 264650"];
14048 [label="return 'CS'; 264651"];
14049 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullabilityMismatchInConstraintsOnPartialImplementation)); 264652"];
14050 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceInitializer)); 264653"];
14051 [label="GetId(ErrorCode.WRN_NullReferenceInitializer) 264654"];
14052 [label="param GetId(ErrorCode errorCode) 264655"];
14053 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264656"];
14054 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264657"];
14055 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264658"];
14056 [label="get\n            {\n                return 'CS';\n            } 264659"];
14057 [label="return 'CS'; 264660"];
14058 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_NullReferenceInitializer)); 264661"];
14059 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ShouldNotReturn)); 264662"];
14060 [label="GetId(ErrorCode.WRN_ShouldNotReturn) 264663"];
14061 [label="param GetId(ErrorCode errorCode) 264664"];
14062 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264665"];
14063 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264666"];
14064 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264667"];
14065 [label="get\n            {\n                return 'CS';\n            } 264668"];
14066 [label="return 'CS'; 264669"];
14067 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ShouldNotReturn)); 264670"];
14068 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DoesNotReturnMismatch)); 264671"];
14069 [label="GetId(ErrorCode.WRN_DoesNotReturnMismatch) 264672"];
14070 [label="param GetId(ErrorCode errorCode) 264673"];
14071 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264674"];
14072 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264675"];
14073 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264676"];
14074 [label="get\n            {\n                return 'CS';\n            } 264677"];
14075 [label="return 'CS'; 264678"];
14076 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_DoesNotReturnMismatch)); 264679"];
14077 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation)); 264680"];
14078 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation) 264681"];
14079 [label="param GetId(ErrorCode errorCode) 264682"];
14080 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264683"];
14081 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264684"];
14082 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264685"];
14083 [label="get\n            {\n                return 'CS';\n            } 264686"];
14084 [label="return 'CS'; 264687"];
14085 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation)); 264688"];
14086 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation)); 264689"];
14087 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation) 264690"];
14088 [label="param GetId(ErrorCode errorCode) 264691"];
14089 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264692"];
14090 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264693"];
14091 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264694"];
14092 [label="get\n            {\n                return 'CS';\n            } 264695"];
14093 [label="return 'CS'; 264696"];
14094 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation)); 264697"];
14095 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride)); 264698"];
14096 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride) 264699"];
14097 [label="param GetId(ErrorCode errorCode) 264700"];
14098 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264701"];
14099 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264702"];
14100 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264703"];
14101 [label="get\n            {\n                return 'CS';\n            } 264704"];
14102 [label="return 'CS'; 264705"];
14103 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride)); 264706"];
14104 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation)); 264707"];
14105 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation) 264708"];
14106 [label="param GetId(ErrorCode errorCode) 264709"];
14107 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264710"];
14108 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264711"];
14109 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264712"];
14110 [label="get\n            {\n                return 'CS';\n            } 264713"];
14111 [label="return 'CS'; 264714"];
14112 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation)); 264715"];
14113 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation)); 264716"];
14114 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation) 264717"];
14115 [label="param GetId(ErrorCode errorCode) 264718"];
14116 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264719"];
14117 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264720"];
14118 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264721"];
14119 [label="get\n            {\n                return 'CS';\n            } 264722"];
14120 [label="return 'CS'; 264723"];
14121 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation)); 264724"];
14122 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride)); 264725"];
14123 [label="GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride) 264726"];
14124 [label="param GetId(ErrorCode errorCode) 264727"];
14125 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264728"];
14126 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264729"];
14127 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264730"];
14128 [label="get\n            {\n                return 'CS';\n            } 264731"];
14129 [label="return 'CS'; 264732"];
14130 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride)); 264733"];
14131 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNull)); 264734"];
14132 [label="GetId(ErrorCode.WRN_MemberNotNull) 264735"];
14133 [label="param GetId(ErrorCode errorCode) 264736"];
14134 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264737"];
14135 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264738"];
14136 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264739"];
14137 [label="get\n            {\n                return 'CS';\n            } 264740"];
14138 [label="return 'CS'; 264741"];
14139 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNull)); 264742"];
14140 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNullBadMember)); 264743"];
14141 [label="GetId(ErrorCode.WRN_MemberNotNullBadMember) 264744"];
14142 [label="param GetId(ErrorCode errorCode) 264745"];
14143 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264746"];
14144 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264747"];
14145 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264748"];
14146 [label="get\n            {\n                return 'CS';\n            } 264749"];
14147 [label="return 'CS'; 264750"];
14148 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNullBadMember)); 264751"];
14149 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNullWhen)); 264752"];
14150 [label="GetId(ErrorCode.WRN_MemberNotNullWhen) 264753"];
14151 [label="param GetId(ErrorCode errorCode) 264754"];
14152 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264755"];
14153 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264756"];
14154 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264757"];
14155 [label="get\n            {\n                return 'CS';\n            } 264758"];
14156 [label="return 'CS'; 264759"];
14157 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_MemberNotNullWhen)); 264760"];
14158 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterDisallowsNull)); 264761"];
14159 [label="GetId(ErrorCode.WRN_ParameterDisallowsNull) 264762"];
14160 [label="param GetId(ErrorCode errorCode) 264763"];
14161 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264764"];
14162 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264765"];
14163 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264766"];
14164 [label="get\n            {\n                return 'CS';\n            } 264767"];
14165 [label="return 'CS'; 264768"];
14166 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterDisallowsNull)); 264769"];
14167 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterNotNullIfNotNull)); 264770"];
14168 [label="GetId(ErrorCode.WRN_ParameterNotNullIfNotNull) 264771"];
14169 [label="param GetId(ErrorCode errorCode) 264772"];
14170 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264773"];
14171 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264774"];
14172 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264775"];
14173 [label="get\n            {\n                return 'CS';\n            } 264776"];
14174 [label="return 'CS'; 264777"];
14175 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ParameterNotNullIfNotNull)); 264778"];
14176 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ReturnNotNullIfNotNull)); 264779"];
14177 [label="GetId(ErrorCode.WRN_ReturnNotNullIfNotNull) 264780"];
14178 [label="param GetId(ErrorCode errorCode) 264781"];
14179 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264782"];
14180 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264783"];
14181 [label="return MessageProvider.Instance.GetIdForErrorCode((int)errorCode); 264784"];
14182 [label="get\n            {\n                return 'CS';\n            } 264785"];
14183 [label="return 'CS'; 264786"];
14184 [label="nullableWarnings.Add(GetId(ErrorCode.WRN_ReturnNotNullIfNotNull)); 264787"];
14185 [label="NullableWarnings = nullableWarnings.ToImmutable(); 264788"];
14186 [label="return ErrorFacts.GetSeverity((ErrorCode)code); 264789"];
14187 [label="ErrorFacts.GetSeverity((ErrorCode)code) 264790"];
14188 [label="param GetSeverity(ErrorCode code) 264791"];
14189 [label="if (code == ErrorCode.Void)\n            {\n                return InternalDiagnosticSeverity.Void;\n            }\n            else if (code == ErrorCode.Unknown)\n            {\n                return InternalDiagnosticSeverity.Unknown;\n            }\n            else if (IsWarning(code))\n            {\n                return DiagnosticSeverity.Warning;\n            }\n            else if (IsInfo(code))\n            {\n                return DiagnosticSeverity.Info;\n            }\n            else if (IsHidden(code))\n            {\n                return DiagnosticSeverity.Hidden;\n            }\n            else\n            {\n                return DiagnosticSeverity.Error;\n            } 264792"];
14190 [label="if (code == ErrorCode.Unknown)\n            {\n                return InternalDiagnosticSeverity.Unknown;\n            }\n            else if (IsWarning(code))\n            {\n                return DiagnosticSeverity.Warning;\n            }\n            else if (IsInfo(code))\n            {\n                return DiagnosticSeverity.Info;\n            }\n            else if (IsHidden(code))\n            {\n                return DiagnosticSeverity.Hidden;\n            }\n            else\n            {\n                return DiagnosticSeverity.Error;\n            } 264793"];
14191 [label="if (IsWarning(code))\n            {\n                return DiagnosticSeverity.Warning;\n            }\n            else if (IsInfo(code))\n            {\n                return DiagnosticSeverity.Info;\n            }\n            else if (IsHidden(code))\n            {\n                return DiagnosticSeverity.Hidden;\n            }\n            else\n            {\n                return DiagnosticSeverity.Error;\n            } 264794"];
14192 [label="IsWarning(code) 264795"];
14193 [label="param IsWarning(ErrorCode code) 264796"];
14194 [label="switch (code)\n            {\n                case ErrorCode.WRN_InvalidMainSig:\n                case ErrorCode.WRN_UnreferencedEvent:\n                case ErrorCode.WRN_LowercaseEllSuffix:\n                case ErrorCode.WRN_DuplicateUsing:\n                case ErrorCode.WRN_NewRequired:\n                case ErrorCode.WRN_NewNotRequired:\n                case ErrorCode.WRN_NewOrOverrideExpected:\n                case ErrorCode.WRN_UnreachableCode:\n                case ErrorCode.WRN_UnreferencedLabel:\n                case ErrorCode.WRN_UnreferencedVar:\n                case ErrorCode.WRN_UnreferencedField:\n                case ErrorCode.WRN_IsAlwaysTrue:\n                case ErrorCode.WRN_IsAlwaysFalse:\n                case ErrorCode.WRN_ByRefNonAgileField:\n                case ErrorCode.WRN_UnreferencedVarAssg:\n                case ErrorCode.WRN_NegativeArrayIndex:\n                case ErrorCode.WRN_BadRefCompareLeft:\n                case ErrorCode.WRN_BadRefCompareRight:\n                case ErrorCode.WRN_PatternIsAmbiguous:\n                case ErrorCode.WRN_PatternNotPublicOrNotInstance:\n                case ErrorCode.WRN_PatternBadSignature:\n                case ErrorCode.WRN_SequentialOnPartialClass:\n                case ErrorCode.WRN_MainCantBeGeneric:\n                case ErrorCode.WRN_UnreferencedFieldAssg:\n                case ErrorCode.WRN_AmbiguousXMLReference:\n                case ErrorCode.WRN_VolatileByRef:\n                case ErrorCode.WRN_SameFullNameThisNsAgg:\n                case ErrorCode.WRN_SameFullNameThisAggAgg:\n                case ErrorCode.WRN_SameFullNameThisAggNs:\n                case ErrorCode.WRN_GlobalAliasDefn:\n                case ErrorCode.WRN_AlwaysNull:\n                case ErrorCode.WRN_CmpAlwaysFalse:\n                case ErrorCode.WRN_FinalizeMethod:\n                case ErrorCode.WRN_GotoCaseShouldConvert:\n                case ErrorCode.WRN_NubExprIsConstBool:\n                case ErrorCode.WRN_ExplicitImplCollision:\n                case ErrorCode.WRN_DeprecatedSymbol:\n                case ErrorCode.WRN_DeprecatedSymbolStr:\n                case ErrorCode.WRN_ExternMethodNoImplementation:\n                case ErrorCode.WRN_ProtectedInSealed:\n                case ErrorCode.WRN_PossibleMistakenNullStatement:\n                case ErrorCode.WRN_UnassignedInternalField:\n                case ErrorCode.WRN_VacuousIntegralComp:\n                case ErrorCode.WRN_AttributeLocationOnBadDeclaration:\n                case ErrorCode.WRN_InvalidAttributeLocation:\n                case ErrorCode.WRN_EqualsWithoutGetHashCode:\n                case ErrorCode.WRN_EqualityOpWithoutEquals:\n                case ErrorCode.WRN_EqualityOpWithoutGetHashCode:\n                case ErrorCode.WRN_IncorrectBooleanAssg:\n                case ErrorCode.WRN_NonObsoleteOverridingObsolete:\n                case ErrorCode.WRN_BitwiseOrSignExtend:\n                case ErrorCode.WRN_CoClassWithoutComImport:\n                case ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter:\n                case ErrorCode.WRN_AssignmentToLockOrDispose:\n                case ErrorCode.WRN_ObsoleteOverridingNonObsolete:\n                case ErrorCode.WRN_DebugFullNameTooLong:\n                case ErrorCode.WRN_ExternCtorNoImplementation:\n                case ErrorCode.WRN_WarningDirective:\n                case ErrorCode.WRN_UnreachableGeneralCatch:\n                case ErrorCode.WRN_DeprecatedCollectionInitAddStr:\n                case ErrorCode.WRN_DeprecatedCollectionInitAdd:\n                case ErrorCode.WRN_DefaultValueForUnconsumedLocation:\n                case ErrorCode.WRN_IdentifierOrNumericLiteralExpected:\n                case ErrorCode.WRN_EmptySwitch:\n                case ErrorCode.WRN_XMLParseError:\n                case ErrorCode.WRN_DuplicateParamTag:\n                case ErrorCode.WRN_UnmatchedParamTag:\n                case ErrorCode.WRN_MissingParamTag:\n                case ErrorCode.WRN_BadXMLRef:\n                case ErrorCode.WRN_BadXMLRefParamType:\n                case ErrorCode.WRN_BadXMLRefReturnType:\n                case ErrorCode.WRN_BadXMLRefSyntax:\n                case ErrorCode.WRN_UnprocessedXMLComment:\n                case ErrorCode.WRN_FailedInclude:\n                case ErrorCode.WRN_InvalidInclude:\n                case ErrorCode.WRN_MissingXMLComment:\n                case ErrorCode.WRN_XMLParseIncludeError:\n                case ErrorCode.WRN_ALinkWarn:\n                case ErrorCode.WRN_CmdOptionConflictsSource:\n                case ErrorCode.WRN_IllegalPragma:\n                case ErrorCode.WRN_IllegalPPWarning:\n                case ErrorCode.WRN_BadRestoreNumber:\n                case ErrorCode.WRN_NonECMAFeature:\n                case ErrorCode.WRN_ErrorOverride:\n                case ErrorCode.WRN_InvalidSearchPathDir:\n                case ErrorCode.WRN_MultiplePredefTypes:\n                case ErrorCode.WRN_TooManyLinesForDebugger:\n                case ErrorCode.WRN_CallOnNonAgileField:\n                case ErrorCode.WRN_InvalidNumber:\n                case ErrorCode.WRN_IllegalPPChecksum:\n                case ErrorCode.WRN_EndOfPPLineExpected:\n                case ErrorCode.WRN_ConflictingChecksum:\n                case ErrorCode.WRN_InvalidAssemblyName:\n                case ErrorCode.WRN_UnifyReferenceMajMin:\n                case ErrorCode.WRN_UnifyReferenceBldRev:\n                case ErrorCode.WRN_DuplicateTypeParamTag:\n                case ErrorCode.WRN_UnmatchedTypeParamTag:\n                case ErrorCode.WRN_MissingTypeParamTag:\n                case ErrorCode.WRN_AssignmentToSelf:\n                case ErrorCode.WRN_ComparisonToSelf:\n                case ErrorCode.WRN_DotOnDefault:\n                case ErrorCode.WRN_BadXMLRefTypeVar:\n                case ErrorCode.WRN_UnmatchedParamRefTag:\n                case ErrorCode.WRN_UnmatchedTypeParamRefTag:\n                case ErrorCode.WRN_ReferencedAssemblyReferencesLinkedPIA:\n                case ErrorCode.WRN_CantHaveManifestForModule:\n                case ErrorCode.WRN_MultipleRuntimeImplementationMatches:\n                case ErrorCode.WRN_MultipleRuntimeOverrideMatches:\n                case ErrorCode.WRN_DynamicDispatchToConditionalMethod:\n                case ErrorCode.WRN_IsDynamicIsConfusing:\n                case ErrorCode.WRN_AsyncLacksAwaits:\n                case ErrorCode.WRN_FileAlreadyIncluded:\n                case ErrorCode.WRN_NoSources:\n                case ErrorCode.WRN_NoConfigNotOnCommandLine:\n                case ErrorCode.WRN_DefineIdentifierRequired:\n                case ErrorCode.WRN_BadUILang:\n                case ErrorCode.WRN_CLS_NoVarArgs:\n                case ErrorCode.WRN_CLS_BadArgType:\n                case ErrorCode.WRN_CLS_BadReturnType:\n                case ErrorCode.WRN_CLS_BadFieldPropType:\n                case ErrorCode.WRN_CLS_BadIdentifierCase:\n                case ErrorCode.WRN_CLS_OverloadRefOut:\n                case ErrorCode.WRN_CLS_OverloadUnnamed:\n                case ErrorCode.WRN_CLS_BadIdentifier:\n                case ErrorCode.WRN_CLS_BadBase:\n                case ErrorCode.WRN_CLS_BadInterfaceMember:\n                case ErrorCode.WRN_CLS_NoAbstractMembers:\n                case ErrorCode.WRN_CLS_NotOnModules:\n                case ErrorCode.WRN_CLS_ModuleMissingCLS:\n                case ErrorCode.WRN_CLS_AssemblyNotCLS:\n                case ErrorCode.WRN_CLS_BadAttributeType:\n                case ErrorCode.WRN_CLS_ArrayArgumentToAttribute:\n                case ErrorCode.WRN_CLS_NotOnModules2:\n                case ErrorCode.WRN_CLS_IllegalTrueInFalse:\n                case ErrorCode.WRN_CLS_MeaninglessOnPrivateType:\n                case ErrorCode.WRN_CLS_AssemblyNotCLS2:\n                case ErrorCode.WRN_CLS_MeaninglessOnParam:\n                case ErrorCode.WRN_CLS_MeaninglessOnReturn:\n                case ErrorCode.WRN_CLS_BadTypeVar:\n                case ErrorCode.WRN_CLS_VolatileField:\n                case ErrorCode.WRN_CLS_BadInterface:\n                case ErrorCode.WRN_UnobservedAwaitableExpression:\n                case ErrorCode.WRN_CallerLineNumberParamForUnconsumedLocation:\n                case ErrorCode.WRN_CallerFilePathParamForUnconsumedLocation:\n                case ErrorCode.WRN_CallerMemberNameParamForUnconsumedLocation:\n                case ErrorCode.WRN_MainIgnored:\n                case ErrorCode.WRN_StaticInAsOrIs:\n                case ErrorCode.WRN_DelaySignButNoKey:\n                case ErrorCode.WRN_InvalidVersionFormat:\n                case ErrorCode.WRN_CallerFilePathPreferredOverCallerMemberName:\n                case ErrorCode.WRN_CallerLineNumberPreferredOverCallerMemberName:\n                case ErrorCode.WRN_CallerLineNumberPreferredOverCallerFilePath:\n                case ErrorCode.WRN_AssemblyAttributeFromModuleIsOverridden:\n                case ErrorCode.WRN_FilterIsConstantTrue:\n                case ErrorCode.WRN_UnimplementedCommandLineSwitch:\n                case ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName:\n                case ErrorCode.WRN_RefCultureMismatch:\n                case ErrorCode.WRN_ConflictingMachineAssembly:\n                case ErrorCode.WRN_UnqualifiedNestedTypeInCref:\n                case ErrorCode.WRN_NoRuntimeMetadataVersion:\n                case ErrorCode.WRN_PdbLocalNameTooLong:\n                case ErrorCode.WRN_AnalyzerCannotBeCreated:\n                case ErrorCode.WRN_NoAnalyzerInAssembly:\n                case ErrorCode.WRN_UnableToLoadAnalyzer:\n                case ErrorCode.WRN_NubExprIsConstBool2:\n                case ErrorCode.WRN_AlignmentMagnitude:\n                case ErrorCode.WRN_AttributeIgnoredWhenPublicSigning:\n                case ErrorCode.WRN_TupleLiteralNameMismatch:\n                case ErrorCode.WRN_Experimental:\n                case ErrorCode.WRN_UnreferencedLocalFunction:\n                case ErrorCode.WRN_FilterIsConstantFalse:\n                case ErrorCode.WRN_FilterIsConstantFalseRedundantTryCatch:\n                case ErrorCode.WRN_AttributesOnBackingFieldsNotAvailable:\n                case ErrorCode.WRN_TupleBinopLiteralNameMismatch:\n                case ErrorCode.WRN_TypeParameterSameAsOuterMethodTypeParameter:\n                case ErrorCode.WRN_UnconsumedEnumeratorCancellationAttributeUsage:\n                case ErrorCode.WRN_UndecoratedCancellationTokenParameter:\n                case ErrorCode.WRN_SwitchExpressionNotExhaustive:\n                case ErrorCode.WRN_CaseConstantNamedUnderscore:\n                case ErrorCode.WRN_IsTypeNamedUnderscore:\n                case ErrorCode.WRN_GivenExpressionNeverMatchesPattern:\n                case ErrorCode.WRN_GivenExpressionAlwaysMatchesConstant:\n                case ErrorCode.WRN_SwitchExpressionNotExhaustiveWithUnnamedEnumValue:\n                case ErrorCode.WRN_ThrowPossibleNull:\n                case ErrorCode.WRN_ConvertingNullableToNonNullable:\n                case ErrorCode.WRN_NullReferenceAssignment:\n                case ErrorCode.WRN_NullReferenceReceiver:\n                case ErrorCode.WRN_NullReferenceReturn:\n                case ErrorCode.WRN_NullReferenceArgument:\n                case ErrorCode.WRN_UnboxPossibleNull:\n                case ErrorCode.WRN_DisallowNullAttributeForbidsMaybeNullAssignment:\n                case ErrorCode.WRN_NullabilityMismatchInTypeOnOverride:\n                case ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride:\n                case ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride:\n                case ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial:\n                case ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation:\n                case ErrorCode.WRN_UninitializedNonNullableField:\n                case ErrorCode.WRN_NullabilityMismatchInAssignment:\n                case ErrorCode.WRN_NullabilityMismatchInArgument:\n                case ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate:\n                case ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate:\n                case ErrorCode.WRN_NullabilityMismatchInArgumentForOutput:\n                case ErrorCode.WRN_NullAsNonNullable:\n                case ErrorCode.WRN_NullableValueTypeMayBeNull:\n                case ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint:\n                case ErrorCode.WRN_MissingNonNullTypesContextForAnnotation:\n                case ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation:\n                case ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint:\n                case ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface:\n                case ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase:\n                case ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList:\n                case ErrorCode.WRN_SwitchExpressionNotExhaustiveForNull:\n                case ErrorCode.WRN_ImplicitCopyInReadOnlyMember:\n                case ErrorCode.WRN_NullabilityMismatchInConstraintsOnPartialImplementation:\n                case ErrorCode.WRN_MissingNonNullTypesContextForAnnotationInGeneratedCode:\n                case ErrorCode.WRN_NullReferenceInitializer:\n                case ErrorCode.WRN_NullabilityMismatchInTypeParameterNotNullConstraint:\n                case ErrorCode.WRN_ParameterConditionallyDisallowsNull:\n                case ErrorCode.WRN_ShouldNotReturn:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnImplicitImplementation:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnImplicitImplementation:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnExplicitImplementation:\n                case ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnExplicitImplementation:\n                case ErrorCode.WRN_DoesNotReturnMismatch:\n                case ErrorCode.WRN_MemberNotNull:\n                case ErrorCode.WRN_MemberNotNullWhen:\n                case ErrorCode.WRN_MemberNotNullBadMember:\n                case ErrorCode.WRN_ParameterDisallowsNull:\n                case ErrorCode.WRN_ConstOutOfRangeChecked:\n                case ErrorCode.WRN_GeneratorFailedDuringInitialization:\n                case ErrorCode.WRN_GeneratorFailedDuringGeneration:\n                case ErrorCode.WRN_GivenExpressionAlwaysMatchesPattern:\n                case ErrorCode.WRN_IsPatternAlways:\n                case ErrorCode.WRN_NullabilityMismatchInReturnTypeOnPartial:\n                case ErrorCode.WRN_ParameterNotNullIfNotNull:\n                case ErrorCode.WRN_ReturnNotNullIfNotNull:\n                case ErrorCode.WRN_SwitchExpressionNotExhaustiveWithWhen:\n                case ErrorCode.WRN_SwitchExpressionNotExhaustiveForNullWithWhen:\n                case ErrorCode.WRN_PrecedenceInversion:\n                case ErrorCode.WRN_AnalyzerReferencesFramework:\n                case ErrorCode.WRN_RecordEqualsWithoutGetHashCode:\n                case ErrorCode.WRN_RecordNamedDisallowed:\n                case ErrorCode.WRN_UnassignedThisAutoProperty:\n                case ErrorCode.WRN_UnassignedThis:\n                case ErrorCode.WRN_ParamUnassigned:\n                case ErrorCode.WRN_UseDefViolationProperty:\n                case ErrorCode.WRN_UseDefViolationField:\n                case ErrorCode.WRN_UseDefViolationThis:\n                case ErrorCode.WRN_UseDefViolationOut:\n                case ErrorCode.WRN_UseDefViolation:\n                case ErrorCode.WRN_SyncAndAsyncEntryPoints:\n                case ErrorCode.WRN_ParameterIsStaticClass:\n                case ErrorCode.WRN_ReturnTypeIsStaticClass:\n                case ErrorCode.WRN_UnreadRecordParameter:\n                case ErrorCode.WRN_DoNotCompareFunctionPointers:\n                    return true;\n                default:\n                    return false;\n            } 264797"];
14195 [label="return false; 264798"];
14196 [label="if (IsInfo(code))\n            {\n                return DiagnosticSeverity.Info;\n            }\n            else if (IsHidden(code))\n            {\n                return DiagnosticSeverity.Hidden;\n            }\n            else\n            {\n                return DiagnosticSeverity.Error;\n            } 264799"];
14197 [label="IsInfo(code) 264800"];
14198 [label="param IsInfo(ErrorCode code) 264801"];
14199 [label="switch (code)\n            {\n                case ErrorCode.INF_UnableToLoadSomeTypesInAnalyzer:\n                    return true;\n                default:\n                    return false;\n            } 264802"];
14200 [label="return false; 264803"];
14201 [label="if (IsHidden(code))\n            {\n                return DiagnosticSeverity.Hidden;\n            }\n            else\n            {\n                return DiagnosticSeverity.Error;\n            } 264804"];
14202 [label="IsHidden(code) 264805"];
14203 [label="param IsHidden(ErrorCode code) 264806"];
14204 [label="switch (code)\n            {\n                case ErrorCode.HDN_UnusedUsingDirective:\n                case ErrorCode.HDN_UnusedExternAlias:\n                    return true;\n                default:\n                    return false;\n            } 264807"];
14205 [label="return false; 264808"];
14206 [label="return DiagnosticSeverity.Error; 264809"];
14207 [label="param DiagnosticInfoWithSymbols(this) 264810"];
14208 [label="this.Symbols 264811"];
14209 [label="_additionalLocations 264812"];
14210 [label="Debug.Assert(code != ErrorCode.ERR_InternalError); 264813"];
14211 [label="additionalLocations.IsDefaultOrEmpty 264814"];
14212 [label="_additionalLocations = additionalLocations.IsDefaultOrEmpty ? SpecializedCollections.EmptyReadOnlyList<Location>() : additionalLocations; 264815"];
14213 [label="_additionalLocations 264816"];
14214 [label="EmptyErrorInfo = new CSDiagnosticInfo(0) 264817"];
14215 [label="ErrorCode.Void 264818"];
14216 [label="new CSDiagnosticInfo(ErrorCode.Void) 264819"];
14217 [label="param CSDiagnosticInfo(ErrorCode code) 264820"];
14218 [label="param CSDiagnosticInfo(this) 264821"];
14219 [label="code 264822"];
14220 [label="Array.Empty<object>() 264823"];
14221 [label="ImmutableArray<Symbol>.Empty 264824"];
14222 [label="ImmutableArray<Location>.Empty 264825"];
14223 [label="param CSDiagnosticInfo(ErrorCode code) 264826"];
14224 [label="param CSDiagnosticInfo(object[] args) 264827"];
14225 [label="param CSDiagnosticInfo(ImmutableArray<Symbol> symbols) 264828"];
14226 [label="param CSDiagnosticInfo(ImmutableArray<Location> additionalLocations) 264829"];
14227 [label="param CSDiagnosticInfo(this) 264830"];
14228 [label="code 264831"];
14229 [label="args 264832"];
14230 [label="symbols 264833"];
14231 [label="param DiagnosticInfoWithSymbols(ErrorCode errorCode) 264834"];
14232 [label="param DiagnosticInfoWithSymbols(object[] arguments) 264835"];
14233 [label="param DiagnosticInfoWithSymbols(ImmutableArray<Symbol> symbols) 264836"];
14234 [label="param DiagnosticInfoWithSymbols(this) 264837"];
14235 [label="CSharp.MessageProvider.Instance 264838"];
14236 [label="errorCode 264839"];
14237 [label="arguments 264840"];
14238 [label="param DiagnosticInfoWithSymbols(this) 264841"];
14239 [label="param GetSeverity(this) 264842"];
14240 [label="ErrorFacts.GetSeverity((ErrorCode)code) 264843"];
14241 [label="return InternalDiagnosticSeverity.Void; 264844"];
14242 [label="this.Symbols 264845"];
14243 [label="_additionalLocations 264846"];
14244 [label="Debug.Assert(code != ErrorCode.ERR_InternalError); 264847"];
14245 [label="additionalLocations.IsDefaultOrEmpty 264848"];
14246 [label="_additionalLocations = additionalLocations.IsDefaultOrEmpty ? SpecializedCollections.EmptyReadOnlyList<Location>() : additionalLocations; 264849"];
14247 [label="_additionalLocations 264850"];
14248 [label="VoidDiagnosticInfo = new CSDiagnosticInfo(ErrorCode.Void) 264851"];
14249 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 264852"];
14250 [label="_lazyUncommonProperties 264853"];
14251 [label="public IEnumerable<object> fieldDefs { get; set; } 264854"];
14252 [label="Debug.Assert(!handle.IsNil); 264855"];
14253 [label="Debug.Assert((object)container != null); 264856"];
14254 [label="Debug.Assert((object)container != null); 264857"];
14255 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 264858"];
14256 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 264859"];
14257 [label="string metadataName; 264860"];
14258 [label="bool makeBad = false; 264861"];
14259 [label="moduleSymbol.Module 264862"];
14260 [label="get\n            {\n                return _module;\n            } 264863"];
14261 [label="return _module; 264864"];
14262 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 264865"];
14263 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 264866"];
14264 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 264867"];
14265 [label="_handle 264868"];
14266 [label="_container 264869"];
14267 [label="moduleSymbol.Module 264870"];
14268 [label="get\n            {\n                return _module;\n            } 264871"];
14269 [label="return _module; 264872"];
14270 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 264873"];
14271 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 264874"];
14272 [label="_flags 264875"];
14273 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 264876"];
14274 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 264877"];
14275 [label="_name 264878"];
14276 [label="mangleName = false; 264879"];
14277 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264880"];
14278 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264881"];
14279 [label="moduleSymbol.ContainingAssembly 264882"];
14280 [label="get\n            {\n                return _assemblySymbol;\n            } 264883"];
14281 [label="return _assemblySymbol; 264884"];
14282 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264885"];
14283 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 264886"];
14284 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 264887"];
14285 [label="this.CorLibrary 264888"];
14286 [label="get\n            {\n                return _corLibrary;\n            } 264889"];
14287 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 264890"];
14288 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 264891"];
14289 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 264892"];
14290 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264893"];
14291 [label="this.DeclaredAccessibility 264894"];
14292 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 264895"];
14293 [label="Accessibility access = Accessibility.Private; 264896"];
14294 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 264897"];
14295 [label="access = Accessibility.Internal; 264898"];
14296 [label="return access; 264899"];
14297 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264900"];
14298 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264901"];
14299 [label="_corTypeId 264902"];
14300 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 264903"];
14301 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 264904"];
14302 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 264905"];
14303 [label="return result; 264906"];
14304 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264907"];
14305 [label="GenericParameterHandleCollection genericParameterHandles; 264908"];
14306 [label="genericParameterHandles 264909"];
14307 [label="ushort arity; 264910"];
14308 [label="BadImageFormatException mrEx = null; 264911"];
14309 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 264912"];
14310 [label="param GetGenericInfo(out ushort arity) 264913"];
14311 [label="param GetGenericInfo(out BadImageFormatException mrEx) 264914"];
14312 [label="mrEx = null; 264915"];
14313 [label="bool mangleName; 264916"];
14314 [label="PENamedTypeSymbol result; 264917"];
14315 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 264918"];
14316 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 264919"];
14317 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 264920"];
14318 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 264921"];
14319 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 264922"];
14320 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 264923"];
14321 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 264924"];
14322 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 264925"];
14323 [label="param PENamedTypeSymbolGeneric(ushort arity) 264926"];
14324 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 264927"];
14325 [label="param PENamedTypeSymbolGeneric(this) 264928"];
14326 [label="moduleSymbol 264929"];
14327 [label="container 264930"];
14328 [label="handle 264931"];
14329 [label="emittedNamespaceName 264932"];
14330 [label="arity 264933"];
14331 [label="mangleName 264934"];
14332 [label="param PENamedTypeSymbolGeneric(this) 264935"];
14333 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 264936"];
14334 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 264937"];
14335 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 264938"];
14336 [label="param PENamedTypeSymbol(string emittedNamespaceName) 264939"];
14337 [label="param PENamedTypeSymbol(ushort arity) 264940"];
14338 [label="param PENamedTypeSymbol(out bool mangleName) 264941"];
14339 [label="_lazyTupleData 264942"];
14340 [label="_container 264943"];
14341 [label="_name 264944"];
14342 [label="_flags 264945"];
14343 [label="_corTypeId 264946"];
14344 [label="Debug.Assert(!handle.IsNil); 264947"];
14345 [label="Debug.Assert((object)container != null); 264948"];
14346 [label="Debug.Assert((object)container != null); 264949"];
14347 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 264950"];
14348 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 264951"];
14349 [label="string metadataName; 264952"];
14350 [label="bool makeBad = false; 264953"];
14351 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 264954"];
14352 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 264955"];
14353 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 264956"];
14354 [label="_name 264957"];
14355 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 264958"];
14356 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 264959"];
14357 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 264960"];
14358 [label="mangleName = !ReferenceEquals(_name, metadataName); 264961"];
14359 [label="mangleName = !ReferenceEquals(_name, metadataName); 264962"];
14360 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 264963"];
14361 [label="Accessibility access = Accessibility.Private; 264964"];
14362 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 264965"];
14363 [label="_arity 264966"];
14364 [label="_mangleName 264967"];
14365 [label="Debug.Assert(genericParameterHandles.Count > 0); 264968"];
14366 [label="Debug.Assert(genericParameterHandles.Count > 0); 264969"];
14367 [label="_arity 264970"];
14368 [label="_genericParameterHandles 264971"];
14369 [label="_mangleName 264972"];
14370 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 264973"];
14371 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 264974"];
14372 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 264975"];
14373 [label="GenericParameterHandleCollection genericParameterHandles; 264976"];
14374 [label="genericParameterHandles 264977"];
14375 [label="ushort arity; 264978"];
14376 [label="BadImageFormatException mrEx = null; 264979"];
14377 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 264980"];
14378 [label="param GetGenericInfo(out ushort arity) 264981"];
14379 [label="param GetGenericInfo(out BadImageFormatException mrEx) 264982"];
14380 [label="mrEx = null; 264983"];
14381 [label="bool mangleName; 264984"];
14382 [label="PENamedTypeSymbol result; 264985"];
14383 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 264986"];
14384 [label="mangleName 264987"];
14385 [label="param PENamedTypeSymbol(out bool mangleName) 264988"];
14386 [label="_lazyTupleData 264989"];
14387 [label="_container 264990"];
14388 [label="_name 264991"];
14389 [label="_flags 264992"];
14390 [label="_corTypeId 264993"];
14391 [label="Debug.Assert(!handle.IsNil); 264994"];
14392 [label="Debug.Assert((object)container != null); 264995"];
14393 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 264996"];
14394 [label="string metadataName; 264997"];
14395 [label="bool makeBad = false; 264998"];
14396 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 264999"];
14397 [label="Accessibility access = Accessibility.Private; 265000"];
14398 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265001"];
14399 [label="_arity 265002"];
14400 [label="_mangleName 265003"];
14401 [label="Debug.Assert(genericParameterHandles.Count > 0); 265004"];
14402 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265005"];
14403 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265006"];
14404 [label="GenericParameterHandleCollection genericParameterHandles; 265007"];
14405 [label="genericParameterHandles 265008"];
14406 [label="ushort arity; 265009"];
14407 [label="BadImageFormatException mrEx = null; 265010"];
14408 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265011"];
14409 [label="param GetGenericInfo(out ushort arity) 265012"];
14410 [label="param GetGenericInfo(out BadImageFormatException mrEx) 265013"];
14411 [label="mrEx = null; 265014"];
14412 [label="PENamedTypeSymbol result; 265015"];
14413 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265016"];
14414 [label="mangleName 265017"];
14415 [label="param PENamedTypeSymbol(out bool mangleName) 265018"];
14416 [label="Debug.Assert(!handle.IsNil); 265019"];
14417 [label="mangleName = false; 265020"];
14418 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265021"];
14419 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265022"];
14420 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265023"];
14421 [label="mangleName 265024"];
14422 [label="param PENamedTypeSymbol(out bool mangleName) 265025"];
14423 [label="_lazyTupleData 265026"];
14424 [label="_container 265027"];
14425 [label="_name 265028"];
14426 [label="_flags 265029"];
14427 [label="_corTypeId 265030"];
14428 [label="Debug.Assert(!handle.IsNil); 265031"];
14429 [label="Debug.Assert((object)container != null); 265032"];
14430 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 265033"];
14431 [label="string metadataName; 265034"];
14432 [label="bool makeBad = false; 265035"];
14433 [label="mangleName = false; 265036"];
14434 [label="Accessibility access = Accessibility.Private; 265037"];
14435 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265038"];
14436 [label="genericParameterHandles 265039"];
14437 [label="ushort arity; 265040"];
14438 [label="BadImageFormatException mrEx = null; 265041"];
14439 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265042"];
14440 [label="param GetGenericInfo(out ushort arity) 265043"];
14441 [label="param GetGenericInfo(out BadImageFormatException mrEx) 265044"];
14442 [label="mrEx = null; 265045"];
14443 [label="PENamedTypeSymbol result; 265046"];
14444 [label="Debug.Assert(!handle.IsNil); 265047"];
14445 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265048"];
14446 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265049"];
14447 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265050"];
14448 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265051"];
14449 [label="mangleName 265052"];
14450 [label="param PENamedTypeSymbol(out bool mangleName) 265053"];
14451 [label="_lazyTupleData 265054"];
14452 [label="_container 265055"];
14453 [label="_name 265056"];
14454 [label="_flags 265057"];
14455 [label="_corTypeId 265058"];
14456 [label="Debug.Assert(!handle.IsNil); 265059"];
14457 [label="Debug.Assert((object)container != null); 265060"];
14458 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 265061"];
14459 [label="string metadataName; 265062"];
14460 [label="bool makeBad = false; 265063"];
14461 [label="mangleName = false; 265064"];
14462 [label="Accessibility access = Accessibility.Private; 265065"];
14463 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265066"];
14464 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 265067"];
14465 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 265068"];
14466 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 265069"];
14467 [label="get\n            {\n                return _name;\n            } 265070"];
14468 [label="return _name; 265071"];
14469 [label="children.Free(); 265072"];
14470 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265073"];
14471 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265074"];
14472 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 265075"];
14473 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 265076"];
14474 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 265077"];
14475 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 265078"];
14476 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 265079"];
14477 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 265080"];
14478 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 265081"];
14479 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 265082"];
14480 [label="param OnNewTypeDeclarationsLoaded(this) 265083"];
14481 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265084"];
14482 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265085"];
14483 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 265086"];
14484 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 265087"];
14485 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265088"];
14486 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 265089"];
14487 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 265090"];
14488 [label="bool added; 265091"];
14489 [label="type.Handle 265092"];
14490 [label="get\n            {\n                return _handle;\n            } 265093"];
14491 [label="return _handle; 265094"];
14492 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 265095"];
14493 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 265096"];
14494 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 265097"];
14495 [label="Debug.Assert(added); 265098"];
14496 [label="type.SpecialType 265099"];
14497 [label="get\n            {\n                return _corTypeId;\n            } 265100"];
14498 [label="return _corTypeId; 265101"];
14499 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265102"];
14500 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265103"];
14501 [label="bool added; 265104"];
14502 [label="Debug.Assert(added); 265105"];
14503 [label="type.SpecialType 265106"];
14504 [label="get\n            {\n                return _corTypeId;\n            } 265107"];
14505 [label="return _corTypeId; 265108"];
14506 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265109"];
14507 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265110"];
14508 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 265111"];
14509 [label="LazyInitializeTypes(nestedTypes); 265112"];
14510 [label="LoadAllMembers(groups); 265113"];
14511 [label="EnsureAllMembersLoaded(); 265114"];
14512 [label="PENestedNamespaceSymbol ns = null; 265115"];
14513 [label="ImmutableArray<PENamedTypeSymbol> t; 265116"];
14514 [label="t 265117"];
14515 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265118"];
14516 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265119"];
14517 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265120"];
14518 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265121"];
14519 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265122"];
14520 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 265123"];
14521 [label="return ImmutableArray<Symbol>.Empty; 265124"];
14522 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 265125"];
14523 [label="Debug.Assert(typesByNS != null); 265126"];
14524 [label="get\n            {\n                return true;\n            } 265127"];
14525 [label="_containingNamespaceSymbol 265128"];
14526 [label="_name 265129"];
14527 [label="_typesByNS 265130"];
14528 [label="Debug.Assert(name != null); 265131"];
14529 [label="Debug.Assert((object)containingNamespace != null); 265132"];
14530 [label="Debug.Assert(typesByNS != null); 265133"];
14531 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 265134"];
14532 [label="genericParameterHandles 265135"];
14533 [label="BadImageFormatException mrEx = null; 265136"];
14534 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265137"];
14535 [label="param GetGenericInfo(out ushort arity) 265138"];
14536 [label="param GetGenericInfo(out BadImageFormatException mrEx) 265139"];
14537 [label="mrEx = null; 265140"];
14538 [label="PENamedTypeSymbol result; 265141"];
14539 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265142"];
14540 [label="mangleName 265143"];
14541 [label="param PENamedTypeSymbol(out bool mangleName) 265144"];
14542 [label="_lazyTupleData 265145"];
14543 [label="_container 265146"];
14544 [label="_name 265147"];
14545 [label="_flags 265148"];
14546 [label="_corTypeId 265149"];
14547 [label="Debug.Assert(!handle.IsNil); 265150"];
14548 [label="Debug.Assert((object)container != null); 265151"];
14549 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 265152"];
14550 [label="string metadataName; 265153"];
14551 [label="bool makeBad = false; 265154"];
14552 [label="mangleName = false; 265155"];
14553 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265156"];
14554 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265157"];
14555 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265158"];
14556 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265159"];
14557 [label="param GetGenericInfo(out ushort arity) 265160"];
14558 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265161"];
14559 [label="mangleName 265162"];
14560 [label="param PENamedTypeSymbol(out bool mangleName) 265163"];
14561 [label="_lazyTupleData 265164"];
14562 [label="_container 265165"];
14563 [label="_name 265166"];
14564 [label="_flags 265167"];
14565 [label="_corTypeId 265168"];
14566 [label="Debug.Assert(!handle.IsNil); 265169"];
14567 [label="Debug.Assert((object)container != null); 265170"];
14568 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 265171"];
14569 [label="string metadataName; 265172"];
14570 [label="bool makeBad = false; 265173"];
14571 [label="mangleName = false; 265174"];
14572 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265175"];
14573 [label="genericParameterHandles 265176"];
14574 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265177"];
14575 [label="param GetGenericInfo(out ushort arity) 265178"];
14576 [label="param GetGenericInfo(out BadImageFormatException mrEx) 265179"];
14577 [label="mrEx = null; 265180"];
14578 [label="PENamedTypeSymbol result; 265181"];
14579 [label="Debug.Assert(!handle.IsNil); 265182"];
14580 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265183"];
14581 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265184"];
14582 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265185"];
14583 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265186"];
14584 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265187"];
14585 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 265188"];
14586 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265189"];
14587 [label="bool added; 265190"];
14588 [label="Debug.Assert(added); 265191"];
14589 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265192"];
14590 [label="EnsureAllMembersLoaded(); 265193"];
14591 [label="return ImmutableArray<Symbol>.Empty; 265194"];
14592 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 265195"];
14593 [label="Debug.Assert(typesByNS != null); 265196"];
14594 [label="get\n            {\n                return true;\n            } 265197"];
14595 [label="_containingNamespaceSymbol 265198"];
14596 [label="_name 265199"];
14597 [label="_typesByNS 265200"];
14598 [label="Debug.Assert(name != null); 265201"];
14599 [label="Debug.Assert((object)containingNamespace != null); 265202"];
14600 [label="Debug.Assert(typesByNS != null); 265203"];
14601 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 265204"];
14602 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265205"];
14603 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265206"];
14604 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 265207"];
14605 [label="bool added; 265208"];
14606 [label="Debug.Assert(added); 265209"];
14607 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 265210"];
14608 [label="EnsureAllMembersLoaded(); 265211"];
14609 [label="return ImmutableArray<Symbol>.Empty; 265212"];
14610 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 265213"];
14611 [label="Debug.Assert(typesByNS != null); 265214"];
14612 [label="get\n            {\n                return true;\n            } 265215"];
14613 [label="_containingNamespaceSymbol 265216"];
14614 [label="_name 265217"];
14615 [label="_typesByNS 265218"];
14616 [label="Debug.Assert(name != null); 265219"];
14617 [label="Debug.Assert((object)containingNamespace != null); 265220"];
14618 [label="Debug.Assert(typesByNS != null); 265221"];
14619 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 265222"];
14620 [label="genericParameterHandles 265223"];
14621 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 265224"];
14622 [label="param GetGenericInfo(out ushort arity) 265225"];
14623 [label="param GetGenericInfo(out BadImageFormatException mrEx) 265226"];
14624 [label="mrEx = null; 265227"];
14625 [label="PENamedTypeSymbol result; 265228"];
14626 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 265229"];
14627 [label="mangleName 265230"];
14628 [label="param PENamedTypeSymbol(out bool mangleName) 265231"];
14629 [label="_lazyTupleData 265232"];
14630 [label="_container 265233"];
14631 [label="_name 265234"];
14632 [label="_flags 265235"];
14633 [label="_corTypeId 265236"];
14634 [label="Debug.Assert(!handle.IsNil); 265237"];
14635 [label="Debug.Assert((object)container != null); 265238"];
14636 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 265239"];
14637 [label="string metadataName; 265240"];
14638 [label="bool makeBad = false; 265241"];
14639 [label="mangleName = false; 265242"];
14640 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 265243"];
14641 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265244"];
14642 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 265245"];
14643 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265246"];
14644 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 265247"];
14645 [label="EnsureAllMembersLoaded(); 265248"];
14646 [label="return ImmutableArray<Symbol>.Empty; 265249"];
14647 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 265250"];
14648 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 265251"];
14649 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 265252"];
14650 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 265253"];
14651 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 265254"];
14652 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 265255"];
14653 [label="MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()) 265256"];
14654 [label="param Create(NamespaceExtent extent) 265257"];
14655 [label="param Create(NamespaceSymbol containingNamespace) 265258"];
14656 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 265259"];
14657 [label="param Create(string nameOpt = null) 265260"];
14658 [label="Debug.Assert(namespacesToMerge.Length != 0); 265261"];
14659 [label="Debug.Assert(namespacesToMerge.Length != 0); 265262"];
14660 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 265263"];
14661 [label="return otherSymbols.ToImmutableAndFree(); 265264"];
14662 [label="var syma = ns1.GetMembers('A').Single() as NamedTypeSymbol; 265265"];
14663 [label="ns1.GetMembers('A') 265266"];
14664 [label="param GetMembers(string name) 265267"];
14665 [label="param GetMembers(this) 265268"];
14666 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 265269"];
14667 [label="members 265270"];
14668 [label="this.GetNameToMembersMap() 265271"];
14669 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 265272"];
14670 [label="ArrayBuilder<SingleTypeDeclaration> types = null; 265273"];
14671 [label="bool allTypesHaveSameIdentity = true; 265274"];
14672 [label="var asType = child as SingleTypeDeclaration; 265275"];
14673 [label="if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    } 265276"];
14674 [label="if (asType != null)\n                    {\n                        // handle types\n                        if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        }\n\n                        types.Add(asType);\n                        continue;\n                    } 265277"];
14675 [label="if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265278"];
14676 [label="if (types == null)\n                        {\n                            types = ArrayBuilder<SingleTypeDeclaration>.GetInstance();\n                        }\n                        else if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265279"];
14677 [label="types = ArrayBuilder<SingleTypeDeclaration>.GetInstance(); 265280"];
14678 [label="types.Add(asType); 265281"];
14679 [label="types.Add(asType); 265282"];
14680 [label="asType.Identity 265283"];
14681 [label="get\n            {\n                return new TypeDeclarationIdentity(this);\n            } 265284"];
14682 [label="return new TypeDeclarationIdentity(this); 265285"];
14683 [label="return new TypeDeclarationIdentity(this); 265286"];
14684 [label="new TypeDeclarationIdentity(this) 265287"];
14685 [label="param TypeDeclarationIdentity(SingleTypeDeclaration decl) 265288"];
14686 [label="param TypeDeclarationIdentity(this) 265289"];
14687 [label="_decl 265290"];
14688 [label="if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265291"];
14689 [label="if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265292"];
14690 [label="get\n            {\n                return new TypeDeclarationIdentity(this);\n            } 265293"];
14691 [label="return new TypeDeclarationIdentity(this); 265294"];
14692 [label="return new TypeDeclarationIdentity(this); 265295"];
14693 [label="new TypeDeclarationIdentity(this) 265296"];
14694 [label="param TypeDeclarationIdentity(SingleTypeDeclaration decl) 265297"];
14695 [label="param TypeDeclarationIdentity(this) 265298"];
14696 [label="_decl 265299"];
14697 [label="types[0].Identity 265300"];
14698 [label="param Equals(TypeDeclarationIdentity other) 265301"];
14699 [label="param Equals(this) 265302"];
14700 [label="var thisDecl = _decl; 265303"];
14701 [label="var otherDecl = other._decl; 265304"];
14702 [label="if ((object)thisDecl == otherDecl)\n                {\n                    return true;\n                } 265305"];
14703 [label="if ((thisDecl._arity != otherDecl._arity) ||\n                    (thisDecl._kind != otherDecl._kind) ||\n                    (thisDecl.name != otherDecl.name))\n                {\n                    return false;\n                } 265306"];
14704 [label="return false; 265307"];
14705 [label="if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265308"];
14706 [label="if (allTypesHaveSameIdentity && !asType.Identity.Equals(types[0].Identity))\n                        {\n                            allTypesHaveSameIdentity = false;\n                        } 265309"];
14707 [label="allTypesHaveSameIdentity = false; 265310"];
14708 [label="if (types != null)\n            {\n                if (allTypesHaveSameIdentity)\n                {\n                    children.Add(new MergedTypeDeclaration(types.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var typeGroups = types.ToDictionary(t => t.Identity);\n                    types.Free();\n\n                    foreach (var typeGroup in typeGroups.Values)\n                    {\n                        children.Add(new MergedTypeDeclaration(typeGroup));\n                    }\n                }\n            } 265311"];
14709 [label="if (allTypesHaveSameIdentity)\n                {\n                    children.Add(new MergedTypeDeclaration(types.ToImmutableAndFree()));\n                }\n                else\n                {\n                    var typeGroups = types.ToDictionary(t => t.Identity);\n                    types.Free();\n\n                    foreach (var typeGroup in typeGroups.Values)\n                    {\n                        children.Add(new MergedTypeDeclaration(typeGroup));\n                    }\n                } 265312"];
14710 [label="var typeGroups = types.ToDictionary(t => t.Identity); 265313"];
14711 [label="param GetHashCode(this) 265314"];
14712 [label="var thisDecl = _decl; 265315"];
14713 [label="thisDecl.Name 265316"];
14714 [label="get\n            {\n                return this.name;\n            } 265317"];
14715 [label="return Hash.Combine(thisDecl.Name.GetHashCode(),\n                    Hash.Combine(thisDecl.Arity.GetHashCode(),\n                    (int)thisDecl.Kind)); 265318"];
14716 [label="thisDecl.Arity 265319"];
14717 [label="get\n            {\n                return _arity;\n            } 265320"];
14718 [label="return _arity; 265321"];
14719 [label="return Hash.Combine(thisDecl.Name.GetHashCode(),\n                    Hash.Combine(thisDecl.Arity.GetHashCode(),\n                    (int)thisDecl.Kind)); 265322"];
14720 [label="thisDecl.Kind 265323"];
14721 [label="get\n            {\n                return _kind;\n            } 265324"];
14722 [label="return _kind; 265325"];
14723 [label="return Hash.Combine(thisDecl.Name.GetHashCode(),\n                    Hash.Combine(thisDecl.Arity.GetHashCode(),\n                    (int)thisDecl.Kind)); 265326"];
14724 [label="return Hash.Combine(thisDecl.Name.GetHashCode(),\n                    Hash.Combine(thisDecl.Arity.GetHashCode(),\n                    (int)thisDecl.Kind)); 265327"];
14725 [label="return Hash.Combine(thisDecl.Name.GetHashCode(),\n                    Hash.Combine(thisDecl.Arity.GetHashCode(),\n                    (int)thisDecl.Kind)); 265328"];
14726 [label="types.Free(); 265329"];
14727 [label="foreach (var typeGroup in typeGroups.Values)\n                    {\n                        children.Add(new MergedTypeDeclaration(typeGroup));\n                    } 265330"];
14728 [label="children.Add(new MergedTypeDeclaration(typeGroup)); 265331"];
14729 [label="new MergedTypeDeclaration(typeGroup) 265332"];
14730 [label="param MergedTypeDeclaration(ImmutableArray<SingleTypeDeclaration> declarations) 265333"];
14731 [label="param MergedTypeDeclaration(this) 265334"];
14732 [label="0 265335"];
14733 [label="declarations[0] 265336"];
14734 [label="declarations[0].Name 265337"];
14735 [label="get\n            {\n                return this.name;\n            } 265338"];
14736 [label="param MergedTypeDeclaration(this) 265339"];
14737 [label="param MergedNamespaceOrTypeDeclaration(string name) 265340"];
14738 [label="name 265341"];
14739 [label="_lazyMemberNames 265342"];
14740 [label="_declarations 265343"];
14741 [label="children.Add(new MergedTypeDeclaration(typeGroup)); 265344"];
14742 [label="name 265345"];
14743 [label="param BuildSymbol(this) 265346"];
14744 [label="get\n            {\n                return this.Declarations[0].Kind;\n            } 265347"];
14745 [label="this.Declarations 265348"];
14746 [label="get\n            {\n                return _declarations;\n            } 265349"];
14747 [label="return _declarations; 265350"];
14748 [label="return this.Declarations[0].Kind; 265351"];
14749 [label="return this.Declarations[0].Kind; 265352"];
14750 [label="this.Declarations[0].Kind 265353"];
14751 [label="get\n            {\n                return _kind;\n            } 265354"];
14752 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 265355"];
14753 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 265356"];
14754 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 265357"];
14755 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 265358"];
14756 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 265359"];
14757 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 265360"];
14758 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 265361"];
14759 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 265362"];
14760 [label="param SourceNamedTypeSymbol(this) 265363"];
14761 [label="false 265364"];
14762 [label="considerName: false 265365"];
14763 [label="false 265366"];
14764 [label="considerExplicitlyImplementedInterfaces: false 265367"];
14765 [label="true 265368"];
14766 [label="considerReturnType: true 265369"];
14767 [label="false 265370"];
14768 [label="considerTypeConstraints: false 265371"];
14769 [label="true 265372"];
14770 [label="considerRefKindDifferences: true 265373"];
14771 [label="true 265374"];
14772 [label="considerCallingConvention: true 265375"];
14773 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265376"];
14774 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265377"];
14775 [label="param MemberSignatureComparer(bool considerName) 265378"];
14776 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265379"];
14777 [label="param MemberSignatureComparer(bool considerReturnType) 265380"];
14778 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265381"];
14779 [label="param MemberSignatureComparer(bool considerCallingConvention) 265382"];
14780 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265383"];
14781 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265384"];
14782 [label="param MemberSignatureComparer(this) 265385"];
14783 [label="_considerName 265386"];
14784 [label="_considerExplicitlyImplementedInterfaces 265387"];
14785 [label="_considerReturnType 265388"];
14786 [label="_considerTypeConstraints 265389"];
14787 [label="_considerCallingConvention 265390"];
14788 [label="_considerRefKindDifferences 265391"];
14789 [label="_typeComparison 265392"];
14790 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265393"];
14791 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265394"];
14792 [label="_considerName 265395"];
14793 [label="_considerExplicitlyImplementedInterfaces 265396"];
14794 [label="_considerReturnType 265397"];
14795 [label="_considerTypeConstraints 265398"];
14796 [label="_considerCallingConvention 265399"];
14797 [label="_considerRefKindDifferences 265400"];
14798 [label="_typeComparison 265401"];
14799 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265402"];
14800 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265403"];
14801 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265404"];
14802 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265405"];
14803 [label="true 265406"];
14804 [label="considerName: true 265407"];
14805 [label="true 265408"];
14806 [label="considerExplicitlyImplementedInterfaces: true 265409"];
14807 [label="true 265410"];
14808 [label="considerReturnType: true 265411"];
14809 [label="false 265412"];
14810 [label="considerTypeConstraints: false 265413"];
14811 [label="true 265414"];
14812 [label="considerCallingConvention: true 265415"];
14813 [label="true 265416"];
14814 [label="considerRefKindDifferences: true 265417"];
14815 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265418"];
14816 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265419"];
14817 [label="param MemberSignatureComparer(bool considerName) 265420"];
14818 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265421"];
14819 [label="param MemberSignatureComparer(bool considerReturnType) 265422"];
14820 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265423"];
14821 [label="param MemberSignatureComparer(bool considerCallingConvention) 265424"];
14822 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265425"];
14823 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265426"];
14824 [label="param MemberSignatureComparer(this) 265427"];
14825 [label="_considerName 265428"];
14826 [label="_considerExplicitlyImplementedInterfaces 265429"];
14827 [label="_considerReturnType 265430"];
14828 [label="_considerTypeConstraints 265431"];
14829 [label="_considerCallingConvention 265432"];
14830 [label="_considerRefKindDifferences 265433"];
14831 [label="_typeComparison 265434"];
14832 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265435"];
14833 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265436"];
14834 [label="_considerName 265437"];
14835 [label="_considerExplicitlyImplementedInterfaces 265438"];
14836 [label="_considerReturnType 265439"];
14837 [label="_considerTypeConstraints 265440"];
14838 [label="_considerCallingConvention 265441"];
14839 [label="_considerRefKindDifferences 265442"];
14840 [label="_typeComparison 265443"];
14841 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265444"];
14842 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265445"];
14843 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265446"];
14844 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265447"];
14845 [label="true 265448"];
14846 [label="considerName: true 265449"];
14847 [label="true 265450"];
14848 [label="considerExplicitlyImplementedInterfaces: true 265451"];
14849 [label="false 265452"];
14850 [label="considerReturnType: false 265453"];
14851 [label="false 265454"];
14852 [label="considerTypeConstraints: false 265455"];
14853 [label="false 265456"];
14854 [label="considerCallingConvention: false 265457"];
14855 [label="true 265458"];
14856 [label="considerRefKindDifferences: true 265459"];
14857 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265460"];
14858 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265461"];
14859 [label="param MemberSignatureComparer(bool considerName) 265462"];
14860 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265463"];
14861 [label="param MemberSignatureComparer(bool considerReturnType) 265464"];
14862 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265465"];
14863 [label="param MemberSignatureComparer(bool considerCallingConvention) 265466"];
14864 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265467"];
14865 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265468"];
14866 [label="param MemberSignatureComparer(this) 265469"];
14867 [label="_considerName 265470"];
14868 [label="_considerExplicitlyImplementedInterfaces 265471"];
14869 [label="_considerReturnType 265472"];
14870 [label="_considerTypeConstraints 265473"];
14871 [label="_considerCallingConvention 265474"];
14872 [label="_considerRefKindDifferences 265475"];
14873 [label="_typeComparison 265476"];
14874 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265477"];
14875 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265478"];
14876 [label="_considerName 265479"];
14877 [label="_considerExplicitlyImplementedInterfaces 265480"];
14878 [label="_considerReturnType 265481"];
14879 [label="_considerTypeConstraints 265482"];
14880 [label="_considerCallingConvention 265483"];
14881 [label="_considerRefKindDifferences 265484"];
14882 [label="_typeComparison 265485"];
14883 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265486"];
14884 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265487"];
14885 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265488"];
14886 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265489"];
14887 [label="true 265490"];
14888 [label="considerName: true 265491"];
14889 [label="true 265492"];
14890 [label="considerExplicitlyImplementedInterfaces: true 265493"];
14891 [label="false 265494"];
14892 [label="considerReturnType: false 265495"];
14893 [label="false 265496"];
14894 [label="considerTypeConstraints: false 265497"];
14895 [label="false 265498"];
14896 [label="considerCallingConvention: false 265499"];
14897 [label="false 265500"];
14898 [label="considerRefKindDifferences: false 265501"];
14899 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265502"];
14900 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265503"];
14901 [label="param MemberSignatureComparer(bool considerName) 265504"];
14902 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265505"];
14903 [label="param MemberSignatureComparer(bool considerReturnType) 265506"];
14904 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265507"];
14905 [label="param MemberSignatureComparer(bool considerCallingConvention) 265508"];
14906 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265509"];
14907 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265510"];
14908 [label="param MemberSignatureComparer(this) 265511"];
14909 [label="_considerName 265512"];
14910 [label="_considerExplicitlyImplementedInterfaces 265513"];
14911 [label="_considerReturnType 265514"];
14912 [label="_considerTypeConstraints 265515"];
14913 [label="_considerCallingConvention 265516"];
14914 [label="_considerRefKindDifferences 265517"];
14915 [label="_typeComparison 265518"];
14916 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265519"];
14917 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265520"];
14918 [label="_considerName 265521"];
14919 [label="_considerExplicitlyImplementedInterfaces 265522"];
14920 [label="_considerReturnType 265523"];
14921 [label="_considerTypeConstraints 265524"];
14922 [label="_considerCallingConvention 265525"];
14923 [label="_considerRefKindDifferences 265526"];
14924 [label="_typeComparison 265527"];
14925 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265528"];
14926 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265529"];
14927 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265530"];
14928 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 265531"];
14929 [label="_typeComparison 265532"];
14930 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265533"];
14931 [label="true 265534"];
14932 [label="considerName: true 265535"];
14933 [label="true 265536"];
14934 [label="considerExplicitlyImplementedInterfaces: true 265537"];
14935 [label="false 265538"];
14936 [label="considerReturnType: false 265539"];
14937 [label="false 265540"];
14938 [label="considerTypeConstraints: false 265541"];
14939 [label="false 265542"];
14940 [label="considerCallingConvention: false 265543"];
14941 [label="true 265544"];
14942 [label="considerRefKindDifferences: true 265545"];
14943 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265546"];
14944 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265547"];
14945 [label="param MemberSignatureComparer(bool considerName) 265548"];
14946 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265549"];
14947 [label="param MemberSignatureComparer(bool considerReturnType) 265550"];
14948 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265551"];
14949 [label="param MemberSignatureComparer(bool considerCallingConvention) 265552"];
14950 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265553"];
14951 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265554"];
14952 [label="param MemberSignatureComparer(this) 265555"];
14953 [label="_considerName 265556"];
14954 [label="_considerExplicitlyImplementedInterfaces 265557"];
14955 [label="_considerReturnType 265558"];
14956 [label="_considerTypeConstraints 265559"];
14957 [label="_considerCallingConvention 265560"];
14958 [label="_considerRefKindDifferences 265561"];
14959 [label="_typeComparison 265562"];
14960 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265563"];
14961 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265564"];
14962 [label="_considerName 265565"];
14963 [label="_considerExplicitlyImplementedInterfaces 265566"];
14964 [label="_considerReturnType 265567"];
14965 [label="_considerTypeConstraints 265568"];
14966 [label="_considerCallingConvention 265569"];
14967 [label="_considerRefKindDifferences 265570"];
14968 [label="_typeComparison 265571"];
14969 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265572"];
14970 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265573"];
14971 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265574"];
14972 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265575"];
14973 [label="true 265576"];
14974 [label="considerName: true 265577"];
14975 [label="true 265578"];
14976 [label="considerExplicitlyImplementedInterfaces: true 265579"];
14977 [label="false 265580"];
14978 [label="considerReturnType: false 265581"];
14979 [label="false 265582"];
14980 [label="considerTypeConstraints: false 265583"];
14981 [label="false 265584"];
14982 [label="considerCallingConvention: false 265585"];
14983 [label="true 265586"];
14984 [label="considerRefKindDifferences: true 265587"];
14985 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265588"];
14986 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265589"];
14987 [label="param MemberSignatureComparer(bool considerName) 265590"];
14988 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265591"];
14989 [label="param MemberSignatureComparer(bool considerReturnType) 265592"];
14990 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265593"];
14991 [label="param MemberSignatureComparer(bool considerCallingConvention) 265594"];
14992 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265595"];
14993 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265596"];
14994 [label="param MemberSignatureComparer(this) 265597"];
14995 [label="_considerName 265598"];
14996 [label="_considerExplicitlyImplementedInterfaces 265599"];
14997 [label="_considerReturnType 265600"];
14998 [label="_considerTypeConstraints 265601"];
14999 [label="_considerCallingConvention 265602"];
15000 [label="_considerRefKindDifferences 265603"];
15001 [label="_typeComparison 265604"];
15002 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265605"];
15003 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265606"];
15004 [label="_considerName 265607"];
15005 [label="_considerExplicitlyImplementedInterfaces 265608"];
15006 [label="_considerReturnType 265609"];
15007 [label="_considerTypeConstraints 265610"];
15008 [label="_considerCallingConvention 265611"];
15009 [label="_considerRefKindDifferences 265612"];
15010 [label="_typeComparison 265613"];
15011 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265614"];
15012 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265615"];
15013 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265616"];
15014 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265617"];
15015 [label="true 265618"];
15016 [label="considerName: true 265619"];
15017 [label="false 265620"];
15018 [label="considerExplicitlyImplementedInterfaces: false 265621"];
15019 [label="false 265622"];
15020 [label="considerReturnType: false 265623"];
15021 [label="false 265624"];
15022 [label="considerTypeConstraints: false 265625"];
15023 [label="false 265626"];
15024 [label="considerCallingConvention: false 265627"];
15025 [label="true 265628"];
15026 [label="considerRefKindDifferences: true 265629"];
15027 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265630"];
15028 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265631"];
15029 [label="param MemberSignatureComparer(bool considerName) 265632"];
15030 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265633"];
15031 [label="param MemberSignatureComparer(bool considerReturnType) 265634"];
15032 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265635"];
15033 [label="param MemberSignatureComparer(bool considerCallingConvention) 265636"];
15034 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265637"];
15035 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265638"];
15036 [label="param MemberSignatureComparer(this) 265639"];
15037 [label="_considerName 265640"];
15038 [label="_considerExplicitlyImplementedInterfaces 265641"];
15039 [label="_considerReturnType 265642"];
15040 [label="_considerTypeConstraints 265643"];
15041 [label="_considerCallingConvention 265644"];
15042 [label="_considerRefKindDifferences 265645"];
15043 [label="_typeComparison 265646"];
15044 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265647"];
15045 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265648"];
15046 [label="_considerName 265649"];
15047 [label="_considerExplicitlyImplementedInterfaces 265650"];
15048 [label="_considerReturnType 265651"];
15049 [label="_considerTypeConstraints 265652"];
15050 [label="_considerCallingConvention 265653"];
15051 [label="_considerRefKindDifferences 265654"];
15052 [label="_typeComparison 265655"];
15053 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265656"];
15054 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265657"];
15055 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265658"];
15056 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265659"];
15057 [label="true 265660"];
15058 [label="considerName: true 265661"];
15059 [label="false 265662"];
15060 [label="considerExplicitlyImplementedInterfaces: false 265663"];
15061 [label="true 265664"];
15062 [label="considerReturnType: true 265665"];
15063 [label="false 265666"];
15064 [label="considerTypeConstraints: false 265667"];
15065 [label="false 265668"];
15066 [label="considerCallingConvention: false 265669"];
15067 [label="false 265670"];
15068 [label="considerRefKindDifferences: false 265671"];
15069 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 265672"];
15070 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 265673"];
15071 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 265674"];
15072 [label="param MemberSignatureComparer(bool considerName) 265675"];
15073 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265676"];
15074 [label="param MemberSignatureComparer(bool considerReturnType) 265677"];
15075 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265678"];
15076 [label="param MemberSignatureComparer(bool considerCallingConvention) 265679"];
15077 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265680"];
15078 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265681"];
15079 [label="param MemberSignatureComparer(this) 265682"];
15080 [label="_considerName 265683"];
15081 [label="_considerExplicitlyImplementedInterfaces 265684"];
15082 [label="_considerReturnType 265685"];
15083 [label="_considerTypeConstraints 265686"];
15084 [label="_considerCallingConvention 265687"];
15085 [label="_considerRefKindDifferences 265688"];
15086 [label="_typeComparison 265689"];
15087 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265690"];
15088 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265691"];
15089 [label="_considerName 265692"];
15090 [label="_considerExplicitlyImplementedInterfaces 265693"];
15091 [label="_considerReturnType 265694"];
15092 [label="_considerTypeConstraints 265695"];
15093 [label="_considerCallingConvention 265696"];
15094 [label="_considerRefKindDifferences 265697"];
15095 [label="_typeComparison 265698"];
15096 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265699"];
15097 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265700"];
15098 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265701"];
15099 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 265702"];
15100 [label="_typeComparison 265703"];
15101 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 265704"];
15102 [label="true 265705"];
15103 [label="considerName: true 265706"];
15104 [label="false 265707"];
15105 [label="considerExplicitlyImplementedInterfaces: false 265708"];
15106 [label="true 265709"];
15107 [label="considerReturnType: true 265710"];
15108 [label="false 265711"];
15109 [label="considerTypeConstraints: false 265712"];
15110 [label="false 265713"];
15111 [label="considerCallingConvention: false 265714"];
15112 [label="false 265715"];
15113 [label="considerRefKindDifferences: false 265716"];
15114 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265717"];
15115 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265718"];
15116 [label="param MemberSignatureComparer(bool considerName) 265719"];
15117 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265720"];
15118 [label="param MemberSignatureComparer(bool considerReturnType) 265721"];
15119 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265722"];
15120 [label="param MemberSignatureComparer(bool considerCallingConvention) 265723"];
15121 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265724"];
15122 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265725"];
15123 [label="param MemberSignatureComparer(this) 265726"];
15124 [label="_considerName 265727"];
15125 [label="_considerExplicitlyImplementedInterfaces 265728"];
15126 [label="_considerReturnType 265729"];
15127 [label="_considerTypeConstraints 265730"];
15128 [label="_considerCallingConvention 265731"];
15129 [label="_considerRefKindDifferences 265732"];
15130 [label="_typeComparison 265733"];
15131 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265734"];
15132 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265735"];
15133 [label="_considerName 265736"];
15134 [label="_considerExplicitlyImplementedInterfaces 265737"];
15135 [label="_considerReturnType 265738"];
15136 [label="_considerTypeConstraints 265739"];
15137 [label="_considerCallingConvention 265740"];
15138 [label="_considerRefKindDifferences 265741"];
15139 [label="_typeComparison 265742"];
15140 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265743"];
15141 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265744"];
15142 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265745"];
15143 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 265746"];
15144 [label="_typeComparison 265747"];
15145 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265748"];
15146 [label="false 265749"];
15147 [label="considerName: false 265750"];
15148 [label="false 265751"];
15149 [label="considerExplicitlyImplementedInterfaces: false 265752"];
15150 [label="false 265753"];
15151 [label="considerReturnType: false 265754"];
15152 [label="false 265755"];
15153 [label="considerTypeConstraints: false 265756"];
15154 [label="false 265757"];
15155 [label="considerCallingConvention: false 265758"];
15156 [label="true 265759"];
15157 [label="considerRefKindDifferences: true 265760"];
15158 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 265761"];
15159 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265762"];
15160 [label="param MemberSignatureComparer(bool considerName) 265763"];
15161 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265764"];
15162 [label="param MemberSignatureComparer(bool considerReturnType) 265765"];
15163 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265766"];
15164 [label="param MemberSignatureComparer(bool considerCallingConvention) 265767"];
15165 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265768"];
15166 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265769"];
15167 [label="param MemberSignatureComparer(this) 265770"];
15168 [label="_considerName 265771"];
15169 [label="_considerExplicitlyImplementedInterfaces 265772"];
15170 [label="_considerReturnType 265773"];
15171 [label="_considerTypeConstraints 265774"];
15172 [label="_considerCallingConvention 265775"];
15173 [label="_considerRefKindDifferences 265776"];
15174 [label="_typeComparison 265777"];
15175 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265778"];
15176 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265779"];
15177 [label="_considerName 265780"];
15178 [label="_considerExplicitlyImplementedInterfaces 265781"];
15179 [label="_considerReturnType 265782"];
15180 [label="_considerTypeConstraints 265783"];
15181 [label="_considerCallingConvention 265784"];
15182 [label="_considerRefKindDifferences 265785"];
15183 [label="_typeComparison 265786"];
15184 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265787"];
15185 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265788"];
15186 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265789"];
15187 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 265790"];
15188 [label="true 265791"];
15189 [label="considerName: true 265792"];
15190 [label="false 265793"];
15191 [label="considerExplicitlyImplementedInterfaces: false 265794"];
15192 [label="true 265795"];
15193 [label="considerReturnType: true 265796"];
15194 [label="false 265797"];
15195 [label="considerTypeConstraints: false 265798"];
15196 [label="false 265799"];
15197 [label="considerCallingConvention: false 265800"];
15198 [label="true 265801"];
15199 [label="considerRefKindDifferences: true 265802"];
15200 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 265803"];
15201 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265804"];
15202 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265805"];
15203 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265806"];
15204 [label="param MemberSignatureComparer(bool considerName) 265807"];
15205 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265808"];
15206 [label="param MemberSignatureComparer(bool considerReturnType) 265809"];
15207 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265810"];
15208 [label="param MemberSignatureComparer(bool considerCallingConvention) 265811"];
15209 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265812"];
15210 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265813"];
15211 [label="param MemberSignatureComparer(this) 265814"];
15212 [label="_considerName 265815"];
15213 [label="_considerExplicitlyImplementedInterfaces 265816"];
15214 [label="_considerReturnType 265817"];
15215 [label="_considerTypeConstraints 265818"];
15216 [label="_considerCallingConvention 265819"];
15217 [label="_considerRefKindDifferences 265820"];
15218 [label="_typeComparison 265821"];
15219 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265822"];
15220 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265823"];
15221 [label="_considerName 265824"];
15222 [label="_considerExplicitlyImplementedInterfaces 265825"];
15223 [label="_considerReturnType 265826"];
15224 [label="_considerTypeConstraints 265827"];
15225 [label="_considerCallingConvention 265828"];
15226 [label="_considerRefKindDifferences 265829"];
15227 [label="_typeComparison 265830"];
15228 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265831"];
15229 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265832"];
15230 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265833"];
15231 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265834"];
15232 [label="false 265835"];
15233 [label="considerName: false 265836"];
15234 [label="false 265837"];
15235 [label="considerExplicitlyImplementedInterfaces: false 265838"];
15236 [label="false 265839"];
15237 [label="considerReturnType: false 265840"];
15238 [label="false 265841"];
15239 [label="considerTypeConstraints: false 265842"];
15240 [label="false 265843"];
15241 [label="considerCallingConvention: false 265844"];
15242 [label="false 265845"];
15243 [label="considerRefKindDifferences: false 265846"];
15244 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 265847"];
15245 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 265848"];
15246 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 265849"];
15247 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 265850"];
15248 [label="param MemberSignatureComparer(bool considerName) 265851"];
15249 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265852"];
15250 [label="param MemberSignatureComparer(bool considerReturnType) 265853"];
15251 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265854"];
15252 [label="param MemberSignatureComparer(bool considerCallingConvention) 265855"];
15253 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265856"];
15254 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265857"];
15255 [label="param MemberSignatureComparer(this) 265858"];
15256 [label="_considerName 265859"];
15257 [label="_considerExplicitlyImplementedInterfaces 265860"];
15258 [label="_considerReturnType 265861"];
15259 [label="_considerTypeConstraints 265862"];
15260 [label="_considerCallingConvention 265863"];
15261 [label="_considerRefKindDifferences 265864"];
15262 [label="_typeComparison 265865"];
15263 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265866"];
15264 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265867"];
15265 [label="_considerName 265868"];
15266 [label="_considerExplicitlyImplementedInterfaces 265869"];
15267 [label="_considerReturnType 265870"];
15268 [label="_considerTypeConstraints 265871"];
15269 [label="_considerCallingConvention 265872"];
15270 [label="_considerRefKindDifferences 265873"];
15271 [label="_typeComparison 265874"];
15272 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265875"];
15273 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265876"];
15274 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265877"];
15275 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 265878"];
15276 [label="_typeComparison 265879"];
15277 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 265880"];
15278 [label="true 265881"];
15279 [label="considerName: true 265882"];
15280 [label="false 265883"];
15281 [label="considerExplicitlyImplementedInterfaces: false 265884"];
15282 [label="true 265885"];
15283 [label="considerReturnType: true 265886"];
15284 [label="false 265887"];
15285 [label="considerTypeConstraints: false 265888"];
15286 [label="true 265889"];
15287 [label="considerCallingConvention: true 265890"];
15288 [label="false 265891"];
15289 [label="considerRefKindDifferences: false 265892"];
15290 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 265893"];
15291 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265894"];
15292 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265895"];
15293 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265896"];
15294 [label="param MemberSignatureComparer(bool considerName) 265897"];
15295 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265898"];
15296 [label="param MemberSignatureComparer(bool considerReturnType) 265899"];
15297 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265900"];
15298 [label="param MemberSignatureComparer(bool considerCallingConvention) 265901"];
15299 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265902"];
15300 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265903"];
15301 [label="param MemberSignatureComparer(this) 265904"];
15302 [label="_considerName 265905"];
15303 [label="_considerExplicitlyImplementedInterfaces 265906"];
15304 [label="_considerReturnType 265907"];
15305 [label="_considerTypeConstraints 265908"];
15306 [label="_considerCallingConvention 265909"];
15307 [label="_considerRefKindDifferences 265910"];
15308 [label="_typeComparison 265911"];
15309 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265912"];
15310 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265913"];
15311 [label="_considerName 265914"];
15312 [label="_considerExplicitlyImplementedInterfaces 265915"];
15313 [label="_considerReturnType 265916"];
15314 [label="_considerTypeConstraints 265917"];
15315 [label="_considerCallingConvention 265918"];
15316 [label="_considerRefKindDifferences 265919"];
15317 [label="_typeComparison 265920"];
15318 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265921"];
15319 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265922"];
15320 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265923"];
15321 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 265924"];
15322 [label="_typeComparison 265925"];
15323 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265926"];
15324 [label="true 265927"];
15325 [label="considerName: true 265928"];
15326 [label="false 265929"];
15327 [label="considerExplicitlyImplementedInterfaces: false 265930"];
15328 [label="true 265931"];
15329 [label="considerReturnType: true 265932"];
15330 [label="false 265933"];
15331 [label="considerTypeConstraints: false 265934"];
15332 [label="true 265935"];
15333 [label="considerCallingConvention: true 265936"];
15334 [label="true 265937"];
15335 [label="considerRefKindDifferences: true 265938"];
15336 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 265939"];
15337 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265940"];
15338 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265941"];
15339 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265942"];
15340 [label="param MemberSignatureComparer(bool considerName) 265943"];
15341 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265944"];
15342 [label="param MemberSignatureComparer(bool considerReturnType) 265945"];
15343 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265946"];
15344 [label="param MemberSignatureComparer(bool considerCallingConvention) 265947"];
15345 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265948"];
15346 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265949"];
15347 [label="param MemberSignatureComparer(this) 265950"];
15348 [label="_considerName 265951"];
15349 [label="_considerExplicitlyImplementedInterfaces 265952"];
15350 [label="_considerReturnType 265953"];
15351 [label="_considerTypeConstraints 265954"];
15352 [label="_considerCallingConvention 265955"];
15353 [label="_considerRefKindDifferences 265956"];
15354 [label="_typeComparison 265957"];
15355 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265958"];
15356 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 265959"];
15357 [label="_considerName 265960"];
15358 [label="_considerExplicitlyImplementedInterfaces 265961"];
15359 [label="_considerReturnType 265962"];
15360 [label="_considerTypeConstraints 265963"];
15361 [label="_considerCallingConvention 265964"];
15362 [label="_considerRefKindDifferences 265965"];
15363 [label="_typeComparison 265966"];
15364 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265967"];
15365 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 265968"];
15366 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 265969"];
15367 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265970"];
15368 [label="true 265971"];
15369 [label="considerName: true 265972"];
15370 [label="true 265973"];
15371 [label="considerExplicitlyImplementedInterfaces: true 265974"];
15372 [label="true 265975"];
15373 [label="considerReturnType: true 265976"];
15374 [label="false 265977"];
15375 [label="considerTypeConstraints: false 265978"];
15376 [label="true 265979"];
15377 [label="considerCallingConvention: true 265980"];
15378 [label="false 265981"];
15379 [label="considerRefKindDifferences: false 265982"];
15380 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 265983"];
15381 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265984"];
15382 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 265985"];
15383 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 265986"];
15384 [label="param MemberSignatureComparer(bool considerName) 265987"];
15385 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 265988"];
15386 [label="param MemberSignatureComparer(bool considerReturnType) 265989"];
15387 [label="param MemberSignatureComparer(bool considerTypeConstraints) 265990"];
15388 [label="param MemberSignatureComparer(bool considerCallingConvention) 265991"];
15389 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 265992"];
15390 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 265993"];
15391 [label="param MemberSignatureComparer(this) 265994"];
15392 [label="_considerName 265995"];
15393 [label="_considerExplicitlyImplementedInterfaces 265996"];
15394 [label="_considerReturnType 265997"];
15395 [label="_considerTypeConstraints 265998"];
15396 [label="_considerCallingConvention 265999"];
15397 [label="_considerRefKindDifferences 266000"];
15398 [label="_typeComparison 266001"];
15399 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266002"];
15400 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266003"];
15401 [label="_considerName 266004"];
15402 [label="_considerExplicitlyImplementedInterfaces 266005"];
15403 [label="_considerReturnType 266006"];
15404 [label="_considerTypeConstraints 266007"];
15405 [label="_considerCallingConvention 266008"];
15406 [label="_considerRefKindDifferences 266009"];
15407 [label="_typeComparison 266010"];
15408 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266011"];
15409 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266012"];
15410 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 266013"];
15411 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 266014"];
15412 [label="_typeComparison 266015"];
15413 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 266016"];
15414 [label="true 266017"];
15415 [label="considerName: true 266018"];
15416 [label="true 266019"];
15417 [label="considerExplicitlyImplementedInterfaces: true 266020"];
15418 [label="true 266021"];
15419 [label="considerReturnType: true 266022"];
15420 [label="true 266023"];
15421 [label="considerTypeConstraints: true 266024"];
15422 [label="true 266025"];
15423 [label="considerCallingConvention: true 266026"];
15424 [label="true 266027"];
15425 [label="considerRefKindDifferences: true 266028"];
15426 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 266029"];
15427 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 266030"];
15428 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 266031"];
15429 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 266032"];
15430 [label="param MemberSignatureComparer(bool considerName) 266033"];
15431 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 266034"];
15432 [label="param MemberSignatureComparer(bool considerReturnType) 266035"];
15433 [label="param MemberSignatureComparer(bool considerTypeConstraints) 266036"];
15434 [label="param MemberSignatureComparer(bool considerCallingConvention) 266037"];
15435 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 266038"];
15436 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 266039"];
15437 [label="param MemberSignatureComparer(this) 266040"];
15438 [label="_considerName 266041"];
15439 [label="_considerExplicitlyImplementedInterfaces 266042"];
15440 [label="_considerReturnType 266043"];
15441 [label="_considerTypeConstraints 266044"];
15442 [label="_considerCallingConvention 266045"];
15443 [label="_considerRefKindDifferences 266046"];
15444 [label="_typeComparison 266047"];
15445 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266048"];
15446 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266049"];
15447 [label="_considerName 266050"];
15448 [label="_considerExplicitlyImplementedInterfaces 266051"];
15449 [label="_considerReturnType 266052"];
15450 [label="_considerTypeConstraints 266053"];
15451 [label="_considerCallingConvention 266054"];
15452 [label="_considerRefKindDifferences 266055"];
15453 [label="_typeComparison 266056"];
15454 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266057"];
15455 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266058"];
15456 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 266059"];
15457 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 266060"];
15458 [label="true 266061"];
15459 [label="considerName: true 266062"];
15460 [label="false 266063"];
15461 [label="considerExplicitlyImplementedInterfaces: false 266064"];
15462 [label="true 266065"];
15463 [label="considerReturnType: true 266066"];
15464 [label="false 266067"];
15465 [label="considerTypeConstraints: false 266068"];
15466 [label="true 266069"];
15467 [label="considerCallingConvention: true 266070"];
15468 [label="true 266071"];
15469 [label="considerRefKindDifferences: true 266072"];
15470 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 266073"];
15471 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 266074"];
15472 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 266075"];
15473 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 266076"];
15474 [label="param MemberSignatureComparer(bool considerName) 266077"];
15475 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 266078"];
15476 [label="param MemberSignatureComparer(bool considerReturnType) 266079"];
15477 [label="param MemberSignatureComparer(bool considerTypeConstraints) 266080"];
15478 [label="param MemberSignatureComparer(bool considerCallingConvention) 266081"];
15479 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 266082"];
15480 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 266083"];
15481 [label="param MemberSignatureComparer(this) 266084"];
15482 [label="_considerName 266085"];
15483 [label="_considerExplicitlyImplementedInterfaces 266086"];
15484 [label="_considerReturnType 266087"];
15485 [label="_considerTypeConstraints 266088"];
15486 [label="_considerCallingConvention 266089"];
15487 [label="_considerRefKindDifferences 266090"];
15488 [label="_typeComparison 266091"];
15489 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266092"];
15490 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266093"];
15491 [label="_considerName 266094"];
15492 [label="_considerExplicitlyImplementedInterfaces 266095"];
15493 [label="_considerReturnType 266096"];
15494 [label="_considerTypeConstraints 266097"];
15495 [label="_considerCallingConvention 266098"];
15496 [label="_considerRefKindDifferences 266099"];
15497 [label="_typeComparison 266100"];
15498 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266101"];
15499 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266102"];
15500 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 266103"];
15501 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 266104"];
15502 [label="false 266105"];
15503 [label="considerName: false 266106"];
15504 [label="false 266107"];
15505 [label="considerExplicitlyImplementedInterfaces: false 266108"];
15506 [label="false 266109"];
15507 [label="considerReturnType: false 266110"];
15508 [label="false 266111"];
15509 [label="considerTypeConstraints: false 266112"];
15510 [label="false 266113"];
15511 [label="considerCallingConvention: false 266114"];
15512 [label="true 266115"];
15513 [label="considerRefKindDifferences: true 266116"];
15514 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 266117"];
15515 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 266118"];
15516 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 266119"];
15517 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 266120"];
15518 [label="param MemberSignatureComparer(bool considerName) 266121"];
15519 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 266122"];
15520 [label="param MemberSignatureComparer(bool considerReturnType) 266123"];
15521 [label="param MemberSignatureComparer(bool considerTypeConstraints) 266124"];
15522 [label="param MemberSignatureComparer(bool considerCallingConvention) 266125"];
15523 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 266126"];
15524 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 266127"];
15525 [label="param MemberSignatureComparer(this) 266128"];
15526 [label="_considerName 266129"];
15527 [label="_considerExplicitlyImplementedInterfaces 266130"];
15528 [label="_considerReturnType 266131"];
15529 [label="_considerTypeConstraints 266132"];
15530 [label="_considerCallingConvention 266133"];
15531 [label="_considerRefKindDifferences 266134"];
15532 [label="_typeComparison 266135"];
15533 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266136"];
15534 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 266137"];
15535 [label="_considerName 266138"];
15536 [label="_considerExplicitlyImplementedInterfaces 266139"];
15537 [label="_considerReturnType 266140"];
15538 [label="_considerTypeConstraints 266141"];
15539 [label="_considerCallingConvention 266142"];
15540 [label="_considerRefKindDifferences 266143"];
15541 [label="_typeComparison 266144"];
15542 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266145"];
15543 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 266146"];
15544 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 266147"];
15545 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 266148"];
15546 [label="MemberSignatureComparer.RecordAPISignatureComparer 266149"];
15547 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 266150"];
15548 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 266151"];
15549 [label="EmptyComparer.Instance 266152"];
15550 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 266153"];
15551 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 266154"];
15552 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 266155"];
15553 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 266156"];
15554 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 266157"];
15555 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 266158"];
15556 [label="containingSymbol 266159"];
15557 [label="declaration 266160"];
15558 [label="diagnostics 266161"];
15559 [label="tupleData 266162"];
15560 [label="param SourceNamedTypeSymbol(this) 266163"];
15561 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 266164"];
15562 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 266165"];
15563 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 266166"];
15564 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 266167"];
15565 [label="param SourceMemberContainerTypeSymbol(this) 266168"];
15566 [label="tupleData 266169"];
15567 [label="param SourceMemberContainerTypeSymbol(this) 266170"];
15568 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 266171"];
15569 [label="_lazyTupleData 266172"];
15570 [label="_declModifiers 266173"];
15571 [label="_containingSymbol 266174"];
15572 [label="declaration 266175"];
15573 [label="new DeclaredMembersAndInitializers() 266176"];
15574 [label="param DeclaredMembersAndInitializers(this) 266177"];
15575 [label="HaveIndexers 266178"];
15576 [label="RecordDeclarationWithParameters 266179"];
15577 [label="RecordPrimaryConstructor 266180"];
15578 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 266181"];
15579 [label="IsNullableEnabledForInstanceConstructorsAndFields 266182"];
15580 [label="IsNullableEnabledForStaticConstructorsAndFields 266183"];
15581 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 266184"];
15582 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 266185"];
15583 [label="_lazyMembersAndInitializers 266186"];
15584 [label="_lazyMembersDictionary 266187"];
15585 [label="_lazyEarlyAttributeDecodingMembersDictionary 266188"];
15586 [label="_lazyTypeMembers 266189"];
15587 [label="_lazyKnownCircularStruct 266190"];
15588 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 266191"];
15589 [label="_lazyContainsExtensionMethods 266192"];
15590 [label="_lazyAnyMemberHasAttributes 266193"];
15591 [label="_containingSymbol 266194"];
15592 [label="this.declaration 266195"];
15593 [label="declaration.Kind 266196"];
15594 [label="get\n            {\n                return this.Declarations[0].Kind;\n            } 266197"];
15595 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 266198"];
15596 [label="declaration.Kind.ToTypeKind() 266199"];
15597 [label="param ToTypeKind(this DeclarationKind kind) 266200"];
15598 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 266201"];
15599 [label="return TypeKind.Class; 266202"];
15600 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 266203"];
15601 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 266204"];
15602 [label="MakeModifiers(typeKind, diagnostics) 266205"];
15603 [label="param MakeModifiers(TypeKind typeKind) 266206"];
15604 [label="param MakeModifiers(DiagnosticBag diagnostics) 266207"];
15605 [label="param MakeModifiers(this) 266208"];
15606 [label="this.ContainingSymbol 266209"];
15607 [label="get\n            {\n                return _containingSymbol;\n            } 266210"];
15608 [label="return _containingSymbol; 266211"];
15609 [label="Symbol containingSymbol = this.ContainingSymbol; 266212"];
15610 [label="DeclarationModifiers defaultAccess; 266213"];
15611 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 266214"];
15612 [label="containingSymbol.Kind 266215"];
15613 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266216"];
15614 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 266217"];
15615 [label="defaultAccess = DeclarationModifiers.Internal; 266218"];
15616 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 266219"];
15617 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 266220"];
15618 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 266221"];
15619 [label="this.IsRecord 266222"];
15620 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 266223"];
15621 [label="this.declaration.Declarations 266224"];
15622 [label="get\n            {\n                return _declarations;\n            } 266225"];
15623 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 266226"];
15624 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 266227"];
15625 [label="this.declaration.Declarations[0].Kind 266228"];
15626 [label="get\n            {\n                return _kind;\n            } 266229"];
15627 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 266230"];
15628 [label="allowedModifiers |= DeclarationModifiers.Static; 266231"];
15629 [label="bool modifierErrors; 266232"];
15630 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266233"];
15631 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266234"];
15632 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266235"];
15633 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266236"];
15634 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 266237"];
15635 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 266238"];
15636 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 266239"];
15637 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 266240"];
15638 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 266241"];
15639 [label="param MakeAndCheckTypeModifiers(this) 266242"];
15640 [label="modifierErrors = false; 266243"];
15641 [label="var result = DeclarationModifiers.Unset; 266244"];
15642 [label="declaration.Declarations 266245"];
15643 [label="get\n            {\n                return _declarations;\n            } 266246"];
15644 [label="return _declarations; 266247"];
15645 [label="var partCount = declaration.Declarations.Length; 266248"];
15646 [label="var missingPartial = false; 266249"];
15647 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 266250"];
15648 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 266251"];
15649 [label="declaration.Declarations 266252"];
15650 [label="var decl = declaration.Declarations[i]; 266253"];
15651 [label="decl.Modifiers 266254"];
15652 [label="get\n            {\n                return _modifiers;\n            } 266255"];
15653 [label="return _modifiers; 266256"];
15654 [label="var mods = decl.Modifiers; 266257"];
15655 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 266258"];
15656 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 266259"];
15657 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266260"];
15658 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266261"];
15659 [label="declaration.Declarations 266262"];
15660 [label="return _declarations; 266263"];
15661 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266264"];
15662 [label="declaration.Declarations[i].NameLocation 266265"];
15663 [label="get\n            {\n                return _nameLocation;\n            } 266266"];
15664 [label="return _nameLocation; 266267"];
15665 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266268"];
15666 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266269"];
15667 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 266270"];
15668 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 266271"];
15669 [label="param CheckModifiers(DeclarationModifiers modifiers) 266272"];
15670 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 266273"];
15671 [label="param CheckModifiers(Location errorLocation) 266274"];
15672 [label="param CheckModifiers(DiagnosticBag diagnostics) 266275"];
15673 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 266276"];
15674 [label="param CheckModifiers(out bool modifierErrors) 266277"];
15675 [label="modifierErrors = false; 266278"];
15676 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 266279"];
15677 [label="DeclarationModifiers result = modifiers & allowedModifiers; 266280"];
15678 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 266281"];
15679 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 266282"];
15680 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 266283"];
15681 [label="return result; 266284"];
15682 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 266285"];
15683 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266286"];
15684 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266287"];
15685 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266288"];
15686 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 266289"];
15687 [label="param CheckAccessibility(DeclarationModifiers modifiers) 266290"];
15688 [label="param CheckAccessibility(Symbol symbol) 266291"];
15689 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 266292"];
15690 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 266293"];
15691 [label="IsValidAccessibility(modifiers) 266294"];
15692 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 266295"];
15693 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 266296"];
15694 [label="return true; 266297"];
15695 [label="symbol.Kind 266298"];
15696 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 266299"];
15697 [label="return SymbolKind.NamedType; 266300"];
15698 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266301"];
15699 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266302"];
15700 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266303"];
15701 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266304"];
15702 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266305"];
15703 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 266306"];
15704 [label="return null; 266307"];
15705 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266308"];
15706 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 266309"];
15707 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 266310"];
15708 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 266311"];
15709 [label="result = mods; 266312"];
15710 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 266313"];
15711 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 266314"];
15712 [label="result |= defaultAccess; 266315"];
15713 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 266316"];
15714 [label="this.Name 266317"];
15715 [label="get\n            {\n                return declaration.Name;\n            } 266318"];
15716 [label="declaration.Name 266319"];
15717 [label="get\n            {\n                return this.name;\n            } 266320"];
15718 [label="return this.name; 266321"];
15719 [label="return declaration.Name; 266322"];
15720 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266323"];
15721 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266324"];
15722 [label="SyntaxFacts.GetText(SyntaxKind.RecordKeyword) 266325"];
15723 [label="param GetText(SyntaxKind kind) 266326"];
15724 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266327"];
15725 [label="return result; 266328"];
15726 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 266329"];
15727 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 266330"];
15728 [label="this.CheckUnsafeModifier(mods, diagnostics); 266331"];
15729 [label="this.CheckUnsafeModifier(mods, diagnostics); 266332"];
15730 [label="this.CheckUnsafeModifier(mods, diagnostics); 266333"];
15731 [label="this.CheckUnsafeModifier(mods, diagnostics) 266334"];
15732 [label="param CheckUnsafeModifier(this Symbol symbol) 266335"];
15733 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 266336"];
15734 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 266337"];
15735 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 266338"];
15736 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 266339"];
15737 [label="symbol.Locations 266340"];
15738 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 266341"];
15739 [label="declaration.NameLocations 266342"];
15740 [label="get\n            {\n                if (Declarations.Length == 1)\n                {\n                    return ImmutableArray.Create(Declarations[0].NameLocation);\n                }\n                else\n                {\n                    var builder = ArrayBuilder<SourceLocation>.GetInstance();\n                    foreach (var decl in Declarations)\n                    {\n                        SourceLocation loc = decl.NameLocation;\n                        if (loc != null)\n                            builder.Add(loc);\n                    }\n                    return builder.ToImmutableAndFree();\n                }\n            } 266343"];
15741 [label="Declarations 266344"];
15742 [label="get\n            {\n                return _declarations;\n            } 266345"];
15743 [label="return _declarations; 266346"];
15744 [label="if (Declarations.Length == 1)\n                {\n                    return ImmutableArray.Create(Declarations[0].NameLocation);\n                }\n                else\n                {\n                    var builder = ArrayBuilder<SourceLocation>.GetInstance();\n                    foreach (var decl in Declarations)\n                    {\n                        SourceLocation loc = decl.NameLocation;\n                        if (loc != null)\n                            builder.Add(loc);\n                    }\n                    return builder.ToImmutableAndFree();\n                } 266347"];
15745 [label="if (Declarations.Length == 1)\n                {\n                    return ImmutableArray.Create(Declarations[0].NameLocation);\n                }\n                else\n                {\n                    var builder = ArrayBuilder<SourceLocation>.GetInstance();\n                    foreach (var decl in Declarations)\n                    {\n                        SourceLocation loc = decl.NameLocation;\n                        if (loc != null)\n                            builder.Add(loc);\n                    }\n                    return builder.ToImmutableAndFree();\n                } 266348"];
15746 [label="Declarations 266349"];
15747 [label="return ImmutableArray.Create(Declarations[0].NameLocation); 266350"];
15748 [label="return ImmutableArray.Create(Declarations[0].NameLocation); 266351"];
15749 [label="Declarations[0].NameLocation 266352"];
15750 [label="get\n            {\n                return _nameLocation;\n            } 266353"];
15751 [label="return _nameLocation; 266354"];
15752 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 266355"];
15753 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 266356"];
15754 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 266357"];
15755 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 266358"];
15756 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 266359"];
15757 [label="param CheckUnsafeModifier(this Symbol symbol) 266360"];
15758 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 266361"];
15759 [label="param CheckUnsafeModifier(Location errorLocation) 266362"];
15760 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 266363"];
15761 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 266364"];
15762 [label="this.CheckUnsafeModifier(mods, diagnostics); 266365"];
15763 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266366"];
15764 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266367"];
15765 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266368"];
15766 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266369"];
15767 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266370"];
15768 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266371"];
15769 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 266372"];
15770 [label="return mods; 266373"];
15771 [label="declaration.Declarations 266374"];
15772 [label="get\n            {\n                return _declarations;\n            } 266375"];
15773 [label="return _declarations; 266376"];
15774 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 266377"];
15775 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 266378"];
15776 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 266379"];
15777 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 266380"];
15778 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 266381"];
15779 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 266382"];
15780 [label="_declModifiers 266383"];
15781 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 266384"];
15782 [label="access == (int)DeclarationModifiers.Public 266385"];
15783 [label="0 266386"];
15784 [label="SpecialTypeOffset = 0 266387"];
15785 [label="6 266388"];
15786 [label="SpecialTypeSize = 6 266389"];
15787 [label="SpecialTypeOffset + SpecialTypeSize 266390"];
15788 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 266391"];
15789 [label="2 266392"];
15790 [label="ManagedKindSize = 2 266393"];
15791 [label="ManagedKindOffset + ManagedKindSize 266394"];
15792 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 266395"];
15793 [label="1 266396"];
15794 [label="FieldDefinitionsNotedSize = 1 266397"];
15795 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 266398"];
15796 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 266399"];
15797 [label="1 266400"];
15798 [label="FlattenedMembersIsSortedSize = 1 266401"];
15799 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 266402"];
15800 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 266403"];
15801 [label="4 266404"];
15802 [label="TypeKindSize = 4 266405"];
15803 [label="TypeKindOffset + TypeKindSize 266406"];
15804 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 266407"];
15805 [label="3 266408"];
15806 [label="NullableContextSize = 3 266409"];
15807 [label="1 266410"];
15808 [label="1 << SpecialTypeSize 266411"];
15809 [label="1 266412"];
15810 [label="(1 << SpecialTypeSize) - 1 266413"];
15811 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 266414"];
15812 [label="1 266415"];
15813 [label="1 << ManagedKindSize 266416"];
15814 [label="1 266417"];
15815 [label="(1 << ManagedKindSize) - 1 266418"];
15816 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 266419"];
15817 [label="1 266420"];
15818 [label="1 << TypeKindSize 266421"];
15819 [label="1 266422"];
15820 [label="(1 << TypeKindSize) - 1 266423"];
15821 [label="TypeKindMask = (1 << TypeKindSize) - 1 266424"];
15822 [label="1 266425"];
15823 [label="1 << NullableContextSize 266426"];
15824 [label="1 266427"];
15825 [label="(1 << NullableContextSize) - 1 266428"];
15826 [label="NullableContextMask = (1 << NullableContextSize) - 1 266429"];
15827 [label="1 266430"];
15828 [label="1 << FieldDefinitionsNotedOffset 266431"];
15829 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 266432"];
15830 [label="1 266433"];
15831 [label="1 << FlattenedMembersIsSortedOffset 266434"];
15832 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 266435"];
15833 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 266436"];
15834 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 266437"];
15835 [label="_flags = new Flags(specialType, typeKind); 266438"];
15836 [label="_flags = new Flags(specialType, typeKind); 266439"];
15837 [label="_flags = new Flags(specialType, typeKind); 266440"];
15838 [label="new Flags(specialType, typeKind) 266441"];
15839 [label="param Flags(SpecialType specialType) 266442"];
15840 [label="param Flags(TypeKind typeKind) 266443"];
15841 [label="param Flags(this) 266444"];
15842 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 266445"];
15843 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 266446"];
15844 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 266447"];
15845 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 266448"];
15846 [label="_flags = specialTypeInt | typeKindInt; 266449"];
15847 [label="_flags 266450"];
15848 [label="_flags 266451"];
15849 [label="this.ContainingType 266452"];
15850 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 266453"];
15851 [label="return _containingSymbol as NamedTypeSymbol; 266454"];
15852 [label="var containingType = this.ContainingType; 266455"];
15853 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 266456"];
15854 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 266457"];
15855 [label="state.NotePartComplete(CompletionPart.TypeArguments); 266458"];
15856 [label="state.NotePartComplete(CompletionPart.TypeArguments) 266459"];
15857 [label="param NotePartComplete(CompletionPart part) 266460"];
15858 [label="param NotePartComplete(this) 266461"];
15859 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 266462"];
15860 [label="_lazyCustomAttributesBag 266463"];
15861 [label="_lazyDocComment 266464"];
15862 [label="_lazyExpandedDocComment 266465"];
15863 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 266466"];
15864 [label="_lazyDeclaredBases 266467"];
15865 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 266468"];
15866 [label="_lazyEnumValueField 266469"];
15867 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 266470"];
15868 [label="declaration.Kind 266471"];
15869 [label="get\n            {\n                return this.Declarations[0].Kind;\n            } 266472"];
15870 [label="return _declarations; 266473"];
15871 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 266474"];
15872 [label="containingSymbol.Kind 266475"];
15873 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266476"];
15874 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 266477"];
15875 [label="get\n            {\n                return declaration.Name;\n            } 266478"];
15876 [label="declaration.Name 266479"];
15877 [label="get\n            {\n                return this.name;\n            } 266480"];
15878 [label="return this.name; 266481"];
15879 [label="return declaration.Name; 266482"];
15880 [label="param BuildSymbol(this) 266483"];
15881 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 266484"];
15882 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 266485"];
15883 [label="containingSymbol 266486"];
15884 [label="tupleData 266487"];
15885 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 266488"];
15886 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 266489"];
15887 [label="tupleData 266490"];
15888 [label="_lazyTupleData 266491"];
15889 [label="_declModifiers 266492"];
15890 [label="_containingSymbol 266493"];
15891 [label="declaration 266494"];
15892 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 266495"];
15893 [label="_lazyMembersAndInitializers 266496"];
15894 [label="_lazyMembersDictionary 266497"];
15895 [label="_lazyEarlyAttributeDecodingMembersDictionary 266498"];
15896 [label="_lazyTypeMembers 266499"];
15897 [label="_lazyKnownCircularStruct 266500"];
15898 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 266501"];
15899 [label="_lazyContainsExtensionMethods 266502"];
15900 [label="_lazyAnyMemberHasAttributes 266503"];
15901 [label="_containingSymbol 266504"];
15902 [label="param MakeModifiers(DiagnosticBag diagnostics) 266505"];
15903 [label="this.ContainingSymbol 266506"];
15904 [label="get\n            {\n                return _containingSymbol;\n            } 266507"];
15905 [label="return _containingSymbol; 266508"];
15906 [label="Symbol containingSymbol = this.ContainingSymbol; 266509"];
15907 [label="DeclarationModifiers defaultAccess; 266510"];
15908 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 266511"];
15909 [label="containingSymbol.Kind 266512"];
15910 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266513"];
15911 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 266514"];
15912 [label="defaultAccess = DeclarationModifiers.Internal; 266515"];
15913 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 266516"];
15914 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 266517"];
15915 [label="this.declaration.Declarations[0].Kind 266518"];
15916 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 266519"];
15917 [label="allowedModifiers |= DeclarationModifiers.Static; 266520"];
15918 [label="bool modifierErrors; 266521"];
15919 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266522"];
15920 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266523"];
15921 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266524"];
15922 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 266525"];
15923 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 266526"];
15924 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 266527"];
15925 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 266528"];
15926 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 266529"];
15927 [label="var result = DeclarationModifiers.Unset; 266530"];
15928 [label="var missingPartial = false; 266531"];
15929 [label="decl.Modifiers 266532"];
15930 [label="get\n            {\n                return _modifiers;\n            } 266533"];
15931 [label="return _modifiers; 266534"];
15932 [label="var mods = decl.Modifiers; 266535"];
15933 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 266536"];
15934 [label="declaration.Declarations[i].NameLocation 266537"];
15935 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 266538"];
15936 [label="param CheckModifiers(DeclarationModifiers modifiers) 266539"];
15937 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 266540"];
15938 [label="param CheckModifiers(Location errorLocation) 266541"];
15939 [label="param CheckModifiers(DiagnosticBag diagnostics) 266542"];
15940 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 266543"];
15941 [label="param CheckModifiers(out bool modifierErrors) 266544"];
15942 [label="modifierErrors = false; 266545"];
15943 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 266546"];
15944 [label="DeclarationModifiers result = modifiers & allowedModifiers; 266547"];
15945 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 266548"];
15946 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 266549"];
15947 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 266550"];
15948 [label="return result; 266551"];
15949 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 266552"];
15950 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266553"];
15951 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266554"];
15952 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266555"];
15953 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 266556"];
15954 [label="param CheckAccessibility(DeclarationModifiers modifiers) 266557"];
15955 [label="param CheckAccessibility(Symbol symbol) 266558"];
15956 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 266559"];
15957 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 266560"];
15958 [label="IsValidAccessibility(modifiers) 266561"];
15959 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 266562"];
15960 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 266563"];
15961 [label="return true; 266564"];
15962 [label="symbol.Kind 266565"];
15963 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 266566"];
15964 [label="return SymbolKind.NamedType; 266567"];
15965 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266568"];
15966 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266569"];
15967 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266570"];
15968 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266571"];
15969 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 266572"];
15970 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 266573"];
15971 [label="return null; 266574"];
15972 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 266575"];
15973 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 266576"];
15974 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 266577"];
15975 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 266578"];
15976 [label="result = mods; 266579"];
15977 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 266580"];
15978 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 266581"];
15979 [label="result |= defaultAccess; 266582"];
15980 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 266583"];
15981 [label="this.Name 266584"];
15982 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266585"];
15983 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266586"];
15984 [label="SyntaxFacts.GetText(SyntaxKind.RecordKeyword) 266587"];
15985 [label="param GetText(SyntaxKind kind) 266588"];
15986 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 266589"];
15987 [label="return result; 266590"];
15988 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 266591"];
15989 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 266592"];
15990 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 266593"];
15991 [label="param CheckUnsafeModifier(this Symbol symbol) 266594"];
15992 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 266595"];
15993 [label="param CheckUnsafeModifier(Location errorLocation) 266596"];
15994 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 266597"];
15995 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 266598"];
15996 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266599"];
15997 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266600"];
15998 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 266601"];
15999 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266602"];
16000 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266603"];
16001 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 266604"];
16002 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 266605"];
16003 [label="return mods; 266606"];
16004 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 266607"];
16005 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 266608"];
16006 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 266609"];
16007 [label="_declModifiers 266610"];
16008 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 266611"];
16009 [label="access == (int)DeclarationModifiers.Public 266612"];
16010 [label="_flags = new Flags(specialType, typeKind); 266613"];
16011 [label="_flags = new Flags(specialType, typeKind); 266614"];
16012 [label="new Flags(specialType, typeKind) 266615"];
16013 [label="param Flags(SpecialType specialType) 266616"];
16014 [label="param Flags(TypeKind typeKind) 266617"];
16015 [label="param Flags(this) 266618"];
16016 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 266619"];
16017 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 266620"];
16018 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 266621"];
16019 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 266622"];
16020 [label="_flags = specialTypeInt | typeKindInt; 266623"];
16021 [label="_flags 266624"];
16022 [label="_flags 266625"];
16023 [label="this.ContainingType 266626"];
16024 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 266627"];
16025 [label="return _containingSymbol as NamedTypeSymbol; 266628"];
16026 [label="var containingType = this.ContainingType; 266629"];
16027 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 266630"];
16028 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 266631"];
16029 [label="state.NotePartComplete(CompletionPart.TypeArguments); 266632"];
16030 [label="state.NotePartComplete(CompletionPart.TypeArguments) 266633"];
16031 [label="param NotePartComplete(CompletionPart part) 266634"];
16032 [label="_lazyCustomAttributesBag 266635"];
16033 [label="_lazyDocComment 266636"];
16034 [label="_lazyExpandedDocComment 266637"];
16035 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 266638"];
16036 [label="_lazyDeclaredBases 266639"];
16037 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 266640"];
16038 [label="_lazyEnumValueField 266641"];
16039 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 266642"];
16040 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 266643"];
16041 [label="containingSymbol.Kind 266644"];
16042 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266645"];
16043 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 266646"];
16044 [label="return this.name; 266647"];
16045 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 266648"];
16046 [label="members 266649"];
16047 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 266650"];
16048 [label="return SymbolKind.NamedType; 266651"];
16049 [label="param CheckMembers(NamespaceSymbol @namespace) 266652"];
16050 [label="param CheckMembers(DiagnosticBag diagnostics) 266653"];
16051 [label="var memberOfArity = new Symbol[10]; 266654"];
16052 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 266655"];
16053 [label="@namespace.ContainingAssembly 266656"];
16054 [label="=> _module.ContainingAssembly 266657"];
16055 [label="_module.ContainingAssembly 266658"];
16056 [label="get\n            {\n                return _assemblySymbol;\n            } 266659"];
16057 [label="return _assemblySymbol; 266660"];
16058 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 266661"];
16059 [label="@namespace.ContainingAssembly.Modules 266662"];
16060 [label="get\n            {\n                return _modules;\n            } 266663"];
16061 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 266664"];
16062 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 266665"];
16063 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 266666"];
16064 [label="var nts = symbol as NamedTypeSymbol; 266667"];
16065 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 266668"];
16066 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 266669"];
16067 [label="((object)nts != null) 266670"];
16068 [label="nts.Arity 266671"];
16069 [label="get\n            {\n                return declaration.Arity;\n            } 266672"];
16070 [label="declaration.Arity 266673"];
16071 [label="get\n            {\n                return this.Declarations[0].Arity;\n            } 266674"];
16072 [label="this.Declarations 266675"];
16073 [label="get\n            {\n                return _declarations;\n            } 266676"];
16074 [label="return this.Declarations[0].Arity; 266677"];
16075 [label="return this.Declarations[0].Arity; 266678"];
16076 [label="this.Declarations[0].Arity 266679"];
16077 [label="get\n            {\n                return _arity;\n            } 266680"];
16078 [label="return declaration.Arity; 266681"];
16079 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 266682"];
16080 [label="var other = memberOfArity[arity]; 266683"];
16081 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266684"];
16082 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266685"];
16083 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266686"];
16084 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266687"];
16085 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 266688"];
16086 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 266689"];
16087 [label="memberOfArity[arity] 266690"];
16088 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 266691"];
16089 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 266692"];
16090 [label="nts.DeclaredAccessibility 266693"];
16091 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 266694"];
16092 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 266695"];
16093 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 266696"];
16094 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 266697"];
16095 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 266698"];
16096 [label="return Accessibility.Internal; 266699"];
16097 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 266700"];
16098 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 266701"];
16099 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 266702"];
16100 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 266703"];
16101 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 266704"];
16102 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 266705"];
16103 [label="var other = memberOfArity[arity]; 266706"];
16104 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266707"];
16105 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266708"];
16106 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266709"];
16107 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 266710"];
16108 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 266711"];
16109 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 266712"];
16110 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 266713"];
16111 [label="nts.DeclaredAccessibility 266714"];
16112 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 266715"];
16113 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 266716"];
16114 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 266717"];
16115 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 266718"];
16116 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 266719"];
16117 [label="return Accessibility.Internal; 266720"];
16118 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 266721"];
16119 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 266722"];
16120 [label="this.Kind 266723"];
16121 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266724"];
16122 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 266725"];
16123 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 266726"];
16124 [label="RegisterDeclaredCorTypes() 266727"];
16125 [label="param RegisterDeclaredCorTypes(this) 266728"];
16126 [label="ContainingAssembly 266729"];
16127 [label="=> _module.ContainingAssembly 266730"];
16128 [label="_module.ContainingAssembly 266731"];
16129 [label="get\n            {\n                return _assemblySymbol;\n            } 266732"];
16130 [label="return _assemblySymbol; 266733"];
16131 [label="AssemblySymbol containingAssembly = ContainingAssembly; 266734"];
16132 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 266735"];
16133 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 266736"];
16134 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 266737"];
16135 [label="RegisterDeclaredCorTypes(); 266738"];
16136 [label="DeclaringCompilation 266739"];
16137 [label="this.Kind 266740"];
16138 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 266741"];
16139 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 266742"];
16140 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 266743"];
16141 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 266744"];
16142 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 266745"];
16143 [label="param SymbolDeclaredEvent(Symbol symbol) 266746"];
16144 [label="param SymbolDeclaredEvent(this) 266747"];
16145 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 266748"];
16146 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 266749"];
16147 [label="Debug.Assert(wasSetThisThread); 266750"];
16148 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266751"];
16149 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266752"];
16150 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266753"];
16151 [label="var bt = (ns1.GetMembers('B').FirstOrDefault() as NamedTypeSymbol).BaseType(); 266754"];
16152 [label="ns1.GetMembers('B') 266755"];
16153 [label="param GetMembers(string name) 266756"];
16154 [label="param GetMembers(this) 266757"];
16155 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 266758"];
16156 [label="members 266759"];
16157 [label="this.GetNameToMembersMap() 266760"];
16158 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 266761"];
16159 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 266762"];
16160 [label="return _nameToMembersMap; 266763"];
16161 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266764"];
16162 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266765"];
16163 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 266766"];
16164 [label="(ns1.GetMembers('B').FirstOrDefault() as NamedTypeSymbol).BaseType() 266767"];
16165 [label="param BaseType(this TypeSymbol symbol) 266768"];
16166 [label="symbol.BaseTypeNoUseSiteDiagnostics 266769"];
16167 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 266770"];
16168 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 266771"];
16169 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 266772"];
16170 [label="ContainingType 266773"];
16171 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 266774"];
16172 [label="return _containingSymbol as NamedTypeSymbol; 266775"];
16173 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 266776"];
16174 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 266777"];
16175 [label="var diagnostics = DiagnosticBag.GetInstance(); 266778"];
16176 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 266779"];
16177 [label="this.MakeAcyclicBaseType(diagnostics) 266780"];
16178 [label="param MakeAcyclicBaseType(DiagnosticBag diagnostics) 266781"];
16179 [label="param MakeAcyclicBaseType(this) 266782"];
16180 [label="this.TypeKind 266783"];
16181 [label="get\n            {\n                return _flags.TypeKind;\n            } 266784"];
16182 [label="_flags.TypeKind 266785"];
16183 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 266786"];
16184 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 266787"];
16185 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 266788"];
16186 [label="return _flags.TypeKind; 266789"];
16187 [label="var typeKind = this.TypeKind; 266790"];
16188 [label="this.DeclaringCompilation 266791"];
16189 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 266792"];
16190 [label="this.Kind 266793"];
16191 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 266794"];
16192 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 266795"];
16193 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 266796"];
16194 [label="this.ContainingSymbol 266797"];
16195 [label="get\n            {\n                return _containingSymbol;\n            } 266798"];
16196 [label="return _containingSymbol; 266799"];
16197 [label="var container = this.ContainingSymbol; 266800"];
16198 [label="return (object)container != null ? container.ContainingModule : null; 266801"];
16199 [label="return (object)container != null ? container.ContainingModule : null; 266802"];
16200 [label="(object)container != null 266803"];
16201 [label="container.ContainingModule 266804"];
16202 [label="var compilation = this.DeclaringCompilation; 266805"];
16203 [label="NamedTypeSymbol declaredBase; 266806"];
16204 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert((object)GetDeclaredBaseType(basesBeingResolved: null) == null, 'Computation skipped for enums');\n                declaredBase = compilation.GetSpecialType(SpecialType.System_Enum);\n            }\n            else\n            {\n                declaredBase = GetDeclaredBaseType(basesBeingResolved: null);\n            } 266807"];
16205 [label="declaredBase = GetDeclaredBaseType(basesBeingResolved: null); 266808"];
16206 [label="GetDeclaredBaseType(basesBeingResolved: null) 266809"];
16207 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 266810"];
16208 [label="param GetDeclaredBaseType(this) 266811"];
16209 [label="return GetDeclaredBases(basesBeingResolved).Item1; 266812"];
16210 [label="GetDeclaredBases(basesBeingResolved) 266813"];
16211 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 266814"];
16212 [label="param GetDeclaredBases(this) 266815"];
16213 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 266816"];
16214 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 266817"];
16215 [label="var diagnostics = DiagnosticBag.GetInstance(); 266818"];
16216 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 266819"];
16217 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 266820"];
16218 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 266821"];
16219 [label="MakeDeclaredBases(basesBeingResolved, diagnostics) 266822"];
16220 [label="param MakeDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 266823"];
16221 [label="param MakeDeclaredBases(DiagnosticBag diagnostics) 266824"];
16222 [label="param MakeDeclaredBases(this) 266825"];
16223 [label="this.TypeKind 266826"];
16224 [label="get\n            {\n                return _flags.TypeKind;\n            } 266827"];
16225 [label="if (this.TypeKind == TypeKind.Enum)\n            {\n                // Handled by GetEnumUnderlyingType().\n                return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(null, ImmutableArray<NamedTypeSymbol>.Empty);\n            } 266828"];
16226 [label="var reportedPartialConflict = false; 266829"];
16227 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 266830"];
16228 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 266831"];
16229 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 266832"];
16230 [label="this.OriginalDefinition 266833"];
16231 [label="get\n            {\n                return this;\n            } 266834"];
16232 [label="return this; 266835"];
16233 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 266836"];
16234 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 266837"];
16235 [label="var baseInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 266838"];
16236 [label="NamedTypeSymbol baseType = null; 266839"];
16237 [label="SourceLocation baseTypeLocation = null; 266840"];
16238 [label="SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>() 266841"];
16239 [label="SymbolEqualityComparer.ConsiderEverything 266842"];
16240 [label="PooledDictionary<TSymbol, V>.CreatePool(SymbolEqualityComparer.ConsiderEverything) 266843"];
16241 [label="s_poolInstance = PooledDictionary<TSymbol, V>.CreatePool(SymbolEqualityComparer.ConsiderEverything) 266844"];
16242 [label="var instance = PooledSymbolDictionary<KSymbol, V>.s_poolInstance.Allocate(); 266845"];
16243 [label="Debug.Assert(instance.Count == 0); 266846"];
16244 [label="Debug.Assert(instance.Count == 0); 266847"];
16245 [label="return instance; 266848"];
16246 [label="var interfaceLocations = SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>(); 266849"];
16247 [label="this.declaration.Declarations 266850"];
16248 [label="get\n            {\n                return _declarations;\n            } 266851"];
16249 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics);\n                if ((object)one == null) continue;\n\n                var partBase = one.Item1;\n                var partInterfaces = one.Item2;\n                if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                }\n\n                foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                }\n            } 266852"];
16250 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 266853"];
16251 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 266854"];
16252 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 266855"];
16253 [label="MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics) 266856"];
16254 [label="param MakeOneDeclaredBases(ConsList<TypeSymbol> newBasesBeingResolved) 266857"];
16255 [label="param MakeOneDeclaredBases(SingleTypeDeclaration decl) 266858"];
16256 [label="param MakeOneDeclaredBases(DiagnosticBag diagnostics) 266859"];
16257 [label="param MakeOneDeclaredBases(this) 266860"];
16258 [label="BaseListSyntax bases = GetBaseListOpt(decl); 266861"];
16259 [label="GetBaseListOpt(decl) 266862"];
16260 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 266863"];
16261 [label="decl.HasBaseDeclarations 266864"];
16262 [label="get\n            {\n                return (_flags & TypeDeclarationFlags.HasBaseDeclarations) != 0;\n            } 266865"];
16263 [label="return (_flags & TypeDeclarationFlags.HasBaseDeclarations) != 0; 266866"];
16264 [label="return (_flags & TypeDeclarationFlags.HasBaseDeclarations) != 0; 266867"];
16265 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 266868"];
16266 [label="decl.SyntaxReference 266869"];
16267 [label="get\n            {\n                return _syntaxReference;\n            } 266870"];
16268 [label="return _syntaxReference; 266871"];
16269 [label="var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax(); 266872"];
16270 [label="var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax(); 266873"];
16271 [label="decl.SyntaxReference.GetSyntax() 266874"];
16272 [label="param GetSyntax(CancellationToken cancellationToken) 266875"];
16273 [label="param GetSyntax(this) 266876"];
16274 [label="return _node; 266877"];
16275 [label="return typeDeclaration.BaseList; 266878"];
16276 [label="if (bases == null)\n            {\n                return null;\n            } 266879"];
16277 [label="if (bases == null)\n            {\n                return null;\n            } 266880"];
16278 [label="NamedTypeSymbol localBase = null; 266881"];
16279 [label="var localInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 266882"];
16280 [label="this.DeclaringCompilation 266883"];
16281 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 266884"];
16282 [label="this.Kind 266885"];
16283 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 266886"];
16284 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 266887"];
16285 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 266888"];
16286 [label="this.ContainingSymbol 266889"];
16287 [label="get\n            {\n                return _containingSymbol;\n            } 266890"];
16288 [label="return _containingSymbol; 266891"];
16289 [label="var container = this.ContainingSymbol; 266892"];
16290 [label="return (object)container != null ? container.ContainingModule : null; 266893"];
16291 [label="return (object)container != null ? container.ContainingModule : null; 266894"];
16292 [label="(object)container != null 266895"];
16293 [label="container.ContainingModule 266896"];
16294 [label="var baseBinder = this.DeclaringCompilation.GetBinder(bases); 266897"];
16295 [label="var baseBinder = this.DeclaringCompilation.GetBinder(bases); 266898"];
16296 [label="this.DeclaringCompilation.GetBinder(bases) 266899"];
16297 [label="param GetBinder(CSharpSyntaxNode syntax) 266900"];
16298 [label="param GetBinder(this) 266901"];
16299 [label="syntax.SyntaxTree 266902"];
16300 [label="get\n            {\n                var result = this._syntaxTree ?? ComputeSyntaxTree(this);\n                Debug.Assert(result != null);\n                return result;\n            } 266903"];
16301 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 266904"];
16302 [label="SyntaxTree? tree = null; 266905"];
16303 [label="tree = node._syntaxTree; 266906"];
16304 [label="if (tree != null)\n                {\n                    break;\n                } 266907"];
16305 [label="if (tree != null)\n                {\n                    break;\n                } 266908"];
16306 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 266909"];
16307 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 266910"];
16308 [label="Debug.Assert(result != null); 266911"];
16309 [label="Debug.Assert(result != null); 266912"];
16310 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 266913"];
16311 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 266914"];
16312 [label="GetBinderFactory(syntax.SyntaxTree) 266915"];
16313 [label="param GetBinderFactory(SyntaxTree syntaxTree) 266916"];
16314 [label="param GetBinderFactory(bool ignoreAccessibility = false) 266917"];
16315 [label="param GetBinderFactory(this) 266918"];
16316 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 266919"];
16317 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 266920"];
16318 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 266921"];
16319 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 266922"];
16320 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 266923"];
16321 [label="param GetBinderFactory(SyntaxTree syntaxTree) 266924"];
16322 [label="param GetBinderFactory(bool ignoreAccessibility) 266925"];
16323 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 266926"];
16324 [label="param GetBinderFactory(this) 266927"];
16325 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 266928"];
16326 [label="ignoreAccessibility 266929"];
16327 [label="_binderFactories 266930"];
16328 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 266931"];
16329 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 266932"];
16330 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 266933"];
16331 [label="GetSyntaxTreeOrdinal(syntaxTree) 266934"];
16332 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 266935"];
16333 [label="param GetSyntaxTreeOrdinal(this) 266936"];
16334 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 266937"];
16335 [label="this.ContainsSyntaxTree(tree) 266938"];
16336 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 266939"];
16337 [label="param ContainsSyntaxTree(this) 266940"];
16338 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 266941"];
16339 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 266942"];
16340 [label="_syntaxAndDeclarations.GetLazyState() 266943"];
16341 [label="param GetLazyState(this) 266944"];
16342 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 266945"];
16343 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 266946"];
16344 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 266947"];
16345 [label="_syntaxAndDeclarations.GetLazyState() 266948"];
16346 [label="param GetLazyState(this) 266949"];
16347 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 266950"];
16348 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 266951"];
16349 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 266952"];
16350 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 266953"];
16351 [label="this.SyntaxTrees 266954"];
16352 [label="param GetLazyState(this) 266955"];
16353 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 266956"];
16354 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 266957"];
16355 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 266958"];
16356 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 266959"];
16357 [label="BinderFactory? previousFactory; 266960"];
16358 [label="var previousWeakReference = binderFactories[treeNum]; 266961"];
16359 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 266962"];
16360 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 266963"];
16361 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 266964"];
16362 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 266965"];
16363 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 266966"];
16364 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 266967"];
16365 [label="param AddNewFactory(SyntaxTree syntaxTree) 266968"];
16366 [label="param AddNewFactory(bool ignoreAccessibility) 266969"];
16367 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 266970"];
16368 [label="param AddNewFactory(this) 266971"];
16369 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 266972"];
16370 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 266973"];
16371 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 266974"];
16372 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 266975"];
16373 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 266976"];
16374 [label="param BinderFactory(CSharpCompilation compilation) 266977"];
16375 [label="param BinderFactory(SyntaxTree syntaxTree) 266978"];
16376 [label="param BinderFactory(bool ignoreAccessibility) 266979"];
16377 [label="param BinderFactory(this) 266980"];
16378 [label="_binderCache 266981"];
16379 [label="_compilation 266982"];
16380 [label="_syntaxTree 266983"];
16381 [label="_buckStopsHereBinder 266984"];
16382 [label="_ignoreAccessibility 266985"];
16383 [label="_binderFactoryVisitorPool 266986"];
16384 [label="_compilation 266987"];
16385 [label="_syntaxTree 266988"];
16386 [label="_ignoreAccessibility 266989"];
16387 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 266990"];
16388 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 266991"];
16389 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 266992"];
16390 [label="_binderFactoryVisitorPool 266993"];
16391 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 266994"];
16392 [label="_binderCache 266995"];
16393 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 266996"];
16394 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 266997"];
16395 [label="new BuckStopsHereBinder(compilation) 266998"];
16396 [label="param BuckStopsHereBinder(CSharpCompilation compilation) 266999"];
16397 [label="param BuckStopsHereBinder(this) 267000"];
16398 [label="0 267001"];
16399 [label="ExternalScope = 0 267002"];
16400 [label="1 267003"];
16401 [label="TopLevelScope = 1 267004"];
16402 [label="2 267005"];
16403 [label="ValueKindInsignificantBits = 2 267006"];
16404 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 267007"];
16405 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 267008"];
16406 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 267009"];
16407 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 267010"];
16408 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 267011"];
16409 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 267012"];
16410 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 267013"];
16411 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 267014"];
16412 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 267015"];
16413 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 267016"];
16414 [label="10 267017"];
16415 [label="MaxParameterListsForErrorRecovery = 10 267018"];
16416 [label="'<>h__TransparentIdentifier' 267019"];
16417 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 267020"];
16418 [label="s => (MethodSymbol)s 267021"];
16419 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 267022"];
16420 [label="s => (PropertySymbol)s 267023"];
16421 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 267024"];
16422 [label="compilation 267025"];
16423 [label="param BuckStopsHereBinder(this) 267026"];
16424 [label="param Binder(CSharpCompilation compilation) 267027"];
16425 [label="param Binder(this) 267028"];
16426 [label="internal CSharpCompilation Compilation { get; } 267029"];
16427 [label="Flags 267030"];
16428 [label="protected internal Binder? Next { get; } 267031"];
16429 [label="_lazyConversions 267032"];
16430 [label="_lazyOverloadResolution 267033"];
16431 [label="RoslynDebug.Assert(compilation != null); 267034"];
16432 [label="RoslynDebug.Assert(compilation != null); 267035"];
16433 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 267036"];
16434 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 267037"];
16435 [label="compilation.Options 267038"];
16436 [label="get\n            {\n                return _options;\n            } 267039"];
16437 [label="return _options; 267040"];
16438 [label="this.Flags = compilation.Options.TopLevelBinderFlags; 267041"];
16439 [label="this.Flags 267042"];
16440 [label="this.Compilation 267043"];
16441 [label="_buckStopsHereBinder 267044"];
16442 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 267045"];
16443 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 267046"];
16444 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 267047"];
16445 [label="BinderFactory? previousFactory; 267048"];
16446 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 267049"];
16447 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 267050"];
16448 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 267051"];
16449 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 267052"];
16450 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 267053"];
16451 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 267054"];
16452 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 267055"];
16453 [label="return newFactory; 267056"];
16454 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 267057"];
16455 [label="GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax) 267058"];
16456 [label="param GetBinder(SyntaxNode node) 267059"];
16457 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 267060"];
16458 [label="param GetBinder(Symbol memberOpt = null) 267061"];
16459 [label="param GetBinder(this) 267062"];
16460 [label="int position = node.SpanStart; 267063"];
16461 [label="node.SpanStart 267064"];
16462 [label="param GetLeadingTriviaWidth(this) 267065"];
16463 [label="InScript 267066"];
16464 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 267067"];
16465 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 267068"];
16466 [label="_syntaxTree.Options 267069"];
16467 [label="get\n            {\n                return this.Options;\n            } 267070"];
16468 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 267071"];
16469 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 267072"];
16470 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 267073"];
16471 [label="node = node.Parent; 267074"];
16472 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 267075"];
16473 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 267076"];
16474 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 267077"];
16475 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 267078"];
16476 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 267079"];
16477 [label="param GetBinder(SyntaxNode node) 267080"];
16478 [label="param GetBinder(int position) 267081"];
16479 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 267082"];
16480 [label="param GetBinder(Symbol memberOpt = null) 267083"];
16481 [label="param GetBinder(this) 267084"];
16482 [label="Debug.Assert(node != null); 267085"];
16483 [label="Debug.Assert(node != null); 267086"];
16484 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 267087"];
16485 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 267088"];
16486 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 267089"];
16487 [label="param BinderFactoryVisitor(BinderFactory factory) 267090"];
16488 [label="param BinderFactoryVisitor(this) 267091"];
16489 [label="param BinderFactoryVisitor(this) 267092"];
16490 [label="param CSharpSyntaxVisitor(this) 267093"];
16491 [label="_position 267094"];
16492 [label="_memberDeclarationOpt 267095"];
16493 [label="_memberOpt 267096"];
16494 [label="_factory 267097"];
16495 [label="_factory 267098"];
16496 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 267099"];
16497 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 267100"];
16498 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 267101"];
16499 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 267102"];
16500 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 267103"];
16501 [label="param Initialize(int position) 267104"];
16502 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 267105"];
16503 [label="param Initialize(Symbol memberOpt) 267106"];
16504 [label="param Initialize(this) 267107"];
16505 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267108"];
16506 [label="memberDeclarationOpt == null 267109"];
16507 [label="param ==(Symbol left) 267110"];
16508 [label="param ==(Symbol right) 267111"];
16509 [label="if (right is null)\n            {\n                return left is null;\n            } 267112"];
16510 [label="return left is null; 267113"];
16511 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267114"];
16512 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267115"];
16513 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267116"];
16514 [label="_position 267117"];
16515 [label="_memberDeclarationOpt 267118"];
16516 [label="_memberOpt 267119"];
16517 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 267120"];
16518 [label="Binder result = visitor.Visit(node); 267121"];
16519 [label="visitor.Visit(node) 267122"];
16520 [label="param Visit(SyntaxNode node) 267123"];
16521 [label="param Visit(this) 267124"];
16522 [label="return VisitCore(node); 267125"];
16523 [label="VisitCore(node) 267126"];
16524 [label="param VisitCore(SyntaxNode node) 267127"];
16525 [label="param VisitCore(this) 267128"];
16526 [label="return ((CSharpSyntaxNode)node).Accept(this); 267129"];
16527 [label="return ((CSharpSyntaxNode)node).Accept(this); 267130"];
16528 [label="return ((CSharpSyntaxNode)node).Accept(this); 267131"];
16529 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 267132"];
16530 [label="param VisitClassDeclaration(this) 267133"];
16531 [label="return VisitTypeDeclarationCore(node); 267134"];
16532 [label="VisitTypeDeclarationCore(node) 267135"];
16533 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 267136"];
16534 [label="param VisitTypeDeclarationCore(this) 267137"];
16535 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 267138"];
16536 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 267139"];
16537 [label="LookupPosition.IsInTypeDeclaration(_position, parent) 267140"];
16538 [label="param IsInTypeDeclaration(int position) 267141"];
16539 [label="param IsInTypeDeclaration(BaseTypeDeclarationSyntax typeDecl) 267142"];
16540 [label="Debug.Assert(typeDecl != null); 267143"];
16541 [label="Debug.Assert(typeDecl != null); 267144"];
16542 [label="return IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken); 267145"];
16543 [label="return IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken); 267146"];
16544 [label="return IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken); 267147"];
16545 [label="typeDecl.CloseBraceToken 267148"];
16546 [label="=> true 267149"];
16547 [label="return IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken); 267150"];
16548 [label="return IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken); 267151"];
16549 [label="IsBeforeToken(position, typeDecl, typeDecl.CloseBraceToken) 267152"];
16550 [label="param IsBeforeToken(int position) 267153"];
16551 [label="param IsBeforeToken(CSharpSyntaxNode node) 267154"];
16552 [label="param IsBeforeToken(SyntaxToken firstExcluded) 267155"];
16553 [label="return IsBeforeToken(position, firstExcluded) && position >= node.SpanStart; 267156"];
16554 [label="return IsBeforeToken(position, firstExcluded) && position >= node.SpanStart; 267157"];
16555 [label="IsBeforeToken(position, firstExcluded) 267158"];
16556 [label="param IsBeforeToken(int position) 267159"];
16557 [label="param IsBeforeToken(SyntaxToken firstExcluded) 267160"];
16558 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267161"];
16559 [label="firstExcluded.Kind() 267162"];
16560 [label="param Kind(this SyntaxToken token) 267163"];
16561 [label="var rawKind = token.RawKind; 267164"];
16562 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 267165"];
16563 [label="IsCSharpKind(rawKind) 267166"];
16564 [label="param IsCSharpKind(int rawKind) 267167"];
16565 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 267168"];
16566 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 267169"];
16567 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267170"];
16568 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267171"];
16569 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267172"];
16570 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267173"];
16571 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267174"];
16572 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267175"];
16573 [label="firstExcluded.SpanStart 267176"];
16574 [label="param GetLeadingTriviaWidth(this) 267177"];
16575 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267178"];
16576 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267179"];
16577 [label="return IsBeforeToken(position, firstExcluded) && position >= node.SpanStart; 267180"];
16578 [label="node.SpanStart 267181"];
16579 [label="param GetLeadingTriviaWidth(this) 267182"];
16580 [label="return IsBeforeToken(position, firstExcluded) && position >= node.SpanStart; 267183"];
16581 [label="return IsBeforeToken(position, firstExcluded) && position >= node.SpanStart; 267184"];
16582 [label="NodeUsage extraInfo = NodeUsage.Normal; 267185"];
16583 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267186"];
16584 [label="parent.OpenBraceToken 267187"];
16585 [label="=> true 267188"];
16586 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267189"];
16587 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267190"];
16588 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267191"];
16589 [label="parent.CloseBraceToken 267192"];
16590 [label="=> true 267193"];
16591 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267194"];
16592 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267195"];
16593 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267196"];
16594 [label="parent.OpenBraceToken 267197"];
16595 [label="=> true 267198"];
16596 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267199"];
16597 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267200"];
16598 [label="parent.CloseBraceToken 267201"];
16599 [label="=> true 267202"];
16600 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267203"];
16601 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267204"];
16602 [label="LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) 267205"];
16603 [label="param IsBetweenTokens(int position) 267206"];
16604 [label="param IsBetweenTokens(SyntaxToken firstIncluded) 267207"];
16605 [label="param IsBetweenTokens(SyntaxToken firstExcluded) 267208"];
16606 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267209"];
16607 [label="firstIncluded.SpanStart 267210"];
16608 [label="param GetLeadingTriviaWidth(this) 267211"];
16609 [label="param GetLeadingTrivia(this) 267212"];
16610 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267213"];
16611 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267214"];
16612 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267215"];
16613 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267216"];
16614 [label="LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists) 267217"];
16615 [label="param IsInAttributeSpecification(int position) 267218"];
16616 [label="param IsInAttributeSpecification(SyntaxList<AttributeListSyntax> attributesSyntaxList) 267219"];
16617 [label="int count = attributesSyntaxList.Count; 267220"];
16618 [label="if (count == 0)\n            {\n                return false;\n            } 267221"];
16619 [label="if (count == 0)\n            {\n                return false;\n            } 267222"];
16620 [label="return false; 267223"];
16621 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267224"];
16622 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267225"];
16623 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267226"];
16624 [label="LookupPosition.IsInTypeParameterList(_position, parent) 267227"];
16625 [label="param IsInTypeParameterList(int position) 267228"];
16626 [label="param IsInTypeParameterList(TypeDeclarationSyntax typeDecl) 267229"];
16627 [label="var typeParameterListOpt = typeDecl.TypeParameterList; 267230"];
16628 [label="return typeParameterListOpt != null && IsBeforeToken(position, typeParameterListOpt, typeParameterListOpt.GreaterThanToken); 267231"];
16629 [label="return typeParameterListOpt != null && IsBeforeToken(position, typeParameterListOpt, typeParameterListOpt.GreaterThanToken); 267232"];
16630 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267233"];
16631 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267234"];
16632 [label="parent.Keyword 267235"];
16633 [label="=> true 267236"];
16634 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267237"];
16635 [label="parent.OpenBraceToken 267238"];
16636 [label="=> true 267239"];
16637 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267240"];
16638 [label="if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 267241"];
16639 [label="LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken) 267242"];
16640 [label="param IsBetweenTokens(int position) 267243"];
16641 [label="param IsBetweenTokens(SyntaxToken firstIncluded) 267244"];
16642 [label="param IsBetweenTokens(SyntaxToken firstExcluded) 267245"];
16643 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267246"];
16644 [label="IsBeforeToken(position, firstExcluded) 267247"];
16645 [label="param IsBeforeToken(int position) 267248"];
16646 [label="param IsBeforeToken(SyntaxToken firstExcluded) 267249"];
16647 [label="firstExcluded.Kind() 267250"];
16648 [label="param Kind(this SyntaxToken token) 267251"];
16649 [label="var rawKind = token.RawKind; 267252"];
16650 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 267253"];
16651 [label="IsCSharpKind(rawKind) 267254"];
16652 [label="param IsCSharpKind(int rawKind) 267255"];
16653 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 267256"];
16654 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 267257"];
16655 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267258"];
16656 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267259"];
16657 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267260"];
16658 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267261"];
16659 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 267262"];
16660 [label="param GetLeadingTrivia(this) 267263"];
16661 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267264"];
16662 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267265"];
16663 [label="extraInfo = NodeUsage.NamedTypeBaseListOrParameterList; 267266"];
16664 [label="return VisitTypeDeclarationCore(parent, extraInfo); 267267"];
16665 [label="return VisitTypeDeclarationCore(parent, extraInfo); 267268"];
16666 [label="VisitTypeDeclarationCore(parent, extraInfo) 267269"];
16667 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 267270"];
16668 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 267271"];
16669 [label="param VisitTypeDeclarationCore(this) 267272"];
16670 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267273"];
16671 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267274"];
16672 [label="CreateBinderCacheKey(parent, extraInfo) 267275"];
16673 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 267276"];
16674 [label="param CreateBinderCacheKey(NodeUsage usage) 267277"];
16675 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267278"];
16676 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267279"];
16677 [label="return new BinderCacheKey(node, usage); 267280"];
16678 [label="return new BinderCacheKey(node, usage); 267281"];
16679 [label="return new BinderCacheKey(node, usage); 267282"];
16680 [label="new BinderCacheKey(node, usage) 267283"];
16681 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 267284"];
16682 [label="param BinderCacheKey(NodeUsage usage) 267285"];
16683 [label="param BinderCacheKey(this) 267286"];
16684 [label="this.syntaxNode 267287"];
16685 [label="this.usage 267288"];
16686 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267289"];
16687 [label="Binder resultBinder; 267290"];
16688 [label="binderCache 267291"];
16689 [label="get\n                {\n                    return _factory._binderCache;\n                } 267292"];
16690 [label="return _factory._binderCache; 267293"];
16691 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 267294"];
16692 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 267295"];
16693 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 267296"];
16694 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 267297"];
16695 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 267298"];
16696 [label="param GetHashCode(this) 267299"];
16697 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 267300"];
16698 [label="parent.Parent 267301"];
16699 [label="resultBinder = VisitCore(parent.Parent); 267302"];
16700 [label="VisitCore(parent.Parent) 267303"];
16701 [label="param VisitCore(SyntaxNode node) 267304"];
16702 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 267305"];
16703 [label="param VisitNamespaceDeclaration(this) 267306"];
16704 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 267307"];
16705 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 267308"];
16706 [label="LookupPosition.IsInNamespaceDeclaration(_position, parent) 267309"];
16707 [label="param IsInNamespaceDeclaration(int position) 267310"];
16708 [label="param IsInNamespaceDeclaration(NamespaceDeclarationSyntax namespaceDecl) 267311"];
16709 [label="Debug.Assert(namespaceDecl != null); 267312"];
16710 [label="Debug.Assert(namespaceDecl != null); 267313"];
16711 [label="return IsBetweenTokens(position, namespaceDecl.NamespaceKeyword, namespaceDecl.CloseBraceToken); 267314"];
16712 [label="return IsBetweenTokens(position, namespaceDecl.NamespaceKeyword, namespaceDecl.CloseBraceToken); 267315"];
16713 [label="namespaceDecl.NamespaceKeyword 267316"];
16714 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 267317"];
16715 [label="=> true 267318"];
16716 [label="return IsBetweenTokens(position, namespaceDecl.NamespaceKeyword, namespaceDecl.CloseBraceToken); 267319"];
16717 [label="namespaceDecl.CloseBraceToken 267320"];
16718 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 267321"];
16719 [label="=> true 267322"];
16720 [label="return IsBetweenTokens(position, namespaceDecl.NamespaceKeyword, namespaceDecl.CloseBraceToken); 267323"];
16721 [label="IsBetweenTokens(position, namespaceDecl.NamespaceKeyword, namespaceDecl.CloseBraceToken) 267324"];
16722 [label="param IsBetweenTokens(int position) 267325"];
16723 [label="param IsBetweenTokens(SyntaxToken firstIncluded) 267326"];
16724 [label="param IsBetweenTokens(SyntaxToken firstExcluded) 267327"];
16725 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267328"];
16726 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267329"];
16727 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267330"];
16728 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 267331"];
16729 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 267332"];
16730 [label="parent.OpenBraceToken 267333"];
16731 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 267334"];
16732 [label="=> true 267335"];
16733 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 267336"];
16734 [label="parent.CloseBraceToken 267337"];
16735 [label="get\n            {\n                return (InternalSyntax.NamespaceDeclarationSyntax)base.Green;\n            } 267338"];
16736 [label="=> true 267339"];
16737 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 267340"];
16738 [label="LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) 267341"];
16739 [label="param IsBetweenTokens(int position) 267342"];
16740 [label="param IsBetweenTokens(SyntaxToken firstIncluded) 267343"];
16741 [label="param IsBetweenTokens(SyntaxToken firstExcluded) 267344"];
16742 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267345"];
16743 [label="return position >= firstIncluded.SpanStart && IsBeforeToken(position, firstExcluded); 267346"];
16744 [label="return firstExcluded.Kind() == SyntaxKind.None || position < firstExcluded.SpanStart; 267347"];
16745 [label="bool inUsing = IsInUsing(parent); 267348"];
16746 [label="IsInUsing(parent) 267349"];
16747 [label="param IsInUsing(CSharpSyntaxNode containingNode) 267350"];
16748 [label="param IsInUsing(this) 267351"];
16749 [label="TextSpan containingSpan = containingNode.Span; 267352"];
16750 [label="containingNode.Span 267353"];
16751 [label="param GetLeadingTriviaWidth(this) 267354"];
16752 [label="param GetTrailingTriviaWidth(this) 267355"];
16753 [label="SyntaxToken token; 267356"];
16754 [label="token 267357"];
16755 [label="containingNode.Kind() 267358"];
16756 [label="param Kind(this) 267359"];
16757 [label="return (SyntaxKind)this.Green.RawKind; 267360"];
16758 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 267361"];
16759 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 267362"];
16760 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 267363"];
16761 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 267364"];
16762 [label="token = containingNode.FindToken(_position); 267365"];
16763 [label="token = containingNode.FindToken(_position); 267366"];
16764 [label="containingNode.FindToken(_position) 267367"];
16765 [label="param FindToken(int position) 267368"];
16766 [label="param FindToken(bool findInsideTrivia = false) 267369"];
16767 [label="param FindToken(this) 267370"];
16768 [label="return base.FindToken(position, findInsideTrivia); 267371"];
16769 [label="return base.FindToken(position, findInsideTrivia); 267372"];
16770 [label="return base.FindToken(position, findInsideTrivia); 267373"];
16771 [label="return base.FindToken(position, findInsideTrivia); 267374"];
16772 [label="=> true 267375"];
16773 [label="var node = token.Parent; 267376"];
16774 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267377"];
16775 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267378"];
16776 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267379"];
16777 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267380"];
16778 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267381"];
16779 [label="node.IsKind(SyntaxKind.UsingDirective) 267382"];
16780 [label="param IsKind([NotNullWhen(true)] this SyntaxNode? node) 267383"];
16781 [label="param IsKind(SyntaxKind kind) 267384"];
16782 [label="return node?.RawKind == (int)kind; 267385"];
16783 [label="node = node.Parent; 267386"];
16784 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267387"];
16785 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267388"];
16786 [label="node.IsKind(SyntaxKind.UsingDirective) 267389"];
16787 [label="param IsKind([NotNullWhen(true)] this SyntaxNode? node) 267390"];
16788 [label="param IsKind(SyntaxKind kind) 267391"];
16789 [label="return node?.RawKind == (int)kind; 267392"];
16790 [label="return false; 267393"];
16791 [label="bool inUsing = IsInUsing(parent); 267394"];
16792 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 267395"];
16793 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 267396"];
16794 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 267397"];
16795 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 267398"];
16796 [label="VisitNamespaceDeclaration(parent, _position, inBody, inUsing) 267399"];
16797 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 267400"];
16798 [label="param VisitNamespaceDeclaration(int position) 267401"];
16799 [label="param VisitNamespaceDeclaration(bool inBody) 267402"];
16800 [label="param VisitNamespaceDeclaration(bool inUsing) 267403"];
16801 [label="param VisitNamespaceDeclaration(this) 267404"];
16802 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 267405"];
16803 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 267406"];
16804 [label="inUsing 267407"];
16805 [label="inBody 267408"];
16806 [label="var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal); 267409"];
16807 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267410"];
16808 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267411"];
16809 [label="CreateBinderCacheKey(parent, extraInfo) 267412"];
16810 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 267413"];
16811 [label="param CreateBinderCacheKey(NodeUsage usage) 267414"];
16812 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267415"];
16813 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267416"];
16814 [label="var key = CreateBinderCacheKey(parent, extraInfo); 267417"];
16815 [label="Binder result; 267418"];
16816 [label="binderCache 267419"];
16817 [label="get\n                {\n                    return _factory._binderCache;\n                } 267420"];
16818 [label="return _factory._binderCache; 267421"];
16819 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267422"];
16820 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267423"];
16821 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267424"];
16822 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267425"];
16823 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267426"];
16824 [label="Binder outer; 267427"];
16825 [label="parent.Parent 267428"];
16826 [label="var container = parent.Parent; 267429"];
16827 [label="InScript 267430"];
16828 [label="get\n                {\n                    return _factory.InScript;\n                } 267431"];
16829 [label="_factory.InScript 267432"];
16830 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 267433"];
16831 [label="return _factory.InScript; 267434"];
16832 [label="if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    } 267435"];
16833 [label="parent.Parent 267436"];
16834 [label="outer = _factory.GetBinder(parent.Parent, position); 267437"];
16835 [label="outer = _factory.GetBinder(parent.Parent, position); 267438"];
16836 [label="outer = _factory.GetBinder(parent.Parent, position); 267439"];
16837 [label="_factory.GetBinder(parent.Parent, position) 267440"];
16838 [label="param GetBinder(SyntaxNode node) 267441"];
16839 [label="param GetBinder(int position) 267442"];
16840 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 267443"];
16841 [label="param GetBinder(Symbol memberOpt = null) 267444"];
16842 [label="Debug.Assert(node != null); 267445"];
16843 [label="Debug.Assert(node != null); 267446"];
16844 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 267447"];
16845 [label="param CSharpSyntaxVisitor(this) 267448"];
16846 [label="_factory 267449"];
16847 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267450"];
16848 [label="memberDeclarationOpt == null 267451"];
16849 [label="param ==(Symbol left) 267452"];
16850 [label="param ==(Symbol right) 267453"];
16851 [label="if (right is null)\n            {\n                return left is null;\n            } 267454"];
16852 [label="return left is null; 267455"];
16853 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267456"];
16854 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 267457"];
16855 [label="return ((CSharpSyntaxNode)node).Accept(this); 267458"];
16856 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 267459"];
16857 [label="param VisitCompilationUnit(this) 267460"];
16858 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 267461"];
16859 [label="IsInUsing(parent) 267462"];
16860 [label="param IsInUsing(CSharpSyntaxNode containingNode) 267463"];
16861 [label="param IsInUsing(this) 267464"];
16862 [label="param GetTrailingTrivia(this) 267465"];
16863 [label="SyntaxToken token; 267466"];
16864 [label="token 267467"];
16865 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 267468"];
16866 [label="=> true 267469"];
16867 [label="var node = token.Parent; 267470"];
16868 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267471"];
16869 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267472"];
16870 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 267473"];
16871 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267474"];
16872 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267475"];
16873 [label="node.IsKind(SyntaxKind.UsingDirective) 267476"];
16874 [label="param IsKind([NotNullWhen(true)] this SyntaxNode? node) 267477"];
16875 [label="param IsKind(SyntaxKind kind) 267478"];
16876 [label="return node?.RawKind == (int)kind; 267479"];
16877 [label="node = node.Parent; 267480"];
16878 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267481"];
16879 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 267482"];
16880 [label="node.IsKind(SyntaxKind.UsingDirective) 267483"];
16881 [label="param IsKind([NotNullWhen(true)] this SyntaxNode? node) 267484"];
16882 [label="param IsKind(SyntaxKind kind) 267485"];
16883 [label="return node?.RawKind == (int)kind; 267486"];
16884 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 267487"];
16885 [label="InScript 267488"];
16886 [label="get\n                {\n                    return _factory.InScript;\n                } 267489"];
16887 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 267490"];
16888 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 267491"];
16889 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 267492"];
16890 [label="param VisitCompilationUnit(bool inUsing) 267493"];
16891 [label="param VisitCompilationUnit(bool inScript) 267494"];
16892 [label="param VisitCompilationUnit(this) 267495"];
16893 [label="syntaxTree 267496"];
16894 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 267497"];
16895 [label="return _factory._syntaxTree; 267498"];
16896 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 267499"];
16897 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 267500"];
16898 [label="param GetRoot(CancellationToken cancellationToken) 267501"];
16899 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 267502"];
16900 [label="inUsing 267503"];
16901 [label="inScript 267504"];
16902 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 267505"];
16903 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 267506"];
16904 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 267507"];
16905 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 267508"];
16906 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 267509"];
16907 [label="param CreateBinderCacheKey(NodeUsage usage) 267510"];
16908 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267511"];
16909 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 267512"];
16910 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 267513"];
16911 [label="Binder result; 267514"];
16912 [label="binderCache 267515"];
16913 [label="get\n                {\n                    return _factory._binderCache;\n                } 267516"];
16914 [label="return _factory._binderCache; 267517"];
16915 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267518"];
16916 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267519"];
16917 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267520"];
16918 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267521"];
16919 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 267522"];
16920 [label="this.buckStopsHereBinder 267523"];
16921 [label="get\n                {\n                    return _factory._buckStopsHereBinder;\n                } 267524"];
16922 [label="return _factory._buckStopsHereBinder; 267525"];
16923 [label="result = this.buckStopsHereBinder; 267526"];
16924 [label="if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    } 267527"];
16925 [label="compilation 267528"];
16926 [label="get\n                {\n                    return _factory._compilation;\n                } 267529"];
16927 [label="return _factory._compilation; 267530"];
16928 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 267531"];
16929 [label="compilation.GlobalNamespace 267532"];
16930 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 267533"];
16931 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 267534"];
16932 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 267535"];
16933 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 267536"];
16934 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 267537"];
16935 [label="new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing) 267538"];
16936 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 267539"];
16937 [label="param InContainerBinder(Binder next) 267540"];
16938 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 267541"];
16939 [label="param InContainerBinder(bool inUsing) 267542"];
16940 [label="param InContainerBinder(this) 267543"];
16941 [label="next 267544"];
16942 [label="param InContainerBinder(this) 267545"];
16943 [label="param Binder(Binder next) 267546"];
16944 [label="param Binder(this) 267547"];
16945 [label="param Binder(Conversions? conversions = null) 267548"];
16946 [label="RoslynDebug.Assert(next != null); 267549"];
16947 [label="RoslynDebug.Assert(next != null); 267550"];
16948 [label="Next 267551"];
16949 [label="this.Flags 267552"];
16950 [label="this.Compilation 267553"];
16951 [label="_lazyConversions 267554"];
16952 [label="_container 267555"];
16953 [label="_computeImports 267556"];
16954 [label="_lazyImports 267557"];
16955 [label="_lazyImportChain 267558"];
16956 [label="_lazyQuickAttributeChecker 267559"];
16957 [label="Debug.Assert((object)container != null); 267560"];
16958 [label="Debug.Assert((object)container != null); 267561"];
16959 [label="Debug.Assert(declarationSyntax != null); 267562"];
16960 [label="Debug.Assert(declarationSyntax != null); 267563"];
16961 [label="_container 267564"];
16962 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 267565"];
16963 [label="_computeImports 267566"];
16964 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 267567"];
16965 [label="declarationSyntax.Kind() 267568"];
16966 [label="param Kind(this) 267569"];
16967 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 267570"];
16968 [label="var compilationUnit = (CompilationUnitSyntax)declarationSyntax; 267571"];
16969 [label="_usingsSyntax 267572"];
16970 [label="compilation 267573"];
16971 [label="get\n                {\n                    return _factory._compilation;\n                } 267574"];
16972 [label="return _factory._compilation; 267575"];
16973 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 267576"];
16974 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 267577"];
16975 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 267578"];
16976 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) 267579"];
16977 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 267580"];
16978 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 267581"];
16979 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 267582"];
16980 [label="var type = GetSimpleProgramNamedTypeSymbol(compilation); 267583"];
16981 [label="GetSimpleProgramNamedTypeSymbol(compilation) 267584"];
16982 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 267585"];
16983 [label="compilation.SourceModule 267586"];
16984 [label="get\n            {\n                return Assembly.Modules[0];\n            } 267587"];
16985 [label="Assembly 267588"];
16986 [label="get\n            {\n                return SourceAssembly;\n            } 267589"];
16987 [label="GetBoundReferenceManager(); 267590"];
16988 [label="return Assembly.Modules[0]; 267591"];
16989 [label="Assembly.Modules 267592"];
16990 [label="get\n            {\n                return _modules;\n            } 267593"];
16991 [label="return Assembly.Modules[0]; 267594"];
16992 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 267595"];
16993 [label="compilation.SourceModule.GlobalNamespace 267596"];
16994 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 267597"];
16995 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 267598"];
16996 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 267599"];
16997 [label="param GetTypeMembers(string name) 267600"];
16998 [label="param GetTypeMembers(this) 267601"];
16999 [label="ImmutableArray<NamedTypeSymbol> members; 267602"];
17000 [label="members 267603"];
17001 [label="this.GetNameToTypeMembersMap() 267604"];
17002 [label="param GetNameToTypeMembersMap(this) 267605"];
17003 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 267606"];
17004 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 267607"];
17005 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 267608"];
17006 [label="GetNameToMembersMap() 267609"];
17007 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 267610"];
17008 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 267611"];
17009 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 267612"];
17010 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 267613"];
17011 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 267614"];
17012 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 267615"];
17013 [label="bool hasType = false; 267616"];
17014 [label="bool hasNamespace = false; 267617"];
17015 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 267618"];
17016 [label="symbol.Kind 267619"];
17017 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 267620"];
17018 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 267621"];
17019 [label="symbol.Kind 267622"];
17020 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 267623"];
17021 [label="Debug.Assert(symbol.Kind == SymbolKind.Namespace); 267624"];
17022 [label="hasNamespace = true; 267625"];
17023 [label="if (hasType)\n                        {\n                            break;\n                        } 267626"];
17024 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 267627"];
17025 [label="return dictionary; 267628"];
17026 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 267629"];
17027 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 267630"];
17028 [label="return _nameToTypeMembersMap; 267631"];
17029 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267632"];
17030 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267633"];
17031 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267634"];
17032 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267635"];
17033 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 267636"];
17034 [label="if (type is null)\n            {\n                return null;\n            } 267637"];
17035 [label="return null; 267638"];
17036 [label="binderCache 267639"];
17037 [label="return _factory._binderCache; 267640"];
17038 [label="binderCache.TryAdd(key, result); 267641"];
17039 [label="binderCache.TryAdd(key, result); 267642"];
17040 [label="binderCache.TryAdd(key, result); 267643"];
17041 [label="binderCache.TryAdd(key, result); 267644"];
17042 [label="binderCache.TryAdd(key, result); 267645"];
17043 [label="return result; 267646"];
17044 [label="return ((CSharpSyntaxNode)node).Accept(this); 267647"];
17045 [label="_binderFactoryVisitorPool.Free(visitor); 267648"];
17046 [label="_binderFactoryVisitorPool.Free(visitor); 267649"];
17047 [label="return result; 267650"];
17048 [label="if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    } 267651"];
17049 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 267652"];
17050 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 267653"];
17051 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 267654"];
17052 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 267655"];
17053 [label="MakeNamespaceBinder(parent, parent.Name, outer, inUsing) 267656"];
17054 [label="param MakeNamespaceBinder(CSharpSyntaxNode node) 267657"];
17055 [label="param MakeNamespaceBinder(NameSyntax name) 267658"];
17056 [label="param MakeNamespaceBinder(Binder outer) 267659"];
17057 [label="param MakeNamespaceBinder(bool inUsing) 267660"];
17058 [label="param MakeNamespaceBinder(this) 267661"];
17059 [label="QualifiedNameSyntax dotted; 267662"];
17060 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 267663"];
17061 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 267664"];
17062 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 267665"];
17063 [label="NamespaceOrTypeSymbol container; 267666"];
17064 [label="if (outer is InContainerBinder inContainerBinder)\n                {\n                    container = inContainerBinder.Container;\n                }\n                else\n                {\n                    Debug.Assert(outer is SimpleProgramUnitBinder);\n                    container = outer.Compilation.GlobalNamespace;\n                } 267667"];
17065 [label="inContainerBinder.Container 267668"];
17066 [label="get\n            {\n                return _container;\n            } 267669"];
17067 [label="return _container; 267670"];
17068 [label="container = inContainerBinder.Container; 267671"];
17069 [label="NamespaceSymbol ns = ((NamespaceSymbol)container).GetNestedNamespace(name); 267672"];
17070 [label="((NamespaceSymbol)container).GetNestedNamespace(name) 267673"];
17071 [label="param GetNestedNamespace(NameSyntax name) 267674"];
17072 [label="param GetNestedNamespace(this) 267675"];
17073 [label="name.Kind() 267676"];
17074 [label="param Kind(this) 267677"];
17075 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName: // DeclarationTreeBuilder.VisitNamespace uses the PlainName, even for generic names\n                case SyntaxKind.IdentifierName:\n                    return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText);\n\n                case SyntaxKind.QualifiedName:\n                    var qn = (QualifiedNameSyntax)name;\n                    var leftNs = this.GetNestedNamespace(qn.Left);\n                    if ((object)leftNs != null)\n                    {\n                        return leftNs.GetNestedNamespace(qn.Right);\n                    }\n\n                    break;\n\n                case SyntaxKind.AliasQualifiedName:\n                    // This is an error scenario, but we should still handle it.\n                    // We recover in the same way as DeclarationTreeBuilder.VisitNamespaceDeclaration.\n                    return this.GetNestedNamespace(name.GetUnqualifiedName().Identifier.ValueText);\n            } 267678"];
17076 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 267679"];
17077 [label="((SimpleNameSyntax)name).Identifier 267680"];
17078 [label="=> true 267681"];
17079 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 267682"];
17080 [label="param GetValueText(this) 267683"];
17081 [label="param GetNestedNamespace(string name) 267684"];
17082 [label="param GetNestedNamespace(this) 267685"];
17083 [label="foreach (var sym in this.GetMembers(name))\n            {\n                if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                }\n            } 267686"];
17084 [label="this.GetMembers(name) 267687"];
17085 [label="param GetMembers(string name) 267688"];
17086 [label="param GetMembers(this) 267689"];
17087 [label="return _cachedLookup[name]; 267690"];
17088 [label="sym.Kind 267691"];
17089 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 267692"];
17090 [label="if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                } 267693"];
17091 [label="return (NamespaceSymbol)sym; 267694"];
17092 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 267695"];
17093 [label="if ((object)ns == null) return outer; 267696"];
17094 [label="if ((object)ns == null) return outer; 267697"];
17095 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 267698"];
17096 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 267699"];
17097 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 267700"];
17098 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 267701"];
17099 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 267702"];
17100 [label="new InContainerBinder(ns, outer, node, inUsing: inUsing) 267703"];
17101 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 267704"];
17102 [label="param InContainerBinder(Binder next) 267705"];
17103 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 267706"];
17104 [label="param InContainerBinder(bool inUsing) 267707"];
17105 [label="param InContainerBinder(this) 267708"];
17106 [label="param InContainerBinder(this) 267709"];
17107 [label="param Binder(this) 267710"];
17108 [label="param Binder(Conversions? conversions = null) 267711"];
17109 [label="RoslynDebug.Assert(next != null); 267712"];
17110 [label="RoslynDebug.Assert(next != null); 267713"];
17111 [label="this.Flags 267714"];
17112 [label="this.Compilation 267715"];
17113 [label="_lazyConversions 267716"];
17114 [label="_container 267717"];
17115 [label="_computeImports 267718"];
17116 [label="_lazyImports 267719"];
17117 [label="_lazyImportChain 267720"];
17118 [label="_lazyQuickAttributeChecker 267721"];
17119 [label="Debug.Assert((object)container != null); 267722"];
17120 [label="Debug.Assert((object)container != null); 267723"];
17121 [label="Debug.Assert(declarationSyntax != null); 267724"];
17122 [label="Debug.Assert(declarationSyntax != null); 267725"];
17123 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 267726"];
17124 [label="_computeImports 267727"];
17125 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 267728"];
17126 [label="declarationSyntax.Kind() 267729"];
17127 [label="param Kind(this) 267730"];
17128 [label="return (SyntaxKind)this.Green.RawKind; 267731"];
17129 [label="declarationSyntax.Kind() 267732"];
17130 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 267733"];
17131 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 267734"];
17132 [label="_usingsSyntax 267735"];
17133 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 267736"];
17134 [label="binderCache 267737"];
17135 [label="return _factory._binderCache; 267738"];
17136 [label="binderCache.TryAdd(key, result); 267739"];
17137 [label="binderCache.TryAdd(key, result); 267740"];
17138 [label="binderCache.TryAdd(key, result); 267741"];
17139 [label="binderCache.TryAdd(key, result); 267742"];
17140 [label="binderCache.TryAdd(key, result); 267743"];
17141 [label="return result; 267744"];
17142 [label="return ((CSharpSyntaxNode)node).Accept(this); 267745"];
17143 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 267746"];
17144 [label="resultBinder.ContainingMemberOrLambda 267747"];
17145 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 267748"];
17146 [label="var merged = _container as MergedNamespaceSymbol; 267749"];
17147 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 267750"];
17148 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 267751"];
17149 [label="((object)merged != null) 267752"];
17150 [label="_container 267753"];
17151 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 267754"];
17152 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 267755"];
17153 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 267756"];
17154 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 267757"];
17155 [label="param GetSourceTypeMember(this) 267758"];
17156 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 267759"];
17157 [label="syntax.Identifier 267760"];
17158 [label="=> true 267761"];
17159 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 267762"];
17160 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 267763"];
17161 [label="param GetValueText(this) 267764"];
17162 [label="get\n            {\n                return this.TypeParameterList == null ? 0 : this.TypeParameterList.Parameters.Count;\n            } 267765"];
17163 [label="syntax.Arity 267766"];
17164 [label="param Kind(this) 267767"];
17165 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 267768"];
17166 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 267769"];
17167 [label="param GetSourceTypeMember(string name) 267770"];
17168 [label="param GetSourceTypeMember(int arity) 267771"];
17169 [label="param GetSourceTypeMember(SyntaxKind kind) 267772"];
17170 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 267773"];
17171 [label="param GetSourceTypeMember(this) 267774"];
17172 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 267775"];
17173 [label="kind.ToDeclarationKind() 267776"];
17174 [label="param ToDeclarationKind(this SyntaxKind kind) 267777"];
17175 [label="switch (kind)\n            {\n                case SyntaxKind.ClassDeclaration: return DeclarationKind.Class;\n                case SyntaxKind.InterfaceDeclaration: return DeclarationKind.Interface;\n                case SyntaxKind.StructDeclaration: return DeclarationKind.Struct;\n                case SyntaxKind.NamespaceDeclaration: return DeclarationKind.Namespace;\n                case SyntaxKind.EnumDeclaration: return DeclarationKind.Enum;\n                case SyntaxKind.DelegateDeclaration: return DeclarationKind.Delegate;\n                case SyntaxKind.RecordDeclaration: return DeclarationKind.Record;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 267778"];
17176 [label="return DeclarationKind.Class; 267779"];
17177 [label="kind.ToDeclarationKind().ToTypeKind() 267780"];
17178 [label="param ToTypeKind(this DeclarationKind kind) 267781"];
17179 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 267782"];
17180 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 267783"];
17181 [label="GetTypeMembers(name, arity) 267784"];
17182 [label="param GetTypeMembers(string name) 267785"];
17183 [label="param GetTypeMembers(int arity) 267786"];
17184 [label="param GetTypeMembers(this) 267787"];
17185 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 267788"];
17186 [label="GetTypeMembers(name) 267789"];
17187 [label="param GetTypeMembers(string name) 267790"];
17188 [label="param GetTypeMembers(this) 267791"];
17189 [label="ImmutableArray<NamedTypeSymbol> members; 267792"];
17190 [label="members 267793"];
17191 [label="this.GetNameToTypeMembersMap() 267794"];
17192 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 267795"];
17193 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 267796"];
17194 [label="GetNameToMembersMap() 267797"];
17195 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 267798"];
17196 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 267799"];
17197 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 267800"];
17198 [label="bool hasType = false; 267801"];
17199 [label="bool hasNamespace = false; 267802"];
17200 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 267803"];
17201 [label="symbol.Kind 267804"];
17202 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 267805"];
17203 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 267806"];
17204 [label="hasType = true; 267807"];
17205 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 267808"];
17206 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 267809"];
17207 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 267810"];
17208 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 267811"];
17209 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 267812"];
17210 [label="bool hasType = false; 267813"];
17211 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 267814"];
17212 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 267815"];
17213 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267816"];
17214 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 267817"];
17215 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 267818"];
17216 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 267819"];
17217 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 267820"];
17218 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 267821"];
17219 [label="var memberT = member as SourceNamedTypeSymbol; 267822"];
17220 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 267823"];
17221 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 267824"];
17222 [label="memberT.TypeKind 267825"];
17223 [label="get\n            {\n                return _flags.TypeKind;\n            } 267826"];
17224 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 267827"];
17225 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 267828"];
17226 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 267829"];
17227 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 267830"];
17228 [label="memberT.Locations 267831"];
17229 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 267832"];
17230 [label="syntax.SyntaxTree 267833"];
17231 [label="Debug.Assert(result != null); 267834"];
17232 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 267835"];
17233 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 267836"];
17234 [label="syntax.Span 267837"];
17235 [label="param GetLeadingTriviaWidth(this) 267838"];
17236 [label="param GetTrailingTriviaWidth(this) 267839"];
17237 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 267840"];
17238 [label="return memberT; 267841"];
17239 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 267842"];
17240 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 267843"];
17241 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 267844"];
17242 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 267845"];
17243 [label="new WithClassTypeParametersBinder(typeSymbol, resultBinder) 267846"];
17244 [label="param WithClassTypeParametersBinder(NamedTypeSymbol container) 267847"];
17245 [label="param WithClassTypeParametersBinder(Binder next) 267848"];
17246 [label="param WithClassTypeParametersBinder(this) 267849"];
17247 [label="next 267850"];
17248 [label="param WithClassTypeParametersBinder(this) 267851"];
17249 [label="param WithTypeParametersBinder(Binder next) 267852"];
17250 [label="param WithTypeParametersBinder(this) 267853"];
17251 [label="next 267854"];
17252 [label="param WithTypeParametersBinder(this) 267855"];
17253 [label="param Binder(Binder next) 267856"];
17254 [label="param Binder(this) 267857"];
17255 [label="param Binder(Conversions? conversions = null) 267858"];
17256 [label="RoslynDebug.Assert(next != null); 267859"];
17257 [label="RoslynDebug.Assert(next != null); 267860"];
17258 [label="this.Flags 267861"];
17259 [label="this.Compilation 267862"];
17260 [label="_lazyConversions 267863"];
17261 [label="_namedType 267864"];
17262 [label="_lazyTypeParameterMap 267865"];
17263 [label="Debug.Assert((object)container != null); 267866"];
17264 [label="Debug.Assert((object)container != null); 267867"];
17265 [label="_namedType 267868"];
17266 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 267869"];
17267 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 267870"];
17268 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 267871"];
17269 [label="param WithUnsafeRegionIfNecessary(this) 267872"];
17270 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 267873"];
17271 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 267874"];
17272 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 267875"];
17273 [label="param Includes(this BinderFlags self) 267876"];
17274 [label="param Includes(BinderFlags other) 267877"];
17275 [label="return (self & other) == other; 267878"];
17276 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 267879"];
17277 [label="modifiers.Any(SyntaxKind.UnsafeKeyword) 267880"];
17278 [label="param Any(this SyntaxTokenList list) 267881"];
17279 [label="param Any(SyntaxKind kind) 267882"];
17280 [label="return list.IndexOf(kind) >= 0; 267883"];
17281 [label="return list.IndexOf(kind) >= 0; 267884"];
17282 [label="list.IndexOf(kind) 267885"];
17283 [label="param IndexOf(this SyntaxTokenList list) 267886"];
17284 [label="param IndexOf(SyntaxKind kind) 267887"];
17285 [label="return list.IndexOf((int)kind); 267888"];
17286 [label="return list.IndexOf((int)kind); 267889"];
17287 [label="return list.IndexOf(kind) >= 0; 267890"];
17288 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 267891"];
17289 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 267892"];
17290 [label="binderCache 267893"];
17291 [label="return _factory._binderCache; 267894"];
17292 [label="binderCache.TryAdd(key, resultBinder); 267895"];
17293 [label="binderCache.TryAdd(key, resultBinder); 267896"];
17294 [label="binderCache.TryAdd(key, resultBinder); 267897"];
17295 [label="binderCache.TryAdd(key, resultBinder); 267898"];
17296 [label="binderCache.TryAdd(key, resultBinder); 267899"];
17297 [label="return resultBinder; 267900"];
17298 [label="return ((CSharpSyntaxNode)node).Accept(this); 267901"];
17299 [label="_binderFactoryVisitorPool.Free(visitor); 267902"];
17300 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 267903"];
17301 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 267904"];
17302 [label="baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 267905"];
17303 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 267906"];
17304 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 267907"];
17305 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(this) 267908"];
17306 [label="Debug.Assert((object)containing != null); 267909"];
17307 [label="Debug.Assert((object)containing != null); 267910"];
17308 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 267911"];
17309 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 267912"];
17310 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 267913"];
17311 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 267914"];
17312 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 267915"];
17313 [label="param BinderWithContainingMemberOrLambda(Binder next) 267916"];
17314 [label="param BinderWithContainingMemberOrLambda(BinderFlags flags) 267917"];
17315 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 267918"];
17316 [label="param BinderWithContainingMemberOrLambda(this) 267919"];
17317 [label="next 267920"];
17318 [label="flags 267921"];
17319 [label="param BinderWithContainingMemberOrLambda(this) 267922"];
17320 [label="param Binder(Binder next) 267923"];
17321 [label="param Binder(BinderFlags flags) 267924"];
17322 [label="param Binder(this) 267925"];
17323 [label="internal CSharpCompilation Compilation { get; } 267926"];
17324 [label="Flags 267927"];
17325 [label="protected internal Binder? Next { get; } 267928"];
17326 [label="_lazyConversions 267929"];
17327 [label="_lazyOverloadResolution 267930"];
17328 [label="RoslynDebug.Assert(next != null); 267931"];
17329 [label="RoslynDebug.Assert(next != null); 267932"];
17330 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 267933"];
17331 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 267934"];
17332 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 267935"];
17333 [label="param Includes(this BinderFlags self) 267936"];
17334 [label="param Includes(BinderFlags other) 267937"];
17335 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 267938"];
17336 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 267939"];
17337 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 267940"];
17338 [label="param Includes(this BinderFlags self) 267941"];
17339 [label="param Includes(BinderFlags other) 267942"];
17340 [label="Next 267943"];
17341 [label="this.Flags 267944"];
17342 [label="this.Compilation 267945"];
17343 [label="_containingMemberOrLambda 267946"];
17344 [label="Debug.Assert(containingMemberOrLambda != null); 267947"];
17345 [label="containingMemberOrLambda != null 267948"];
17346 [label="param !=(Symbol left) 267949"];
17347 [label="param !=(Symbol right) 267950"];
17348 [label="if (right is null)\n            {\n                return left is object;\n            } 267951"];
17349 [label="return left is object; 267952"];
17350 [label="Debug.Assert(containingMemberOrLambda != null); 267953"];
17351 [label="_containingMemberOrLambda 267954"];
17352 [label="baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 267955"];
17353 [label="int i = -1; 267956"];
17354 [label="foreach (var baseTypeSyntax in bases.Types)\n            {\n                i++;\n                var typeSyntax = baseTypeSyntax.Type;\n                if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                }\n\n                var location = new SourceLocation(typeSyntax);\n\n                TypeSymbol baseType;\n\n                if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                }\n\n                switch (baseType.TypeKind)\n                {\n                    case TypeKind.Interface:\n                        foreach (var t in localInterfaces)\n                        {\n                            if (t.Equals(baseType, TypeCompareKind.ConsiderEverything))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateInterfaceInBaseList, location, baseType);\n                            }\n                            else if (t.Equals(baseType, TypeCompareKind.ObliviousNullableModifierMatchesAny))\n                            {\n                                // duplicates with ?/! differences are reported later, we report local differences between oblivious and ?/! here\n                                diagnostics.Add(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, location, baseType, this);\n                            }\n                        }\n\n                        if (this.IsStatic)\n                        {\n                            // '{0}': static classes cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_StaticClassInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (this.IsRefLikeType)\n                        {\n                            // '{0}': ref structs cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_RefStructInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (baseType.ContainsDynamic())\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromConstructedDynamic, location, this, baseType);\n                        }\n\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Class:\n                        if (TypeKind == TypeKind.Class)\n                        {\n                            if ((object)localBase == null)\n                            {\n                                localBase = (NamedTypeSymbol)baseType;\n                                diagnostics.Add(ErrorCode.ERR_BaseClassMustBeFirst, location, baseType);\n                                continue;\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NoMultipleInheritance, location, this, localBase, baseType);\n                                continue;\n                            }\n                        }\n                        goto default;\n\n                    case TypeKind.TypeParameter:\n                        diagnostics.Add(ErrorCode.ERR_DerivingFromATyVar, location, baseType);\n                        continue;\n\n                    case TypeKind.Error:\n                        // put the error type in the interface list so we don't lose track of it\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Dynamic:\n                        diagnostics.Add(ErrorCode.ERR_DeriveFromDynamic, location, this);\n                        continue;\n\n                    case TypeKind.Submission:\n                        throw ExceptionUtilities.UnexpectedValue(baseType.TypeKind);\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType);\n                        continue;\n                }\n            } 267957"];
17355 [label="bases.Types 267958"];
17356 [label="param CSharpSyntaxNode(GreenNode green) 267959"];
17357 [label="param CSharpSyntaxNode(SyntaxNode? parent) 267960"];
17358 [label="param CSharpSyntaxNode(int position) 267961"];
17359 [label="param CSharpSyntaxNode(this) 267962"];
17360 [label="i++; 267963"];
17361 [label="var typeSyntax = baseTypeSyntax.Type; 267964"];
17362 [label="baseTypeSyntax.Type 267965"];
17363 [label="param CSharpSyntaxNode(GreenNode green) 267966"];
17364 [label="param CSharpSyntaxNode(SyntaxNode? parent) 267967"];
17365 [label="param CSharpSyntaxNode(int position) 267968"];
17366 [label="param CSharpSyntaxNode(this) 267969"];
17367 [label="typeSyntax.Kind() 267970"];
17368 [label="param Kind(this) 267971"];
17369 [label="if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                } 267972"];
17370 [label="typeSyntax.Kind() 267973"];
17371 [label="param Kind(this) 267974"];
17372 [label="if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                } 267975"];
17373 [label="SyntaxFacts.IsName(typeSyntax.Kind()) 267976"];
17374 [label="param IsName(SyntaxKind kind) 267977"];
17375 [label="switch (kind)\n            {\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.QualifiedName:\n                case SyntaxKind.AliasQualifiedName:\n                    return true;\n                default:\n                    return false;\n            } 267978"];
17376 [label="return false; 267979"];
17377 [label="if (typeSyntax.Kind() != SyntaxKind.PredefinedType && !SyntaxFacts.IsName(typeSyntax.Kind()))\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation());\n                } 267980"];
17378 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 267981"];
17379 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 267982"];
17380 [label="typeSyntax.GetLocation() 267983"];
17381 [label="param GetLocation(this) 267984"];
17382 [label="return new SourceLocation(this); 267985"];
17383 [label="return new SourceLocation(this); 267986"];
17384 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 267987"];
17385 [label="SyntaxTree? tree = null; 267988"];
17386 [label="tree = node._syntaxTree; 267989"];
17387 [label="if (tree != null)\n                {\n                    break;\n                } 267990"];
17388 [label="if (tree != null)\n                {\n                    break;\n                } 267991"];
17389 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 267992"];
17390 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 267993"];
17391 [label="Debug.Assert(tree != null); 267994"];
17392 [label="Debug.Assert(tree != null); 267995"];
17393 [label="var existingTree = n._syntaxTree; 267996"];
17394 [label="if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    } 267997"];
17395 [label="if (existingTree != null)\n                    {\n                        Debug.Assert(existingTree == tree, 'how could this node belong to a different tree?');\n\n                        // yield the race\n                        break;\n                    } 267998"];
17396 [label="Debug.Assert(result != null); 267999"];
17397 [label="Debug.Assert(result != null); 268000"];
17398 [label="param GetLeadingTrivia(this) 268001"];
17399 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 268002"];
17400 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()) 268003"];
17401 [label="param Add(this DiagnosticBag diagnostics) 268004"];
17402 [label="param Add(ErrorCode code) 268005"];
17403 [label="param Add(Location location) 268006"];
17404 [label="var info = new CSDiagnosticInfo(code); 268007"];
17405 [label="var info = new CSDiagnosticInfo(code); 268008"];
17406 [label="new CSDiagnosticInfo(code) 268009"];
17407 [label="param CSDiagnosticInfo(ErrorCode code) 268010"];
17408 [label="param CSDiagnosticInfo(this) 268011"];
17409 [label="param DiagnosticInfoWithSymbols(this) 268012"];
17410 [label="param GetSeverity(this) 268013"];
17411 [label="Debug.Assert(code != ErrorCode.ERR_InternalError); 268014"];
17412 [label="var diag = new CSDiagnostic(info, location); 268015"];
17413 [label="var diag = new CSDiagnostic(info, location); 268016"];
17414 [label="var diag = new CSDiagnostic(info, location); 268017"];
17415 [label="new CSDiagnostic(info, location) 268018"];
17416 [label="param CSDiagnostic(DiagnosticInfo info) 268019"];
17417 [label="param CSDiagnostic(Location location) 268020"];
17418 [label="param CSDiagnostic(bool isSuppressed = false) 268021"];
17419 [label="param CSDiagnostic(this) 268022"];
17420 [label="info 268023"];
17421 [label="location 268024"];
17422 [label="isSuppressed 268025"];
17423 [label="param CSDiagnostic(this) 268026"];
17424 [label="param CSDiagnostic(this) 268027"];
17425 [label="diagnostics.Add(diag); 268028"];
17426 [label="diagnostics.Add(diag); 268029"];
17427 [label="return info; 268030"];
17428 [label="diagnostics.Add(ErrorCode.ERR_BadBaseType, typeSyntax.GetLocation()); 268031"];
17429 [label="var location = new SourceLocation(typeSyntax); 268032"];
17430 [label="var location = new SourceLocation(typeSyntax); 268033"];
17431 [label="var location = new SourceLocation(typeSyntax); 268034"];
17432 [label="Debug.Assert(result != null); 268035"];
17433 [label="Debug.Assert(result != null); 268036"];
17434 [label="param GetLeadingTrivia(this) 268037"];
17435 [label="TypeSymbol baseType; 268038"];
17436 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 268039"];
17437 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 268040"];
17438 [label="TypeKind 268041"];
17439 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 268042"];
17440 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 268043"];
17441 [label="if (i == 0 && TypeKind == TypeKind.Class) // allow class in the first position\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n\n                    SpecialType baseSpecialType = baseType.SpecialType;\n                    if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    }\n\n                    if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    }\n\n                    bool baseTypeIsErrorWithoutInterfaceGuess = false;\n\n                    // If baseType is an error symbol and our best guess is that the desired symbol\n                    // is an interface, then put baseType in the interfaces list, rather than the\n                    // base type slot, to avoid the frustrating scenario where an error message\n                    // indicates that the symbol being returned as the base type was elsewhere\n                    // interpreted as an interface.\n                    if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    }\n\n                    if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    }\n                }\n                else\n                {\n                    baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type;\n                } 268044"];
17442 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 268045"];
17443 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 268046"];
17444 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 268047"];
17445 [label="baseType = baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type; 268048"];
17446 [label="baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved) 268049"];
17447 [label="param BindType(ExpressionSyntax syntax) 268050"];
17448 [label="param BindType(DiagnosticBag diagnostics) 268051"];
17449 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 268052"];
17450 [label="param BindType(bool suppressUseSiteDiagnostics = false) 268053"];
17451 [label="param BindType(this) 268054"];
17452 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 268055"];
17453 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 268056"];
17454 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 268057"];
17455 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 268058"];
17456 [label="BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics) 268059"];
17457 [label="param BindTypeOrAlias(ExpressionSyntax syntax) 268060"];
17458 [label="param BindTypeOrAlias(DiagnosticBag diagnostics) 268061"];
17459 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 268062"];
17460 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 268063"];
17461 [label="param BindTypeOrAlias(this) 268064"];
17462 [label="Debug.Assert(diagnostics != null); 268065"];
17463 [label="Debug.Assert(diagnostics != null); 268066"];
17464 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 268067"];
17465 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 268068"];
17466 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 268069"];
17467 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 268070"];
17468 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 268071"];
17469 [label="BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics) 268072"];
17470 [label="param BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax) 268073"];
17471 [label="param BindNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 268074"];
17472 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 268075"];
17473 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 268076"];
17474 [label="param BindNamespaceOrTypeOrAliasSymbol(this) 268077"];
17475 [label="syntax.Kind() 268078"];
17476 [label="param Kind(this) 268079"];
17477 [label="switch (syntax.Kind())\n            {\n                case SyntaxKind.NullableType:\n                    return bindNullable(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.PredefinedType:\n                    return bindPredefined(syntax, diagnostics);\n\n                case SyntaxKind.IdentifierName:\n                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null);\n\n                case SyntaxKind.GenericName:\n                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt: null);\n\n                case SyntaxKind.AliasQualifiedName:\n                    return bindAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n\n                case SyntaxKind.QualifiedName:\n                    {\n                        var node = (QualifiedNameSyntax)syntax;\n                        return BindQualifiedName(node.Left, node.Right, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.SimpleMemberAccessExpression:\n                    {\n                        var node = (MemberAccessExpressionSyntax)syntax;\n                        return BindQualifiedName(node.Expression, node.Name, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.ArrayType:\n                    {\n                        return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true);\n                    }\n\n                case SyntaxKind.PointerType:\n                    return bindPointer(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.FunctionPointerType:\n                    var functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax;\n                    if (GetUnsafeDiagnosticInfo(sizeOfTypeOpt: null) is CSDiagnosticInfo info)\n                    {\n                        var @delegate = functionPointerTypeSyntax.DelegateKeyword;\n                        var asterisk = functionPointerTypeSyntax.AsteriskToken;\n                        RoslynDebug.Assert(@delegate.SyntaxTree is object);\n                        diagnostics.Add(info, Location.Create(@delegate.SyntaxTree, TextSpan.FromBounds(@delegate.SpanStart, asterisk.Span.End)));\n                    }\n\n                    return TypeWithAnnotations.Create(\n                        FunctionPointerTypeSymbol.CreateFromSource(\n                            functionPointerTypeSyntax,\n                            this,\n                            diagnostics,\n                            basesBeingResolved,\n                            suppressUseSiteDiagnostics));\n\n                case SyntaxKind.OmittedTypeArgument:\n                    {\n                        return BindTypeArgument((TypeSyntax)syntax, diagnostics, basesBeingResolved);\n                    }\n\n                case SyntaxKind.TupleType:\n                    {\n                        var tupleTypeSyntax = (TupleTypeSyntax)syntax;\n                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics, basesBeingResolved));\n                    }\n\n                case SyntaxKind.RefType:\n                    {\n                        // ref needs to be handled by the caller\n                        var refTypeSyntax = (RefTypeSyntax)syntax;\n                        var refToken = refTypeSyntax.RefKeyword;\n                        if (!syntax.HasErrors)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, refToken.GetLocation(), refToken.ToString());\n                        }\n\n                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                default:\n                    {\n                        // This is invalid syntax for a type.  This arises when a constant pattern that fails to bind\n                        // is attempted to be bound as a type pattern.\n                        return createErrorType(syntax);\n                    }\n            } 268080"];
17478 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 268081"];
17479 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 268082"];
17480 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 268083"];
17481 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 268084"];
17482 [label="BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true) 268085"];
17483 [label="param BindArrayType(ArrayTypeSyntax node) 268086"];
17484 [label="param BindArrayType(DiagnosticBag diagnostics) 268087"];
17485 [label="param BindArrayType(bool permitDimensions) 268088"];
17486 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 268089"];
17487 [label="param BindArrayType(bool disallowRestrictedTypes) 268090"];
17488 [label="param BindArrayType(this) 268091"];
17489 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 268092"];
17490 [label="node.ElementType 268093"];
17491 [label="param CSharpSyntaxNode(GreenNode green) 268094"];
17492 [label="param CSharpSyntaxNode(SyntaxNode? parent) 268095"];
17493 [label="param CSharpSyntaxNode(int position) 268096"];
17494 [label="param CSharpSyntaxNode(this) 268097"];
17495 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 268098"];
17496 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 268099"];
17497 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 268100"];
17498 [label="BindType(node.ElementType, diagnostics, basesBeingResolved) 268101"];
17499 [label="param BindType(ExpressionSyntax syntax) 268102"];
17500 [label="param BindType(DiagnosticBag diagnostics) 268103"];
17501 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 268104"];
17502 [label="param BindType(bool suppressUseSiteDiagnostics = false) 268105"];
17503 [label="param BindType(this) 268106"];
17504 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 268107"];
17505 [label="Debug.Assert(diagnostics != null); 268108"];
17506 [label="Debug.Assert(diagnostics != null); 268109"];
17507 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 268110"];
17508 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 268111"];
17509 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 268112"];
17510 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 268113"];
17511 [label="return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null); 268114"];
17512 [label="BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null) 268115"];
17513 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(IdentifierNameSyntax node) 268116"];
17514 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 268117"];
17515 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 268118"];
17516 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 268119"];
17517 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(NamespaceOrTypeSymbol qualifierOpt) 268120"];
17518 [label="param BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(this) 268121"];
17519 [label="var identifierValueText = node.Identifier.ValueText; 268122"];
17520 [label="node.Identifier 268123"];
17521 [label="=> true 268124"];
17522 [label="var identifierValueText = node.Identifier.ValueText; 268125"];
17523 [label="var identifierValueText = node.Identifier.ValueText; 268126"];
17524 [label="param GetValueText(this) 268127"];
17525 [label="if (string.IsNullOrWhiteSpace(identifierValueText))\n            {\n                return TypeWithAnnotations.Create(new ExtendedErrorTypeSymbol(\n                    Compilation.Assembly.GlobalNamespace, identifierValueText, 0,\n                    new CSDiagnosticInfo(ErrorCode.ERR_SingleTypeNameNotFound)));\n            } 268128"];
17526 [label="node.Parent 268129"];
17527 [label="get\n            {\n                return (CSharpSyntaxNode?)base.Parent;\n            } 268130"];
17528 [label="return (CSharpSyntaxNode?)base.Parent; 268131"];
17529 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268132"];
17530 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268133"];
17531 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268134"];
17532 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268135"];
17533 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268136"];
17534 [label="CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics) 268137"];
17535 [label="param CreateErrorIfLookupOnTypeParameter(CSharpSyntaxNode node) 268138"];
17536 [label="param CreateErrorIfLookupOnTypeParameter(NamespaceOrTypeSymbol qualifierOpt) 268139"];
17537 [label="param CreateErrorIfLookupOnTypeParameter(string name) 268140"];
17538 [label="param CreateErrorIfLookupOnTypeParameter(int arity) 268141"];
17539 [label="param CreateErrorIfLookupOnTypeParameter(DiagnosticBag diagnostics) 268142"];
17540 [label="param CreateErrorIfLookupOnTypeParameter(this) 268143"];
17541 [label="if (((object)qualifierOpt != null) && (qualifierOpt.Kind == SymbolKind.TypeParameter))\n            {\n                var diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_LookupInTypeVariable, qualifierOpt);\n                diagnostics.Add(diagnosticInfo, node.Location);\n                return new ExtendedErrorTypeSymbol(this.Compilation, name, arity, diagnosticInfo, unreported: false);\n            } 268144"];
17542 [label="if (((object)qualifierOpt != null) && (qualifierOpt.Kind == SymbolKind.TypeParameter))\n            {\n                var diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_LookupInTypeVariable, qualifierOpt);\n                diagnostics.Add(diagnosticInfo, node.Location);\n                return new ExtendedErrorTypeSymbol(this.Compilation, name, arity, diagnosticInfo, unreported: false);\n            } 268145"];
17543 [label="return null; 268146"];
17544 [label="var errorResult = CreateErrorIfLookupOnTypeParameter(node.Parent, qualifierOpt, identifierValueText, 0, diagnostics); 268147"];
17545 [label="if ((object)errorResult != null)\n            {\n                return TypeWithAnnotations.Create(errorResult);\n            } 268148"];
17546 [label="if ((object)errorResult != null)\n            {\n                return TypeWithAnnotations.Create(errorResult);\n            } 268149"];
17547 [label="CreatePool() 268150"];
17548 [label="ObjectPool<LookupResult> pool = null; 268151"];
17549 [label="pool = new ObjectPool<LookupResult>(() => new LookupResult(pool), 128); 268152"];
17550 [label="pool = new ObjectPool<LookupResult>(() => new LookupResult(pool), 128); 268153"];
17551 [label="return pool; 268154"];
17552 [label="s_poolInstance = CreatePool() 268155"];
17553 [label="LookupResult.GetInstance() 268156"];
17554 [label="var instance = s_poolInstance.Allocate(); 268157"];
17555 [label="var instance = s_poolInstance.Allocate(); 268158"];
17556 [label="var instance = s_poolInstance.Allocate(); 268159"];
17557 [label="param LookupResult(ObjectPool<LookupResult> pool) 268160"];
17558 [label="param LookupResult(this) 268161"];
17559 [label="_kind 268162"];
17560 [label="_symbolList 268163"];
17561 [label="_error 268164"];
17562 [label="_pool 268165"];
17563 [label="_pool 268166"];
17564 [label="_kind 268167"];
17565 [label="_symbolList = new ArrayBuilder<Symbol>(); 268168"];
17566 [label="_symbolList 268169"];
17567 [label="_error = null; 268170"];
17568 [label="_error 268171"];
17569 [label="var instance = s_poolInstance.Allocate(); 268172"];
17570 [label="instance.IsClear 268173"];
17571 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268174"];
17572 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268175"];
17573 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268176"];
17574 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268177"];
17575 [label="Debug.Assert(instance.IsClear); 268178"];
17576 [label="return instance; 268179"];
17577 [label="var result = LookupResult.GetInstance(); 268180"];
17578 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 268181"];
17579 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 268182"];
17580 [label="node.Identifier 268183"];
17581 [label="=> true 268184"];
17582 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 268185"];
17583 [label="LookupOptions options = GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()); 268186"];
17584 [label="node.Identifier.IsVerbatimIdentifier() 268187"];
17585 [label="param IsVerbatimIdentifier(this SyntaxToken token) 268188"];
17586 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268189"];
17587 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268190"];
17588 [label="token.IsKind(SyntaxKind.IdentifierToken) 268191"];
17589 [label="param IsKind(this SyntaxToken token) 268192"];
17590 [label="param IsKind(SyntaxKind kind) 268193"];
17591 [label="return token.RawKind == (int)kind; 268194"];
17592 [label="token.Text 268195"];
17593 [label="param ToString(this) 268196"];
17594 [label="this.Text 268197"];
17595 [label="get { return this.TextField; } 268198"];
17596 [label="return this.Text; 268199"];
17597 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268200"];
17598 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268201"];
17599 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268202"];
17600 [label="token.Text 268203"];
17601 [label="param ToString(this) 268204"];
17602 [label="this.Text 268205"];
17603 [label="return token.IsKind(SyntaxKind.IdentifierToken) && token.Text.Length > 0 && token.Text[0] == '@'; 268206"];
17604 [label="GetSimpleNameLookupOptions(node, node.Identifier.IsVerbatimIdentifier()) 268207"];
17605 [label="param GetSimpleNameLookupOptions(NameSyntax node) 268208"];
17606 [label="param GetSimpleNameLookupOptions(bool isVerbatimIdentifier) 268209"];
17607 [label="if (SyntaxFacts.IsAttributeName(node))\n            {\n                //  SPEC:   By convention, attribute classes are named with a suffix of Attribute.\n                //  SPEC:   An attribute-name of the form type-name may either include or omit this suffix.\n                //  SPEC:   If an attribute class is found both with and without this suffix, an ambiguity\n                //  SPEC:   is present, and a compile-time error results. If the attribute-name is spelled\n                //  SPEC:   such that its right-most identifier is a verbatim identifier (2.4.2), then only\n                //  SPEC:   an attribute without a suffix is matched, thus enabling such an ambiguity to be resolved.\n\n                return isVerbatimIdentifier ? LookupOptions.VerbatimNameAttributeTypeOnly : LookupOptions.AttributeTypeOnly;\n            }\n            else\n            {\n                return LookupOptions.NamespacesOrTypesOnly;\n            } 268210"];
17608 [label="SyntaxFacts.IsAttributeName(node) 268211"];
17609 [label="param IsAttributeName(SyntaxNode node) 268212"];
17610 [label="var parent = node.Parent; 268213"];
17611 [label="if (parent == null || !IsName(node.Kind()))\n            {\n                return false;\n            } 268214"];
17612 [label="if (parent == null || !IsName(node.Kind()))\n            {\n                return false;\n            } 268215"];
17613 [label="if (parent == null || !IsName(node.Kind()))\n            {\n                return false;\n            } 268216"];
17614 [label="node.Kind() 268217"];
17615 [label="param Kind(this SyntaxNode node) 268218"];
17616 [label="var rawKind = node.RawKind; 268219"];
17617 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 268220"];
17618 [label="IsCSharpKind(rawKind) 268221"];
17619 [label="param IsCSharpKind(int rawKind) 268222"];
17620 [label="IsName(node.Kind()) 268223"];
17621 [label="param IsName(SyntaxKind kind) 268224"];
17622 [label="return true; 268225"];
17623 [label="if (parent == null || !IsName(node.Kind()))\n            {\n                return false;\n            } 268226"];
17624 [label="switch (parent.Kind())\n            {\n                case QualifiedName:\n                    var qn = (QualifiedNameSyntax)parent;\n                    return qn.Right == node ? IsAttributeName(parent) : false;\n\n                case AliasQualifiedName:\n                    var an = (AliasQualifiedNameSyntax)parent;\n                    return an.Name == node ? IsAttributeName(parent) : false;\n            } 268227"];
17625 [label="parent.Kind() 268228"];
17626 [label="param Kind(this SyntaxNode node) 268229"];
17627 [label="var rawKind = node.RawKind; 268230"];
17628 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 268231"];
17629 [label="IsCSharpKind(rawKind) 268232"];
17630 [label="param IsCSharpKind(int rawKind) 268233"];
17631 [label="var p = node.Parent as AttributeSyntax; 268234"];
17632 [label="return p != null && p.Name == node; 268235"];
17633 [label="return p != null && p.Name == node; 268236"];
17634 [label="return LookupOptions.NamespacesOrTypesOnly; 268237"];
17635 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 268238"];
17636 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268239"];
17637 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268240"];
17638 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268241"];
17639 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268242"];
17640 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268243"];
17641 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268244"];
17642 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics); 268245"];
17643 [label="this.LookupSymbolsSimpleName(result, qualifierOpt, identifierValueText, 0, basesBeingResolved, options, diagnose: true, useSiteDiagnostics: ref useSiteDiagnostics) 268246"];
17644 [label="param LookupSymbolsSimpleName(LookupResult result) 268247"];
17645 [label="param LookupSymbolsSimpleName(NamespaceOrTypeSymbol qualifierOpt) 268248"];
17646 [label="param LookupSymbolsSimpleName(string plainName) 268249"];
17647 [label="param LookupSymbolsSimpleName(int arity) 268250"];
17648 [label="param LookupSymbolsSimpleName(ConsList<TypeSymbol> basesBeingResolved) 268251"];
17649 [label="param LookupSymbolsSimpleName(LookupOptions options) 268252"];
17650 [label="param LookupSymbolsSimpleName(bool diagnose) 268253"];
17651 [label="param LookupSymbolsSimpleName(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268254"];
17652 [label="param LookupSymbolsSimpleName(this) 268255"];
17653 [label="if (options.IsAttributeTypeLookup())\n            {\n                this.LookupAttributeType(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            } 268256"];
17654 [label="options.IsAttributeTypeLookup() 268257"];
17655 [label="param IsAttributeTypeLookup(this LookupOptions options) 268258"];
17656 [label="return (options & LookupOptions.AttributeTypeOnly) == LookupOptions.AttributeTypeOnly; 268259"];
17657 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268260"];
17658 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268261"];
17659 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268262"];
17660 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268263"];
17661 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268264"];
17662 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268265"];
17663 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268266"];
17664 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268267"];
17665 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics) 268268"];
17666 [label="param LookupSymbolsOrMembersInternal(LookupResult result) 268269"];
17667 [label="param LookupSymbolsOrMembersInternal(NamespaceOrTypeSymbol qualifierOpt) 268270"];
17668 [label="param LookupSymbolsOrMembersInternal(string name) 268271"];
17669 [label="param LookupSymbolsOrMembersInternal(int arity) 268272"];
17670 [label="param LookupSymbolsOrMembersInternal(ConsList<TypeSymbol> basesBeingResolved) 268273"];
17671 [label="param LookupSymbolsOrMembersInternal(LookupOptions options) 268274"];
17672 [label="param LookupSymbolsOrMembersInternal(bool diagnose) 268275"];
17673 [label="param LookupSymbolsOrMembersInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268276"];
17674 [label="param LookupSymbolsOrMembersInternal(this) 268277"];
17675 [label="if ((object)qualifierOpt == null)\n            {\n                this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n            } 268278"];
17676 [label="if ((object)qualifierOpt == null)\n            {\n                this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInternal(result, qualifierOpt, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n            } 268279"];
17677 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268280"];
17678 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268281"];
17679 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268282"];
17680 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268283"];
17681 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268284"];
17682 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268285"];
17683 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 268286"];
17684 [label="this.LookupSymbolsInternal(result, name, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics) 268287"];
17685 [label="param LookupSymbolsInternal(LookupResult result) 268288"];
17686 [label="param LookupSymbolsInternal(string name) 268289"];
17687 [label="param LookupSymbolsInternal(int arity) 268290"];
17688 [label="param LookupSymbolsInternal(ConsList<TypeSymbol> basesBeingResolved) 268291"];
17689 [label="param LookupSymbolsInternal(LookupOptions options) 268292"];
17690 [label="param LookupSymbolsInternal(bool diagnose) 268293"];
17691 [label="param LookupSymbolsInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268294"];
17692 [label="param LookupSymbolsInternal(this) 268295"];
17693 [label="result.IsClear 268296"];
17694 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268297"];
17695 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268298"];
17696 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268299"];
17697 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268300"];
17698 [label="Debug.Assert(result.IsClear); 268301"];
17699 [label="Debug.Assert(options.AreValid()); 268302"];
17700 [label="options.AreValid() 268303"];
17701 [label="param AreValid(this LookupOptions options) 268304"];
17702 [label="if (options == LookupOptions.Default)\n            {\n                return true;\n            } 268305"];
17703 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 268306"];
17704 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 268307"];
17705 [label="LookupOptions mustBeAndNotBeInstance = (LookupOptions.MustBeInstance | LookupOptions.MustNotBeInstance); 268308"];
17706 [label="if ((options & mustBeAndNotBeInstance) == mustBeAndNotBeInstance)\n            {\n                return false;\n            } 268309"];
17707 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268310"];
17708 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268311"];
17709 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268312"];
17710 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 268313"];
17711 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 268314"];
17712 [label="return OnlyOneBitSet(onlyOptions); 268315"];
17713 [label="OnlyOneBitSet(onlyOptions) 268316"];
17714 [label="param OnlyOneBitSet(LookupOptions o) 268317"];
17715 [label="return (o & (o - 1)) == 0; 268318"];
17716 [label="return (o & (o - 1)) == 0; 268319"];
17717 [label="Binder binder = null; 268320"];
17718 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 268321"];
17719 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 268322"];
17720 [label="result.IsMultiViable 268323"];
17721 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 268324"];
17722 [label="Kind 268325"];
17723 [label="get\n            {\n                return _kind;\n            } 268326"];
17724 [label="return _kind; 268327"];
17725 [label="return Kind == LookupResultKind.Viable; 268328"];
17726 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 268329"];
17727 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 268330"];
17728 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 268331"];
17729 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 268332"];
17730 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268333"];
17731 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268334"];
17732 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268335"];
17733 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268336"];
17734 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268337"];
17735 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268338"];
17736 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268339"];
17737 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268340"];
17738 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics) 268341"];
17739 [label="param LookupSymbolsInSingleBinder(LookupResult result) 268342"];
17740 [label="param LookupSymbolsInSingleBinder(string name) 268343"];
17741 [label="param LookupSymbolsInSingleBinder(int arity) 268344"];
17742 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 268345"];
17743 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 268346"];
17744 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 268347"];
17745 [label="param LookupSymbolsInSingleBinder(bool diagnose) 268348"];
17746 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268349"];
17747 [label="param LookupSymbolsInSingleBinder(this) 268350"];
17748 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268351"];
17749 [label="result.IsClear 268352"];
17750 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268353"];
17751 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268354"];
17752 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268355"];
17753 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268356"];
17754 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 268357"];
17755 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 268358"];
17756 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 268359"];
17757 [label="for (var scope = this; scope != null && !result.IsMultiViable; scope = scope.Next)\n            {\n                if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                }\n\n                if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                }\n            } 268360"];
17758 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 268361"];
17759 [label="if (binder != null)\n                {\n                    var tmp = LookupResult.GetInstance();\n                    scope.LookupSymbolsInSingleBinder(tmp, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    result.MergeEqual(tmp);\n                    tmp.Free();\n                }\n                else\n                {\n                    scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics);\n                    if (!result.IsClear)\n                    {\n                        binder = scope;\n                    }\n                } 268362"];
17760 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268363"];
17761 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268364"];
17762 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268365"];
17763 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268366"];
17764 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268367"];
17765 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268368"];
17766 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268369"];
17767 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268370"];
17768 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics) 268371"];
17769 [label="param LookupSymbolsInSingleBinder(LookupResult result) 268372"];
17770 [label="param LookupSymbolsInSingleBinder(string name) 268373"];
17771 [label="param LookupSymbolsInSingleBinder(int arity) 268374"];
17772 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 268375"];
17773 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 268376"];
17774 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 268377"];
17775 [label="param LookupSymbolsInSingleBinder(bool diagnose) 268378"];
17776 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268379"];
17777 [label="param LookupSymbolsInSingleBinder(this) 268380"];
17778 [label="result.IsClear 268381"];
17779 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268382"];
17780 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268383"];
17781 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268384"];
17782 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268385"];
17783 [label="Debug.Assert(result.IsClear); 268386"];
17784 [label="LookupMask 268387"];
17785 [label="get\n            {\n                return LookupOptions.NamespaceAliasesOnly | LookupOptions.MustBeInvocableIfMember;\n            } 268388"];
17786 [label="return LookupOptions.NamespaceAliasesOnly | LookupOptions.MustBeInvocableIfMember; 268389"];
17787 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 268390"];
17788 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 268391"];
17789 [label="if ((options & LookupMask) != 0)\n            {\n                return;\n            } 268392"];
17790 [label="TypeParameterMap 268393"];
17791 [label="get\n            {\n                if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                }\n                return _lazyTypeParameterMap;\n            } 268394"];
17792 [label="if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                } 268395"];
17793 [label="if (_lazyTypeParameterMap == null)\n                {\n                    var result = new MultiDictionary<string, TypeParameterSymbol>();\n                    foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    }\n                    Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null);\n                } 268396"];
17794 [label="var result = new MultiDictionary<string, TypeParameterSymbol>(); 268397"];
17795 [label="_namedType.TypeParameters 268398"];
17796 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 268399"];
17797 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 268400"];
17798 [label="var diagnostics = DiagnosticBag.GetInstance(); 268401"];
17799 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 268402"];
17800 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 268403"];
17801 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 268404"];
17802 [label="AddDeclarationDiagnostics(diagnostics); 268405"];
17803 [label="AddDeclarationDiagnostics(diagnostics) 268406"];
17804 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 268407"];
17805 [label="param AddDeclarationDiagnostics(this) 268408"];
17806 [label="ContainingSymbol 268409"];
17807 [label="get\n            {\n                return _containingSymbol;\n            } 268410"];
17808 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 268411"];
17809 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 268412"];
17810 [label="AddDeclarationDiagnostics(diagnostics); 268413"];
17811 [label="diagnostics.Free(); 268414"];
17812 [label="return _lazyTypeParameters; 268415"];
17813 [label="foreach (TypeParameterSymbol tps in _namedType.TypeParameters)\n                    {\n                        result.Add(tps.Name, tps);\n                    } 268416"];
17814 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 268417"];
17815 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 268418"];
17816 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 268419"];
17817 [label="Interlocked.CompareExchange(ref _lazyTypeParameterMap, result, null); 268420"];
17818 [label="return _lazyTypeParameterMap; 268421"];
17819 [label="foreach (var typeParameter in TypeParameterMap[name])\n            {\n                result.MergeEqual(originalBinder.CheckViability(typeParameter, arity, options, null, diagnose, ref useSiteDiagnostics));\n            } 268422"];
17820 [label="foreach (var typeParameter in TypeParameterMap[name])\n            {\n                result.MergeEqual(originalBinder.CheckViability(typeParameter, arity, options, null, diagnose, ref useSiteDiagnostics));\n            } 268423"];
17821 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268424"];
17822 [label="result.IsClear 268425"];
17823 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268426"];
17824 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268427"];
17825 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268428"];
17826 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268429"];
17827 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 268430"];
17828 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 268431"];
17829 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 268432"];
17830 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268433"];
17831 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268434"];
17832 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268435"];
17833 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268436"];
17834 [label="scope.LookupSymbolsInSingleBinder(result, name, arity, basesBeingResolved, options, this, diagnose, ref useSiteDiagnostics); 268437"];
17835 [label="param LookupSymbolsInSingleBinder(LookupResult result) 268438"];
17836 [label="param LookupSymbolsInSingleBinder(string name) 268439"];
17837 [label="param LookupSymbolsInSingleBinder(int arity) 268440"];
17838 [label="param LookupSymbolsInSingleBinder(ConsList<TypeSymbol> basesBeingResolved) 268441"];
17839 [label="param LookupSymbolsInSingleBinder(LookupOptions options) 268442"];
17840 [label="param LookupSymbolsInSingleBinder(Binder originalBinder) 268443"];
17841 [label="param LookupSymbolsInSingleBinder(bool diagnose) 268444"];
17842 [label="param LookupSymbolsInSingleBinder(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268445"];
17843 [label="param LookupSymbolsInSingleBinder(this) 268446"];
17844 [label="result.IsClear 268447"];
17845 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 268448"];
17846 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268449"];
17847 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268450"];
17848 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 268451"];
17849 [label="Debug.Assert(result.IsClear); 268452"];
17850 [label="IsSubmissionClass 268453"];
17851 [label="get { return (_container?.Kind == SymbolKind.NamedType) && ((NamedTypeSymbol)_container).IsSubmissionClass; } 268454"];
17852 [label=".Kind 268455"];
17853 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 268456"];
17854 [label="return (_container?.Kind == SymbolKind.NamedType) && ((NamedTypeSymbol)_container).IsSubmissionClass; 268457"];
17855 [label="if (IsSubmissionClass)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n                return;\n            } 268458"];
17856 [label="var imports = GetImports(basesBeingResolved); 268459"];
17857 [label="GetImports(basesBeingResolved) 268460"];
17858 [label="param GetImports(ConsList<TypeSymbol> basesBeingResolved) 268461"];
17859 [label="param GetImports(this) 268462"];
17860 [label="Debug.Assert(_lazyImports != null || _computeImports != null, 'Have neither imports nor a way to compute them.'); 268463"];
17861 [label="Debug.Assert(_lazyImports != null || _computeImports != null, 'Have neither imports nor a way to compute them.'); 268464"];
17862 [label="if (_lazyImports == null)\n            {\n                Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null);\n            } 268465"];
17863 [label="if (_lazyImports == null)\n            {\n                Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null);\n            } 268466"];
17864 [label="null 268467"];
17865 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 268468"];
17866 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 268469"];
17867 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 268470"];
17868 [label="null 268471"];
17869 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 268472"];
17870 [label="param Imports(CSharpCompilation compilation) 268473"];
17871 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 268474"];
17872 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 268475"];
17873 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 268476"];
17874 [label="param Imports(DiagnosticBag diagnostics) 268477"];
17875 [label="param Imports(this) 268478"];
17876 [label="_compilation 268479"];
17877 [label="_diagnostics 268480"];
17878 [label="UsingAliases 268481"];
17879 [label="Debug.Assert(usingAliases != null); 268482"];
17880 [label="Debug.Assert(usingAliases != null); 268483"];
17881 [label="Debug.Assert(!usings.IsDefault); 268484"];
17882 [label="Debug.Assert(!externs.IsDefault); 268485"];
17883 [label="_compilation 268486"];
17884 [label="this.UsingAliases 268487"];
17885 [label="this.Usings 268488"];
17886 [label="_diagnostics 268489"];
17887 [label="this.ExternAliases 268490"];
17888 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 268491"];
17889 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 268492"];
17890 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 268493"];
17891 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 268494"];
17892 [label="param FromSyntax(CSharpSyntaxNode declarationSyntax) 268495"];
17893 [label="param FromSyntax(InContainerBinder binder) 268496"];
17894 [label="param FromSyntax(ConsList<TypeSymbol> basesBeingResolved) 268497"];
17895 [label="param FromSyntax(bool inUsing) 268498"];
17896 [label="SyntaxList<UsingDirectiveSyntax> usingDirectives; 268499"];
17897 [label="usingDirectives 268500"];
17898 [label="SyntaxList<ExternAliasDirectiveSyntax> externAliasDirectives; 268501"];
17899 [label="externAliasDirectives 268502"];
17900 [label="declarationSyntax.Kind() 268503"];
17901 [label="param Kind(this) 268504"];
17902 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n            {\n                var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : compilationUnit.Usings;\n                externAliasDirectives = compilationUnit.Externs;\n            }\n            else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n            {\n                var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings;\n                externAliasDirectives = namespaceDecl.Externs;\n            }\n            else\n            {\n                return Empty;\n            } 268505"];
17903 [label="declarationSyntax.Kind() 268506"];
17904 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n            {\n                var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                // using directives are not in scope within using directives\n                usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings;\n                externAliasDirectives = namespaceDecl.Externs;\n            }\n            else\n            {\n                return Empty;\n            } 268507"];
17905 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 268508"];
17906 [label="inUsing 268509"];
17907 [label="namespaceDecl.Usings 268510"];
17908 [label="usingDirectives = inUsing ? default(SyntaxList<UsingDirectiveSyntax>) : namespaceDecl.Usings; 268511"];
17909 [label="externAliasDirectives = namespaceDecl.Externs; 268512"];
17910 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 268513"];
17911 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 268514"];
17912 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 268515"];
17913 [label="if (usingDirectives.Count == 0 && externAliasDirectives.Count == 0)\n            {\n                return Empty;\n            } 268516"];
17914 [label="return Empty; 268517"];
17915 [label="Interlocked.CompareExchange(ref _lazyImports, _computeImports(basesBeingResolved), null); 268518"];
17916 [label="return _lazyImports; 268519"];
17917 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 268520"];
17918 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 268521"];
17919 [label="_container != null 268522"];
17920 [label="param !=(Symbol left) 268523"];
17921 [label="param !=(Symbol right) 268524"];
17922 [label="if (right is null)\n            {\n                return left is object;\n            } 268525"];
17923 [label="return left is object; 268526"];
17924 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 268527"];
17925 [label="if ((options & LookupOptions.NamespaceAliasesOnly) == 0 && _container != null)\n            {\n                this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n\n                if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                }\n            } 268528"];
17926 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268529"];
17927 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268530"];
17928 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268531"];
17929 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268532"];
17930 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268533"];
17931 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268534"];
17932 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268535"];
17933 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268536"];
17934 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268537"];
17935 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics) 268538"];
17936 [label="param LookupMembersInternal(LookupResult result) 268539"];
17937 [label="param LookupMembersInternal(NamespaceOrTypeSymbol nsOrType) 268540"];
17938 [label="param LookupMembersInternal(string name) 268541"];
17939 [label="param LookupMembersInternal(int arity) 268542"];
17940 [label="param LookupMembersInternal(ConsList<TypeSymbol> basesBeingResolved) 268543"];
17941 [label="param LookupMembersInternal(LookupOptions options) 268544"];
17942 [label="param LookupMembersInternal(Binder originalBinder) 268545"];
17943 [label="param LookupMembersInternal(bool diagnose) 268546"];
17944 [label="param LookupMembersInternal(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268547"];
17945 [label="param LookupMembersInternal(this) 268548"];
17946 [label="Debug.Assert(options.AreValid()); 268549"];
17947 [label="options.AreValid() 268550"];
17948 [label="param AreValid(this LookupOptions options) 268551"];
17949 [label="if (options == LookupOptions.Default)\n            {\n                return true;\n            } 268552"];
17950 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 268553"];
17951 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return options == LookupOptions.LabelsOnly;\n            } 268554"];
17952 [label="LookupOptions mustBeAndNotBeInstance = (LookupOptions.MustBeInstance | LookupOptions.MustNotBeInstance); 268555"];
17953 [label="if ((options & mustBeAndNotBeInstance) == mustBeAndNotBeInstance)\n            {\n                return false;\n            } 268556"];
17954 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268557"];
17955 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268558"];
17956 [label="if ((options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustNotBeMethodTypeParameter)) != 0 &&\n                (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) != 0)\n            {\n                return false;\n            } 268559"];
17957 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 268560"];
17958 [label="LookupOptions onlyOptions = options &\n                (LookupOptions.NamespaceAliasesOnly\n                 | LookupOptions.NamespacesOrTypesOnly\n                 | LookupOptions.AllMethodsOnArityZero); 268561"];
17959 [label="return OnlyOneBitSet(onlyOptions); 268562"];
17960 [label="OnlyOneBitSet(onlyOptions) 268563"];
17961 [label="param OnlyOneBitSet(LookupOptions o) 268564"];
17962 [label="return (o & (o - 1)) == 0; 268565"];
17963 [label="return (o & (o - 1)) == 0; 268566"];
17964 [label="Debug.Assert(arity >= 0); 268567"];
17965 [label="Debug.Assert(arity >= 0); 268568"];
17966 [label="nsOrType.IsNamespace 268569"];
17967 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 268570"];
17968 [label="Kind 268571"];
17969 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 268572"];
17970 [label="return Kind == SymbolKind.Namespace; 268573"];
17971 [label="if (nsOrType.IsNamespace)\n            {\n                LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics);\n            }\n            else\n            {\n                this.LookupMembersInType(result, (TypeSymbol)nsOrType, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics);\n            } 268574"];
17972 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268575"];
17973 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268576"];
17974 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268577"];
17975 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268578"];
17976 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268579"];
17977 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268580"];
17978 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268581"];
17979 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268582"];
17980 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics) 268583"];
17981 [label="param LookupMembersInNamespace(LookupResult result) 268584"];
17982 [label="param LookupMembersInNamespace(NamespaceSymbol ns) 268585"];
17983 [label="param LookupMembersInNamespace(string name) 268586"];
17984 [label="param LookupMembersInNamespace(int arity) 268587"];
17985 [label="param LookupMembersInNamespace(LookupOptions options) 268588"];
17986 [label="param LookupMembersInNamespace(Binder originalBinder) 268589"];
17987 [label="param LookupMembersInNamespace(bool diagnose) 268590"];
17988 [label="param LookupMembersInNamespace(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268591"];
17989 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 268592"];
17990 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 268593"];
17991 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 268594"];
17992 [label="var members = GetCandidateMembers(ns, name, options, originalBinder); 268595"];
17993 [label="GetCandidateMembers(ns, name, options, originalBinder) 268596"];
17994 [label="param GetCandidateMembers(NamespaceOrTypeSymbol nsOrType) 268597"];
17995 [label="param GetCandidateMembers(string name) 268598"];
17996 [label="param GetCandidateMembers(LookupOptions options) 268599"];
17997 [label="param GetCandidateMembers(Binder originalBinder) 268600"];
17998 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268601"];
17999 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268602"];
18000 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && nsOrType is TypeSymbol)\n            {\n                return nsOrType.GetTypeMembers(name).Cast<NamedTypeSymbol, Symbol>();\n            }\n            else if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268603"];
18001 [label="nsOrType.Kind 268604"];
18002 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 268605"];
18003 [label="if (nsOrType.Kind == SymbolKind.NamedType && originalBinder.IsEarlyAttributeBinder)\n            {\n                return ((NamedTypeSymbol)nsOrType).GetEarlyAttributeDecodingMembers(name);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268606"];
18004 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268607"];
18005 [label="if ((options & LookupOptions.LabelsOnly) != 0)\n            {\n                return ImmutableArray<Symbol>.Empty;\n            }\n            else\n            {\n                return nsOrType.GetMembers(name);\n            } 268608"];
18006 [label="return nsOrType.GetMembers(name); 268609"];
18007 [label="nsOrType.GetMembers(name) 268610"];
18008 [label="param GetMembers(string name) 268611"];
18009 [label="foreach (Symbol member in members)\n            {\n                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics);\n                result.MergeEqual(resultOfThisMember);\n            } 268612"];
18010 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 268613"];
18011 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 268614"];
18012 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 268615"];
18013 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 268616"];
18014 [label="SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics); 268617"];
18015 [label="originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics) 268618"];
18016 [label="param CheckViability(Symbol symbol) 268619"];
18017 [label="param CheckViability(int arity) 268620"];
18018 [label="param CheckViability(LookupOptions options) 268621"];
18019 [label="param CheckViability(TypeSymbol accessThroughType) 268622"];
18020 [label="param CheckViability(bool diagnose) 268623"];
18021 [label="param CheckViability(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268624"];
18022 [label="param CheckViability(ConsList<TypeSymbol> basesBeingResolved = null) 268625"];
18023 [label="param CheckViability(this) 268626"];
18024 [label="bool inaccessibleViaQualifier; 268627"];
18025 [label="DiagnosticInfo diagInfo; 268628"];
18026 [label="symbol.Kind 268629"];
18027 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268630"];
18028 [label="var unwrappedSymbol = symbol.Kind == SymbolKind.Alias\n                ? ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved)\n                : symbol; 268631"];
18029 [label="symbol.Kind == SymbolKind.Alias 268632"];
18030 [label="var unwrappedSymbol = symbol.Kind == SymbolKind.Alias\n                ? ((AliasSymbol)symbol).GetAliasTarget(basesBeingResolved)\n                : symbol; 268633"];
18031 [label="this.Compilation.SourceModule 268634"];
18032 [label="get\n            {\n                return Assembly.Modules[0];\n            } 268635"];
18033 [label="GetBoundReferenceManager(); 268636"];
18034 [label="if (!this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) && unwrappedSymbol.IsHiddenByCodeAnalysisEmbeddedAttribute())\n            {\n                return LookupResult.Empty();\n            }\n            else if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268637"];
18035 [label="unwrappedSymbol.ContainingModule 268638"];
18036 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 268639"];
18037 [label="return _containingSymbol; 268640"];
18038 [label="if (!this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) && unwrappedSymbol.IsHiddenByCodeAnalysisEmbeddedAttribute())\n            {\n                return LookupResult.Empty();\n            }\n            else if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268641"];
18039 [label="this.Compilation.SourceModule.Equals(unwrappedSymbol.ContainingModule) 268642"];
18040 [label="param Equals(object obj) 268643"];
18041 [label="param Equals(this) 268644"];
18042 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 268645"];
18043 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 268646"];
18044 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 268647"];
18045 [label="param Equals(Symbol other) 268648"];
18046 [label="param Equals(TypeCompareKind compareKind) 268649"];
18047 [label="param Equals(this) 268650"];
18048 [label="return (object)this == other; 268651"];
18049 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268652"];
18050 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268653"];
18051 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268654"];
18052 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268655"];
18053 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268656"];
18054 [label="WrongArity(symbol, arity, diagnose, options, out diagInfo) 268657"];
18055 [label="param WrongArity(Symbol symbol) 268658"];
18056 [label="param WrongArity(int arity) 268659"];
18057 [label="param WrongArity(bool diagnose) 268660"];
18058 [label="param WrongArity(LookupOptions options) 268661"];
18059 [label="param WrongArity(out DiagnosticInfo diagInfo) 268662"];
18060 [label="symbol.Kind 268663"];
18061 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268664"];
18062 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                    if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    }\n                    break;\n\n                case SymbolKind.Method:\n                    if (arity != 0 || (options & LookupOptions.AllMethodsOnArityZero) == 0)\n                    {\n                        MethodSymbol method = (MethodSymbol)symbol;\n                        if (method.Arity != arity)\n                        {\n                            if (method.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, method, MessageID.IDS_SK_METHOD.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, method, MessageID.IDS_SK_METHOD.Localize(), method.Arity) : null;\n                            }\n                            return true;\n                        }\n                    }\n                    break;\n\n                default:\n                    if (arity != 0)\n                    {\n                        diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_TypeArgsNotAllowed, symbol, symbol.Kind.Localize()) : null;\n                        return true;\n                    }\n                    break;\n            } 268665"];
18063 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 268666"];
18064 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 268667"];
18065 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 268668"];
18066 [label="if (arity != 0 || (options & LookupOptions.AllNamedTypesOnArityZero) == 0)\n                    {\n                        NamedTypeSymbol namedType = (NamedTypeSymbol)symbol;\n                        // non-declared types only appear as using aliases (aliases are arity 0)\n                        Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType));\n                        if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        }\n                    } 268669"];
18067 [label="NamedTypeSymbol namedType = (NamedTypeSymbol)symbol; 268670"];
18068 [label="namedType.ConstructedFrom 268671"];
18069 [label="get { return this; } 268672"];
18070 [label="return this; 268673"];
18071 [label="Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType)); 268674"];
18072 [label="Debug.Assert(object.ReferenceEquals(namedType.ConstructedFrom, namedType)); 268675"];
18073 [label="namedType.Arity 268676"];
18074 [label="get\n            {\n                return declaration.Arity;\n            } 268677"];
18075 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 268678"];
18076 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 268679"];
18077 [label="options.IsAttributeTypeLookup() 268680"];
18078 [label="param IsAttributeTypeLookup(this LookupOptions options) 268681"];
18079 [label="if (namedType.Arity != arity || options.IsAttributeTypeLookup() && arity != 0)\n                        {\n                            if (namedType.Arity == 0)\n                            {\n                                // The non-generic {1} '{0}' cannot be used with type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars, namedType, MessageID.IDS_SK_TYPE.Localize()) : null;\n                            }\n                            else\n                            {\n                                // Using the generic {1} '{0}' requires {2} type arguments\n                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity, namedType, MessageID.IDS_SK_TYPE.Localize(), namedType.Arity) : null;\n                            }\n                            return true;\n                        } 268682"];
18080 [label="diagInfo = null; 268683"];
18081 [label="return false; 268684"];
18082 [label="if (WrongArity(symbol, arity, diagnose, options, out diagInfo))\n            {\n                return LookupResult.WrongArity(symbol, diagInfo);\n            }\n            else if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268685"];
18083 [label="InCref 268686"];
18084 [label="get { return this.Flags.Includes(BinderFlags.Cref); } 268687"];
18085 [label="return this.Flags.Includes(BinderFlags.Cref); 268688"];
18086 [label="return this.Flags.Includes(BinderFlags.Cref); 268689"];
18087 [label="this.Flags.Includes(BinderFlags.Cref) 268690"];
18088 [label="param Includes(this BinderFlags self) 268691"];
18089 [label="param Includes(BinderFlags other) 268692"];
18090 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268693"];
18091 [label="unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters 268694"];
18092 [label="get\n            {\n                if (this.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)this;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Ordinary:\n                        case MethodKind.LocalFunction:\n                        case MethodKind.DelegateInvoke:\n                        case MethodKind.Destructor: // See comment in CanBeReferencedByName.\n                            return true;\n                        case MethodKind.PropertyGet:\n                        case MethodKind.PropertySet:\n                            return ((PropertySymbol)method.AssociatedSymbol).CanCallMethodsDirectly();\n                        default:\n                            return false;\n                    }\n                }\n                return true;\n            } 268695"];
18093 [label="this.Kind 268696"];
18094 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268697"];
18095 [label="if (this.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)this;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Ordinary:\n                        case MethodKind.LocalFunction:\n                        case MethodKind.DelegateInvoke:\n                        case MethodKind.Destructor: // See comment in CanBeReferencedByName.\n                            return true;\n                        case MethodKind.PropertyGet:\n                        case MethodKind.PropertySet:\n                            return ((PropertySymbol)method.AssociatedSymbol).CanCallMethodsDirectly();\n                        default:\n                            return false;\n                    }\n                } 268698"];
18096 [label="return true; 268699"];
18097 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268700"];
18098 [label="if (!InCref && !unwrappedSymbol.CanBeReferencedByNameIgnoringIllegalCharacters)\n            {\n                // Strictly speaking, this test should actually check CanBeReferencedByName.\n                // However, we don't want to pay that cost in cases where the lookup is based\n                // on a provided name.  As a result, we skip the character check here and let\n                // SemanticModel.LookupNames filter out invalid names before returning.\n\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_CantCallSpecialMethod, unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268701"];
18099 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268702"];
18100 [label="if ((options & LookupOptions.NamespacesOrTypesOnly) != 0 && !(unwrappedSymbol is NamespaceOrTypeSymbol))\n            {\n                return LookupResult.NotTypeOrNamespace(unwrappedSymbol, symbol, diagnose);\n            }\n            else if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268703"];
18101 [label="if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268704"];
18102 [label="if ((options & LookupOptions.MustBeInvocableIfMember) != 0\n                && IsNonInvocableMember(unwrappedSymbol))\n            {\n                return LookupResult.NotInvocable(unwrappedSymbol, symbol, diagnose);\n            }\n            else if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268705"];
18103 [label="InCref 268706"];
18104 [label="if (InCref && !this.IsCrefAccessible(unwrappedSymbol))\n            {\n                var unwrappedSymbols = ImmutableArray.Create<Symbol>(unwrappedSymbol);\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, unwrappedSymbols, additionalLocations: ImmutableArray<Location>.Empty) : null;\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268707"];
18105 [label="InCref 268708"];
18106 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268709"];
18107 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268710"];
18108 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268711"];
18109 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268712"];
18110 [label="RefineAccessThroughType(options, accessThroughType) 268713"];
18111 [label="param RefineAccessThroughType(LookupOptions options) 268714"];
18112 [label="param RefineAccessThroughType(TypeSymbol accessThroughType) 268715"];
18113 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 268716"];
18114 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 268717"];
18115 [label="((options & LookupOptions.UseBaseReferenceAccessibility) != 0) 268718"];
18116 [label="return ((options & LookupOptions.UseBaseReferenceAccessibility) != 0)\n                ? null\n                : accessThroughType; 268719"];
18117 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268720"];
18118 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268721"];
18119 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268722"];
18120 [label="this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved) 268723"];
18121 [label="param IsAccessible(Symbol symbol) 268724"];
18122 [label="param IsAccessible(TypeSymbol accessThroughType) 268725"];
18123 [label="param IsAccessible(out bool failedThroughTypeCheck) 268726"];
18124 [label="param IsAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268727"];
18125 [label="param IsAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 268728"];
18126 [label="param IsAccessible(this) 268729"];
18127 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 268730"];
18128 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 268731"];
18129 [label="this.Flags.Includes(BinderFlags.IgnoreAccessibility) 268732"];
18130 [label="param Includes(this BinderFlags self) 268733"];
18131 [label="param Includes(BinderFlags other) 268734"];
18132 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268735"];
18133 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268736"];
18134 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268737"];
18135 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268738"];
18136 [label="return IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268739"];
18137 [label="IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 268740"];
18138 [label="param IsAccessibleHelper(Symbol symbol) 268741"];
18139 [label="param IsAccessibleHelper(TypeSymbol accessThroughType) 268742"];
18140 [label="param IsAccessibleHelper(out bool failedThroughTypeCheck) 268743"];
18141 [label="param IsAccessibleHelper(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268744"];
18142 [label="param IsAccessibleHelper(ConsList<TypeSymbol> basesBeingResolved) 268745"];
18143 [label="param IsAccessibleHelper(this) 268746"];
18144 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268747"];
18145 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268748"];
18146 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268749"];
18147 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268750"];
18148 [label="return Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268751"];
18149 [label="Next.IsAccessibleHelper(symbol, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 268752"];
18150 [label="param IsAccessibleHelper(Symbol symbol) 268753"];
18151 [label="param IsAccessibleHelper(TypeSymbol accessThroughType) 268754"];
18152 [label="param IsAccessibleHelper(out bool failedThroughTypeCheck) 268755"];
18153 [label="param IsAccessibleHelper(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268756"];
18154 [label="param IsAccessibleHelper(ConsList<TypeSymbol> basesBeingResolved) 268757"];
18155 [label="param IsAccessibleHelper(this) 268758"];
18156 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268759"];
18157 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268760"];
18158 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268761"];
18159 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268762"];
18160 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268763"];
18161 [label="return this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268764"];
18162 [label="this.IsSymbolAccessibleConditional(symbol, _namedType, accessThroughType, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 268765"];
18163 [label="param IsSymbolAccessibleConditional(Symbol symbol) 268766"];
18164 [label="param IsSymbolAccessibleConditional(NamedTypeSymbol within) 268767"];
18165 [label="param IsSymbolAccessibleConditional(TypeSymbol throughTypeOpt) 268768"];
18166 [label="param IsSymbolAccessibleConditional(out bool failedThroughTypeCheck) 268769"];
18167 [label="param IsSymbolAccessibleConditional(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 268770"];
18168 [label="param IsSymbolAccessibleConditional(ConsList<TypeSymbol>? basesBeingResolved = null) 268771"];
18169 [label="param IsSymbolAccessibleConditional(this) 268772"];
18170 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 268773"];
18171 [label="if (this.Flags.Includes(BinderFlags.IgnoreAccessibility))\n            {\n                failedThroughTypeCheck = false;\n                return true;\n            } 268774"];
18172 [label="this.Flags.Includes(BinderFlags.IgnoreAccessibility) 268775"];
18173 [label="param Includes(this BinderFlags self) 268776"];
18174 [label="param Includes(BinderFlags other) 268777"];
18175 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268778"];
18176 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268779"];
18177 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268780"];
18178 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268781"];
18179 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268782"];
18180 [label="return AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved); 268783"];
18181 [label="AccessCheck.IsSymbolAccessible(symbol, within, throughTypeOpt, out failedThroughTypeCheck, ref useSiteDiagnostics, basesBeingResolved) 268784"];
18182 [label="param IsSymbolAccessible(Symbol symbol) 268785"];
18183 [label="param IsSymbolAccessible(NamedTypeSymbol within) 268786"];
18184 [label="param IsSymbolAccessible(TypeSymbol throughTypeOpt) 268787"];
18185 [label="param IsSymbolAccessible(out bool failedThroughTypeCheck) 268788"];
18186 [label="param IsSymbolAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268789"];
18187 [label="param IsSymbolAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 268790"];
18188 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268791"];
18189 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268792"];
18190 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268793"];
18191 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268794"];
18192 [label="within.DeclaringCompilation 268795"];
18193 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 268796"];
18194 [label="this.Kind 268797"];
18195 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268798"];
18196 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 268799"];
18197 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268800"];
18198 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268801"];
18199 [label="return IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved); 268802"];
18200 [label="IsSymbolAccessibleCore(symbol, within, throughTypeOpt, out failedThroughTypeCheck, within.DeclaringCompilation, ref useSiteDiagnostics, basesBeingResolved) 268803"];
18201 [label="param IsSymbolAccessibleCore(Symbol symbol) 268804"];
18202 [label="param IsSymbolAccessibleCore(Symbol within) 268805"];
18203 [label="param IsSymbolAccessibleCore(TypeSymbol throughTypeOpt) 268806"];
18204 [label="param IsSymbolAccessibleCore(out bool failedThroughTypeCheck) 268807"];
18205 [label="param IsSymbolAccessibleCore(CSharpCompilation compilation) 268808"];
18206 [label="param IsSymbolAccessibleCore(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268809"];
18207 [label="param IsSymbolAccessibleCore(ConsList<TypeSymbol> basesBeingResolved = null) 268810"];
18208 [label="Debug.Assert((object)symbol != null); 268811"];
18209 [label="Debug.Assert((object)symbol != null); 268812"];
18210 [label="Debug.Assert((object)within != null); 268813"];
18211 [label="Debug.Assert((object)within != null); 268814"];
18212 [label="within.IsDefinition 268815"];
18213 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 268816"];
18214 [label="OriginalDefinition 268817"];
18215 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 268818"];
18216 [label="OriginalSymbolDefinition 268819"];
18217 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 268820"];
18218 [label="this.OriginalTypeSymbolDefinition 268821"];
18219 [label="get\n            {\n                return this.OriginalDefinition;\n            } 268822"];
18220 [label="this.OriginalDefinition 268823"];
18221 [label="get\n            {\n                return this;\n            } 268824"];
18222 [label="return this.OriginalDefinition; 268825"];
18223 [label="return this.OriginalTypeSymbolDefinition; 268826"];
18224 [label="return OriginalSymbolDefinition; 268827"];
18225 [label="return (object)this == (object)OriginalDefinition; 268828"];
18226 [label="Debug.Assert(within.IsDefinition); 268829"];
18227 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 268830"];
18228 [label="failedThroughTypeCheck = false; 268831"];
18229 [label="symbol.Kind 268832"];
18230 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268833"];
18231 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.ArrayType:\n                    return IsSymbolAccessibleCore(((ArrayTypeSymbol)symbol).ElementType, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.PointerType:\n                    return IsSymbolAccessibleCore(((PointerTypeSymbol)symbol).PointedAtType, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.NamedType:\n                    return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.Alias:\n                    return IsSymbolAccessibleCore(((AliasSymbol)symbol).Target, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.Discard:\n                    return IsSymbolAccessibleCore(((DiscardSymbol)symbol).TypeWithAnnotations.Type, within, null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved);\n\n                case SymbolKind.FunctionPointerType:\n                    var funcPtr = (FunctionPointerTypeSymbol)symbol;\n                    if (!IsSymbolAccessibleCore(funcPtr.Signature.ReturnType, within, throughTypeOpt: null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                    {\n                        return false;\n                    }\n\n                    foreach (var param in funcPtr.Signature.Parameters)\n                    {\n                        if (!IsSymbolAccessibleCore(param.Type, within, throughTypeOpt: null, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                        {\n                            return false;\n                        }\n                    }\n\n                    return true;\n\n                case SymbolKind.ErrorType:\n                    // Always assume that error types are accessible.\n                    return true;\n\n                case SymbolKind.TypeParameter:\n                case SymbolKind.Parameter:\n                case SymbolKind.Local:\n                case SymbolKind.Label:\n                case SymbolKind.Namespace:\n                case SymbolKind.DynamicType:\n                case SymbolKind.Assembly:\n                case SymbolKind.NetModule:\n                case SymbolKind.RangeVariable:\n                case SymbolKind.Method when ((MethodSymbol)symbol).MethodKind == MethodKind.LocalFunction:\n                    // These types of symbols are always accessible (if visible).\n                    return true;\n\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                    if (!symbol.RequiresInstanceReceiver())\n                    {\n                        // static members aren't accessed 'through' an 'instance' of any type.  So we\n                        // null out the 'through' instance here.  This ensures that we'll understand\n                        // accessing protected statics properly.\n                        throughTypeOpt = null;\n                    }\n\n                    return IsMemberAccessible(symbol.ContainingType, symbol.DeclaredAccessibility, within, throughTypeOpt, out failedThroughTypeCheck, compilation, ref useSiteDiagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 268834"];
18232 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 268835"];
18233 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 268836"];
18234 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 268837"];
18235 [label="return IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved); 268838"];
18236 [label="IsNamedTypeAccessible((NamedTypeSymbol)symbol, within, ref useSiteDiagnostics, basesBeingResolved) 268839"];
18237 [label="param IsNamedTypeAccessible(NamedTypeSymbol type) 268840"];
18238 [label="param IsNamedTypeAccessible(Symbol within) 268841"];
18239 [label="param IsNamedTypeAccessible(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 268842"];
18240 [label="param IsNamedTypeAccessible(ConsList<TypeSymbol> basesBeingResolved = null) 268843"];
18241 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 268844"];
18242 [label="Debug.Assert((object)type != null); 268845"];
18243 [label="Debug.Assert((object)type != null); 268846"];
18244 [label="within.DeclaringCompilation 268847"];
18245 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 268848"];
18246 [label="this.Kind 268849"];
18247 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268850"];
18248 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 268851"];
18249 [label="var compilation = within.DeclaringCompilation; 268852"];
18250 [label="bool unused; 268853"];
18251 [label="type.IsDefinition 268854"];
18252 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 268855"];
18253 [label="OriginalDefinition 268856"];
18254 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 268857"];
18255 [label="OriginalSymbolDefinition 268858"];
18256 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 268859"];
18257 [label="this.OriginalTypeSymbolDefinition 268860"];
18258 [label="get\n            {\n                return this.OriginalDefinition;\n            } 268861"];
18259 [label="this.OriginalDefinition 268862"];
18260 [label="get\n            {\n                return this;\n            } 268863"];
18261 [label="return this.OriginalDefinition; 268864"];
18262 [label="return this.OriginalTypeSymbolDefinition; 268865"];
18263 [label="return OriginalSymbolDefinition; 268866"];
18264 [label="return (object)this == (object)OriginalDefinition; 268867"];
18265 [label="if (!type.IsDefinition)\n            {\n                // All type argument must be accessible.\n                var typeArgs = type.TypeArgumentsWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics);\n                foreach (var typeArg in typeArgs)\n                {\n                    // type parameters are always accessible, so don't check those (so common it's\n                    // worth optimizing this).\n                    if (typeArg.Type.Kind != SymbolKind.TypeParameter && !IsSymbolAccessibleCore(typeArg.Type, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved))\n                    {\n                        return false;\n                    }\n                }\n            } 268868"];
18266 [label="type.ContainingType 268869"];
18267 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 268870"];
18268 [label="return _containingSymbol as NamedTypeSymbol; 268871"];
18269 [label="var containingType = type.ContainingType; 268872"];
18270 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 268873"];
18271 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 268874"];
18272 [label="(object)containingType == null 268875"];
18273 [label="type.ContainingAssembly 268876"];
18274 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 268877"];
18275 [label="this.ContainingSymbol 268878"];
18276 [label="get\n            {\n                return _containingSymbol;\n            } 268879"];
18277 [label="var container = this.ContainingSymbol; 268880"];
18278 [label="return (object)container != null ? container.ContainingAssembly : null; 268881"];
18279 [label="return (object)container != null ? container.ContainingAssembly : null; 268882"];
18280 [label="(object)container != null 268883"];
18281 [label="container.ContainingAssembly 268884"];
18282 [label="=> _module.ContainingAssembly 268885"];
18283 [label="_module.ContainingAssembly 268886"];
18284 [label="get\n            {\n                return _assemblySymbol;\n            } 268887"];
18285 [label="return _assemblySymbol; 268888"];
18286 [label="type.DeclaredAccessibility 268889"];
18287 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 268890"];
18288 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 268891"];
18289 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 268892"];
18290 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 268893"];
18291 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 268894"];
18292 [label="return Accessibility.Internal; 268895"];
18293 [label="return (object)containingType == null\n                ? IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within)\n                : IsMemberAccessible(containingType, type.DeclaredAccessibility, within, null, out unused, compilation, ref useSiteDiagnostics, basesBeingResolved); 268896"];
18294 [label="IsNonNestedTypeAccessible(type.ContainingAssembly, type.DeclaredAccessibility, within) 268897"];
18295 [label="param IsNonNestedTypeAccessible(AssemblySymbol assembly) 268898"];
18296 [label="param IsNonNestedTypeAccessible(Accessibility declaredAccessibility) 268899"];
18297 [label="param IsNonNestedTypeAccessible(Symbol within) 268900"];
18298 [label="Debug.Assert(within is NamedTypeSymbol || within is AssemblySymbol); 268901"];
18299 [label="Debug.Assert((object)assembly != null); 268902"];
18300 [label="Debug.Assert((object)assembly != null); 268903"];
18301 [label="switch (declaredAccessibility)\n            {\n                case Accessibility.NotApplicable:\n                case Accessibility.Public:\n                    // Public symbols are always accessible from any context\n                    return true;\n\n                case Accessibility.Private:\n                case Accessibility.Protected:\n                case Accessibility.ProtectedAndInternal:\n                    // Shouldn't happen except in error cases.\n                    return false;\n\n                case Accessibility.Internal:\n                case Accessibility.ProtectedOrInternal:\n\n                    // within is typically a type\n                    var withinType = within as NamedTypeSymbol;\n                    var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within;\n\n                    // An internal type is accessible if we're in the same assembly or we have\n                    // friend access to the assembly it was defined in.\n                    return (object)withinAssembly == (object)assembly || withinAssembly.HasInternalAccessTo(assembly);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaredAccessibility);\n            } 268904"];
18302 [label="var withinType = within as NamedTypeSymbol; 268905"];
18303 [label="var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within; 268906"];
18304 [label="var withinAssembly = (object)withinType != null ? withinType.ContainingAssembly : (AssemblySymbol)within; 268907"];
18305 [label="(object)withinType != null 268908"];
18306 [label="withinType.ContainingAssembly 268909"];
18307 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 268910"];
18308 [label="this.ContainingSymbol 268911"];
18309 [label="get\n            {\n                return _containingSymbol;\n            } 268912"];
18310 [label="var container = this.ContainingSymbol; 268913"];
18311 [label="return (object)container != null ? container.ContainingAssembly : null; 268914"];
18312 [label="return (object)container != null ? container.ContainingAssembly : null; 268915"];
18313 [label="(object)container != null 268916"];
18314 [label="container.ContainingAssembly 268917"];
18315 [label="=> _module.ContainingAssembly 268918"];
18316 [label="_module.ContainingAssembly 268919"];
18317 [label="get\n            {\n                return _assemblySymbol;\n            } 268920"];
18318 [label="return _assemblySymbol; 268921"];
18319 [label="return (object)withinAssembly == (object)assembly || withinAssembly.HasInternalAccessTo(assembly); 268922"];
18320 [label="if (!InCref &&\n                     !this.IsAccessible(unwrappedSymbol,\n                                        RefineAccessThroughType(options, accessThroughType),\n                                        out inaccessibleViaQualifier,\n                                        ref useSiteDiagnostics,\n                                        basesBeingResolved))\n            {\n                if (!diagnose)\n                {\n                    diagInfo = null;\n                }\n                else if (inaccessibleViaQualifier)\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess, unwrappedSymbol, accessThroughType, this.ContainingType);\n                }\n                else if (IsBadIvtSpecification())\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_FriendRefNotEqualToThis, unwrappedSymbol.ContainingAssembly.Identity.ToString(), AssemblyIdentity.PublicKeyToString(this.Compilation.Assembly.PublicKey));\n                }\n                else\n                {\n                    diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadAccess, new[] { unwrappedSymbol }, ImmutableArray.Create<Symbol>(unwrappedSymbol), additionalLocations: ImmutableArray<Location>.Empty);\n                }\n\n                return LookupResult.Inaccessible(symbol, diagInfo);\n            }\n            else if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268923"];
18321 [label="InCref 268924"];
18322 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268925"];
18323 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268926"];
18324 [label="unwrappedSymbol.MustCallMethodsDirectly() 268927"];
18325 [label="param MustCallMethodsDirectly(this Symbol symbol) 268928"];
18326 [label="symbol.Kind 268929"];
18327 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 268930"];
18328 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.Property:\n                    return ((PropertySymbol)symbol).MustCallMethodsDirectly;\n                case SymbolKind.Event:\n                    return ((EventSymbol)symbol).MustCallMethodsDirectly;\n                default:\n                    return false;\n            } 268931"];
18329 [label="return false; 268932"];
18330 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268933"];
18331 [label="if (!InCref && unwrappedSymbol.MustCallMethodsDirectly())\n            {\n                diagInfo = diagnose ? MakeCallMethodsDirectlyDiagnostic(unwrappedSymbol) : null;\n                return LookupResult.NotReferencable(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268934"];
18332 [label="if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268935"];
18333 [label="if ((options & LookupOptions.MustBeInstance) != 0 && !IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectRequired, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268936"];
18334 [label="if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268937"];
18335 [label="if ((options & LookupOptions.MustNotBeInstance) != 0 && IsInstance(unwrappedSymbol))\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_ObjectProhibited, unwrappedSymbol) : null;\n                return LookupResult.StaticInstanceMismatch(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268938"];
18336 [label="if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268939"];
18337 [label="if ((options & LookupOptions.MustNotBeNamespace) != 0 && unwrappedSymbol.Kind == SymbolKind.Namespace)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown, unwrappedSymbol, unwrappedSymbol.GetKindText()) : null;\n                return LookupResult.NotTypeOrNamespace(symbol, diagInfo);\n            }\n            else if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268940"];
18338 [label="if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268941"];
18339 [label="if ((options & LookupOptions.LabelsOnly) != 0 && unwrappedSymbol.Kind != SymbolKind.Label)\n            {\n                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_LabelNotFound, unwrappedSymbol.Name) : null;\n                return LookupResult.NotLabel(symbol, diagInfo);\n            }\n            else\n            {\n                return LookupResult.Good(symbol);\n            } 268942"];
18340 [label="return LookupResult.Good(symbol); 268943"];
18341 [label="LookupResult.Good(symbol) 268944"];
18342 [label="param Good(Symbol symbol) 268945"];
18343 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 268946"];
18344 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 268947"];
18345 [label="return new SingleLookupResult(LookupResultKind.Viable, symbol, null); 268948"];
18346 [label="new SingleLookupResult(LookupResultKind.Viable, symbol, null) 268949"];
18347 [label="param SingleLookupResult(LookupResultKind kind) 268950"];
18348 [label="param SingleLookupResult(Symbol symbol) 268951"];
18349 [label="param SingleLookupResult(DiagnosticInfo error) 268952"];
18350 [label="param SingleLookupResult(this) 268953"];
18351 [label="this.Kind 268954"];
18352 [label="this.Symbol 268955"];
18353 [label="this.Error 268956"];
18354 [label="return LookupResult.Good(symbol); 268957"];
18355 [label="result.MergeEqual(resultOfThisMember); 268958"];
18356 [label="result.MergeEqual(resultOfThisMember) 268959"];
18357 [label="param MergeEqual(SingleLookupResult result) 268960"];
18358 [label="param MergeEqual(this) 268961"];
18359 [label="Kind 268962"];
18360 [label="get\n            {\n                return _kind;\n            } 268963"];
18361 [label="if (Kind > result.Kind)\n            {\n                // existing result is better\n            }\n            else if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 268964"];
18362 [label="if (Kind > result.Kind)\n            {\n                // existing result is better\n            }\n            else if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 268965"];
18363 [label="Kind 268966"];
18364 [label="if (result.Kind > Kind)\n            {\n                this.SetFrom(result);\n            }\n            else if ((object)result.Symbol != null)\n            {\n                // Same goodness. Include all symbols\n                _symbolList.Add(result.Symbol);\n            } 268967"];
18365 [label="this.SetFrom(result); 268968"];
18366 [label="this.SetFrom(result) 268969"];
18367 [label="param SetFrom(SingleLookupResult other) 268970"];
18368 [label="param SetFrom(this) 268971"];
18369 [label="_kind 268972"];
18370 [label="_symbolList.Clear(); 268973"];
18371 [label="_symbolList.Add(other.Symbol); 268974"];
18372 [label="_symbolList.Add(other.Symbol); 268975"];
18373 [label="_error 268976"];
18374 [label="this.SetFrom(result); 268977"];
18375 [label="result.MergeEqual(resultOfThisMember); 268978"];
18376 [label="foreach (Symbol member in members)\n            {\n                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member, arity, options, null, diagnose, ref useSiteDiagnostics);\n                result.MergeEqual(resultOfThisMember);\n            } 268979"];
18377 [label="LookupMembersInNamespace(result, (NamespaceSymbol)nsOrType, name, arity, options, originalBinder, diagnose, ref useSiteDiagnostics); 268980"];
18378 [label="this.LookupMembersInternal(result, _container, name, arity, basesBeingResolved, options, originalBinder, diagnose, ref useSiteDiagnostics); 268981"];
18379 [label="result.IsMultiViable 268982"];
18380 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 268983"];
18381 [label="return _kind; 268984"];
18382 [label="if (result.IsMultiViable)\n                {\n                    // symbols cannot conflict with using alias names\n                    if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    }\n\n                    return;\n                } 268985"];
18383 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 268986"];
18384 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 268987"];
18385 [label="originalBinder.IsSemanticModelBinder 268988"];
18386 [label="get\n            {\n                return this.Flags.Includes(BinderFlags.SemanticModel);\n            } 268989"];
18387 [label="return this.Flags.Includes(BinderFlags.SemanticModel); 268990"];
18388 [label="return this.Flags.Includes(BinderFlags.SemanticModel); 268991"];
18389 [label="this.Flags.Includes(BinderFlags.SemanticModel) 268992"];
18390 [label="param Includes(this BinderFlags self) 268993"];
18391 [label="param Includes(BinderFlags other) 268994"];
18392 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 268995"];
18393 [label="imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder) 268996"];
18394 [label="param IsUsingAlias(string name) 268997"];
18395 [label="param IsUsingAlias(bool callerIsSemanticModel) 268998"];
18396 [label="param IsUsingAlias(this) 268999"];
18397 [label="AliasAndUsingDirective node; 269000"];
18398 [label="node 269001"];
18399 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 269002"];
18400 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 269003"];
18401 [label="if (this.UsingAliases.TryGetValue(name, out node))\n            {\n                // This method is called by InContainerBinder.LookupSymbolsInSingleBinder to see if\n                // there's a conflict between an alias and a member.  As a conflict may cause a\n                // speculative lambda binding to fail this is semantically relevant and we need to\n                // mark this using alias as referenced (and thus not something that can be removed).\n                MarkImportDirective(node.UsingDirective, callerIsSemanticModel);\n                return true;\n            } 269004"];
18402 [label="return false; 269005"];
18403 [label="if (arity == 0 && imports.IsUsingAlias(name, originalBinder.IsSemanticModelBinder))\n                    {\n                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictAliasAndMember, name, _container);\n                        var error = new ExtendedErrorTypeSymbol((NamespaceOrTypeSymbol)null, name, arity, diagInfo, unreported: true);\n                        result.SetFrom(LookupResult.Good(error)); // force lookup to be done w/ error symbol as result\n                    } 269006"];
18404 [label="return; 269007"];
18405 [label="result.IsClear 269008"];
18406 [label="get\n            {\n                return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0;\n            } 269009"];
18407 [label="return _kind == LookupResultKind.Empty && _error == null && _symbolList.Count == 0; 269010"];
18408 [label="if (!result.IsClear)\n                    {\n                        binder = scope;\n                    } 269011"];
18409 [label="binder = scope; 269012"];
18410 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 269013"];
18411 [label="if ((options & LookupOptions.LabelsOnly) != 0 && scope.IsLastBinderWithinMember())\n                {\n                    // Labels declared outside of a member are not visible inside.\n                    break;\n                } 269014"];
18412 [label="return binder; 269015"];
18413 [label="this.LookupSymbolsOrMembersInternal(result, qualifierOpt, plainName, arity, basesBeingResolved, options, diagnose, ref useSiteDiagnostics); 269016"];
18414 [label="diagnostics.Add(node, useSiteDiagnostics); 269017"];
18415 [label="diagnostics.Add(node, useSiteDiagnostics); 269018"];
18416 [label="diagnostics.Add(node, useSiteDiagnostics); 269019"];
18417 [label="diagnostics.Add(node, useSiteDiagnostics) 269020"];
18418 [label="param Add(this DiagnosticBag diagnostics) 269021"];
18419 [label="param Add(SyntaxNode node) 269022"];
18420 [label="param Add(HashSet<DiagnosticInfo> useSiteDiagnostics) 269023"];
18421 [label="return !useSiteDiagnostics.IsNullOrEmpty() && diagnostics.Add(node.Location, useSiteDiagnostics); 269024"];
18422 [label="Symbol bindingResult = null; 269025"];
18423 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 269026"];
18424 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 269027"];
18425 [label="if ((object)qualifierOpt == null &&\n                !IsViableType(result))\n            {\n                if (node.Identifier.ValueText == 'dynamic')\n                {\n                    if ((node.Parent == null ||\n                          node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as attribute type\n                          SyntaxFacts.IsInTypeOnlyContext(node)) &&\n                        Compilation.LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion())\n                    {\n                        bindingResult = Compilation.DynamicType;\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n                else\n                {\n                    bindingResult = BindNativeIntegerSymbolIfAny(node, diagnostics);\n                }\n            } 269028"];
18426 [label="IsViableType(result) 269029"];
18427 [label="param IsViableType(LookupResult result) 269030"];
18428 [label="result.IsMultiViable 269031"];
18429 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 269032"];
18430 [label="Kind 269033"];
18431 [label="get\n            {\n                return _kind;\n            } 269034"];
18432 [label="return _kind; 269035"];
18433 [label="if (!result.IsMultiViable)\n            {\n                return false;\n            } 269036"];
18434 [label="result.Symbols 269037"];
18435 [label="get\n            {\n                return _symbolList;\n            } 269038"];
18436 [label="return _symbolList; 269039"];
18437 [label="foreach (var s in result.Symbols)\n            {\n                switch (s.Kind)\n                {\n                    case SymbolKind.Alias:\n                        if (((AliasSymbol)s).Target.Kind == SymbolKind.NamedType) return true;\n                        break;\n                    case SymbolKind.NamedType:\n                    case SymbolKind.TypeParameter:\n                        return true;\n                }\n            } 269040"];
18438 [label="s.Kind 269041"];
18439 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269042"];
18440 [label="switch (s.Kind)\n                {\n                    case SymbolKind.Alias:\n                        if (((AliasSymbol)s).Target.Kind == SymbolKind.NamedType) return true;\n                        break;\n                    case SymbolKind.NamedType:\n                    case SymbolKind.TypeParameter:\n                        return true;\n                } 269043"];
18441 [label="return true; 269044"];
18442 [label="if (bindingResult is null)\n            {\n                bool wasError;\n\n                bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options);\n                if (bindingResult.Kind == SymbolKind.Alias)\n                {\n                    var aliasTarget = ((AliasSymbol)bindingResult).GetAliasTarget(basesBeingResolved);\n                    if (aliasTarget.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)aliasTarget).ContainsDynamic())\n                    {\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                }\n            } 269045"];
18443 [label="bool wasError; 269046"];
18444 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269047"];
18445 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269048"];
18446 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269049"];
18447 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269050"];
18448 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269051"];
18449 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269052"];
18450 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269053"];
18451 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269054"];
18452 [label="bindingResult = ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269055"];
18453 [label="ResultSymbol(result, identifierValueText, 0, node, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options) 269056"];
18454 [label="param ResultSymbol(LookupResult result) 269057"];
18455 [label="param ResultSymbol(string simpleName) 269058"];
18456 [label="param ResultSymbol(int arity) 269059"];
18457 [label="param ResultSymbol(SyntaxNode where) 269060"];
18458 [label="param ResultSymbol(DiagnosticBag diagnostics) 269061"];
18459 [label="param ResultSymbol(bool suppressUseSiteDiagnostics) 269062"];
18460 [label="param ResultSymbol(out bool wasError) 269063"];
18461 [label="param ResultSymbol(NamespaceOrTypeSymbol qualifierOpt = null) 269064"];
18462 [label="param ResultSymbol(LookupOptions options = default(LookupOptions)) 269065"];
18463 [label="param ResultSymbol(this) 269066"];
18464 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269067"];
18465 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269068"];
18466 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269069"];
18467 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269070"];
18468 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269071"];
18469 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269072"];
18470 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269073"];
18471 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269074"];
18472 [label="Symbol symbol = resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options); 269075"];
18473 [label="resultSymbol(result, simpleName, arity, where, diagnostics, suppressUseSiteDiagnostics, out wasError, qualifierOpt, options) 269076"];
18474 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269077"];
18475 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269078"];
18476 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269079"];
18477 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269080"];
18478 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269081"];
18479 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269082"];
18480 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269083"];
18481 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269084"];
18482 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269085"];
18483 [label="Symbol resultSymbol(\n                LookupResult result,\n                string simpleName,\n                int arity,\n                SyntaxNode where,\n                DiagnosticBag diagnostics,\n                bool suppressUseSiteDiagnostics,\n                out bool wasError,\n                NamespaceOrTypeSymbol qualifierOpt,\n                LookupOptions options)\n            {\n                Debug.Assert(where != null);\n                Debug.Assert(diagnostics != null);\n\n                var symbols = result.Symbols;\n                wasError = false;\n\n                if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                }\n\n                // Below here is the error case; no viable symbols found (but maybe one or more non-viable.)\n                wasError = true;\n\n                if (result.Kind == LookupResultKind.Empty)\n                {\n                    string aliasOpt = null;\n                    SyntaxNode node = where;\n                    while (node is ExpressionSyntax)\n                    {\n                        if (node.Kind() == SyntaxKind.AliasQualifiedName)\n                        {\n                            aliasOpt = ((AliasQualifiedNameSyntax)node).Alias.Identifier.ValueText;\n                            break;\n                        }\n                        node = node.Parent;\n                    }\n\n                    CSDiagnosticInfo info = NotFound(where, simpleName, arity,\n                        // LAFHIS\n                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, diagnostics, aliasOpt, qualifierOpt, options);\n                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? Compilation.Assembly.GlobalNamespace, simpleName, arity, info);\n                }\n\n                Debug.Assert(symbols.Count > 0);\n\n                // Report any errors we encountered with the symbol we looked up.\n                if (!suppressUseSiteDiagnostics)\n                {\n                    for (int i = 0; i < symbols.Count; i++)\n                    {\n                        ReportUseSiteDiagnostics(symbols[i], diagnostics, where);\n                    }\n                }\n\n                // result.Error might be null if we have already generated parser errors,\n                // e.g. when generic name is used for attribute name.\n                if (result.Error != null &&\n                    ((object)qualifierOpt == null || qualifierOpt.Kind != SymbolKind.ErrorType)) // Suppress cascading.\n                {\n                    diagnostics.Add(new CSDiagnostic(result.Error, where.Location));\n                }\n\n                if ((symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||\n                    result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType)\n                {\n                    // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types, preserving the symbols and the result kind.\n                    // We do this if there are multiple symbols too, because just returning one would be losing important information, and they might\n                    // be of different kinds.\n                    return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0]), symbols.ToImmutable(), result.Kind, result.Error, arity);\n                }\n                else\n                {\n                    // It's a single non-type-or-namespace; error was already reported, so just return it.\n                    return symbols[0];\n                }\n            } 269086"];
18484 [label="Debug.Assert(where != null); 269087"];
18485 [label="Debug.Assert(where != null); 269088"];
18486 [label="Debug.Assert(diagnostics != null); 269089"];
18487 [label="Debug.Assert(diagnostics != null); 269090"];
18488 [label="result.Symbols 269091"];
18489 [label="get\n            {\n                return _symbolList;\n            } 269092"];
18490 [label="return _symbolList; 269093"];
18491 [label="var symbols = result.Symbols; 269094"];
18492 [label="wasError = false; 269095"];
18493 [label="result.IsMultiViable 269096"];
18494 [label="get\n            {\n                return Kind == LookupResultKind.Viable;\n            } 269097"];
18495 [label="Kind 269098"];
18496 [label="get\n            {\n                return _kind;\n            } 269099"];
18497 [label="return _kind; 269100"];
18498 [label="if (result.IsMultiViable)\n                {\n                    if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    }\n                } 269101"];
18499 [label="if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    } 269102"];
18500 [label="if (symbols.Count > 1)\n                    {\n                        // gracefully handle symbols.Count > 2\n                        symbols.Sort(ConsistentSymbolOrder.Instance);\n\n                        var originalSymbols = symbols.ToImmutable();\n\n                        for (int i = 0; i < symbols.Count; i++)\n                        {\n                            symbols[i] = UnwrapAlias(symbols[i], diagnostics, where);\n                        }\n\n                        BestSymbolInfo secondBest;\n                        BestSymbolInfo best = GetBestSymbolInfo(symbols, out secondBest);\n\n                        Debug.Assert(!best.IsNone);\n                        Debug.Assert(!secondBest.IsNone);\n\n                        if (best.IsFromCompilation && !secondBest.IsFromCompilation)\n                        {\n                            var srcSymbol = symbols[best.Index];\n                            var mdSymbol = symbols[secondBest.Index];\n\n                            object arg0;\n\n                            if (best.IsFromSourceModule)\n                            {\n                                arg0 = srcSymbol.Locations.First().SourceTree.FilePath;\n                            }\n                            else\n                            {\n                                Debug.Assert(best.IsFromAddedModule);\n                                arg0 = srcSymbol.ContainingModule;\n                            }\n\n                            //if names match, arities match, and containing symbols match (recursively), ...\n                            if (NameAndArityMatchRecursively(srcSymbol, mdSymbol))\n                            {\n                                if (srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisNsAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.Namespace)\n                                {\n                                    // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggNs, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        GetContainingAssembly(mdSymbol),\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else if (srcSymbol.Kind == SymbolKind.NamedType && mdSymbol.Kind == SymbolKind.NamedType)\n                                {\n                                    // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.\n                                    diagnostics.Add(ErrorCode.WRN_SameFullNameThisAggAgg, where.Location, originalSymbols,\n                                        arg0,\n                                        srcSymbol,\n                                        mdSymbol.ContainingAssembly,\n                                        mdSymbol);\n\n                                    return originalSymbols[best.Index];\n                                }\n                                else\n                                {\n                                    // namespace would be merged with the source namespace:\n                                    Debug.Assert(!(srcSymbol.Kind == SymbolKind.Namespace && mdSymbol.Kind == SymbolKind.Namespace));\n                                }\n                            }\n                        }\n\n                        var first = symbols[best.Index];\n                        var second = symbols[secondBest.Index];\n\n                        Debug.Assert(!Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything) || options.IsAttributeTypeLookup(),\n                            'This kind of ambiguity is only possible for attributes.');\n\n                        Debug.Assert(!Symbol.Equals(first, second, TypeCompareKind.ConsiderEverything) || !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                            'Why does the LookupResult contain the same symbol twice?');\n\n                        CSDiagnosticInfo info;\n                        bool reportError;\n\n                        //if names match, arities match, and containing symbols match (recursively), ...\n                        if (first != second &&\n                            NameAndArityMatchRecursively(first, second))\n                        {\n                            // suppress reporting the error if we found multiple symbols from source module\n                            // since an error has already been reported from the declaration\n                            reportError = !(best.IsFromSourceModule && secondBest.IsFromSourceModule);\n\n                            if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.NamedType)\n                            {\n                                if (first.OriginalDefinition == second.OriginalDefinition)\n                                {\n                                    // We imported different generic instantiations of the same generic type\n                                    // and have an ambiguous reference to a type nested in it\n                                    reportError = true;\n\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                                else\n                                {\n                                    Debug.Assert(!best.IsFromCorLibrary);\n\n                                    // ErrorCode.ERR_SameFullNameAggAgg: The type '{1}' exists in both '{0}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameAggAgg, originalSymbols,\n                                        new object[] { first.ContainingAssembly, first, second.ContainingAssembly });\n\n                                    // Do not report this error if the first is declared in source and the second is declared in added module,\n                                    // we already reported declaration error about this name collision.\n                                    // Do not report this error if both are declared in added modules,\n                                    // we will report assembly level declaration error about this name collision.\n                                    if (secondBest.IsFromAddedModule)\n                                    {\n                                        Debug.Assert(best.IsFromCompilation);\n                                        reportError = false;\n                                    }\n                                    else if (this.Flags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) &&\n                                        secondBest.IsFromCorLibrary)\n                                    {\n                                        // Ignore duplicate types from the cor library if necessary.\n                                        // (Specifically the framework assemblies loaded at runtime in\n                                        // the EE may contain types also available from mscorlib.dll.)\n                                        return first;\n                                    }\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.Namespace && second.Kind == SymbolKind.NamedType)\n                            {\n                                // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                    new object[] { GetContainingAssembly(first), first, second.ContainingAssembly, second });\n\n                                // Do not report this error if namespace is declared in source and the type is declared in added module,\n                                // we already reported declaration error about this name collision.\n                                if (best.IsFromSourceModule && secondBest.IsFromAddedModule)\n                                {\n                                    reportError = false;\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.NamedType && second.Kind == SymbolKind.Namespace)\n                            {\n                                if (!secondBest.IsFromCompilation || secondBest.IsFromSourceModule)\n                                {\n                                    // ErrorCode.ERR_SameFullNameNsAgg: The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameNsAgg, originalSymbols,\n                                        new object[] { GetContainingAssembly(second), second, first.ContainingAssembly, first });\n                                }\n                                else\n                                {\n                                    Debug.Assert(secondBest.IsFromAddedModule);\n\n                                    // ErrorCode.ERR_SameFullNameThisAggThisNs: The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'\n                                    object arg0;\n\n                                    if (best.IsFromSourceModule)\n                                    {\n                                        arg0 = first.Locations.First().SourceTree.FilePath;\n                                    }\n                                    else\n                                    {\n                                        Debug.Assert(best.IsFromAddedModule);\n                                        arg0 = first.ContainingModule;\n                                    }\n\n                                    ModuleSymbol arg2 = second.ContainingModule;\n\n                                    // Merged namespaces that span multiple modules don't have a containing module,\n                                    // so just use module with the smallest ordinal from the containing assembly.\n                                    if ((object)arg2 == null)\n                                    {\n                                        foreach (NamespaceSymbol ns in ((NamespaceSymbol)second).ConstituentNamespaces)\n                                        {\n                                            if (ns.ContainingAssembly == Compilation.Assembly)\n                                            {\n                                                ModuleSymbol module = ns.ContainingModule;\n\n                                                if ((object)arg2 == null || arg2.Ordinal > module.Ordinal)\n                                                {\n                                                    arg2 = module;\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    Debug.Assert(arg2.ContainingAssembly == Compilation.Assembly);\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_SameFullNameThisAggThisNs, originalSymbols,\n                                        new object[] { arg0, first, arg2, second });\n                                }\n                            }\n                            else if (first.Kind == SymbolKind.RangeVariable && second.Kind == SymbolKind.RangeVariable)\n                            {\n                                // We will already have reported a conflicting range variable declaration.\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                            else\n                            {\n                                // TODO: this is not an appropriate error message here, but used as a fallback until the\n                                // appropriate diagnostics are implemented.\n                                // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                //info = diagnostics.Add(ErrorCode.ERR_AmbigContext, location, readOnlySymbols,\n                                //    whereText,\n                                //    first,\n                                //    second);\n\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n\n                                reportError = true;\n                            }\n                        }\n                        else\n                        {\n                            Debug.Assert(originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name ||\n                                         !Symbol.Equals(originalSymbols[best.Index], originalSymbols[secondBest.Index], TypeCompareKind.ConsiderEverything),\n                                'Why was the lookup result viable if it contained non-equal symbols with the same name?');\n\n                            reportError = true;\n\n                            if (first is NamespaceOrTypeSymbol && second is NamespaceOrTypeSymbol)\n                            {\n                                if (options.IsAttributeTypeLookup() &&\n                                    first.Kind == SymbolKind.NamedType &&\n                                    second.Kind == SymbolKind.NamedType &&\n                                    originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names, if available.\n                                    Compilation.IsAttributeType((NamedTypeSymbol)first) &&\n                                    Compilation.IsAttributeType((NamedTypeSymbol)second))\n                                {\n                                    //  SPEC:   If an attribute class is found both with and without Attribute suffix, an ambiguity\n                                    //  SPEC:   is present, and a compile-time error results.\n\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbiguousAttribute, originalSymbols,\n                                        // LAFHIS\n                                        new object[] { ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName, first, second });\n                                }\n                                else\n                                {\n                                    // '{0}' is an ambiguous reference between '{1}' and '{2}'\n                                    info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigContext, originalSymbols,\n                                        new object[] {\n                                            // LAFHIS\n                                        ((where is NameSyntax) ? ((NameSyntax)where).ErrorDisplayName() : null) ?? simpleName,\n                                        new FormattedSymbol(first, SymbolDisplayFormat.CSharpErrorMessageFormat),\n                                        new FormattedSymbol(second, SymbolDisplayFormat.CSharpErrorMessageFormat) });\n                                }\n                            }\n                            else\n                            {\n                                // CS0229: Ambiguity between '{0}' and '{1}'\n                                info = new CSDiagnosticInfo(ErrorCode.ERR_AmbigMember, originalSymbols,\n                                    new object[] { first, second });\n                            }\n                        }\n\n                        wasError = true;\n\n                        if (reportError)\n                        {\n                            diagnostics.Add(info, where.Location);\n                        }\n\n                        return new ExtendedErrorTypeSymbol(\n                            GetContainingNamespaceOrType(originalSymbols[0]),\n                            originalSymbols,\n                            LookupResultKind.Ambiguous,\n                            info,\n                            arity);\n                    }\n                    else\n                    {\n                        // Single viable result.\n                        var singleResult = symbols[0];\n\n                        // Cannot reference System.Void directly.\n                        var singleType = singleResult as TypeSymbol;\n                        if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        }\n\n                        return singleResult;\n                    } 269103"];
18501 [label="var singleResult = symbols[0]; 269104"];
18502 [label="var singleType = singleResult as TypeSymbol; 269105"];
18503 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 269106"];
18504 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 269107"];
18505 [label="singleType.PrimitiveTypeCode 269108"];
18506 [label="=> TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 269109"];
18507 [label="TypeKind 269110"];
18508 [label="get\n            {\n                return _flags.TypeKind;\n            } 269111"];
18509 [label="TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 269112"];
18510 [label="SpecialType 269113"];
18511 [label="get\n            {\n                return _flags.SpecialType;\n            } 269114"];
18512 [label="_flags.SpecialType 269115"];
18513 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 269116"];
18514 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 269117"];
18515 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 269118"];
18516 [label="return _flags.SpecialType; 269119"];
18517 [label="SpecialTypes.GetTypeCode(SpecialType) 269120"];
18518 [label="if ((object)singleType != null && singleType.PrimitiveTypeCode == Cci.PrimitiveTypeCode.Void && simpleName == 'Void')\n                        {\n                            wasError = true;\n                            var errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_SystemVoid);\n                            diagnostics.Add(errorInfo, where.Location);\n                            singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult), singleResult, LookupResultKind.NotReferencable, errorInfo); // UNDONE: Review resultkind.\n                        }\n                        // Check for bad symbol.\n                        else\n                        {\n                            if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            }\n\n                            if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            }\n                        } 269121"];
18519 [label="singleResult.Kind 269122"];
18520 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269123"];
18521 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 269124"];
18522 [label="this.Compilation.SourceModule 269125"];
18523 [label="get\n            {\n                return Assembly.Modules[0];\n            } 269126"];
18524 [label="GetBoundReferenceManager(); 269127"];
18525 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 269128"];
18526 [label="((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked 269129"];
18527 [label="get\n            {\n                return GetAssembliesToEmbedTypesFrom().Length > 0;\n            } 269130"];
18528 [label="GetAssembliesToEmbedTypesFrom() 269131"];
18529 [label="param GetAssembliesToEmbedTypesFrom(this) 269132"];
18530 [label="if (_lazyAssembliesToEmbedTypesFrom.IsDefault)\n            {\n                AssertReferencesInitialized();\n                var buffer = ArrayBuilder<AssemblySymbol>.GetInstance();\n\n                foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                }\n\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>));\n            } 269133"];
18531 [label="AssertReferencesInitialized() 269134"];
18532 [label="param AssertReferencesInitialized(this) 269135"];
18533 [label="Debug.Assert(_moduleReferences != null); 269136"];
18534 [label="Debug.Assert(_moduleReferences != null); 269137"];
18535 [label="AssertReferencesInitialized(); 269138"];
18536 [label="var buffer = ArrayBuilder<AssemblySymbol>.GetInstance(); 269139"];
18537 [label="this.GetReferencedAssemblySymbols() 269140"];
18538 [label="AssertReferencesInitialized() 269141"];
18539 [label="param AssertReferencesInitialized(this) 269142"];
18540 [label="Debug.Assert(_moduleReferences != null); 269143"];
18541 [label="Debug.Assert(_moduleReferences != null); 269144"];
18542 [label="AssertReferencesInitialized(); 269145"];
18543 [label="foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                } 269146"];
18544 [label="asm.IsLinked 269147"];
18545 [label="get\n            {\n                return _isLinked;\n            } 269148"];
18546 [label="return _isLinked; 269149"];
18547 [label="if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    } 269150"];
18548 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 269151"];
18549 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 269152"];
18550 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 269153"];
18551 [label="Debug.Assert(!_lazyAssembliesToEmbedTypesFrom.IsDefault); 269154"];
18552 [label="return _lazyAssembliesToEmbedTypesFrom; 269155"];
18553 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 269156"];
18554 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 269157"];
18555 [label="if (singleResult.Kind == SymbolKind.NamedType &&\n                                ((SourceModuleSymbol)this.Compilation.SourceModule).AnyReferencedAssembliesAreLinked)\n                            {\n                                // Complain about unembeddable types from linked assemblies.\n                                Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType((NamedTypeSymbol)singleResult, where, diagnostics);\n                            } 269158"];
18556 [label="if (!suppressUseSiteDiagnostics)\n                            {\n                                wasError = ReportUseSiteDiagnostics(singleResult, diagnostics, where);\n                            }\n                            else if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            } 269159"];
18557 [label="singleResult.Kind 269160"];
18558 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269161"];
18559 [label="if (singleResult.Kind == SymbolKind.ErrorType)\n                            {\n                                // We want to report ERR_CircularBase error on the spot to make sure\n                                // that the right location is used for it.\n                                var errorType = (ErrorTypeSymbol)singleResult;\n\n                                if (errorType.Unreported)\n                                {\n                                    DiagnosticInfo errorInfo = errorType.ErrorInfo;\n\n                                    if (errorInfo != null && errorInfo.Code == (int)ErrorCode.ERR_CircularBase)\n                                    {\n                                        wasError = true;\n                                        diagnostics.Add(errorInfo, where.Location);\n                                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType), errorType.Name, errorType.Arity, errorInfo, unreported: false);\n                                    }\n                                }\n                            } 269162"];
18560 [label="return singleResult; 269163"];
18561 [label="symbol.Kind 269164"];
18562 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269165"];
18563 [label="if (symbol.Kind == SymbolKind.NamedType)\n            {\n                CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics);\n            } 269166"];
18564 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 269167"];
18565 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 269168"];
18566 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 269169"];
18567 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics); 269170"];
18568 [label="CheckRuntimeSupportForSymbolAccess(where, receiverOpt: null, symbol, diagnostics) 269171"];
18569 [label="param CheckRuntimeSupportForSymbolAccess(SyntaxNode node) 269172"];
18570 [label="param CheckRuntimeSupportForSymbolAccess(BoundExpression receiverOpt) 269173"];
18571 [label="param CheckRuntimeSupportForSymbolAccess(Symbol symbol) 269174"];
18572 [label="param CheckRuntimeSupportForSymbolAccess(DiagnosticBag diagnostics) 269175"];
18573 [label="param CheckRuntimeSupportForSymbolAccess(this) 269176"];
18574 [label="symbol.ContainingType 269177"];
18575 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 269178"];
18576 [label="return _containingSymbol as NamedTypeSymbol; 269179"];
18577 [label="if (symbol.ContainingType?.IsInterface == true && !Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation && Compilation.SourceModule != symbol.ContainingModule)\n            {\n                if (!symbol.IsStatic && !(symbol is TypeSymbol) &&\n                    !symbol.IsImplementableInterfaceMember())\n                {\n                    Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, node);\n                }\n                else\n                {\n                    switch (symbol.DeclaredAccessibility)\n                    {\n                        case Accessibility.Protected:\n                        case Accessibility.ProtectedOrInternal:\n                        case Accessibility.ProtectedAndInternal:\n\n                            Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember, node);\n                            break;\n                    }\n                }\n            } 269180"];
18578 [label="if (symbol.ContainingType?.IsInterface == true && !Compilation.Assembly.RuntimeSupportsDefaultInterfaceImplementation && Compilation.SourceModule != symbol.ContainingModule)\n            {\n                if (!symbol.IsStatic && !(symbol is TypeSymbol) &&\n                    !symbol.IsImplementableInterfaceMember())\n                {\n                    Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, node);\n                }\n                else\n                {\n                    switch (symbol.DeclaredAccessibility)\n                    {\n                        case Accessibility.Protected:\n                        case Accessibility.ProtectedOrInternal:\n                        case Accessibility.ProtectedAndInternal:\n\n                            Error(diagnostics, ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember, node);\n                            break;\n                    }\n                }\n            } 269181"];
18579 [label="return symbol; 269182"];
18580 [label="bindingResult.Kind 269183"];
18581 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269184"];
18582 [label="if (bindingResult.Kind == SymbolKind.Alias)\n                {\n                    var aliasTarget = ((AliasSymbol)bindingResult).GetAliasTarget(basesBeingResolved);\n                    if (aliasTarget.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)aliasTarget).ContainsDynamic())\n                    {\n                        ReportUseSiteDiagnosticForDynamic(diagnostics, node);\n                    }\n                } 269185"];
18583 [label="result.Free() 269186"];
18584 [label="param Free(this) 269187"];
18585 [label="this.Clear() 269188"];
18586 [label="param Clear(this) 269189"];
18587 [label="_kind 269190"];
18588 [label="_symbolList.Clear(); 269191"];
18589 [label="_error = null; 269192"];
18590 [label="_error 269193"];
18591 [label="this.Clear(); 269194"];
18592 [label="if (_pool != null)\n            {\n                _pool.Free(this);\n            } 269195"];
18593 [label="if (_pool != null)\n            {\n                _pool.Free(this);\n            } 269196"];
18594 [label="_pool.Free(this); 269197"];
18595 [label="_pool.Free(this); 269198"];
18596 [label="result.Free(); 269199"];
18597 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 269200"];
18598 [label="node.Identifier 269201"];
18599 [label="=> true 269202"];
18600 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 269203"];
18601 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 269204"];
18602 [label="AreNullableAnnotationsEnabled(node.Identifier) 269205"];
18603 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 269206"];
18604 [label="param AreNullableAnnotationsEnabled(this) 269207"];
18605 [label="RoslynDebug.Assert(token.SyntaxTree is object); 269208"];
18606 [label="RoslynDebug.Assert(token.SyntaxTree is object); 269209"];
18607 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 269210"];
18608 [label="SyntaxTree? tree = null; 269211"];
18609 [label="tree = node._syntaxTree; 269212"];
18610 [label="if (tree != null)\n                {\n                    break;\n                } 269213"];
18611 [label="if (tree != null)\n                {\n                    break;\n                } 269214"];
18612 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 269215"];
18613 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 269216"];
18614 [label="Debug.Assert(result != null); 269217"];
18615 [label="Debug.Assert(result != null); 269218"];
18616 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 269219"];
18617 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 269220"];
18618 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 269221"];
18619 [label="Debug.Assert(result != null); 269222"];
18620 [label="Debug.Assert(result != null); 269223"];
18621 [label="param GetLeadingTrivia(this) 269224"];
18622 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 269225"];
18623 [label="param AreNullableAnnotationsEnabled(int position) 269226"];
18624 [label="param AreNullableAnnotationsEnabled(this) 269227"];
18625 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 269228"];
18626 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 269229"];
18627 [label="csTree.GetNullableContextState(position) 269230"];
18628 [label="param GetNullableContextState(int position) 269231"];
18629 [label="=> GetNullableContextStateMap().GetContextState(position) 269232"];
18630 [label="GetNullableContextStateMap() 269233"];
18631 [label="param GetNullableContextStateMap(this) 269234"];
18632 [label="if (_lazyNullableContextStateMap == null)\n            {\n                // Create the #nullable directive map on demand.\n                Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null);\n            } 269235"];
18633 [label="if (_lazyNullableContextStateMap == null)\n            {\n                // Create the #nullable directive map on demand.\n                Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null);\n            } 269236"];
18634 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269237"];
18635 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269238"];
18636 [label="NullableContextStateMap.Create(this) 269239"];
18637 [label="param Create(SyntaxTree tree) 269240"];
18638 [label="var contexts = GetContexts(tree); 269241"];
18639 [label="GetContexts(tree) 269242"];
18640 [label="param GetContexts(SyntaxTree tree) 269243"];
18641 [label="GetContextForFileStart() 269244"];
18642 [label="0 269245"];
18643 [label="position: 0 269246"];
18644 [label="warningsState: NullableContextState.State.Unknown 269247"];
18645 [label="annotationsState: NullableContextState.State.Unknown 269248"];
18646 [label="new NullableContextState(\n                position: 0,\n                warningsState: NullableContextState.State.Unknown,\n                annotationsState: NullableContextState.State.Unknown) 269249"];
18647 [label="param NullableContextState(int position) 269250"];
18648 [label="param NullableContextState(State warningsState) 269251"];
18649 [label="param NullableContextState(State annotationsState) 269252"];
18650 [label="param NullableContextState(this) 269253"];
18651 [label="Position 269254"];
18652 [label="WarningsState 269255"];
18653 [label="AnnotationsState 269256"];
18654 [label="var previousContext = GetContextForFileStart(); 269257"];
18655 [label="var builder = ArrayBuilder<NullableContextState>.GetInstance(); 269258"];
18656 [label="foreach (var d in tree.GetRoot().GetDirectives())\n            {\n                if (d.Kind() != SyntaxKind.NullableDirectiveTrivia)\n                {\n                    continue;\n                }\n                var nn = (NullableDirectiveTriviaSyntax)d;\n                if (nn.SettingToken.IsMissing || !nn.IsActive)\n                {\n                    continue;\n                }\n\n                var position = nn.EndPosition;\n                var setting = (nn.SettingToken.Kind()) switch\n                {\n                    SyntaxKind.EnableKeyword => NullableContextState.State.Enabled,\n                    SyntaxKind.DisableKeyword => NullableContextState.State.Disabled,\n                    SyntaxKind.RestoreKeyword => NullableContextState.State.ExplicitlyRestored,\n                    var kind => throw ExceptionUtilities.UnexpectedValue(kind),\n                };\n\n                var context = nn.TargetToken.Kind() switch\n                {\n                    SyntaxKind.None => new NullableContextState(position, setting, setting),\n                    SyntaxKind.WarningsKeyword => new NullableContextState(position, warningsState: setting, annotationsState: previousContext.AnnotationsState),\n                    SyntaxKind.AnnotationsKeyword => new NullableContextState(position, warningsState: previousContext.WarningsState, annotationsState: setting),\n                    var kind => throw ExceptionUtilities.UnexpectedValue(kind)\n                };\n\n                builder.Add(context);\n                previousContext = context;\n            } 269259"];
18657 [label="foreach (var d in tree.GetRoot().GetDirectives())\n            {\n                if (d.Kind() != SyntaxKind.NullableDirectiveTrivia)\n                {\n                    continue;\n                }\n                var nn = (NullableDirectiveTriviaSyntax)d;\n                if (nn.SettingToken.IsMissing || !nn.IsActive)\n                {\n                    continue;\n                }\n\n                var position = nn.EndPosition;\n                var setting = (nn.SettingToken.Kind()) switch\n                {\n                    SyntaxKind.EnableKeyword => NullableContextState.State.Enabled,\n                    SyntaxKind.DisableKeyword => NullableContextState.State.Disabled,\n                    SyntaxKind.RestoreKeyword => NullableContextState.State.ExplicitlyRestored,\n                    var kind => throw ExceptionUtilities.UnexpectedValue(kind),\n                };\n\n                var context = nn.TargetToken.Kind() switch\n                {\n                    SyntaxKind.None => new NullableContextState(position, setting, setting),\n                    SyntaxKind.WarningsKeyword => new NullableContextState(position, warningsState: setting, annotationsState: previousContext.AnnotationsState),\n                    SyntaxKind.AnnotationsKeyword => new NullableContextState(position, warningsState: previousContext.WarningsState, annotationsState: setting),\n                    var kind => throw ExceptionUtilities.UnexpectedValue(kind)\n                };\n\n                builder.Add(context);\n                previousContext = context;\n            } 269260"];
18658 [label="param GetRoot(CancellationToken cancellationToken) 269261"];
18659 [label="tree.GetRoot().GetDirectives() 269262"];
18660 [label="param GetDirectives(this SyntaxNode node) 269263"];
18661 [label="param GetDirectives(Func<DirectiveTriviaSyntax, bool>? filter = null) 269264"];
18662 [label="return ((CSharpSyntaxNode)node).GetDirectives(filter); 269265"];
18663 [label="((CSharpSyntaxNode)node).GetDirectives(filter) 269266"];
18664 [label="param GetDirectives(Func<DirectiveTriviaSyntax, bool>? filter = null) 269267"];
18665 [label="param GetDirectives(this) 269268"];
18666 [label="return ((SyntaxNodeOrToken)this).GetDirectives<DirectiveTriviaSyntax>(filter); 269269"];
18667 [label="return ((SyntaxNodeOrToken)this).GetDirectives<DirectiveTriviaSyntax>(filter); 269270"];
18668 [label="return builder.ToImmutableAndFree(); 269271"];
18669 [label="var contexts = GetContexts(tree); 269272"];
18670 [label="return new NullableContextStateMap(contexts); 269273"];
18671 [label="return new NullableContextStateMap(contexts); 269274"];
18672 [label="new NullableContextStateMap(contexts) 269275"];
18673 [label="param NullableContextStateMap(ImmutableArray<NullableContextState> contexts) 269276"];
18674 [label="param NullableContextStateMap(this) 269277"];
18675 [label="for (int i = 1; i < contexts.Length; i++)\n            {\n                Debug.Assert(contexts[i - 1].Position < contexts[i].Position);\n            } 269278"];
18676 [label="for (int i = 1; i < contexts.Length; i++)\n            {\n                Debug.Assert(contexts[i - 1].Position < contexts[i].Position);\n            } 269279"];
18677 [label="_contexts 269280"];
18678 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269281"];
18679 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269282"];
18680 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269283"];
18681 [label="Interlocked.CompareExchange(\n                    ref _lazyNullableContextStateMap,\n                    new StrongBox<NullableContextStateMap>(NullableContextStateMap.Create(this)),\n                    null); 269284"];
18682 [label="return _lazyNullableContextStateMap.Value; 269285"];
18683 [label="position 269286"];
18684 [label="GetNullableContextStateMap().GetContextState(position) 269287"];
18685 [label="param GetContextState(int position) 269288"];
18686 [label="param GetContextState(this) 269289"];
18687 [label="var index = GetContextStateIndex(position); 269290"];
18688 [label="GetContextStateIndex(position) 269291"];
18689 [label="param GetContextStateIndex(int position) 269292"];
18690 [label="param GetContextStateIndex(this) 269293"];
18691 [label="var searchContext = new NullableContextState(position, warningsState: NullableContextState.State.Unknown, annotationsState: NullableContextState.State.Unknown); 269294"];
18692 [label="var searchContext = new NullableContextState(position, warningsState: NullableContextState.State.Unknown, annotationsState: NullableContextState.State.Unknown); 269295"];
18693 [label="var searchContext = new NullableContextState(position, warningsState: NullableContextState.State.Unknown, annotationsState: NullableContextState.State.Unknown); 269296"];
18694 [label="new NullableContextState(position, warningsState: NullableContextState.State.Unknown, annotationsState: NullableContextState.State.Unknown) 269297"];
18695 [label="param NullableContextState(int position) 269298"];
18696 [label="param NullableContextState(State warningsState) 269299"];
18697 [label="param NullableContextState(State annotationsState) 269300"];
18698 [label="param NullableContextState(this) 269301"];
18699 [label="Position 269302"];
18700 [label="WarningsState 269303"];
18701 [label="AnnotationsState 269304"];
18702 [label="new PositionComparer() 269305"];
18703 [label="param PositionComparer(this) 269306"];
18704 [label="Instance = new PositionComparer() 269307"];
18705 [label="int index = _contexts.BinarySearch(searchContext, PositionComparer.Instance); 269308"];
18706 [label="int index = _contexts.BinarySearch(searchContext, PositionComparer.Instance); 269309"];
18707 [label="int index = _contexts.BinarySearch(searchContext, PositionComparer.Instance); 269310"];
18708 [label="int index = _contexts.BinarySearch(searchContext, PositionComparer.Instance); 269311"];
18709 [label="if (index < 0)\n            {\n                // If no exact match, BinarySearch returns the complement\n                // of the index of the next higher value.\n                index = ~index - 1;\n            } 269312"];
18710 [label="if (index < 0)\n            {\n                // If no exact match, BinarySearch returns the complement\n                // of the index of the next higher value.\n                index = ~index - 1;\n            } 269313"];
18711 [label="index = ~index - 1; 269314"];
18712 [label="Debug.Assert(index >= -1); 269315"];
18713 [label="Debug.Assert(index >= -1); 269316"];
18714 [label="Debug.Assert(index < _contexts.Length); 269317"];
18715 [label="if (index >= 0)\n            {\n                Debug.Assert(_contexts[index].Position <= position);\n                Debug.Assert(index == _contexts.Length - 1 || position < _contexts[index + 1].Position);\n            } 269318"];
18716 [label="if (index >= 0)\n            {\n                Debug.Assert(_contexts[index].Position <= position);\n                Debug.Assert(index == _contexts.Length - 1 || position < _contexts[index + 1].Position);\n            } 269319"];
18717 [label="return index; 269320"];
18718 [label="return index < 0 ? GetContextForFileStart() : _contexts[index]; 269321"];
18719 [label="return index < 0 ? GetContextForFileStart() : _contexts[index]; 269322"];
18720 [label="index < 0 269323"];
18721 [label="GetContextForFileStart() 269324"];
18722 [label="0 269325"];
18723 [label="position: 0 269326"];
18724 [label="warningsState: NullableContextState.State.Unknown 269327"];
18725 [label="annotationsState: NullableContextState.State.Unknown 269328"];
18726 [label="new NullableContextState(\n                position: 0,\n                warningsState: NullableContextState.State.Unknown,\n                annotationsState: NullableContextState.State.Unknown) 269329"];
18727 [label="param NullableContextState(int position) 269330"];
18728 [label="param NullableContextState(State warningsState) 269331"];
18729 [label="param NullableContextState(State annotationsState) 269332"];
18730 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 269333"];
18731 [label="this.Compilation.Options 269334"];
18732 [label="get\n            {\n                return _options;\n            } 269335"];
18733 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 269336"];
18734 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 269337"];
18735 [label="csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None) 269338"];
18736 [label="param IsGeneratedCode(SyntaxTreeOptionsProvider? provider) 269339"];
18737 [label="param IsGeneratedCode(CancellationToken cancellationToken) 269340"];
18738 [label="param IsGeneratedCode(this) 269341"];
18739 [label="return provider?.IsGenerated(this, cancellationToken) switch\n            {\n                null or GeneratedKind.Unknown => isGeneratedHeuristic(),\n                GeneratedKind kind => kind != GeneratedKind.NotGenerated\n            }; 269342"];
18740 [label="provider?.IsGenerated(this, cancellationToken) switch\n            {\n                null or GeneratedKind.Unknown => isGeneratedHeuristic(),\n                GeneratedKind kind => kind != GeneratedKind.NotGenerated\n            } 269343"];
18741 [label="isGeneratedHeuristic() 269344"];
18742 [label="bool isGeneratedHeuristic()\n            {\n                if (_lazyIsGeneratedCode == GeneratedKind.Unknown)\n                {\n                    // Create the generated code status on demand\n                    bool isGenerated = GeneratedCodeUtilities.IsGeneratedCode(\n                            this,\n                            isComment: trivia => trivia.Kind() == SyntaxKind.SingleLineCommentTrivia || trivia.Kind() == SyntaxKind.MultiLineCommentTrivia,\n                            cancellationToken: default);\n                    _lazyIsGeneratedCode = isGenerated ? GeneratedKind.MarkedGenerated : GeneratedKind.NotGenerated;\n                }\n\n                return _lazyIsGeneratedCode == GeneratedKind.MarkedGenerated;\n            } 269345"];
18743 [label="if (_lazyIsGeneratedCode == GeneratedKind.Unknown)\n                {\n                    // Create the generated code status on demand\n                    bool isGenerated = GeneratedCodeUtilities.IsGeneratedCode(\n                            this,\n                            isComment: trivia => trivia.Kind() == SyntaxKind.SingleLineCommentTrivia || trivia.Kind() == SyntaxKind.MultiLineCommentTrivia,\n                            cancellationToken: default);\n                    _lazyIsGeneratedCode = isGenerated ? GeneratedKind.MarkedGenerated : GeneratedKind.NotGenerated;\n                } 269346"];
18744 [label="bool isGenerated = GeneratedCodeUtilities.IsGeneratedCode(\n                            this,\n                            isComment: trivia => trivia.Kind() == SyntaxKind.SingleLineCommentTrivia || trivia.Kind() == SyntaxKind.MultiLineCommentTrivia,\n                            cancellationToken: default); 269347"];
18745 [label="bool isGenerated = GeneratedCodeUtilities.IsGeneratedCode(\n                            this,\n                            isComment: trivia => trivia.Kind() == SyntaxKind.SingleLineCommentTrivia || trivia.Kind() == SyntaxKind.MultiLineCommentTrivia,\n                            cancellationToken: default); 269348"];
18746 [label="bool isGenerated = GeneratedCodeUtilities.IsGeneratedCode(\n                            this,\n                            isComment: trivia => trivia.Kind() == SyntaxKind.SingleLineCommentTrivia || trivia.Kind() == SyntaxKind.MultiLineCommentTrivia,\n                            cancellationToken: default); 269349"];
18747 [label="get { return _path; } 269350"];
18748 [label="return _path; 269351"];
18749 [label="param GetRoot(CancellationToken cancellationToken) 269352"];
18750 [label="=> true 269353"];
18751 [label="param GetLeadingTriviaCore(this) 269354"];
18752 [label="this.GetLeadingTrivia() 269355"];
18753 [label="param GetLeadingTrivia(this) 269356"];
18754 [label="return this.LeadingField; 269357"];
18755 [label="return this.GetLeadingTrivia(); 269358"];
18756 [label="param Kind(this SyntaxTrivia trivia) 269359"];
18757 [label="var rawKind = trivia.RawKind; 269360"];
18758 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 269361"];
18759 [label="IsCSharpKind(rawKind) 269362"];
18760 [label="param IsCSharpKind(int rawKind) 269363"];
18761 [label="isGenerated 269364"];
18762 [label="_lazyIsGeneratedCode = isGenerated ? GeneratedKind.MarkedGenerated : GeneratedKind.NotGenerated; 269365"];
18763 [label="_lazyIsGeneratedCode 269366"];
18764 [label="return _lazyIsGeneratedCode == GeneratedKind.MarkedGenerated; 269367"];
18765 [label="AreNullableAnnotationsGloballyEnabled() 269368"];
18766 [label="param AreNullableAnnotationsGloballyEnabled(this) 269369"];
18767 [label="RoslynDebug.Assert(Next is object); 269370"];
18768 [label="RoslynDebug.Assert(Next is object); 269371"];
18769 [label="Next.AreNullableAnnotationsGloballyEnabled() 269372"];
18770 [label="param AreNullableAnnotationsGloballyEnabled(this) 269373"];
18771 [label="param AreNullableAnnotationsGloballyEnabled(this) 269374"];
18772 [label="GetGlobalAnnotationState() 269375"];
18773 [label="param GetGlobalAnnotationState(this) 269376"];
18774 [label="Compilation.Options 269377"];
18775 [label="get\n            {\n                return _options;\n            } 269378"];
18776 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 269379"];
18777 [label="return false; 269380"];
18778 [label="return GetGlobalAnnotationState(); 269381"];
18779 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 269382"];
18780 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 269383"];
18781 [label="return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult); 269384"];
18782 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(AreNullableAnnotationsEnabled(node.Identifier), bindingResult) 269385"];
18783 [label="param CreateUnannotated(bool isNullableEnabled) 269386"];
18784 [label="param CreateUnannotated(Symbol symbol) 269387"];
18785 [label="if (symbol is null)\n                {\n                    return default;\n                } 269388"];
18786 [label="var type = symbol as TypeSymbol; 269389"];
18787 [label="return type is null ?\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(symbol, isNullableEnabled) :\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)); 269390"];
18788 [label="type is null 269391"];
18789 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 269392"];
18790 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 269393"];
18791 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 269394"];
18792 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 269395"];
18793 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 269396"];
18794 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 269397"];
18795 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 269398"];
18796 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 269399"];
18797 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 269400"];
18798 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 269401"];
18799 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 269402"];
18800 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 269403"];
18801 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 269404"];
18802 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 269405"];
18803 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 269406"];
18804 [label="return type is null ?\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(symbol, isNullableEnabled) :\n                    new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)); 269407"];
18805 [label="TypeWithAnnotations.Create(isNullableEnabled, type) 269408"];
18806 [label="param Create(bool isNullableEnabled) 269409"];
18807 [label="param Create(TypeSymbol typeSymbol) 269410"];
18808 [label="param Create(bool isAnnotated = false) 269411"];
18809 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 269412"];
18810 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 269413"];
18811 [label="isAnnotated 269414"];
18812 [label="isNullableEnabled 269415"];
18813 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 269416"];
18814 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 269417"];
18815 [label="Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious) 269418"];
18816 [label="param Create(TypeSymbol typeSymbol) 269419"];
18817 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 269420"];
18818 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 269421"];
18819 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 269422"];
18820 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 269423"];
18821 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 269424"];
18822 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 269425"];
18823 [label="'Expressions' 269426"];
18824 [label="'Linq' 269427"];
18825 [label="'' 269428"];
18826 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 269429"];
18827 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 269430"];
18828 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 269431"];
18829 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 269432"];
18830 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 269433"];
18831 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 269434"];
18832 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 269435"];
18833 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 269436"];
18834 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 269437"];
18835 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 269438"];
18836 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 269439"];
18837 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 269440"];
18838 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 269441"];
18839 [label="typeSymbol.IsNullableType() 269442"];
18840 [label="param IsNullableType(this TypeSymbol type) 269443"];
18841 [label="type.OriginalDefinition 269444"];
18842 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 269445"];
18843 [label="OriginalTypeSymbolDefinition 269446"];
18844 [label="get\n            {\n                return this.OriginalDefinition;\n            } 269447"];
18845 [label="this.OriginalDefinition 269448"];
18846 [label="get\n            {\n                return this;\n            } 269449"];
18847 [label="return this.OriginalDefinition; 269450"];
18848 [label="return OriginalTypeSymbolDefinition; 269451"];
18849 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 269452"];
18850 [label="type.OriginalDefinition.SpecialType 269453"];
18851 [label="get\n            {\n                return _flags.SpecialType;\n            } 269454"];
18852 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 269455"];
18853 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 269456"];
18854 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 269457"];
18855 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 269458"];
18856 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 269459"];
18857 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 269460"];
18858 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 269461"];
18859 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 269462"];
18860 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 269463"];
18861 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 269464"];
18862 [label="param NonLazyType(this) 269465"];
18863 [label="param Extensions(this) 269466"];
18864 [label="Debug.Assert(!customModifiers.IsDefault); 269467"];
18865 [label="_customModifiers 269468"];
18866 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 269469"];
18867 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 269470"];
18868 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 269471"];
18869 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 269472"];
18870 [label="Extensions.Create(customModifiers) 269473"];
18871 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 269474"];
18872 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 269475"];
18873 [label="return Default; 269476"];
18874 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 269477"];
18875 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 269478"];
18876 [label="param TypeWithAnnotations(TypeSymbol defaultType) 269479"];
18877 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 269480"];
18878 [label="param TypeWithAnnotations(Extensions extensions) 269481"];
18879 [label="param TypeWithAnnotations(this) 269482"];
18880 [label="var a1 = defaultType is null; 269483"];
18881 [label="!a1 269484"];
18882 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 269485"];
18883 [label="defaultType.IsNullableType() 269486"];
18884 [label="param IsNullableType(this TypeSymbol type) 269487"];
18885 [label="type.OriginalDefinition 269488"];
18886 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 269489"];
18887 [label="OriginalTypeSymbolDefinition 269490"];
18888 [label="get\n            {\n                return this.OriginalDefinition;\n            } 269491"];
18889 [label="this.OriginalDefinition 269492"];
18890 [label="get\n            {\n                return this;\n            } 269493"];
18891 [label="return this.OriginalDefinition; 269494"];
18892 [label="return OriginalTypeSymbolDefinition; 269495"];
18893 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 269496"];
18894 [label="type.OriginalDefinition.SpecialType 269497"];
18895 [label="get\n            {\n                return _flags.SpecialType;\n            } 269498"];
18896 [label="_flags.SpecialType 269499"];
18897 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 269500"];
18898 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 269501"];
18899 [label="Debug.Assert(a1 || a2 != true || a3); 269502"];
18900 [label="Debug.Assert(a1 || a2 != true || a3); 269503"];
18901 [label="Debug.Assert(extensions != null); 269504"];
18902 [label="Debug.Assert(extensions != null); 269505"];
18903 [label="DefaultType 269506"];
18904 [label="NullableAnnotation 269507"];
18905 [label="_extensions 269508"];
18906 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 269509"];
18907 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 269510"];
18908 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations.Create(isNullableEnabled, type)) 269511"];
18909 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 269512"];
18910 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 269513"];
18911 [label="typeWithAnnotations.HasType 269514"];
18912 [label="=> !(DefaultType is null) 269515"];
18913 [label="DefaultType is null 269516"];
18914 [label="!(DefaultType is null) 269517"];
18915 [label="Debug.Assert(typeWithAnnotations.HasType); 269518"];
18916 [label="_typeWithAnnotations 269519"];
18917 [label="_symbol = null; 269520"];
18918 [label="_symbol 269521"];
18919 [label="_isNullableEnabled = false; 269522"];
18920 [label="_isNullableEnabled 269523"];
18921 [label="symbol.IsType 269524"];
18922 [label="=> !_typeWithAnnotations.IsDefault 269525"];
18923 [label="_typeWithAnnotations.IsDefault 269526"];
18924 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 269527"];
18925 [label="DefaultType is null 269528"];
18926 [label="DefaultType is null && this.NullableAnnotation == 0 269529"];
18927 [label="DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 269530"];
18928 [label="!_typeWithAnnotations.IsDefault 269531"];
18929 [label="if (symbol.IsType ||\n                (symbol.IsAlias && UnwrapAliasNoDiagnostics(symbol.Symbol, basesBeingResolved) is TypeSymbol))\n            {\n                if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                }\n\n                return symbol;\n            } 269532"];
18930 [label="symbol.IsType 269533"];
18931 [label="if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                } 269534"];
18932 [label="symbol.TypeWithAnnotations 269535"];
18933 [label="=> _typeWithAnnotations 269536"];
18934 [label="_typeWithAnnotations 269537"];
18935 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 269538"];
18936 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 269539"];
18937 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 269540"];
18938 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 269541"];
18939 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics) 269542"];
18940 [label="param ReportDiagnosticsIfObsolete(Binder binder) 269543"];
18941 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 269544"];
18942 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 269545"];
18943 [label="=>\n            _extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 269546"];
18944 [label="this 269547"];
18945 [label="binder 269548"];
18946 [label="syntax 269549"];
18947 [label="diagnostics 269550"];
18948 [label="_extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 269551"];
18949 [label="param ReportDiagnosticsIfObsolete(TypeWithAnnotations type) 269552"];
18950 [label="param ReportDiagnosticsIfObsolete(Binder binder) 269553"];
18951 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 269554"];
18952 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 269555"];
18953 [label="param ReportDiagnosticsIfObsolete(this) 269556"];
18954 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 269557"];
18955 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 269558"];
18956 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 269559"];
18957 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics) 269560"];
18958 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 269561"];
18959 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 269562"];
18960 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 269563"];
18961 [label="param ReportDiagnosticsIfObsoleteCore(this) 269564"];
18962 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 269565"];
18963 [label="Type 269566"];
18964 [label="=> _extensions?.GetResolvedType(DefaultType) 269567"];
18965 [label="DefaultType 269568"];
18966 [label=".GetResolvedType(DefaultType) 269569"];
18967 [label="param GetResolvedType(TypeSymbol defaultType) 269570"];
18968 [label="=> defaultType 269571"];
18969 [label="defaultType 269572"];
18970 [label="_extensions?.GetResolvedType(DefaultType) 269573"];
18971 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 269574"];
18972 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 269575"];
18973 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 269576"];
18974 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false) 269577"];
18975 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 269578"];
18976 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 269579"];
18977 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 269580"];
18978 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 269581"];
18979 [label="param ReportDiagnosticsIfObsolete(this) 269582"];
18980 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 269583"];
18981 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 269584"];
18982 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 269585"];
18983 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 269586"];
18984 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver) 269587"];
18985 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 269588"];
18986 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 269589"];
18987 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 269590"];
18988 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 269591"];
18989 [label="param ReportDiagnosticsIfObsolete(this) 269592"];
18990 [label="symbol.Kind 269593"];
18991 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269594"];
18992 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Event:\n                case SymbolKind.Property:\n                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags);\n                    break;\n            } 269595"];
18993 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269596"];
18994 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269597"];
18995 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269598"];
18996 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269599"];
18997 [label="this.ContainingMemberOrLambda 269600"];
18998 [label="get { return _containingMemberOrLambda; } 269601"];
18999 [label="return _containingMemberOrLambda; 269602"];
19000 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269603"];
19001 [label="this.ContainingType 269604"];
19002 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 269605"];
19003 [label="this.ContainingMemberOrLambda 269606"];
19004 [label="get { return _containingMemberOrLambda; } 269607"];
19005 [label="return _containingMemberOrLambda; 269608"];
19006 [label="var member = this.ContainingMemberOrLambda; 269609"];
19007 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 269610"];
19008 [label="member.Kind 269611"];
19009 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269612"];
19010 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 269613"];
19011 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 269614"];
19012 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 269615"];
19013 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 269616"];
19014 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269617"];
19015 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269618"];
19016 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags) 269619"];
19017 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 269620"];
19018 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 269621"];
19019 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 269622"];
19020 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 269623"];
19021 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 269624"];
19022 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 269625"];
19023 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 269626"];
19024 [label="RoslynDebug.Assert(symbol is object); 269627"];
19025 [label="RoslynDebug.Assert(symbol is object); 269628"];
19026 [label="symbol.Kind 269629"];
19027 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269630"];
19028 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 269631"];
19029 [label="symbol.Kind 269632"];
19030 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269633"];
19031 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 269634"];
19032 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 269635"];
19033 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 269636"];
19034 [label="symbol.GetLeastOverriddenMember(containingType) 269637"];
19035 [label="param GetLeastOverriddenMember(this Symbol member) 269638"];
19036 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 269639"];
19037 [label="member.Kind 269640"];
19038 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 269641"];
19039 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    var method = (MethodSymbol)member;\n                    return method.GetConstructedLeastOverriddenMethod(accessingTypeOpt, requireSameReturnType: false);\n\n                case SymbolKind.Property:\n                    var property = (PropertySymbol)member;\n                    return property.GetLeastOverriddenProperty(accessingTypeOpt);\n\n                case SymbolKind.Event:\n                    var evnt = (EventSymbol)member;\n                    return evnt.GetLeastOverriddenEvent(accessingTypeOpt);\n\n                default:\n                    return member;\n            } 269642"];
19040 [label="return member; 269643"];
19041 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 269644"];
19042 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 269645"];
19043 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269646"];
19044 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269647"];
19045 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269648"];
19046 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269649"];
19047 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269650"];
19048 [label="ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location) 269651"];
19049 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 269652"];
19050 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol symbol) 269653"];
19051 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 269654"];
19052 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 269655"];
19053 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 269656"];
19054 [label="RoslynDebug.Assert(diagnostics != null); 269657"];
19055 [label="RoslynDebug.Assert(diagnostics != null); 269658"];
19056 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 269659"];
19057 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 269660"];
19058 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 269661"];
19059 [label="ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember) 269662"];
19060 [label="param GetObsoleteDiagnosticKind(Symbol symbol) 269663"];
19061 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 269664"];
19062 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 269665"];
19063 [label="symbol.ObsoleteKind 269666"];
19064 [label="get\n            {\n                var data = this.ObsoleteAttributeData;\n                return (data == null) ? ObsoleteAttributeKind.None : data.Kind;\n            } 269667"];
19065 [label="this.ObsoleteAttributeData 269668"];
19066 [label="get\n            {\n                var lazyCustomAttributesBag = _lazyCustomAttributesBag;\n                if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                }\n\n                foreach (var decl in this.declaration.Declarations)\n                {\n                    if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    }\n                }\n\n                return null;\n            } 269669"];
19067 [label="var lazyCustomAttributesBag = _lazyCustomAttributesBag; 269670"];
19068 [label="if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                } 269671"];
19069 [label="if (lazyCustomAttributesBag != null && lazyCustomAttributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n                {\n                    var data = (CommonTypeEarlyWellKnownAttributeData)lazyCustomAttributesBag.EarlyDecodedWellKnownAttributeData;\n                    return data != null ? data.ObsoleteAttributeData : null;\n                } 269672"];
19070 [label="this.declaration.Declarations 269673"];
19071 [label="get\n            {\n                return _declarations;\n            } 269674"];
19072 [label="foreach (var decl in this.declaration.Declarations)\n                {\n                    if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    }\n                } 269675"];
19073 [label="decl.HasAnyAttributes 269676"];
19074 [label="get\n            {\n                return (_flags & TypeDeclarationFlags.HasAnyAttributes) != 0;\n            } 269677"];
19075 [label="return (_flags & TypeDeclarationFlags.HasAnyAttributes) != 0; 269678"];
19076 [label="return (_flags & TypeDeclarationFlags.HasAnyAttributes) != 0; 269679"];
19077 [label="if (decl.HasAnyAttributes)\n                    {\n                        return ObsoleteAttributeData.Uninitialized;\n                    } 269680"];
19078 [label="return null; 269681"];
19079 [label="var data = this.ObsoleteAttributeData; 269682"];
19080 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 269683"];
19081 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 269684"];
19082 [label="(data == null) 269685"];
19083 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 269686"];
19084 [label="return ObsoleteDiagnosticKind.NotObsolete; 269687"];
19085 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 269688"];
19086 [label="DiagnosticInfo? info = null; 269689"];
19087 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 269690"];
19088 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 269691"];
19089 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 269692"];
19090 [label="return kind; 269693"];
19091 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 269694"];
19092 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 269695"];
19093 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 269696"];
19094 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 269697"];
19095 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 269698"];
19096 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 269699"];
19097 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 269700"];
19098 [label="return symbol; 269701"];
19099 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 269702"];
19100 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 269703"];
19101 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 269704"];
19102 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 269705"];
19103 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 269706"];
19104 [label="param UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol) 269707"];
19105 [label="param UnwrapAlias(DiagnosticBag diagnostics) 269708"];
19106 [label="param UnwrapAlias(SyntaxNode syntax) 269709"];
19107 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 269710"];
19108 [label="param UnwrapAlias(this) 269711"];
19109 [label="symbol.IsAlias 269712"];
19110 [label="=> _symbol?.Kind == SymbolKind.Alias 269713"];
19111 [label="_symbol 269714"];
19112 [label="_symbol?.Kind == SymbolKind.Alias 269715"];
19113 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 269716"];
19114 [label="return symbol; 269717"];
19115 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 269718"];
19116 [label="=> _typeWithAnnotations 269719"];
19117 [label="_typeWithAnnotations 269720"];
19118 [label="type.IsStatic 269721"];
19119 [label="=>\n            _extensions.IsStatic(DefaultType) 269722"];
19120 [label="DefaultType 269723"];
19121 [label="_extensions.IsStatic(DefaultType) 269724"];
19122 [label="param IsStatic(TypeSymbol typeSymbol) 269725"];
19123 [label="=> typeSymbol.IsStatic 269726"];
19124 [label="typeSymbol.IsStatic 269727"];
19125 [label="=> HasFlag(DeclarationModifiers.Static) 269728"];
19126 [label="DeclarationModifiers.Static 269729"];
19127 [label="HasFlag(DeclarationModifiers.Static) 269730"];
19128 [label="param HasFlag(DeclarationModifiers flag) 269731"];
19129 [label="=> (_declModifiers & flag) != 0 269732"];
19130 [label="_declModifiers & flag 269733"];
19131 [label="0 269734"];
19132 [label="(_declModifiers & flag) != 0 269735"];
19133 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 269736"];
19134 [label="if (disallowRestrictedTypes)\n            {\n                // Restricted types cannot be on the heap, but they can be on the stack, so are allowed in a stackalloc\n                if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                }\n            } 269737"];
19135 [label="ShouldCheckConstraints 269738"];
19136 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 269739"];
19137 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 269740"];
19138 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 269741"];
19139 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 269742"];
19140 [label="param Includes(this BinderFlags self) 269743"];
19141 [label="param Includes(BinderFlags other) 269744"];
19142 [label="if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                } 269745"];
19143 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 269746"];
19144 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 269747"];
19145 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 269748"];
19146 [label="new LazyArrayElementCantBeRefAnyDiagnosticInfo(type) 269749"];
19147 [label="param LazyArrayElementCantBeRefAnyDiagnosticInfo(TypeWithAnnotations possiblyRestrictedTypeSymbol) 269750"];
19148 [label="param LazyArrayElementCantBeRefAnyDiagnosticInfo(this) 269751"];
19149 [label="param LazyArrayElementCantBeRefAnyDiagnosticInfo(this) 269752"];
19150 [label="param LazyDiagnosticInfo(this) 269753"];
19151 [label="CSharp.MessageProvider.Instance 269754"];
19152 [label="ErrorCode.Unknown 269755"];
19153 [label="param LazyDiagnosticInfo(this) 269756"];
19154 [label="param LazyDiagnosticInfo(this) 269757"];
19155 [label="param GetSeverity(this) 269758"];
19156 [label="return InternalDiagnosticSeverity.Unknown; 269759"];
19157 [label="_lazyInfo 269760"];
19158 [label="_possiblyRestrictedTypeSymbol 269761"];
19159 [label="node.ElementType.GetLocation() 269762"];
19160 [label="param GetLocation(this) 269763"];
19161 [label="return new SourceLocation(this); 269764"];
19162 [label="Debug.Assert(result != null); 269765"];
19163 [label="Debug.Assert(result != null); 269766"];
19164 [label="param GetLeadingTrivia(this) 269767"];
19165 [label="param GetTrailingTrivia(this) 269768"];
19166 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()) 269769"];
19167 [label="param Add(this DiagnosticBag diagnostics) 269770"];
19168 [label="param Add(DiagnosticInfo info) 269771"];
19169 [label="param Add(Location location) 269772"];
19170 [label="var diag = new CSDiagnostic(info, location); 269773"];
19171 [label="var diag = new CSDiagnostic(info, location); 269774"];
19172 [label="var diag = new CSDiagnostic(info, location); 269775"];
19173 [label="new CSDiagnostic(info, location) 269776"];
19174 [label="param CSDiagnostic(DiagnosticInfo info) 269777"];
19175 [label="param CSDiagnostic(Location location) 269778"];
19176 [label="param CSDiagnostic(bool isSuppressed = false) 269779"];
19177 [label="param CSDiagnostic(this) 269780"];
19178 [label="param CSDiagnostic(this) 269781"];
19179 [label="diagnostics.Add(diag); 269782"];
19180 [label="diagnostics.Add(diag); 269783"];
19181 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 269784"];
19182 [label="node.RankSpecifiers 269785"];
19183 [label="param CSharpSyntaxNode(GreenNode green) 269786"];
19184 [label="param CSharpSyntaxNode(SyntaxNode? parent) 269787"];
19185 [label="param CSharpSyntaxNode(int position) 269788"];
19186 [label="param CSharpSyntaxNode(this) 269789"];
19187 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 269790"];
19188 [label="var rankSpecifier = node.RankSpecifiers[i]; 269791"];
19189 [label="var dimension = rankSpecifier.Sizes; 269792"];
19190 [label="rankSpecifier.Sizes 269793"];
19191 [label="param CSharpSyntaxNode(GreenNode green) 269794"];
19192 [label="param CSharpSyntaxNode(SyntaxNode? parent) 269795"];
19193 [label="param CSharpSyntaxNode(int position) 269796"];
19194 [label="param CSharpSyntaxNode(this) 269797"];
19195 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 269798"];
19196 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 269799"];
19197 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 269800"];
19198 [label="dimension[0].Kind() 269801"];
19199 [label="param Kind(this) 269802"];
19200 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 269803"];
19201 [label="this.Compilation.Assembly 269804"];
19202 [label="get\n            {\n                return SourceAssembly;\n            } 269805"];
19203 [label="GetBoundReferenceManager(); 269806"];
19204 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 269807"];
19205 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 269808"];
19206 [label="rankSpecifier.Rank 269809"];
19207 [label="get\n            {\n                return this.Sizes.Count;\n            } 269810"];
19208 [label="return this.Sizes.Count; 269811"];
19209 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 269812"];
19210 [label="ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank) 269813"];
19211 [label="param CreateCSharpArray(AssemblySymbol declaringAssembly) 269814"];
19212 [label="param CreateCSharpArray(TypeWithAnnotations elementTypeWithAnnotations) 269815"];
19213 [label="param CreateCSharpArray(int rank = 1) 269816"];
19214 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 269817"];
19215 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 269818"];
19216 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 269819"];
19217 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 269820"];
19218 [label="CreateSZArray(declaringAssembly, elementTypeWithAnnotations) 269821"];
19219 [label="param CreateSZArray(AssemblySymbol declaringAssembly) 269822"];
19220 [label="param CreateSZArray(TypeWithAnnotations elementType) 269823"];
19221 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 269824"];
19222 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 269825"];
19223 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 269826"];
19224 [label="param GetSpecialType(SpecialType type) 269827"];
19225 [label="param GetSpecialType(this) 269828"];
19226 [label="CorLibrary 269829"];
19227 [label="get\n            {\n                return _corLibrary;\n            } 269830"];
19228 [label="return CorLibrary.GetDeclaredSpecialType(type); 269831"];
19229 [label="return CorLibrary.GetDeclaredSpecialType(type); 269832"];
19230 [label="CorLibrary.GetDeclaredSpecialType(type) 269833"];
19231 [label="param GetDeclaredSpecialType(SpecialType type) 269834"];
19232 [label="param GetDeclaredSpecialType(this) 269835"];
19233 [label="this.Modules 269836"];
19234 [label="get\n            {\n                return _modules;\n            } 269837"];
19235 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 269838"];
19236 [label="module.GetReferencedAssemblies() 269839"];
19237 [label="param GetReferencedAssemblies(this) 269840"];
19238 [label="AssertReferencesInitialized() 269841"];
19239 [label="param AssertReferencesInitialized(this) 269842"];
19240 [label="Debug.Assert(_moduleReferences != null); 269843"];
19241 [label="Debug.Assert(_moduleReferences != null); 269844"];
19242 [label="AssertReferencesInitialized(); 269845"];
19243 [label="return _moduleReferences.Identities; 269846"];
19244 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 269847"];
19245 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 269848"];
19246 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 269849"];
19247 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 269850"];
19248 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 269851"];
19249 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 269852"];
19250 [label="this.Modules 269853"];
19251 [label="ModuleSymbol module = this.Modules[0]; 269854"];
19252 [label="ModuleSymbol module = this.Modules[0]; 269855"];
19253 [label="NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName); 269856"];
19254 [label="module.LookupTopLevelMetadataType(ref emittedName) 269857"];
19255 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 269858"];
19256 [label="param LookupTopLevelMetadataType(this) 269859"];
19257 [label="NamedTypeSymbol result; 269860"];
19258 [label="this.GlobalNamespace 269861"];
19259 [label="get { return _globalNamespace; } 269862"];
19260 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 269863"];
19261 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 269864"];
19262 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 269865"];
19263 [label="param LookupNestedNamespace(ImmutableArray<string> names) 269866"];
19264 [label="param LookupNestedNamespace(this) 269867"];
19265 [label="NamespaceSymbol scope = this; 269868"];
19266 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 269869"];
19267 [label="NamespaceSymbol nextScope = null; 269870"];
19268 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 269871"];
19269 [label="scope.GetMembers(name) 269872"];
19270 [label="param GetMembers(string name) 269873"];
19271 [label="param GetMembers(this) 269874"];
19272 [label="EnsureAllMembersLoaded(); 269875"];
19273 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 269876"];
19274 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 269877"];
19275 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 269878"];
19276 [label="return ImmutableArray.Create<Symbol>(ns); 269879"];
19277 [label="var ns = symbol as NamespaceSymbol; 269880"];
19278 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 269881"];
19279 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 269882"];
19280 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 269883"];
19281 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 269884"];
19282 [label="nextScope = ns; 269885"];
19283 [label="scope = nextScope; 269886"];
19284 [label="if ((object)scope == null)\n                {\n                    break;\n                } 269887"];
19285 [label="if ((object)scope == null)\n                {\n                    break;\n                } 269888"];
19286 [label="return scope; 269889"];
19287 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 269890"];
19288 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 269891"];
19289 [label="result = scope.LookupMetadataType(ref emittedName); 269892"];
19290 [label="scope.LookupMetadataType(ref emittedName) 269893"];
19291 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 269894"];
19292 [label="param LookupMetadataType(this) 269895"];
19293 [label="Debug.Assert(!emittedTypeName.IsNull); 269896"];
19294 [label="NamespaceOrTypeSymbol scope = this; 269897"];
19295 [label="scope.Kind 269898"];
19296 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 269899"];
19297 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 269900"];
19298 [label="NamedTypeSymbol? namedType = null; 269901"];
19299 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 269902"];
19300 [label="namespaceOrTypeMembers 269903"];
19301 [label="scope.IsNamespace 269904"];
19302 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 269905"];
19303 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 269906"];
19304 [label="bool isTopLevel = scope.IsNamespace; 269907"];
19305 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 269908"];
19306 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 269909"];
19307 [label="param ToDisplayString(SymbolDisplayFormat format = null) 269910"];
19308 [label="param ToDisplayString(this) 269911"];
19309 [label="ISymbol 269912"];
19310 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 269913"];
19311 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 269914"];
19312 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 269915"];
19313 [label="CreateISymbol() 269916"];
19314 [label="param CreateISymbol(this) 269917"];
19315 [label="return new PublicModel.NamespaceSymbol(this); 269918"];
19316 [label="return new PublicModel.NamespaceSymbol(this); 269919"];
19317 [label="new PublicModel.NamespaceSymbol(this) 269920"];
19318 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 269921"];
19319 [label="param NamespaceSymbol(this) 269922"];
19320 [label="param NamespaceSymbol(this) 269923"];
19321 [label="param NamespaceOrTypeSymbol(this) 269924"];
19322 [label="param NamespaceOrTypeSymbol(this) 269925"];
19323 [label="param Symbol(this) 269926"];
19324 [label="_underlying 269927"];
19325 [label="Debug.Assert(underlying is object); 269928"];
19326 [label="_underlying 269929"];
19327 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 269930"];
19328 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 269931"];
19329 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 269932"];
19330 [label="return _lazyISymbol; 269933"];
19331 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 269934"];
19332 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 269935"];
19333 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 269936"];
19334 [label="param ToDisplayString(ISymbol symbol) 269937"];
19335 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 269938"];
19336 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 269939"];
19337 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 269940"];
19338 [label="ToDisplayParts(symbol, format) 269941"];
19339 [label="param ToDisplayParts(ISymbol symbol) 269942"];
19340 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 269943"];
19341 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 269944"];
19342 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 269945"];
19343 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 269946"];
19344 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 269947"];
19345 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 269948"];
19346 [label="param ToDisplayParts(ISymbol symbol) 269949"];
19347 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 269950"];
19348 [label="param ToDisplayParts(int positionOpt) 269951"];
19349 [label="param ToDisplayParts(SymbolDisplayFormat format) 269952"];
19350 [label="param ToDisplayParts(bool minimal) 269953"];
19351 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 269954"];
19352 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 269955"];
19353 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 269956"];
19354 [label="Debug.Assert(semanticModelOpt == null); 269957"];
19355 [label="Debug.Assert(semanticModelOpt == null); 269958"];
19356 [label="Debug.Assert(positionOpt < 0); 269959"];
19357 [label="Debug.Assert(positionOpt < 0); 269960"];
19358 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 269961"];
19359 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 269962"];
19360 [label="'modopt' 269963"];
19361 [label="IL_KEYWORD_MODOPT = 'modopt' 269964"];
19362 [label="'modreq' 269965"];
19363 [label="IL_KEYWORD_MODREQ = 'modreq' 269966"];
19364 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 269967"];
19365 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 269968"];
19366 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 269969"];
19367 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 269970"];
19368 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 269971"];
19369 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 269972"];
19370 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 269973"];
19371 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 269974"];
19372 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 269975"];
19373 [label="param SymbolDisplayVisitor(int positionOpt) 269976"];
19374 [label="param SymbolDisplayVisitor(this) 269977"];
19375 [label="builder 269978"];
19376 [label="format 269979"];
19377 [label="true 269980"];
19378 [label="semanticModelOpt 269981"];
19379 [label="positionOpt 269982"];
19380 [label="param SymbolDisplayVisitor(this) 269983"];
19381 [label="param SymbolDisplayVisitor(this) 269984"];
19382 [label="_escapeKeywordIdentifiers 269985"];
19383 [label="_lazyAliasMap 269986"];
19384 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 269987"];
19385 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 269988"];
19386 [label="_escapeKeywordIdentifiers 269989"];
19387 [label="symbol.Accept(visitor); 269990"];
19388 [label="symbol.Accept(visitor) 269991"];
19389 [label="param Accept(SymbolVisitor visitor) 269992"];
19390 [label="param Accept(this) 269993"];
19391 [label="Accept(visitor); 269994"];
19392 [label="Accept(visitor) 269995"];
19393 [label="param Accept(SymbolVisitor visitor) 269996"];
19394 [label="param Accept(this) 269997"];
19395 [label="visitor.VisitNamespace(this); 269998"];
19396 [label="visitor.VisitNamespace(this) 269999"];
19397 [label="param VisitNamespace(INamespaceSymbol symbol) 270000"];
19398 [label="param VisitNamespace(this) 270001"];
19399 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 270002"];
19400 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270003"];
19401 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270004"];
19402 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 270005"];
19403 [label="symbol.ContainingNamespace 270006"];
19404 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 270007"];
19405 [label="UnderlyingSymbol 270008"];
19406 [label="=> _underlying 270009"];
19407 [label="_underlying 270010"];
19408 [label="UnderlyingSymbol.ContainingNamespace 270011"];
19409 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 270012"];
19410 [label="this.ContainingSymbol 270013"];
19411 [label="get { return _containingNamespaceSymbol; } 270014"];
19412 [label="return _containingNamespaceSymbol; 270015"];
19413 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 270016"];
19414 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 270017"];
19415 [label="var ns = container as NamespaceSymbol; 270018"];
19416 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 270019"];
19417 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 270020"];
19418 [label="return ns; 270021"];
19419 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 270022"];
19420 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 270023"];
19421 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 270024"];
19422 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 270025"];
19423 [label="param GetPublicSymbol(this Symbol? symbol) 270026"];
19424 [label=".ISymbol 270027"];
19425 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 270028"];
19426 [label="param NamespaceOrTypeSymbol(this) 270029"];
19427 [label="param Symbol(this) 270030"];
19428 [label="_underlying 270031"];
19429 [label="Debug.Assert(underlying is object); 270032"];
19430 [label="return (TISymbol?)symbol?.ISymbol; 270033"];
19431 [label="var containingNamespace = symbol.ContainingNamespace; 270034"];
19432 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 270035"];
19433 [label="ShouldVisitNamespace(containingNamespace) 270036"];
19434 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 270037"];
19435 [label="param ShouldVisitNamespace(this) 270038"];
19436 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 270039"];
19437 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270040"];
19438 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270041"];
19439 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 270042"];
19440 [label="namespaceSymbol.IsGlobalNamespace 270043"];
19441 [label="=> _underlying.IsGlobalNamespace 270044"];
19442 [label="_underlying.IsGlobalNamespace 270045"];
19443 [label="get\n            {\n                return true;\n            } 270046"];
19444 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 270047"];
19445 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 270048"];
19446 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 270049"];
19447 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 270050"];
19448 [label="symbol.IsGlobalNamespace 270051"];
19449 [label="=> _underlying.IsGlobalNamespace 270052"];
19450 [label="_underlying.IsGlobalNamespace 270053"];
19451 [label="get\n            {\n                return false;\n            } 270054"];
19452 [label="return false; 270055"];
19453 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 270056"];
19454 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 270057"];
19455 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 270058"];
19456 [label="symbol.Name 270059"];
19457 [label="=> UnderlyingSymbol.Name 270060"];
19458 [label="UnderlyingSymbol 270061"];
19459 [label="=> _underlying 270062"];
19460 [label="_underlying 270063"];
19461 [label="UnderlyingSymbol.Name 270064"];
19462 [label="get\n            {\n                return _name;\n            } 270065"];
19463 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 270066"];
19464 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 270067"];
19465 [label="param CreatePart(SymbolDisplayPartKind kind) 270068"];
19466 [label="param CreatePart(ISymbol symbol) 270069"];
19467 [label="param CreatePart(string text) 270070"];
19468 [label="param CreatePart(this) 270071"];
19469 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 270072"];
19470 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 270073"];
19471 [label="(text == null) 270074"];
19472 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 270075"];
19473 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 270076"];
19474 [label="return new SymbolDisplayPart(kind, symbol, text); 270077"];
19475 [label="return new SymbolDisplayPart(kind, symbol, text); 270078"];
19476 [label="return new SymbolDisplayPart(kind, symbol, text); 270079"];
19477 [label="return new SymbolDisplayPart(kind, symbol, text); 270080"];
19478 [label="visitor.VisitNamespace(this); 270081"];
19479 [label="Accept(visitor); 270082"];
19480 [label="symbol.Accept(visitor); 270083"];
19481 [label="return builder.ToImmutableAndFree(); 270084"];
19482 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 270085"];
19483 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 270086"];
19484 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 270087"];
19485 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 270088"];
19486 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 270089"];
19487 [label="int forcedArity = emittedTypeName.ForcedArity; 270090"];
19488 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 270091"];
19489 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 270092"];
19490 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 270093"];
19491 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 270094"];
19492 [label="forcedArity = 0; 270095"];
19493 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 270096"];
19494 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 270097"];
19495 [label="param GetTypeMembers(string name) 270098"];
19496 [label="param GetTypeMembers(this) 270099"];
19497 [label="EnsureAllMembersLoaded() 270100"];
19498 [label="param EnsureAllMembersLoaded(this) 270101"];
19499 [label="var typesByNS = _typesByNS; 270102"];
19500 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 270103"];
19501 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 270104"];
19502 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 270105"];
19503 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 270106"];
19504 [label="LoadAllMembers(typesByNS); 270107"];
19505 [label="LoadAllMembers(typesByNS) 270108"];
19506 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 270109"];
19507 [label="Debug.Assert(typesByNS != null); 270110"];
19508 [label="Debug.Assert(typesByNS != null); 270111"];
19509 [label="get\n            {\n                return false;\n            } 270112"];
19510 [label="GetQualifiedNameLength() 270113"];
19511 [label="param GetQualifiedNameLength(this) 270114"];
19512 [label="this.Name 270115"];
19513 [label="get\n            {\n                return _name;\n            } 270116"];
19514 [label="int length = this.Name.Length; 270117"];
19515 [label="ContainingNamespace 270118"];
19516 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 270119"];
19517 [label="var parent = ContainingNamespace; 270120"];
19518 [label=".IsGlobalNamespace 270121"];
19519 [label="get\n            {\n                return true;\n            } 270122"];
19520 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 270123"];
19521 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 270124"];
19522 [label="return length; 270125"];
19523 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 270126"];
19524 [label="_containingNamespaceSymbol 270127"];
19525 [label="_name 270128"];
19526 [label="_typesByNS 270129"];
19527 [label="Debug.Assert(name != null); 270130"];
19528 [label="Debug.Assert((object)containingNamespace != null); 270131"];
19529 [label="Debug.Assert(typesByNS != null); 270132"];
19530 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270133"];
19531 [label="_containingNamespaceSymbol.ContainingPEModule 270134"];
19532 [label="get\n            {\n                return _moduleSymbol;\n            } 270135"];
19533 [label="return _containingNamespaceSymbol.ContainingPEModule; 270136"];
19534 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 270137"];
19535 [label="genericParameterHandles 270138"];
19536 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 270139"];
19537 [label="param GetGenericInfo(out ushort arity) 270140"];
19538 [label="param GetGenericInfo(out BadImageFormatException mrEx) 270141"];
19539 [label="mrEx = null; 270142"];
19540 [label="PENamedTypeSymbol result; 270143"];
19541 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 270144"];
19542 [label="mangleName 270145"];
19543 [label="param PENamedTypeSymbol(out bool mangleName) 270146"];
19544 [label="_lazyTupleData 270147"];
19545 [label="_container 270148"];
19546 [label="_name 270149"];
19547 [label="_flags 270150"];
19548 [label="_corTypeId 270151"];
19549 [label="Debug.Assert(!handle.IsNil); 270152"];
19550 [label="Debug.Assert((object)container != null); 270153"];
19551 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 270154"];
19552 [label="string metadataName; 270155"];
19553 [label="bool makeBad = false; 270156"];
19554 [label="mangleName = false; 270157"];
19555 [label="Accessibility access = Accessibility.Private; 270158"];
19556 [label="access = Accessibility.Public; 270159"];
19557 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 270160"];
19558 [label="_corTypeId 270161"];
19559 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 270162"];
19560 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270163"];
19561 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270164"];
19562 [label="genericParameterHandles 270165"];
19563 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 270166"];
19564 [label="param GetGenericInfo(out ushort arity) 270167"];
19565 [label="param GetGenericInfo(out BadImageFormatException mrEx) 270168"];
19566 [label="mrEx = null; 270169"];
19567 [label="PENamedTypeSymbol result; 270170"];
19568 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 270171"];
19569 [label="mangleName 270172"];
19570 [label="param PENamedTypeSymbol(out bool mangleName) 270173"];
19571 [label="_lazyTupleData 270174"];
19572 [label="_container 270175"];
19573 [label="_name 270176"];
19574 [label="_flags 270177"];
19575 [label="_corTypeId 270178"];
19576 [label="Debug.Assert(!handle.IsNil); 270179"];
19577 [label="Debug.Assert((object)container != null); 270180"];
19578 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 270181"];
19579 [label="string metadataName; 270182"];
19580 [label="bool makeBad = false; 270183"];
19581 [label="mangleName = false; 270184"];
19582 [label="Accessibility access = Accessibility.Private; 270185"];
19583 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 270186"];
19584 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270187"];
19585 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270188"];
19586 [label="_corTypeId 270189"];
19587 [label="genericParameterHandles 270190"];
19588 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 270191"];
19589 [label="param GetGenericInfo(out ushort arity) 270192"];
19590 [label="param GetGenericInfo(out BadImageFormatException mrEx) 270193"];
19591 [label="mrEx = null; 270194"];
19592 [label="PENamedTypeSymbol result; 270195"];
19593 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 270196"];
19594 [label="mangleName 270197"];
19595 [label="param PENamedTypeSymbol(out bool mangleName) 270198"];
19596 [label="_lazyTupleData 270199"];
19597 [label="_container 270200"];
19598 [label="_name 270201"];
19599 [label="_flags 270202"];
19600 [label="_corTypeId 270203"];
19601 [label="Debug.Assert(!handle.IsNil); 270204"];
19602 [label="Debug.Assert((object)container != null); 270205"];
19603 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 270206"];
19604 [label="string metadataName; 270207"];
19605 [label="bool makeBad = false; 270208"];
19606 [label="mangleName = false; 270209"];
19607 [label="Accessibility access = Accessibility.Private; 270210"];
19608 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 270211"];
19609 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270212"];
19610 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270213"];
19611 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 270214"];
19612 [label="mangleName 270215"];
19613 [label="param PENamedTypeSymbol(out bool mangleName) 270216"];
19614 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 270217"];
19615 [label="_arity 270218"];
19616 [label="_mangleName 270219"];
19617 [label="Debug.Assert(genericParameterHandles.Count > 0); 270220"];
19618 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270221"];
19619 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270222"];
19620 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 270223"];
19621 [label="bool added; 270224"];
19622 [label="Debug.Assert(added); 270225"];
19623 [label="type.SpecialType 270226"];
19624 [label="get\n            {\n                return _corTypeId;\n            } 270227"];
19625 [label="return _corTypeId; 270228"];
19626 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 270229"];
19627 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 270230"];
19628 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 270231"];
19629 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 270232"];
19630 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 270233"];
19631 [label="param RegisterDeclaredSpecialType(this) 270234"];
19632 [label="corType.SpecialType 270235"];
19633 [label="get\n            {\n                return _corTypeId;\n            } 270236"];
19634 [label="SpecialType typeId = corType.SpecialType; 270237"];
19635 [label="Debug.Assert(typeId != SpecialType.None); 270238"];
19636 [label="corType.ContainingAssembly 270239"];
19637 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 270240"];
19638 [label="get\n            {\n                return _container;\n            } 270241"];
19639 [label="return _container; 270242"];
19640 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270243"];
19641 [label="ContainingPEModule 270244"];
19642 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270245"];
19643 [label="return ContainingPEModule.ContainingAssembly; 270246"];
19644 [label="ContainingPEModule.ContainingAssembly 270247"];
19645 [label="get\n            {\n                return _assemblySymbol;\n            } 270248"];
19646 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270249"];
19647 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270250"];
19648 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270251"];
19649 [label="corType.ContainingModule 270252"];
19650 [label="get\n            {\n                return ContainingPEModule;\n            } 270253"];
19651 [label="ContainingPEModule 270254"];
19652 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270255"];
19653 [label="Symbol s = _container; 270256"];
19654 [label="s.Kind 270257"];
19655 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270258"];
19656 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270259"];
19657 [label="((PENamespaceSymbol)s).ContainingPEModule 270260"];
19658 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270261"];
19659 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270262"];
19660 [label="return ContainingPEModule; 270263"];
19661 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270264"];
19662 [label="corType.ContainingModule.Ordinal 270265"];
19663 [label="get\n            {\n                return _ordinal;\n            } 270266"];
19664 [label="return _ordinal; 270267"];
19665 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270268"];
19666 [label="this.CorLibrary 270269"];
19667 [label="get\n            {\n                return _corLibrary;\n            } 270270"];
19668 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270271"];
19669 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270272"];
19670 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 270273"];
19671 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 270274"];
19672 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 270275"];
19673 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 270276"];
19674 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 270277"];
19675 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 270278"];
19676 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 270279"];
19677 [label="Interlocked.Increment(ref _cachedSpecialTypes); 270280"];
19678 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270281"];
19679 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270282"];
19680 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270283"];
19681 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 270284"];
19682 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 270285"];
19683 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 270286"];
19684 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 270287"];
19685 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 270288"];
19686 [label="bool added; 270289"];
19687 [label="Debug.Assert(added); 270290"];
19688 [label="Debug.Assert(typeId != SpecialType.None); 270291"];
19689 [label="corType.ContainingAssembly 270292"];
19690 [label="get\n            {\n                return _container;\n            } 270293"];
19691 [label="return _container; 270294"];
19692 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270295"];
19693 [label="ContainingPEModule 270296"];
19694 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270297"];
19695 [label="return ContainingPEModule.ContainingAssembly; 270298"];
19696 [label="ContainingPEModule.ContainingAssembly 270299"];
19697 [label="get\n            {\n                return _assemblySymbol;\n            } 270300"];
19698 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270301"];
19699 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270302"];
19700 [label="corType.ContainingModule 270303"];
19701 [label="get\n            {\n                return ContainingPEModule;\n            } 270304"];
19702 [label="ContainingPEModule 270305"];
19703 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270306"];
19704 [label="Symbol s = _container; 270307"];
19705 [label="s.Kind 270308"];
19706 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270309"];
19707 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270310"];
19708 [label="((PENamespaceSymbol)s).ContainingPEModule 270311"];
19709 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270312"];
19710 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270313"];
19711 [label="return ContainingPEModule; 270314"];
19712 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270315"];
19713 [label="corType.ContainingModule.Ordinal 270316"];
19714 [label="get\n            {\n                return _ordinal;\n            } 270317"];
19715 [label="return _ordinal; 270318"];
19716 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270319"];
19717 [label="this.CorLibrary 270320"];
19718 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270321"];
19719 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270322"];
19720 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270323"];
19721 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270324"];
19722 [label="bool added; 270325"];
19723 [label="Debug.Assert(added); 270326"];
19724 [label="Debug.Assert(typeId != SpecialType.None); 270327"];
19725 [label="corType.ContainingAssembly 270328"];
19726 [label="get\n            {\n                return _container;\n            } 270329"];
19727 [label="return _container; 270330"];
19728 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270331"];
19729 [label="ContainingPEModule 270332"];
19730 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270333"];
19731 [label="return ContainingPEModule.ContainingAssembly; 270334"];
19732 [label="ContainingPEModule.ContainingAssembly 270335"];
19733 [label="get\n            {\n                return _assemblySymbol;\n            } 270336"];
19734 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270337"];
19735 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270338"];
19736 [label="corType.ContainingModule 270339"];
19737 [label="get\n            {\n                return ContainingPEModule;\n            } 270340"];
19738 [label="ContainingPEModule 270341"];
19739 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270342"];
19740 [label="Symbol s = _container; 270343"];
19741 [label="s.Kind 270344"];
19742 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270345"];
19743 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270346"];
19744 [label="((PENamespaceSymbol)s).ContainingPEModule 270347"];
19745 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270348"];
19746 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270349"];
19747 [label="return ContainingPEModule; 270350"];
19748 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270351"];
19749 [label="corType.ContainingModule.Ordinal 270352"];
19750 [label="get\n            {\n                return _ordinal;\n            } 270353"];
19751 [label="return _ordinal; 270354"];
19752 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270355"];
19753 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270356"];
19754 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270357"];
19755 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270358"];
19756 [label="bool added; 270359"];
19757 [label="Debug.Assert(added); 270360"];
19758 [label="return _container; 270361"];
19759 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270362"];
19760 [label="ContainingPEModule 270363"];
19761 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270364"];
19762 [label="return ContainingPEModule.ContainingAssembly; 270365"];
19763 [label="ContainingPEModule.ContainingAssembly 270366"];
19764 [label="get\n            {\n                return _assemblySymbol;\n            } 270367"];
19765 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270368"];
19766 [label="Symbol s = _container; 270369"];
19767 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270370"];
19768 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270371"];
19769 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270372"];
19770 [label="return ContainingPEModule; 270373"];
19771 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270374"];
19772 [label="get\n            {\n                return _ordinal;\n            } 270375"];
19773 [label="return _ordinal; 270376"];
19774 [label="LoadAllMembers(typesByNS); 270377"];
19775 [label="Interlocked.Exchange(ref _typesByNS, null); 270378"];
19776 [label="Interlocked.Exchange(ref _typesByNS, null); 270379"];
19777 [label="EnsureAllMembersLoaded(); 270380"];
19778 [label="ImmutableArray<PENamedTypeSymbol> t; 270381"];
19779 [label="t 270382"];
19780 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 270383"];
19781 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 270384"];
19782 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 270385"];
19783 [label="lazyTypes.TryGetValue(name, out t) 270386"];
19784 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 270387"];
19785 [label="named.MangleName 270388"];
19786 [label="get\n                {\n                    return false;\n                } 270389"];
19787 [label="return false; 270390"];
19788 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270391"];
19789 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270392"];
19790 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270393"];
19791 [label="named.Arity 270394"];
19792 [label="get\n                {\n                    return 0;\n                } 270395"];
19793 [label="return 0; 270396"];
19794 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270397"];
19795 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270398"];
19796 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 270399"];
19797 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 270400"];
19798 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 270401"];
19799 [label="namedType = named; 270402"];
19800 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 270403"];
19801 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 270404"];
19802 [label="return namedType; 270405"];
19803 [label="Debug.Assert((object)result != null); 270406"];
19804 [label="Debug.Assert((object)result != null); 270407"];
19805 [label="return result; 270408"];
19806 [label="result.Kind 270409"];
19807 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 270410"];
19808 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270411"];
19809 [label="result.DeclaredAccessibility 270412"];
19810 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 270413"];
19811 [label="Accessibility access = Accessibility.Private; 270414"];
19812 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270415"];
19813 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270416"];
19814 [label="RegisterDeclaredSpecialType(result); 270417"];
19815 [label="RegisterDeclaredSpecialType(result) 270418"];
19816 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 270419"];
19817 [label="param RegisterDeclaredSpecialType(this) 270420"];
19818 [label="corType.SpecialType 270421"];
19819 [label="Debug.Assert(typeId != SpecialType.None); 270422"];
19820 [label="corType.ContainingAssembly 270423"];
19821 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 270424"];
19822 [label="get\n            {\n                return _container;\n            } 270425"];
19823 [label="return _container; 270426"];
19824 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270427"];
19825 [label="ContainingPEModule 270428"];
19826 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270429"];
19827 [label="return ContainingPEModule.ContainingAssembly; 270430"];
19828 [label="ContainingPEModule.ContainingAssembly 270431"];
19829 [label="get\n            {\n                return _assemblySymbol;\n            } 270432"];
19830 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270433"];
19831 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270434"];
19832 [label="corType.ContainingModule 270435"];
19833 [label="get\n            {\n                return ContainingPEModule;\n            } 270436"];
19834 [label="ContainingPEModule 270437"];
19835 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270438"];
19836 [label="Symbol s = _container; 270439"];
19837 [label="s.Kind 270440"];
19838 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270441"];
19839 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270442"];
19840 [label="((PENamespaceSymbol)s).ContainingPEModule 270443"];
19841 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270444"];
19842 [label="_containingNamespaceSymbol.ContainingPEModule 270445"];
19843 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270446"];
19844 [label="return ContainingPEModule; 270447"];
19845 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270448"];
19846 [label="corType.ContainingModule.Ordinal 270449"];
19847 [label="get\n            {\n                return _ordinal;\n            } 270450"];
19848 [label="return _ordinal; 270451"];
19849 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270452"];
19850 [label="this.CorLibrary 270453"];
19851 [label="get\n            {\n                return _corLibrary;\n            } 270454"];
19852 [label="return _corLibrary; 270455"];
19853 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270456"];
19854 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270457"];
19855 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 270458"];
19856 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 270459"];
19857 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 270460"];
19858 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 270461"];
19859 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 270462"];
19860 [label="RegisterDeclaredSpecialType(result); 270463"];
19861 [label="return _lazySpecialTypes[(int)type]; 270464"];
19862 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 270465"];
19863 [label="GetSZArrayInterfaces(elementType, declaringAssembly) 270466"];
19864 [label="param GetSZArrayInterfaces(TypeWithAnnotations elementTypeWithAnnotations) 270467"];
19865 [label="param GetSZArrayInterfaces(AssemblySymbol declaringAssembly) 270468"];
19866 [label="var constructedInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 270469"];
19867 [label="var iListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T); 270470"];
19868 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T) 270471"];
19869 [label="param GetSpecialType(SpecialType type) 270472"];
19870 [label="param GetSpecialType(this) 270473"];
19871 [label="CorLibrary 270474"];
19872 [label="get\n            {\n                return _corLibrary;\n            } 270475"];
19873 [label="return _corLibrary; 270476"];
19874 [label="return CorLibrary.GetDeclaredSpecialType(type); 270477"];
19875 [label="CorLibrary.GetDeclaredSpecialType(type) 270478"];
19876 [label="param GetDeclaredSpecialType(SpecialType type) 270479"];
19877 [label="this.Modules 270480"];
19878 [label="get\n            {\n                return _modules;\n            } 270481"];
19879 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 270482"];
19880 [label="module.GetReferencedAssemblies() 270483"];
19881 [label="param GetReferencedAssemblies(this) 270484"];
19882 [label="AssertReferencesInitialized() 270485"];
19883 [label="param AssertReferencesInitialized(this) 270486"];
19884 [label="Debug.Assert(_moduleReferences != null); 270487"];
19885 [label="Debug.Assert(_moduleReferences != null); 270488"];
19886 [label="AssertReferencesInitialized(); 270489"];
19887 [label="return _moduleReferences.Identities; 270490"];
19888 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 270491"];
19889 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 270492"];
19890 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 270493"];
19891 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 270494"];
19892 [label="NamedTypeSymbol result; 270495"];
19893 [label="NamespaceSymbol nextScope = null; 270496"];
19894 [label="EnsureAllMembersLoaded(); 270497"];
19895 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 270498"];
19896 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 270499"];
19897 [label="if ((object)scope == null)\n                {\n                    break;\n                } 270500"];
19898 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 270501"];
19899 [label="Debug.Assert(typesByNS != null); 270502"];
19900 [label="get\n            {\n                return false;\n            } 270503"];
19901 [label="ContainingNamespace 270504"];
19902 [label="var parent = ContainingNamespace; 270505"];
19903 [label=".IsGlobalNamespace 270506"];
19904 [label="get\n            {\n                return false;\n            } 270507"];
19905 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 270508"];
19906 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 270509"];
19907 [label="parent.Name 270510"];
19908 [label="get\n            {\n                return _name;\n            } 270511"];
19909 [label="length += parent.Name.Length + 1; 270512"];
19910 [label="length += parent.Name.Length + 1; 270513"];
19911 [label="parent.ContainingNamespace 270514"];
19912 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 270515"];
19913 [label="parent = parent.ContainingNamespace; 270516"];
19914 [label="get\n            {\n                return true;\n            } 270517"];
19915 [label="_containingNamespaceSymbol 270518"];
19916 [label="_name 270519"];
19917 [label="_typesByNS 270520"];
19918 [label="Debug.Assert(name != null); 270521"];
19919 [label="Debug.Assert((object)containingNamespace != null); 270522"];
19920 [label="Debug.Assert(typesByNS != null); 270523"];
19921 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 270524"];
19922 [label="genericParameterHandles 270525"];
19923 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 270526"];
19924 [label="param GetGenericInfo(out ushort arity) 270527"];
19925 [label="param GetGenericInfo(out BadImageFormatException mrEx) 270528"];
19926 [label="mrEx = null; 270529"];
19927 [label="PENamedTypeSymbol result; 270530"];
19928 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 270531"];
19929 [label="mangleName 270532"];
19930 [label="param PENamedTypeSymbol(out bool mangleName) 270533"];
19931 [label="_lazyTupleData 270534"];
19932 [label="_container 270535"];
19933 [label="_name 270536"];
19934 [label="_flags 270537"];
19935 [label="_corTypeId 270538"];
19936 [label="Debug.Assert(!handle.IsNil); 270539"];
19937 [label="Debug.Assert((object)container != null); 270540"];
19938 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 270541"];
19939 [label="string metadataName; 270542"];
19940 [label="bool makeBad = false; 270543"];
19941 [label="mangleName = false; 270544"];
19942 [label="Accessibility access = Accessibility.Private; 270545"];
19943 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 270546"];
19944 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270547"];
19945 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270548"];
19946 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270549"];
19947 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270550"];
19948 [label="bool added; 270551"];
19949 [label="Debug.Assert(added); 270552"];
19950 [label="Debug.Assert(typeId != SpecialType.None); 270553"];
19951 [label="corType.ContainingAssembly 270554"];
19952 [label="get\n            {\n                return _container;\n            } 270555"];
19953 [label="return _container; 270556"];
19954 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270557"];
19955 [label="ContainingPEModule 270558"];
19956 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270559"];
19957 [label="return ContainingPEModule.ContainingAssembly; 270560"];
19958 [label="ContainingPEModule.ContainingAssembly 270561"];
19959 [label="get\n            {\n                return _assemblySymbol;\n            } 270562"];
19960 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270563"];
19961 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270564"];
19962 [label="corType.ContainingModule 270565"];
19963 [label="get\n            {\n                return ContainingPEModule;\n            } 270566"];
19964 [label="ContainingPEModule 270567"];
19965 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270568"];
19966 [label="Symbol s = _container; 270569"];
19967 [label="s.Kind 270570"];
19968 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270571"];
19969 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270572"];
19970 [label="((PENamespaceSymbol)s).ContainingPEModule 270573"];
19971 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270574"];
19972 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270575"];
19973 [label="return ContainingPEModule; 270576"];
19974 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270577"];
19975 [label="corType.ContainingModule.Ordinal 270578"];
19976 [label="get\n            {\n                return _ordinal;\n            } 270579"];
19977 [label="return _ordinal; 270580"];
19978 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270581"];
19979 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270582"];
19980 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270583"];
19981 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270584"];
19982 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 270585"];
19983 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 270586"];
19984 [label="if ((object)scope == null)\n                {\n                    break;\n                } 270587"];
19985 [label="Debug.Assert(!emittedTypeName.IsNull); 270588"];
19986 [label="scope.Kind 270589"];
19987 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270590"];
19988 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 270591"];
19989 [label="NamedTypeSymbol? namedType = null; 270592"];
19990 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 270593"];
19991 [label="namespaceOrTypeMembers 270594"];
19992 [label="scope.IsNamespace 270595"];
19993 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 270596"];
19994 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270597"];
19995 [label="bool isTopLevel = scope.IsNamespace; 270598"];
19996 [label="param NamespaceOrTypeSymbol(this) 270599"];
19997 [label="param Symbol(this) 270600"];
19998 [label="_underlying 270601"];
19999 [label="Debug.Assert(underlying is object); 270602"];
20000 [label="param ToDisplayParts(bool minimal) 270603"];
20001 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 270604"];
20002 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 270605"];
20003 [label="Debug.Assert(semanticModelOpt == null); 270606"];
20004 [label="Debug.Assert(positionOpt < 0); 270607"];
20005 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 270608"];
20006 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 270609"];
20007 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270610"];
20008 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270611"];
20009 [label="return (TISymbol?)symbol?.ISymbol; 270612"];
20010 [label="var containingNamespace = symbol.ContainingNamespace; 270613"];
20011 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 270614"];
20012 [label="ShouldVisitNamespace(containingNamespace) 270615"];
20013 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 270616"];
20014 [label="param ShouldVisitNamespace(this) 270617"];
20015 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 270618"];
20016 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270619"];
20017 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270620"];
20018 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 270621"];
20019 [label="namespaceSymbol.IsGlobalNamespace 270622"];
20020 [label="=> _underlying.IsGlobalNamespace 270623"];
20021 [label="get\n            {\n                return false;\n            } 270624"];
20022 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 270625"];
20023 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 270626"];
20024 [label="containingNamespace.Accept(this.NotFirstVisitor); 270627"];
20025 [label="this.NotFirstVisitor 270628"];
20026 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 270629"];
20027 [label="param MakeNotFirstVisitor(this) 270630"];
20028 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 270631"];
20029 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 270632"];
20030 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 270633"];
20031 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 270634"];
20032 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 270635"];
20033 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 270636"];
20034 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 270637"];
20035 [label="param SymbolDisplayVisitor(int positionOpt) 270638"];
20036 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 270639"];
20037 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 270640"];
20038 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 270641"];
20039 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 270642"];
20040 [label="param SymbolDisplayVisitor(this) 270643"];
20041 [label="builder 270644"];
20042 [label="format 270645"];
20043 [label="isFirstSymbolVisited 270646"];
20044 [label="semanticModelOpt 270647"];
20045 [label="positionOpt 270648"];
20046 [label="inNamespaceOrType 270649"];
20047 [label="param SymbolDisplayVisitor(this) 270650"];
20048 [label="param SymbolDisplayVisitor(this) 270651"];
20049 [label="_escapeKeywordIdentifiers 270652"];
20050 [label="_lazyAliasMap 270653"];
20051 [label="containingNamespace.Accept(this.NotFirstVisitor); 270654"];
20052 [label="containingNamespace.Accept(this.NotFirstVisitor); 270655"];
20053 [label="containingNamespace.Accept(this.NotFirstVisitor) 270656"];
20054 [label="param Accept(SymbolVisitor visitor) 270657"];
20055 [label="param Accept(this) 270658"];
20056 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 270659"];
20057 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270660"];
20058 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 270661"];
20059 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 270662"];
20060 [label="param ShouldVisitNamespace(this) 270663"];
20061 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 270664"];
20062 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270665"];
20063 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 270666"];
20064 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 270667"];
20065 [label="=> _underlying.IsGlobalNamespace 270668"];
20066 [label="get\n            {\n                return false;\n            } 270669"];
20067 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 270670"];
20068 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 270671"];
20069 [label="get\n            {\n                return true;\n            } 270672"];
20070 [label="=> _underlying.IsGlobalNamespace 270673"];
20071 [label="get\n            {\n                return false;\n            } 270674"];
20072 [label="containingNamespace.IsGlobalNamespace 270675"];
20073 [label="=> _underlying.IsGlobalNamespace 270676"];
20074 [label="get\n            {\n                return false;\n            } 270677"];
20075 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 270678"];
20076 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 270679"];
20077 [label="param AddPunctuation(SyntaxKind punctuationKind) 270680"];
20078 [label="param AddPunctuation(this) 270681"];
20079 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270682"];
20080 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270683"];
20081 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270684"];
20082 [label="SyntaxFacts.GetText(punctuationKind) 270685"];
20083 [label="param GetText(SyntaxKind kind) 270686"];
20084 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 270687"];
20085 [label="param CreatePart(SymbolDisplayPartKind kind) 270688"];
20086 [label="param CreatePart(ISymbol symbol) 270689"];
20087 [label="param CreatePart(string text) 270690"];
20088 [label="param CreatePart(this) 270691"];
20089 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 270692"];
20090 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 270693"];
20091 [label="=> _underlying.IsGlobalNamespace 270694"];
20092 [label="get\n            {\n                return false;\n            } 270695"];
20093 [label="containingNamespace.Accept(this.NotFirstVisitor); 270696"];
20094 [label="containingNamespace.IsGlobalNamespace 270697"];
20095 [label="=> _underlying.IsGlobalNamespace 270698"];
20096 [label="get\n            {\n                return false;\n            } 270699"];
20097 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 270700"];
20098 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 270701"];
20099 [label="param AddPunctuation(SyntaxKind punctuationKind) 270702"];
20100 [label="param AddPunctuation(this) 270703"];
20101 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270704"];
20102 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270705"];
20103 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 270706"];
20104 [label="SyntaxFacts.GetText(punctuationKind) 270707"];
20105 [label="param GetText(SyntaxKind kind) 270708"];
20106 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 270709"];
20107 [label="param CreatePart(SymbolDisplayPartKind kind) 270710"];
20108 [label="param CreatePart(ISymbol symbol) 270711"];
20109 [label="param CreatePart(string text) 270712"];
20110 [label="param CreatePart(this) 270713"];
20111 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 270714"];
20112 [label="=> _underlying.IsGlobalNamespace 270715"];
20113 [label="get\n            {\n                return false;\n            } 270716"];
20114 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 270717"];
20115 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 270718"];
20116 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 270719"];
20117 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 270720"];
20118 [label="if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                } 270721"];
20119 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName); 270722"];
20120 [label="scope.GetTypeMembers(emittedTypeName.UnmangledTypeName) 270723"];
20121 [label="param GetTypeMembers(string name) 270724"];
20122 [label="var typesByNS = _typesByNS; 270725"];
20123 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 270726"];
20124 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 270727"];
20125 [label="Debug.Assert(typesByNS != null); 270728"];
20126 [label="get\n            {\n                return false;\n            } 270729"];
20127 [label="parent.ContainingNamespace 270730"];
20128 [label="parent = parent.ContainingNamespace; 270731"];
20129 [label="get\n            {\n                return false;\n            } 270732"];
20130 [label="get\n            {\n                return true;\n            } 270733"];
20131 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 270734"];
20132 [label="genericParameterHandles 270735"];
20133 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 270736"];
20134 [label="param GetGenericInfo(out ushort arity) 270737"];
20135 [label="param GetGenericInfo(out BadImageFormatException mrEx) 270738"];
20136 [label="mrEx = null; 270739"];
20137 [label="PENamedTypeSymbol result; 270740"];
20138 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 270741"];
20139 [label="mangleName 270742"];
20140 [label="param PENamedTypeSymbol(out bool mangleName) 270743"];
20141 [label="_lazyTupleData 270744"];
20142 [label="_container 270745"];
20143 [label="_name 270746"];
20144 [label="_flags 270747"];
20145 [label="_corTypeId 270748"];
20146 [label="Debug.Assert(!handle.IsNil); 270749"];
20147 [label="Debug.Assert((object)container != null); 270750"];
20148 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 270751"];
20149 [label="string metadataName; 270752"];
20150 [label="bool makeBad = false; 270753"];
20151 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 270754"];
20152 [label="Accessibility access = Accessibility.Private; 270755"];
20153 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 270756"];
20154 [label="_arity 270757"];
20155 [label="_mangleName 270758"];
20156 [label="Debug.Assert(genericParameterHandles.Count > 0); 270759"];
20157 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270760"];
20158 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 270761"];
20159 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 270762"];
20160 [label="mangleName 270763"];
20161 [label="param PENamedTypeSymbol(out bool mangleName) 270764"];
20162 [label="mangleName = false; 270765"];
20163 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270766"];
20164 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 270767"];
20165 [label="bool added; 270768"];
20166 [label="Debug.Assert(added); 270769"];
20167 [label="Debug.Assert(typeId != SpecialType.None); 270770"];
20168 [label="corType.ContainingAssembly 270771"];
20169 [label="get\n            {\n                return _container;\n            } 270772"];
20170 [label="return _container; 270773"];
20171 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270774"];
20172 [label="ContainingPEModule 270775"];
20173 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270776"];
20174 [label="return ContainingPEModule.ContainingAssembly; 270777"];
20175 [label="ContainingPEModule.ContainingAssembly 270778"];
20176 [label="get\n            {\n                return _assemblySymbol;\n            } 270779"];
20177 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270780"];
20178 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270781"];
20179 [label="corType.ContainingModule 270782"];
20180 [label="get\n            {\n                return ContainingPEModule;\n            } 270783"];
20181 [label="ContainingPEModule 270784"];
20182 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270785"];
20183 [label="Symbol s = _container; 270786"];
20184 [label="s.Kind 270787"];
20185 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270788"];
20186 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270789"];
20187 [label="((PENamespaceSymbol)s).ContainingPEModule 270790"];
20188 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270791"];
20189 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270792"];
20190 [label="return ContainingPEModule; 270793"];
20191 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270794"];
20192 [label="corType.ContainingModule.Ordinal 270795"];
20193 [label="get\n            {\n                return _ordinal;\n            } 270796"];
20194 [label="return _ordinal; 270797"];
20195 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270798"];
20196 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270799"];
20197 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270800"];
20198 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 270801"];
20199 [label="EnsureAllMembersLoaded(); 270802"];
20200 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 270803"];
20201 [label="foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    } 270804"];
20202 [label="named.Arity 270805"];
20203 [label="get\n                {\n                    return _arity;\n                } 270806"];
20204 [label="return _arity; 270807"];
20205 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 270808"];
20206 [label="named.MangleName 270809"];
20207 [label="get\n                {\n                    return _mangleName;\n                } 270810"];
20208 [label="return _mangleName; 270811"];
20209 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 270812"];
20210 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 270813"];
20211 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 270814"];
20212 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 270815"];
20213 [label="namedType = named; 270816"];
20214 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 270817"];
20215 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 270818"];
20216 [label="Debug.Assert((object)result != null); 270819"];
20217 [label="Debug.Assert((object)result != null); 270820"];
20218 [label="result.Kind 270821"];
20219 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 270822"];
20220 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270823"];
20221 [label="result.DeclaredAccessibility 270824"];
20222 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 270825"];
20223 [label="Accessibility access = Accessibility.Private; 270826"];
20224 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270827"];
20225 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 270828"];
20226 [label="Debug.Assert(typeId != SpecialType.None); 270829"];
20227 [label="corType.ContainingAssembly 270830"];
20228 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 270831"];
20229 [label="get\n            {\n                return _container;\n            } 270832"];
20230 [label="return _container; 270833"];
20231 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 270834"];
20232 [label="ContainingPEModule 270835"];
20233 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270836"];
20234 [label="return ContainingPEModule.ContainingAssembly; 270837"];
20235 [label="ContainingPEModule.ContainingAssembly 270838"];
20236 [label="get\n            {\n                return _assemblySymbol;\n            } 270839"];
20237 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270840"];
20238 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 270841"];
20239 [label="corType.ContainingModule 270842"];
20240 [label="get\n            {\n                return ContainingPEModule;\n            } 270843"];
20241 [label="ContainingPEModule 270844"];
20242 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270845"];
20243 [label="Symbol s = _container; 270846"];
20244 [label="s.Kind 270847"];
20245 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270848"];
20246 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270849"];
20247 [label="((PENamespaceSymbol)s).ContainingPEModule 270850"];
20248 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270851"];
20249 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270852"];
20250 [label="return ContainingPEModule; 270853"];
20251 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270854"];
20252 [label="corType.ContainingModule.Ordinal 270855"];
20253 [label="get\n            {\n                return _ordinal;\n            } 270856"];
20254 [label="return _ordinal; 270857"];
20255 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 270858"];
20256 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270859"];
20257 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 270860"];
20258 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 270861"];
20259 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 270862"];
20260 [label="return _lazySpecialTypes[(int)type]; 270863"];
20261 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 270864"];
20262 [label="iListOfT.IsErrorType() 270865"];
20263 [label="param IsErrorType(this TypeSymbol type) 270866"];
20264 [label="RoslynDebug.Assert((object)type != null); 270867"];
20265 [label="RoslynDebug.Assert((object)type != null); 270868"];
20266 [label="type.Kind 270869"];
20267 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 270870"];
20268 [label="return type.Kind == SymbolKind.ErrorType; 270871"];
20269 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 270872"];
20270 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 270873"];
20271 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 270874"];
20272 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 270875"];
20273 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 270876"];
20274 [label="new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 270877"];
20275 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 270878"];
20276 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 270879"];
20277 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 270880"];
20278 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 270881"];
20279 [label="param ConstructedNamedTypeSymbol(this) 270882"];
20280 [label="constructedFrom.ContainingSymbol 270883"];
20281 [label="get\n            {\n                return _container;\n            } 270884"];
20282 [label="return _container; 270885"];
20283 [label="constructedFrom.ContainingType 270886"];
20284 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 270887"];
20285 [label="return _container as NamedTypeSymbol; 270888"];
20286 [label="constructedFrom.OriginalDefinition 270889"];
20287 [label="get\n            {\n                return this;\n            } 270890"];
20288 [label="constructedFrom.OriginalDefinition.TypeParameters 270891"];
20289 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 270892"];
20290 [label="EnsureTypeParametersAreLoaded() 270893"];
20291 [label="param EnsureTypeParametersAreLoaded(this) 270894"];
20292 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 270895"];
20293 [label="ContainingPEModule 270896"];
20294 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 270897"];
20295 [label="Symbol s = _container; 270898"];
20296 [label="s.Kind 270899"];
20297 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 270900"];
20298 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 270901"];
20299 [label="((PENamespaceSymbol)s).ContainingPEModule 270902"];
20300 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 270903"];
20301 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 270904"];
20302 [label="var moduleSymbol = ContainingPEModule; 270905"];
20303 [label="int firstIndex = _genericParameterHandles.Count - _arity; 270906"];
20304 [label="TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity]; 270907"];
20305 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 270908"];
20306 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 270909"];
20307 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 270910"];
20308 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 270911"];
20309 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 270912"];
20310 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 270913"];
20311 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 270914"];
20312 [label="new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]) 270915"];
20313 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 270916"];
20314 [label="param PETypeParameterSymbol(PENamedTypeSymbol definingNamedType) 270917"];
20315 [label="param PETypeParameterSymbol(ushort ordinal) 270918"];
20316 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 270919"];
20317 [label="param PETypeParameterSymbol(this) 270920"];
20318 [label="moduleSymbol 270921"];
20319 [label="definingNamedType 270922"];
20320 [label="ordinal 270923"];
20321 [label="handle 270924"];
20322 [label="param PETypeParameterSymbol(this) 270925"];
20323 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 270926"];
20324 [label="param PETypeParameterSymbol(Symbol definingSymbol) 270927"];
20325 [label="param PETypeParameterSymbol(ushort ordinal) 270928"];
20326 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 270929"];
20327 [label="param PETypeParameterSymbol(this) 270930"];
20328 [label="param PETypeParameterSymbol(this) 270931"];
20329 [label="param TypeParameterSymbol(this) 270932"];
20330 [label="param TypeParameterSymbol(this) 270933"];
20331 [label="_lazyAdapter 270934"];
20332 [label="_containingSymbol 270935"];
20333 [label="_name 270936"];
20334 [label="_ordinal 270937"];
20335 [label="_lazyConstraintsUseSiteErrorInfo = CSDiagnosticInfo.EmptyErrorInfo 270938"];
20336 [label="_flags 270939"];
20337 [label="_lazyHasIsUnmanagedConstraint 270940"];
20338 [label="new TypeParameterBounds() 270941"];
20339 [label="param TypeParameterBounds(this) 270942"];
20340 [label="EffectiveBaseClass 270943"];
20341 [label="DeducedBaseType 270944"];
20342 [label="EffectiveBaseClass = null!; 270945"];
20343 [label="EffectiveBaseClass 270946"];
20344 [label="DeducedBaseType = null!; 270947"];
20345 [label="DeducedBaseType 270948"];
20346 [label="Unset = new TypeParameterBounds() 270949"];
20347 [label="_lazyBounds = TypeParameterBounds.Unset 270950"];
20348 [label="Debug.Assert((object)moduleSymbol != null); 270951"];
20349 [label="Debug.Assert((object)moduleSymbol != null); 270952"];
20350 [label="Debug.Assert((object)definingSymbol != null); 270953"];
20351 [label="Debug.Assert((object)definingSymbol != null); 270954"];
20352 [label="Debug.Assert(ordinal >= 0); 270955"];
20353 [label="Debug.Assert(ordinal >= 0); 270956"];
20354 [label="Debug.Assert(!handle.IsNil); 270957"];
20355 [label="_containingSymbol 270958"];
20356 [label="GenericParameterAttributes flags = 0; 270959"];
20357 [label="moduleSymbol.Module 270960"];
20358 [label="get\n            {\n                return _module;\n            } 270961"];
20359 [label="return _module; 270962"];
20360 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 270963"];
20361 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 270964"];
20362 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 270965"];
20363 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 270966"];
20364 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 270967"];
20365 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 270968"];
20366 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 270969"];
20367 [label="((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) 270970"];
20368 [label="_flags 270971"];
20369 [label="_ordinal 270972"];
20370 [label="_handle 270973"];
20371 [label="ownedParams[i] 270974"];
20372 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 270975"];
20373 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 270976"];
20374 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 270977"];
20375 [label="EnsureTypeParametersAreLoaded(); 270978"];
20376 [label="return _lazyTypeParameters; 270979"];
20377 [label="t => t.Type 270980"];
20378 [label="AsTypeSymbol = t => t.Type 270981"];
20379 [label="ReferenceEqualityComparer.Instance 270982"];
20380 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 270983"];
20381 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 270984"];
20382 [label="new TypeMap() 270985"];
20383 [label="param TypeMap(this) 270986"];
20384 [label="s_emptyDictionary 270987"];
20385 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 270988"];
20386 [label="param AbstractTypeParameterMap(this) 270989"];
20387 [label="param AbstractTypeMap(this) 270990"];
20388 [label="Mapping 270991"];
20389 [label="this.Mapping 270992"];
20390 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 270993"];
20391 [label="s_emptyTypeMap = new TypeMap() 270994"];
20392 [label="typeArgumentsWithAnnotations 270995"];
20393 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 270996"];
20394 [label="param TypeMap(NamedTypeSymbol containingType) 270997"];
20395 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 270998"];
20396 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> typeArguments) 270999"];
20397 [label="param TypeMap(this) 271000"];
20398 [label="containingType 271001"];
20399 [label="ForType(containingType) 271002"];
20400 [label="param ForType(NamedTypeSymbol containingType) 271003"];
20401 [label="var substituted = containingType as SubstitutedNamedTypeSymbol; 271004"];
20402 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 271005"];
20403 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 271006"];
20404 [label="(object)substituted != null 271007"];
20405 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 271008"];
20406 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 271009"];
20407 [label="param AbstractTypeParameterMap(this) 271010"];
20408 [label="param AbstractTypeMap(this) 271011"];
20409 [label="Mapping 271012"];
20410 [label="this.Mapping 271013"];
20411 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 271014"];
20412 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 271015"];
20413 [label="TypeParameterSymbol tp = typeParameters[i]; 271016"];
20414 [label="TypeWithAnnotations ta = typeArguments[i]; 271017"];
20415 [label="if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                } 271018"];
20416 [label="ta.Is(tp) 271019"];
20417 [label="param Is(TypeParameterSymbol other) 271020"];
20418 [label="param Is(this) 271021"];
20419 [label="1 271022"];
20420 [label="NotAnnotatedAttributeValue = 1 271023"];
20421 [label="2 271024"];
20422 [label="AnnotatedAttributeValue = 2 271025"];
20423 [label="0 271026"];
20424 [label="ObliviousAttributeValue = 0 271027"];
20425 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 271028"];
20426 [label="NullableAnnotation.IsOblivious() 271029"];
20427 [label="param IsOblivious(this NullableAnnotation annotation) 271030"];
20428 [label="annotation == NullableAnnotation.Oblivious 271031"];
20429 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 271032"];
20430 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 271033"];
20431 [label="Mapping.Add(tp, ta); 271034"];
20432 [label="Mapping.Add(tp, ta); 271035"];
20433 [label="Mapping.Add(tp, ta); 271036"];
20434 [label="constructedFrom.OriginalDefinition 271037"];
20435 [label="get\n            {\n                return this;\n            } 271038"];
20436 [label="s_symbolAsMemberFunc = SymbolExtensions.SymbolAsMember 271039"];
20437 [label="constructedFrom 271040"];
20438 [label="unbound 271041"];
20439 [label="tupleData 271042"];
20440 [label="param ConstructedNamedTypeSymbol(this) 271043"];
20441 [label="param SubstitutedNamedTypeSymbol(Symbol newContainer) 271044"];
20442 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 271045"];
20443 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol originalDefinition) 271046"];
20444 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol constructedFrom = null) 271047"];
20445 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 271048"];
20446 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 271049"];
20447 [label="param SubstitutedNamedTypeSymbol(this) 271050"];
20448 [label="originalDefinition 271051"];
20449 [label="tupleData 271052"];
20450 [label="param SubstitutedNamedTypeSymbol(this) 271053"];
20451 [label="param WrappedNamedTypeSymbol(NamedTypeSymbol underlyingType) 271054"];
20452 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 271055"];
20453 [label="param WrappedNamedTypeSymbol(this) 271056"];
20454 [label="tupleData 271057"];
20455 [label="param WrappedNamedTypeSymbol(this) 271058"];
20456 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 271059"];
20457 [label="_lazyTupleData 271060"];
20458 [label="_underlyingType 271061"];
20459 [label="Debug.Assert((object)underlyingType != null); 271062"];
20460 [label="Debug.Assert((object)underlyingType != null); 271063"];
20461 [label="_underlyingType 271064"];
20462 [label="_unbound 271065"];
20463 [label="_inputMap 271066"];
20464 [label="_newContainer 271067"];
20465 [label="_lazyMap 271068"];
20466 [label="_hashCode 271069"];
20467 [label="_lazyMembersByNameCache 271070"];
20468 [label="originalDefinition.IsDefinition 271071"];
20469 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 271072"];
20470 [label="OriginalDefinition 271073"];
20471 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 271074"];
20472 [label="OriginalSymbolDefinition 271075"];
20473 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 271076"];
20474 [label="this.OriginalTypeSymbolDefinition 271077"];
20475 [label="get\n            {\n                return this.OriginalDefinition;\n            } 271078"];
20476 [label="this.OriginalDefinition 271079"];
20477 [label="get\n            {\n                return this;\n            } 271080"];
20478 [label="return this.OriginalDefinition; 271081"];
20479 [label="return this.OriginalTypeSymbolDefinition; 271082"];
20480 [label="return OriginalSymbolDefinition; 271083"];
20481 [label="return (object)this == (object)OriginalDefinition; 271084"];
20482 [label="Debug.Assert(originalDefinition.IsDefinition); 271085"];
20483 [label="Debug.Assert(!originalDefinition.IsErrorType()); 271086"];
20484 [label="originalDefinition.IsErrorType() 271087"];
20485 [label="param IsErrorType(this TypeSymbol type) 271088"];
20486 [label="RoslynDebug.Assert((object)type != null); 271089"];
20487 [label="RoslynDebug.Assert((object)type != null); 271090"];
20488 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 271091"];
20489 [label="Debug.Assert(!originalDefinition.IsErrorType()); 271092"];
20490 [label="_newContainer 271093"];
20491 [label="_inputMap 271094"];
20492 [label="_unbound 271095"];
20493 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 271096"];
20494 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 271097"];
20495 [label="constructedFrom.ConstructedFrom 271098"];
20496 [label="get\n            {\n                return this;\n            } 271099"];
20497 [label="return this; 271100"];
20498 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 271101"];
20499 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 271102"];
20500 [label="constructedFrom.TypeParameters 271103"];
20501 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 271104"];
20502 [label="EnsureTypeParametersAreLoaded() 271105"];
20503 [label="param EnsureTypeParametersAreLoaded(this) 271106"];
20504 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 271107"];
20505 [label="EnsureTypeParametersAreLoaded(); 271108"];
20506 [label="return _lazyTypeParameters; 271109"];
20507 [label="_lazyTypeParameters = constructedFrom.TypeParameters; 271110"];
20508 [label="_lazyTypeParameters 271111"];
20509 [label="_lazyMap 271112"];
20510 [label="_constructedFrom 271113"];
20511 [label="_typeArgumentsWithAnnotations 271114"];
20512 [label="_constructedFrom 271115"];
20513 [label="constructedFrom.Arity 271116"];
20514 [label="get\n                {\n                    return _arity;\n                } 271117"];
20515 [label="return _arity; 271118"];
20516 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 271119"];
20517 [label="constructedFrom.Arity 271120"];
20518 [label="get\n                {\n                    return _arity;\n                } 271121"];
20519 [label="return _arity; 271122"];
20520 [label="Debug.Assert(constructedFrom.Arity != 0); 271123"];
20521 [label="Debug.Assert(constructedFrom.Arity != 0); 271124"];
20522 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 271125"];
20523 [label="var iReadOnlyListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T); 271126"];
20524 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T) 271127"];
20525 [label="param GetSpecialType(SpecialType type) 271128"];
20526 [label="param GetSpecialType(this) 271129"];
20527 [label="CorLibrary 271130"];
20528 [label="get\n            {\n                return _corLibrary;\n            } 271131"];
20529 [label="return _corLibrary; 271132"];
20530 [label="return CorLibrary.GetDeclaredSpecialType(type); 271133"];
20531 [label="CorLibrary.GetDeclaredSpecialType(type) 271134"];
20532 [label="param GetDeclaredSpecialType(SpecialType type) 271135"];
20533 [label="this.Modules 271136"];
20534 [label="get\n            {\n                return _modules;\n            } 271137"];
20535 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 271138"];
20536 [label="module.GetReferencedAssemblies() 271139"];
20537 [label="param GetReferencedAssemblies(this) 271140"];
20538 [label="AssertReferencesInitialized() 271141"];
20539 [label="param AssertReferencesInitialized(this) 271142"];
20540 [label="Debug.Assert(_moduleReferences != null); 271143"];
20541 [label="Debug.Assert(_moduleReferences != null); 271144"];
20542 [label="AssertReferencesInitialized(); 271145"];
20543 [label="return _moduleReferences.Identities; 271146"];
20544 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 271147"];
20545 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 271148"];
20546 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 271149"];
20547 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 271150"];
20548 [label="return _lazySpecialTypes[(int)type]; 271151"];
20549 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 271152"];
20550 [label="iReadOnlyListOfT.IsErrorType() 271153"];
20551 [label="param IsErrorType(this TypeSymbol type) 271154"];
20552 [label="RoslynDebug.Assert((object)type != null); 271155"];
20553 [label="RoslynDebug.Assert((object)type != null); 271156"];
20554 [label="type.Kind 271157"];
20555 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 271158"];
20556 [label="return type.Kind == SymbolKind.ErrorType; 271159"];
20557 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 271160"];
20558 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 271161"];
20559 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 271162"];
20560 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 271163"];
20561 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 271164"];
20562 [label="new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 271165"];
20563 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 271166"];
20564 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 271167"];
20565 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 271168"];
20566 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 271169"];
20567 [label="param ConstructedNamedTypeSymbol(this) 271170"];
20568 [label="constructedFrom.ContainingSymbol 271171"];
20569 [label="constructedFrom.ContainingType 271172"];
20570 [label="constructedFrom.OriginalDefinition 271173"];
20571 [label="constructedFrom.OriginalDefinition.TypeParameters 271174"];
20572 [label="EnsureTypeParametersAreLoaded() 271175"];
20573 [label="s.Kind 271176"];
20574 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 271177"];
20575 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 271178"];
20576 [label="_containingSymbol 271179"];
20577 [label="_ordinal 271180"];
20578 [label="_flags 271181"];
20579 [label="Debug.Assert((object)moduleSymbol != null); 271182"];
20580 [label="Debug.Assert((object)definingSymbol != null); 271183"];
20581 [label="Debug.Assert(ordinal >= 0); 271184"];
20582 [label="Debug.Assert(!handle.IsNil); 271185"];
20583 [label="EnsureTypeParametersAreLoaded(); 271186"];
20584 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 271187"];
20585 [label="param TypeMap(this) 271188"];
20586 [label="ForType(containingType) 271189"];
20587 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 271190"];
20588 [label="param AbstractTypeParameterMap(this) 271191"];
20589 [label="param AbstractTypeMap(this) 271192"];
20590 [label="Mapping 271193"];
20591 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 271194"];
20592 [label="constructedFrom.OriginalDefinition 271195"];
20593 [label="unbound 271196"];
20594 [label="tupleData 271197"];
20595 [label="param ConstructedNamedTypeSymbol(this) 271198"];
20596 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 271199"];
20597 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 271200"];
20598 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 271201"];
20599 [label="param SubstitutedNamedTypeSymbol(this) 271202"];
20600 [label="tupleData 271203"];
20601 [label="param SubstitutedNamedTypeSymbol(this) 271204"];
20602 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 271205"];
20603 [label="param WrappedNamedTypeSymbol(this) 271206"];
20604 [label="tupleData 271207"];
20605 [label="param WrappedNamedTypeSymbol(this) 271208"];
20606 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 271209"];
20607 [label="_lazyTupleData 271210"];
20608 [label="_underlyingType 271211"];
20609 [label="Debug.Assert((object)underlyingType != null); 271212"];
20610 [label="Debug.Assert((object)underlyingType != null); 271213"];
20611 [label="_unbound 271214"];
20612 [label="_inputMap 271215"];
20613 [label="_newContainer 271216"];
20614 [label="_lazyMap 271217"];
20615 [label="_hashCode 271218"];
20616 [label="_lazyMembersByNameCache 271219"];
20617 [label="originalDefinition.IsDefinition 271220"];
20618 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 271221"];
20619 [label="OriginalDefinition 271222"];
20620 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 271223"];
20621 [label="OriginalSymbolDefinition 271224"];
20622 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 271225"];
20623 [label="this.OriginalTypeSymbolDefinition 271226"];
20624 [label="get\n            {\n                return this.OriginalDefinition;\n            } 271227"];
20625 [label="this.OriginalDefinition 271228"];
20626 [label="get\n            {\n                return this;\n            } 271229"];
20627 [label="return this.OriginalDefinition; 271230"];
20628 [label="return this.OriginalTypeSymbolDefinition; 271231"];
20629 [label="return OriginalSymbolDefinition; 271232"];
20630 [label="return (object)this == (object)OriginalDefinition; 271233"];
20631 [label="Debug.Assert(originalDefinition.IsDefinition); 271234"];
20632 [label="Debug.Assert(!originalDefinition.IsErrorType()); 271235"];
20633 [label="originalDefinition.IsErrorType() 271236"];
20634 [label="param IsErrorType(this TypeSymbol type) 271237"];
20635 [label="RoslynDebug.Assert((object)type != null); 271238"];
20636 [label="RoslynDebug.Assert((object)type != null); 271239"];
20637 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 271240"];
20638 [label="Debug.Assert(!originalDefinition.IsErrorType()); 271241"];
20639 [label="_inputMap 271242"];
20640 [label="_unbound 271243"];
20641 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 271244"];
20642 [label="constructedFrom.ConstructedFrom 271245"];
20643 [label="get\n            {\n                return this;\n            } 271246"];
20644 [label="return this; 271247"];
20645 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 271248"];
20646 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 271249"];
20647 [label="EnsureTypeParametersAreLoaded(); 271250"];
20648 [label="_constructedFrom 271251"];
20649 [label="constructedFrom.Arity 271252"];
20650 [label="get\n                {\n                    return _arity;\n                } 271253"];
20651 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 271254"];
20652 [label="constructedFrom.Arity 271255"];
20653 [label="get\n                {\n                    return _arity;\n                } 271256"];
20654 [label="Debug.Assert(constructedFrom.Arity != 0); 271257"];
20655 [label="Debug.Assert(constructedFrom.Arity != 0); 271258"];
20656 [label="return constructedInterfaces.ToImmutableAndFree(); 271259"];
20657 [label="CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)) 271260"];
20658 [label="param CreateSZArray(TypeWithAnnotations elementTypeWithAnnotations) 271261"];
20659 [label="param CreateSZArray(NamedTypeSymbol array) 271262"];
20660 [label="param CreateSZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 271263"];
20661 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 271264"];
20662 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 271265"];
20663 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 271266"];
20664 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 271267"];
20665 [label="new SZArray(elementTypeWithAnnotations, array, constructedInterfaces) 271268"];
20666 [label="param SZArray(TypeWithAnnotations elementTypeWithAnnotations) 271269"];
20667 [label="param SZArray(NamedTypeSymbol array) 271270"];
20668 [label="param SZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 271271"];
20669 [label="param SZArray(this) 271272"];
20670 [label="elementTypeWithAnnotations 271273"];
20671 [label="array 271274"];
20672 [label="param SZArray(this) 271275"];
20673 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 271276"];
20674 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 271277"];
20675 [label="param ArrayTypeSymbol(this) 271278"];
20676 [label="param ArrayTypeSymbol(this) 271279"];
20677 [label="_lazyAdapter 271280"];
20678 [label="_baseType 271281"];
20679 [label="elementTypeWithAnnotations.HasType 271282"];
20680 [label="=> !(DefaultType is null) 271283"];
20681 [label="DefaultType is null 271284"];
20682 [label="!(DefaultType is null) 271285"];
20683 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 271286"];
20684 [label="RoslynDebug.Assert((object)array != null); 271287"];
20685 [label="RoslynDebug.Assert((object)array != null); 271288"];
20686 [label="_elementTypeWithAnnotations 271289"];
20687 [label="_baseType 271290"];
20688 [label="Debug.Assert(constructedInterfaces.Length <= 2); 271291"];
20689 [label="Debug.Assert(constructedInterfaces.Length <= 2); 271292"];
20690 [label="_interfaces 271293"];
20691 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 271294"];
20692 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 271295"];
20693 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271296"];
20694 [label="rankSpecifier.CloseBracketToken 271297"];
20695 [label="=> true 271298"];
20696 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271299"];
20697 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271300"];
20698 [label="AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken) 271301"];
20699 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 271302"];
20700 [label="ArrayBuilder<CSharpSyntaxNode>? nodes = null; 271303"];
20701 [label="SyntaxTree? tree = null; 271304"];
20702 [label="tree = node._syntaxTree; 271305"];
20703 [label="if (tree != null)\n                {\n                    break;\n                } 271306"];
20704 [label="if (tree != null)\n                {\n                    break;\n                } 271307"];
20705 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 271308"];
20706 [label="if (parent == null)\n                {\n                    // set the tree on the root node atomically\n                    Interlocked.CompareExchange(ref node._syntaxTree, CSharpSyntaxTree.CreateWithoutClone(node), null);\n                    tree = node._syntaxTree;\n                    break;\n                } 271309"];
20707 [label="Debug.Assert(result != null); 271310"];
20708 [label="Debug.Assert(result != null); 271311"];
20709 [label="Debug.Assert(index >= -1); 271312"];
20710 [label="Debug.Assert(index >= -1); 271313"];
20711 [label="Debug.Assert(index < _contexts.Length); 271314"];
20712 [label="if (index >= 0)\n            {\n                Debug.Assert(_contexts[index].Position <= position);\n                Debug.Assert(index == _contexts.Length - 1 || position < _contexts[index + 1].Position);\n            } 271315"];
20713 [label="if (index >= 0)\n            {\n                Debug.Assert(_contexts[index].Position <= position);\n                Debug.Assert(index == _contexts.Length - 1 || position < _contexts[index + 1].Position);\n            } 271316"];
20714 [label="0 271317"];
20715 [label="position: 0 271318"];
20716 [label="warningsState: NullableContextState.State.Unknown 271319"];
20717 [label="param IsGeneratedCode(CancellationToken cancellationToken) 271320"];
20718 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271321"];
20719 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271322"];
20720 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array) 271323"];
20721 [label="param Create(bool isNullableEnabled) 271324"];
20722 [label="param Create(TypeSymbol typeSymbol) 271325"];
20723 [label="param Create(bool isAnnotated = false) 271326"];
20724 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 271327"];
20725 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 271328"];
20726 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 271329"];
20727 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 271330"];
20728 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 271331"];
20729 [label="typeSymbol.IsNullableType() 271332"];
20730 [label="param IsNullableType(this TypeSymbol type) 271333"];
20731 [label="type.OriginalDefinition 271334"];
20732 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 271335"];
20733 [label="OriginalTypeSymbolDefinition 271336"];
20734 [label="get\n            {\n                return this;\n            } 271337"];
20735 [label="return this; 271338"];
20736 [label="return OriginalTypeSymbolDefinition; 271339"];
20737 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 271340"];
20738 [label="type.OriginalDefinition.SpecialType 271341"];
20739 [label="get\n            {\n                return SpecialType.None;\n            } 271342"];
20740 [label="return SpecialType.None; 271343"];
20741 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 271344"];
20742 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 271345"];
20743 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 271346"];
20744 [label="var a1 = defaultType is null; 271347"];
20745 [label="!a1 271348"];
20746 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 271349"];
20747 [label="defaultType.IsNullableType() 271350"];
20748 [label="param IsNullableType(this TypeSymbol type) 271351"];
20749 [label="type.OriginalDefinition 271352"];
20750 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 271353"];
20751 [label="OriginalTypeSymbolDefinition 271354"];
20752 [label="get\n            {\n                return this;\n            } 271355"];
20753 [label="return this; 271356"];
20754 [label="return OriginalTypeSymbolDefinition; 271357"];
20755 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 271358"];
20756 [label="type.OriginalDefinition.SpecialType 271359"];
20757 [label="get\n            {\n                return SpecialType.None;\n            } 271360"];
20758 [label="return SpecialType.None; 271361"];
20759 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 271362"];
20760 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 271363"];
20761 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 271364"];
20762 [label="Debug.Assert(a1 || a2 != true || a3); 271365"];
20763 [label="Debug.Assert(a1 || a2 != true || a3); 271366"];
20764 [label="Debug.Assert(extensions != null); 271367"];
20765 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 271368"];
20766 [label="return type; 271369"];
20767 [label="param operator(TypeWithAnnotations typeWithAnnotations) 271370"];
20768 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 271371"];
20769 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 271372"];
20770 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 271373"];
20771 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 271374"];
20772 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 271375"];
20773 [label="typeWithAnnotations.HasType 271376"];
20774 [label="=> !(DefaultType is null) 271377"];
20775 [label="DefaultType is null 271378"];
20776 [label="!(DefaultType is null) 271379"];
20777 [label="Debug.Assert(typeWithAnnotations.HasType); 271380"];
20778 [label="_symbol = null; 271381"];
20779 [label="_symbol 271382"];
20780 [label="_isNullableEnabled = false; 271383"];
20781 [label="_isNullableEnabled 271384"];
20782 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 271385"];
20783 [label="symbol.IsType 271386"];
20784 [label="=> !_typeWithAnnotations.IsDefault 271387"];
20785 [label="_typeWithAnnotations.IsDefault 271388"];
20786 [label="DefaultType is null 271389"];
20787 [label="param ReportDiagnosticsIfObsolete(Binder binder) 271390"];
20788 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 271391"];
20789 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 271392"];
20790 [label="binder 271393"];
20791 [label="syntax 271394"];
20792 [label="diagnostics 271395"];
20793 [label="param ReportDiagnosticsIfObsolete(Binder binder) 271396"];
20794 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 271397"];
20795 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 271398"];
20796 [label="param ReportDiagnosticsIfObsolete(this) 271399"];
20797 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 271400"];
20798 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 271401"];
20799 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 271402"];
20800 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 271403"];
20801 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 271404"];
20802 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 271405"];
20803 [label="=> defaultType 271406"];
20804 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 271407"];
20805 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 271408"];
20806 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 271409"];
20807 [label="param ReportDiagnosticsIfObsolete(this) 271410"];
20808 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 271411"];
20809 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 271412"];
20810 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 271413"];
20811 [label="param ReportDiagnosticsIfObsolete(this) 271414"];
20812 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 271415"];
20813 [label="return SymbolKind.ArrayType; 271416"];
20814 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 271417"];
20815 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 271418"];
20816 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 271419"];
20817 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 271420"];
20818 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 271421"];
20819 [label="param UnwrapAlias(DiagnosticBag diagnostics) 271422"];
20820 [label="param UnwrapAlias(SyntaxNode syntax) 271423"];
20821 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 271424"];
20822 [label="param UnwrapAlias(this) 271425"];
20823 [label="symbol.IsAlias 271426"];
20824 [label="=> _symbol?.Kind == SymbolKind.Alias 271427"];
20825 [label="_symbol 271428"];
20826 [label="_symbol?.Kind == SymbolKind.Alias 271429"];
20827 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 271430"];
20828 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 271431"];
20829 [label="baseBinder.BindType(typeSyntax, diagnostics, newBasesBeingResolved).Type 271432"];
20830 [label="=> _extensions?.GetResolvedType(DefaultType) 271433"];
20831 [label=".GetResolvedType(DefaultType) 271434"];
20832 [label="=> defaultType 271435"];
20833 [label="baseType.SpecialType 271436"];
20834 [label="get\n            {\n                return SpecialType.None;\n            } 271437"];
20835 [label="return SpecialType.None; 271438"];
20836 [label="SpecialType baseSpecialType = baseType.SpecialType; 271439"];
20837 [label="if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    } 271440"];
20838 [label="IsRestrictedBaseType(baseSpecialType) 271441"];
20839 [label="param IsRestrictedBaseType(SpecialType specialType) 271442"];
20840 [label="switch (specialType)\n            {\n                case SpecialType.System_Array:\n                case SpecialType.System_Enum:\n                case SpecialType.System_Delegate:\n                case SpecialType.System_MulticastDelegate:\n                case SpecialType.System_ValueType:\n                    return true;\n            } 271443"];
20841 [label="return false; 271444"];
20842 [label="if (IsRestrictedBaseType(baseSpecialType))\n                    {\n                        // check for one of the specific exceptions required for compiling mscorlib\n                        if (this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||\n                            this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate)\n                        {\n                            // allowed\n                        }\n                        else if (baseSpecialType == SpecialType.System_Array && this.ContainingAssembly.CorLibrary == this.ContainingAssembly)\n                        {\n                            // Specific exception for System.ArrayContracts, which is only built when CONTRACTS_FULL is defined.\n                            // (See InheritanceResolver::CheckForBaseClassErrors).\n                        }\n                        else\n                        {\n                            // '{0}' cannot derive from special class '{1}'\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromEnumOrValueType, location, this, baseType);\n                            continue;\n                        }\n                    } 271445"];
20843 [label="baseType.IsSealed 271446"];
20844 [label="get\n            {\n                return false;\n            } 271447"];
20845 [label="return false; 271448"];
20846 [label="if (baseType.IsSealed && !this.IsStatic) // Give precedence to ERR_StaticDerivedFromNonObject\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CantDeriveFromSealedType, location, this, baseType);\n                        continue;\n                    } 271449"];
20847 [label="bool baseTypeIsErrorWithoutInterfaceGuess = false; 271450"];
20848 [label="baseType.TypeKind 271451"];
20849 [label="get\n            {\n                return TypeKind.Array;\n            } 271452"];
20850 [label="return TypeKind.Array; 271453"];
20851 [label="if (baseType.TypeKind == TypeKind.Error)\n                    {\n                        baseTypeIsErrorWithoutInterfaceGuess = true;\n\n                        TypeKind guessTypeKind = baseType.GetNonErrorTypeKindGuess();\n                        if (guessTypeKind == TypeKind.Interface)\n                        {\n                            //base type is an error *with* a guessed interface\n                            baseTypeIsErrorWithoutInterfaceGuess = false;\n                        }\n                    } 271454"];
20852 [label="baseType.TypeKind 271455"];
20853 [label="get\n            {\n                return TypeKind.Array;\n            } 271456"];
20854 [label="return TypeKind.Array; 271457"];
20855 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271458"];
20856 [label="baseType.TypeKind 271459"];
20857 [label="get\n            {\n                return TypeKind.Array;\n            } 271460"];
20858 [label="return TypeKind.Array; 271461"];
20859 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271462"];
20860 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271463"];
20861 [label="baseType.TypeKind 271464"];
20862 [label="get\n            {\n                return TypeKind.Array;\n            } 271465"];
20863 [label="return TypeKind.Array; 271466"];
20864 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271467"];
20865 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271468"];
20866 [label="if ((baseType.TypeKind == TypeKind.Class ||\n                         baseType.TypeKind == TypeKind.Delegate ||\n                         baseType.TypeKind == TypeKind.Struct ||\n                         baseTypeIsErrorWithoutInterfaceGuess) &&\n                        ((object)localBase == null))\n                    {\n                        localBase = (NamedTypeSymbol)baseType;\n                        Debug.Assert((object)localBase != null);\n                        if (this.IsStatic && localBase.SpecialType != SpecialType.System_Object)\n                        {\n                            // Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.\n                            var info = diagnostics.Add(ErrorCode.ERR_StaticDerivedFromNonObject, location, this, localBase);\n                            localBase = new ExtendedErrorTypeSymbol(localBase, LookupResultKind.NotReferencable, info);\n                        }\n                        continue;\n                    } 271469"];
20867 [label="baseType.TypeKind 271470"];
20868 [label="get\n            {\n                return TypeKind.Array;\n            } 271471"];
20869 [label="return TypeKind.Array; 271472"];
20870 [label="switch (baseType.TypeKind)\n                {\n                    case TypeKind.Interface:\n                        foreach (var t in localInterfaces)\n                        {\n                            if (t.Equals(baseType, TypeCompareKind.ConsiderEverything))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateInterfaceInBaseList, location, baseType);\n                            }\n                            else if (t.Equals(baseType, TypeCompareKind.ObliviousNullableModifierMatchesAny))\n                            {\n                                // duplicates with ?/! differences are reported later, we report local differences between oblivious and ?/! here\n                                diagnostics.Add(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, location, baseType, this);\n                            }\n                        }\n\n                        if (this.IsStatic)\n                        {\n                            // '{0}': static classes cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_StaticClassInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (this.IsRefLikeType)\n                        {\n                            // '{0}': ref structs cannot implement interfaces\n                            diagnostics.Add(ErrorCode.ERR_RefStructInterfaceImpl, location, this, baseType);\n                        }\n\n                        if (baseType.ContainsDynamic())\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DeriveFromConstructedDynamic, location, this, baseType);\n                        }\n\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Class:\n                        if (TypeKind == TypeKind.Class)\n                        {\n                            if ((object)localBase == null)\n                            {\n                                localBase = (NamedTypeSymbol)baseType;\n                                diagnostics.Add(ErrorCode.ERR_BaseClassMustBeFirst, location, baseType);\n                                continue;\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NoMultipleInheritance, location, this, localBase, baseType);\n                                continue;\n                            }\n                        }\n                        goto default;\n\n                    case TypeKind.TypeParameter:\n                        diagnostics.Add(ErrorCode.ERR_DerivingFromATyVar, location, baseType);\n                        continue;\n\n                    case TypeKind.Error:\n                        // put the error type in the interface list so we don't lose track of it\n                        localInterfaces.Add((NamedTypeSymbol)baseType);\n                        continue;\n\n                    case TypeKind.Dynamic:\n                        diagnostics.Add(ErrorCode.ERR_DeriveFromDynamic, location, this);\n                        continue;\n\n                    case TypeKind.Submission:\n                        throw ExceptionUtilities.UnexpectedValue(baseType.TypeKind);\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType);\n                        continue;\n                } 271473"];
20871 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 271474"];
20872 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 271475"];
20873 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 271476"];
20874 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 271477"];
20875 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType) 271478"];
20876 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType) 271479"];
20877 [label="param Add(this DiagnosticBag diagnostics) 271480"];
20878 [label="param Add(ErrorCode code) 271481"];
20879 [label="param Add(Location location) 271482"];
20880 [label="param Add(params object[] args) 271483"];
20881 [label="var info = new CSDiagnosticInfo(code, args); 271484"];
20882 [label="var info = new CSDiagnosticInfo(code, args); 271485"];
20883 [label="var info = new CSDiagnosticInfo(code, args); 271486"];
20884 [label="new CSDiagnosticInfo(code, args) 271487"];
20885 [label="param CSDiagnosticInfo(ErrorCode code) 271488"];
20886 [label="param CSDiagnosticInfo(params object[] args) 271489"];
20887 [label="param CSDiagnosticInfo(this) 271490"];
20888 [label="code 271491"];
20889 [label="args 271492"];
20890 [label="ImmutableArray<Symbol>.Empty 271493"];
20891 [label="ImmutableArray<Location>.Empty 271494"];
20892 [label="param CSDiagnosticInfo(this) 271495"];
20893 [label="param CSDiagnosticInfo(ErrorCode code) 271496"];
20894 [label="param CSDiagnosticInfo(object[] args) 271497"];
20895 [label="param CSDiagnosticInfo(ImmutableArray<Symbol> symbols) 271498"];
20896 [label="param CSDiagnosticInfo(ImmutableArray<Location> additionalLocations) 271499"];
20897 [label="param DiagnosticInfoWithSymbols(this) 271500"];
20898 [label="param GetSeverity(this) 271501"];
20899 [label="Debug.Assert(code != ErrorCode.ERR_InternalError); 271502"];
20900 [label="_additionalLocations 271503"];
20901 [label="var diag = new CSDiagnostic(info, location); 271504"];
20902 [label="var diag = new CSDiagnostic(info, location); 271505"];
20903 [label="var diag = new CSDiagnostic(info, location); 271506"];
20904 [label="new CSDiagnostic(info, location) 271507"];
20905 [label="param CSDiagnostic(DiagnosticInfo info) 271508"];
20906 [label="param CSDiagnostic(Location location) 271509"];
20907 [label="param CSDiagnostic(bool isSuppressed = false) 271510"];
20908 [label="param CSDiagnostic(this) 271511"];
20909 [label="info 271512"];
20910 [label="isSuppressed 271513"];
20911 [label="param CSDiagnostic(this) 271514"];
20912 [label="param CSDiagnostic(this) 271515"];
20913 [label="diagnostics.Add(diag); 271516"];
20914 [label="diagnostics.Add(diag); 271517"];
20915 [label="return info; 271518"];
20916 [label="diagnostics.Add(ErrorCode.ERR_NonInterfaceInInterfaceList, location, baseType); 271519"];
20917 [label="this.SpecialType 271520"];
20918 [label="get\n            {\n                return _flags.SpecialType;\n            } 271521"];
20919 [label="_flags.SpecialType 271522"];
20920 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 271523"];
20921 [label="if (this.SpecialType == SpecialType.System_Object && ((object)localBase != null || localInterfaces.Count != 0))\n            {\n                var name = GetName(bases.Parent);\n                diagnostics.Add(ErrorCode.ERR_ObjectCantHaveBases, new SourceLocation(name));\n            } 271524"];
20922 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 271525"];
20923 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 271526"];
20924 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(localBase, localInterfaces.ToImmutableAndFree()); 271527"];
20925 [label="if ((object)one == null) continue; 271528"];
20926 [label="if ((object)one == null) continue; 271529"];
20927 [label="var partBase = one.Item1; 271530"];
20928 [label="var partInterfaces = one.Item2; 271531"];
20929 [label="if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                } 271532"];
20930 [label="if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    } 271533"];
20931 [label="if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    } 271534"];
20932 [label="baseType = partBase; 271535"];
20933 [label="decl.NameLocation 271536"];
20934 [label="return _nameLocation; 271537"];
20935 [label="baseTypeLocation = decl.NameLocation; 271538"];
20936 [label="foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                } 271539"];
20937 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 271540"];
20938 [label="declaration.Kind 271541"];
20939 [label="get\n            {\n                return this.Declarations[0].Kind;\n            } 271542"];
20940 [label="if (declaration.Kind == DeclarationKind.Record)\n            {\n                var type = DeclaringCompilation.GetWellKnownType(WellKnownType.System_IEquatable_T).Construct(this);\n                if (baseInterfaces.IndexOf(type, SymbolEqualityComparer.AllIgnoreOptions) < 0)\n                {\n                    baseInterfaces.Add(type);\n                    type.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                }\n            } 271543"];
20941 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 271544"];
20942 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 271545"];
20943 [label="var baseInterfacesRO = baseInterfaces.ToImmutableAndFree(); 271546"];
20944 [label="DeclaredAccessibility 271547"];
20945 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 271548"];
20946 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 271549"];
20947 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 271550"];
20948 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 271551"];
20949 [label="IsInterface 271552"];
20950 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 271553"];
20951 [label="this.TypeKind 271554"];
20952 [label="get\n            {\n                return _flags.TypeKind;\n            } 271555"];
20953 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 271556"];
20954 [label="return this.TypeKind == TypeKind.Interface; 271557"];
20955 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 271558"];
20956 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 271559"];
20957 [label="interfaceLocations.Free(); 271560"];
20958 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 271561"];
20959 [label="Locations 271562"];
20960 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 271563"];
20961 [label="get\n            {\n                if (Declarations.Length == 1)\n                {\n                    return ImmutableArray.Create(Declarations[0].NameLocation);\n                }\n                else\n                {\n                    var builder = ArrayBuilder<SourceLocation>.GetInstance();\n                    foreach (var decl in Declarations)\n                    {\n                        SourceLocation loc = decl.NameLocation;\n                        if (loc != null)\n                            builder.Add(loc);\n                    }\n                    return builder.ToImmutableAndFree();\n                }\n            } 271564"];
20962 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 271565"];
20963 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 271566"];
20964 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 271567"];
20965 [label="diagnostics.Add(Locations[0], useSiteDiagnostics) 271568"];
20966 [label="param Add(this DiagnosticBag diagnostics) 271569"];
20967 [label="param Add(Location location) 271570"];
20968 [label="param Add(HashSet<DiagnosticInfo> useSiteDiagnostics) 271571"];
20969 [label="if (useSiteDiagnostics.IsNullOrEmpty())\n            {\n                return false;\n            } 271572"];
20970 [label="return false; 271573"];
20971 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 271574"];
20972 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 271575"];
20973 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 271576"];
20974 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 271577"];
20975 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 271578"];
20976 [label="AddDeclarationDiagnostics(diagnostics); 271579"];
20977 [label="AddDeclarationDiagnostics(diagnostics) 271580"];
20978 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 271581"];
20979 [label="param AddDeclarationDiagnostics(this) 271582"];
20980 [label="ContainingSymbol 271583"];
20981 [label="get\n            {\n                return _containingSymbol;\n            } 271584"];
20982 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 271585"];
20983 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 271586"];
20984 [label="this.DeclaringCompilation 271587"];
20985 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 271588"];
20986 [label="this.Kind 271589"];
20987 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 271590"];
20988 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 271591"];
20989 [label="CSharpCompilation compilation = this.DeclaringCompilation; 271592"];
20990 [label="Debug.Assert(compilation != null); 271593"];
20991 [label="Debug.Assert(compilation != null); 271594"];
20992 [label="compilation.DeclarationDiagnostics 271595"];
20993 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 271596"];
20994 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 271597"];
20995 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 271598"];
20996 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 271599"];
20997 [label="AddDeclarationDiagnostics(diagnostics); 271600"];
20998 [label="diagnostics.Free(); 271601"];
20999 [label="return _lazyDeclaredBases; 271602"];
21000 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 271603"];
21001 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 271604"];
21002 [label="switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                } 271605"];
21003 [label="this.SpecialType 271606"];
21004 [label="if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        } 271607"];
21005 [label="declaredBase = compilation.GetSpecialType(SpecialType.System_Object); 271608"];
21006 [label="compilation.GetSpecialType(SpecialType.System_Object) 271609"];
21007 [label="param GetSpecialType(SpecialType specialType) 271610"];
21008 [label="param GetSpecialType(this) 271611"];
21009 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 271612"];
21010 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 271613"];
21011 [label="NamedTypeSymbol result; 271614"];
21012 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 271615"];
21013 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 271616"];
21014 [label="Assembly 271617"];
21015 [label="GetBoundReferenceManager(); 271618"];
21016 [label="result = Assembly.GetSpecialType(specialType); 271619"];
21017 [label="result = Assembly.GetSpecialType(specialType); 271620"];
21018 [label="Assembly.GetSpecialType(specialType) 271621"];
21019 [label="param GetSpecialType(SpecialType type) 271622"];
21020 [label="param GetSpecialType(this) 271623"];
21021 [label="this.Modules 271624"];
21022 [label="get\n            {\n                return _modules;\n            } 271625"];
21023 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 271626"];
21024 [label="module.GetReferencedAssemblies() 271627"];
21025 [label="param GetReferencedAssemblies(this) 271628"];
21026 [label="AssertReferencesInitialized() 271629"];
21027 [label="param AssertReferencesInitialized(this) 271630"];
21028 [label="Debug.Assert(_moduleReferences != null); 271631"];
21029 [label="Debug.Assert(_moduleReferences != null); 271632"];
21030 [label="AssertReferencesInitialized(); 271633"];
21031 [label="return _moduleReferences.Identities; 271634"];
21032 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 271635"];
21033 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 271636"];
21034 [label="result.SpecialType 271637"];
21035 [label="get\n            {\n                return _corTypeId;\n            } 271638"];
21036 [label="Debug.Assert(result.SpecialType == specialType); 271639"];
21037 [label="return result; 271640"];
21038 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 271641"];
21039 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 271642"];
21040 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 271643"];
21041 [label="param TypeDependsOn(NamedTypeSymbol depends) 271644"];
21042 [label="param TypeDependsOn(NamedTypeSymbol on) 271645"];
21043 [label="Debug.Assert((object)depends != null); 271646"];
21044 [label="Debug.Assert((object)depends != null); 271647"];
21045 [label="Debug.Assert((object)on != null); 271648"];
21046 [label="Debug.Assert((object)on != null); 271649"];
21047 [label="on.IsDefinition 271650"];
21048 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 271651"];
21049 [label="OriginalDefinition 271652"];
21050 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 271653"];
21051 [label="OriginalSymbolDefinition 271654"];
21052 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 271655"];
21053 [label="this.OriginalTypeSymbolDefinition 271656"];
21054 [label="get\n            {\n                return this.OriginalDefinition;\n            } 271657"];
21055 [label="this.OriginalDefinition 271658"];
21056 [label="get\n            {\n                return this;\n            } 271659"];
21057 [label="return this; 271660"];
21058 [label="return this.OriginalDefinition; 271661"];
21059 [label="return this.OriginalTypeSymbolDefinition; 271662"];
21060 [label="return OriginalSymbolDefinition; 271663"];
21061 [label="return (object)this == (object)OriginalDefinition; 271664"];
21062 [label="Debug.Assert(on.IsDefinition); 271665"];
21063 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 271666"];
21064 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 271667"];
21065 [label="depends.DeclaringCompilation 271668"];
21066 [label="get { return null; } 271669"];
21067 [label="return null; 271670"];
21068 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 271671"];
21069 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 271672"];
21070 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 271673"];
21071 [label="param TypeDependsClosure(NamedTypeSymbol type) 271674"];
21072 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 271675"];
21073 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 271676"];
21074 [label="if ((object)type == null)\n            {\n                return;\n            } 271677"];
21075 [label="if ((object)type == null)\n            {\n                return;\n            } 271678"];
21076 [label="type.OriginalDefinition 271679"];
21077 [label="get\n            {\n                return this;\n            } 271680"];
21078 [label="type = type.OriginalDefinition; 271681"];
21079 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 271682"];
21080 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 271683"];
21081 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 271684"];
21082 [label="param GetHashCode(this) 271685"];
21083 [label="this.SpecialType 271686"];
21084 [label="get\n            {\n                return _corTypeId;\n            } 271687"];
21085 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 271688"];
21086 [label="return (int)SpecialType.System_Object; 271689"];
21087 [label="type.IsInterface 271690"];
21088 [label="get\n            {\n                return _flags.IsInterface();\n            } 271691"];
21089 [label="return _flags.IsInterface(); 271692"];
21090 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 271693"];
21091 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 271694"];
21092 [label="type.GetDeclaredBaseType(null) 271695"];
21093 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 271696"];
21094 [label="param GetDeclaredBaseType(this) 271697"];
21095 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 271698"];
21096 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 271699"];
21097 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 271700"];
21098 [label="param GetDeclaredBaseType(this) 271701"];
21099 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 271702"];
21100 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 271703"];
21101 [label="MakeDeclaredBaseType() 271704"];
21102 [label="param MakeDeclaredBaseType(this) 271705"];
21103 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 271706"];
21104 [label="ContainingPEModule 271707"];
21105 [label="s.Kind 271708"];
21106 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 271709"];
21107 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 271710"];
21108 [label="var moduleSymbol = ContainingPEModule; 271711"];
21109 [label="moduleSymbol.Module 271712"];
21110 [label="get\n            {\n                return _module;\n            } 271713"];
21111 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 271714"];
21112 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 271715"];
21113 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 271716"];
21114 [label="return null; 271717"];
21115 [label="var baseType = MakeDeclaredBaseType(); 271718"];
21116 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 271719"];
21117 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 271720"];
21118 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 271721"];
21119 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 271722"];
21120 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 271723"];
21121 [label="return _lazyDeclaredBaseType; 271724"];
21122 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 271725"];
21123 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 271726"];
21124 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 271727"];
21125 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 271728"];
21126 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 271729"];
21127 [label="param TypeDependsClosure(NamedTypeSymbol type) 271730"];
21128 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 271731"];
21129 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 271732"];
21130 [label="if ((object)type == null)\n            {\n                return;\n            } 271733"];
21131 [label="if ((object)type == null)\n            {\n                return;\n            } 271734"];
21132 [label="return; 271735"];
21133 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 271736"];
21134 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 271737"];
21135 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 271738"];
21136 [label="var result = hs.Contains(on); 271739"];
21137 [label="var result = hs.Contains(on); 271740"];
21138 [label="var result = hs.Contains(on); 271741"];
21139 [label="this.SpecialType 271742"];
21140 [label="_flags.SpecialType 271743"];
21141 [label="OriginalDefinition 271744"];
21142 [label="get\n            {\n                return this;\n            } 271745"];
21143 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 271746"];
21144 [label="hs.Free(); 271747"];
21145 [label="return result; 271748"];
21146 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 271749"];
21147 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 271750"];
21148 [label="_hasNoBaseCycles = true; 271751"];
21149 [label="_hasNoBaseCycles 271752"];
21150 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 271753"];
21151 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 271754"];
21152 [label="NamedTypeSymbol current = declaredBase; 271755"];
21153 [label="current.DeclaringCompilation 271756"];
21154 [label="get { return null; } 271757"];
21155 [label="return null; 271758"];
21156 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 271759"];
21157 [label="this.DeclaringCompilation 271760"];
21158 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 271761"];
21159 [label="this.Kind 271762"];
21160 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 271763"];
21161 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 271764"];
21162 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 271765"];
21163 [label="this.ContainingSymbol 271766"];
21164 [label="get\n            {\n                return _containingSymbol;\n            } 271767"];
21165 [label="return _containingSymbol; 271768"];
21166 [label="return (object)container != null ? container.ContainingModule : null; 271769"];
21167 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 271770"];
21168 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 271771"];
21169 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 271772"];
21170 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 271773"];
21171 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics) 271774"];
21172 [label="param AddUseSiteDiagnostics(this TypeSymbol type) 271775"];
21173 [label="param AddUseSiteDiagnostics(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 271776"];
21174 [label="type.GetUseSiteDiagnostic() 271777"];
21175 [label="param GetUseSiteDiagnostic(this) 271778"];
21176 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 271779"];
21177 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 271780"];
21178 [label="GetUseSiteDiagnosticImpl() 271781"];
21179 [label="param GetUseSiteDiagnosticImpl(this) 271782"];
21180 [label="DiagnosticInfo diagnostic = null; 271783"];
21181 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 271784"];
21182 [label="CalculateUseSiteDiagnostic() 271785"];
21183 [label="param CalculateUseSiteDiagnostic(this) 271786"];
21184 [label="DiagnosticInfo result = null; 271787"];
21185 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 271788"];
21186 [label="DeriveUseSiteDiagnosticFromBase() 271789"];
21187 [label="param DeriveUseSiteDiagnosticFromBase(this) 271790"];
21188 [label="this.BaseTypeNoUseSiteDiagnostics 271791"];
21189 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 271792"];
21190 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 271793"];
21191 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 271794"];
21192 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 271795"];
21193 [label="MakeAcyclicBaseType() 271796"];
21194 [label="param MakeAcyclicBaseType(this) 271797"];
21195 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 271798"];
21196 [label="GetDeclaredBaseType(null) 271799"];
21197 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 271800"];
21198 [label="param GetDeclaredBaseType(this) 271801"];
21199 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 271802"];
21200 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 271803"];
21201 [label="return _lazyDeclaredBaseType; 271804"];
21202 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 271805"];
21203 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 271806"];
21204 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 271807"];
21205 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 271808"];
21206 [label="return null; 271809"];
21207 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 271810"];
21208 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 271811"];
21209 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 271812"];
21210 [label="return _lazyBaseType; 271813"];
21211 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 271814"];
21212 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 271815"];
21213 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 271816"];
21214 [label="return null; 271817"];
21215 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 271818"];
21216 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 271819"];
21217 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 271820"];
21218 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 271821"];
21219 [label="param MergeUseSiteDiagnostics(this) 271822"];
21220 [label="if (info == null)\n            {\n                return false;\n            } 271823"];
21221 [label="if (info == null)\n            {\n                return false;\n            } 271824"];
21222 [label="return false; 271825"];
21223 [label="this.ContainingModule 271826"];
21224 [label="get\n            {\n                return ContainingPEModule;\n            } 271827"];
21225 [label="ContainingPEModule 271828"];
21226 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 271829"];
21227 [label="Symbol s = _container; 271830"];
21228 [label="s.Kind 271831"];
21229 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 271832"];
21230 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 271833"];
21231 [label="return ContainingPEModule; 271834"];
21232 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 271835"];
21233 [label="this.ContainingModule.HasUnifiedReferences 271836"];
21234 [label="get { return GetUnifiedAssemblies().Length > 0; } 271837"];
21235 [label="GetUnifiedAssemblies() 271838"];
21236 [label="param GetUnifiedAssemblies(this) 271839"];
21237 [label="AssertReferencesInitialized() 271840"];
21238 [label="param AssertReferencesInitialized(this) 271841"];
21239 [label="Debug.Assert(_moduleReferences != null); 271842"];
21240 [label="Debug.Assert(_moduleReferences != null); 271843"];
21241 [label="AssertReferencesInitialized(); 271844"];
21242 [label="return GetUnifiedAssemblies().Length > 0; 271845"];
21243 [label="return GetUnifiedAssemblies().Length > 0; 271846"];
21244 [label="return result; 271847"];
21245 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 271848"];
21246 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 271849"];
21247 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 271850"];
21248 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 271851"];
21249 [label="param MergeUseSiteDiagnostics(this) 271852"];
21250 [label="if (info == null)\n            {\n                return false;\n            } 271853"];
21251 [label="if (info == null)\n            {\n                return false;\n            } 271854"];
21252 [label="return false; 271855"];
21253 [label="this.ContainingPEModule 271856"];
21254 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 271857"];
21255 [label="Symbol s = _container; 271858"];
21256 [label="s.Kind 271859"];
21257 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 271860"];
21258 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 271861"];
21259 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 271862"];
21260 [label="this.ContainingPEModule.Module 271863"];
21261 [label="get\n            {\n                return _module;\n            } 271864"];
21262 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 271865"];
21263 [label="TypeKind 271866"];
21264 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 271867"];
21265 [label="TypeKind result = _lazyKind; 271868"];
21266 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 271869"];
21267 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 271870"];
21268 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 271871"];
21269 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 271872"];
21270 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 271873"];
21271 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 271874"];
21272 [label="result = TypeKind.Class; 271875"];
21273 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 271876"];
21274 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 271877"];
21275 [label="_lazyKind 271878"];
21276 [label="return result; 271879"];
21277 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 271880"];
21278 [label="SpecialType 271881"];
21279 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 271882"];
21280 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 271883"];
21281 [label="TypeSymbol @base = GetDeclaredBaseType(null); 271884"];
21282 [label="GetDeclaredBaseType(null) 271885"];
21283 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 271886"];
21284 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 271887"];
21285 [label="TypeSymbol @base = GetDeclaredBaseType(null); 271888"];
21286 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 271889"];
21287 [label="return diagnostic; 271890"];
21288 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 271891"];
21289 [label="_lazyUseSiteDiagnostic 271892"];
21290 [label="return _lazyUseSiteDiagnostic; 271893"];
21291 [label="DiagnosticInfo errorInfo = type.GetUseSiteDiagnostic(); 271894"];
21292 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 271895"];
21293 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 271896"];
21294 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 271897"];
21295 [label="current.BaseTypeNoUseSiteDiagnostics 271898"];
21296 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 271899"];
21297 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 271900"];
21298 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 271901"];
21299 [label="return _lazyBaseType; 271902"];
21300 [label="current = current.BaseTypeNoUseSiteDiagnostics; 271903"];
21301 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 271904"];
21302 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 271905"];
21303 [label="if (!useSiteDiagnostics.IsNullOrEmpty())\n            {\n                diagnostics.Add(FindBaseRefSyntax(declaredBase) ?? Locations[0], useSiteDiagnostics);\n            } 271906"];
21304 [label="return declaredBase; 271907"];
21305 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 271908"];
21306 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 271909"];
21307 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 271910"];
21308 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 271911"];
21309 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 271912"];
21310 [label="AddDeclarationDiagnostics(diagnostics); 271913"];
21311 [label="AddDeclarationDiagnostics(diagnostics) 271914"];
21312 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 271915"];
21313 [label="ContainingSymbol 271916"];
21314 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 271917"];
21315 [label="AddDeclarationDiagnostics(diagnostics); 271918"];
21316 [label="diagnostics.Free(); 271919"];
21317 [label="return _lazyBaseType; 271920"];
21318 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 271921"];
21319 [label="CustomAssert.Equal('Object', bt.Name); 271922"];
21320 [label="bt.Name 271923"];
21321 [label="get\n            {\n                return _name;\n            } 271924"];
21322 [label="CustomAssert.Equal('Object', bt.Name); 271925"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
195 -> 2;
195 -> 194;
196 -> 1;
197 -> 1;
198 -> 197;
198 -> 1;
199 -> 1;
200 -> 198;
200 -> 199;
201 -> 200;
201 -> 199;
202 -> 199;
203 -> 201;
203 -> 202;
204 -> 202;
205 -> 203;
205 -> 204;
205 -> 202;
206 -> 202;
206 -> 1;
207 -> 1;
208 -> 1;
209 -> 206;
209 -> 208;
210 -> 207;
210 -> 208;
211 -> 207;
211 -> 208;
212 -> 207;
212 -> 208;
213 -> 207;
213 -> 208;
214 -> 207;
214 -> 208;
215 -> 207;
215 -> 208;
216 -> 207;
216 -> 208;
217 -> 209;
217 -> 208;
218 -> 213;
218 -> 208;
219 -> 210;
219 -> 208;
220 -> 208;
221 -> 218;
221 -> 220;
222 -> 219;
222 -> 220;
223 -> 221;
223 -> 220;
224 -> 220;
225 -> 223;
225 -> 224;
226 -> 225;
226 -> 224;
227 -> 226;
228 -> 0;
228 -> 227;
229 -> 228;
230 -> 229;
231 -> 229;
232 -> 0;
232 -> 231;
233 -> 232;
233 -> 230;
233 -> 229;
234 -> 233;
234 -> 227;
235 -> 220;
236 -> 222;
236 -> 235;
236 -> 220;
237 -> 234;
237 -> 236;
238 -> 211;
238 -> 208;
239 -> 212;
239 -> 208;
240 -> 214;
240 -> 208;
241 -> 215;
241 -> 208;
242 -> 216;
242 -> 208;
243 -> 208;
244 -> 217;
244 -> 243;
245 -> 237;
245 -> 243;
246 -> 238;
246 -> 243;
247 -> 239;
247 -> 243;
248 -> 240;
248 -> 243;
249 -> 241;
249 -> 243;
250 -> 242;
250 -> 243;
251 -> 244;
251 -> 243;
252 -> 245;
252 -> 243;
253 -> 246;
253 -> 243;
254 -> 247;
254 -> 243;
255 -> 248;
255 -> 243;
256 -> 249;
256 -> 243;
257 -> 250;
257 -> 243;
258 -> 243;
259 -> 258;
259 -> 243;
260 -> 243;
261 -> 251;
261 -> 260;
262 -> 252;
262 -> 260;
263 -> 253;
263 -> 260;
264 -> 254;
264 -> 260;
265 -> 255;
265 -> 260;
266 -> 256;
266 -> 260;
267 -> 257;
267 -> 260;
268 -> 259;
268 -> 260;
269 -> 264;
269 -> 260;
270 -> 266;
270 -> 260;
271 -> 260;
272 -> 269;
272 -> 271;
273 -> 270;
273 -> 271;
274 -> 261;
274 -> 271;
275 -> 274;
275 -> 205;
275 -> 271;
276 -> 275;
277 -> 273;
277 -> 275;
278 -> 272;
278 -> 275;
279 -> 275;
280 -> 276;
280 -> 279;
281 -> 277;
281 -> 279;
282 -> 278;
282 -> 279;
283 -> 276;
283 -> 279;
284 -> 279;
285 -> 282;
285 -> 284;
285 -> 279;
287 -> 286;
288 -> 286;
289 -> 286;
290 -> 286;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 288;
293 -> 286;
294 -> 289;
294 -> 286;
295 -> 290;
295 -> 286;
296 -> 295;
296 -> 286;
297 -> 0;
297 -> 286;
298 -> 292;
298 -> 291;
299 -> 293;
299 -> 291;
300 -> 294;
300 -> 291;
301 -> 296;
301 -> 291;
302 -> 297;
302 -> 291;
303 -> 291;
304 -> 300;
304 -> 291;
305 -> 299;
305 -> 291;
306 -> 303;
306 -> 304;
306 -> 305;
306 -> 291;
307 -> 303;
307 -> 291;
308 -> 303;
308 -> 291;
309 -> 303;
309 -> 291;
310 -> 298;
310 -> 303;
310 -> 291;
311 -> 298;
311 -> 291;
312 -> 291;
313 -> 311;
313 -> 312;
314 -> 313;
314 -> 312;
315 -> 0;
315 -> 314;
316 -> 315;
316 -> 303;
316 -> 291;
317 -> 301;
317 -> 291;
318 -> 317;
318 -> 303;
318 -> 291;
319 -> 302;
319 -> 291;
320 -> 0;
320 -> 291;
321 -> 319;
321 -> 303;
321 -> 291;
322 -> 286;
323 -> 0;
324 -> 0;
326 -> 323;
326 -> 325;
327 -> 324;
327 -> 325;
328 -> 325;
329 -> 325;
330 -> 325;
331 -> 326;
331 -> 325;
332 -> 327;
332 -> 325;
333 -> 328;
333 -> 325;
334 -> 329;
334 -> 325;
335 -> 334;
335 -> 325;
336 -> 0;
336 -> 325;
337 -> 331;
337 -> 330;
338 -> 332;
338 -> 330;
339 -> 333;
339 -> 330;
340 -> 335;
340 -> 330;
341 -> 336;
341 -> 330;
342 -> 330;
343 -> 339;
343 -> 330;
344 -> 338;
344 -> 330;
345 -> 342;
345 -> 343;
345 -> 344;
345 -> 330;
346 -> 342;
346 -> 330;
347 -> 342;
347 -> 330;
348 -> 342;
348 -> 330;
349 -> 337;
349 -> 342;
349 -> 330;
350 -> 337;
350 -> 330;
351 -> 330;
352 -> 350;
352 -> 351;
353 -> 352;
353 -> 351;
354 -> 0;
354 -> 353;
355 -> 354;
355 -> 342;
355 -> 330;
356 -> 340;
356 -> 330;
357 -> 356;
357 -> 342;
357 -> 330;
358 -> 341;
358 -> 330;
359 -> 358;
359 -> 319;
359 -> 330;
360 -> 0;
360 -> 330;
361 -> 359;
361 -> 342;
361 -> 330;
362 -> 325;
363 -> 0;
365 -> 363;
365 -> 364;
366 -> 362;
366 -> 364;
367 -> 365;
367 -> 366;
367 -> 345;
367 -> 364;
368 -> 365;
368 -> 364;
369 -> 366;
369 -> 364;
370 -> 364;
371 -> 364;
372 -> 369;
372 -> 371;
373 -> 370;
373 -> 371;
374 -> 372;
374 -> 345;
374 -> 348;
374 -> 349;
374 -> 371;
375 -> 372;
375 -> 345;
375 -> 371;
376 -> 372;
376 -> 345;
376 -> 371;
377 -> 372;
377 -> 345;
377 -> 357;
377 -> 371;
378 -> 371;
379 -> 372;
379 -> 378;
380 -> 379;
380 -> 345;
380 -> 346;
380 -> 361;
380 -> 378;
381 -> 371;
382 -> 374;
382 -> 381;
383 -> 375;
383 -> 381;
384 -> 376;
384 -> 381;
385 -> 377;
385 -> 381;
386 -> 380;
386 -> 381;
387 -> 373;
387 -> 381;
388 -> 381;
389 -> 388;
389 -> 384;
389 -> 383;
389 -> 381;
390 -> 388;
390 -> 381;
391 -> 388;
391 -> 381;
392 -> 388;
392 -> 381;
393 -> 382;
393 -> 381;
394 -> 381;
395 -> 393;
395 -> 394;
396 -> 395;
396 -> 394;
397 -> 0;
397 -> 396;
398 -> 397;
398 -> 388;
398 -> 381;
399 -> 385;
399 -> 345;
399 -> 346;
399 -> 361;
399 -> 347;
399 -> 355;
399 -> 348;
399 -> 349;
399 -> 357;
399 -> 356;
399 -> 359;
399 -> 381;
400 -> 386;
400 -> 399;
400 -> 381;
401 -> 0;
401 -> 381;
402 -> 365;
402 -> 370;
402 -> 364;
403 -> 368;
403 -> 370;
403 -> 364;
404 -> 370;
405 -> 0;
407 -> 405;
407 -> 406;
408 -> 362;
408 -> 406;
409 -> 407;
409 -> 408;
409 -> 400;
409 -> 406;
410 -> 407;
410 -> 406;
411 -> 406;
412 -> 410;
412 -> 411;
413 -> 412;
413 -> 411;
414 -> 412;
414 -> 413;
415 -> 408;
415 -> 406;
416 -> 406;
417 -> 406;
418 -> 415;
418 -> 417;
419 -> 416;
419 -> 417;
420 -> 418;
420 -> 400;
420 -> 417;
421 -> 418;
421 -> 400;
421 -> 417;
422 -> 418;
422 -> 400;
422 -> 417;
423 -> 418;
423 -> 400;
423 -> 417;
424 -> 417;
425 -> 418;
425 -> 424;
426 -> 425;
426 -> 400;
426 -> 424;
427 -> 417;
428 -> 419;
428 -> 427;
429 -> 427;
430 -> 429;
430 -> 422;
430 -> 421;
430 -> 427;
431 -> 429;
431 -> 427;
432 -> 429;
432 -> 427;
433 -> 429;
433 -> 427;
434 -> 427;
435 -> 0;
435 -> 427;
436 -> 407;
436 -> 416;
436 -> 406;
437 -> 414;
437 -> 416;
437 -> 406;
438 -> 416;
439 -> 0;
441 -> 439;
441 -> 440;
442 -> 362;
442 -> 440;
443 -> 441;
443 -> 442;
443 -> 426;
443 -> 440;
444 -> 441;
444 -> 440;
445 -> 440;
446 -> 444;
446 -> 445;
447 -> 446;
447 -> 445;
448 -> 446;
448 -> 447;
449 -> 442;
449 -> 440;
450 -> 440;
451 -> 440;
452 -> 449;
452 -> 451;
453 -> 450;
453 -> 451;
454 -> 452;
454 -> 426;
454 -> 451;
455 -> 452;
455 -> 426;
455 -> 451;
456 -> 452;
456 -> 426;
456 -> 451;
457 -> 452;
457 -> 426;
457 -> 451;
458 -> 451;
459 -> 452;
459 -> 458;
460 -> 459;
460 -> 426;
460 -> 458;
461 -> 451;
462 -> 453;
462 -> 461;
463 -> 461;
464 -> 463;
464 -> 456;
464 -> 455;
464 -> 461;
465 -> 463;
465 -> 461;
466 -> 463;
466 -> 461;
467 -> 463;
467 -> 461;
468 -> 461;
469 -> 0;
469 -> 461;
470 -> 441;
470 -> 450;
470 -> 440;
471 -> 448;
471 -> 450;
471 -> 440;
472 -> 450;
473 -> 0;
475 -> 473;
475 -> 474;
476 -> 362;
476 -> 474;
477 -> 475;
477 -> 476;
477 -> 460;
477 -> 474;
478 -> 475;
478 -> 474;
479 -> 474;
480 -> 478;
480 -> 479;
481 -> 480;
481 -> 479;
482 -> 480;
482 -> 481;
483 -> 476;
483 -> 474;
484 -> 474;
485 -> 474;
486 -> 483;
486 -> 485;
487 -> 484;
487 -> 485;
488 -> 486;
488 -> 460;
488 -> 485;
489 -> 486;
489 -> 460;
489 -> 485;
490 -> 486;
490 -> 460;
490 -> 485;
491 -> 486;
491 -> 460;
491 -> 485;
492 -> 485;
493 -> 486;
493 -> 492;
494 -> 493;
494 -> 460;
494 -> 492;
495 -> 485;
496 -> 487;
496 -> 495;
497 -> 495;
498 -> 497;
498 -> 490;
498 -> 489;
498 -> 495;
499 -> 497;
499 -> 495;
500 -> 497;
500 -> 495;
501 -> 497;
501 -> 495;
502 -> 495;
503 -> 0;
503 -> 495;
504 -> 475;
504 -> 484;
504 -> 474;
505 -> 482;
505 -> 484;
505 -> 474;
506 -> 484;
507 -> 0;
509 -> 507;
509 -> 508;
510 -> 362;
510 -> 508;
511 -> 509;
511 -> 510;
511 -> 494;
511 -> 508;
512 -> 509;
512 -> 508;
513 -> 508;
514 -> 512;
514 -> 513;
515 -> 514;
515 -> 513;
516 -> 514;
516 -> 515;
517 -> 510;
517 -> 508;
518 -> 508;
519 -> 508;
520 -> 517;
520 -> 519;
521 -> 518;
521 -> 519;
522 -> 520;
522 -> 494;
522 -> 519;
523 -> 520;
523 -> 494;
523 -> 519;
524 -> 520;
524 -> 494;
524 -> 519;
525 -> 520;
525 -> 494;
525 -> 519;
526 -> 519;
527 -> 520;
527 -> 526;
528 -> 527;
528 -> 494;
528 -> 526;
529 -> 519;
530 -> 521;
530 -> 529;
531 -> 529;
532 -> 531;
532 -> 524;
532 -> 523;
532 -> 529;
533 -> 531;
533 -> 529;
534 -> 531;
534 -> 529;
535 -> 531;
535 -> 529;
536 -> 529;
537 -> 0;
537 -> 529;
538 -> 509;
538 -> 518;
538 -> 508;
539 -> 516;
539 -> 518;
539 -> 508;
540 -> 518;
541 -> 0;
543 -> 541;
543 -> 542;
544 -> 362;
544 -> 542;
545 -> 543;
545 -> 544;
545 -> 528;
545 -> 542;
546 -> 543;
546 -> 542;
547 -> 542;
548 -> 546;
548 -> 547;
549 -> 548;
549 -> 547;
550 -> 548;
550 -> 549;
551 -> 544;
551 -> 542;
552 -> 542;
553 -> 542;
554 -> 551;
554 -> 553;
555 -> 552;
555 -> 553;
556 -> 554;
556 -> 528;
556 -> 553;
557 -> 554;
557 -> 528;
557 -> 553;
558 -> 554;
558 -> 528;
558 -> 553;
559 -> 554;
559 -> 528;
559 -> 553;
560 -> 553;
561 -> 554;
561 -> 560;
562 -> 561;
562 -> 528;
562 -> 560;
563 -> 553;
564 -> 555;
564 -> 563;
565 -> 563;
566 -> 565;
566 -> 558;
566 -> 557;
566 -> 563;
567 -> 565;
567 -> 563;
568 -> 565;
568 -> 563;
569 -> 565;
569 -> 563;
570 -> 563;
571 -> 0;
571 -> 563;
572 -> 543;
572 -> 552;
572 -> 542;
573 -> 550;
573 -> 552;
573 -> 542;
574 -> 552;
575 -> 0;
577 -> 575;
577 -> 576;
578 -> 362;
578 -> 576;
579 -> 577;
579 -> 578;
579 -> 562;
579 -> 576;
580 -> 578;
580 -> 579;
581 -> 580;
582 -> 0;
584 -> 582;
584 -> 583;
585 -> 362;
585 -> 583;
586 -> 584;
586 -> 585;
586 -> 562;
586 -> 583;
587 -> 584;
587 -> 583;
588 -> 583;
589 -> 587;
589 -> 588;
590 -> 589;
590 -> 588;
591 -> 589;
591 -> 590;
592 -> 585;
592 -> 583;
593 -> 583;
594 -> 583;
595 -> 592;
595 -> 594;
596 -> 593;
596 -> 594;
597 -> 595;
597 -> 562;
597 -> 594;
598 -> 595;
598 -> 562;
598 -> 594;
599 -> 595;
599 -> 562;
599 -> 594;
600 -> 595;
600 -> 562;
600 -> 594;
601 -> 594;
602 -> 595;
602 -> 601;
603 -> 602;
603 -> 562;
603 -> 601;
604 -> 594;
605 -> 596;
605 -> 604;
606 -> 604;
607 -> 606;
607 -> 599;
607 -> 598;
607 -> 604;
608 -> 606;
608 -> 604;
609 -> 606;
609 -> 604;
610 -> 606;
610 -> 604;
611 -> 604;
612 -> 0;
612 -> 604;
613 -> 584;
613 -> 593;
613 -> 583;
614 -> 591;
614 -> 593;
614 -> 583;
615 -> 593;
616 -> 0;
618 -> 616;
618 -> 617;
619 -> 362;
619 -> 617;
620 -> 618;
620 -> 619;
620 -> 603;
620 -> 617;
621 -> 618;
621 -> 617;
622 -> 617;
623 -> 621;
623 -> 622;
624 -> 623;
624 -> 622;
625 -> 623;
625 -> 624;
626 -> 619;
626 -> 617;
627 -> 617;
628 -> 617;
629 -> 626;
629 -> 628;
630 -> 627;
630 -> 628;
631 -> 629;
631 -> 603;
631 -> 628;
632 -> 629;
632 -> 603;
632 -> 628;
633 -> 629;
633 -> 603;
633 -> 628;
634 -> 629;
634 -> 603;
634 -> 628;
635 -> 628;
636 -> 629;
636 -> 635;
637 -> 636;
637 -> 603;
637 -> 635;
638 -> 628;
639 -> 630;
639 -> 638;
640 -> 638;
641 -> 640;
641 -> 633;
641 -> 632;
641 -> 638;
642 -> 640;
642 -> 638;
643 -> 640;
643 -> 638;
644 -> 640;
644 -> 638;
645 -> 638;
646 -> 0;
646 -> 638;
647 -> 618;
647 -> 627;
647 -> 617;
648 -> 625;
648 -> 627;
648 -> 617;
649 -> 627;
650 -> 0;
652 -> 650;
652 -> 651;
653 -> 362;
653 -> 651;
654 -> 652;
654 -> 653;
654 -> 637;
654 -> 651;
655 -> 652;
655 -> 651;
656 -> 651;
657 -> 655;
657 -> 656;
658 -> 657;
658 -> 656;
659 -> 657;
659 -> 658;
660 -> 653;
660 -> 651;
661 -> 651;
662 -> 651;
663 -> 660;
663 -> 662;
664 -> 661;
664 -> 662;
665 -> 663;
665 -> 637;
665 -> 662;
666 -> 663;
666 -> 637;
666 -> 662;
667 -> 663;
667 -> 637;
667 -> 662;
668 -> 663;
668 -> 637;
668 -> 662;
669 -> 662;
670 -> 663;
670 -> 669;
671 -> 670;
671 -> 637;
671 -> 669;
672 -> 662;
673 -> 664;
673 -> 672;
674 -> 672;
675 -> 674;
675 -> 667;
675 -> 666;
675 -> 672;
676 -> 674;
676 -> 672;
677 -> 674;
677 -> 672;
678 -> 674;
678 -> 672;
679 -> 672;
680 -> 0;
680 -> 672;
681 -> 652;
681 -> 661;
681 -> 651;
682 -> 659;
682 -> 661;
682 -> 651;
683 -> 661;
684 -> 0;
686 -> 684;
686 -> 685;
687 -> 362;
687 -> 685;
688 -> 686;
688 -> 687;
688 -> 671;
688 -> 685;
689 -> 687;
689 -> 685;
690 -> 685;
691 -> 685;
692 -> 689;
692 -> 691;
693 -> 690;
693 -> 691;
694 -> 692;
694 -> 671;
694 -> 691;
695 -> 692;
695 -> 671;
695 -> 691;
696 -> 692;
696 -> 671;
696 -> 691;
697 -> 692;
697 -> 671;
697 -> 691;
698 -> 691;
699 -> 692;
699 -> 698;
700 -> 699;
700 -> 671;
700 -> 698;
701 -> 691;
702 -> 693;
702 -> 701;
703 -> 701;
704 -> 703;
704 -> 696;
704 -> 695;
704 -> 701;
705 -> 703;
705 -> 701;
706 -> 703;
706 -> 701;
707 -> 703;
707 -> 701;
708 -> 701;
709 -> 0;
709 -> 701;
710 -> 686;
710 -> 690;
710 -> 685;
711 -> 690;
712 -> 362;
715 -> 712;
715 -> 714;
716 -> 713;
716 -> 714;
717 -> 714;
718 -> 714;
719 -> 715;
719 -> 718;
720 -> 719;
720 -> 700;
720 -> 718;
721 -> 720;
721 -> 714;
722 -> 714;
723 -> 716;
723 -> 714;
724 -> 717;
724 -> 714;
725 -> 723;
725 -> 724;
725 -> 714;
726 -> 725;
726 -> 722;
726 -> 714;
727 -> 721;
727 -> 722;
727 -> 700;
727 -> 726;
727 -> 725;
727 -> 714;
728 -> 714;
729 -> 727;
729 -> 728;
730 -> 715;
730 -> 728;
731 -> 729;
731 -> 728;
732 -> 0;
732 -> 728;
733 -> 730;
733 -> 728;
734 -> 728;
735 -> 728;
736 -> 733;
736 -> 735;
737 -> 734;
737 -> 735;
738 -> 736;
738 -> 731;
738 -> 735;
739 -> 736;
739 -> 731;
739 -> 735;
740 -> 736;
740 -> 731;
740 -> 735;
741 -> 736;
741 -> 731;
741 -> 735;
742 -> 735;
743 -> 736;
743 -> 742;
744 -> 743;
744 -> 731;
744 -> 742;
745 -> 735;
746 -> 737;
746 -> 745;
747 -> 745;
748 -> 747;
748 -> 740;
748 -> 739;
748 -> 745;
749 -> 747;
749 -> 745;
750 -> 747;
750 -> 745;
751 -> 747;
751 -> 745;
752 -> 745;
753 -> 0;
753 -> 745;
754 -> 731;
754 -> 734;
754 -> 728;
755 -> 734;
755 -> 714;
756 -> 755;
757 -> 0;
759 -> 757;
759 -> 758;
760 -> 759;
760 -> 758;
761 -> 758;
762 -> 760;
762 -> 761;
763 -> 762;
763 -> 761;
764 -> 763;
765 -> 758;
766 -> 759;
766 -> 758;
767 -> 0;
767 -> 766;
769 -> 767;
769 -> 768;
771 -> 769;
771 -> 770;
772 -> 362;
772 -> 770;
773 -> 771;
773 -> 772;
773 -> 744;
773 -> 770;
774 -> 771;
774 -> 770;
775 -> 770;
776 -> 774;
776 -> 775;
777 -> 776;
777 -> 775;
778 -> 776;
778 -> 777;
779 -> 772;
779 -> 770;
780 -> 770;
781 -> 770;
782 -> 779;
782 -> 781;
783 -> 780;
783 -> 781;
784 -> 782;
784 -> 744;
784 -> 781;
785 -> 782;
785 -> 744;
785 -> 781;
786 -> 782;
786 -> 744;
786 -> 781;
787 -> 782;
787 -> 744;
787 -> 781;
788 -> 781;
789 -> 782;
789 -> 788;
790 -> 789;
790 -> 744;
790 -> 788;
791 -> 781;
792 -> 783;
792 -> 791;
793 -> 791;
794 -> 793;
794 -> 786;
794 -> 785;
794 -> 791;
795 -> 793;
795 -> 791;
796 -> 793;
796 -> 791;
797 -> 793;
797 -> 791;
798 -> 791;
799 -> 0;
799 -> 791;
800 -> 771;
800 -> 780;
800 -> 770;
801 -> 778;
801 -> 780;
801 -> 770;
802 -> 780;
803 -> 0;
805 -> 803;
805 -> 804;
806 -> 805;
806 -> 804;
807 -> 804;
808 -> 806;
808 -> 807;
809 -> 808;
809 -> 807;
810 -> 809;
811 -> 804;
812 -> 805;
812 -> 804;
813 -> 0;
813 -> 812;
815 -> 813;
815 -> 814;
816 -> 362;
816 -> 814;
817 -> 815;
817 -> 816;
817 -> 790;
817 -> 814;
818 -> 815;
818 -> 814;
819 -> 814;
820 -> 818;
820 -> 819;
821 -> 820;
821 -> 819;
822 -> 820;
822 -> 821;
823 -> 816;
823 -> 814;
824 -> 814;
825 -> 814;
826 -> 823;
826 -> 825;
827 -> 824;
827 -> 825;
828 -> 826;
828 -> 790;
828 -> 825;
829 -> 826;
829 -> 790;
829 -> 825;
830 -> 826;
830 -> 790;
830 -> 825;
831 -> 826;
831 -> 790;
831 -> 825;
832 -> 825;
833 -> 826;
833 -> 832;
834 -> 833;
834 -> 790;
834 -> 832;
835 -> 825;
836 -> 827;
836 -> 835;
837 -> 835;
838 -> 837;
838 -> 830;
838 -> 829;
838 -> 835;
839 -> 837;
839 -> 835;
840 -> 837;
840 -> 835;
841 -> 837;
841 -> 835;
842 -> 835;
843 -> 0;
843 -> 835;
844 -> 815;
844 -> 824;
844 -> 814;
845 -> 822;
845 -> 824;
845 -> 814;
846 -> 824;
847 -> 0;
849 -> 847;
849 -> 848;
850 -> 362;
850 -> 848;
851 -> 849;
851 -> 850;
851 -> 834;
851 -> 848;
852 -> 849;
852 -> 848;
853 -> 848;
854 -> 852;
854 -> 853;
855 -> 854;
855 -> 853;
856 -> 854;
856 -> 855;
857 -> 850;
857 -> 848;
858 -> 848;
859 -> 848;
860 -> 857;
860 -> 859;
861 -> 858;
861 -> 859;
862 -> 860;
862 -> 834;
862 -> 859;
863 -> 860;
863 -> 834;
863 -> 859;
864 -> 860;
864 -> 834;
864 -> 859;
865 -> 860;
865 -> 834;
865 -> 859;
866 -> 859;
867 -> 860;
867 -> 866;
868 -> 867;
868 -> 834;
868 -> 866;
869 -> 859;
870 -> 861;
870 -> 869;
871 -> 869;
872 -> 871;
872 -> 864;
872 -> 863;
872 -> 869;
873 -> 871;
873 -> 869;
874 -> 871;
874 -> 869;
875 -> 871;
875 -> 869;
876 -> 869;
877 -> 0;
877 -> 869;
878 -> 849;
878 -> 858;
878 -> 848;
879 -> 856;
879 -> 858;
879 -> 848;
880 -> 858;
881 -> 615;
883 -> 882;
884 -> 0;
885 -> 0;
886 -> 0;
888 -> 884;
888 -> 887;
889 -> 885;
889 -> 887;
890 -> 886;
890 -> 887;
891 -> 887;
892 -> 887;
893 -> 888;
893 -> 887;
894 -> 889;
894 -> 887;
895 -> 890;
895 -> 887;
896 -> 891;
896 -> 887;
897 -> 896;
897 -> 887;
898 -> 0;
898 -> 887;
899 -> 893;
899 -> 892;
900 -> 894;
900 -> 892;
901 -> 895;
901 -> 892;
902 -> 897;
902 -> 892;
903 -> 898;
903 -> 892;
904 -> 892;
905 -> 901;
905 -> 892;
906 -> 900;
906 -> 892;
907 -> 904;
907 -> 905;
907 -> 906;
907 -> 892;
908 -> 904;
908 -> 892;
909 -> 904;
909 -> 892;
910 -> 904;
910 -> 892;
911 -> 899;
911 -> 904;
911 -> 892;
912 -> 899;
912 -> 892;
913 -> 892;
914 -> 912;
914 -> 913;
915 -> 914;
915 -> 913;
916 -> 914;
916 -> 915;
917 -> 916;
917 -> 904;
917 -> 892;
918 -> 902;
918 -> 892;
919 -> 918;
919 -> 904;
919 -> 892;
920 -> 903;
920 -> 892;
921 -> 920;
921 -> 868;
921 -> 892;
922 -> 0;
922 -> 892;
923 -> 883;
925 -> 923;
925 -> 924;
926 -> 887;
926 -> 924;
927 -> 925;
927 -> 924;
928 -> 0;
928 -> 924;
929 -> 927;
929 -> 928;
929 -> 882;
929 -> 921;
929 -> 924;
930 -> 926;
930 -> 924;
931 -> 924;
932 -> 924;
933 -> 930;
933 -> 932;
934 -> 931;
934 -> 932;
935 -> 933;
935 -> 907;
935 -> 910;
935 -> 911;
935 -> 932;
936 -> 933;
936 -> 907;
936 -> 932;
937 -> 933;
937 -> 907;
937 -> 932;
938 -> 933;
938 -> 907;
938 -> 919;
938 -> 932;
939 -> 932;
940 -> 933;
940 -> 939;
941 -> 940;
941 -> 907;
941 -> 908;
941 -> 921;
941 -> 939;
942 -> 932;
943 -> 935;
943 -> 942;
944 -> 936;
944 -> 942;
945 -> 937;
945 -> 942;
946 -> 938;
946 -> 942;
947 -> 934;
947 -> 942;
948 -> 942;
949 -> 948;
949 -> 945;
949 -> 944;
949 -> 942;
950 -> 948;
950 -> 942;
951 -> 948;
951 -> 942;
952 -> 948;
952 -> 942;
953 -> 943;
953 -> 942;
954 -> 942;
955 -> 953;
955 -> 954;
956 -> 955;
956 -> 954;
957 -> 955;
957 -> 956;
958 -> 957;
958 -> 948;
958 -> 942;
959 -> 946;
959 -> 907;
959 -> 908;
959 -> 921;
959 -> 909;
959 -> 917;
959 -> 910;
959 -> 911;
959 -> 919;
959 -> 918;
959 -> 929;
959 -> 942;
960 -> 0;
960 -> 942;
961 -> 929;
961 -> 931;
961 -> 924;
962 -> 931;
966 -> 964;
966 -> 965;
966 -> 963;
967 -> 966;
967 -> 963;
968 -> 966;
968 -> 963;
969 -> 967;
969 -> 963;
970 -> 0;
970 -> 963;
971 -> 969;
971 -> 970;
971 -> 966;
971 -> 959;
971 -> 963;
972 -> 968;
972 -> 963;
973 -> 963;
974 -> 963;
975 -> 972;
975 -> 974;
976 -> 973;
976 -> 974;
977 -> 975;
977 -> 971;
977 -> 974;
978 -> 975;
978 -> 971;
978 -> 974;
979 -> 975;
979 -> 971;
979 -> 974;
980 -> 974;
981 -> 975;
981 -> 980;
982 -> 974;
983 -> 976;
983 -> 982;
984 -> 982;
985 -> 984;
985 -> 979;
985 -> 978;
985 -> 982;
986 -> 984;
986 -> 982;
987 -> 984;
987 -> 982;
988 -> 984;
988 -> 982;
989 -> 982;
990 -> 0;
990 -> 982;
991 -> 971;
991 -> 973;
991 -> 963;
992 -> 966;
992 -> 973;
992 -> 971;
992 -> 985;
992 -> 986;
992 -> 991;
992 -> 987;
992 -> 977;
992 -> 988;
993 -> 438;
993 -> 430;
993 -> 431;
993 -> 426;
993 -> 432;
993 -> 420;
993 -> 437;
993 -> 433;
993 -> 436;
993 -> 423;
993 -> 992;
993 -> 963;
994 -> 993;
995 -> 574;
996 -> 649;
997 -> 649;
998 -> 615;
999 -> 0;
1000 -> 0;
1002 -> 999;
1002 -> 1001;
1003 -> 1000;
1003 -> 1001;
1004 -> 1001;
1005 -> 1002;
1005 -> 1001;
1006 -> 1003;
1006 -> 1001;
1007 -> 0;
1007 -> 1001;
1008 -> 1004;
1008 -> 1001;
1009 -> 1001;
1010 -> 1005;
1010 -> 1009;
1011 -> 1006;
1011 -> 1009;
1012 -> 1007;
1012 -> 1009;
1013 -> 1008;
1013 -> 1009;
1014 -> 1009;
1015 -> 1009;
1016 -> 1009;
1017 -> 1009;
1018 -> 1009;
1019 -> 1009;
1020 -> 1009;
1021 -> 1009;
1022 -> 1009;
1023 -> 1009;
1024 -> 1009;
1025 -> 1009;
1026 -> 1009;
1027 -> 1009;
1028 -> 1009;
1029 -> 1009;
1030 -> 1009;
1031 -> 1009;
1032 -> 1009;
1033 -> 1009;
1034 -> 1009;
1035 -> 1009;
1036 -> 1009;
1037 -> 1009;
1038 -> 1010;
1038 -> 1009;
1039 -> 1011;
1039 -> 1009;
1040 -> 1012;
1040 -> 1009;
1041 -> 1013;
1041 -> 1009;
1042 -> 1014;
1042 -> 1009;
1043 -> 1015;
1043 -> 1009;
1044 -> 1016;
1044 -> 1009;
1045 -> 1017;
1045 -> 1009;
1046 -> 1018;
1046 -> 1009;
1047 -> 1019;
1047 -> 1009;
1048 -> 1020;
1048 -> 1009;
1049 -> 1021;
1049 -> 1009;
1050 -> 1022;
1050 -> 1009;
1051 -> 1023;
1051 -> 1009;
1052 -> 1024;
1052 -> 1009;
1053 -> 1025;
1053 -> 1009;
1054 -> 1026;
1054 -> 1009;
1055 -> 1027;
1055 -> 1009;
1056 -> 1028;
1056 -> 1009;
1057 -> 1009;
1058 -> 1009;
1059 -> 1029;
1059 -> 1009;
1060 -> 1030;
1060 -> 1009;
1061 -> 1009;
1062 -> 1031;
1062 -> 1009;
1063 -> 1032;
1063 -> 1009;
1064 -> 1033;
1064 -> 1009;
1065 -> 1035;
1065 -> 1009;
1066 -> 1009;
1067 -> 1034;
1067 -> 1009;
1068 -> 0;
1068 -> 1009;
1069 -> 1036;
1069 -> 1009;
1070 -> 1038;
1070 -> 1037;
1071 -> 1039;
1071 -> 1037;
1072 -> 1040;
1072 -> 1037;
1073 -> 1041;
1073 -> 1037;
1074 -> 1042;
1074 -> 1037;
1075 -> 1043;
1075 -> 1037;
1076 -> 1044;
1076 -> 1037;
1077 -> 1045;
1077 -> 1037;
1078 -> 1046;
1078 -> 1037;
1079 -> 1047;
1079 -> 1037;
1080 -> 1048;
1080 -> 1037;
1081 -> 1049;
1081 -> 1037;
1082 -> 1050;
1082 -> 1037;
1083 -> 1051;
1083 -> 1037;
1084 -> 1052;
1084 -> 1037;
1085 -> 1053;
1085 -> 1037;
1086 -> 1054;
1086 -> 1037;
1087 -> 1055;
1087 -> 1037;
1088 -> 1056;
1088 -> 1037;
1089 -> 1057;
1089 -> 1037;
1090 -> 1058;
1090 -> 1037;
1091 -> 1059;
1091 -> 1037;
1092 -> 1060;
1092 -> 1037;
1093 -> 1061;
1093 -> 1037;
1094 -> 1062;
1094 -> 1037;
1095 -> 1063;
1095 -> 1037;
1096 -> 1064;
1096 -> 1037;
1097 -> 1065;
1097 -> 1037;
1098 -> 1066;
1098 -> 1037;
1099 -> 1067;
1099 -> 1037;
1100 -> 1068;
1100 -> 1037;
1101 -> 1069;
1101 -> 1037;
1102 -> 1037;
1103 -> 1070;
1103 -> 1037;
1104 -> 1071;
1104 -> 1037;
1105 -> 1072;
1105 -> 1037;
1106 -> 1073;
1106 -> 1037;
1107 -> 1074;
1107 -> 1037;
1108 -> 1079;
1108 -> 1037;
1109 -> 1080;
1109 -> 1037;
1110 -> 1081;
1110 -> 1037;
1111 -> 1082;
1111 -> 1037;
1112 -> 1099;
1112 -> 1037;
1113 -> 1076;
1113 -> 1037;
1114 -> 1077;
1114 -> 1037;
1115 -> 1083;
1115 -> 1037;
1116 -> 1084;
1116 -> 1037;
1117 -> 1085;
1117 -> 1037;
1118 -> 1086;
1118 -> 1037;
1119 -> 1118;
1119 -> 1037;
1120 -> 1087;
1120 -> 1037;
1121 -> 1088;
1121 -> 1037;
1122 -> 1089;
1122 -> 1037;
1123 -> 1090;
1123 -> 1037;
1124 -> 1091;
1124 -> 1037;
1125 -> 1092;
1125 -> 1037;
1126 -> 1093;
1126 -> 1037;
1127 -> 1094;
1127 -> 1037;
1128 -> 1095;
1128 -> 1037;
1129 -> 1096;
1129 -> 1037;
1130 -> 1097;
1130 -> 1037;
1131 -> 1098;
1131 -> 1037;
1132 -> 1102;
1132 -> 1103;
1132 -> 1104;
1132 -> 1105;
1132 -> 1106;
1132 -> 1107;
1132 -> 1108;
1132 -> 1109;
1132 -> 1110;
1132 -> 1111;
1132 -> 1112;
1132 -> 1113;
1132 -> 1114;
1132 -> 1115;
1132 -> 1116;
1132 -> 1117;
1132 -> 1119;
1132 -> 1120;
1132 -> 1121;
1132 -> 1122;
1132 -> 1123;
1132 -> 1124;
1132 -> 1125;
1132 -> 1126;
1132 -> 1127;
1132 -> 1128;
1132 -> 1129;
1132 -> 1130;
1132 -> 1131;
1132 -> 1057;
1132 -> 1037;
1133 -> 1102;
1133 -> 1037;
1134 -> 1102;
1134 -> 1037;
1135 -> 1102;
1135 -> 1037;
1136 -> 1075;
1136 -> 1037;
1137 -> 1136;
1137 -> 1102;
1137 -> 1037;
1138 -> 1078;
1138 -> 1102;
1138 -> 1037;
1139 -> 1100;
1139 -> 1102;
1139 -> 1037;
1140 -> 1101;
1140 -> 1102;
1140 -> 1037;
1141 -> 1009;
1142 -> 0;
1143 -> 0;
1145 -> 1142;
1145 -> 1144;
1146 -> 1143;
1146 -> 1144;
1147 -> 1144;
1148 -> 1145;
1148 -> 1144;
1149 -> 1146;
1149 -> 1144;
1150 -> 0;
1150 -> 1144;
1151 -> 1147;
1151 -> 1144;
1152 -> 1144;
1153 -> 1148;
1153 -> 1152;
1154 -> 1149;
1154 -> 1152;
1155 -> 1150;
1155 -> 1152;
1156 -> 1151;
1156 -> 1152;
1157 -> 1152;
1158 -> 1152;
1159 -> 1152;
1160 -> 1152;
1161 -> 1152;
1162 -> 1152;
1163 -> 1152;
1164 -> 1152;
1165 -> 1152;
1166 -> 1152;
1167 -> 1152;
1168 -> 1152;
1169 -> 1152;
1170 -> 1152;
1171 -> 1152;
1172 -> 1152;
1173 -> 1152;
1174 -> 1152;
1175 -> 1152;
1176 -> 1152;
1177 -> 1152;
1178 -> 1152;
1179 -> 1152;
1180 -> 1152;
1181 -> 1153;
1181 -> 1152;
1182 -> 1154;
1182 -> 1152;
1183 -> 1155;
1183 -> 1152;
1184 -> 1156;
1184 -> 1152;
1185 -> 1157;
1185 -> 1152;
1186 -> 1158;
1186 -> 1152;
1187 -> 1159;
1187 -> 1152;
1188 -> 1160;
1188 -> 1152;
1189 -> 1161;
1189 -> 1152;
1190 -> 1162;
1190 -> 1152;
1191 -> 1163;
1191 -> 1152;
1192 -> 1164;
1192 -> 1152;
1193 -> 1165;
1193 -> 1152;
1194 -> 1166;
1194 -> 1152;
1195 -> 1167;
1195 -> 1152;
1196 -> 1168;
1196 -> 1152;
1197 -> 1169;
1197 -> 1152;
1198 -> 1170;
1198 -> 1152;
1199 -> 1171;
1199 -> 1152;
1200 -> 1152;
1201 -> 1152;
1202 -> 1172;
1202 -> 1152;
1203 -> 1173;
1203 -> 1152;
1204 -> 1152;
1205 -> 1174;
1205 -> 1152;
1206 -> 1175;
1206 -> 1152;
1207 -> 1176;
1207 -> 1152;
1208 -> 1178;
1208 -> 1152;
1209 -> 1152;
1210 -> 1177;
1210 -> 1152;
1211 -> 0;
1211 -> 1152;
1212 -> 1179;
1212 -> 1152;
1213 -> 1181;
1213 -> 1180;
1214 -> 1182;
1214 -> 1180;
1215 -> 1183;
1215 -> 1180;
1216 -> 1184;
1216 -> 1180;
1217 -> 1185;
1217 -> 1180;
1218 -> 1186;
1218 -> 1180;
1219 -> 1187;
1219 -> 1180;
1220 -> 1188;
1220 -> 1180;
1221 -> 1189;
1221 -> 1180;
1222 -> 1190;
1222 -> 1180;
1223 -> 1191;
1223 -> 1180;
1224 -> 1192;
1224 -> 1180;
1225 -> 1193;
1225 -> 1180;
1226 -> 1194;
1226 -> 1180;
1227 -> 1195;
1227 -> 1180;
1228 -> 1196;
1228 -> 1180;
1229 -> 1197;
1229 -> 1180;
1230 -> 1198;
1230 -> 1180;
1231 -> 1199;
1231 -> 1180;
1232 -> 1200;
1232 -> 1180;
1233 -> 1201;
1233 -> 1180;
1234 -> 1202;
1234 -> 1180;
1235 -> 1203;
1235 -> 1180;
1236 -> 1204;
1236 -> 1180;
1237 -> 1205;
1237 -> 1180;
1238 -> 1206;
1238 -> 1180;
1239 -> 1207;
1239 -> 1180;
1240 -> 1208;
1240 -> 1180;
1241 -> 1209;
1241 -> 1180;
1242 -> 1210;
1242 -> 1180;
1243 -> 1211;
1243 -> 1180;
1244 -> 1212;
1244 -> 1180;
1245 -> 1180;
1246 -> 1213;
1246 -> 1180;
1247 -> 1214;
1247 -> 1180;
1248 -> 1215;
1248 -> 1180;
1249 -> 1216;
1249 -> 1180;
1250 -> 1217;
1250 -> 1180;
1251 -> 1222;
1251 -> 1180;
1252 -> 1223;
1252 -> 1180;
1253 -> 1224;
1253 -> 1180;
1254 -> 1225;
1254 -> 1180;
1255 -> 1242;
1255 -> 1180;
1256 -> 1219;
1256 -> 1180;
1257 -> 1220;
1257 -> 1180;
1258 -> 1226;
1258 -> 1180;
1259 -> 1227;
1259 -> 1180;
1260 -> 1228;
1260 -> 1180;
1261 -> 1229;
1261 -> 1180;
1262 -> 1261;
1262 -> 1180;
1263 -> 1230;
1263 -> 1180;
1264 -> 1231;
1264 -> 1180;
1265 -> 1232;
1265 -> 1180;
1266 -> 1233;
1266 -> 1180;
1267 -> 1234;
1267 -> 1180;
1268 -> 1235;
1268 -> 1180;
1269 -> 1236;
1269 -> 1180;
1270 -> 1237;
1270 -> 1180;
1271 -> 1238;
1271 -> 1180;
1272 -> 1239;
1272 -> 1180;
1273 -> 1240;
1273 -> 1180;
1274 -> 1241;
1274 -> 1180;
1275 -> 1245;
1275 -> 1246;
1275 -> 1247;
1275 -> 1248;
1275 -> 1249;
1275 -> 1250;
1275 -> 1251;
1275 -> 1252;
1275 -> 1253;
1275 -> 1254;
1275 -> 1255;
1275 -> 1256;
1275 -> 1257;
1275 -> 1258;
1275 -> 1259;
1275 -> 1260;
1275 -> 1262;
1275 -> 1263;
1275 -> 1264;
1275 -> 1265;
1275 -> 1266;
1275 -> 1267;
1275 -> 1268;
1275 -> 1269;
1275 -> 1270;
1275 -> 1271;
1275 -> 1272;
1275 -> 1273;
1275 -> 1274;
1275 -> 1200;
1275 -> 1180;
1276 -> 1245;
1276 -> 1180;
1277 -> 1245;
1277 -> 1180;
1278 -> 1245;
1278 -> 1180;
1279 -> 1218;
1279 -> 1180;
1280 -> 1279;
1280 -> 1245;
1280 -> 1180;
1281 -> 1221;
1281 -> 1245;
1281 -> 1180;
1282 -> 1243;
1282 -> 1245;
1282 -> 1180;
1283 -> 1244;
1283 -> 1245;
1283 -> 1180;
1284 -> 1152;
1287 -> 1285;
1287 -> 1286;
1288 -> 1141;
1288 -> 1286;
1289 -> 1287;
1289 -> 1288;
1289 -> 1132;
1289 -> 1286;
1290 -> 1288;
1290 -> 1286;
1291 -> 1286;
1292 -> 1286;
1293 -> 1290;
1293 -> 1292;
1294 -> 1291;
1294 -> 1292;
1295 -> 1293;
1295 -> 1132;
1295 -> 1292;
1296 -> 1293;
1296 -> 1132;
1296 -> 1292;
1297 -> 1293;
1297 -> 1132;
1297 -> 1292;
1298 -> 1293;
1298 -> 1132;
1298 -> 1292;
1299 -> 1293;
1299 -> 1132;
1299 -> 1137;
1299 -> 1292;
1300 -> 1293;
1300 -> 1132;
1300 -> 1292;
1301 -> 1293;
1301 -> 1132;
1301 -> 1292;
1302 -> 1293;
1302 -> 1132;
1302 -> 1133;
1302 -> 1138;
1302 -> 1292;
1303 -> 1293;
1303 -> 1132;
1303 -> 1292;
1304 -> 1293;
1304 -> 1132;
1304 -> 1292;
1305 -> 1293;
1305 -> 1132;
1305 -> 1292;
1306 -> 1293;
1306 -> 1132;
1306 -> 1292;
1307 -> 1293;
1307 -> 1132;
1307 -> 1292;
1308 -> 1293;
1308 -> 1132;
1308 -> 1292;
1309 -> 1293;
1309 -> 1132;
1309 -> 1292;
1310 -> 1293;
1310 -> 1132;
1310 -> 1292;
1311 -> 1293;
1311 -> 1132;
1311 -> 1292;
1312 -> 1293;
1312 -> 1132;
1312 -> 1292;
1313 -> 1293;
1313 -> 1132;
1313 -> 1292;
1314 -> 1293;
1314 -> 1132;
1314 -> 1292;
1315 -> 1293;
1315 -> 1132;
1315 -> 1292;
1316 -> 1293;
1316 -> 1132;
1316 -> 1292;
1317 -> 1293;
1317 -> 1132;
1317 -> 1292;
1318 -> 1293;
1318 -> 1132;
1318 -> 1292;
1319 -> 1293;
1319 -> 1132;
1319 -> 1292;
1320 -> 1293;
1320 -> 1132;
1320 -> 1292;
1321 -> 1293;
1321 -> 1132;
1321 -> 1292;
1322 -> 1293;
1322 -> 1132;
1322 -> 1292;
1323 -> 1293;
1323 -> 1132;
1323 -> 1292;
1324 -> 1293;
1324 -> 1132;
1324 -> 1292;
1325 -> 1293;
1325 -> 1132;
1325 -> 1134;
1325 -> 1139;
1325 -> 1292;
1326 -> 1293;
1326 -> 1132;
1326 -> 1135;
1326 -> 1140;
1326 -> 1292;
1327 -> 1292;
1328 -> 1295;
1328 -> 1327;
1329 -> 1296;
1329 -> 1327;
1330 -> 1297;
1330 -> 1327;
1331 -> 1298;
1331 -> 1327;
1332 -> 1299;
1332 -> 1327;
1333 -> 1300;
1333 -> 1327;
1334 -> 1301;
1334 -> 1327;
1335 -> 1302;
1335 -> 1327;
1336 -> 1303;
1336 -> 1327;
1337 -> 1304;
1337 -> 1327;
1338 -> 1305;
1338 -> 1327;
1339 -> 1306;
1339 -> 1327;
1340 -> 1307;
1340 -> 1327;
1341 -> 1308;
1341 -> 1327;
1342 -> 1309;
1342 -> 1327;
1343 -> 1310;
1343 -> 1327;
1344 -> 1311;
1344 -> 1327;
1345 -> 1312;
1345 -> 1327;
1346 -> 1313;
1346 -> 1327;
1347 -> 1314;
1347 -> 1327;
1348 -> 1315;
1348 -> 1327;
1349 -> 1316;
1349 -> 1327;
1350 -> 1317;
1350 -> 1327;
1351 -> 1318;
1351 -> 1327;
1352 -> 1319;
1352 -> 1327;
1353 -> 1320;
1353 -> 1327;
1354 -> 1321;
1354 -> 1327;
1355 -> 1322;
1355 -> 1327;
1356 -> 1323;
1356 -> 1327;
1357 -> 1324;
1357 -> 1327;
1358 -> 1325;
1358 -> 1327;
1359 -> 1326;
1359 -> 1327;
1360 -> 1294;
1360 -> 1327;
1361 -> 1327;
1362 -> 1361;
1362 -> 1328;
1362 -> 1329;
1362 -> 1330;
1362 -> 1331;
1362 -> 1332;
1362 -> 1337;
1362 -> 1338;
1362 -> 1339;
1362 -> 1340;
1362 -> 1357;
1362 -> 1334;
1362 -> 1335;
1362 -> 1341;
1362 -> 1342;
1362 -> 1343;
1362 -> 1344;
1362 -> 1345;
1362 -> 1346;
1362 -> 1347;
1362 -> 1348;
1362 -> 1349;
1362 -> 1350;
1362 -> 1351;
1362 -> 1352;
1362 -> 1353;
1362 -> 1354;
1362 -> 1355;
1362 -> 1356;
1362 -> 1132;
1362 -> 1133;
1362 -> 1138;
1362 -> 1134;
1362 -> 1139;
1362 -> 1135;
1362 -> 1140;
1362 -> 1137;
1362 -> 1136;
1362 -> 1327;
1363 -> 1361;
1363 -> 1327;
1364 -> 1361;
1364 -> 1327;
1365 -> 1361;
1365 -> 1327;
1366 -> 1333;
1366 -> 1327;
1367 -> 1366;
1367 -> 1361;
1367 -> 1327;
1368 -> 1336;
1368 -> 1361;
1368 -> 1327;
1369 -> 1287;
1369 -> 1291;
1369 -> 1286;
1370 -> 1291;
1373 -> 1371;
1373 -> 1372;
1374 -> 1284;
1374 -> 1372;
1375 -> 1373;
1375 -> 1374;
1375 -> 1275;
1375 -> 1372;
1376 -> 1374;
1376 -> 1372;
1377 -> 1372;
1378 -> 1372;
1379 -> 1376;
1379 -> 1378;
1380 -> 1377;
1380 -> 1378;
1381 -> 1379;
1381 -> 1275;
1381 -> 1378;
1382 -> 1379;
1382 -> 1275;
1382 -> 1378;
1383 -> 1379;
1383 -> 1275;
1383 -> 1378;
1384 -> 1379;
1384 -> 1275;
1384 -> 1378;
1385 -> 1379;
1385 -> 1275;
1385 -> 1280;
1385 -> 1378;
1386 -> 1379;
1386 -> 1275;
1386 -> 1378;
1387 -> 1379;
1387 -> 1275;
1387 -> 1378;
1388 -> 1379;
1388 -> 1275;
1388 -> 1276;
1388 -> 1281;
1388 -> 1378;
1389 -> 1379;
1389 -> 1275;
1389 -> 1378;
1390 -> 1379;
1390 -> 1275;
1390 -> 1378;
1391 -> 1379;
1391 -> 1275;
1391 -> 1378;
1392 -> 1379;
1392 -> 1275;
1392 -> 1378;
1393 -> 1379;
1393 -> 1275;
1393 -> 1378;
1394 -> 1379;
1394 -> 1275;
1394 -> 1378;
1395 -> 1379;
1395 -> 1275;
1395 -> 1378;
1396 -> 1379;
1396 -> 1275;
1396 -> 1378;
1397 -> 1379;
1397 -> 1275;
1397 -> 1378;
1398 -> 1379;
1398 -> 1275;
1398 -> 1378;
1399 -> 1379;
1399 -> 1275;
1399 -> 1378;
1400 -> 1379;
1400 -> 1275;
1400 -> 1378;
1401 -> 1379;
1401 -> 1275;
1401 -> 1378;
1402 -> 1379;
1402 -> 1275;
1402 -> 1378;
1403 -> 1379;
1403 -> 1275;
1403 -> 1378;
1404 -> 1379;
1404 -> 1275;
1404 -> 1378;
1405 -> 1379;
1405 -> 1275;
1405 -> 1378;
1406 -> 1379;
1406 -> 1275;
1406 -> 1378;
1407 -> 1379;
1407 -> 1275;
1407 -> 1378;
1408 -> 1379;
1408 -> 1275;
1408 -> 1378;
1409 -> 1379;
1409 -> 1275;
1409 -> 1378;
1410 -> 1379;
1410 -> 1275;
1410 -> 1378;
1411 -> 1379;
1411 -> 1275;
1411 -> 1277;
1411 -> 1282;
1411 -> 1378;
1412 -> 1379;
1412 -> 1275;
1412 -> 1278;
1412 -> 1283;
1412 -> 1378;
1413 -> 1378;
1414 -> 1381;
1414 -> 1413;
1415 -> 1382;
1415 -> 1413;
1416 -> 1383;
1416 -> 1413;
1417 -> 1384;
1417 -> 1413;
1418 -> 1385;
1418 -> 1413;
1419 -> 1386;
1419 -> 1413;
1420 -> 1387;
1420 -> 1413;
1421 -> 1388;
1421 -> 1413;
1422 -> 1389;
1422 -> 1413;
1423 -> 1390;
1423 -> 1413;
1424 -> 1391;
1424 -> 1413;
1425 -> 1392;
1425 -> 1413;
1426 -> 1393;
1426 -> 1413;
1427 -> 1394;
1427 -> 1413;
1428 -> 1395;
1428 -> 1413;
1429 -> 1396;
1429 -> 1413;
1430 -> 1397;
1430 -> 1413;
1431 -> 1398;
1431 -> 1413;
1432 -> 1399;
1432 -> 1413;
1433 -> 1400;
1433 -> 1413;
1434 -> 1401;
1434 -> 1413;
1435 -> 1402;
1435 -> 1413;
1436 -> 1403;
1436 -> 1413;
1437 -> 1404;
1437 -> 1413;
1438 -> 1405;
1438 -> 1413;
1439 -> 1406;
1439 -> 1413;
1440 -> 1407;
1440 -> 1413;
1441 -> 1408;
1441 -> 1413;
1442 -> 1409;
1442 -> 1413;
1443 -> 1410;
1443 -> 1413;
1444 -> 1411;
1444 -> 1413;
1445 -> 1412;
1445 -> 1413;
1446 -> 1380;
1446 -> 1413;
1447 -> 1413;
1448 -> 1447;
1448 -> 1414;
1448 -> 1415;
1448 -> 1416;
1448 -> 1417;
1448 -> 1418;
1448 -> 1423;
1448 -> 1424;
1448 -> 1425;
1448 -> 1426;
1448 -> 1443;
1448 -> 1420;
1448 -> 1421;
1448 -> 1427;
1448 -> 1428;
1448 -> 1429;
1448 -> 1430;
1448 -> 1431;
1448 -> 1432;
1448 -> 1433;
1448 -> 1434;
1448 -> 1435;
1448 -> 1436;
1448 -> 1437;
1448 -> 1438;
1448 -> 1439;
1448 -> 1440;
1448 -> 1441;
1448 -> 1442;
1448 -> 1275;
1448 -> 1276;
1448 -> 1281;
1448 -> 1277;
1448 -> 1282;
1448 -> 1278;
1448 -> 1283;
1448 -> 1280;
1448 -> 1279;
1448 -> 1413;
1449 -> 1447;
1449 -> 1413;
1450 -> 1447;
1450 -> 1413;
1451 -> 1447;
1451 -> 1413;
1452 -> 1419;
1452 -> 1413;
1453 -> 1452;
1453 -> 1447;
1453 -> 1413;
1454 -> 1422;
1454 -> 1447;
1454 -> 1413;
1455 -> 1373;
1455 -> 1377;
1455 -> 1372;
1456 -> 1377;
1457 -> 0;
1458 -> 0;
1460 -> 1457;
1460 -> 1459;
1461 -> 1458;
1461 -> 1459;
1462 -> 1459;
1463 -> 1460;
1463 -> 1459;
1464 -> 1461;
1464 -> 1459;
1465 -> 0;
1465 -> 1459;
1466 -> 1462;
1466 -> 1459;
1467 -> 1459;
1468 -> 1463;
1468 -> 1467;
1469 -> 1464;
1469 -> 1467;
1470 -> 1465;
1470 -> 1467;
1471 -> 1466;
1471 -> 1467;
1472 -> 1467;
1473 -> 1467;
1474 -> 1467;
1475 -> 1467;
1476 -> 1467;
1477 -> 1467;
1478 -> 1467;
1479 -> 1467;
1480 -> 1467;
1481 -> 1467;
1482 -> 1467;
1483 -> 1467;
1484 -> 1467;
1485 -> 1467;
1486 -> 1467;
1487 -> 1467;
1488 -> 1467;
1489 -> 1467;
1490 -> 1467;
1491 -> 1467;
1492 -> 1467;
1493 -> 1467;
1494 -> 1467;
1495 -> 1467;
1496 -> 1468;
1496 -> 1467;
1497 -> 1469;
1497 -> 1467;
1498 -> 1470;
1498 -> 1467;
1499 -> 1471;
1499 -> 1467;
1500 -> 1472;
1500 -> 1467;
1501 -> 1473;
1501 -> 1467;
1502 -> 1474;
1502 -> 1467;
1503 -> 1475;
1503 -> 1467;
1504 -> 1476;
1504 -> 1467;
1505 -> 1477;
1505 -> 1467;
1506 -> 1478;
1506 -> 1467;
1507 -> 1479;
1507 -> 1467;
1508 -> 1480;
1508 -> 1467;
1509 -> 1481;
1509 -> 1467;
1510 -> 1482;
1510 -> 1467;
1511 -> 1483;
1511 -> 1467;
1512 -> 1484;
1512 -> 1467;
1513 -> 1485;
1513 -> 1467;
1514 -> 1486;
1514 -> 1467;
1515 -> 1467;
1516 -> 1467;
1517 -> 1487;
1517 -> 1467;
1518 -> 1488;
1518 -> 1467;
1519 -> 1467;
1520 -> 1489;
1520 -> 1467;
1521 -> 1490;
1521 -> 1467;
1522 -> 1491;
1522 -> 1467;
1523 -> 1493;
1523 -> 1467;
1524 -> 1467;
1525 -> 1492;
1525 -> 1467;
1526 -> 0;
1526 -> 1467;
1527 -> 1494;
1527 -> 1467;
1528 -> 1496;
1528 -> 1495;
1529 -> 1497;
1529 -> 1495;
1530 -> 1498;
1530 -> 1495;
1531 -> 1499;
1531 -> 1495;
1532 -> 1500;
1532 -> 1495;
1533 -> 1501;
1533 -> 1495;
1534 -> 1502;
1534 -> 1495;
1535 -> 1503;
1535 -> 1495;
1536 -> 1504;
1536 -> 1495;
1537 -> 1505;
1537 -> 1495;
1538 -> 1506;
1538 -> 1495;
1539 -> 1507;
1539 -> 1495;
1540 -> 1508;
1540 -> 1495;
1541 -> 1509;
1541 -> 1495;
1542 -> 1510;
1542 -> 1495;
1543 -> 1511;
1543 -> 1495;
1544 -> 1512;
1544 -> 1495;
1545 -> 1513;
1545 -> 1495;
1546 -> 1514;
1546 -> 1495;
1547 -> 1515;
1547 -> 1495;
1548 -> 1516;
1548 -> 1495;
1549 -> 1517;
1549 -> 1495;
1550 -> 1518;
1550 -> 1495;
1551 -> 1519;
1551 -> 1495;
1552 -> 1520;
1552 -> 1495;
1553 -> 1521;
1553 -> 1495;
1554 -> 1522;
1554 -> 1495;
1555 -> 1523;
1555 -> 1495;
1556 -> 1524;
1556 -> 1495;
1557 -> 1525;
1557 -> 1495;
1558 -> 1526;
1558 -> 1495;
1559 -> 1527;
1559 -> 1495;
1560 -> 1495;
1561 -> 1528;
1561 -> 1495;
1562 -> 1529;
1562 -> 1495;
1563 -> 1530;
1563 -> 1495;
1564 -> 1531;
1564 -> 1495;
1565 -> 1532;
1565 -> 1495;
1566 -> 1537;
1566 -> 1495;
1567 -> 1538;
1567 -> 1495;
1568 -> 1539;
1568 -> 1495;
1569 -> 1540;
1569 -> 1495;
1570 -> 1557;
1570 -> 1495;
1571 -> 1534;
1571 -> 1495;
1572 -> 1535;
1572 -> 1495;
1573 -> 1541;
1573 -> 1495;
1574 -> 1542;
1574 -> 1495;
1575 -> 1543;
1575 -> 1495;
1576 -> 1544;
1576 -> 1495;
1577 -> 1576;
1577 -> 1495;
1578 -> 1545;
1578 -> 1495;
1579 -> 1546;
1579 -> 1495;
1580 -> 1547;
1580 -> 1495;
1581 -> 1548;
1581 -> 1495;
1582 -> 1549;
1582 -> 1495;
1583 -> 1550;
1583 -> 1495;
1584 -> 1551;
1584 -> 1495;
1585 -> 1552;
1585 -> 1495;
1586 -> 1553;
1586 -> 1495;
1587 -> 1554;
1587 -> 1495;
1588 -> 1555;
1588 -> 1495;
1589 -> 1556;
1589 -> 1495;
1590 -> 1560;
1590 -> 1561;
1590 -> 1562;
1590 -> 1563;
1590 -> 1564;
1590 -> 1565;
1590 -> 1566;
1590 -> 1567;
1590 -> 1568;
1590 -> 1569;
1590 -> 1570;
1590 -> 1571;
1590 -> 1572;
1590 -> 1573;
1590 -> 1574;
1590 -> 1575;
1590 -> 1577;
1590 -> 1578;
1590 -> 1579;
1590 -> 1580;
1590 -> 1581;
1590 -> 1582;
1590 -> 1583;
1590 -> 1584;
1590 -> 1585;
1590 -> 1586;
1590 -> 1587;
1590 -> 1588;
1590 -> 1589;
1590 -> 1515;
1590 -> 1495;
1591 -> 1560;
1591 -> 1495;
1592 -> 1560;
1592 -> 1495;
1593 -> 1560;
1593 -> 1495;
1594 -> 1533;
1594 -> 1495;
1595 -> 1594;
1595 -> 1560;
1595 -> 1495;
1596 -> 1536;
1596 -> 1560;
1596 -> 1495;
1597 -> 1558;
1597 -> 1560;
1597 -> 1495;
1598 -> 1559;
1598 -> 1560;
1598 -> 1495;
1599 -> 1467;
1600 -> 0;
1601 -> 0;
1603 -> 1600;
1603 -> 1602;
1604 -> 1601;
1604 -> 1602;
1605 -> 1602;
1606 -> 1603;
1606 -> 1602;
1607 -> 1604;
1607 -> 1602;
1608 -> 0;
1608 -> 1602;
1609 -> 1605;
1609 -> 1602;
1610 -> 1602;
1611 -> 1606;
1611 -> 1610;
1612 -> 1607;
1612 -> 1610;
1613 -> 1608;
1613 -> 1610;
1614 -> 1609;
1614 -> 1610;
1615 -> 1610;
1616 -> 1610;
1617 -> 1610;
1618 -> 1610;
1619 -> 1610;
1620 -> 1610;
1621 -> 1610;
1622 -> 1610;
1623 -> 1610;
1624 -> 1610;
1625 -> 1610;
1626 -> 1610;
1627 -> 1610;
1628 -> 1610;
1629 -> 1610;
1630 -> 1610;
1631 -> 1610;
1632 -> 1610;
1633 -> 1610;
1634 -> 1610;
1635 -> 1610;
1636 -> 1610;
1637 -> 1610;
1638 -> 1610;
1639 -> 1611;
1639 -> 1610;
1640 -> 1612;
1640 -> 1610;
1641 -> 1613;
1641 -> 1610;
1642 -> 1614;
1642 -> 1610;
1643 -> 1615;
1643 -> 1610;
1644 -> 1616;
1644 -> 1610;
1645 -> 1617;
1645 -> 1610;
1646 -> 1618;
1646 -> 1610;
1647 -> 1619;
1647 -> 1610;
1648 -> 1620;
1648 -> 1610;
1649 -> 1621;
1649 -> 1610;
1650 -> 1622;
1650 -> 1610;
1651 -> 1623;
1651 -> 1610;
1652 -> 1624;
1652 -> 1610;
1653 -> 1625;
1653 -> 1610;
1654 -> 1626;
1654 -> 1610;
1655 -> 1627;
1655 -> 1610;
1656 -> 1628;
1656 -> 1610;
1657 -> 1629;
1657 -> 1610;
1658 -> 1610;
1659 -> 1610;
1660 -> 1630;
1660 -> 1610;
1661 -> 1631;
1661 -> 1610;
1662 -> 1610;
1663 -> 1632;
1663 -> 1610;
1664 -> 1633;
1664 -> 1610;
1665 -> 1634;
1665 -> 1610;
1666 -> 1636;
1666 -> 1610;
1667 -> 1610;
1668 -> 1635;
1668 -> 1610;
1669 -> 0;
1669 -> 1610;
1670 -> 1637;
1670 -> 1610;
1671 -> 1639;
1671 -> 1638;
1672 -> 1640;
1672 -> 1638;
1673 -> 1641;
1673 -> 1638;
1674 -> 1642;
1674 -> 1638;
1675 -> 1643;
1675 -> 1638;
1676 -> 1644;
1676 -> 1638;
1677 -> 1645;
1677 -> 1638;
1678 -> 1646;
1678 -> 1638;
1679 -> 1647;
1679 -> 1638;
1680 -> 1648;
1680 -> 1638;
1681 -> 1649;
1681 -> 1638;
1682 -> 1650;
1682 -> 1638;
1683 -> 1651;
1683 -> 1638;
1684 -> 1652;
1684 -> 1638;
1685 -> 1653;
1685 -> 1638;
1686 -> 1654;
1686 -> 1638;
1687 -> 1655;
1687 -> 1638;
1688 -> 1656;
1688 -> 1638;
1689 -> 1657;
1689 -> 1638;
1690 -> 1658;
1690 -> 1638;
1691 -> 1659;
1691 -> 1638;
1692 -> 1660;
1692 -> 1638;
1693 -> 1661;
1693 -> 1638;
1694 -> 1662;
1694 -> 1638;
1695 -> 1663;
1695 -> 1638;
1696 -> 1664;
1696 -> 1638;
1697 -> 1665;
1697 -> 1638;
1698 -> 1666;
1698 -> 1638;
1699 -> 1667;
1699 -> 1638;
1700 -> 1668;
1700 -> 1638;
1701 -> 1669;
1701 -> 1638;
1702 -> 1670;
1702 -> 1638;
1703 -> 1638;
1704 -> 1671;
1704 -> 1638;
1705 -> 1672;
1705 -> 1638;
1706 -> 1673;
1706 -> 1638;
1707 -> 1674;
1707 -> 1638;
1708 -> 1675;
1708 -> 1638;
1709 -> 1680;
1709 -> 1638;
1710 -> 1681;
1710 -> 1638;
1711 -> 1682;
1711 -> 1638;
1712 -> 1683;
1712 -> 1638;
1713 -> 1700;
1713 -> 1638;
1714 -> 1677;
1714 -> 1638;
1715 -> 1678;
1715 -> 1638;
1716 -> 1684;
1716 -> 1638;
1717 -> 1685;
1717 -> 1638;
1718 -> 1686;
1718 -> 1638;
1719 -> 1687;
1719 -> 1638;
1720 -> 1719;
1720 -> 1638;
1721 -> 1688;
1721 -> 1638;
1722 -> 1689;
1722 -> 1638;
1723 -> 1690;
1723 -> 1638;
1724 -> 1691;
1724 -> 1638;
1725 -> 1692;
1725 -> 1638;
1726 -> 1693;
1726 -> 1638;
1727 -> 1694;
1727 -> 1638;
1728 -> 1695;
1728 -> 1638;
1729 -> 1696;
1729 -> 1638;
1730 -> 1697;
1730 -> 1638;
1731 -> 1698;
1731 -> 1638;
1732 -> 1699;
1732 -> 1638;
1733 -> 1703;
1733 -> 1704;
1733 -> 1705;
1733 -> 1706;
1733 -> 1707;
1733 -> 1708;
1733 -> 1709;
1733 -> 1710;
1733 -> 1711;
1733 -> 1712;
1733 -> 1713;
1733 -> 1714;
1733 -> 1715;
1733 -> 1716;
1733 -> 1717;
1733 -> 1718;
1733 -> 1720;
1733 -> 1721;
1733 -> 1722;
1733 -> 1723;
1733 -> 1724;
1733 -> 1725;
1733 -> 1726;
1733 -> 1727;
1733 -> 1728;
1733 -> 1729;
1733 -> 1730;
1733 -> 1731;
1733 -> 1732;
1733 -> 1658;
1733 -> 1638;
1734 -> 1703;
1734 -> 1638;
1735 -> 1703;
1735 -> 1638;
1736 -> 1703;
1736 -> 1638;
1737 -> 1676;
1737 -> 1638;
1738 -> 1737;
1738 -> 1703;
1738 -> 1638;
1739 -> 1679;
1739 -> 1703;
1739 -> 1638;
1740 -> 1701;
1740 -> 1703;
1740 -> 1638;
1741 -> 1702;
1741 -> 1703;
1741 -> 1638;
1742 -> 1610;
1743 -> 0;
1744 -> 0;
1746 -> 1743;
1746 -> 1745;
1747 -> 1744;
1747 -> 1745;
1748 -> 1745;
1749 -> 1746;
1749 -> 1745;
1750 -> 1747;
1750 -> 1745;
1751 -> 0;
1751 -> 1745;
1752 -> 1748;
1752 -> 1745;
1753 -> 1745;
1754 -> 1749;
1754 -> 1753;
1755 -> 1750;
1755 -> 1753;
1756 -> 1751;
1756 -> 1753;
1757 -> 1752;
1757 -> 1753;
1758 -> 1753;
1759 -> 1753;
1760 -> 1753;
1761 -> 1753;
1762 -> 1753;
1763 -> 1753;
1764 -> 1753;
1765 -> 1753;
1766 -> 1753;
1767 -> 1753;
1768 -> 1753;
1769 -> 1753;
1770 -> 1753;
1771 -> 1753;
1772 -> 1753;
1773 -> 1753;
1774 -> 1753;
1775 -> 1753;
1776 -> 1753;
1777 -> 1753;
1778 -> 1753;
1779 -> 1753;
1780 -> 1753;
1781 -> 1753;
1782 -> 1754;
1782 -> 1753;
1783 -> 1755;
1783 -> 1753;
1784 -> 1756;
1784 -> 1753;
1785 -> 1757;
1785 -> 1753;
1786 -> 1758;
1786 -> 1753;
1787 -> 1759;
1787 -> 1753;
1788 -> 1760;
1788 -> 1753;
1789 -> 1761;
1789 -> 1753;
1790 -> 1762;
1790 -> 1753;
1791 -> 1763;
1791 -> 1753;
1792 -> 1764;
1792 -> 1753;
1793 -> 1765;
1793 -> 1753;
1794 -> 1766;
1794 -> 1753;
1795 -> 1767;
1795 -> 1753;
1796 -> 1768;
1796 -> 1753;
1797 -> 1769;
1797 -> 1753;
1798 -> 1770;
1798 -> 1753;
1799 -> 1771;
1799 -> 1753;
1800 -> 1772;
1800 -> 1753;
1801 -> 1753;
1802 -> 1753;
1803 -> 1773;
1803 -> 1753;
1804 -> 1774;
1804 -> 1753;
1805 -> 1753;
1806 -> 1775;
1806 -> 1753;
1807 -> 1776;
1807 -> 1753;
1808 -> 1777;
1808 -> 1753;
1809 -> 1779;
1809 -> 1753;
1810 -> 1753;
1811 -> 1778;
1811 -> 1753;
1812 -> 0;
1812 -> 1753;
1813 -> 1780;
1813 -> 1753;
1814 -> 1782;
1814 -> 1781;
1815 -> 1783;
1815 -> 1781;
1816 -> 1784;
1816 -> 1781;
1817 -> 1785;
1817 -> 1781;
1818 -> 1786;
1818 -> 1781;
1819 -> 1787;
1819 -> 1781;
1820 -> 1788;
1820 -> 1781;
1821 -> 1789;
1821 -> 1781;
1822 -> 1790;
1822 -> 1781;
1823 -> 1791;
1823 -> 1781;
1824 -> 1792;
1824 -> 1781;
1825 -> 1793;
1825 -> 1781;
1826 -> 1794;
1826 -> 1781;
1827 -> 1795;
1827 -> 1781;
1828 -> 1796;
1828 -> 1781;
1829 -> 1797;
1829 -> 1781;
1830 -> 1798;
1830 -> 1781;
1831 -> 1799;
1831 -> 1781;
1832 -> 1800;
1832 -> 1781;
1833 -> 1801;
1833 -> 1781;
1834 -> 1802;
1834 -> 1781;
1835 -> 1803;
1835 -> 1781;
1836 -> 1804;
1836 -> 1781;
1837 -> 1805;
1837 -> 1781;
1838 -> 1806;
1838 -> 1781;
1839 -> 1807;
1839 -> 1781;
1840 -> 1808;
1840 -> 1781;
1841 -> 1809;
1841 -> 1781;
1842 -> 1810;
1842 -> 1781;
1843 -> 1811;
1843 -> 1781;
1844 -> 1812;
1844 -> 1781;
1845 -> 1813;
1845 -> 1781;
1846 -> 1781;
1847 -> 1814;
1847 -> 1781;
1848 -> 1815;
1848 -> 1781;
1849 -> 1816;
1849 -> 1781;
1850 -> 1817;
1850 -> 1781;
1851 -> 1818;
1851 -> 1781;
1852 -> 1823;
1852 -> 1781;
1853 -> 1824;
1853 -> 1781;
1854 -> 1825;
1854 -> 1781;
1855 -> 1826;
1855 -> 1781;
1856 -> 1843;
1856 -> 1781;
1857 -> 1820;
1857 -> 1781;
1858 -> 1821;
1858 -> 1781;
1859 -> 1827;
1859 -> 1781;
1860 -> 1828;
1860 -> 1781;
1861 -> 1829;
1861 -> 1781;
1862 -> 1830;
1862 -> 1781;
1863 -> 1862;
1863 -> 1781;
1864 -> 1831;
1864 -> 1781;
1865 -> 1832;
1865 -> 1781;
1866 -> 1833;
1866 -> 1781;
1867 -> 1834;
1867 -> 1781;
1868 -> 1835;
1868 -> 1781;
1869 -> 1836;
1869 -> 1781;
1870 -> 1837;
1870 -> 1781;
1871 -> 1838;
1871 -> 1781;
1872 -> 1839;
1872 -> 1781;
1873 -> 1840;
1873 -> 1781;
1874 -> 1841;
1874 -> 1781;
1875 -> 1842;
1875 -> 1781;
1876 -> 1846;
1876 -> 1847;
1876 -> 1848;
1876 -> 1849;
1876 -> 1850;
1876 -> 1851;
1876 -> 1852;
1876 -> 1853;
1876 -> 1854;
1876 -> 1855;
1876 -> 1856;
1876 -> 1857;
1876 -> 1858;
1876 -> 1859;
1876 -> 1860;
1876 -> 1861;
1876 -> 1863;
1876 -> 1864;
1876 -> 1865;
1876 -> 1866;
1876 -> 1867;
1876 -> 1868;
1876 -> 1869;
1876 -> 1870;
1876 -> 1871;
1876 -> 1872;
1876 -> 1873;
1876 -> 1874;
1876 -> 1875;
1876 -> 1801;
1876 -> 1781;
1877 -> 1846;
1877 -> 1781;
1878 -> 1846;
1878 -> 1781;
1879 -> 1846;
1879 -> 1781;
1880 -> 1819;
1880 -> 1781;
1881 -> 1880;
1881 -> 1846;
1881 -> 1781;
1882 -> 1822;
1882 -> 1846;
1882 -> 1781;
1883 -> 1844;
1883 -> 1846;
1883 -> 1781;
1884 -> 1845;
1884 -> 1846;
1884 -> 1781;
1885 -> 1753;
1886 -> 0;
1887 -> 0;
1889 -> 1886;
1889 -> 1888;
1890 -> 1887;
1890 -> 1888;
1891 -> 1888;
1892 -> 1889;
1892 -> 1888;
1893 -> 1890;
1893 -> 1888;
1894 -> 0;
1894 -> 1888;
1895 -> 1891;
1895 -> 1888;
1896 -> 1888;
1897 -> 1892;
1897 -> 1896;
1898 -> 1893;
1898 -> 1896;
1899 -> 1894;
1899 -> 1896;
1900 -> 1895;
1900 -> 1896;
1901 -> 1896;
1902 -> 1896;
1903 -> 1896;
1904 -> 1896;
1905 -> 1896;
1906 -> 1896;
1907 -> 1896;
1908 -> 1896;
1909 -> 1896;
1910 -> 1896;
1911 -> 1896;
1912 -> 1896;
1913 -> 1896;
1914 -> 1896;
1915 -> 1896;
1916 -> 1896;
1917 -> 1896;
1918 -> 1896;
1919 -> 1896;
1920 -> 1896;
1921 -> 1896;
1922 -> 1896;
1923 -> 1896;
1924 -> 1896;
1925 -> 1897;
1925 -> 1896;
1926 -> 1898;
1926 -> 1896;
1927 -> 1899;
1927 -> 1896;
1928 -> 1900;
1928 -> 1896;
1929 -> 1901;
1929 -> 1896;
1930 -> 1902;
1930 -> 1896;
1931 -> 1903;
1931 -> 1896;
1932 -> 1904;
1932 -> 1896;
1933 -> 1905;
1933 -> 1896;
1934 -> 1906;
1934 -> 1896;
1935 -> 1907;
1935 -> 1896;
1936 -> 1908;
1936 -> 1896;
1937 -> 1909;
1937 -> 1896;
1938 -> 1910;
1938 -> 1896;
1939 -> 1911;
1939 -> 1896;
1940 -> 1912;
1940 -> 1896;
1941 -> 1913;
1941 -> 1896;
1942 -> 1914;
1942 -> 1896;
1943 -> 1915;
1943 -> 1896;
1944 -> 1896;
1945 -> 1896;
1946 -> 1916;
1946 -> 1896;
1947 -> 1917;
1947 -> 1896;
1948 -> 1896;
1949 -> 1918;
1949 -> 1896;
1950 -> 1919;
1950 -> 1896;
1951 -> 1920;
1951 -> 1896;
1952 -> 1922;
1952 -> 1896;
1953 -> 1896;
1954 -> 1921;
1954 -> 1896;
1955 -> 0;
1955 -> 1896;
1956 -> 1923;
1956 -> 1896;
1957 -> 1925;
1957 -> 1924;
1958 -> 1926;
1958 -> 1924;
1959 -> 1927;
1959 -> 1924;
1960 -> 1928;
1960 -> 1924;
1961 -> 1929;
1961 -> 1924;
1962 -> 1930;
1962 -> 1924;
1963 -> 1931;
1963 -> 1924;
1964 -> 1932;
1964 -> 1924;
1965 -> 1933;
1965 -> 1924;
1966 -> 1934;
1966 -> 1924;
1967 -> 1935;
1967 -> 1924;
1968 -> 1936;
1968 -> 1924;
1969 -> 1937;
1969 -> 1924;
1970 -> 1938;
1970 -> 1924;
1971 -> 1939;
1971 -> 1924;
1972 -> 1940;
1972 -> 1924;
1973 -> 1941;
1973 -> 1924;
1974 -> 1942;
1974 -> 1924;
1975 -> 1943;
1975 -> 1924;
1976 -> 1944;
1976 -> 1924;
1977 -> 1945;
1977 -> 1924;
1978 -> 1946;
1978 -> 1924;
1979 -> 1947;
1979 -> 1924;
1980 -> 1948;
1980 -> 1924;
1981 -> 1949;
1981 -> 1924;
1982 -> 1950;
1982 -> 1924;
1983 -> 1951;
1983 -> 1924;
1984 -> 1952;
1984 -> 1924;
1985 -> 1953;
1985 -> 1924;
1986 -> 1954;
1986 -> 1924;
1987 -> 1955;
1987 -> 1924;
1988 -> 1956;
1988 -> 1924;
1989 -> 1924;
1990 -> 1957;
1990 -> 1924;
1991 -> 1958;
1991 -> 1924;
1992 -> 1959;
1992 -> 1924;
1993 -> 1960;
1993 -> 1924;
1994 -> 1961;
1994 -> 1924;
1995 -> 1966;
1995 -> 1924;
1996 -> 1967;
1996 -> 1924;
1997 -> 1968;
1997 -> 1924;
1998 -> 1969;
1998 -> 1924;
1999 -> 1986;
1999 -> 1924;
2000 -> 1963;
2000 -> 1924;
2001 -> 1964;
2001 -> 1924;
2002 -> 1970;
2002 -> 1924;
2003 -> 1971;
2003 -> 1924;
2004 -> 1972;
2004 -> 1924;
2005 -> 1973;
2005 -> 1924;
2006 -> 2005;
2006 -> 1924;
2007 -> 1974;
2007 -> 1924;
2008 -> 1975;
2008 -> 1924;
2009 -> 1976;
2009 -> 1924;
2010 -> 1977;
2010 -> 1924;
2011 -> 1978;
2011 -> 1924;
2012 -> 1979;
2012 -> 1924;
2013 -> 1980;
2013 -> 1924;
2014 -> 1981;
2014 -> 1924;
2015 -> 1982;
2015 -> 1924;
2016 -> 1983;
2016 -> 1924;
2017 -> 1984;
2017 -> 1924;
2018 -> 1985;
2018 -> 1924;
2019 -> 1989;
2019 -> 1990;
2019 -> 1991;
2019 -> 1992;
2019 -> 1993;
2019 -> 1994;
2019 -> 1995;
2019 -> 1996;
2019 -> 1997;
2019 -> 1998;
2019 -> 1999;
2019 -> 2000;
2019 -> 2001;
2019 -> 2002;
2019 -> 2003;
2019 -> 2004;
2019 -> 2006;
2019 -> 2007;
2019 -> 2008;
2019 -> 2009;
2019 -> 2010;
2019 -> 2011;
2019 -> 2012;
2019 -> 2013;
2019 -> 2014;
2019 -> 2015;
2019 -> 2016;
2019 -> 2017;
2019 -> 2018;
2019 -> 1944;
2019 -> 1924;
2020 -> 1989;
2020 -> 1924;
2021 -> 1989;
2021 -> 1924;
2022 -> 1989;
2022 -> 1924;
2023 -> 1962;
2023 -> 1924;
2024 -> 2023;
2024 -> 1989;
2024 -> 1924;
2025 -> 1965;
2025 -> 1989;
2025 -> 1924;
2026 -> 1987;
2026 -> 1989;
2026 -> 1924;
2027 -> 1988;
2027 -> 1989;
2027 -> 1924;
2028 -> 1896;
2029 -> 0;
2030 -> 0;
2032 -> 2029;
2032 -> 2031;
2033 -> 2030;
2033 -> 2031;
2034 -> 2031;
2035 -> 2032;
2035 -> 2031;
2036 -> 2033;
2036 -> 2031;
2037 -> 0;
2037 -> 2031;
2038 -> 2034;
2038 -> 2031;
2039 -> 2031;
2040 -> 2035;
2040 -> 2039;
2041 -> 2036;
2041 -> 2039;
2042 -> 2037;
2042 -> 2039;
2043 -> 2038;
2043 -> 2039;
2044 -> 2039;
2045 -> 2039;
2046 -> 2039;
2047 -> 2039;
2048 -> 2039;
2049 -> 2039;
2050 -> 2039;
2051 -> 2039;
2052 -> 2039;
2053 -> 2039;
2054 -> 2039;
2055 -> 2039;
2056 -> 2039;
2057 -> 2039;
2058 -> 2039;
2059 -> 2039;
2060 -> 2039;
2061 -> 2039;
2062 -> 2039;
2063 -> 2039;
2064 -> 2039;
2065 -> 2039;
2066 -> 2039;
2067 -> 2039;
2068 -> 2040;
2068 -> 2039;
2069 -> 2041;
2069 -> 2039;
2070 -> 2042;
2070 -> 2039;
2071 -> 2043;
2071 -> 2039;
2072 -> 2044;
2072 -> 2039;
2073 -> 2045;
2073 -> 2039;
2074 -> 2046;
2074 -> 2039;
2075 -> 2047;
2075 -> 2039;
2076 -> 2048;
2076 -> 2039;
2077 -> 2049;
2077 -> 2039;
2078 -> 2050;
2078 -> 2039;
2079 -> 2051;
2079 -> 2039;
2080 -> 2052;
2080 -> 2039;
2081 -> 2053;
2081 -> 2039;
2082 -> 2054;
2082 -> 2039;
2083 -> 2055;
2083 -> 2039;
2084 -> 2056;
2084 -> 2039;
2085 -> 2057;
2085 -> 2039;
2086 -> 2058;
2086 -> 2039;
2087 -> 2039;
2088 -> 2039;
2089 -> 2059;
2089 -> 2039;
2090 -> 2060;
2090 -> 2039;
2091 -> 2039;
2092 -> 2061;
2092 -> 2039;
2093 -> 2062;
2093 -> 2039;
2094 -> 2063;
2094 -> 2039;
2095 -> 2065;
2095 -> 2039;
2096 -> 2039;
2097 -> 2064;
2097 -> 2039;
2098 -> 0;
2098 -> 2039;
2099 -> 2066;
2099 -> 2039;
2100 -> 2068;
2100 -> 2067;
2101 -> 2069;
2101 -> 2067;
2102 -> 2070;
2102 -> 2067;
2103 -> 2071;
2103 -> 2067;
2104 -> 2072;
2104 -> 2067;
2105 -> 2073;
2105 -> 2067;
2106 -> 2074;
2106 -> 2067;
2107 -> 2075;
2107 -> 2067;
2108 -> 2076;
2108 -> 2067;
2109 -> 2077;
2109 -> 2067;
2110 -> 2078;
2110 -> 2067;
2111 -> 2079;
2111 -> 2067;
2112 -> 2080;
2112 -> 2067;
2113 -> 2081;
2113 -> 2067;
2114 -> 2082;
2114 -> 2067;
2115 -> 2083;
2115 -> 2067;
2116 -> 2084;
2116 -> 2067;
2117 -> 2085;
2117 -> 2067;
2118 -> 2086;
2118 -> 2067;
2119 -> 2087;
2119 -> 2067;
2120 -> 2088;
2120 -> 2067;
2121 -> 2089;
2121 -> 2067;
2122 -> 2090;
2122 -> 2067;
2123 -> 2091;
2123 -> 2067;
2124 -> 2092;
2124 -> 2067;
2125 -> 2093;
2125 -> 2067;
2126 -> 2094;
2126 -> 2067;
2127 -> 2095;
2127 -> 2067;
2128 -> 2096;
2128 -> 2067;
2129 -> 2097;
2129 -> 2067;
2130 -> 2098;
2130 -> 2067;
2131 -> 2099;
2131 -> 2067;
2132 -> 2067;
2133 -> 2100;
2133 -> 2067;
2134 -> 2101;
2134 -> 2067;
2135 -> 2102;
2135 -> 2067;
2136 -> 2103;
2136 -> 2067;
2137 -> 2104;
2137 -> 2067;
2138 -> 2109;
2138 -> 2067;
2139 -> 2110;
2139 -> 2067;
2140 -> 2111;
2140 -> 2067;
2141 -> 2112;
2141 -> 2067;
2142 -> 2129;
2142 -> 2067;
2143 -> 2106;
2143 -> 2067;
2144 -> 2107;
2144 -> 2067;
2145 -> 2113;
2145 -> 2067;
2146 -> 2114;
2146 -> 2067;
2147 -> 2115;
2147 -> 2067;
2148 -> 2116;
2148 -> 2067;
2149 -> 2148;
2149 -> 2067;
2150 -> 2117;
2150 -> 2067;
2151 -> 2118;
2151 -> 2067;
2152 -> 2119;
2152 -> 2067;
2153 -> 2120;
2153 -> 2067;
2154 -> 2121;
2154 -> 2067;
2155 -> 2122;
2155 -> 2067;
2156 -> 2123;
2156 -> 2067;
2157 -> 2124;
2157 -> 2067;
2158 -> 2125;
2158 -> 2067;
2159 -> 2126;
2159 -> 2067;
2160 -> 2127;
2160 -> 2067;
2161 -> 2128;
2161 -> 2067;
2162 -> 2132;
2162 -> 2133;
2162 -> 2134;
2162 -> 2135;
2162 -> 2136;
2162 -> 2137;
2162 -> 2138;
2162 -> 2139;
2162 -> 2140;
2162 -> 2141;
2162 -> 2142;
2162 -> 2143;
2162 -> 2144;
2162 -> 2145;
2162 -> 2146;
2162 -> 2147;
2162 -> 2149;
2162 -> 2150;
2162 -> 2151;
2162 -> 2152;
2162 -> 2153;
2162 -> 2154;
2162 -> 2155;
2162 -> 2156;
2162 -> 2157;
2162 -> 2158;
2162 -> 2159;
2162 -> 2160;
2162 -> 2161;
2162 -> 2087;
2162 -> 2067;
2163 -> 2132;
2163 -> 2067;
2164 -> 2132;
2164 -> 2067;
2165 -> 2132;
2165 -> 2067;
2166 -> 2105;
2166 -> 2067;
2167 -> 2166;
2167 -> 2132;
2167 -> 2067;
2168 -> 2108;
2168 -> 2132;
2168 -> 2067;
2169 -> 2130;
2169 -> 2132;
2169 -> 2067;
2170 -> 2131;
2170 -> 2132;
2170 -> 2067;
2171 -> 2039;
2172 -> 0;
2173 -> 0;
2175 -> 2172;
2175 -> 2174;
2176 -> 2173;
2176 -> 2174;
2177 -> 2174;
2178 -> 2175;
2178 -> 2174;
2179 -> 2176;
2179 -> 2174;
2180 -> 0;
2180 -> 2174;
2181 -> 2177;
2181 -> 2174;
2182 -> 2174;
2183 -> 2178;
2183 -> 2182;
2184 -> 2179;
2184 -> 2182;
2185 -> 2180;
2185 -> 2182;
2186 -> 2181;
2186 -> 2182;
2187 -> 2182;
2188 -> 2182;
2189 -> 2182;
2190 -> 2182;
2191 -> 2182;
2192 -> 2182;
2193 -> 2182;
2194 -> 2182;
2195 -> 2182;
2196 -> 2182;
2197 -> 2182;
2198 -> 2182;
2199 -> 2182;
2200 -> 2182;
2201 -> 2182;
2202 -> 2182;
2203 -> 2182;
2204 -> 2182;
2205 -> 2182;
2206 -> 2182;
2207 -> 2182;
2208 -> 2182;
2209 -> 2182;
2210 -> 2182;
2211 -> 2183;
2211 -> 2182;
2212 -> 2184;
2212 -> 2182;
2213 -> 2185;
2213 -> 2182;
2214 -> 2186;
2214 -> 2182;
2215 -> 2187;
2215 -> 2182;
2216 -> 2188;
2216 -> 2182;
2217 -> 2189;
2217 -> 2182;
2218 -> 2190;
2218 -> 2182;
2219 -> 2191;
2219 -> 2182;
2220 -> 2192;
2220 -> 2182;
2221 -> 2193;
2221 -> 2182;
2222 -> 2194;
2222 -> 2182;
2223 -> 2195;
2223 -> 2182;
2224 -> 2196;
2224 -> 2182;
2225 -> 2197;
2225 -> 2182;
2226 -> 2198;
2226 -> 2182;
2227 -> 2199;
2227 -> 2182;
2228 -> 2200;
2228 -> 2182;
2229 -> 2201;
2229 -> 2182;
2230 -> 2182;
2231 -> 2182;
2232 -> 2202;
2232 -> 2182;
2233 -> 2203;
2233 -> 2182;
2234 -> 2182;
2235 -> 2204;
2235 -> 2182;
2236 -> 2205;
2236 -> 2182;
2237 -> 2206;
2237 -> 2182;
2238 -> 2208;
2238 -> 2182;
2239 -> 2182;
2240 -> 2207;
2240 -> 2182;
2241 -> 0;
2241 -> 2182;
2242 -> 2209;
2242 -> 2182;
2243 -> 2211;
2243 -> 2210;
2244 -> 2212;
2244 -> 2210;
2245 -> 2213;
2245 -> 2210;
2246 -> 2214;
2246 -> 2210;
2247 -> 2215;
2247 -> 2210;
2248 -> 2216;
2248 -> 2210;
2249 -> 2217;
2249 -> 2210;
2250 -> 2218;
2250 -> 2210;
2251 -> 2219;
2251 -> 2210;
2252 -> 2220;
2252 -> 2210;
2253 -> 2221;
2253 -> 2210;
2254 -> 2222;
2254 -> 2210;
2255 -> 2223;
2255 -> 2210;
2256 -> 2224;
2256 -> 2210;
2257 -> 2225;
2257 -> 2210;
2258 -> 2226;
2258 -> 2210;
2259 -> 2227;
2259 -> 2210;
2260 -> 2228;
2260 -> 2210;
2261 -> 2229;
2261 -> 2210;
2262 -> 2230;
2262 -> 2210;
2263 -> 2231;
2263 -> 2210;
2264 -> 2232;
2264 -> 2210;
2265 -> 2233;
2265 -> 2210;
2266 -> 2234;
2266 -> 2210;
2267 -> 2235;
2267 -> 2210;
2268 -> 2236;
2268 -> 2210;
2269 -> 2237;
2269 -> 2210;
2270 -> 2238;
2270 -> 2210;
2271 -> 2239;
2271 -> 2210;
2272 -> 2240;
2272 -> 2210;
2273 -> 2241;
2273 -> 2210;
2274 -> 2242;
2274 -> 2210;
2275 -> 2210;
2276 -> 2243;
2276 -> 2210;
2277 -> 2244;
2277 -> 2210;
2278 -> 2245;
2278 -> 2210;
2279 -> 2246;
2279 -> 2210;
2280 -> 2247;
2280 -> 2210;
2281 -> 2252;
2281 -> 2210;
2282 -> 2253;
2282 -> 2210;
2283 -> 2254;
2283 -> 2210;
2284 -> 2255;
2284 -> 2210;
2285 -> 2272;
2285 -> 2210;
2286 -> 2249;
2286 -> 2210;
2287 -> 2250;
2287 -> 2210;
2288 -> 2256;
2288 -> 2210;
2289 -> 2257;
2289 -> 2210;
2290 -> 2258;
2290 -> 2210;
2291 -> 2259;
2291 -> 2210;
2292 -> 2291;
2292 -> 2210;
2293 -> 2260;
2293 -> 2210;
2294 -> 2261;
2294 -> 2210;
2295 -> 2262;
2295 -> 2210;
2296 -> 2263;
2296 -> 2210;
2297 -> 2264;
2297 -> 2210;
2298 -> 2265;
2298 -> 2210;
2299 -> 2266;
2299 -> 2210;
2300 -> 2267;
2300 -> 2210;
2301 -> 2268;
2301 -> 2210;
2302 -> 2269;
2302 -> 2210;
2303 -> 2270;
2303 -> 2210;
2304 -> 2271;
2304 -> 2210;
2305 -> 2275;
2305 -> 2276;
2305 -> 2277;
2305 -> 2278;
2305 -> 2279;
2305 -> 2280;
2305 -> 2281;
2305 -> 2282;
2305 -> 2283;
2305 -> 2284;
2305 -> 2285;
2305 -> 2286;
2305 -> 2287;
2305 -> 2288;
2305 -> 2289;
2305 -> 2290;
2305 -> 2292;
2305 -> 2293;
2305 -> 2294;
2305 -> 2295;
2305 -> 2296;
2305 -> 2297;
2305 -> 2298;
2305 -> 2299;
2305 -> 2300;
2305 -> 2301;
2305 -> 2302;
2305 -> 2303;
2305 -> 2304;
2305 -> 2230;
2305 -> 2210;
2306 -> 2275;
2306 -> 2210;
2307 -> 2275;
2307 -> 2210;
2308 -> 2275;
2308 -> 2210;
2309 -> 2248;
2309 -> 2210;
2310 -> 2309;
2310 -> 2275;
2310 -> 2210;
2311 -> 2251;
2311 -> 2275;
2311 -> 2210;
2312 -> 2273;
2312 -> 2275;
2312 -> 2210;
2313 -> 2274;
2313 -> 2275;
2313 -> 2210;
2314 -> 2182;
2317 -> 2315;
2317 -> 2316;
2318 -> 1141;
2318 -> 2316;
2319 -> 2317;
2319 -> 2318;
2319 -> 1362;
2319 -> 1363;
2319 -> 1368;
2319 -> 2316;
2320 -> 2318;
2320 -> 2316;
2321 -> 2316;
2322 -> 2316;
2323 -> 2320;
2323 -> 2322;
2324 -> 2321;
2324 -> 2322;
2325 -> 2323;
2325 -> 1362;
2325 -> 2322;
2326 -> 2323;
2326 -> 1362;
2326 -> 2322;
2327 -> 2323;
2327 -> 1362;
2327 -> 2322;
2328 -> 2323;
2328 -> 1362;
2328 -> 2322;
2329 -> 2323;
2329 -> 1362;
2329 -> 1367;
2329 -> 2322;
2330 -> 2323;
2330 -> 1362;
2330 -> 2322;
2331 -> 2323;
2331 -> 1362;
2331 -> 2322;
2332 -> 2323;
2332 -> 1362;
2332 -> 1363;
2332 -> 1368;
2332 -> 2322;
2333 -> 2323;
2333 -> 1362;
2333 -> 2322;
2334 -> 2323;
2334 -> 1362;
2334 -> 2322;
2335 -> 2323;
2335 -> 1362;
2335 -> 2322;
2336 -> 2323;
2336 -> 1362;
2336 -> 2322;
2337 -> 2323;
2337 -> 1362;
2337 -> 2322;
2338 -> 2323;
2338 -> 1362;
2338 -> 2322;
2339 -> 2323;
2339 -> 1362;
2339 -> 2322;
2340 -> 2323;
2340 -> 1362;
2340 -> 2322;
2341 -> 2323;
2341 -> 1362;
2341 -> 2322;
2342 -> 2323;
2342 -> 1362;
2342 -> 2322;
2343 -> 2323;
2343 -> 1362;
2343 -> 2322;
2344 -> 2323;
2344 -> 1362;
2344 -> 1369;
2344 -> 2322;
2345 -> 2323;
2345 -> 1362;
2345 -> 2322;
2346 -> 2323;
2346 -> 1362;
2346 -> 2322;
2347 -> 2323;
2347 -> 1362;
2347 -> 2322;
2348 -> 2323;
2348 -> 1362;
2348 -> 2322;
2349 -> 2323;
2349 -> 1362;
2349 -> 2322;
2350 -> 2323;
2350 -> 1362;
2350 -> 2322;
2351 -> 2323;
2351 -> 1362;
2351 -> 2322;
2352 -> 2323;
2352 -> 1362;
2352 -> 2322;
2353 -> 2323;
2353 -> 1362;
2353 -> 2322;
2354 -> 2323;
2354 -> 1362;
2354 -> 2322;
2355 -> 2323;
2355 -> 1362;
2355 -> 1364;
2355 -> 1358;
2355 -> 2322;
2356 -> 2323;
2356 -> 1362;
2356 -> 1365;
2356 -> 1359;
2356 -> 2322;
2357 -> 2322;
2358 -> 2324;
2358 -> 2357;
2359 -> 2357;
2360 -> 2359;
2360 -> 2325;
2360 -> 2326;
2360 -> 2327;
2360 -> 2328;
2360 -> 2329;
2360 -> 2334;
2360 -> 2335;
2360 -> 2336;
2360 -> 2337;
2360 -> 2354;
2360 -> 2331;
2360 -> 2332;
2360 -> 2338;
2360 -> 2339;
2360 -> 2340;
2360 -> 2341;
2360 -> 2342;
2360 -> 2343;
2360 -> 2344;
2360 -> 2345;
2360 -> 2346;
2360 -> 2347;
2360 -> 2348;
2360 -> 2349;
2360 -> 2350;
2360 -> 2351;
2360 -> 2352;
2360 -> 2353;
2360 -> 1362;
2360 -> 1363;
2360 -> 1368;
2360 -> 1364;
2360 -> 1358;
2360 -> 1365;
2360 -> 1359;
2360 -> 1367;
2360 -> 1369;
2360 -> 1366;
2360 -> 2357;
2361 -> 2359;
2361 -> 2357;
2362 -> 2359;
2362 -> 2357;
2363 -> 2359;
2363 -> 2357;
2364 -> 2317;
2364 -> 2321;
2364 -> 2316;
2365 -> 2321;
2368 -> 2366;
2368 -> 2367;
2369 -> 1284;
2369 -> 2367;
2370 -> 2368;
2370 -> 2369;
2370 -> 1448;
2370 -> 1449;
2370 -> 1454;
2370 -> 2367;
2371 -> 2369;
2371 -> 2367;
2372 -> 2367;
2373 -> 2367;
2374 -> 2371;
2374 -> 2373;
2375 -> 2372;
2375 -> 2373;
2376 -> 2374;
2376 -> 1448;
2376 -> 2373;
2377 -> 2374;
2377 -> 1448;
2377 -> 2373;
2378 -> 2374;
2378 -> 1448;
2378 -> 2373;
2379 -> 2374;
2379 -> 1448;
2379 -> 2373;
2380 -> 2374;
2380 -> 1448;
2380 -> 1453;
2380 -> 2373;
2381 -> 2374;
2381 -> 1448;
2381 -> 2373;
2382 -> 2374;
2382 -> 1448;
2382 -> 2373;
2383 -> 2374;
2383 -> 1448;
2383 -> 1449;
2383 -> 1454;
2383 -> 2373;
2384 -> 2374;
2384 -> 1448;
2384 -> 2373;
2385 -> 2374;
2385 -> 1448;
2385 -> 2373;
2386 -> 2374;
2386 -> 1448;
2386 -> 2373;
2387 -> 2374;
2387 -> 1448;
2387 -> 2373;
2388 -> 2374;
2388 -> 1448;
2388 -> 2373;
2389 -> 2374;
2389 -> 1448;
2389 -> 2373;
2390 -> 2374;
2390 -> 1448;
2390 -> 2373;
2391 -> 2374;
2391 -> 1448;
2391 -> 2373;
2392 -> 2374;
2392 -> 1448;
2392 -> 2373;
2393 -> 2374;
2393 -> 1448;
2393 -> 2373;
2394 -> 2374;
2394 -> 1448;
2394 -> 2373;
2395 -> 2374;
2395 -> 1448;
2395 -> 1455;
2395 -> 2373;
2396 -> 2374;
2396 -> 1448;
2396 -> 2373;
2397 -> 2374;
2397 -> 1448;
2397 -> 2373;
2398 -> 2374;
2398 -> 1448;
2398 -> 2373;
2399 -> 2374;
2399 -> 1448;
2399 -> 2373;
2400 -> 2374;
2400 -> 1448;
2400 -> 2373;
2401 -> 2374;
2401 -> 1448;
2401 -> 2373;
2402 -> 2374;
2402 -> 1448;
2402 -> 2373;
2403 -> 2374;
2403 -> 1448;
2403 -> 2373;
2404 -> 2374;
2404 -> 1448;
2404 -> 2373;
2405 -> 2374;
2405 -> 1448;
2405 -> 2373;
2406 -> 2374;
2406 -> 1448;
2406 -> 1450;
2406 -> 1444;
2406 -> 2373;
2407 -> 2374;
2407 -> 1448;
2407 -> 1451;
2407 -> 1445;
2407 -> 2373;
2408 -> 2373;
2409 -> 2375;
2409 -> 2408;
2410 -> 2408;
2411 -> 2410;
2411 -> 2376;
2411 -> 2377;
2411 -> 2378;
2411 -> 2379;
2411 -> 2380;
2411 -> 2385;
2411 -> 2386;
2411 -> 2387;
2411 -> 2388;
2411 -> 2405;
2411 -> 2382;
2411 -> 2383;
2411 -> 2389;
2411 -> 2390;
2411 -> 2391;
2411 -> 2392;
2411 -> 2393;
2411 -> 2394;
2411 -> 2395;
2411 -> 2396;
2411 -> 2397;
2411 -> 2398;
2411 -> 2399;
2411 -> 2400;
2411 -> 2401;
2411 -> 2402;
2411 -> 2403;
2411 -> 2404;
2411 -> 1448;
2411 -> 1449;
2411 -> 1454;
2411 -> 1450;
2411 -> 1444;
2411 -> 1451;
2411 -> 1445;
2411 -> 1453;
2411 -> 1455;
2411 -> 1452;
2411 -> 2408;
2412 -> 2410;
2412 -> 2408;
2413 -> 2410;
2413 -> 2408;
2414 -> 2410;
2414 -> 2408;
2415 -> 2368;
2415 -> 2372;
2415 -> 2367;
2416 -> 2372;
2419 -> 2417;
2419 -> 2418;
2420 -> 1599;
2420 -> 2418;
2421 -> 2419;
2421 -> 2420;
2421 -> 1590;
2421 -> 1591;
2421 -> 1596;
2421 -> 2418;
2422 -> 2420;
2422 -> 2418;
2423 -> 2418;
2424 -> 2418;
2425 -> 2422;
2425 -> 2424;
2426 -> 2423;
2426 -> 2424;
2427 -> 2425;
2427 -> 1590;
2427 -> 2424;
2428 -> 2425;
2428 -> 1590;
2428 -> 2424;
2429 -> 2425;
2429 -> 1590;
2429 -> 2424;
2430 -> 2425;
2430 -> 1590;
2430 -> 2424;
2431 -> 2425;
2431 -> 1590;
2431 -> 1595;
2431 -> 2424;
2432 -> 2425;
2432 -> 1590;
2432 -> 2424;
2433 -> 2425;
2433 -> 1590;
2433 -> 2424;
2434 -> 2425;
2434 -> 1590;
2434 -> 1591;
2434 -> 1596;
2434 -> 2424;
2435 -> 2425;
2435 -> 1590;
2435 -> 2424;
2436 -> 2425;
2436 -> 1590;
2436 -> 2424;
2437 -> 2425;
2437 -> 1590;
2437 -> 2424;
2438 -> 2425;
2438 -> 1590;
2438 -> 2424;
2439 -> 2425;
2439 -> 1590;
2439 -> 2424;
2440 -> 2425;
2440 -> 1590;
2440 -> 2424;
2441 -> 2425;
2441 -> 1590;
2441 -> 2424;
2442 -> 2425;
2442 -> 1590;
2442 -> 2424;
2443 -> 2425;
2443 -> 1590;
2443 -> 2424;
2444 -> 2425;
2444 -> 1590;
2444 -> 2424;
2445 -> 2425;
2445 -> 1590;
2445 -> 2424;
2446 -> 2425;
2446 -> 1590;
2446 -> 2424;
2447 -> 2425;
2447 -> 1590;
2447 -> 2424;
2448 -> 2425;
2448 -> 1590;
2448 -> 2424;
2449 -> 2425;
2449 -> 1590;
2449 -> 2424;
2450 -> 2425;
2450 -> 1590;
2450 -> 2424;
2451 -> 2425;
2451 -> 1590;
2451 -> 2424;
2452 -> 2425;
2452 -> 1590;
2452 -> 2424;
2453 -> 2425;
2453 -> 1590;
2453 -> 2424;
2454 -> 2425;
2454 -> 1590;
2454 -> 2424;
2455 -> 2425;
2455 -> 1590;
2455 -> 2424;
2456 -> 2425;
2456 -> 1590;
2456 -> 2424;
2457 -> 2425;
2457 -> 1590;
2457 -> 1592;
2457 -> 1597;
2457 -> 2424;
2458 -> 2425;
2458 -> 1590;
2458 -> 1593;
2458 -> 1598;
2458 -> 2424;
2459 -> 2424;
2460 -> 2427;
2460 -> 2459;
2461 -> 2428;
2461 -> 2459;
2462 -> 2429;
2462 -> 2459;
2463 -> 2430;
2463 -> 2459;
2464 -> 2431;
2464 -> 2459;
2465 -> 2432;
2465 -> 2459;
2466 -> 2433;
2466 -> 2459;
2467 -> 2434;
2467 -> 2459;
2468 -> 2435;
2468 -> 2459;
2469 -> 2436;
2469 -> 2459;
2470 -> 2437;
2470 -> 2459;
2471 -> 2438;
2471 -> 2459;
2472 -> 2439;
2472 -> 2459;
2473 -> 2440;
2473 -> 2459;
2474 -> 2441;
2474 -> 2459;
2475 -> 2442;
2475 -> 2459;
2476 -> 2443;
2476 -> 2459;
2477 -> 2444;
2477 -> 2459;
2478 -> 2445;
2478 -> 2459;
2479 -> 2446;
2479 -> 2459;
2480 -> 2447;
2480 -> 2459;
2481 -> 2448;
2481 -> 2459;
2482 -> 2449;
2482 -> 2459;
2483 -> 2450;
2483 -> 2459;
2484 -> 2451;
2484 -> 2459;
2485 -> 2452;
2485 -> 2459;
2486 -> 2453;
2486 -> 2459;
2487 -> 2454;
2487 -> 2459;
2488 -> 2455;
2488 -> 2459;
2489 -> 2456;
2489 -> 2459;
2490 -> 2457;
2490 -> 2459;
2491 -> 2458;
2491 -> 2459;
2492 -> 2426;
2492 -> 2459;
2493 -> 2459;
2494 -> 2493;
2494 -> 2460;
2494 -> 2461;
2494 -> 2462;
2494 -> 2463;
2494 -> 2464;
2494 -> 2469;
2494 -> 2470;
2494 -> 2471;
2494 -> 2472;
2494 -> 2489;
2494 -> 2466;
2494 -> 2467;
2494 -> 2473;
2494 -> 2474;
2494 -> 2475;
2494 -> 2476;
2494 -> 2477;
2494 -> 2478;
2494 -> 2479;
2494 -> 2480;
2494 -> 2481;
2494 -> 2482;
2494 -> 2483;
2494 -> 2484;
2494 -> 2485;
2494 -> 2486;
2494 -> 2487;
2494 -> 2488;
2494 -> 1590;
2494 -> 1591;
2494 -> 1596;
2494 -> 1592;
2494 -> 1597;
2494 -> 1593;
2494 -> 1598;
2494 -> 1595;
2494 -> 1594;
2494 -> 2459;
2495 -> 2493;
2495 -> 2459;
2496 -> 2493;
2496 -> 2459;
2497 -> 2493;
2497 -> 2459;
2498 -> 2465;
2498 -> 2459;
2499 -> 2498;
2499 -> 2493;
2499 -> 2459;
2500 -> 2468;
2500 -> 2493;
2500 -> 2459;
2501 -> 2419;
2501 -> 2423;
2501 -> 2418;
2502 -> 2423;
2505 -> 2503;
2505 -> 2504;
2506 -> 1742;
2506 -> 2504;
2507 -> 2505;
2507 -> 2506;
2507 -> 1733;
2507 -> 1734;
2507 -> 1739;
2507 -> 2504;
2508 -> 2506;
2508 -> 2504;
2509 -> 2504;
2510 -> 2504;
2511 -> 2508;
2511 -> 2510;
2512 -> 2509;
2512 -> 2510;
2513 -> 2511;
2513 -> 1733;
2513 -> 2510;
2514 -> 2511;
2514 -> 1733;
2514 -> 2510;
2515 -> 2511;
2515 -> 1733;
2515 -> 2510;
2516 -> 2511;
2516 -> 1733;
2516 -> 2510;
2517 -> 2511;
2517 -> 1733;
2517 -> 1738;
2517 -> 2510;
2518 -> 2511;
2518 -> 1733;
2518 -> 2510;
2519 -> 2511;
2519 -> 1733;
2519 -> 2510;
2520 -> 2511;
2520 -> 1733;
2520 -> 1734;
2520 -> 1739;
2520 -> 2510;
2521 -> 2511;
2521 -> 1733;
2521 -> 2510;
2522 -> 2511;
2522 -> 1733;
2522 -> 2510;
2523 -> 2511;
2523 -> 1733;
2523 -> 2510;
2524 -> 2511;
2524 -> 1733;
2524 -> 2510;
2525 -> 2511;
2525 -> 1733;
2525 -> 2510;
2526 -> 2511;
2526 -> 1733;
2526 -> 2510;
2527 -> 2511;
2527 -> 1733;
2527 -> 2510;
2528 -> 2511;
2528 -> 1733;
2528 -> 2510;
2529 -> 2511;
2529 -> 1733;
2529 -> 2510;
2530 -> 2511;
2530 -> 1733;
2530 -> 2510;
2531 -> 2511;
2531 -> 1733;
2531 -> 2510;
2532 -> 2511;
2532 -> 1733;
2532 -> 2510;
2533 -> 2511;
2533 -> 1733;
2533 -> 2510;
2534 -> 2511;
2534 -> 1733;
2534 -> 2510;
2535 -> 2511;
2535 -> 1733;
2535 -> 2510;
2536 -> 2511;
2536 -> 1733;
2536 -> 2510;
2537 -> 2511;
2537 -> 1733;
2537 -> 2510;
2538 -> 2511;
2538 -> 1733;
2538 -> 2510;
2539 -> 2511;
2539 -> 1733;
2539 -> 2510;
2540 -> 2511;
2540 -> 1733;
2540 -> 2510;
2541 -> 2511;
2541 -> 1733;
2541 -> 2510;
2542 -> 2511;
2542 -> 1733;
2542 -> 2510;
2543 -> 2511;
2543 -> 1733;
2543 -> 1735;
2543 -> 1740;
2543 -> 2510;
2544 -> 2511;
2544 -> 1733;
2544 -> 1736;
2544 -> 1741;
2544 -> 2510;
2545 -> 2510;
2546 -> 2513;
2546 -> 2545;
2547 -> 2514;
2547 -> 2545;
2548 -> 2515;
2548 -> 2545;
2549 -> 2516;
2549 -> 2545;
2550 -> 2517;
2550 -> 2545;
2551 -> 2518;
2551 -> 2545;
2552 -> 2519;
2552 -> 2545;
2553 -> 2520;
2553 -> 2545;
2554 -> 2521;
2554 -> 2545;
2555 -> 2522;
2555 -> 2545;
2556 -> 2523;
2556 -> 2545;
2557 -> 2524;
2557 -> 2545;
2558 -> 2525;
2558 -> 2545;
2559 -> 2526;
2559 -> 2545;
2560 -> 2527;
2560 -> 2545;
2561 -> 2528;
2561 -> 2545;
2562 -> 2529;
2562 -> 2545;
2563 -> 2530;
2563 -> 2545;
2564 -> 2531;
2564 -> 2545;
2565 -> 2532;
2565 -> 2545;
2566 -> 2533;
2566 -> 2545;
2567 -> 2534;
2567 -> 2545;
2568 -> 2535;
2568 -> 2545;
2569 -> 2536;
2569 -> 2545;
2570 -> 2537;
2570 -> 2545;
2571 -> 2538;
2571 -> 2545;
2572 -> 2539;
2572 -> 2545;
2573 -> 2540;
2573 -> 2545;
2574 -> 2541;
2574 -> 2545;
2575 -> 2542;
2575 -> 2545;
2576 -> 2543;
2576 -> 2545;
2577 -> 2544;
2577 -> 2545;
2578 -> 2512;
2578 -> 2545;
2579 -> 2545;
2580 -> 2579;
2580 -> 2546;
2580 -> 2547;
2580 -> 2548;
2580 -> 2549;
2580 -> 2550;
2580 -> 2555;
2580 -> 2556;
2580 -> 2557;
2580 -> 2558;
2580 -> 2575;
2580 -> 2552;
2580 -> 2553;
2580 -> 2559;
2580 -> 2560;
2580 -> 2561;
2580 -> 2562;
2580 -> 2563;
2580 -> 2564;
2580 -> 2565;
2580 -> 2566;
2580 -> 2567;
2580 -> 2568;
2580 -> 2569;
2580 -> 2570;
2580 -> 2571;
2580 -> 2572;
2580 -> 2573;
2580 -> 2574;
2580 -> 1733;
2580 -> 1734;
2580 -> 1739;
2580 -> 1735;
2580 -> 1740;
2580 -> 1736;
2580 -> 1741;
2580 -> 1738;
2580 -> 1737;
2580 -> 2545;
2581 -> 2579;
2581 -> 2545;
2582 -> 2579;
2582 -> 2545;
2583 -> 2579;
2583 -> 2545;
2584 -> 2551;
2584 -> 2545;
2585 -> 2584;
2585 -> 2579;
2585 -> 2545;
2586 -> 2554;
2586 -> 2579;
2586 -> 2545;
2587 -> 2505;
2587 -> 2509;
2587 -> 2504;
2588 -> 2509;
2589 -> 0;
2591 -> 2589;
2591 -> 2590;
2592 -> 1141;
2592 -> 2590;
2593 -> 2591;
2593 -> 2590;
2594 -> 2592;
2594 -> 2360;
2594 -> 2590;
2595 -> 2593;
2595 -> 2594;
2595 -> 2590;
2596 -> 2592;
2596 -> 2590;
2597 -> 2590;
2598 -> 2590;
2599 -> 2596;
2599 -> 2598;
2600 -> 2597;
2600 -> 2598;
2601 -> 2599;
2601 -> 2360;
2601 -> 2598;
2602 -> 2599;
2602 -> 2360;
2602 -> 2598;
2603 -> 2599;
2603 -> 2360;
2603 -> 2598;
2604 -> 2599;
2604 -> 2360;
2604 -> 2598;
2605 -> 2599;
2605 -> 2360;
2605 -> 2330;
2605 -> 2598;
2606 -> 2599;
2606 -> 2360;
2606 -> 2598;
2607 -> 2599;
2607 -> 2360;
2607 -> 2598;
2608 -> 2599;
2608 -> 2360;
2608 -> 2361;
2608 -> 2333;
2608 -> 2364;
2608 -> 2598;
2609 -> 2599;
2609 -> 2360;
2609 -> 2598;
2610 -> 2599;
2610 -> 2360;
2610 -> 2598;
2611 -> 2599;
2611 -> 2360;
2611 -> 2598;
2612 -> 2599;
2612 -> 2360;
2612 -> 2598;
2613 -> 2599;
2613 -> 2360;
2613 -> 2598;
2614 -> 2599;
2614 -> 2360;
2614 -> 2598;
2615 -> 2599;
2615 -> 2360;
2615 -> 2598;
2616 -> 2599;
2616 -> 2360;
2616 -> 2598;
2617 -> 2599;
2617 -> 2360;
2617 -> 2598;
2618 -> 2599;
2618 -> 2360;
2618 -> 2598;
2619 -> 2599;
2619 -> 2360;
2619 -> 2598;
2620 -> 2599;
2620 -> 2360;
2620 -> 2598;
2621 -> 2599;
2621 -> 2360;
2621 -> 2598;
2622 -> 2599;
2622 -> 2360;
2622 -> 2598;
2623 -> 2599;
2623 -> 2360;
2623 -> 2598;
2624 -> 2599;
2624 -> 2360;
2624 -> 2598;
2625 -> 2599;
2625 -> 2360;
2625 -> 2598;
2626 -> 2599;
2626 -> 2360;
2626 -> 2598;
2627 -> 2599;
2627 -> 2360;
2627 -> 2598;
2628 -> 2599;
2628 -> 2360;
2628 -> 2598;
2629 -> 2599;
2629 -> 2360;
2629 -> 2598;
2630 -> 2599;
2630 -> 2360;
2630 -> 2598;
2631 -> 2599;
2631 -> 2360;
2631 -> 2362;
2631 -> 2355;
2631 -> 2598;
2632 -> 2599;
2632 -> 2360;
2632 -> 2363;
2632 -> 2356;
2632 -> 2598;
2633 -> 2598;
2634 -> 2600;
2634 -> 2633;
2635 -> 2633;
2636 -> 2635;
2636 -> 2633;
2637 -> 2635;
2637 -> 2633;
2638 -> 2635;
2638 -> 2633;
2639 -> 2591;
2639 -> 2597;
2639 -> 2590;
2640 -> 2597;
2641 -> 0;
2643 -> 2641;
2643 -> 2642;
2644 -> 1284;
2644 -> 2642;
2645 -> 2643;
2645 -> 2642;
2646 -> 2644;
2646 -> 2411;
2646 -> 2642;
2647 -> 2645;
2647 -> 2646;
2647 -> 2642;
2648 -> 2644;
2648 -> 2642;
2649 -> 2642;
2650 -> 2642;
2651 -> 2648;
2651 -> 2650;
2652 -> 2649;
2652 -> 2650;
2653 -> 2651;
2653 -> 2411;
2653 -> 2650;
2654 -> 2651;
2654 -> 2411;
2654 -> 2650;
2655 -> 2651;
2655 -> 2411;
2655 -> 2650;
2656 -> 2651;
2656 -> 2411;
2656 -> 2650;
2657 -> 2651;
2657 -> 2411;
2657 -> 2381;
2657 -> 2650;
2658 -> 2651;
2658 -> 2411;
2658 -> 2650;
2659 -> 2651;
2659 -> 2411;
2659 -> 2650;
2660 -> 2651;
2660 -> 2411;
2660 -> 2412;
2660 -> 2384;
2660 -> 2415;
2660 -> 2650;
2661 -> 2651;
2661 -> 2411;
2661 -> 2650;
2662 -> 2651;
2662 -> 2411;
2662 -> 2650;
2663 -> 2651;
2663 -> 2411;
2663 -> 2650;
2664 -> 2651;
2664 -> 2411;
2664 -> 2650;
2665 -> 2651;
2665 -> 2411;
2665 -> 2650;
2666 -> 2651;
2666 -> 2411;
2666 -> 2650;
2667 -> 2651;
2667 -> 2411;
2667 -> 2650;
2668 -> 2651;
2668 -> 2411;
2668 -> 2650;
2669 -> 2651;
2669 -> 2411;
2669 -> 2650;
2670 -> 2651;
2670 -> 2411;
2670 -> 2650;
2671 -> 2651;
2671 -> 2411;
2671 -> 2650;
2672 -> 2651;
2672 -> 2411;
2672 -> 2650;
2673 -> 2651;
2673 -> 2411;
2673 -> 2650;
2674 -> 2651;
2674 -> 2411;
2674 -> 2650;
2675 -> 2651;
2675 -> 2411;
2675 -> 2650;
2676 -> 2651;
2676 -> 2411;
2676 -> 2650;
2677 -> 2651;
2677 -> 2411;
2677 -> 2650;
2678 -> 2651;
2678 -> 2411;
2678 -> 2650;
2679 -> 2651;
2679 -> 2411;
2679 -> 2650;
2680 -> 2651;
2680 -> 2411;
2680 -> 2650;
2681 -> 2651;
2681 -> 2411;
2681 -> 2650;
2682 -> 2651;
2682 -> 2411;
2682 -> 2650;
2683 -> 2651;
2683 -> 2411;
2683 -> 2413;
2683 -> 2406;
2683 -> 2650;
2684 -> 2651;
2684 -> 2411;
2684 -> 2414;
2684 -> 2407;
2684 -> 2650;
2685 -> 2650;
2686 -> 2652;
2686 -> 2685;
2687 -> 2685;
2688 -> 2687;
2688 -> 2685;
2689 -> 2687;
2689 -> 2685;
2690 -> 2687;
2690 -> 2685;
2691 -> 2643;
2691 -> 2649;
2691 -> 2642;
2692 -> 2649;
2693 -> 0;
2695 -> 2693;
2695 -> 2694;
2696 -> 2171;
2696 -> 2694;
2697 -> 2695;
2697 -> 2694;
2698 -> 2696;
2698 -> 2162;
2698 -> 2694;
2699 -> 2697;
2699 -> 2698;
2699 -> 2694;
2700 -> 2696;
2700 -> 2694;
2701 -> 2694;
2702 -> 2694;
2703 -> 2700;
2703 -> 2702;
2704 -> 2701;
2704 -> 2702;
2705 -> 2703;
2705 -> 2162;
2705 -> 2702;
2706 -> 2703;
2706 -> 2162;
2706 -> 2702;
2707 -> 2703;
2707 -> 2162;
2707 -> 2702;
2708 -> 2703;
2708 -> 2162;
2708 -> 2702;
2709 -> 2703;
2709 -> 2162;
2709 -> 2167;
2709 -> 2702;
2710 -> 2703;
2710 -> 2162;
2710 -> 2702;
2711 -> 2703;
2711 -> 2162;
2711 -> 2702;
2712 -> 2703;
2712 -> 2162;
2712 -> 2163;
2712 -> 2168;
2712 -> 2702;
2713 -> 2703;
2713 -> 2162;
2713 -> 2702;
2714 -> 2703;
2714 -> 2162;
2714 -> 2702;
2715 -> 2703;
2715 -> 2162;
2715 -> 2702;
2716 -> 2703;
2716 -> 2162;
2716 -> 2702;
2717 -> 2703;
2717 -> 2162;
2717 -> 2702;
2718 -> 2703;
2718 -> 2162;
2718 -> 2702;
2719 -> 2703;
2719 -> 2162;
2719 -> 2702;
2720 -> 2703;
2720 -> 2162;
2720 -> 2702;
2721 -> 2703;
2721 -> 2162;
2721 -> 2702;
2722 -> 2703;
2722 -> 2162;
2722 -> 2702;
2723 -> 2703;
2723 -> 2162;
2723 -> 2702;
2724 -> 2703;
2724 -> 2162;
2724 -> 2702;
2725 -> 2703;
2725 -> 2162;
2725 -> 2702;
2726 -> 2703;
2726 -> 2162;
2726 -> 2702;
2727 -> 2703;
2727 -> 2162;
2727 -> 2702;
2728 -> 2703;
2728 -> 2162;
2728 -> 2702;
2729 -> 2703;
2729 -> 2162;
2729 -> 2702;
2730 -> 2703;
2730 -> 2162;
2730 -> 2702;
2731 -> 2703;
2731 -> 2162;
2731 -> 2702;
2732 -> 2703;
2732 -> 2162;
2732 -> 2702;
2733 -> 2703;
2733 -> 2162;
2733 -> 2702;
2734 -> 2703;
2734 -> 2162;
2734 -> 2702;
2735 -> 2703;
2735 -> 2162;
2735 -> 2164;
2735 -> 2169;
2735 -> 2702;
2736 -> 2703;
2736 -> 2162;
2736 -> 2165;
2736 -> 2170;
2736 -> 2702;
2737 -> 2702;
2738 -> 2705;
2738 -> 2737;
2739 -> 2706;
2739 -> 2737;
2740 -> 2707;
2740 -> 2737;
2741 -> 2708;
2741 -> 2737;
2742 -> 2709;
2742 -> 2737;
2743 -> 2710;
2743 -> 2737;
2744 -> 2711;
2744 -> 2737;
2745 -> 2712;
2745 -> 2737;
2746 -> 2713;
2746 -> 2737;
2747 -> 2714;
2747 -> 2737;
2748 -> 2715;
2748 -> 2737;
2749 -> 2716;
2749 -> 2737;
2750 -> 2717;
2750 -> 2737;
2751 -> 2718;
2751 -> 2737;
2752 -> 2719;
2752 -> 2737;
2753 -> 2720;
2753 -> 2737;
2754 -> 2721;
2754 -> 2737;
2755 -> 2722;
2755 -> 2737;
2756 -> 2723;
2756 -> 2737;
2757 -> 2724;
2757 -> 2737;
2758 -> 2725;
2758 -> 2737;
2759 -> 2726;
2759 -> 2737;
2760 -> 2727;
2760 -> 2737;
2761 -> 2728;
2761 -> 2737;
2762 -> 2729;
2762 -> 2737;
2763 -> 2730;
2763 -> 2737;
2764 -> 2731;
2764 -> 2737;
2765 -> 2732;
2765 -> 2737;
2766 -> 2733;
2766 -> 2737;
2767 -> 2734;
2767 -> 2737;
2768 -> 2735;
2768 -> 2737;
2769 -> 2736;
2769 -> 2737;
2770 -> 2704;
2770 -> 2737;
2771 -> 2737;
2772 -> 2771;
2772 -> 2738;
2772 -> 2739;
2772 -> 2740;
2772 -> 2741;
2772 -> 2742;
2772 -> 2747;
2772 -> 2748;
2772 -> 2749;
2772 -> 2750;
2772 -> 2767;
2772 -> 2744;
2772 -> 2745;
2772 -> 2751;
2772 -> 2752;
2772 -> 2753;
2772 -> 2754;
2772 -> 2755;
2772 -> 2756;
2772 -> 2757;
2772 -> 2758;
2772 -> 2759;
2772 -> 2760;
2772 -> 2761;
2772 -> 2762;
2772 -> 2763;
2772 -> 2764;
2772 -> 2765;
2772 -> 2766;
2772 -> 2162;
2772 -> 2163;
2772 -> 2168;
2772 -> 2164;
2772 -> 2169;
2772 -> 2165;
2772 -> 2170;
2772 -> 2167;
2772 -> 2166;
2772 -> 2737;
2773 -> 2771;
2773 -> 2737;
2774 -> 2771;
2774 -> 2737;
2775 -> 2771;
2775 -> 2737;
2776 -> 2743;
2776 -> 2737;
2777 -> 2776;
2777 -> 2771;
2777 -> 2737;
2778 -> 2746;
2778 -> 2771;
2778 -> 2737;
2779 -> 2695;
2779 -> 2701;
2779 -> 2694;
2780 -> 2701;
2781 -> 0;
2783 -> 2781;
2783 -> 2782;
2784 -> 1599;
2784 -> 2782;
2785 -> 2783;
2785 -> 2782;
2786 -> 2784;
2786 -> 2494;
2786 -> 2782;
2787 -> 2785;
2787 -> 2786;
2787 -> 2782;
2788 -> 2784;
2788 -> 2782;
2789 -> 2782;
2790 -> 2782;
2791 -> 2788;
2791 -> 2790;
2792 -> 2789;
2792 -> 2790;
2793 -> 2791;
2793 -> 2494;
2793 -> 2790;
2794 -> 2791;
2794 -> 2494;
2794 -> 2790;
2795 -> 2791;
2795 -> 2494;
2795 -> 2790;
2796 -> 2791;
2796 -> 2494;
2796 -> 2790;
2797 -> 2791;
2797 -> 2494;
2797 -> 2499;
2797 -> 2790;
2798 -> 2791;
2798 -> 2494;
2798 -> 2790;
2799 -> 2791;
2799 -> 2494;
2799 -> 2790;
2800 -> 2791;
2800 -> 2494;
2800 -> 2495;
2800 -> 2500;
2800 -> 2501;
2800 -> 2790;
2801 -> 2791;
2801 -> 2494;
2801 -> 2790;
2802 -> 2791;
2802 -> 2494;
2802 -> 2790;
2803 -> 2791;
2803 -> 2494;
2803 -> 2790;
2804 -> 2791;
2804 -> 2494;
2804 -> 2790;
2805 -> 2791;
2805 -> 2494;
2805 -> 2790;
2806 -> 2791;
2806 -> 2494;
2806 -> 2790;
2807 -> 2791;
2807 -> 2494;
2807 -> 2790;
2808 -> 2791;
2808 -> 2494;
2808 -> 2790;
2809 -> 2791;
2809 -> 2494;
2809 -> 2790;
2810 -> 2791;
2810 -> 2494;
2810 -> 2790;
2811 -> 2791;
2811 -> 2494;
2811 -> 2790;
2812 -> 2791;
2812 -> 2494;
2812 -> 2790;
2813 -> 2791;
2813 -> 2494;
2813 -> 2790;
2814 -> 2791;
2814 -> 2494;
2814 -> 2790;
2815 -> 2791;
2815 -> 2494;
2815 -> 2790;
2816 -> 2791;
2816 -> 2494;
2816 -> 2790;
2817 -> 2791;
2817 -> 2494;
2817 -> 2790;
2818 -> 2791;
2818 -> 2494;
2818 -> 2790;
2819 -> 2791;
2819 -> 2494;
2819 -> 2790;
2820 -> 2791;
2820 -> 2494;
2820 -> 2790;
2821 -> 2791;
2821 -> 2494;
2821 -> 2790;
2822 -> 2791;
2822 -> 2494;
2822 -> 2790;
2823 -> 2791;
2823 -> 2494;
2823 -> 2496;
2823 -> 2490;
2823 -> 2790;
2824 -> 2791;
2824 -> 2494;
2824 -> 2497;
2824 -> 2491;
2824 -> 2790;
2825 -> 2790;
2826 -> 2792;
2826 -> 2825;
2827 -> 2825;
2828 -> 2827;
2828 -> 2793;
2828 -> 2794;
2828 -> 2795;
2828 -> 2796;
2828 -> 2797;
2828 -> 2802;
2828 -> 2803;
2828 -> 2804;
2828 -> 2805;
2828 -> 2822;
2828 -> 2799;
2828 -> 2800;
2828 -> 2806;
2828 -> 2807;
2828 -> 2808;
2828 -> 2809;
2828 -> 2810;
2828 -> 2811;
2828 -> 2812;
2828 -> 2813;
2828 -> 2814;
2828 -> 2815;
2828 -> 2816;
2828 -> 2817;
2828 -> 2818;
2828 -> 2819;
2828 -> 2820;
2828 -> 2821;
2828 -> 2494;
2828 -> 2495;
2828 -> 2500;
2828 -> 2501;
2828 -> 2496;
2828 -> 2490;
2828 -> 2497;
2828 -> 2491;
2828 -> 2499;
2828 -> 2498;
2828 -> 2825;
2829 -> 2827;
2829 -> 2825;
2830 -> 2827;
2830 -> 2825;
2831 -> 2827;
2831 -> 2825;
2832 -> 2783;
2832 -> 2789;
2832 -> 2782;
2833 -> 2789;
2834 -> 0;
2835 -> 0;
2835 -> 2834;
2836 -> 2835;
2837 -> 362;
2837 -> 285;
2838 -> 280;
2838 -> 279;
2839 -> 0;
2839 -> 279;
2840 -> 2839;
2840 -> 283;
2840 -> 279;
2841 -> 279;
2842 -> 2838;
2842 -> 2840;
2842 -> 2841;
2842 -> 0;
2842 -> 279;
2844 -> 2843;
2845 -> 2844;
2847 -> 2845;
2847 -> 2846;
2848 -> 2846;
2849 -> 2846;
2850 -> 2847;
2850 -> 2846;
2851 -> 2848;
2851 -> 2850;
2852 -> 0;
2852 -> 2851;
2853 -> 2846;
2854 -> 2852;
2854 -> 2853;
2854 -> 2846;
2856 -> 0;
2856 -> 2846;
2857 -> 2847;
2857 -> 2846;
2858 -> 2846;
2859 -> 2856;
2859 -> 2858;
2860 -> 2857;
2860 -> 2858;
2861 -> 2859;
2861 -> 2858;
2862 -> 2860;
2862 -> 2858;
2863 -> 2858;
2864 -> 2858;
2865 -> 2861;
2865 -> 2864;
2866 -> 2862;
2866 -> 2864;
2867 -> 2863;
2867 -> 2864;
2868 -> 2863;
2868 -> 2864;
2869 -> 2863;
2869 -> 2864;
2870 -> 2865;
2870 -> 2864;
2871 -> 2867;
2871 -> 2864;
2872 -> 2868;
2872 -> 2864;
2874 -> 2873;
2875 -> 2866;
2875 -> 2864;
2876 -> 2864;
2877 -> 2870;
2877 -> 2876;
2878 -> 2871;
2878 -> 2876;
2879 -> 2872;
2879 -> 2876;
2880 -> 2875;
2880 -> 2876;
2881 -> 2869;
2881 -> 2876;
2882 -> 2877;
2882 -> 2876;
2883 -> 2878;
2883 -> 2876;
2884 -> 2879;
2884 -> 2876;
2885 -> 2880;
2885 -> 2876;
2886 -> 2876;
2887 -> 2886;
2887 -> 2882;
2887 -> 2883;
2887 -> 2884;
2887 -> 2885;
2887 -> 2876;
2888 -> 2886;
2888 -> 2876;
2889 -> 2888;
2889 -> 2887;
2889 -> 2876;
2890 -> 2869;
2890 -> 2864;
2891 -> 2866;
2891 -> 2869;
2891 -> 2864;
2892 -> 2865;
2892 -> 0;
2892 -> 2864;
2893 -> 2863;
2893 -> 2846;
2894 -> 2848;
2894 -> 2846;
2895 -> 2893;
2895 -> 2894;
2896 -> 2895;
2899 -> 2897;
2899 -> 2898;
2900 -> 2898;
2901 -> 2898;
2902 -> 2899;
2902 -> 2898;
2903 -> 2900;
2903 -> 2902;
2904 -> 0;
2904 -> 2903;
2905 -> 2898;
2906 -> 2904;
2906 -> 2905;
2906 -> 2898;
2907 -> 0;
2907 -> 2898;
2908 -> 2899;
2908 -> 2898;
2909 -> 2898;
2910 -> 2907;
2910 -> 2909;
2911 -> 2908;
2911 -> 2909;
2912 -> 2910;
2912 -> 2909;
2913 -> 2911;
2913 -> 2909;
2914 -> 2909;
2915 -> 2909;
2916 -> 2912;
2916 -> 2915;
2917 -> 2913;
2917 -> 2915;
2918 -> 2914;
2918 -> 2915;
2919 -> 2914;
2919 -> 2915;
2920 -> 2914;
2920 -> 2915;
2921 -> 2916;
2921 -> 2915;
2922 -> 2918;
2922 -> 2915;
2923 -> 2919;
2923 -> 2915;
2924 -> 2917;
2924 -> 2915;
2925 -> 2915;
2926 -> 2921;
2926 -> 2925;
2927 -> 2922;
2927 -> 2925;
2928 -> 2923;
2928 -> 2925;
2929 -> 2924;
2929 -> 2925;
2930 -> 2920;
2930 -> 2925;
2931 -> 2926;
2931 -> 2925;
2932 -> 2927;
2932 -> 2925;
2933 -> 2928;
2933 -> 2925;
2934 -> 2929;
2934 -> 2925;
2935 -> 2925;
2936 -> 2935;
2936 -> 2931;
2936 -> 2932;
2936 -> 2933;
2936 -> 2934;
2936 -> 2925;
2937 -> 2935;
2937 -> 2925;
2938 -> 2937;
2938 -> 2936;
2938 -> 2925;
2939 -> 2920;
2939 -> 2915;
2940 -> 2917;
2940 -> 2920;
2940 -> 2915;
2941 -> 2916;
2941 -> 0;
2941 -> 2915;
2942 -> 2914;
2942 -> 2898;
2943 -> 2900;
2943 -> 2898;
2944 -> 2942;
2944 -> 2943;
2945 -> 2944;
2948 -> 2946;
2948 -> 2947;
2949 -> 2947;
2950 -> 2947;
2951 -> 2948;
2951 -> 2947;
2952 -> 2949;
2952 -> 2951;
2953 -> 0;
2953 -> 2952;
2954 -> 2947;
2955 -> 2953;
2955 -> 2954;
2955 -> 2947;
2956 -> 0;
2956 -> 2947;
2957 -> 2948;
2957 -> 2947;
2958 -> 2947;
2959 -> 2956;
2959 -> 2958;
2960 -> 2957;
2960 -> 2958;
2961 -> 2959;
2961 -> 2958;
2962 -> 2960;
2962 -> 2958;
2963 -> 2958;
2964 -> 2958;
2965 -> 2961;
2965 -> 2964;
2966 -> 2962;
2966 -> 2964;
2967 -> 2963;
2967 -> 2964;
2968 -> 2963;
2968 -> 2964;
2969 -> 2963;
2969 -> 2964;
2970 -> 2965;
2970 -> 2964;
2971 -> 2967;
2971 -> 2964;
2972 -> 2968;
2972 -> 2964;
2973 -> 2966;
2973 -> 2964;
2974 -> 2964;
2975 -> 2970;
2975 -> 2974;
2976 -> 2971;
2976 -> 2974;
2977 -> 2972;
2977 -> 2974;
2978 -> 2973;
2978 -> 2974;
2979 -> 2969;
2979 -> 2974;
2980 -> 2975;
2980 -> 2974;
2981 -> 2976;
2981 -> 2974;
2982 -> 2977;
2982 -> 2974;
2983 -> 2978;
2983 -> 2974;
2984 -> 2974;
2985 -> 2984;
2985 -> 2980;
2985 -> 2981;
2985 -> 2982;
2985 -> 2983;
2985 -> 2974;
2986 -> 2984;
2986 -> 2974;
2987 -> 2986;
2987 -> 2985;
2987 -> 2974;
2988 -> 2969;
2988 -> 2964;
2989 -> 2966;
2989 -> 2969;
2989 -> 2964;
2990 -> 2965;
2990 -> 0;
2990 -> 2964;
2991 -> 2963;
2991 -> 2947;
2992 -> 2949;
2992 -> 2947;
2993 -> 2991;
2993 -> 2992;
2994 -> 2993;
2997 -> 2995;
2997 -> 2996;
2998 -> 2996;
2999 -> 0;
2999 -> 2996;
3000 -> 2997;
3000 -> 2996;
3001 -> 2996;
3002 -> 2999;
3002 -> 3001;
3003 -> 3000;
3003 -> 3001;
3004 -> 3002;
3004 -> 3001;
3005 -> 3003;
3005 -> 3001;
3006 -> 3001;
3007 -> 3001;
3008 -> 3004;
3008 -> 3007;
3009 -> 3005;
3009 -> 3007;
3010 -> 3006;
3010 -> 3007;
3011 -> 3006;
3011 -> 3007;
3012 -> 3006;
3012 -> 3007;
3013 -> 3008;
3013 -> 3007;
3014 -> 3010;
3014 -> 3007;
3015 -> 3011;
3015 -> 3007;
3016 -> 3009;
3016 -> 3007;
3017 -> 3007;
3018 -> 3013;
3018 -> 3017;
3019 -> 3014;
3019 -> 3017;
3020 -> 3015;
3020 -> 3017;
3021 -> 3016;
3021 -> 3017;
3022 -> 3012;
3022 -> 3017;
3023 -> 3018;
3023 -> 3017;
3024 -> 3019;
3024 -> 3017;
3025 -> 3020;
3025 -> 3017;
3026 -> 3021;
3026 -> 3017;
3027 -> 3017;
3028 -> 3027;
3028 -> 3023;
3028 -> 3024;
3028 -> 3025;
3028 -> 3026;
3028 -> 3017;
3029 -> 3027;
3029 -> 3017;
3030 -> 3029;
3030 -> 3028;
3030 -> 3017;
3031 -> 3012;
3031 -> 3007;
3032 -> 3009;
3032 -> 3012;
3032 -> 3007;
3033 -> 3008;
3033 -> 0;
3033 -> 3007;
3034 -> 3006;
3034 -> 2996;
3035 -> 2998;
3035 -> 2996;
3036 -> 3034;
3036 -> 3035;
3037 -> 3036;
3040 -> 3038;
3040 -> 3039;
3041 -> 3039;
3042 -> 0;
3042 -> 3039;
3043 -> 3040;
3043 -> 3039;
3044 -> 3039;
3045 -> 3042;
3045 -> 3044;
3046 -> 3043;
3046 -> 3044;
3047 -> 3045;
3047 -> 3044;
3048 -> 3046;
3048 -> 3044;
3049 -> 3044;
3050 -> 3044;
3051 -> 3047;
3051 -> 3050;
3052 -> 3048;
3052 -> 3050;
3053 -> 3049;
3053 -> 3050;
3054 -> 3049;
3054 -> 3050;
3055 -> 3049;
3055 -> 3050;
3056 -> 3051;
3056 -> 3050;
3057 -> 3053;
3057 -> 3050;
3058 -> 3054;
3058 -> 3050;
3059 -> 3052;
3059 -> 3050;
3060 -> 3050;
3061 -> 3056;
3061 -> 3060;
3062 -> 3057;
3062 -> 3060;
3063 -> 3058;
3063 -> 3060;
3064 -> 3059;
3064 -> 3060;
3065 -> 3055;
3065 -> 3060;
3066 -> 3061;
3066 -> 3060;
3067 -> 3062;
3067 -> 3060;
3068 -> 3063;
3068 -> 3060;
3069 -> 3064;
3069 -> 3060;
3070 -> 3060;
3071 -> 3070;
3071 -> 3066;
3071 -> 3067;
3071 -> 3068;
3071 -> 3069;
3071 -> 3060;
3072 -> 3070;
3072 -> 3060;
3073 -> 3072;
3073 -> 3071;
3073 -> 3060;
3074 -> 3055;
3074 -> 3050;
3075 -> 3052;
3075 -> 3055;
3075 -> 3050;
3076 -> 3051;
3076 -> 0;
3076 -> 3050;
3077 -> 3049;
3077 -> 3039;
3078 -> 3041;
3078 -> 3039;
3079 -> 3077;
3079 -> 3078;
3080 -> 3079;
3081 -> 2844;
3083 -> 3082;
3085 -> 3081;
3085 -> 3084;
3086 -> 3083;
3086 -> 3084;
3087 -> 3084;
3088 -> 3085;
3088 -> 3084;
3089 -> 3086;
3089 -> 3088;
3090 -> 0;
3090 -> 3089;
3091 -> 3084;
3092 -> 3090;
3092 -> 3091;
3092 -> 3084;
3093 -> 0;
3093 -> 3084;
3094 -> 3085;
3094 -> 3084;
3095 -> 3084;
3096 -> 3093;
3096 -> 3095;
3097 -> 3094;
3097 -> 3095;
3098 -> 3096;
3098 -> 3095;
3099 -> 3097;
3099 -> 3095;
3100 -> 3095;
3101 -> 3095;
3102 -> 3098;
3102 -> 3101;
3103 -> 3099;
3103 -> 3101;
3104 -> 3100;
3104 -> 3101;
3105 -> 3100;
3105 -> 3101;
3106 -> 3100;
3106 -> 3101;
3107 -> 3102;
3107 -> 3101;
3108 -> 3104;
3108 -> 3101;
3109 -> 3105;
3109 -> 3101;
3110 -> 3103;
3110 -> 3101;
3111 -> 3101;
3112 -> 3107;
3112 -> 3111;
3113 -> 3108;
3113 -> 3111;
3114 -> 3109;
3114 -> 3111;
3115 -> 3110;
3115 -> 3111;
3116 -> 3106;
3116 -> 3111;
3117 -> 3112;
3117 -> 3111;
3118 -> 3113;
3118 -> 3111;
3119 -> 3114;
3119 -> 3111;
3120 -> 3115;
3120 -> 3111;
3121 -> 3111;
3122 -> 3121;
3122 -> 3117;
3122 -> 3118;
3122 -> 3119;
3122 -> 3120;
3122 -> 3111;
3123 -> 3121;
3123 -> 3111;
3124 -> 3123;
3124 -> 3122;
3124 -> 3111;
3125 -> 3106;
3125 -> 3101;
3126 -> 3103;
3126 -> 3106;
3126 -> 3101;
3127 -> 3102;
3127 -> 0;
3127 -> 3101;
3128 -> 3100;
3128 -> 3084;
3129 -> 3086;
3129 -> 3084;
3130 -> 3128;
3130 -> 3084;
3131 -> 3084;
3132 -> 0;
3132 -> 3131;
3132 -> 3084;
3133 -> 3130;
3133 -> 3131;
3133 -> 3124;
3133 -> 3125;
3133 -> 3126;
3133 -> 3132;
3133 -> 0;
3133 -> 3084;
3134 -> 3133;
3134 -> 3131;
3135 -> 3133;
3135 -> 3131;
3136 -> 3131;
3137 -> 3135;
3137 -> 3136;
3138 -> 3137;
3138 -> 3133;
3138 -> 3136;
3139 -> 3138;
3139 -> 3131;
3140 -> 3135;
3140 -> 3133;
3140 -> 3131;
3141 -> 3134;
3141 -> 3131;
3142 -> 3131;
3143 -> 3131;
3144 -> 3139;
3144 -> 3143;
3145 -> 3140;
3145 -> 3143;
3146 -> 3140;
3146 -> 3143;
3147 -> 3141;
3147 -> 3143;
3148 -> 3142;
3148 -> 3143;
3149 -> 3143;
3150 -> 3148;
3150 -> 3149;
3151 -> 3149;
3152 -> 3151;
3152 -> 3144;
3152 -> 3146;
3152 -> 3147;
3152 -> 3145;
3152 -> 3140;
3152 -> 3149;
3153 -> 3151;
3153 -> 3149;
3154 -> 3148;
3154 -> 3143;
3155 -> 3144;
3155 -> 0;
3155 -> 3143;
3156 -> 3152;
3159 -> 3158;
3161 -> 3157;
3161 -> 3160;
3162 -> 3159;
3162 -> 3160;
3163 -> 3160;
3164 -> 3161;
3164 -> 3160;
3165 -> 3162;
3165 -> 3164;
3166 -> 0;
3166 -> 3165;
3167 -> 3160;
3168 -> 3166;
3168 -> 3167;
3168 -> 3160;
3169 -> 0;
3169 -> 3160;
3170 -> 3161;
3170 -> 3160;
3171 -> 3160;
3172 -> 3169;
3172 -> 3171;
3173 -> 3170;
3173 -> 3171;
3174 -> 3172;
3174 -> 3171;
3175 -> 3173;
3175 -> 3171;
3176 -> 3171;
3177 -> 3171;
3178 -> 3174;
3178 -> 3177;
3179 -> 3175;
3179 -> 3177;
3180 -> 3176;
3180 -> 3177;
3181 -> 3176;
3181 -> 3177;
3182 -> 3176;
3182 -> 3177;
3183 -> 3178;
3183 -> 3177;
3184 -> 3180;
3184 -> 3177;
3185 -> 3181;
3185 -> 3177;
3186 -> 3179;
3186 -> 3177;
3187 -> 3177;
3188 -> 3183;
3188 -> 3187;
3189 -> 3184;
3189 -> 3187;
3190 -> 3185;
3190 -> 3187;
3191 -> 3186;
3191 -> 3187;
3192 -> 3182;
3192 -> 3187;
3193 -> 3188;
3193 -> 3187;
3194 -> 3189;
3194 -> 3187;
3195 -> 3190;
3195 -> 3187;
3196 -> 3191;
3196 -> 3187;
3197 -> 3187;
3198 -> 3197;
3198 -> 3193;
3198 -> 3194;
3198 -> 3195;
3198 -> 3196;
3198 -> 3187;
3199 -> 3197;
3199 -> 3187;
3200 -> 3199;
3200 -> 3198;
3200 -> 3187;
3201 -> 3182;
3201 -> 3177;
3202 -> 3179;
3202 -> 3182;
3202 -> 3177;
3203 -> 3178;
3203 -> 0;
3203 -> 3177;
3204 -> 3176;
3204 -> 3160;
3205 -> 3162;
3205 -> 3160;
3206 -> 3204;
3206 -> 3160;
3207 -> 3160;
3208 -> 0;
3208 -> 3207;
3208 -> 3160;
3209 -> 3206;
3209 -> 3207;
3209 -> 3200;
3209 -> 3201;
3209 -> 3202;
3209 -> 3208;
3209 -> 3152;
3209 -> 3160;
3210 -> 3207;
3211 -> 3207;
3212 -> 3207;
3213 -> 3211;
3213 -> 3212;
3214 -> 3212;
3215 -> 3213;
3215 -> 3214;
3216 -> 3214;
3217 -> 3216;
3217 -> 3214;
3218 -> 3213;
3218 -> 3212;
3219 -> 3209;
3219 -> 0;
3219 -> 3212;
3220 -> 3209;
3223 -> 3222;
3225 -> 3221;
3225 -> 3224;
3226 -> 3223;
3226 -> 3224;
3227 -> 3224;
3228 -> 3225;
3228 -> 3224;
3229 -> 3226;
3229 -> 3228;
3230 -> 0;
3230 -> 3229;
3231 -> 3224;
3232 -> 3230;
3232 -> 3231;
3232 -> 3224;
3233 -> 0;
3233 -> 3224;
3234 -> 3225;
3234 -> 3224;
3235 -> 3224;
3236 -> 3233;
3236 -> 3235;
3237 -> 3234;
3237 -> 3235;
3238 -> 3236;
3238 -> 3235;
3239 -> 3237;
3239 -> 3235;
3240 -> 3235;
3241 -> 3235;
3242 -> 3238;
3242 -> 3241;
3243 -> 3239;
3243 -> 3241;
3244 -> 3240;
3244 -> 3241;
3245 -> 3240;
3245 -> 3241;
3246 -> 3240;
3246 -> 3241;
3247 -> 3242;
3247 -> 3241;
3248 -> 3244;
3248 -> 3241;
3249 -> 3245;
3249 -> 3241;
3250 -> 3243;
3250 -> 3241;
3251 -> 3241;
3252 -> 3247;
3252 -> 3251;
3253 -> 3248;
3253 -> 3251;
3254 -> 3249;
3254 -> 3251;
3255 -> 3250;
3255 -> 3251;
3256 -> 3246;
3256 -> 3251;
3257 -> 3252;
3257 -> 3251;
3258 -> 3253;
3258 -> 3251;
3259 -> 3254;
3259 -> 3251;
3260 -> 3255;
3260 -> 3251;
3261 -> 3251;
3262 -> 3261;
3262 -> 3257;
3262 -> 3258;
3262 -> 3259;
3262 -> 3260;
3262 -> 3251;
3263 -> 3261;
3263 -> 3251;
3264 -> 3263;
3264 -> 3262;
3264 -> 3251;
3265 -> 3246;
3265 -> 3241;
3266 -> 3243;
3266 -> 3246;
3266 -> 3241;
3267 -> 3242;
3267 -> 0;
3267 -> 3241;
3268 -> 3240;
3268 -> 3224;
3269 -> 3226;
3269 -> 3224;
3270 -> 3268;
3270 -> 3224;
3271 -> 3224;
3272 -> 0;
3272 -> 3271;
3272 -> 3224;
3273 -> 3270;
3273 -> 3271;
3273 -> 3264;
3273 -> 3265;
3273 -> 3266;
3273 -> 3272;
3273 -> 3209;
3273 -> 3224;
3274 -> 3271;
3275 -> 3271;
3276 -> 3271;
3277 -> 3275;
3277 -> 3276;
3278 -> 3276;
3279 -> 3277;
3279 -> 3278;
3280 -> 3278;
3281 -> 3280;
3281 -> 3278;
3282 -> 3277;
3282 -> 3276;
3283 -> 3273;
3283 -> 0;
3283 -> 3276;
3284 -> 3273;
3287 -> 3286;
3289 -> 3285;
3289 -> 3288;
3290 -> 3287;
3290 -> 3288;
3291 -> 0;
3291 -> 3288;
3292 -> 3289;
3292 -> 3288;
3293 -> 3288;
3294 -> 3291;
3294 -> 3293;
3295 -> 3292;
3295 -> 3293;
3296 -> 3294;
3296 -> 3293;
3297 -> 3295;
3297 -> 3293;
3298 -> 3293;
3299 -> 3293;
3300 -> 3296;
3300 -> 3299;
3301 -> 3297;
3301 -> 3299;
3302 -> 3298;
3302 -> 3299;
3303 -> 3298;
3303 -> 3299;
3304 -> 3298;
3304 -> 3299;
3305 -> 3300;
3305 -> 3299;
3306 -> 3302;
3306 -> 3299;
3307 -> 3303;
3307 -> 3299;
3308 -> 3301;
3308 -> 3299;
3309 -> 3299;
3310 -> 3305;
3310 -> 3309;
3311 -> 3306;
3311 -> 3309;
3312 -> 3307;
3312 -> 3309;
3313 -> 3308;
3313 -> 3309;
3314 -> 3304;
3314 -> 3309;
3315 -> 3310;
3315 -> 3309;
3316 -> 3311;
3316 -> 3309;
3317 -> 3312;
3317 -> 3309;
3318 -> 3313;
3318 -> 3309;
3319 -> 3309;
3320 -> 3319;
3320 -> 3315;
3320 -> 3316;
3320 -> 3317;
3320 -> 3318;
3320 -> 3309;
3321 -> 3319;
3321 -> 3309;
3322 -> 3321;
3322 -> 3320;
3322 -> 3309;
3323 -> 3304;
3323 -> 3299;
3324 -> 3301;
3324 -> 3304;
3324 -> 3299;
3325 -> 3300;
3325 -> 0;
3325 -> 3299;
3326 -> 3298;
3326 -> 3288;
3327 -> 3290;
3327 -> 3288;
3328 -> 3326;
3328 -> 3288;
3329 -> 3288;
3330 -> 0;
3330 -> 3329;
3330 -> 3288;
3331 -> 3328;
3331 -> 3329;
3331 -> 3322;
3331 -> 3323;
3331 -> 3324;
3331 -> 3330;
3331 -> 3273;
3331 -> 3288;
3332 -> 3329;
3333 -> 3329;
3334 -> 3329;
3335 -> 3333;
3335 -> 3334;
3336 -> 3334;
3337 -> 3335;
3337 -> 3336;
3338 -> 3336;
3339 -> 3338;
3339 -> 3336;
3340 -> 3335;
3340 -> 3334;
3341 -> 3331;
3341 -> 0;
3341 -> 3334;
3342 -> 3331;
3345 -> 3344;
3347 -> 3343;
3347 -> 3346;
3348 -> 3345;
3348 -> 3346;
3349 -> 0;
3349 -> 3346;
3350 -> 3347;
3350 -> 3346;
3351 -> 3346;
3352 -> 3349;
3352 -> 3351;
3353 -> 3350;
3353 -> 3351;
3354 -> 3352;
3354 -> 3351;
3355 -> 3353;
3355 -> 3351;
3356 -> 3351;
3357 -> 3351;
3358 -> 3354;
3358 -> 3357;
3359 -> 3355;
3359 -> 3357;
3360 -> 3356;
3360 -> 3357;
3361 -> 3356;
3361 -> 3357;
3362 -> 3356;
3362 -> 3357;
3363 -> 3358;
3363 -> 3357;
3364 -> 3360;
3364 -> 3357;
3365 -> 3361;
3365 -> 3357;
3366 -> 3359;
3366 -> 3357;
3367 -> 3357;
3368 -> 3363;
3368 -> 3367;
3369 -> 3364;
3369 -> 3367;
3370 -> 3365;
3370 -> 3367;
3371 -> 3366;
3371 -> 3367;
3372 -> 3362;
3372 -> 3367;
3373 -> 3368;
3373 -> 3367;
3374 -> 3369;
3374 -> 3367;
3375 -> 3370;
3375 -> 3367;
3376 -> 3371;
3376 -> 3367;
3377 -> 3367;
3378 -> 3377;
3378 -> 3373;
3378 -> 3374;
3378 -> 3375;
3378 -> 3376;
3378 -> 3367;
3379 -> 3377;
3379 -> 3367;
3380 -> 3379;
3380 -> 3378;
3380 -> 3367;
3381 -> 3362;
3381 -> 3357;
3382 -> 3359;
3382 -> 3362;
3382 -> 3357;
3383 -> 3358;
3383 -> 0;
3383 -> 3357;
3384 -> 3356;
3384 -> 3346;
3385 -> 3348;
3385 -> 3346;
3386 -> 3384;
3386 -> 3346;
3387 -> 3346;
3388 -> 0;
3388 -> 3387;
3388 -> 3346;
3389 -> 3386;
3389 -> 3387;
3389 -> 3380;
3389 -> 3381;
3389 -> 3382;
3389 -> 3388;
3389 -> 3331;
3389 -> 3346;
3390 -> 3387;
3391 -> 3387;
3392 -> 3387;
3393 -> 3391;
3393 -> 3392;
3394 -> 3392;
3395 -> 3393;
3395 -> 3394;
3396 -> 3394;
3397 -> 3396;
3397 -> 3394;
3398 -> 3393;
3398 -> 3392;
3399 -> 3389;
3399 -> 0;
3399 -> 3392;
3400 -> 3389;
3401 -> 0;
3403 -> 3402;
3405 -> 3401;
3405 -> 3404;
3406 -> 3403;
3406 -> 3404;
3407 -> 0;
3407 -> 3404;
3408 -> 3405;
3408 -> 3404;
3409 -> 3404;
3410 -> 3407;
3410 -> 3409;
3411 -> 3408;
3411 -> 3409;
3412 -> 3410;
3412 -> 3409;
3413 -> 3411;
3413 -> 3409;
3414 -> 3409;
3415 -> 3409;
3416 -> 3412;
3416 -> 3415;
3417 -> 3413;
3417 -> 3415;
3418 -> 3414;
3418 -> 3415;
3419 -> 3414;
3419 -> 3415;
3420 -> 3414;
3420 -> 3415;
3421 -> 3416;
3421 -> 3415;
3422 -> 3418;
3422 -> 3415;
3423 -> 3419;
3423 -> 3415;
3424 -> 3417;
3424 -> 3415;
3425 -> 3415;
3426 -> 3421;
3426 -> 3425;
3427 -> 3422;
3427 -> 3425;
3428 -> 3423;
3428 -> 3425;
3429 -> 3424;
3429 -> 3425;
3430 -> 3420;
3430 -> 3425;
3431 -> 3426;
3431 -> 3425;
3432 -> 3427;
3432 -> 3425;
3433 -> 3428;
3433 -> 3425;
3434 -> 3429;
3434 -> 3425;
3435 -> 3425;
3436 -> 3435;
3436 -> 3431;
3436 -> 3432;
3436 -> 3433;
3436 -> 3434;
3436 -> 3425;
3437 -> 3435;
3437 -> 3425;
3438 -> 3437;
3438 -> 3436;
3438 -> 3425;
3439 -> 3420;
3439 -> 3415;
3440 -> 3417;
3440 -> 3420;
3440 -> 3415;
3441 -> 3416;
3441 -> 0;
3441 -> 3415;
3442 -> 3414;
3442 -> 3404;
3443 -> 3406;
3443 -> 3404;
3444 -> 3442;
3444 -> 3404;
3445 -> 3404;
3446 -> 0;
3446 -> 3445;
3446 -> 3404;
3447 -> 3444;
3447 -> 3445;
3447 -> 3438;
3447 -> 3439;
3447 -> 3440;
3447 -> 3446;
3447 -> 3389;
3447 -> 3404;
3448 -> 3445;
3449 -> 3445;
3450 -> 3445;
3451 -> 3449;
3451 -> 3450;
3452 -> 3450;
3453 -> 3451;
3453 -> 3452;
3454 -> 3452;
3455 -> 3454;
3455 -> 3452;
3456 -> 3451;
3456 -> 3450;
3457 -> 3447;
3457 -> 0;
3457 -> 3450;
3458 -> 3447;
3461 -> 2896;
3461 -> 3460;
3462 -> 3460;
3463 -> 3461;
3463 -> 3460;
3464 -> 3462;
3464 -> 3463;
3464 -> 2889;
3464 -> 2890;
3464 -> 2891;
3464 -> 3460;
3466 -> 2945;
3466 -> 3465;
3467 -> 3465;
3468 -> 3466;
3468 -> 3465;
3469 -> 3467;
3469 -> 3468;
3469 -> 2938;
3469 -> 2939;
3469 -> 2940;
3469 -> 3465;
3471 -> 2994;
3471 -> 3470;
3472 -> 3470;
3473 -> 3471;
3473 -> 3470;
3474 -> 3472;
3474 -> 3473;
3474 -> 2987;
3474 -> 2988;
3474 -> 2989;
3474 -> 3470;
3476 -> 3037;
3476 -> 3475;
3477 -> 3475;
3478 -> 3476;
3478 -> 3475;
3479 -> 3477;
3479 -> 3478;
3479 -> 3030;
3479 -> 3031;
3479 -> 3032;
3479 -> 3475;
3481 -> 3080;
3481 -> 3480;
3482 -> 3480;
3483 -> 3481;
3483 -> 3480;
3484 -> 3482;
3484 -> 3483;
3484 -> 3073;
3484 -> 3074;
3484 -> 3075;
3484 -> 3480;
3486 -> 3156;
3486 -> 3485;
3487 -> 3485;
3488 -> 3486;
3488 -> 3485;
3489 -> 3487;
3489 -> 3488;
3489 -> 3447;
3489 -> 3485;
3491 -> 3220;
3491 -> 3490;
3492 -> 3490;
3493 -> 3491;
3493 -> 3490;
3494 -> 3492;
3494 -> 3493;
3494 -> 3489;
3494 -> 3490;
3496 -> 3284;
3496 -> 3495;
3497 -> 3495;
3498 -> 3496;
3498 -> 3495;
3499 -> 3497;
3499 -> 3498;
3499 -> 3494;
3499 -> 3495;
3501 -> 3342;
3501 -> 3500;
3502 -> 3500;
3503 -> 3501;
3503 -> 3500;
3504 -> 3502;
3504 -> 3503;
3504 -> 3499;
3504 -> 3500;
3506 -> 3400;
3506 -> 3505;
3507 -> 3505;
3508 -> 3506;
3508 -> 3505;
3509 -> 3507;
3509 -> 3508;
3509 -> 3504;
3509 -> 3505;
3511 -> 3458;
3511 -> 3510;
3512 -> 3510;
3513 -> 3511;
3513 -> 3510;
3514 -> 3512;
3514 -> 3513;
3514 -> 3509;
3514 -> 3510;
3515 -> 2842;
3515 -> 279;
3516 -> 2837;
3516 -> 279;
3517 -> 281;
3517 -> 279;
3518 -> 279;
3519 -> 279;
3520 -> 3515;
3520 -> 3519;
3521 -> 3516;
3521 -> 3519;
3522 -> 3517;
3522 -> 3519;
3523 -> 3518;
3523 -> 3519;
3525 -> 3524;
3526 -> 3525;
3527 -> 3526;
3527 -> 3525;
3528 -> 3526;
3528 -> 3525;
3529 -> 3526;
3529 -> 3525;
3530 -> 3526;
3530 -> 3525;
3531 -> 0;
3531 -> 3526;
3531 -> 3525;
3532 -> 3525;
3532 -> 3524;
3533 -> 0;
3533 -> 3524;
3534 -> 3524;
3535 -> 3524;
3536 -> 3533;
3536 -> 3535;
3537 -> 3534;
3537 -> 3535;
3538 -> 3534;
3538 -> 3535;
3539 -> 3536;
3539 -> 3535;
3540 -> 3537;
3540 -> 3535;
3541 -> 3538;
3541 -> 3535;
3542 -> 3535;
3543 -> 3539;
3543 -> 3542;
3544 -> 3540;
3544 -> 3542;
3545 -> 3541;
3545 -> 3542;
3546 -> 3543;
3546 -> 3542;
3547 -> 3544;
3547 -> 3542;
3548 -> 3542;
3549 -> 3546;
3549 -> 3548;
3550 -> 3547;
3550 -> 3548;
3551 -> 3549;
3551 -> 3548;
3552 -> 0;
3552 -> 3548;
3553 -> 3548;
3554 -> 3551;
3554 -> 3552;
3554 -> 3553;
3554 -> 2842;
3554 -> 3548;
3555 -> 3550;
3555 -> 3548;
3556 -> 3554;
3556 -> 3555;
3556 -> 3548;
3558 -> 3557;
3561 -> 3560;
3563 -> 3562;
3574 -> 3565;
3574 -> 3564;
3575 -> 3566;
3575 -> 3564;
3576 -> 3567;
3576 -> 3564;
3577 -> 3568;
3577 -> 3564;
3578 -> 3569;
3578 -> 3564;
3579 -> 3570;
3579 -> 3564;
3580 -> 3571;
3580 -> 3564;
3581 -> 3572;
3581 -> 3564;
3582 -> 3573;
3582 -> 3564;
3583 -> 3564;
3585 -> 3584;
3586 -> 322;
3586 -> 3542;
3587 -> 3586;
3587 -> 3545;
3587 -> 3542;
3588 -> 3542;
3589 -> 3542;
3590 -> 3556;
3590 -> 3589;
3591 -> 3587;
3591 -> 3589;
3592 -> 3588;
3592 -> 3589;
3593 -> 3588;
3593 -> 3589;
3594 -> 3588;
3594 -> 3589;
3595 -> 3590;
3595 -> 3589;
3596 -> 3589;
3597 -> 3595;
3597 -> 3596;
3598 -> 3594;
3598 -> 3596;
3599 -> 3598;
3599 -> 3596;
3600 -> 3598;
3600 -> 3596;
3601 -> 0;
3603 -> 3602;
3605 -> 3604;
3606 -> 3605;
3607 -> 3597;
3607 -> 3596;
3608 -> 3596;
3609 -> 3596;
3610 -> 3607;
3610 -> 3609;
3611 -> 3608;
3611 -> 3609;
3612 -> 3611;
3612 -> 3609;
3613 -> 3611;
3613 -> 3609;
3614 -> 3611;
3614 -> 3609;
3615 -> 3611;
3615 -> 3609;
3616 -> 3611;
3616 -> 3609;
3617 -> 3611;
3617 -> 3609;
3618 -> 3611;
3618 -> 3609;
3619 -> 3611;
3619 -> 3609;
3620 -> 3610;
3620 -> 3611;
3620 -> 3609;
3621 -> 3609;
3622 -> 3621;
3622 -> 3611;
3622 -> 3609;
3623 -> 3609;
3624 -> 3623;
3624 -> 3611;
3624 -> 3609;
3625 -> 3610;
3625 -> 3556;
3625 -> 3611;
3625 -> 3609;
3626 -> 3609;
3627 -> 3626;
3627 -> 3611;
3627 -> 3609;
3628 -> 3606;
3628 -> 3605;
3628 -> 3609;
3629 -> 3628;
3629 -> 3611;
3629 -> 3609;
3630 -> 3609;
3631 -> 3630;
3631 -> 3611;
3631 -> 3609;
3632 -> 3608;
3632 -> 3598;
3632 -> 3596;
3633 -> 3594;
3633 -> 3589;
3634 -> 3594;
3634 -> 3589;
3635 -> 3594;
3635 -> 3589;
3636 -> 3594;
3636 -> 3589;
3637 -> 3594;
3637 -> 3589;
3638 -> 3594;
3638 -> 3589;
3639 -> 3594;
3639 -> 3589;
3640 -> 3594;
3640 -> 3589;
3641 -> 3594;
3641 -> 3589;
3642 -> 3594;
3642 -> 3589;
3643 -> 3589;
3644 -> 3643;
3644 -> 3589;
3645 -> 3644;
3645 -> 3594;
3645 -> 3589;
3646 -> 3589;
3647 -> 3646;
3647 -> 3589;
3648 -> 3647;
3648 -> 3594;
3648 -> 3589;
3649 -> 3594;
3649 -> 3589;
3650 -> 3594;
3650 -> 3589;
3651 -> 3589;
3652 -> 3591;
3652 -> 3651;
3652 -> 3589;
3653 -> 3591;
3653 -> 3594;
3653 -> 3589;
3654 -> 3589;
3655 -> 3654;
3655 -> 3594;
3655 -> 3589;
3656 -> 3589;
3657 -> 3656;
3657 -> 3594;
3657 -> 3589;
3660 -> 3658;
3660 -> 3659;
3661 -> 3660;
3663 -> 3662;
3664 -> 3589;
3665 -> 3589;
3666 -> 3664;
3666 -> 3665;
3667 -> 3666;
3667 -> 3665;
3668 -> 3666;
3668 -> 3665;
3669 -> 3666;
3669 -> 3665;
3670 -> 3665;
3671 -> 3670;
3671 -> 3666;
3671 -> 3665;
3672 -> 3665;
3673 -> 3672;
3673 -> 3666;
3673 -> 3665;
3674 -> 3661;
3674 -> 3660;
3674 -> 3665;
3675 -> 3674;
3675 -> 3666;
3675 -> 3665;
3676 -> 3664;
3676 -> 3594;
3676 -> 3589;
3677 -> 3594;
3677 -> 3589;
3678 -> 3592;
3678 -> 3594;
3678 -> 3589;
3679 -> 3593;
3679 -> 3594;
3679 -> 3589;
3680 -> 3588;
3680 -> 3535;
3681 -> 3680;
3681 -> 3535;
3682 -> 3535;
3683 -> 3681;
3683 -> 3682;
3684 -> 0;
3685 -> 3683;
3685 -> 3682;
3686 -> 3682;
3687 -> 3682;
3688 -> 3685;
3688 -> 3687;
3689 -> 3686;
3689 -> 3687;
3690 -> 3686;
3690 -> 3687;
3691 -> 3686;
3691 -> 3687;
3692 -> 3686;
3692 -> 3687;
3693 -> 3686;
3693 -> 3687;
3696 -> 3694;
3696 -> 3695;
3697 -> 3696;
3698 -> 3688;
3698 -> 3687;
3699 -> 3691;
3699 -> 3687;
3700 -> 3689;
3700 -> 3687;
3701 -> 3690;
3701 -> 3687;
3702 -> 3687;
3703 -> 3687;
3704 -> 3692;
3704 -> 3687;
3705 -> 3687;
3706 -> 3698;
3706 -> 3705;
3707 -> 3699;
3707 -> 3705;
3708 -> 3700;
3708 -> 3705;
3709 -> 3701;
3709 -> 3705;
3710 -> 3702;
3710 -> 3705;
3711 -> 3703;
3711 -> 3705;
3712 -> 3704;
3712 -> 3705;
3713 -> 3693;
3713 -> 3705;
3714 -> 3713;
3714 -> 3705;
3715 -> 3713;
3715 -> 3705;
3716 -> 3713;
3716 -> 3705;
3717 -> 3713;
3717 -> 3705;
3718 -> 3713;
3718 -> 3705;
3719 -> 3713;
3719 -> 3705;
3720 -> 3713;
3720 -> 3705;
3721 -> 3713;
3721 -> 3705;
3722 -> 3713;
3722 -> 3705;
3723 -> 3713;
3723 -> 3705;
3724 -> 3713;
3724 -> 3705;
3725 -> 3713;
3725 -> 3705;
3726 -> 3713;
3726 -> 3705;
3727 -> 3706;
3727 -> 3713;
3727 -> 3705;
3728 -> 3707;
3728 -> 3713;
3728 -> 3705;
3729 -> 3710;
3729 -> 3713;
3729 -> 3705;
3730 -> 3712;
3730 -> 3713;
3730 -> 3705;
3731 -> 3705;
3732 -> 3731;
3732 -> 3713;
3732 -> 3705;
3733 -> 3705;
3734 -> 3708;
3734 -> 3733;
3734 -> 3705;
3735 -> 3734;
3735 -> 3713;
3735 -> 3705;
3736 -> 3705;
3737 -> 3713;
3737 -> 3736;
3738 -> 3737;
3738 -> 3735;
3738 -> 3736;
3739 -> 3738;
3739 -> 3705;
3740 -> 3739;
3740 -> 3710;
3740 -> 3705;
3741 -> 3740;
3742 -> 3741;
3742 -> 3713;
3742 -> 3740;
3743 -> 3740;
3744 -> 3743;
3744 -> 3713;
3744 -> 3740;
3745 -> 3705;
3746 -> 3713;
3746 -> 3745;
3747 -> 3746;
3747 -> 3735;
3747 -> 3745;
3748 -> 3747;
3748 -> 3705;
3749 -> 3711;
3749 -> 3748;
3749 -> 3705;
3750 -> 3749;
3750 -> 3712;
3750 -> 3686;
3750 -> 3705;
3751 -> 3750;
3752 -> 3713;
3752 -> 3751;
3753 -> 3751;
3754 -> 3751;
3755 -> 3752;
3755 -> 3727;
3755 -> 3632;
3755 -> 3754;
3756 -> 3755;
3756 -> 3620;
3756 -> 3754;
3757 -> 3756;
3757 -> 3751;
3758 -> 3757;
3758 -> 3751;
3759 -> 3758;
3759 -> 3752;
3759 -> 3751;
3760 -> 3752;
3760 -> 3727;
3760 -> 3751;
3761 -> 3752;
3761 -> 3728;
3761 -> 3751;
3762 -> 3751;
3763 -> 3762;
3763 -> 3757;
3763 -> 3751;
3764 -> 3761;
3764 -> 3763;
3765 -> 3763;
3766 -> 3764;
3766 -> 3765;
3767 -> 3760;
3767 -> 3765;
3768 -> 3559;
3768 -> 3765;
3769 -> 3766;
3769 -> 3767;
3769 -> 3765;
3770 -> 3767;
3770 -> 3769;
3770 -> 3765;
3771 -> 3767;
3771 -> 3632;
3771 -> 3600;
3771 -> 3653;
3771 -> 3769;
3771 -> 3655;
3771 -> 3657;
3771 -> 3637;
3771 -> 3676;
3771 -> 3678;
3771 -> 3679;
3771 -> 3641;
3771 -> 3642;
3771 -> 3645;
3771 -> 3648;
3771 -> 3649;
3771 -> 3677;
3771 -> 3620;
3771 -> 3622;
3771 -> 3624;
3771 -> 3625;
3771 -> 3629;
3771 -> 3617;
3771 -> 3631;
3771 -> 3627;
3771 -> 3556;
3771 -> 3644;
3771 -> 3647;
3771 -> 306;
3771 -> 307;
3771 -> 321;
3771 -> 308;
3771 -> 316;
3771 -> 309;
3771 -> 310;
3771 -> 318;
3771 -> 992;
3771 -> 317;
3771 -> 3654;
3771 -> 3656;
3771 -> 3671;
3771 -> 3673;
3771 -> 3675;
3771 -> 3674;
3771 -> 3672;
3771 -> 3670;
3771 -> 3626;
3771 -> 3628;
3771 -> 3770;
3772 -> 3770;
3773 -> 3771;
3773 -> 3772;
3774 -> 3772;
3775 -> 3773;
3775 -> 3771;
3775 -> 3774;
3776 -> 3775;
3776 -> 3771;
3776 -> 3774;
3777 -> 3772;
3778 -> 3772;
3779 -> 3778;
3779 -> 3773;
3779 -> 3772;
3780 -> 3771;
3780 -> 3772;
3781 -> 3780;
3781 -> 3771;
3781 -> 3772;
3782 -> 3771;
3782 -> 3781;
3782 -> 3776;
3782 -> 3779;
3782 -> 3770;
3783 -> 3771;
3783 -> 3772;
3784 -> 3783;
3784 -> 3782;
3784 -> 3772;
3785 -> 3771;
3785 -> 3772;
3786 -> 3785;
3786 -> 3784;
3786 -> 3772;
3787 -> 3771;
3787 -> 3772;
3788 -> 3771;
3788 -> 3772;
3789 -> 3788;
3789 -> 3786;
3789 -> 3787;
3789 -> 3772;
3790 -> 3789;
3790 -> 3788;
3790 -> 3772;
3791 -> 3771;
3791 -> 3772;
3792 -> 3791;
3792 -> 3786;
3792 -> 3772;
3793 -> 3771;
3793 -> 3792;
3793 -> 3786;
3793 -> 3790;
3793 -> 3770;
3794 -> 3771;
3794 -> 3772;
3795 -> 3771;
3795 -> 3772;
3796 -> 3794;
3796 -> 3795;
3796 -> 3793;
3796 -> 3772;
3797 -> 3772;
3798 -> 3796;
3798 -> 3797;
3798 -> 3772;
3799 -> 3796;
3799 -> 3795;
3799 -> 3793;
3799 -> 3772;
3800 -> 3796;
3800 -> 3795;
3800 -> 3798;
3801 -> 3770;
3802 -> 3767;
3802 -> 3801;
3803 -> 3802;
3803 -> 3800;
3803 -> 3801;
3804 -> 3801;
3805 -> 3802;
3805 -> 3803;
3805 -> 3804;
3806 -> 3805;
3806 -> 3803;
3806 -> 3804;
3807 -> 3806;
3807 -> 3801;
3808 -> 3801;
3809 -> 3802;
3809 -> 3803;
3809 -> 3801;
3810 -> 3801;
3811 -> 3807;
3811 -> 3810;
3812 -> 3808;
3812 -> 3810;
3813 -> 3809;
3813 -> 3810;
3814 -> 3802;
3814 -> 3810;
3815 -> 3812;
3815 -> 3810;
3816 -> 3810;
3817 -> 3816;
3818 -> 3814;
3818 -> 3817;
3819 -> 3817;
3820 -> 3818;
3820 -> 3803;
3820 -> 3819;
3821 -> 3817;
3822 -> 3817;
3823 -> 3822;
3823 -> 3818;
3823 -> 3817;
3824 -> 3816;
3825 -> 3816;
3826 -> 3814;
3826 -> 3803;
3826 -> 3825;
3827 -> 3826;
3827 -> 3803;
3827 -> 3825;
3828 -> 3825;
3829 -> 3826;
3829 -> 3828;
3830 -> 3829;
3830 -> 3803;
3830 -> 3828;
3831 -> 3830;
3832 -> 3829;
3832 -> 3831;
3833 -> 3832;
3833 -> 3803;
3833 -> 3831;
3834 -> 3833;
3834 -> 3830;
3835 -> 3834;
3836 -> 3835;
3836 -> 3825;
3837 -> 3601;
3837 -> 3836;
3838 -> 3837;
3838 -> 3816;
3839 -> 3816;
3840 -> 3838;
3840 -> 3839;
3840 -> 3816;
3841 -> 3840;
3843 -> 3842;
3844 -> 3842;
3845 -> 3838;
3845 -> 3841;
3846 -> 3841;
3847 -> 3845;
3847 -> 3846;
3848 -> 3846;
3849 -> 3847;
3849 -> 3848;
3849 -> 3846;
3850 -> 3847;
3850 -> 3846;
3851 -> 3838;
3851 -> 3849;
3852 -> 3849;
3853 -> 3851;
3853 -> 3852;
3854 -> 3852;
3855 -> 3853;
3855 -> 3854;
3855 -> 3852;
3856 -> 3838;
3856 -> 3816;
3857 -> 3856;
3858 -> 3802;
3858 -> 3803;
3858 -> 3813;
3858 -> 3801;
3859 -> 3801;
3860 -> 3801;
3861 -> 3802;
3861 -> 3860;
3862 -> 3860;
3863 -> 3861;
3863 -> 3803;
3863 -> 3862;
3864 -> 3860;
3865 -> 3860;
3866 -> 3865;
3866 -> 3861;
3866 -> 3860;
3867 -> 3801;
3868 -> 3859;
3868 -> 3801;
3869 -> 3868;
3869 -> 3802;
3869 -> 3803;
3869 -> 3820;
3869 -> 3863;
3869 -> 3823;
3869 -> 3866;
3869 -> 3813;
3869 -> 3859;
3869 -> 3801;
3870 -> 3801;
3871 -> 3869;
3871 -> 3870;
3872 -> 3871;
3872 -> 3869;
3872 -> 3870;
3873 -> 3869;
3873 -> 3870;
3874 -> 3873;
3874 -> 3872;
3874 -> 3870;
3875 -> 3870;
3876 -> 3873;
3876 -> 3875;
3877 -> 3876;
3877 -> 3872;
3877 -> 3875;
3878 -> 3877;
3879 -> 3878;
3879 -> 3877;
3880 -> 3879;
3881 -> 3880;
3881 -> 3870;
3882 -> 3601;
3882 -> 3881;
3883 -> 3869;
3883 -> 3870;
3884 -> 3883;
3884 -> 3882;
3884 -> 3870;
3885 -> 3870;
3886 -> 3883;
3886 -> 3885;
3887 -> 3886;
3887 -> 3882;
3887 -> 3885;
3888 -> 3887;
3888 -> 3870;
3889 -> 0;
3891 -> 3889;
3891 -> 3890;
3892 -> 3890;
3893 -> 3891;
3893 -> 3892;
3893 -> 3890;
3894 -> 3890;
3897 -> 3895;
3897 -> 3896;
3898 -> 3896;
3899 -> 3897;
3899 -> 3898;
3899 -> 3896;
3900 -> 3896;
3901 -> 3869;
3901 -> 3870;
3902 -> 3901;
3902 -> 3888;
3902 -> 3870;
3903 -> 3870;
3904 -> 3902;
3904 -> 3903;
3905 -> 3904;
3905 -> 3903;
3906 -> 3903;
3907 -> 3905;
3907 -> 3906;
3907 -> 3903;
3908 -> 3905;
3908 -> 3903;
3909 -> 3870;
3910 -> 3908;
3910 -> 3909;
3910 -> 3870;
3911 -> 3869;
3911 -> 3870;
3912 -> 3911;
3912 -> 3910;
3912 -> 3870;
3913 -> 3870;
3914 -> 3912;
3914 -> 3913;
3915 -> 3913;
3916 -> 3914;
3916 -> 3915;
3916 -> 3913;
3917 -> 3870;
3918 -> 3914;
3918 -> 3917;
3918 -> 3870;
3919 -> 3858;
3919 -> 3801;
3920 -> 3801;
3921 -> 3919;
3921 -> 3920;
3922 -> 3920;
3923 -> 3920;
3924 -> 3921;
3924 -> 3923;
3924 -> 3920;
3925 -> 3924;
3926 -> 3925;
3926 -> 3921;
3926 -> 3918;
3926 -> 3924;
3927 -> 3922;
3927 -> 3920;
3928 -> 3927;
3928 -> 3801;
3929 -> 3801;
3930 -> 3928;
3930 -> 3929;
3931 -> 3802;
3931 -> 3929;
3932 -> 3929;
3933 -> 3931;
3933 -> 3918;
3933 -> 3932;
3933 -> 3929;
3934 -> 3933;
3935 -> 3934;
3935 -> 3801;
3936 -> 3802;
3936 -> 3918;
3936 -> 3801;
3937 -> 3801;
3938 -> 3802;
3938 -> 3936;
3938 -> 3801;
3939 -> 3801;
3940 -> 3937;
3940 -> 3939;
3941 -> 3937;
3941 -> 3939;
3942 -> 3938;
3942 -> 3939;
3943 -> 3802;
3943 -> 3939;
3944 -> 3941;
3944 -> 3939;
3945 -> 3939;
3946 -> 3945;
3947 -> 3943;
3947 -> 3946;
3948 -> 3946;
3949 -> 3947;
3949 -> 3936;
3949 -> 3948;
3950 -> 3946;
3951 -> 3946;
3952 -> 3951;
3952 -> 3947;
3952 -> 3946;
3953 -> 3945;
3954 -> 3945;
3955 -> 3943;
3955 -> 3936;
3955 -> 3954;
3956 -> 3954;
3957 -> 3955;
3957 -> 3945;
3958 -> 3945;
3959 -> 3957;
3959 -> 3958;
3959 -> 3945;
3960 -> 3959;
3961 -> 3957;
3961 -> 3960;
3962 -> 3960;
3963 -> 3961;
3963 -> 3962;
3964 -> 3962;
3965 -> 3963;
3965 -> 3964;
3965 -> 3962;
3966 -> 3963;
3966 -> 3962;
3967 -> 3957;
3967 -> 3965;
3968 -> 3965;
3969 -> 3967;
3969 -> 3968;
3970 -> 3968;
3971 -> 3969;
3971 -> 3970;
3971 -> 3968;
3972 -> 3957;
3972 -> 3945;
3973 -> 3972;
3974 -> 3802;
3974 -> 3936;
3974 -> 3942;
3974 -> 3801;
3975 -> 3918;
3975 -> 3801;
3976 -> 3858;
3976 -> 3801;
3977 -> 3974;
3977 -> 3801;
3978 -> 3935;
3978 -> 3801;
3979 -> 3801;
3980 -> 3975;
3980 -> 3979;
3981 -> 3976;
3981 -> 3979;
3982 -> 3977;
3982 -> 3979;
3983 -> 3978;
3983 -> 3979;
3984 -> 3802;
3984 -> 3979;
3985 -> 3980;
3985 -> 3918;
3985 -> 0;
3985 -> 3979;
3986 -> 3981;
3986 -> 3936;
3986 -> 3949;
3986 -> 3952;
3986 -> 3942;
3986 -> 3979;
3987 -> 3982;
3987 -> 3986;
3987 -> 3979;
3988 -> 3979;
3989 -> 3980;
3989 -> 3918;
3989 -> 3979;
3990 -> 3980;
3990 -> 3918;
3990 -> 3989;
3991 -> 3986;
3991 -> 3990;
3992 -> 3980;
3992 -> 3918;
3992 -> 3990;
3993 -> 3987;
3993 -> 3990;
3994 -> 3990;
3995 -> 3991;
3995 -> 3994;
3996 -> 3992;
3996 -> 3994;
3997 -> 3993;
3997 -> 3994;
3998 -> 0;
3999 -> 0;
4001 -> 3999;
4001 -> 4000;
4002 -> 4001;
4003 -> 4002;
4005 -> 3999;
4005 -> 4004;
4006 -> 4005;
4007 -> 4006;
4009 -> 3999;
4009 -> 4008;
4010 -> 4009;
4011 -> 4010;
4013 -> 3999;
4013 -> 4012;
4014 -> 4013;
4015 -> 4014;
4017 -> 3998;
4018 -> 4017;
4018 -> 3999;
4019 -> 4003;
4019 -> 4002;
4019 -> 4017;
4019 -> 4018;
4020 -> 4017;
4020 -> 4018;
4021 -> 4018;
4022 -> 4018;
4023 -> 4020;
4023 -> 4022;
4024 -> 4021;
4024 -> 4022;
4025 -> 4023;
4025 -> 4022;
4026 -> 4022;
4027 -> 4025;
4027 -> 4026;
4028 -> 4024;
4028 -> 4026;
4029 -> 4027;
4029 -> 4026;
4030 -> 4026;
4031 -> 4030;
4031 -> 4029;
4031 -> 4026;
4032 -> 4030;
4032 -> 4026;
4033 -> 4032;
4033 -> 4031;
4033 -> 4026;
4034 -> 4022;
4035 -> 4024;
4035 -> 4034;
4036 -> 4034;
4037 -> 4035;
4037 -> 4036;
4038 -> 4037;
4038 -> 4033;
4038 -> 4036;
4039 -> 4038;
4039 -> 4034;
4040 -> 4034;
4041 -> 4039;
4041 -> 4040;
4042 -> 4041;
4042 -> 4040;
4043 -> 4042;
4044 -> 4043;
4044 -> 4022;
4045 -> 4044;
4045 -> 4024;
4045 -> 4022;
4046 -> 4024;
4046 -> 4033;
4046 -> 0;
4046 -> 4022;
4047 -> 4046;
4047 -> 4024;
4047 -> 4022;
4048 -> 4021;
4048 -> 4019;
4048 -> 4018;
4050 -> 4007;
4050 -> 4006;
4050 -> 4017;
4050 -> 4018;
4051 -> 4017;
4051 -> 4018;
4052 -> 3458;
4052 -> 4018;
4053 -> 4018;
4054 -> 4018;
4055 -> 4051;
4055 -> 4054;
4056 -> 4052;
4056 -> 4054;
4057 -> 4052;
4057 -> 4054;
4058 -> 4053;
4058 -> 4054;
4059 -> 4055;
4059 -> 4054;
4060 -> 4054;
4061 -> 4059;
4061 -> 4060;
4062 -> 4058;
4062 -> 4060;
4063 -> 4061;
4063 -> 4060;
4064 -> 4060;
4065 -> 4063;
4065 -> 4064;
4066 -> 4062;
4066 -> 4064;
4067 -> 4065;
4067 -> 4064;
4068 -> 4064;
4069 -> 4068;
4069 -> 4067;
4069 -> 4064;
4070 -> 4068;
4070 -> 4064;
4071 -> 4070;
4071 -> 4069;
4071 -> 4064;
4072 -> 4060;
4073 -> 4062;
4073 -> 4072;
4074 -> 4072;
4075 -> 4073;
4075 -> 4074;
4076 -> 4075;
4076 -> 4071;
4076 -> 4074;
4077 -> 4076;
4077 -> 4072;
4078 -> 4072;
4079 -> 4077;
4079 -> 4078;
4080 -> 4079;
4080 -> 4078;
4081 -> 4080;
4082 -> 4081;
4082 -> 4060;
4083 -> 4082;
4083 -> 4062;
4083 -> 4060;
4084 -> 4062;
4084 -> 4071;
4084 -> 0;
4084 -> 4060;
4085 -> 4084;
4085 -> 4062;
4085 -> 4060;
4086 -> 4058;
4086 -> 4054;
4087 -> 4058;
4087 -> 4054;
4088 -> 4054;
4089 -> 4056;
4089 -> 4088;
4089 -> 4054;
4090 -> 4056;
4090 -> 4089;
4091 -> 4058;
4091 -> 4090;
4091 -> 4071;
4091 -> 4083;
4091 -> 4085;
4091 -> 4086;
4091 -> 4087;
4091 -> 3514;
4091 -> 4089;
4092 -> 4056;
4092 -> 4058;
4092 -> 4089;
4093 -> 4054;
4094 -> 4057;
4094 -> 4093;
4094 -> 4054;
4095 -> 4057;
4095 -> 4094;
4096 -> 4058;
4096 -> 4095;
4096 -> 4091;
4096 -> 4092;
4096 -> 4094;
4097 -> 4057;
4097 -> 4058;
4097 -> 4094;
4098 -> 4053;
4098 -> 4050;
4098 -> 4018;
4099 -> 4011;
4099 -> 4010;
4099 -> 4017;
4099 -> 4018;
4100 -> 4017;
4100 -> 4018;
4101 -> 4018;
4102 -> 3037;
4102 -> 4018;
4103 -> 4018;
4104 -> 4100;
4104 -> 4103;
4105 -> 4101;
4105 -> 4103;
4106 -> 4102;
4106 -> 4103;
4107 -> 4101;
4107 -> 4103;
4108 -> 4104;
4108 -> 4103;
4109 -> 4103;
4110 -> 4108;
4110 -> 4109;
4111 -> 4107;
4111 -> 4109;
4112 -> 4110;
4112 -> 4109;
4113 -> 4109;
4114 -> 4112;
4114 -> 4113;
4115 -> 4111;
4115 -> 4113;
4116 -> 4114;
4116 -> 4113;
4117 -> 4113;
4118 -> 4117;
4118 -> 4116;
4118 -> 4113;
4119 -> 4117;
4119 -> 4113;
4120 -> 4119;
4120 -> 4118;
4120 -> 4113;
4121 -> 4109;
4122 -> 4111;
4122 -> 4121;
4123 -> 4121;
4124 -> 4122;
4124 -> 4123;
4125 -> 4124;
4125 -> 4120;
4125 -> 4123;
4126 -> 4125;
4126 -> 4121;
4127 -> 4121;
4128 -> 4126;
4128 -> 4127;
4129 -> 4128;
4129 -> 4127;
4130 -> 4129;
4131 -> 4130;
4131 -> 4109;
4132 -> 4131;
4132 -> 4111;
4132 -> 4109;
4133 -> 4111;
4133 -> 4120;
4133 -> 0;
4133 -> 4109;
4134 -> 4133;
4134 -> 4111;
4134 -> 4109;
4135 -> 4107;
4135 -> 4103;
4136 -> 4107;
4136 -> 4103;
4137 -> 4103;
4138 -> 4105;
4138 -> 4137;
4138 -> 4103;
4139 -> 4103;
4140 -> 4106;
4140 -> 4139;
4140 -> 4103;
4141 -> 4106;
4141 -> 4140;
4142 -> 4107;
4142 -> 4141;
4142 -> 4120;
4142 -> 4132;
4142 -> 4134;
4142 -> 4135;
4142 -> 4136;
4142 -> 3479;
4142 -> 4140;
4143 -> 4106;
4143 -> 4107;
4143 -> 4140;
4144 -> 4101;
4144 -> 4099;
4144 -> 4018;
4145 -> 4015;
4145 -> 4014;
4145 -> 4017;
4145 -> 4018;
4146 -> 4017;
4146 -> 4018;
4147 -> 4018;
4148 -> 2896;
4148 -> 4018;
4149 -> 4018;
4150 -> 4146;
4150 -> 4149;
4151 -> 4147;
4151 -> 4149;
4152 -> 4148;
4152 -> 4149;
4153 -> 4147;
4153 -> 4149;
4154 -> 4150;
4154 -> 4149;
4155 -> 4149;
4156 -> 4154;
4156 -> 4155;
4157 -> 4153;
4157 -> 4155;
4158 -> 4156;
4158 -> 4155;
4159 -> 4155;
4160 -> 4158;
4160 -> 4159;
4161 -> 4157;
4161 -> 4159;
4162 -> 4160;
4162 -> 4159;
4163 -> 4159;
4164 -> 4163;
4164 -> 4162;
4164 -> 4159;
4165 -> 4163;
4165 -> 4159;
4166 -> 4165;
4166 -> 4164;
4166 -> 4159;
4167 -> 4155;
4168 -> 4157;
4168 -> 4167;
4169 -> 4167;
4170 -> 4168;
4170 -> 4169;
4171 -> 4170;
4171 -> 4166;
4171 -> 4169;
4172 -> 4171;
4172 -> 4167;
4173 -> 4167;
4174 -> 4172;
4174 -> 4173;
4175 -> 4174;
4175 -> 4173;
4176 -> 4175;
4177 -> 4176;
4177 -> 4155;
4178 -> 4177;
4178 -> 4157;
4178 -> 4155;
4179 -> 4157;
4179 -> 4166;
4179 -> 0;
4179 -> 4155;
4180 -> 4179;
4180 -> 4157;
4180 -> 4155;
4181 -> 4153;
4181 -> 4149;
4182 -> 4153;
4182 -> 4149;
4183 -> 4149;
4184 -> 4151;
4184 -> 4183;
4184 -> 4149;
4185 -> 4149;
4186 -> 4152;
4186 -> 4185;
4186 -> 4149;
4187 -> 4152;
4187 -> 4186;
4188 -> 4153;
4188 -> 4187;
4188 -> 4166;
4188 -> 4178;
4188 -> 4180;
4188 -> 4181;
4188 -> 4182;
4188 -> 3464;
4188 -> 4186;
4189 -> 4152;
4189 -> 4153;
4189 -> 4186;
4190 -> 4147;
4190 -> 4145;
4190 -> 4018;
4191 -> 4003;
4191 -> 4002;
4191 -> 4018;
4192 -> 4021;
4192 -> 4022;
4193 -> 4192;
4193 -> 4022;
4194 -> 4193;
4194 -> 4026;
4195 -> 4194;
4195 -> 4026;
4196 -> 4030;
4196 -> 4195;
4196 -> 4026;
4197 -> 4032;
4197 -> 4196;
4197 -> 4026;
4198 -> 4037;
4198 -> 4197;
4198 -> 4036;
4199 -> 4198;
4199 -> 4034;
4200 -> 4199;
4200 -> 4040;
4201 -> 4200;
4201 -> 4040;
4202 -> 4201;
4203 -> 4202;
4203 -> 4022;
4204 -> 4203;
4204 -> 4024;
4204 -> 4022;
4205 -> 4024;
4205 -> 4197;
4205 -> 0;
4205 -> 4022;
4206 -> 4205;
4206 -> 4024;
4206 -> 4022;
4207 -> 4021;
4207 -> 4191;
4207 -> 4018;
4208 -> 4007;
4208 -> 4006;
4208 -> 4018;
4209 -> 4053;
4209 -> 4054;
4210 -> 4209;
4210 -> 4054;
4211 -> 4210;
4211 -> 4060;
4212 -> 4211;
4212 -> 4060;
4213 -> 4212;
4213 -> 4064;
4214 -> 4213;
4214 -> 4064;
4215 -> 4068;
4215 -> 4214;
4215 -> 4064;
4216 -> 4070;
4216 -> 4215;
4216 -> 4064;
4217 -> 4075;
4217 -> 4216;
4217 -> 4074;
4218 -> 4217;
4218 -> 4072;
4219 -> 4218;
4219 -> 4078;
4220 -> 4219;
4220 -> 4078;
4221 -> 4220;
4222 -> 4221;
4222 -> 4060;
4223 -> 4222;
4223 -> 4062;
4223 -> 4060;
4224 -> 4062;
4224 -> 4216;
4224 -> 0;
4224 -> 4060;
4225 -> 4224;
4225 -> 4062;
4225 -> 4060;
4226 -> 4058;
4226 -> 4090;
4226 -> 4216;
4226 -> 4223;
4226 -> 4225;
4226 -> 4086;
4226 -> 4087;
4226 -> 4096;
4226 -> 4097;
4226 -> 4089;
4227 -> 4053;
4227 -> 4208;
4227 -> 4018;
4228 -> 4011;
4228 -> 4010;
4228 -> 4018;
4229 -> 4101;
4229 -> 4103;
4230 -> 4229;
4230 -> 4103;
4231 -> 4230;
4231 -> 4109;
4232 -> 4231;
4232 -> 4109;
4233 -> 4232;
4233 -> 4113;
4234 -> 4233;
4234 -> 4113;
4235 -> 4117;
4235 -> 4234;
4235 -> 4113;
4236 -> 4119;
4236 -> 4235;
4236 -> 4113;
4237 -> 4124;
4237 -> 4236;
4237 -> 4123;
4238 -> 4237;
4238 -> 4121;
4239 -> 4238;
4239 -> 4127;
4240 -> 4239;
4240 -> 4127;
4241 -> 4240;
4242 -> 4241;
4242 -> 4109;
4243 -> 4242;
4243 -> 4111;
4243 -> 4109;
4244 -> 4111;
4244 -> 4236;
4244 -> 0;
4244 -> 4109;
4245 -> 4244;
4245 -> 4111;
4245 -> 4109;
4246 -> 4107;
4246 -> 4141;
4246 -> 4236;
4246 -> 4243;
4246 -> 4245;
4246 -> 4135;
4246 -> 4136;
4246 -> 4142;
4246 -> 4143;
4246 -> 4140;
4247 -> 4101;
4247 -> 4228;
4247 -> 4018;
4248 -> 4015;
4248 -> 4014;
4248 -> 4018;
4249 -> 4147;
4249 -> 4149;
4250 -> 4249;
4250 -> 4149;
4251 -> 4250;
4251 -> 4155;
4252 -> 4251;
4252 -> 4155;
4253 -> 4252;
4253 -> 4159;
4254 -> 4253;
4254 -> 4159;
4255 -> 4163;
4255 -> 4254;
4255 -> 4159;
4256 -> 4165;
4256 -> 4255;
4256 -> 4159;
4257 -> 4170;
4257 -> 4256;
4257 -> 4169;
4258 -> 4257;
4258 -> 4167;
4259 -> 4258;
4259 -> 4173;
4260 -> 4259;
4260 -> 4173;
4261 -> 4260;
4262 -> 4261;
4262 -> 4155;
4263 -> 4262;
4263 -> 4157;
4263 -> 4155;
4264 -> 4157;
4264 -> 4256;
4264 -> 0;
4264 -> 4155;
4265 -> 4264;
4265 -> 4157;
4265 -> 4155;
4266 -> 4153;
4266 -> 4187;
4266 -> 4256;
4266 -> 4263;
4266 -> 4265;
4266 -> 4181;
4266 -> 4182;
4266 -> 4188;
4266 -> 4189;
4266 -> 4186;
4267 -> 4147;
4267 -> 4248;
4267 -> 4018;
4268 -> 4201;
4269 -> 4268;
4269 -> 4022;
4270 -> 4269;
4270 -> 4024;
4270 -> 4022;
4271 -> 4220;
4272 -> 4271;
4272 -> 4060;
4273 -> 4272;
4273 -> 4062;
4273 -> 4060;
4274 -> 4058;
4274 -> 4090;
4274 -> 4216;
4274 -> 4273;
4274 -> 4225;
4274 -> 4086;
4274 -> 4087;
4274 -> 4226;
4274 -> 4097;
4274 -> 4089;
4275 -> 4240;
4276 -> 4275;
4276 -> 4109;
4277 -> 4276;
4277 -> 4111;
4277 -> 4109;
4278 -> 4107;
4278 -> 4141;
4278 -> 4236;
4278 -> 4277;
4278 -> 4245;
4278 -> 4135;
4278 -> 4136;
4278 -> 4246;
4278 -> 4143;
4278 -> 4140;
4279 -> 4260;
4280 -> 4279;
4280 -> 4155;
4281 -> 4280;
4281 -> 4157;
4281 -> 4155;
4282 -> 4153;
4282 -> 4187;
4282 -> 4256;
4282 -> 4281;
4282 -> 4265;
4282 -> 4181;
4282 -> 4182;
4282 -> 4266;
4282 -> 4189;
4282 -> 4186;
4283 -> 4201;
4284 -> 4283;
4284 -> 4022;
4285 -> 4284;
4285 -> 4024;
4285 -> 4022;
4286 -> 4220;
4287 -> 4286;
4287 -> 4060;
4288 -> 4287;
4288 -> 4062;
4288 -> 4060;
4289 -> 4058;
4289 -> 4090;
4289 -> 4216;
4289 -> 4288;
4289 -> 4225;
4289 -> 4086;
4289 -> 4087;
4289 -> 4274;
4289 -> 4097;
4289 -> 4089;
4290 -> 4240;
4291 -> 4290;
4291 -> 4109;
4292 -> 4291;
4292 -> 4111;
4292 -> 4109;
4293 -> 4107;
4293 -> 4141;
4293 -> 4236;
4293 -> 4292;
4293 -> 4245;
4293 -> 4135;
4293 -> 4136;
4293 -> 4278;
4293 -> 4143;
4293 -> 4140;
4294 -> 4260;
4295 -> 4294;
4295 -> 4155;
4296 -> 4295;
4296 -> 4157;
4296 -> 4155;
4297 -> 4153;
4297 -> 4187;
4297 -> 4256;
4297 -> 4296;
4297 -> 4265;
4297 -> 4181;
4297 -> 4182;
4297 -> 4282;
4297 -> 4189;
4297 -> 4186;
4298 -> 4201;
4299 -> 4298;
4299 -> 4022;
4300 -> 4299;
4300 -> 4024;
4300 -> 4022;
4301 -> 4220;
4302 -> 4301;
4302 -> 4060;
4303 -> 4302;
4303 -> 4062;
4303 -> 4060;
4304 -> 4058;
4304 -> 4090;
4304 -> 4216;
4304 -> 4303;
4304 -> 4225;
4304 -> 4086;
4304 -> 4087;
4304 -> 4289;
4304 -> 4097;
4304 -> 4089;
4305 -> 4240;
4306 -> 4305;
4306 -> 4109;
4307 -> 4306;
4307 -> 4111;
4307 -> 4109;
4308 -> 4107;
4308 -> 4141;
4308 -> 4236;
4308 -> 4307;
4308 -> 4245;
4308 -> 4135;
4308 -> 4136;
4308 -> 4293;
4308 -> 4143;
4308 -> 4140;
4309 -> 4260;
4310 -> 4309;
4310 -> 4155;
4311 -> 4310;
4311 -> 4157;
4311 -> 4155;
4312 -> 4153;
4312 -> 4187;
4312 -> 4256;
4312 -> 4311;
4312 -> 4265;
4312 -> 4181;
4312 -> 4182;
4312 -> 4297;
4312 -> 4189;
4312 -> 4186;
4313 -> 4201;
4314 -> 4313;
4314 -> 4022;
4315 -> 4314;
4315 -> 4024;
4315 -> 4022;
4316 -> 4220;
4317 -> 4316;
4317 -> 4060;
4318 -> 4317;
4318 -> 4062;
4318 -> 4060;
4319 -> 4058;
4319 -> 4090;
4319 -> 4216;
4319 -> 4318;
4319 -> 4225;
4319 -> 4086;
4319 -> 4087;
4319 -> 4304;
4319 -> 4097;
4319 -> 4089;
4320 -> 4240;
4321 -> 4320;
4321 -> 4109;
4322 -> 4321;
4322 -> 4111;
4322 -> 4109;
4323 -> 4107;
4323 -> 4141;
4323 -> 4236;
4323 -> 4322;
4323 -> 4245;
4323 -> 4135;
4323 -> 4136;
4323 -> 4308;
4323 -> 4143;
4323 -> 4140;
4324 -> 4260;
4325 -> 4324;
4325 -> 4155;
4326 -> 4325;
4326 -> 4157;
4326 -> 4155;
4327 -> 4153;
4327 -> 4187;
4327 -> 4256;
4327 -> 4326;
4327 -> 4265;
4327 -> 4181;
4327 -> 4182;
4327 -> 4312;
4327 -> 4189;
4327 -> 4186;
4328 -> 4201;
4329 -> 4328;
4329 -> 4022;
4330 -> 4329;
4330 -> 4024;
4330 -> 4022;
4331 -> 4220;
4332 -> 4331;
4332 -> 4060;
4333 -> 4332;
4333 -> 4062;
4333 -> 4060;
4334 -> 4058;
4334 -> 4090;
4334 -> 4216;
4334 -> 4333;
4334 -> 4225;
4334 -> 4086;
4334 -> 4087;
4334 -> 4319;
4334 -> 4097;
4334 -> 4089;
4335 -> 4240;
4336 -> 4335;
4336 -> 4109;
4337 -> 4336;
4337 -> 4111;
4337 -> 4109;
4338 -> 4107;
4338 -> 4141;
4338 -> 4236;
4338 -> 4337;
4338 -> 4245;
4338 -> 4135;
4338 -> 4136;
4338 -> 4323;
4338 -> 4143;
4338 -> 4140;
4339 -> 4260;
4340 -> 4339;
4340 -> 4155;
4341 -> 4340;
4341 -> 4157;
4341 -> 4155;
4342 -> 4153;
4342 -> 4187;
4342 -> 4256;
4342 -> 4341;
4342 -> 4265;
4342 -> 4181;
4342 -> 4182;
4342 -> 4327;
4342 -> 4189;
4342 -> 4186;
4343 -> 4201;
4344 -> 4343;
4344 -> 4022;
4345 -> 4344;
4345 -> 4024;
4345 -> 4022;
4346 -> 4220;
4347 -> 4346;
4347 -> 4060;
4348 -> 4347;
4348 -> 4062;
4348 -> 4060;
4349 -> 4058;
4349 -> 4090;
4349 -> 4216;
4349 -> 4348;
4349 -> 4225;
4349 -> 4086;
4349 -> 4087;
4349 -> 4334;
4349 -> 4097;
4349 -> 4089;
4350 -> 4240;
4351 -> 4350;
4351 -> 4109;
4352 -> 4351;
4352 -> 4111;
4352 -> 4109;
4353 -> 4107;
4353 -> 4141;
4353 -> 4236;
4353 -> 4352;
4353 -> 4245;
4353 -> 4135;
4353 -> 4136;
4353 -> 4338;
4353 -> 4143;
4353 -> 4140;
4354 -> 4260;
4355 -> 4354;
4355 -> 4155;
4356 -> 4355;
4356 -> 4157;
4356 -> 4155;
4357 -> 4153;
4357 -> 4187;
4357 -> 4256;
4357 -> 4356;
4357 -> 4265;
4357 -> 4181;
4357 -> 4182;
4357 -> 4342;
4357 -> 4189;
4357 -> 4186;
4358 -> 4201;
4359 -> 4358;
4359 -> 4022;
4360 -> 4359;
4360 -> 4024;
4360 -> 4022;
4361 -> 4220;
4362 -> 4361;
4362 -> 4060;
4363 -> 4362;
4363 -> 4062;
4363 -> 4060;
4364 -> 4058;
4364 -> 4090;
4364 -> 4216;
4364 -> 4363;
4364 -> 4225;
4364 -> 4086;
4364 -> 4087;
4364 -> 4349;
4364 -> 4097;
4364 -> 4089;
4365 -> 4240;
4366 -> 4365;
4366 -> 4109;
4367 -> 4366;
4367 -> 4111;
4367 -> 4109;
4368 -> 4107;
4368 -> 4141;
4368 -> 4236;
4368 -> 4367;
4368 -> 4245;
4368 -> 4135;
4368 -> 4136;
4368 -> 4353;
4368 -> 4143;
4368 -> 4140;
4369 -> 4260;
4370 -> 4369;
4370 -> 4155;
4371 -> 4370;
4371 -> 4157;
4371 -> 4155;
4372 -> 4153;
4372 -> 4187;
4372 -> 4256;
4372 -> 4371;
4372 -> 4265;
4372 -> 4181;
4372 -> 4182;
4372 -> 4357;
4372 -> 4189;
4372 -> 4186;
4373 -> 4201;
4374 -> 4373;
4374 -> 4022;
4375 -> 4374;
4375 -> 4024;
4375 -> 4022;
4376 -> 4220;
4377 -> 4376;
4377 -> 4060;
4378 -> 4377;
4378 -> 4062;
4378 -> 4060;
4379 -> 4058;
4379 -> 4090;
4379 -> 4216;
4379 -> 4378;
4379 -> 4225;
4379 -> 4086;
4379 -> 4087;
4379 -> 4364;
4379 -> 4097;
4379 -> 4089;
4380 -> 4240;
4381 -> 4380;
4381 -> 4109;
4382 -> 4381;
4382 -> 4111;
4382 -> 4109;
4383 -> 4107;
4383 -> 4141;
4383 -> 4236;
4383 -> 4382;
4383 -> 4245;
4383 -> 4135;
4383 -> 4136;
4383 -> 4368;
4383 -> 4143;
4383 -> 4140;
4384 -> 4260;
4385 -> 4384;
4385 -> 4155;
4386 -> 4385;
4386 -> 4157;
4386 -> 4155;
4387 -> 4153;
4387 -> 4187;
4387 -> 4256;
4387 -> 4386;
4387 -> 4265;
4387 -> 4181;
4387 -> 4182;
4387 -> 4372;
4387 -> 4189;
4387 -> 4186;
4388 -> 4201;
4389 -> 4388;
4389 -> 4022;
4390 -> 4389;
4390 -> 4024;
4390 -> 4022;
4391 -> 4220;
4392 -> 4391;
4392 -> 4060;
4393 -> 4392;
4393 -> 4062;
4393 -> 4060;
4394 -> 4058;
4394 -> 4090;
4394 -> 4216;
4394 -> 4393;
4394 -> 4225;
4394 -> 4086;
4394 -> 4087;
4394 -> 4379;
4394 -> 4097;
4394 -> 4089;
4395 -> 4240;
4396 -> 4395;
4396 -> 4109;
4397 -> 4396;
4397 -> 4111;
4397 -> 4109;
4398 -> 4107;
4398 -> 4141;
4398 -> 4236;
4398 -> 4397;
4398 -> 4245;
4398 -> 4135;
4398 -> 4136;
4398 -> 4383;
4398 -> 4143;
4398 -> 4140;
4399 -> 4260;
4400 -> 4399;
4400 -> 4155;
4401 -> 4400;
4401 -> 4157;
4401 -> 4155;
4402 -> 4153;
4402 -> 4187;
4402 -> 4256;
4402 -> 4401;
4402 -> 4265;
4402 -> 4181;
4402 -> 4182;
4402 -> 4387;
4402 -> 4189;
4402 -> 4186;
4403 -> 4201;
4404 -> 4403;
4404 -> 4022;
4405 -> 4404;
4405 -> 4024;
4405 -> 4022;
4406 -> 4220;
4407 -> 4406;
4407 -> 4060;
4408 -> 4407;
4408 -> 4062;
4408 -> 4060;
4409 -> 4058;
4409 -> 4090;
4409 -> 4216;
4409 -> 4408;
4409 -> 4225;
4409 -> 4086;
4409 -> 4087;
4409 -> 4394;
4409 -> 4097;
4409 -> 4089;
4410 -> 4240;
4411 -> 4410;
4411 -> 4109;
4412 -> 4411;
4412 -> 4111;
4412 -> 4109;
4413 -> 4107;
4413 -> 4141;
4413 -> 4236;
4413 -> 4412;
4413 -> 4245;
4413 -> 4135;
4413 -> 4136;
4413 -> 4398;
4413 -> 4143;
4413 -> 4140;
4414 -> 4260;
4415 -> 4414;
4415 -> 4155;
4416 -> 4415;
4416 -> 4157;
4416 -> 4155;
4417 -> 4153;
4417 -> 4187;
4417 -> 4256;
4417 -> 4416;
4417 -> 4265;
4417 -> 4181;
4417 -> 4182;
4417 -> 4402;
4417 -> 4189;
4417 -> 4186;
4418 -> 4201;
4419 -> 4418;
4419 -> 4022;
4420 -> 4419;
4420 -> 4024;
4420 -> 4022;
4421 -> 4220;
4422 -> 4421;
4422 -> 4060;
4423 -> 4422;
4423 -> 4062;
4423 -> 4060;
4424 -> 4058;
4424 -> 4090;
4424 -> 4216;
4424 -> 4423;
4424 -> 4225;
4424 -> 4086;
4424 -> 4087;
4424 -> 4409;
4424 -> 4097;
4424 -> 4089;
4425 -> 4240;
4426 -> 4425;
4426 -> 4109;
4427 -> 4426;
4427 -> 4111;
4427 -> 4109;
4428 -> 4107;
4428 -> 4141;
4428 -> 4236;
4428 -> 4427;
4428 -> 4245;
4428 -> 4135;
4428 -> 4136;
4428 -> 4413;
4428 -> 4143;
4428 -> 4140;
4429 -> 4260;
4430 -> 4429;
4430 -> 4155;
4431 -> 4430;
4431 -> 4157;
4431 -> 4155;
4432 -> 4153;
4432 -> 4187;
4432 -> 4256;
4432 -> 4431;
4432 -> 4265;
4432 -> 4181;
4432 -> 4182;
4432 -> 4417;
4432 -> 4189;
4432 -> 4186;
4433 -> 4201;
4434 -> 4433;
4434 -> 4022;
4435 -> 4434;
4435 -> 4024;
4435 -> 4022;
4436 -> 4220;
4437 -> 4436;
4437 -> 4060;
4438 -> 4437;
4438 -> 4062;
4438 -> 4060;
4439 -> 4058;
4439 -> 4090;
4439 -> 4216;
4439 -> 4438;
4439 -> 4225;
4439 -> 4086;
4439 -> 4087;
4439 -> 4424;
4439 -> 4097;
4439 -> 4089;
4440 -> 4240;
4441 -> 4440;
4441 -> 4109;
4442 -> 4441;
4442 -> 4111;
4442 -> 4109;
4443 -> 4107;
4443 -> 4141;
4443 -> 4236;
4443 -> 4442;
4443 -> 4245;
4443 -> 4135;
4443 -> 4136;
4443 -> 4428;
4443 -> 4143;
4443 -> 4140;
4444 -> 4260;
4445 -> 4444;
4445 -> 4155;
4446 -> 4445;
4446 -> 4157;
4446 -> 4155;
4447 -> 4153;
4447 -> 4187;
4447 -> 4256;
4447 -> 4446;
4447 -> 4265;
4447 -> 4181;
4447 -> 4182;
4447 -> 4432;
4447 -> 4189;
4447 -> 4186;
4448 -> 4201;
4449 -> 4448;
4449 -> 4022;
4450 -> 4449;
4450 -> 4024;
4450 -> 4022;
4451 -> 4220;
4452 -> 4451;
4452 -> 4060;
4453 -> 4452;
4453 -> 4062;
4453 -> 4060;
4454 -> 4058;
4454 -> 4090;
4454 -> 4216;
4454 -> 4453;
4454 -> 4225;
4454 -> 4086;
4454 -> 4087;
4454 -> 4439;
4454 -> 4097;
4454 -> 4089;
4455 -> 4240;
4456 -> 4455;
4456 -> 4109;
4457 -> 4456;
4457 -> 4111;
4457 -> 4109;
4458 -> 4107;
4458 -> 4141;
4458 -> 4236;
4458 -> 4457;
4458 -> 4245;
4458 -> 4135;
4458 -> 4136;
4458 -> 4443;
4458 -> 4143;
4458 -> 4140;
4459 -> 4260;
4460 -> 4459;
4460 -> 4155;
4461 -> 4460;
4461 -> 4157;
4461 -> 4155;
4462 -> 4153;
4462 -> 4187;
4462 -> 4256;
4462 -> 4461;
4462 -> 4265;
4462 -> 4181;
4462 -> 4182;
4462 -> 4447;
4462 -> 4189;
4462 -> 4186;
4463 -> 4201;
4464 -> 4463;
4464 -> 4022;
4465 -> 4464;
4465 -> 4024;
4465 -> 4022;
4466 -> 4220;
4467 -> 4466;
4467 -> 4060;
4468 -> 4467;
4468 -> 4062;
4468 -> 4060;
4469 -> 4058;
4469 -> 4090;
4469 -> 4216;
4469 -> 4468;
4469 -> 4225;
4469 -> 4086;
4469 -> 4087;
4469 -> 4454;
4469 -> 4097;
4469 -> 4089;
4470 -> 4240;
4471 -> 4470;
4471 -> 4109;
4472 -> 4471;
4472 -> 4111;
4472 -> 4109;
4473 -> 4107;
4473 -> 4141;
4473 -> 4236;
4473 -> 4472;
4473 -> 4245;
4473 -> 4135;
4473 -> 4136;
4473 -> 4458;
4473 -> 4143;
4473 -> 4140;
4474 -> 4260;
4475 -> 4474;
4475 -> 4155;
4476 -> 4475;
4476 -> 4157;
4476 -> 4155;
4477 -> 4153;
4477 -> 4187;
4477 -> 4256;
4477 -> 4476;
4477 -> 4265;
4477 -> 4181;
4477 -> 4182;
4477 -> 4462;
4477 -> 4189;
4477 -> 4186;
4478 -> 4201;
4479 -> 4478;
4479 -> 4022;
4480 -> 4479;
4480 -> 4024;
4480 -> 4022;
4481 -> 4220;
4482 -> 4481;
4482 -> 4060;
4483 -> 4482;
4483 -> 4062;
4483 -> 4060;
4484 -> 4058;
4484 -> 4090;
4484 -> 4216;
4484 -> 4483;
4484 -> 4225;
4484 -> 4086;
4484 -> 4087;
4484 -> 4469;
4484 -> 4097;
4484 -> 4089;
4485 -> 4240;
4486 -> 4485;
4486 -> 4109;
4487 -> 4486;
4487 -> 4111;
4487 -> 4109;
4488 -> 4107;
4488 -> 4141;
4488 -> 4236;
4488 -> 4487;
4488 -> 4245;
4488 -> 4135;
4488 -> 4136;
4488 -> 4473;
4488 -> 4143;
4488 -> 4140;
4489 -> 4260;
4490 -> 4489;
4490 -> 4155;
4491 -> 4490;
4491 -> 4157;
4491 -> 4155;
4492 -> 4153;
4492 -> 4187;
4492 -> 4256;
4492 -> 4491;
4492 -> 4265;
4492 -> 4181;
4492 -> 4182;
4492 -> 4477;
4492 -> 4189;
4492 -> 4186;
4493 -> 4201;
4494 -> 4493;
4494 -> 4022;
4495 -> 4494;
4495 -> 4024;
4495 -> 4022;
4496 -> 4220;
4497 -> 4496;
4497 -> 4060;
4498 -> 4497;
4498 -> 4062;
4498 -> 4060;
4499 -> 4058;
4499 -> 4090;
4499 -> 4216;
4499 -> 4498;
4499 -> 4225;
4499 -> 4086;
4499 -> 4087;
4499 -> 4484;
4499 -> 4097;
4499 -> 4089;
4500 -> 4240;
4501 -> 4500;
4501 -> 4109;
4502 -> 4501;
4502 -> 4111;
4502 -> 4109;
4503 -> 4107;
4503 -> 4141;
4503 -> 4236;
4503 -> 4502;
4503 -> 4245;
4503 -> 4135;
4503 -> 4136;
4503 -> 4488;
4503 -> 4143;
4503 -> 4140;
4504 -> 4260;
4505 -> 4504;
4505 -> 4155;
4506 -> 4505;
4506 -> 4157;
4506 -> 4155;
4507 -> 4153;
4507 -> 4187;
4507 -> 4256;
4507 -> 4506;
4507 -> 4265;
4507 -> 4181;
4507 -> 4182;
4507 -> 4492;
4507 -> 4189;
4507 -> 4186;
4508 -> 4201;
4509 -> 4508;
4509 -> 4022;
4510 -> 4509;
4510 -> 4024;
4510 -> 4022;
4511 -> 4220;
4512 -> 4511;
4512 -> 4060;
4513 -> 4512;
4513 -> 4062;
4513 -> 4060;
4514 -> 4058;
4514 -> 4090;
4514 -> 4216;
4514 -> 4513;
4514 -> 4225;
4514 -> 4086;
4514 -> 4087;
4514 -> 4499;
4514 -> 4097;
4514 -> 4089;
4515 -> 4240;
4516 -> 4515;
4516 -> 4109;
4517 -> 4516;
4517 -> 4111;
4517 -> 4109;
4518 -> 4107;
4518 -> 4141;
4518 -> 4236;
4518 -> 4517;
4518 -> 4245;
4518 -> 4135;
4518 -> 4136;
4518 -> 4503;
4518 -> 4143;
4518 -> 4140;
4519 -> 4260;
4520 -> 4519;
4520 -> 4155;
4521 -> 4520;
4521 -> 4157;
4521 -> 4155;
4522 -> 4153;
4522 -> 4187;
4522 -> 4256;
4522 -> 4521;
4522 -> 4265;
4522 -> 4181;
4522 -> 4182;
4522 -> 4507;
4522 -> 4189;
4522 -> 4186;
4523 -> 4201;
4524 -> 4523;
4524 -> 4022;
4525 -> 4524;
4525 -> 4024;
4525 -> 4022;
4526 -> 4220;
4527 -> 4526;
4527 -> 4060;
4528 -> 4527;
4528 -> 4062;
4528 -> 4060;
4529 -> 4058;
4529 -> 4090;
4529 -> 4216;
4529 -> 4528;
4529 -> 4225;
4529 -> 4086;
4529 -> 4087;
4529 -> 4514;
4529 -> 4097;
4529 -> 4089;
4530 -> 4240;
4531 -> 4530;
4531 -> 4109;
4532 -> 4531;
4532 -> 4111;
4532 -> 4109;
4533 -> 4107;
4533 -> 4141;
4533 -> 4236;
4533 -> 4532;
4533 -> 4245;
4533 -> 4135;
4533 -> 4136;
4533 -> 4518;
4533 -> 4143;
4533 -> 4140;
4534 -> 4260;
4535 -> 4534;
4535 -> 4155;
4536 -> 4535;
4536 -> 4157;
4536 -> 4155;
4537 -> 4153;
4537 -> 4187;
4537 -> 4256;
4537 -> 4536;
4537 -> 4265;
4537 -> 4181;
4537 -> 4182;
4537 -> 4522;
4537 -> 4189;
4537 -> 4186;
4538 -> 4201;
4539 -> 4538;
4539 -> 4022;
4540 -> 4539;
4540 -> 4024;
4540 -> 4022;
4541 -> 4220;
4542 -> 4541;
4542 -> 4060;
4543 -> 4542;
4543 -> 4062;
4543 -> 4060;
4544 -> 4058;
4544 -> 4090;
4544 -> 4216;
4544 -> 4543;
4544 -> 4225;
4544 -> 4086;
4544 -> 4087;
4544 -> 4529;
4544 -> 4097;
4544 -> 4089;
4545 -> 4240;
4546 -> 4545;
4546 -> 4109;
4547 -> 4546;
4547 -> 4111;
4547 -> 4109;
4548 -> 4107;
4548 -> 4141;
4548 -> 4236;
4548 -> 4547;
4548 -> 4245;
4548 -> 4135;
4548 -> 4136;
4548 -> 4533;
4548 -> 4143;
4548 -> 4140;
4549 -> 4260;
4550 -> 4549;
4550 -> 4155;
4551 -> 4550;
4551 -> 4157;
4551 -> 4155;
4552 -> 4153;
4552 -> 4187;
4552 -> 4256;
4552 -> 4551;
4552 -> 4265;
4552 -> 4181;
4552 -> 4182;
4552 -> 4537;
4552 -> 4189;
4552 -> 4186;
4553 -> 4201;
4554 -> 4553;
4554 -> 4022;
4555 -> 4554;
4555 -> 4024;
4555 -> 4022;
4556 -> 4220;
4557 -> 4556;
4557 -> 4060;
4558 -> 4557;
4558 -> 4062;
4558 -> 4060;
4559 -> 4058;
4559 -> 4090;
4559 -> 4216;
4559 -> 4558;
4559 -> 4225;
4559 -> 4086;
4559 -> 4087;
4559 -> 4544;
4559 -> 4097;
4559 -> 4089;
4560 -> 4240;
4561 -> 4560;
4561 -> 4109;
4562 -> 4561;
4562 -> 4111;
4562 -> 4109;
4563 -> 4107;
4563 -> 4141;
4563 -> 4236;
4563 -> 4562;
4563 -> 4245;
4563 -> 4135;
4563 -> 4136;
4563 -> 4548;
4563 -> 4143;
4563 -> 4140;
4564 -> 4260;
4565 -> 4564;
4565 -> 4155;
4566 -> 4565;
4566 -> 4157;
4566 -> 4155;
4567 -> 4153;
4567 -> 4187;
4567 -> 4256;
4567 -> 4566;
4567 -> 4265;
4567 -> 4181;
4567 -> 4182;
4567 -> 4552;
4567 -> 4189;
4567 -> 4186;
4568 -> 4201;
4569 -> 4568;
4569 -> 4022;
4570 -> 4569;
4570 -> 4024;
4570 -> 4022;
4571 -> 4220;
4572 -> 4571;
4572 -> 4060;
4573 -> 4572;
4573 -> 4062;
4573 -> 4060;
4574 -> 4058;
4574 -> 4090;
4574 -> 4216;
4574 -> 4573;
4574 -> 4225;
4574 -> 4086;
4574 -> 4087;
4574 -> 4559;
4574 -> 4097;
4574 -> 4089;
4575 -> 4240;
4576 -> 4575;
4576 -> 4109;
4577 -> 4576;
4577 -> 4111;
4577 -> 4109;
4578 -> 4107;
4578 -> 4141;
4578 -> 4236;
4578 -> 4577;
4578 -> 4245;
4578 -> 4135;
4578 -> 4136;
4578 -> 4563;
4578 -> 4143;
4578 -> 4140;
4579 -> 4260;
4580 -> 4579;
4580 -> 4155;
4581 -> 4580;
4581 -> 4157;
4581 -> 4155;
4582 -> 4153;
4582 -> 4187;
4582 -> 4256;
4582 -> 4581;
4582 -> 4265;
4582 -> 4181;
4582 -> 4182;
4582 -> 4567;
4582 -> 4189;
4582 -> 4186;
4583 -> 4201;
4584 -> 4583;
4584 -> 4022;
4585 -> 4584;
4585 -> 4024;
4585 -> 4022;
4586 -> 4220;
4587 -> 4586;
4587 -> 4060;
4588 -> 4587;
4588 -> 4062;
4588 -> 4060;
4589 -> 4058;
4589 -> 4090;
4589 -> 4216;
4589 -> 4588;
4589 -> 4225;
4589 -> 4086;
4589 -> 4087;
4589 -> 4574;
4589 -> 4097;
4589 -> 4089;
4590 -> 4240;
4591 -> 4590;
4591 -> 4109;
4592 -> 4591;
4592 -> 4111;
4592 -> 4109;
4593 -> 4107;
4593 -> 4141;
4593 -> 4236;
4593 -> 4592;
4593 -> 4245;
4593 -> 4135;
4593 -> 4136;
4593 -> 4578;
4593 -> 4143;
4593 -> 4140;
4594 -> 4260;
4595 -> 4594;
4595 -> 4155;
4596 -> 4595;
4596 -> 4157;
4596 -> 4155;
4597 -> 4153;
4597 -> 4187;
4597 -> 4256;
4597 -> 4596;
4597 -> 4265;
4597 -> 4181;
4597 -> 4182;
4597 -> 4582;
4597 -> 4189;
4597 -> 4186;
4598 -> 4201;
4599 -> 4598;
4599 -> 4022;
4600 -> 4599;
4600 -> 4024;
4600 -> 4022;
4601 -> 4220;
4602 -> 4601;
4602 -> 4060;
4603 -> 4602;
4603 -> 4062;
4603 -> 4060;
4604 -> 4058;
4604 -> 4090;
4604 -> 4216;
4604 -> 4603;
4604 -> 4225;
4604 -> 4086;
4604 -> 4087;
4604 -> 4589;
4604 -> 4097;
4604 -> 4089;
4605 -> 4240;
4606 -> 4605;
4606 -> 4109;
4607 -> 4606;
4607 -> 4111;
4607 -> 4109;
4608 -> 4107;
4608 -> 4141;
4608 -> 4236;
4608 -> 4607;
4608 -> 4245;
4608 -> 4135;
4608 -> 4136;
4608 -> 4593;
4608 -> 4143;
4608 -> 4140;
4609 -> 4260;
4610 -> 4609;
4610 -> 4155;
4611 -> 4610;
4611 -> 4157;
4611 -> 4155;
4612 -> 4153;
4612 -> 4187;
4612 -> 4256;
4612 -> 4611;
4612 -> 4265;
4612 -> 4181;
4612 -> 4182;
4612 -> 4597;
4612 -> 4189;
4612 -> 4186;
4613 -> 4201;
4614 -> 4613;
4614 -> 4022;
4615 -> 4614;
4615 -> 4024;
4615 -> 4022;
4616 -> 4220;
4617 -> 4616;
4617 -> 4060;
4618 -> 4617;
4618 -> 4062;
4618 -> 4060;
4619 -> 4058;
4619 -> 4090;
4619 -> 4216;
4619 -> 4618;
4619 -> 4225;
4619 -> 4086;
4619 -> 4087;
4619 -> 4604;
4619 -> 4097;
4619 -> 4089;
4620 -> 4240;
4621 -> 4620;
4621 -> 4109;
4622 -> 4621;
4622 -> 4111;
4622 -> 4109;
4623 -> 4107;
4623 -> 4141;
4623 -> 4236;
4623 -> 4622;
4623 -> 4245;
4623 -> 4135;
4623 -> 4136;
4623 -> 4608;
4623 -> 4143;
4623 -> 4140;
4624 -> 4260;
4625 -> 4624;
4625 -> 4155;
4626 -> 4625;
4626 -> 4157;
4626 -> 4155;
4627 -> 4153;
4627 -> 4187;
4627 -> 4256;
4627 -> 4626;
4627 -> 4265;
4627 -> 4181;
4627 -> 4182;
4627 -> 4612;
4627 -> 4189;
4627 -> 4186;
4628 -> 4201;
4629 -> 4628;
4629 -> 4022;
4630 -> 4629;
4630 -> 4024;
4630 -> 4022;
4631 -> 4220;
4632 -> 4631;
4632 -> 4060;
4633 -> 4632;
4633 -> 4062;
4633 -> 4060;
4634 -> 4058;
4634 -> 4090;
4634 -> 4216;
4634 -> 4633;
4634 -> 4225;
4634 -> 4086;
4634 -> 4087;
4634 -> 4619;
4634 -> 4097;
4634 -> 4089;
4635 -> 4240;
4636 -> 4635;
4636 -> 4109;
4637 -> 4636;
4637 -> 4111;
4637 -> 4109;
4638 -> 4107;
4638 -> 4141;
4638 -> 4236;
4638 -> 4637;
4638 -> 4245;
4638 -> 4135;
4638 -> 4136;
4638 -> 4623;
4638 -> 4143;
4638 -> 4140;
4639 -> 4260;
4640 -> 4639;
4640 -> 4155;
4641 -> 4640;
4641 -> 4157;
4641 -> 4155;
4642 -> 4153;
4642 -> 4187;
4642 -> 4256;
4642 -> 4641;
4642 -> 4265;
4642 -> 4181;
4642 -> 4182;
4642 -> 4627;
4642 -> 4189;
4642 -> 4186;
4643 -> 4201;
4644 -> 4643;
4644 -> 4022;
4645 -> 4644;
4645 -> 4024;
4645 -> 4022;
4646 -> 4220;
4647 -> 4646;
4647 -> 4060;
4648 -> 4647;
4648 -> 4062;
4648 -> 4060;
4649 -> 4058;
4649 -> 4090;
4649 -> 4216;
4649 -> 4648;
4649 -> 4225;
4649 -> 4086;
4649 -> 4087;
4649 -> 4634;
4649 -> 4097;
4649 -> 4089;
4650 -> 4240;
4651 -> 4650;
4651 -> 4109;
4652 -> 4651;
4652 -> 4111;
4652 -> 4109;
4653 -> 4107;
4653 -> 4141;
4653 -> 4236;
4653 -> 4652;
4653 -> 4245;
4653 -> 4135;
4653 -> 4136;
4653 -> 4638;
4653 -> 4143;
4653 -> 4140;
4654 -> 4260;
4655 -> 4654;
4655 -> 4155;
4656 -> 4655;
4656 -> 4157;
4656 -> 4155;
4657 -> 4153;
4657 -> 4187;
4657 -> 4256;
4657 -> 4656;
4657 -> 4265;
4657 -> 4181;
4657 -> 4182;
4657 -> 4642;
4657 -> 4189;
4657 -> 4186;
4658 -> 4201;
4659 -> 4658;
4659 -> 4022;
4660 -> 4659;
4660 -> 4024;
4660 -> 4022;
4661 -> 4220;
4662 -> 4661;
4662 -> 4060;
4663 -> 4662;
4663 -> 4062;
4663 -> 4060;
4664 -> 4058;
4664 -> 4090;
4664 -> 4216;
4664 -> 4663;
4664 -> 4225;
4664 -> 4086;
4664 -> 4087;
4664 -> 4649;
4664 -> 4097;
4664 -> 4089;
4665 -> 4240;
4666 -> 4665;
4666 -> 4109;
4667 -> 4666;
4667 -> 4111;
4667 -> 4109;
4668 -> 4107;
4668 -> 4141;
4668 -> 4236;
4668 -> 4667;
4668 -> 4245;
4668 -> 4135;
4668 -> 4136;
4668 -> 4653;
4668 -> 4143;
4668 -> 4140;
4669 -> 4260;
4670 -> 4669;
4670 -> 4155;
4671 -> 4670;
4671 -> 4157;
4671 -> 4155;
4672 -> 4153;
4672 -> 4187;
4672 -> 4256;
4672 -> 4671;
4672 -> 4265;
4672 -> 4181;
4672 -> 4182;
4672 -> 4657;
4672 -> 4189;
4672 -> 4186;
4673 -> 4201;
4674 -> 4673;
4674 -> 4022;
4675 -> 4674;
4675 -> 4024;
4675 -> 4022;
4676 -> 4220;
4677 -> 4676;
4677 -> 4060;
4678 -> 4677;
4678 -> 4062;
4678 -> 4060;
4679 -> 4058;
4679 -> 4090;
4679 -> 4216;
4679 -> 4678;
4679 -> 4225;
4679 -> 4086;
4679 -> 4087;
4679 -> 4664;
4679 -> 4097;
4679 -> 4089;
4680 -> 4240;
4681 -> 4680;
4681 -> 4109;
4682 -> 4681;
4682 -> 4111;
4682 -> 4109;
4683 -> 4107;
4683 -> 4141;
4683 -> 4236;
4683 -> 4682;
4683 -> 4245;
4683 -> 4135;
4683 -> 4136;
4683 -> 4668;
4683 -> 4143;
4683 -> 4140;
4684 -> 4260;
4685 -> 4684;
4685 -> 4155;
4686 -> 4685;
4686 -> 4157;
4686 -> 4155;
4687 -> 4153;
4687 -> 4187;
4687 -> 4256;
4687 -> 4686;
4687 -> 4265;
4687 -> 4181;
4687 -> 4182;
4687 -> 4672;
4687 -> 4189;
4687 -> 4186;
4688 -> 0;
4688 -> 4201;
4689 -> 4688;
4689 -> 4022;
4690 -> 4689;
4690 -> 4024;
4690 -> 4022;
4691 -> 0;
4691 -> 4220;
4692 -> 4691;
4692 -> 4060;
4693 -> 4692;
4693 -> 4062;
4693 -> 4060;
4694 -> 4058;
4694 -> 4090;
4694 -> 4216;
4694 -> 4693;
4694 -> 4225;
4694 -> 4086;
4694 -> 4087;
4694 -> 4679;
4694 -> 4097;
4694 -> 4089;
4695 -> 0;
4695 -> 4240;
4696 -> 4695;
4696 -> 4109;
4697 -> 4696;
4697 -> 4111;
4697 -> 4109;
4698 -> 4107;
4698 -> 4141;
4698 -> 4236;
4698 -> 4697;
4698 -> 4245;
4698 -> 4135;
4698 -> 4136;
4698 -> 4683;
4698 -> 4143;
4698 -> 4140;
4699 -> 0;
4699 -> 4260;
4700 -> 4699;
4700 -> 4155;
4701 -> 4700;
4701 -> 4157;
4701 -> 4155;
4702 -> 4153;
4702 -> 4187;
4702 -> 4256;
4702 -> 4701;
4702 -> 4265;
4702 -> 4181;
4702 -> 4182;
4702 -> 4687;
4702 -> 4189;
4702 -> 4186;
4703 -> 4201;
4704 -> 4703;
4704 -> 4022;
4705 -> 4704;
4705 -> 4024;
4705 -> 4022;
4706 -> 4220;
4707 -> 4706;
4707 -> 4060;
4708 -> 4707;
4708 -> 4062;
4708 -> 4060;
4709 -> 4058;
4709 -> 4090;
4709 -> 4216;
4709 -> 4708;
4709 -> 4225;
4709 -> 4086;
4709 -> 4087;
4709 -> 4694;
4709 -> 4097;
4709 -> 4089;
4710 -> 4240;
4711 -> 4710;
4711 -> 4109;
4712 -> 4711;
4712 -> 4111;
4712 -> 4109;
4713 -> 4107;
4713 -> 4141;
4713 -> 4236;
4713 -> 4712;
4713 -> 4245;
4713 -> 4135;
4713 -> 4136;
4713 -> 4698;
4713 -> 4143;
4713 -> 4140;
4714 -> 4260;
4715 -> 4714;
4715 -> 4155;
4716 -> 4715;
4716 -> 4157;
4716 -> 4155;
4717 -> 4153;
4717 -> 4187;
4717 -> 4256;
4717 -> 4716;
4717 -> 4265;
4717 -> 4181;
4717 -> 4182;
4717 -> 4702;
4717 -> 4189;
4717 -> 4186;
4718 -> 4201;
4719 -> 4718;
4719 -> 4022;
4720 -> 4719;
4720 -> 4024;
4720 -> 4022;
4721 -> 4220;
4722 -> 4721;
4722 -> 4060;
4723 -> 4722;
4723 -> 4062;
4723 -> 4060;
4724 -> 4058;
4724 -> 4090;
4724 -> 4216;
4724 -> 4723;
4724 -> 4225;
4724 -> 4086;
4724 -> 4087;
4724 -> 4709;
4724 -> 4097;
4724 -> 4089;
4725 -> 4240;
4726 -> 4725;
4726 -> 4109;
4727 -> 4726;
4727 -> 4111;
4727 -> 4109;
4728 -> 4107;
4728 -> 4141;
4728 -> 4236;
4728 -> 4727;
4728 -> 4245;
4728 -> 4135;
4728 -> 4136;
4728 -> 4713;
4728 -> 4143;
4728 -> 4140;
4729 -> 4260;
4730 -> 4729;
4730 -> 4155;
4731 -> 4730;
4731 -> 4157;
4731 -> 4155;
4732 -> 4153;
4732 -> 4187;
4732 -> 4256;
4732 -> 4731;
4732 -> 4265;
4732 -> 4181;
4732 -> 4182;
4732 -> 4717;
4732 -> 4189;
4732 -> 4186;
4733 -> 4201;
4734 -> 4733;
4734 -> 4022;
4735 -> 4734;
4735 -> 4024;
4735 -> 4022;
4736 -> 4220;
4737 -> 4736;
4737 -> 4060;
4738 -> 4737;
4738 -> 4062;
4738 -> 4060;
4739 -> 4058;
4739 -> 4090;
4739 -> 4216;
4739 -> 4738;
4739 -> 4225;
4739 -> 4086;
4739 -> 4087;
4739 -> 4724;
4739 -> 4097;
4739 -> 4089;
4740 -> 4240;
4741 -> 4740;
4741 -> 4109;
4742 -> 4741;
4742 -> 4111;
4742 -> 4109;
4743 -> 4107;
4743 -> 4141;
4743 -> 4236;
4743 -> 4742;
4743 -> 4245;
4743 -> 4135;
4743 -> 4136;
4743 -> 4728;
4743 -> 4143;
4743 -> 4140;
4744 -> 4260;
4745 -> 4744;
4745 -> 4155;
4746 -> 4745;
4746 -> 4157;
4746 -> 4155;
4747 -> 4153;
4747 -> 4187;
4747 -> 4256;
4747 -> 4746;
4747 -> 4265;
4747 -> 4181;
4747 -> 4182;
4747 -> 4732;
4747 -> 4189;
4747 -> 4186;
4748 -> 4201;
4749 -> 4748;
4749 -> 4022;
4750 -> 4749;
4750 -> 4024;
4750 -> 4022;
4751 -> 4220;
4752 -> 4751;
4752 -> 4060;
4753 -> 4752;
4753 -> 4062;
4753 -> 4060;
4754 -> 4058;
4754 -> 4090;
4754 -> 4216;
4754 -> 4753;
4754 -> 4225;
4754 -> 4086;
4754 -> 4087;
4754 -> 4739;
4754 -> 4097;
4754 -> 4089;
4755 -> 4240;
4756 -> 4755;
4756 -> 4109;
4757 -> 4756;
4757 -> 4111;
4757 -> 4109;
4758 -> 4107;
4758 -> 4141;
4758 -> 4236;
4758 -> 4757;
4758 -> 4245;
4758 -> 4135;
4758 -> 4136;
4758 -> 4743;
4758 -> 4143;
4758 -> 4140;
4759 -> 4260;
4760 -> 4759;
4760 -> 4155;
4761 -> 4760;
4761 -> 4157;
4761 -> 4155;
4762 -> 4153;
4762 -> 4187;
4762 -> 4256;
4762 -> 4761;
4762 -> 4265;
4762 -> 4181;
4762 -> 4182;
4762 -> 4747;
4762 -> 4189;
4762 -> 4186;
4763 -> 4201;
4764 -> 4763;
4764 -> 4022;
4765 -> 4764;
4765 -> 4024;
4765 -> 4022;
4766 -> 4220;
4767 -> 4766;
4767 -> 4060;
4768 -> 4767;
4768 -> 4062;
4768 -> 4060;
4769 -> 4058;
4769 -> 4090;
4769 -> 4216;
4769 -> 4768;
4769 -> 4225;
4769 -> 4086;
4769 -> 4087;
4769 -> 4754;
4769 -> 4097;
4769 -> 4089;
4770 -> 4240;
4771 -> 4770;
4771 -> 4109;
4772 -> 4771;
4772 -> 4111;
4772 -> 4109;
4773 -> 4107;
4773 -> 4141;
4773 -> 4236;
4773 -> 4772;
4773 -> 4245;
4773 -> 4135;
4773 -> 4136;
4773 -> 4758;
4773 -> 4143;
4773 -> 4140;
4774 -> 4260;
4775 -> 4774;
4775 -> 4155;
4776 -> 4775;
4776 -> 4157;
4776 -> 4155;
4777 -> 4153;
4777 -> 4187;
4777 -> 4256;
4777 -> 4776;
4777 -> 4265;
4777 -> 4181;
4777 -> 4182;
4777 -> 4762;
4777 -> 4189;
4777 -> 4186;
4778 -> 4201;
4779 -> 4778;
4779 -> 4022;
4780 -> 4779;
4780 -> 4024;
4780 -> 4022;
4781 -> 4220;
4782 -> 4781;
4782 -> 4060;
4783 -> 4782;
4783 -> 4062;
4783 -> 4060;
4784 -> 4058;
4784 -> 4090;
4784 -> 4216;
4784 -> 4783;
4784 -> 4225;
4784 -> 4086;
4784 -> 4087;
4784 -> 4769;
4784 -> 4097;
4784 -> 4089;
4785 -> 4240;
4786 -> 4785;
4786 -> 4109;
4787 -> 4786;
4787 -> 4111;
4787 -> 4109;
4788 -> 4107;
4788 -> 4141;
4788 -> 4236;
4788 -> 4787;
4788 -> 4245;
4788 -> 4135;
4788 -> 4136;
4788 -> 4773;
4788 -> 4143;
4788 -> 4140;
4789 -> 4260;
4790 -> 4789;
4790 -> 4155;
4791 -> 4790;
4791 -> 4157;
4791 -> 4155;
4792 -> 4153;
4792 -> 4187;
4792 -> 4256;
4792 -> 4791;
4792 -> 4265;
4792 -> 4181;
4792 -> 4182;
4792 -> 4777;
4792 -> 4189;
4792 -> 4186;
4793 -> 4201;
4794 -> 4793;
4794 -> 4022;
4795 -> 4794;
4795 -> 4024;
4795 -> 4022;
4796 -> 4220;
4797 -> 4796;
4797 -> 4060;
4798 -> 4797;
4798 -> 4062;
4798 -> 4060;
4799 -> 4058;
4799 -> 4090;
4799 -> 4216;
4799 -> 4798;
4799 -> 4225;
4799 -> 4086;
4799 -> 4087;
4799 -> 4784;
4799 -> 4097;
4799 -> 4089;
4800 -> 4240;
4801 -> 4800;
4801 -> 4109;
4802 -> 4801;
4802 -> 4111;
4802 -> 4109;
4803 -> 4107;
4803 -> 4141;
4803 -> 4236;
4803 -> 4802;
4803 -> 4245;
4803 -> 4135;
4803 -> 4136;
4803 -> 4788;
4803 -> 4143;
4803 -> 4140;
4804 -> 4260;
4805 -> 4804;
4805 -> 4155;
4806 -> 4805;
4806 -> 4157;
4806 -> 4155;
4807 -> 4153;
4807 -> 4187;
4807 -> 4256;
4807 -> 4806;
4807 -> 4265;
4807 -> 4181;
4807 -> 4182;
4807 -> 4792;
4807 -> 4189;
4807 -> 4186;
4808 -> 4201;
4809 -> 4808;
4809 -> 4022;
4810 -> 4809;
4810 -> 4024;
4810 -> 4022;
4811 -> 4220;
4812 -> 4811;
4812 -> 4060;
4813 -> 4812;
4813 -> 4062;
4813 -> 4060;
4814 -> 4058;
4814 -> 4090;
4814 -> 4216;
4814 -> 4813;
4814 -> 4225;
4814 -> 4086;
4814 -> 4087;
4814 -> 4799;
4814 -> 4097;
4814 -> 4089;
4815 -> 4240;
4816 -> 4815;
4816 -> 4109;
4817 -> 4816;
4817 -> 4111;
4817 -> 4109;
4818 -> 4107;
4818 -> 4141;
4818 -> 4236;
4818 -> 4817;
4818 -> 4245;
4818 -> 4135;
4818 -> 4136;
4818 -> 4803;
4818 -> 4143;
4818 -> 4140;
4819 -> 4260;
4820 -> 4819;
4820 -> 4155;
4821 -> 4820;
4821 -> 4157;
4821 -> 4155;
4822 -> 4153;
4822 -> 4187;
4822 -> 4256;
4822 -> 4821;
4822 -> 4265;
4822 -> 4181;
4822 -> 4182;
4822 -> 4807;
4822 -> 4189;
4822 -> 4186;
4823 -> 4201;
4824 -> 4823;
4824 -> 4022;
4825 -> 4824;
4825 -> 4024;
4825 -> 4022;
4826 -> 4220;
4827 -> 4826;
4827 -> 4060;
4828 -> 4827;
4828 -> 4062;
4828 -> 4060;
4829 -> 4058;
4829 -> 4090;
4829 -> 4216;
4829 -> 4828;
4829 -> 4225;
4829 -> 4086;
4829 -> 4087;
4829 -> 4814;
4829 -> 4097;
4829 -> 4089;
4830 -> 4240;
4831 -> 4830;
4831 -> 4109;
4832 -> 4831;
4832 -> 4111;
4832 -> 4109;
4833 -> 4107;
4833 -> 4141;
4833 -> 4236;
4833 -> 4832;
4833 -> 4245;
4833 -> 4135;
4833 -> 4136;
4833 -> 4818;
4833 -> 4143;
4833 -> 4140;
4834 -> 4260;
4835 -> 4834;
4835 -> 4155;
4836 -> 4835;
4836 -> 4157;
4836 -> 4155;
4837 -> 4153;
4837 -> 4187;
4837 -> 4256;
4837 -> 4836;
4837 -> 4265;
4837 -> 4181;
4837 -> 4182;
4837 -> 4822;
4837 -> 4189;
4837 -> 4186;
4838 -> 4201;
4839 -> 4838;
4839 -> 4022;
4840 -> 4839;
4840 -> 4024;
4840 -> 4022;
4841 -> 4220;
4842 -> 4841;
4842 -> 4060;
4843 -> 4842;
4843 -> 4062;
4843 -> 4060;
4844 -> 4058;
4844 -> 4090;
4844 -> 4216;
4844 -> 4843;
4844 -> 4225;
4844 -> 4086;
4844 -> 4087;
4844 -> 4829;
4844 -> 4097;
4844 -> 4089;
4845 -> 4240;
4846 -> 4845;
4846 -> 4109;
4847 -> 4846;
4847 -> 4111;
4847 -> 4109;
4848 -> 4107;
4848 -> 4141;
4848 -> 4236;
4848 -> 4847;
4848 -> 4245;
4848 -> 4135;
4848 -> 4136;
4848 -> 4833;
4848 -> 4143;
4848 -> 4140;
4849 -> 4260;
4850 -> 4849;
4850 -> 4155;
4851 -> 4850;
4851 -> 4157;
4851 -> 4155;
4852 -> 4153;
4852 -> 4187;
4852 -> 4256;
4852 -> 4851;
4852 -> 4265;
4852 -> 4181;
4852 -> 4182;
4852 -> 4837;
4852 -> 4189;
4852 -> 4186;
4853 -> 4201;
4854 -> 4853;
4854 -> 4022;
4855 -> 4854;
4855 -> 4024;
4855 -> 4022;
4856 -> 4220;
4857 -> 4856;
4857 -> 4060;
4858 -> 4857;
4858 -> 4062;
4858 -> 4060;
4859 -> 4058;
4859 -> 4090;
4859 -> 4216;
4859 -> 4858;
4859 -> 4225;
4859 -> 4086;
4859 -> 4087;
4859 -> 4844;
4859 -> 4097;
4859 -> 4089;
4860 -> 4240;
4861 -> 4860;
4861 -> 4109;
4862 -> 4861;
4862 -> 4111;
4862 -> 4109;
4863 -> 4107;
4863 -> 4141;
4863 -> 4236;
4863 -> 4862;
4863 -> 4245;
4863 -> 4135;
4863 -> 4136;
4863 -> 4848;
4863 -> 4143;
4863 -> 4140;
4864 -> 4260;
4865 -> 4864;
4865 -> 4155;
4866 -> 4865;
4866 -> 4157;
4866 -> 4155;
4867 -> 4153;
4867 -> 4187;
4867 -> 4256;
4867 -> 4866;
4867 -> 4265;
4867 -> 4181;
4867 -> 4182;
4867 -> 4852;
4867 -> 4189;
4867 -> 4186;
4868 -> 4201;
4869 -> 4868;
4869 -> 4022;
4870 -> 4869;
4870 -> 4024;
4870 -> 4022;
4871 -> 4220;
4872 -> 4871;
4872 -> 4060;
4873 -> 4872;
4873 -> 4062;
4873 -> 4060;
4874 -> 4058;
4874 -> 4090;
4874 -> 4216;
4874 -> 4873;
4874 -> 4225;
4874 -> 4086;
4874 -> 4087;
4874 -> 4859;
4874 -> 4097;
4874 -> 4089;
4875 -> 4240;
4876 -> 4875;
4876 -> 4109;
4877 -> 4876;
4877 -> 4111;
4877 -> 4109;
4878 -> 4107;
4878 -> 4141;
4878 -> 4236;
4878 -> 4877;
4878 -> 4245;
4878 -> 4135;
4878 -> 4136;
4878 -> 4863;
4878 -> 4143;
4878 -> 4140;
4879 -> 4260;
4880 -> 4879;
4880 -> 4155;
4881 -> 4880;
4881 -> 4157;
4881 -> 4155;
4882 -> 4153;
4882 -> 4187;
4882 -> 4256;
4882 -> 4881;
4882 -> 4265;
4882 -> 4181;
4882 -> 4182;
4882 -> 4867;
4882 -> 4189;
4882 -> 4186;
4883 -> 4201;
4884 -> 4883;
4884 -> 4022;
4885 -> 4884;
4885 -> 4024;
4885 -> 4022;
4886 -> 4220;
4887 -> 4886;
4887 -> 4060;
4888 -> 4887;
4888 -> 4062;
4888 -> 4060;
4889 -> 4058;
4889 -> 4090;
4889 -> 4216;
4889 -> 4888;
4889 -> 4225;
4889 -> 4086;
4889 -> 4087;
4889 -> 4874;
4889 -> 4097;
4889 -> 4089;
4890 -> 4240;
4891 -> 4890;
4891 -> 4109;
4892 -> 4891;
4892 -> 4111;
4892 -> 4109;
4893 -> 4107;
4893 -> 4141;
4893 -> 4236;
4893 -> 4892;
4893 -> 4245;
4893 -> 4135;
4893 -> 4136;
4893 -> 4878;
4893 -> 4143;
4893 -> 4140;
4894 -> 4260;
4895 -> 4894;
4895 -> 4155;
4896 -> 4895;
4896 -> 4157;
4896 -> 4155;
4897 -> 4153;
4897 -> 4187;
4897 -> 4256;
4897 -> 4896;
4897 -> 4265;
4897 -> 4181;
4897 -> 4182;
4897 -> 4882;
4897 -> 4189;
4897 -> 4186;
4898 -> 4201;
4899 -> 4898;
4899 -> 4022;
4900 -> 4899;
4900 -> 4024;
4900 -> 4022;
4901 -> 4220;
4902 -> 4901;
4902 -> 4060;
4903 -> 4902;
4903 -> 4062;
4903 -> 4060;
4904 -> 4058;
4904 -> 4090;
4904 -> 4216;
4904 -> 4903;
4904 -> 4225;
4904 -> 4086;
4904 -> 4087;
4904 -> 4889;
4904 -> 4097;
4904 -> 4089;
4905 -> 4240;
4906 -> 4905;
4906 -> 4109;
4907 -> 4906;
4907 -> 4111;
4907 -> 4109;
4908 -> 4107;
4908 -> 4141;
4908 -> 4236;
4908 -> 4907;
4908 -> 4245;
4908 -> 4135;
4908 -> 4136;
4908 -> 4893;
4908 -> 4143;
4908 -> 4140;
4909 -> 4260;
4910 -> 4909;
4910 -> 4155;
4911 -> 4910;
4911 -> 4157;
4911 -> 4155;
4912 -> 4153;
4912 -> 4187;
4912 -> 4256;
4912 -> 4911;
4912 -> 4265;
4912 -> 4181;
4912 -> 4182;
4912 -> 4897;
4912 -> 4189;
4912 -> 4186;
4913 -> 4201;
4914 -> 4913;
4914 -> 4022;
4915 -> 4914;
4915 -> 4024;
4915 -> 4022;
4916 -> 4220;
4917 -> 4916;
4917 -> 4060;
4918 -> 4917;
4918 -> 4062;
4918 -> 4060;
4919 -> 4058;
4919 -> 4090;
4919 -> 4216;
4919 -> 4918;
4919 -> 4225;
4919 -> 4086;
4919 -> 4087;
4919 -> 4904;
4919 -> 4097;
4919 -> 4089;
4920 -> 4240;
4921 -> 4920;
4921 -> 4109;
4922 -> 4921;
4922 -> 4111;
4922 -> 4109;
4923 -> 4107;
4923 -> 4141;
4923 -> 4236;
4923 -> 4922;
4923 -> 4245;
4923 -> 4135;
4923 -> 4136;
4923 -> 4908;
4923 -> 4143;
4923 -> 4140;
4924 -> 4260;
4925 -> 4924;
4925 -> 4155;
4926 -> 4925;
4926 -> 4157;
4926 -> 4155;
4927 -> 4153;
4927 -> 4187;
4927 -> 4256;
4927 -> 4926;
4927 -> 4265;
4927 -> 4181;
4927 -> 4182;
4927 -> 4912;
4927 -> 4189;
4927 -> 4186;
4928 -> 4201;
4929 -> 4928;
4929 -> 4022;
4930 -> 4929;
4930 -> 4024;
4930 -> 4022;
4931 -> 4220;
4932 -> 4931;
4932 -> 4060;
4933 -> 4932;
4933 -> 4062;
4933 -> 4060;
4934 -> 4058;
4934 -> 4090;
4934 -> 4216;
4934 -> 4933;
4934 -> 4225;
4934 -> 4086;
4934 -> 4087;
4934 -> 4919;
4934 -> 4097;
4934 -> 4089;
4935 -> 4240;
4936 -> 4935;
4936 -> 4109;
4937 -> 4936;
4937 -> 4111;
4937 -> 4109;
4938 -> 4107;
4938 -> 4141;
4938 -> 4236;
4938 -> 4937;
4938 -> 4245;
4938 -> 4135;
4938 -> 4136;
4938 -> 4923;
4938 -> 4143;
4938 -> 4140;
4939 -> 4260;
4940 -> 4939;
4940 -> 4155;
4941 -> 4940;
4941 -> 4157;
4941 -> 4155;
4942 -> 4153;
4942 -> 4187;
4942 -> 4256;
4942 -> 4941;
4942 -> 4265;
4942 -> 4181;
4942 -> 4182;
4942 -> 4927;
4942 -> 4189;
4942 -> 4186;
4943 -> 4201;
4944 -> 4943;
4944 -> 4022;
4945 -> 4944;
4945 -> 4024;
4945 -> 4022;
4946 -> 4220;
4947 -> 4946;
4947 -> 4060;
4948 -> 4947;
4948 -> 4062;
4948 -> 4060;
4949 -> 4058;
4949 -> 4090;
4949 -> 4216;
4949 -> 4948;
4949 -> 4225;
4949 -> 4086;
4949 -> 4087;
4949 -> 4934;
4949 -> 4097;
4949 -> 4089;
4950 -> 4240;
4951 -> 4950;
4951 -> 4109;
4952 -> 4951;
4952 -> 4111;
4952 -> 4109;
4953 -> 4107;
4953 -> 4141;
4953 -> 4236;
4953 -> 4952;
4953 -> 4245;
4953 -> 4135;
4953 -> 4136;
4953 -> 4938;
4953 -> 4143;
4953 -> 4140;
4954 -> 4260;
4955 -> 4954;
4955 -> 4155;
4956 -> 4955;
4956 -> 4157;
4956 -> 4155;
4957 -> 4153;
4957 -> 4187;
4957 -> 4256;
4957 -> 4956;
4957 -> 4265;
4957 -> 4181;
4957 -> 4182;
4957 -> 4942;
4957 -> 4189;
4957 -> 4186;
4958 -> 4201;
4959 -> 4958;
4959 -> 4022;
4960 -> 4959;
4960 -> 4024;
4960 -> 4022;
4961 -> 4220;
4962 -> 4961;
4962 -> 4060;
4963 -> 4962;
4963 -> 4062;
4963 -> 4060;
4964 -> 4058;
4964 -> 4090;
4964 -> 4216;
4964 -> 4963;
4964 -> 4225;
4964 -> 4086;
4964 -> 4087;
4964 -> 4949;
4964 -> 4097;
4964 -> 4089;
4965 -> 4240;
4966 -> 4965;
4966 -> 4109;
4967 -> 4966;
4967 -> 4111;
4967 -> 4109;
4968 -> 4107;
4968 -> 4141;
4968 -> 4236;
4968 -> 4967;
4968 -> 4245;
4968 -> 4135;
4968 -> 4136;
4968 -> 4953;
4968 -> 4143;
4968 -> 4140;
4969 -> 4260;
4970 -> 4969;
4970 -> 4155;
4971 -> 4970;
4971 -> 4157;
4971 -> 4155;
4972 -> 4153;
4972 -> 4187;
4972 -> 4256;
4972 -> 4971;
4972 -> 4265;
4972 -> 4181;
4972 -> 4182;
4972 -> 4957;
4972 -> 4189;
4972 -> 4186;
4973 -> 4201;
4974 -> 4973;
4974 -> 4022;
4975 -> 4974;
4975 -> 4024;
4975 -> 4022;
4976 -> 4220;
4977 -> 4976;
4977 -> 4060;
4978 -> 4977;
4978 -> 4062;
4978 -> 4060;
4979 -> 4058;
4979 -> 4090;
4979 -> 4216;
4979 -> 4978;
4979 -> 4225;
4979 -> 4086;
4979 -> 4087;
4979 -> 4964;
4979 -> 4097;
4979 -> 4089;
4980 -> 4240;
4981 -> 4980;
4981 -> 4109;
4982 -> 4981;
4982 -> 4111;
4982 -> 4109;
4983 -> 4107;
4983 -> 4141;
4983 -> 4236;
4983 -> 4982;
4983 -> 4245;
4983 -> 4135;
4983 -> 4136;
4983 -> 4968;
4983 -> 4143;
4983 -> 4140;
4984 -> 4260;
4985 -> 4984;
4985 -> 4155;
4986 -> 4985;
4986 -> 4157;
4986 -> 4155;
4987 -> 4153;
4987 -> 4187;
4987 -> 4256;
4987 -> 4986;
4987 -> 4265;
4987 -> 4181;
4987 -> 4182;
4987 -> 4972;
4987 -> 4189;
4987 -> 4186;
4988 -> 4201;
4989 -> 4988;
4989 -> 4022;
4990 -> 4989;
4990 -> 4024;
4990 -> 4022;
4991 -> 4220;
4992 -> 4991;
4992 -> 4060;
4993 -> 4992;
4993 -> 4062;
4993 -> 4060;
4994 -> 4058;
4994 -> 4090;
4994 -> 4216;
4994 -> 4993;
4994 -> 4225;
4994 -> 4086;
4994 -> 4087;
4994 -> 4979;
4994 -> 4097;
4994 -> 4089;
4995 -> 4240;
4996 -> 4995;
4996 -> 4109;
4997 -> 4996;
4997 -> 4111;
4997 -> 4109;
4998 -> 4107;
4998 -> 4141;
4998 -> 4236;
4998 -> 4997;
4998 -> 4245;
4998 -> 4135;
4998 -> 4136;
4998 -> 4983;
4998 -> 4143;
4998 -> 4140;
4999 -> 4260;
5000 -> 4999;
5000 -> 4155;
5001 -> 5000;
5001 -> 4157;
5001 -> 4155;
5002 -> 4153;
5002 -> 4187;
5002 -> 4256;
5002 -> 5001;
5002 -> 4265;
5002 -> 4181;
5002 -> 4182;
5002 -> 4987;
5002 -> 4189;
5002 -> 4186;
5003 -> 4201;
5004 -> 5003;
5004 -> 4022;
5005 -> 5004;
5005 -> 4024;
5005 -> 4022;
5006 -> 4220;
5007 -> 5006;
5007 -> 4060;
5008 -> 5007;
5008 -> 4062;
5008 -> 4060;
5009 -> 4058;
5009 -> 4090;
5009 -> 4216;
5009 -> 5008;
5009 -> 4225;
5009 -> 4086;
5009 -> 4087;
5009 -> 4994;
5009 -> 4097;
5009 -> 4089;
5010 -> 4240;
5011 -> 5010;
5011 -> 4109;
5012 -> 5011;
5012 -> 4111;
5012 -> 4109;
5013 -> 4107;
5013 -> 4141;
5013 -> 4236;
5013 -> 5012;
5013 -> 4245;
5013 -> 4135;
5013 -> 4136;
5013 -> 4998;
5013 -> 4143;
5013 -> 4140;
5014 -> 4260;
5015 -> 5014;
5015 -> 4155;
5016 -> 5015;
5016 -> 4157;
5016 -> 4155;
5017 -> 4153;
5017 -> 4187;
5017 -> 4256;
5017 -> 5016;
5017 -> 4265;
5017 -> 4181;
5017 -> 4182;
5017 -> 5002;
5017 -> 4189;
5017 -> 4186;
5018 -> 4201;
5019 -> 5018;
5019 -> 4022;
5020 -> 5019;
5020 -> 4024;
5020 -> 4022;
5021 -> 4220;
5022 -> 5021;
5022 -> 4060;
5023 -> 5022;
5023 -> 4062;
5023 -> 4060;
5024 -> 4058;
5024 -> 4090;
5024 -> 4216;
5024 -> 5023;
5024 -> 4225;
5024 -> 4086;
5024 -> 4087;
5024 -> 5009;
5024 -> 4097;
5024 -> 4089;
5025 -> 4240;
5026 -> 5025;
5026 -> 4109;
5027 -> 5026;
5027 -> 4111;
5027 -> 4109;
5028 -> 4107;
5028 -> 4141;
5028 -> 4236;
5028 -> 5027;
5028 -> 4245;
5028 -> 4135;
5028 -> 4136;
5028 -> 5013;
5028 -> 4143;
5028 -> 4140;
5029 -> 4260;
5030 -> 5029;
5030 -> 4155;
5031 -> 5030;
5031 -> 4157;
5031 -> 4155;
5032 -> 4153;
5032 -> 4187;
5032 -> 4256;
5032 -> 5031;
5032 -> 4265;
5032 -> 4181;
5032 -> 4182;
5032 -> 5017;
5032 -> 4189;
5032 -> 4186;
5033 -> 4201;
5034 -> 5033;
5034 -> 4022;
5035 -> 5034;
5035 -> 4024;
5035 -> 4022;
5036 -> 4220;
5037 -> 5036;
5037 -> 4060;
5038 -> 5037;
5038 -> 4062;
5038 -> 4060;
5039 -> 4058;
5039 -> 4090;
5039 -> 4216;
5039 -> 5038;
5039 -> 4225;
5039 -> 4086;
5039 -> 4087;
5039 -> 5024;
5039 -> 4097;
5039 -> 4089;
5040 -> 4240;
5041 -> 5040;
5041 -> 4109;
5042 -> 5041;
5042 -> 4111;
5042 -> 4109;
5043 -> 4107;
5043 -> 4141;
5043 -> 4236;
5043 -> 5042;
5043 -> 4245;
5043 -> 4135;
5043 -> 4136;
5043 -> 5028;
5043 -> 4143;
5043 -> 4140;
5044 -> 4260;
5045 -> 5044;
5045 -> 4155;
5046 -> 5045;
5046 -> 4157;
5046 -> 4155;
5047 -> 4153;
5047 -> 4187;
5047 -> 4256;
5047 -> 5046;
5047 -> 4265;
5047 -> 4181;
5047 -> 4182;
5047 -> 5032;
5047 -> 4189;
5047 -> 4186;
5048 -> 4201;
5049 -> 5048;
5049 -> 4022;
5050 -> 5049;
5050 -> 4024;
5050 -> 4022;
5051 -> 4220;
5052 -> 5051;
5052 -> 4060;
5053 -> 5052;
5053 -> 4062;
5053 -> 4060;
5054 -> 4058;
5054 -> 4090;
5054 -> 4216;
5054 -> 5053;
5054 -> 4225;
5054 -> 4086;
5054 -> 4087;
5054 -> 5039;
5054 -> 4097;
5054 -> 4089;
5055 -> 4240;
5056 -> 5055;
5056 -> 4109;
5057 -> 5056;
5057 -> 4111;
5057 -> 4109;
5058 -> 4107;
5058 -> 4141;
5058 -> 4236;
5058 -> 5057;
5058 -> 4245;
5058 -> 4135;
5058 -> 4136;
5058 -> 5043;
5058 -> 4143;
5058 -> 4140;
5059 -> 4260;
5060 -> 5059;
5060 -> 4155;
5061 -> 5060;
5061 -> 4157;
5061 -> 4155;
5062 -> 4153;
5062 -> 4187;
5062 -> 4256;
5062 -> 5061;
5062 -> 4265;
5062 -> 4181;
5062 -> 4182;
5062 -> 5047;
5062 -> 4189;
5062 -> 4186;
5063 -> 4201;
5064 -> 5063;
5064 -> 4022;
5065 -> 5064;
5065 -> 4024;
5065 -> 4022;
5066 -> 4220;
5067 -> 5066;
5067 -> 4060;
5068 -> 5067;
5068 -> 4062;
5068 -> 4060;
5069 -> 4058;
5069 -> 4090;
5069 -> 4216;
5069 -> 5068;
5069 -> 4225;
5069 -> 4086;
5069 -> 4087;
5069 -> 5054;
5069 -> 4097;
5069 -> 4089;
5070 -> 4240;
5071 -> 5070;
5071 -> 4109;
5072 -> 5071;
5072 -> 4111;
5072 -> 4109;
5073 -> 4107;
5073 -> 4141;
5073 -> 4236;
5073 -> 5072;
5073 -> 4245;
5073 -> 4135;
5073 -> 4136;
5073 -> 5058;
5073 -> 4143;
5073 -> 4140;
5074 -> 4260;
5075 -> 5074;
5075 -> 4155;
5076 -> 5075;
5076 -> 4157;
5076 -> 4155;
5077 -> 4153;
5077 -> 4187;
5077 -> 4256;
5077 -> 5076;
5077 -> 4265;
5077 -> 4181;
5077 -> 4182;
5077 -> 5062;
5077 -> 4189;
5077 -> 4186;
5078 -> 4201;
5079 -> 5078;
5079 -> 4022;
5080 -> 5079;
5080 -> 4024;
5080 -> 4022;
5081 -> 4220;
5082 -> 5081;
5082 -> 4060;
5083 -> 5082;
5083 -> 4062;
5083 -> 4060;
5084 -> 4058;
5084 -> 4090;
5084 -> 4216;
5084 -> 5083;
5084 -> 4225;
5084 -> 4086;
5084 -> 4087;
5084 -> 5069;
5084 -> 4097;
5084 -> 4089;
5085 -> 4240;
5086 -> 5085;
5086 -> 4109;
5087 -> 5086;
5087 -> 4111;
5087 -> 4109;
5088 -> 4107;
5088 -> 4141;
5088 -> 4236;
5088 -> 5087;
5088 -> 4245;
5088 -> 4135;
5088 -> 4136;
5088 -> 5073;
5088 -> 4143;
5088 -> 4140;
5089 -> 4260;
5090 -> 5089;
5090 -> 4155;
5091 -> 5090;
5091 -> 4157;
5091 -> 4155;
5092 -> 4153;
5092 -> 4187;
5092 -> 4256;
5092 -> 5091;
5092 -> 4265;
5092 -> 4181;
5092 -> 4182;
5092 -> 5077;
5092 -> 4189;
5092 -> 4186;
5093 -> 4201;
5094 -> 5093;
5094 -> 4022;
5095 -> 5094;
5095 -> 4024;
5095 -> 4022;
5096 -> 4220;
5097 -> 5096;
5097 -> 4060;
5098 -> 5097;
5098 -> 4062;
5098 -> 4060;
5099 -> 4058;
5099 -> 4090;
5099 -> 4216;
5099 -> 5098;
5099 -> 4225;
5099 -> 4086;
5099 -> 4087;
5099 -> 5084;
5099 -> 4097;
5099 -> 4089;
5100 -> 4240;
5101 -> 5100;
5101 -> 4109;
5102 -> 5101;
5102 -> 4111;
5102 -> 4109;
5103 -> 4107;
5103 -> 4141;
5103 -> 4236;
5103 -> 5102;
5103 -> 4245;
5103 -> 4135;
5103 -> 4136;
5103 -> 5088;
5103 -> 4143;
5103 -> 4140;
5104 -> 4260;
5105 -> 5104;
5105 -> 4155;
5106 -> 5105;
5106 -> 4157;
5106 -> 4155;
5107 -> 4153;
5107 -> 4187;
5107 -> 4256;
5107 -> 5106;
5107 -> 4265;
5107 -> 4181;
5107 -> 4182;
5107 -> 5092;
5107 -> 4189;
5107 -> 4186;
5108 -> 4201;
5109 -> 5108;
5109 -> 4022;
5110 -> 5109;
5110 -> 4024;
5110 -> 4022;
5111 -> 4220;
5112 -> 5111;
5112 -> 4060;
5113 -> 5112;
5113 -> 4062;
5113 -> 4060;
5114 -> 4058;
5114 -> 4090;
5114 -> 4216;
5114 -> 5113;
5114 -> 4225;
5114 -> 4086;
5114 -> 4087;
5114 -> 5099;
5114 -> 4097;
5114 -> 4089;
5115 -> 4240;
5116 -> 5115;
5116 -> 4109;
5117 -> 5116;
5117 -> 4111;
5117 -> 4109;
5118 -> 4107;
5118 -> 4141;
5118 -> 4236;
5118 -> 5117;
5118 -> 4245;
5118 -> 4135;
5118 -> 4136;
5118 -> 5103;
5118 -> 4143;
5118 -> 4140;
5119 -> 4260;
5120 -> 5119;
5120 -> 4155;
5121 -> 5120;
5121 -> 4157;
5121 -> 4155;
5122 -> 4153;
5122 -> 4187;
5122 -> 4256;
5122 -> 5121;
5122 -> 4265;
5122 -> 4181;
5122 -> 4182;
5122 -> 5107;
5122 -> 4189;
5122 -> 4186;
5123 -> 4201;
5124 -> 5123;
5124 -> 4022;
5125 -> 5124;
5125 -> 4024;
5125 -> 4022;
5126 -> 4220;
5127 -> 5126;
5127 -> 4060;
5128 -> 5127;
5128 -> 4062;
5128 -> 4060;
5129 -> 4058;
5129 -> 4090;
5129 -> 4216;
5129 -> 5128;
5129 -> 4225;
5129 -> 4086;
5129 -> 4087;
5129 -> 5114;
5129 -> 4097;
5129 -> 4089;
5130 -> 4240;
5131 -> 5130;
5131 -> 4109;
5132 -> 5131;
5132 -> 4111;
5132 -> 4109;
5133 -> 4107;
5133 -> 4141;
5133 -> 4236;
5133 -> 5132;
5133 -> 4245;
5133 -> 4135;
5133 -> 4136;
5133 -> 5118;
5133 -> 4143;
5133 -> 4140;
5134 -> 4260;
5135 -> 5134;
5135 -> 4155;
5136 -> 5135;
5136 -> 4157;
5136 -> 4155;
5137 -> 4153;
5137 -> 4187;
5137 -> 4256;
5137 -> 5136;
5137 -> 4265;
5137 -> 4181;
5137 -> 4182;
5137 -> 5122;
5137 -> 4189;
5137 -> 4186;
5138 -> 4201;
5139 -> 5138;
5139 -> 4022;
5140 -> 5139;
5140 -> 4024;
5140 -> 4022;
5141 -> 4220;
5142 -> 5141;
5142 -> 4060;
5143 -> 5142;
5143 -> 4062;
5143 -> 4060;
5144 -> 4058;
5144 -> 4090;
5144 -> 4216;
5144 -> 5143;
5144 -> 4225;
5144 -> 4086;
5144 -> 4087;
5144 -> 5129;
5144 -> 4097;
5144 -> 4089;
5145 -> 4240;
5146 -> 5145;
5146 -> 4109;
5147 -> 5146;
5147 -> 4111;
5147 -> 4109;
5148 -> 4107;
5148 -> 4141;
5148 -> 4236;
5148 -> 5147;
5148 -> 4245;
5148 -> 4135;
5148 -> 4136;
5148 -> 5133;
5148 -> 4143;
5148 -> 4140;
5149 -> 4260;
5150 -> 5149;
5150 -> 4155;
5151 -> 5150;
5151 -> 4157;
5151 -> 4155;
5152 -> 4153;
5152 -> 4187;
5152 -> 4256;
5152 -> 5151;
5152 -> 4265;
5152 -> 4181;
5152 -> 4182;
5152 -> 5137;
5152 -> 4189;
5152 -> 4186;
5153 -> 4201;
5154 -> 5153;
5154 -> 4022;
5155 -> 5154;
5155 -> 4024;
5155 -> 4022;
5156 -> 4220;
5157 -> 5156;
5157 -> 4060;
5158 -> 5157;
5158 -> 4062;
5158 -> 4060;
5159 -> 4058;
5159 -> 4090;
5159 -> 4216;
5159 -> 5158;
5159 -> 4225;
5159 -> 4086;
5159 -> 4087;
5159 -> 5144;
5159 -> 4097;
5159 -> 4089;
5160 -> 4240;
5161 -> 5160;
5161 -> 4109;
5162 -> 5161;
5162 -> 4111;
5162 -> 4109;
5163 -> 4107;
5163 -> 4141;
5163 -> 4236;
5163 -> 5162;
5163 -> 4245;
5163 -> 4135;
5163 -> 4136;
5163 -> 5148;
5163 -> 4143;
5163 -> 4140;
5164 -> 4260;
5165 -> 5164;
5165 -> 4155;
5166 -> 5165;
5166 -> 4157;
5166 -> 4155;
5167 -> 4153;
5167 -> 4187;
5167 -> 4256;
5167 -> 5166;
5167 -> 4265;
5167 -> 4181;
5167 -> 4182;
5167 -> 5152;
5167 -> 4189;
5167 -> 4186;
5168 -> 4201;
5169 -> 5168;
5169 -> 4022;
5170 -> 5169;
5170 -> 4024;
5170 -> 4022;
5171 -> 4220;
5172 -> 5171;
5172 -> 4060;
5173 -> 5172;
5173 -> 4062;
5173 -> 4060;
5174 -> 4058;
5174 -> 4090;
5174 -> 4216;
5174 -> 5173;
5174 -> 4225;
5174 -> 4086;
5174 -> 4087;
5174 -> 5159;
5174 -> 4097;
5174 -> 4089;
5175 -> 4240;
5176 -> 5175;
5176 -> 4109;
5177 -> 5176;
5177 -> 4111;
5177 -> 4109;
5178 -> 4107;
5178 -> 4141;
5178 -> 4236;
5178 -> 5177;
5178 -> 4245;
5178 -> 4135;
5178 -> 4136;
5178 -> 5163;
5178 -> 4143;
5178 -> 4140;
5179 -> 4260;
5180 -> 5179;
5180 -> 4155;
5181 -> 5180;
5181 -> 4157;
5181 -> 4155;
5182 -> 4153;
5182 -> 4187;
5182 -> 4256;
5182 -> 5181;
5182 -> 4265;
5182 -> 4181;
5182 -> 4182;
5182 -> 5167;
5182 -> 4189;
5182 -> 4186;
5183 -> 4201;
5184 -> 5183;
5184 -> 4022;
5185 -> 5184;
5185 -> 4024;
5185 -> 4022;
5186 -> 4220;
5187 -> 5186;
5187 -> 4060;
5188 -> 5187;
5188 -> 4062;
5188 -> 4060;
5189 -> 4058;
5189 -> 4090;
5189 -> 4216;
5189 -> 5188;
5189 -> 4225;
5189 -> 4086;
5189 -> 4087;
5189 -> 5174;
5189 -> 4097;
5189 -> 4089;
5190 -> 4240;
5191 -> 5190;
5191 -> 4109;
5192 -> 5191;
5192 -> 4111;
5192 -> 4109;
5193 -> 4107;
5193 -> 4141;
5193 -> 4236;
5193 -> 5192;
5193 -> 4245;
5193 -> 4135;
5193 -> 4136;
5193 -> 5178;
5193 -> 4143;
5193 -> 4140;
5194 -> 4260;
5195 -> 5194;
5195 -> 4155;
5196 -> 5195;
5196 -> 4157;
5196 -> 4155;
5197 -> 4153;
5197 -> 4187;
5197 -> 4256;
5197 -> 5196;
5197 -> 4265;
5197 -> 4181;
5197 -> 4182;
5197 -> 5182;
5197 -> 4189;
5197 -> 4186;
5198 -> 4201;
5199 -> 5198;
5199 -> 4022;
5200 -> 5199;
5200 -> 4024;
5200 -> 4022;
5201 -> 4220;
5202 -> 5201;
5202 -> 4060;
5203 -> 5202;
5203 -> 4062;
5203 -> 4060;
5204 -> 4058;
5204 -> 4090;
5204 -> 4216;
5204 -> 5203;
5204 -> 4225;
5204 -> 4086;
5204 -> 4087;
5204 -> 5189;
5204 -> 4097;
5204 -> 4089;
5205 -> 4240;
5206 -> 5205;
5206 -> 4109;
5207 -> 5206;
5207 -> 4111;
5207 -> 4109;
5208 -> 4107;
5208 -> 4141;
5208 -> 4236;
5208 -> 5207;
5208 -> 4245;
5208 -> 4135;
5208 -> 4136;
5208 -> 5193;
5208 -> 4143;
5208 -> 4140;
5209 -> 4260;
5210 -> 5209;
5210 -> 4155;
5211 -> 5210;
5211 -> 4157;
5211 -> 4155;
5212 -> 4153;
5212 -> 4187;
5212 -> 4256;
5212 -> 5211;
5212 -> 4265;
5212 -> 4181;
5212 -> 4182;
5212 -> 5197;
5212 -> 4189;
5212 -> 4186;
5213 -> 4201;
5214 -> 5213;
5214 -> 4022;
5215 -> 5214;
5215 -> 4024;
5215 -> 4022;
5216 -> 4220;
5217 -> 5216;
5217 -> 4060;
5218 -> 5217;
5218 -> 4062;
5218 -> 4060;
5219 -> 4058;
5219 -> 4090;
5219 -> 4216;
5219 -> 5218;
5219 -> 4225;
5219 -> 4086;
5219 -> 4087;
5219 -> 5204;
5219 -> 4097;
5219 -> 4089;
5220 -> 4240;
5221 -> 5220;
5221 -> 4109;
5222 -> 5221;
5222 -> 4111;
5222 -> 4109;
5223 -> 4107;
5223 -> 4141;
5223 -> 4236;
5223 -> 5222;
5223 -> 4245;
5223 -> 4135;
5223 -> 4136;
5223 -> 5208;
5223 -> 4143;
5223 -> 4140;
5224 -> 4260;
5225 -> 5224;
5225 -> 4155;
5226 -> 5225;
5226 -> 4157;
5226 -> 4155;
5227 -> 4153;
5227 -> 4187;
5227 -> 4256;
5227 -> 5226;
5227 -> 4265;
5227 -> 4181;
5227 -> 4182;
5227 -> 5212;
5227 -> 4189;
5227 -> 4186;
5228 -> 4201;
5229 -> 5228;
5229 -> 4022;
5230 -> 5229;
5230 -> 4024;
5230 -> 4022;
5231 -> 4220;
5232 -> 5231;
5232 -> 4060;
5233 -> 5232;
5233 -> 4062;
5233 -> 4060;
5234 -> 4058;
5234 -> 4090;
5234 -> 4216;
5234 -> 5233;
5234 -> 4225;
5234 -> 4086;
5234 -> 4087;
5234 -> 5219;
5234 -> 4097;
5234 -> 4089;
5235 -> 4240;
5236 -> 5235;
5236 -> 4109;
5237 -> 5236;
5237 -> 4111;
5237 -> 4109;
5238 -> 4107;
5238 -> 4141;
5238 -> 4236;
5238 -> 5237;
5238 -> 4245;
5238 -> 4135;
5238 -> 4136;
5238 -> 5223;
5238 -> 4143;
5238 -> 4140;
5239 -> 4260;
5240 -> 5239;
5240 -> 4155;
5241 -> 5240;
5241 -> 4157;
5241 -> 4155;
5242 -> 4153;
5242 -> 4187;
5242 -> 4256;
5242 -> 5241;
5242 -> 4265;
5242 -> 4181;
5242 -> 4182;
5242 -> 5227;
5242 -> 4189;
5242 -> 4186;
5243 -> 4201;
5244 -> 5243;
5244 -> 4022;
5245 -> 5244;
5245 -> 4024;
5245 -> 4022;
5246 -> 4220;
5247 -> 5246;
5247 -> 4060;
5248 -> 5247;
5248 -> 4062;
5248 -> 4060;
5249 -> 4058;
5249 -> 4090;
5249 -> 4216;
5249 -> 5248;
5249 -> 4225;
5249 -> 4086;
5249 -> 4087;
5249 -> 5234;
5249 -> 4097;
5249 -> 4089;
5250 -> 4240;
5251 -> 5250;
5251 -> 4109;
5252 -> 5251;
5252 -> 4111;
5252 -> 4109;
5253 -> 4107;
5253 -> 4141;
5253 -> 4236;
5253 -> 5252;
5253 -> 4245;
5253 -> 4135;
5253 -> 4136;
5253 -> 5238;
5253 -> 4143;
5253 -> 4140;
5254 -> 4260;
5255 -> 5254;
5255 -> 4155;
5256 -> 5255;
5256 -> 4157;
5256 -> 4155;
5257 -> 4153;
5257 -> 4187;
5257 -> 4256;
5257 -> 5256;
5257 -> 4265;
5257 -> 4181;
5257 -> 4182;
5257 -> 5242;
5257 -> 4189;
5257 -> 4186;
5258 -> 4201;
5259 -> 5258;
5259 -> 4022;
5260 -> 5259;
5260 -> 4024;
5260 -> 4022;
5261 -> 4220;
5262 -> 5261;
5262 -> 4060;
5263 -> 5262;
5263 -> 4062;
5263 -> 4060;
5264 -> 4058;
5264 -> 4090;
5264 -> 4216;
5264 -> 5263;
5264 -> 4225;
5264 -> 4086;
5264 -> 4087;
5264 -> 5249;
5264 -> 4097;
5264 -> 4089;
5265 -> 4240;
5266 -> 5265;
5266 -> 4109;
5267 -> 5266;
5267 -> 4111;
5267 -> 4109;
5268 -> 4107;
5268 -> 4141;
5268 -> 4236;
5268 -> 5267;
5268 -> 4245;
5268 -> 4135;
5268 -> 4136;
5268 -> 5253;
5268 -> 4143;
5268 -> 4140;
5269 -> 4260;
5270 -> 5269;
5270 -> 4155;
5271 -> 5270;
5271 -> 4157;
5271 -> 4155;
5272 -> 4153;
5272 -> 4187;
5272 -> 4256;
5272 -> 5271;
5272 -> 4265;
5272 -> 4181;
5272 -> 4182;
5272 -> 5257;
5272 -> 4189;
5272 -> 4186;
5273 -> 4201;
5274 -> 5273;
5274 -> 4022;
5275 -> 5274;
5275 -> 4024;
5275 -> 4022;
5276 -> 4220;
5277 -> 5276;
5277 -> 4060;
5278 -> 5277;
5278 -> 4062;
5278 -> 4060;
5279 -> 4058;
5279 -> 4090;
5279 -> 4216;
5279 -> 5278;
5279 -> 4225;
5279 -> 4086;
5279 -> 4087;
5279 -> 5264;
5279 -> 4097;
5279 -> 4089;
5280 -> 4240;
5281 -> 5280;
5281 -> 4109;
5282 -> 5281;
5282 -> 4111;
5282 -> 4109;
5283 -> 4107;
5283 -> 4141;
5283 -> 4236;
5283 -> 5282;
5283 -> 4245;
5283 -> 4135;
5283 -> 4136;
5283 -> 5268;
5283 -> 4143;
5283 -> 4140;
5284 -> 4260;
5285 -> 5284;
5285 -> 4155;
5286 -> 5285;
5286 -> 4157;
5286 -> 4155;
5287 -> 4153;
5287 -> 4187;
5287 -> 4256;
5287 -> 5286;
5287 -> 4265;
5287 -> 4181;
5287 -> 4182;
5287 -> 5272;
5287 -> 4189;
5287 -> 4186;
5288 -> 4201;
5289 -> 5288;
5289 -> 4022;
5290 -> 5289;
5290 -> 4024;
5290 -> 4022;
5291 -> 4220;
5292 -> 5291;
5292 -> 4060;
5293 -> 5292;
5293 -> 4062;
5293 -> 4060;
5294 -> 4058;
5294 -> 4090;
5294 -> 4216;
5294 -> 5293;
5294 -> 4225;
5294 -> 4086;
5294 -> 4087;
5294 -> 5279;
5294 -> 4097;
5294 -> 4089;
5295 -> 4240;
5296 -> 5295;
5296 -> 4109;
5297 -> 5296;
5297 -> 4111;
5297 -> 4109;
5298 -> 4107;
5298 -> 4141;
5298 -> 4236;
5298 -> 5297;
5298 -> 4245;
5298 -> 4135;
5298 -> 4136;
5298 -> 5283;
5298 -> 4143;
5298 -> 4140;
5299 -> 4260;
5300 -> 5299;
5300 -> 4155;
5301 -> 5300;
5301 -> 4157;
5301 -> 4155;
5302 -> 4153;
5302 -> 4187;
5302 -> 4256;
5302 -> 5301;
5302 -> 4265;
5302 -> 4181;
5302 -> 4182;
5302 -> 5287;
5302 -> 4189;
5302 -> 4186;
5303 -> 4201;
5304 -> 5303;
5304 -> 4022;
5305 -> 5304;
5305 -> 4024;
5305 -> 4022;
5306 -> 4220;
5307 -> 5306;
5307 -> 4060;
5308 -> 5307;
5308 -> 4062;
5308 -> 4060;
5309 -> 4058;
5309 -> 4090;
5309 -> 4216;
5309 -> 5308;
5309 -> 4225;
5309 -> 4086;
5309 -> 4087;
5309 -> 5294;
5309 -> 4097;
5309 -> 4089;
5310 -> 4240;
5311 -> 5310;
5311 -> 4109;
5312 -> 5311;
5312 -> 4111;
5312 -> 4109;
5313 -> 4107;
5313 -> 4141;
5313 -> 4236;
5313 -> 5312;
5313 -> 4245;
5313 -> 4135;
5313 -> 4136;
5313 -> 5298;
5313 -> 4143;
5313 -> 4140;
5314 -> 4260;
5315 -> 5314;
5315 -> 4155;
5316 -> 5315;
5316 -> 4157;
5316 -> 4155;
5317 -> 4153;
5317 -> 4187;
5317 -> 4256;
5317 -> 5316;
5317 -> 4265;
5317 -> 4181;
5317 -> 4182;
5317 -> 5302;
5317 -> 4189;
5317 -> 4186;
5318 -> 4201;
5319 -> 5318;
5319 -> 4022;
5320 -> 5319;
5320 -> 4024;
5320 -> 4022;
5321 -> 4220;
5322 -> 5321;
5322 -> 4060;
5323 -> 5322;
5323 -> 4062;
5323 -> 4060;
5324 -> 4058;
5324 -> 4090;
5324 -> 4216;
5324 -> 5323;
5324 -> 4225;
5324 -> 4086;
5324 -> 4087;
5324 -> 5309;
5324 -> 4097;
5324 -> 4089;
5325 -> 4240;
5326 -> 5325;
5326 -> 4109;
5327 -> 5326;
5327 -> 4111;
5327 -> 4109;
5328 -> 4107;
5328 -> 4141;
5328 -> 4236;
5328 -> 5327;
5328 -> 4245;
5328 -> 4135;
5328 -> 4136;
5328 -> 5313;
5328 -> 4143;
5328 -> 4140;
5329 -> 4260;
5330 -> 5329;
5330 -> 4155;
5331 -> 5330;
5331 -> 4157;
5331 -> 4155;
5332 -> 4153;
5332 -> 4187;
5332 -> 4256;
5332 -> 5331;
5332 -> 4265;
5332 -> 4181;
5332 -> 4182;
5332 -> 5317;
5332 -> 4189;
5332 -> 4186;
5333 -> 4201;
5334 -> 5333;
5334 -> 4022;
5335 -> 5334;
5335 -> 4024;
5335 -> 4022;
5336 -> 4220;
5337 -> 5336;
5337 -> 4060;
5338 -> 5337;
5338 -> 4062;
5338 -> 4060;
5339 -> 4058;
5339 -> 4090;
5339 -> 4216;
5339 -> 5338;
5339 -> 4225;
5339 -> 4086;
5339 -> 4087;
5339 -> 5324;
5339 -> 4097;
5339 -> 4089;
5340 -> 4240;
5341 -> 5340;
5341 -> 4109;
5342 -> 5341;
5342 -> 4111;
5342 -> 4109;
5343 -> 4107;
5343 -> 4141;
5343 -> 4236;
5343 -> 5342;
5343 -> 4245;
5343 -> 4135;
5343 -> 4136;
5343 -> 5328;
5343 -> 4143;
5343 -> 4140;
5344 -> 4260;
5345 -> 5344;
5345 -> 4155;
5346 -> 5345;
5346 -> 4157;
5346 -> 4155;
5347 -> 4153;
5347 -> 4187;
5347 -> 4256;
5347 -> 5346;
5347 -> 4265;
5347 -> 4181;
5347 -> 4182;
5347 -> 5332;
5347 -> 4189;
5347 -> 4186;
5348 -> 4201;
5349 -> 5348;
5349 -> 4022;
5350 -> 5349;
5350 -> 4024;
5350 -> 4022;
5351 -> 4220;
5352 -> 5351;
5352 -> 4060;
5353 -> 5352;
5353 -> 4062;
5353 -> 4060;
5354 -> 4058;
5354 -> 4090;
5354 -> 4216;
5354 -> 5353;
5354 -> 4225;
5354 -> 4086;
5354 -> 4087;
5354 -> 5339;
5354 -> 4097;
5354 -> 4089;
5355 -> 4240;
5356 -> 5355;
5356 -> 4109;
5357 -> 5356;
5357 -> 4111;
5357 -> 4109;
5358 -> 4107;
5358 -> 4141;
5358 -> 4236;
5358 -> 5357;
5358 -> 4245;
5358 -> 4135;
5358 -> 4136;
5358 -> 5343;
5358 -> 4143;
5358 -> 4140;
5359 -> 4260;
5360 -> 5359;
5360 -> 4155;
5361 -> 5360;
5361 -> 4157;
5361 -> 4155;
5362 -> 4153;
5362 -> 4187;
5362 -> 4256;
5362 -> 5361;
5362 -> 4265;
5362 -> 4181;
5362 -> 4182;
5362 -> 5347;
5362 -> 4189;
5362 -> 4186;
5363 -> 4201;
5364 -> 5363;
5364 -> 4022;
5365 -> 5364;
5365 -> 4024;
5365 -> 4022;
5366 -> 4220;
5367 -> 5366;
5367 -> 4060;
5368 -> 5367;
5368 -> 4062;
5368 -> 4060;
5369 -> 4058;
5369 -> 4090;
5369 -> 4216;
5369 -> 5368;
5369 -> 4225;
5369 -> 4086;
5369 -> 4087;
5369 -> 5354;
5369 -> 4097;
5369 -> 4089;
5370 -> 4240;
5371 -> 5370;
5371 -> 4109;
5372 -> 5371;
5372 -> 4111;
5372 -> 4109;
5373 -> 4107;
5373 -> 4141;
5373 -> 4236;
5373 -> 5372;
5373 -> 4245;
5373 -> 4135;
5373 -> 4136;
5373 -> 5358;
5373 -> 4143;
5373 -> 4140;
5374 -> 4260;
5375 -> 5374;
5375 -> 4155;
5376 -> 5375;
5376 -> 4157;
5376 -> 4155;
5377 -> 4153;
5377 -> 4187;
5377 -> 4256;
5377 -> 5376;
5377 -> 4265;
5377 -> 4181;
5377 -> 4182;
5377 -> 5362;
5377 -> 4189;
5377 -> 4186;
5378 -> 4201;
5379 -> 5378;
5379 -> 4022;
5380 -> 5379;
5380 -> 4024;
5380 -> 4022;
5381 -> 4220;
5382 -> 5381;
5382 -> 4060;
5383 -> 5382;
5383 -> 4062;
5383 -> 4060;
5384 -> 4058;
5384 -> 4090;
5384 -> 4216;
5384 -> 5383;
5384 -> 4225;
5384 -> 4086;
5384 -> 4087;
5384 -> 5369;
5384 -> 4097;
5384 -> 4089;
5385 -> 4240;
5386 -> 5385;
5386 -> 4109;
5387 -> 5386;
5387 -> 4111;
5387 -> 4109;
5388 -> 4107;
5388 -> 4141;
5388 -> 4236;
5388 -> 5387;
5388 -> 4245;
5388 -> 4135;
5388 -> 4136;
5388 -> 5373;
5388 -> 4143;
5388 -> 4140;
5389 -> 4260;
5390 -> 5389;
5390 -> 4155;
5391 -> 5390;
5391 -> 4157;
5391 -> 4155;
5392 -> 4153;
5392 -> 4187;
5392 -> 4256;
5392 -> 5391;
5392 -> 4265;
5392 -> 4181;
5392 -> 4182;
5392 -> 5377;
5392 -> 4189;
5392 -> 4186;
5393 -> 4201;
5394 -> 5393;
5394 -> 4022;
5395 -> 5394;
5395 -> 4024;
5395 -> 4022;
5396 -> 4220;
5397 -> 5396;
5397 -> 4060;
5398 -> 5397;
5398 -> 4062;
5398 -> 4060;
5399 -> 4058;
5399 -> 4090;
5399 -> 4216;
5399 -> 5398;
5399 -> 4225;
5399 -> 4086;
5399 -> 4087;
5399 -> 5384;
5399 -> 4097;
5399 -> 4089;
5400 -> 4240;
5401 -> 5400;
5401 -> 4109;
5402 -> 5401;
5402 -> 4111;
5402 -> 4109;
5403 -> 4107;
5403 -> 4141;
5403 -> 4236;
5403 -> 5402;
5403 -> 4245;
5403 -> 4135;
5403 -> 4136;
5403 -> 5388;
5403 -> 4143;
5403 -> 4140;
5404 -> 4260;
5405 -> 5404;
5405 -> 4155;
5406 -> 5405;
5406 -> 4157;
5406 -> 4155;
5407 -> 4153;
5407 -> 4187;
5407 -> 4256;
5407 -> 5406;
5407 -> 4265;
5407 -> 4181;
5407 -> 4182;
5407 -> 5392;
5407 -> 4189;
5407 -> 4186;
5408 -> 4201;
5409 -> 5408;
5409 -> 4022;
5410 -> 5409;
5410 -> 4024;
5410 -> 4022;
5411 -> 4220;
5412 -> 5411;
5412 -> 4060;
5413 -> 5412;
5413 -> 4062;
5413 -> 4060;
5414 -> 4058;
5414 -> 4090;
5414 -> 4216;
5414 -> 5413;
5414 -> 4225;
5414 -> 4086;
5414 -> 4087;
5414 -> 5399;
5414 -> 4097;
5414 -> 4089;
5415 -> 4240;
5416 -> 5415;
5416 -> 4109;
5417 -> 5416;
5417 -> 4111;
5417 -> 4109;
5418 -> 4107;
5418 -> 4141;
5418 -> 4236;
5418 -> 5417;
5418 -> 4245;
5418 -> 4135;
5418 -> 4136;
5418 -> 5403;
5418 -> 4143;
5418 -> 4140;
5419 -> 4260;
5420 -> 5419;
5420 -> 4155;
5421 -> 5420;
5421 -> 4157;
5421 -> 4155;
5422 -> 4153;
5422 -> 4187;
5422 -> 4256;
5422 -> 5421;
5422 -> 4265;
5422 -> 4181;
5422 -> 4182;
5422 -> 5407;
5422 -> 4189;
5422 -> 4186;
5423 -> 4201;
5424 -> 5423;
5424 -> 4022;
5425 -> 5424;
5425 -> 4024;
5425 -> 4022;
5426 -> 4220;
5427 -> 5426;
5427 -> 4060;
5428 -> 5427;
5428 -> 4062;
5428 -> 4060;
5429 -> 4058;
5429 -> 4090;
5429 -> 4216;
5429 -> 5428;
5429 -> 4225;
5429 -> 4086;
5429 -> 4087;
5429 -> 5414;
5429 -> 4097;
5429 -> 4089;
5430 -> 4240;
5431 -> 5430;
5431 -> 4109;
5432 -> 5431;
5432 -> 4111;
5432 -> 4109;
5433 -> 4107;
5433 -> 4141;
5433 -> 4236;
5433 -> 5432;
5433 -> 4245;
5433 -> 4135;
5433 -> 4136;
5433 -> 5418;
5433 -> 4143;
5433 -> 4140;
5434 -> 4260;
5435 -> 5434;
5435 -> 4155;
5436 -> 5435;
5436 -> 4157;
5436 -> 4155;
5437 -> 4153;
5437 -> 4187;
5437 -> 4256;
5437 -> 5436;
5437 -> 4265;
5437 -> 4181;
5437 -> 4182;
5437 -> 5422;
5437 -> 4189;
5437 -> 4186;
5438 -> 4201;
5439 -> 5438;
5439 -> 4022;
5440 -> 5439;
5440 -> 4024;
5440 -> 4022;
5441 -> 4220;
5442 -> 5441;
5442 -> 4060;
5443 -> 5442;
5443 -> 4062;
5443 -> 4060;
5444 -> 4058;
5444 -> 4090;
5444 -> 4216;
5444 -> 5443;
5444 -> 4225;
5444 -> 4086;
5444 -> 4087;
5444 -> 5429;
5444 -> 4097;
5444 -> 4089;
5445 -> 4240;
5446 -> 5445;
5446 -> 4109;
5447 -> 5446;
5447 -> 4111;
5447 -> 4109;
5448 -> 4107;
5448 -> 4141;
5448 -> 4236;
5448 -> 5447;
5448 -> 4245;
5448 -> 4135;
5448 -> 4136;
5448 -> 5433;
5448 -> 4143;
5448 -> 4140;
5449 -> 4260;
5450 -> 5449;
5450 -> 4155;
5451 -> 5450;
5451 -> 4157;
5451 -> 4155;
5452 -> 4153;
5452 -> 4187;
5452 -> 4256;
5452 -> 5451;
5452 -> 4265;
5452 -> 4181;
5452 -> 4182;
5452 -> 5437;
5452 -> 4189;
5452 -> 4186;
5453 -> 4201;
5454 -> 5453;
5454 -> 4022;
5455 -> 5454;
5455 -> 4024;
5455 -> 4022;
5456 -> 4220;
5457 -> 5456;
5457 -> 4060;
5458 -> 5457;
5458 -> 4062;
5458 -> 4060;
5459 -> 4058;
5459 -> 4090;
5459 -> 4216;
5459 -> 5458;
5459 -> 4225;
5459 -> 4086;
5459 -> 4087;
5459 -> 5444;
5459 -> 4097;
5459 -> 4089;
5460 -> 4240;
5461 -> 5460;
5461 -> 4109;
5462 -> 5461;
5462 -> 4111;
5462 -> 4109;
5463 -> 4107;
5463 -> 4141;
5463 -> 4236;
5463 -> 5462;
5463 -> 4245;
5463 -> 4135;
5463 -> 4136;
5463 -> 5448;
5463 -> 4143;
5463 -> 4140;
5464 -> 4260;
5465 -> 5464;
5465 -> 4155;
5466 -> 5465;
5466 -> 4157;
5466 -> 4155;
5467 -> 4153;
5467 -> 4187;
5467 -> 4256;
5467 -> 5466;
5467 -> 4265;
5467 -> 4181;
5467 -> 4182;
5467 -> 5452;
5467 -> 4189;
5467 -> 4186;
5468 -> 4201;
5469 -> 5468;
5469 -> 4022;
5470 -> 5469;
5470 -> 4024;
5470 -> 4022;
5471 -> 4220;
5472 -> 5471;
5472 -> 4060;
5473 -> 5472;
5473 -> 4062;
5473 -> 4060;
5474 -> 4058;
5474 -> 4090;
5474 -> 4216;
5474 -> 5473;
5474 -> 4225;
5474 -> 4086;
5474 -> 4087;
5474 -> 5459;
5474 -> 4097;
5474 -> 4089;
5475 -> 4240;
5476 -> 5475;
5476 -> 4109;
5477 -> 5476;
5477 -> 4111;
5477 -> 4109;
5478 -> 4107;
5478 -> 4141;
5478 -> 4236;
5478 -> 5477;
5478 -> 4245;
5478 -> 4135;
5478 -> 4136;
5478 -> 5463;
5478 -> 4143;
5478 -> 4140;
5479 -> 4260;
5480 -> 5479;
5480 -> 4155;
5481 -> 5480;
5481 -> 4157;
5481 -> 4155;
5482 -> 4153;
5482 -> 4187;
5482 -> 4256;
5482 -> 5481;
5482 -> 4265;
5482 -> 4181;
5482 -> 4182;
5482 -> 5467;
5482 -> 4189;
5482 -> 4186;
5483 -> 4201;
5484 -> 5483;
5484 -> 4022;
5485 -> 5484;
5485 -> 4024;
5485 -> 4022;
5486 -> 4220;
5487 -> 5486;
5487 -> 4060;
5488 -> 5487;
5488 -> 4062;
5488 -> 4060;
5489 -> 4058;
5489 -> 4090;
5489 -> 4216;
5489 -> 5488;
5489 -> 4225;
5489 -> 4086;
5489 -> 4087;
5489 -> 5474;
5489 -> 4097;
5489 -> 4089;
5490 -> 4240;
5491 -> 5490;
5491 -> 4109;
5492 -> 5491;
5492 -> 4111;
5492 -> 4109;
5493 -> 4107;
5493 -> 4141;
5493 -> 4236;
5493 -> 5492;
5493 -> 4245;
5493 -> 4135;
5493 -> 4136;
5493 -> 5478;
5493 -> 4143;
5493 -> 4140;
5494 -> 4260;
5495 -> 5494;
5495 -> 4155;
5496 -> 5495;
5496 -> 4157;
5496 -> 4155;
5497 -> 4153;
5497 -> 4187;
5497 -> 4256;
5497 -> 5496;
5497 -> 4265;
5497 -> 4181;
5497 -> 4182;
5497 -> 5482;
5497 -> 4189;
5497 -> 4186;
5498 -> 4201;
5499 -> 5498;
5499 -> 4022;
5500 -> 5499;
5500 -> 4024;
5500 -> 4022;
5501 -> 4220;
5502 -> 5501;
5502 -> 4060;
5503 -> 5502;
5503 -> 4062;
5503 -> 4060;
5504 -> 4058;
5504 -> 4090;
5504 -> 4216;
5504 -> 5503;
5504 -> 4225;
5504 -> 4086;
5504 -> 4087;
5504 -> 5489;
5504 -> 4097;
5504 -> 4089;
5505 -> 4240;
5506 -> 5505;
5506 -> 4109;
5507 -> 5506;
5507 -> 4111;
5507 -> 4109;
5508 -> 4107;
5508 -> 4141;
5508 -> 4236;
5508 -> 5507;
5508 -> 4245;
5508 -> 4135;
5508 -> 4136;
5508 -> 5493;
5508 -> 4143;
5508 -> 4140;
5509 -> 4260;
5510 -> 5509;
5510 -> 4155;
5511 -> 5510;
5511 -> 4157;
5511 -> 4155;
5512 -> 4153;
5512 -> 4187;
5512 -> 4256;
5512 -> 5511;
5512 -> 4265;
5512 -> 4181;
5512 -> 4182;
5512 -> 5497;
5512 -> 4189;
5512 -> 4186;
5513 -> 4201;
5514 -> 5513;
5514 -> 4022;
5515 -> 5514;
5515 -> 4024;
5515 -> 4022;
5516 -> 4220;
5517 -> 5516;
5517 -> 4060;
5518 -> 5517;
5518 -> 4062;
5518 -> 4060;
5519 -> 4058;
5519 -> 4090;
5519 -> 4216;
5519 -> 5518;
5519 -> 4225;
5519 -> 4086;
5519 -> 4087;
5519 -> 5504;
5519 -> 4097;
5519 -> 4089;
5520 -> 4240;
5521 -> 5520;
5521 -> 4109;
5522 -> 5521;
5522 -> 4111;
5522 -> 4109;
5523 -> 4107;
5523 -> 4141;
5523 -> 4236;
5523 -> 5522;
5523 -> 4245;
5523 -> 4135;
5523 -> 4136;
5523 -> 5508;
5523 -> 4143;
5523 -> 4140;
5524 -> 4260;
5525 -> 5524;
5525 -> 4155;
5526 -> 5525;
5526 -> 4157;
5526 -> 4155;
5527 -> 4153;
5527 -> 4187;
5527 -> 4256;
5527 -> 5526;
5527 -> 4265;
5527 -> 4181;
5527 -> 4182;
5527 -> 5512;
5527 -> 4189;
5527 -> 4186;
5528 -> 4201;
5529 -> 5528;
5529 -> 4022;
5530 -> 5529;
5530 -> 4024;
5530 -> 4022;
5531 -> 4220;
5532 -> 5531;
5532 -> 4060;
5533 -> 5532;
5533 -> 4062;
5533 -> 4060;
5534 -> 4058;
5534 -> 4090;
5534 -> 4216;
5534 -> 5533;
5534 -> 4225;
5534 -> 4086;
5534 -> 4087;
5534 -> 5519;
5534 -> 4097;
5534 -> 4089;
5535 -> 4240;
5536 -> 5535;
5536 -> 4109;
5537 -> 5536;
5537 -> 4111;
5537 -> 4109;
5538 -> 4107;
5538 -> 4141;
5538 -> 4236;
5538 -> 5537;
5538 -> 4245;
5538 -> 4135;
5538 -> 4136;
5538 -> 5523;
5538 -> 4143;
5538 -> 4140;
5539 -> 4260;
5540 -> 5539;
5540 -> 4155;
5541 -> 5540;
5541 -> 4157;
5541 -> 4155;
5542 -> 4153;
5542 -> 4187;
5542 -> 4256;
5542 -> 5541;
5542 -> 4265;
5542 -> 4181;
5542 -> 4182;
5542 -> 5527;
5542 -> 4189;
5542 -> 4186;
5543 -> 4201;
5544 -> 5543;
5544 -> 4022;
5545 -> 5544;
5545 -> 4024;
5545 -> 4022;
5546 -> 4220;
5547 -> 5546;
5547 -> 4060;
5548 -> 5547;
5548 -> 4062;
5548 -> 4060;
5549 -> 4058;
5549 -> 4090;
5549 -> 4216;
5549 -> 5548;
5549 -> 4225;
5549 -> 4086;
5549 -> 4087;
5549 -> 5534;
5549 -> 4097;
5549 -> 4089;
5550 -> 4240;
5551 -> 5550;
5551 -> 4109;
5552 -> 5551;
5552 -> 4111;
5552 -> 4109;
5553 -> 4107;
5553 -> 4141;
5553 -> 4236;
5553 -> 5552;
5553 -> 4245;
5553 -> 4135;
5553 -> 4136;
5553 -> 5538;
5553 -> 4143;
5553 -> 4140;
5554 -> 4260;
5555 -> 5554;
5555 -> 4155;
5556 -> 5555;
5556 -> 4157;
5556 -> 4155;
5557 -> 4153;
5557 -> 4187;
5557 -> 4256;
5557 -> 5556;
5557 -> 4265;
5557 -> 4181;
5557 -> 4182;
5557 -> 5542;
5557 -> 4189;
5557 -> 4186;
5558 -> 4201;
5559 -> 5558;
5559 -> 4022;
5560 -> 5559;
5560 -> 4024;
5560 -> 4022;
5561 -> 4220;
5562 -> 5561;
5562 -> 4060;
5563 -> 5562;
5563 -> 4062;
5563 -> 4060;
5564 -> 4058;
5564 -> 4090;
5564 -> 4216;
5564 -> 5563;
5564 -> 4225;
5564 -> 4086;
5564 -> 4087;
5564 -> 5549;
5564 -> 4097;
5564 -> 4089;
5565 -> 4240;
5566 -> 5565;
5566 -> 4109;
5567 -> 5566;
5567 -> 4111;
5567 -> 4109;
5568 -> 4107;
5568 -> 4141;
5568 -> 4236;
5568 -> 5567;
5568 -> 4245;
5568 -> 4135;
5568 -> 4136;
5568 -> 5553;
5568 -> 4143;
5568 -> 4140;
5569 -> 4260;
5570 -> 5569;
5570 -> 4155;
5571 -> 5570;
5571 -> 4157;
5571 -> 4155;
5572 -> 4153;
5572 -> 4187;
5572 -> 4256;
5572 -> 5571;
5572 -> 4265;
5572 -> 4181;
5572 -> 4182;
5572 -> 5557;
5572 -> 4189;
5572 -> 4186;
5573 -> 4201;
5574 -> 5573;
5574 -> 4022;
5575 -> 5574;
5575 -> 4024;
5575 -> 4022;
5576 -> 4220;
5577 -> 5576;
5577 -> 4060;
5578 -> 5577;
5578 -> 4062;
5578 -> 4060;
5579 -> 4058;
5579 -> 4090;
5579 -> 4216;
5579 -> 5578;
5579 -> 4225;
5579 -> 4086;
5579 -> 4087;
5579 -> 5564;
5579 -> 4097;
5579 -> 4089;
5580 -> 4240;
5581 -> 5580;
5581 -> 4109;
5582 -> 5581;
5582 -> 4111;
5582 -> 4109;
5583 -> 4107;
5583 -> 4141;
5583 -> 4236;
5583 -> 5582;
5583 -> 4245;
5583 -> 4135;
5583 -> 4136;
5583 -> 5568;
5583 -> 4143;
5583 -> 4140;
5584 -> 4260;
5585 -> 5584;
5585 -> 4155;
5586 -> 5585;
5586 -> 4157;
5586 -> 4155;
5587 -> 4153;
5587 -> 4187;
5587 -> 4256;
5587 -> 5586;
5587 -> 4265;
5587 -> 4181;
5587 -> 4182;
5587 -> 5572;
5587 -> 4189;
5587 -> 4186;
5588 -> 4201;
5589 -> 5588;
5589 -> 4022;
5590 -> 5589;
5590 -> 4024;
5590 -> 4022;
5591 -> 4220;
5592 -> 5591;
5592 -> 4060;
5593 -> 5592;
5593 -> 4062;
5593 -> 4060;
5594 -> 4058;
5594 -> 4090;
5594 -> 4216;
5594 -> 5593;
5594 -> 4225;
5594 -> 4086;
5594 -> 4087;
5594 -> 5579;
5594 -> 4097;
5594 -> 4089;
5595 -> 4240;
5596 -> 5595;
5596 -> 4109;
5597 -> 5596;
5597 -> 4111;
5597 -> 4109;
5598 -> 4107;
5598 -> 4141;
5598 -> 4236;
5598 -> 5597;
5598 -> 4245;
5598 -> 4135;
5598 -> 4136;
5598 -> 5583;
5598 -> 4143;
5598 -> 4140;
5599 -> 4260;
5600 -> 5599;
5600 -> 4155;
5601 -> 5600;
5601 -> 4157;
5601 -> 4155;
5602 -> 4153;
5602 -> 4187;
5602 -> 4256;
5602 -> 5601;
5602 -> 4265;
5602 -> 4181;
5602 -> 4182;
5602 -> 5587;
5602 -> 4189;
5602 -> 4186;
5603 -> 4201;
5604 -> 5603;
5604 -> 4022;
5605 -> 5604;
5605 -> 4024;
5605 -> 4022;
5606 -> 4220;
5607 -> 5606;
5607 -> 4060;
5608 -> 5607;
5608 -> 4062;
5608 -> 4060;
5609 -> 4058;
5609 -> 4090;
5609 -> 4216;
5609 -> 5608;
5609 -> 4225;
5609 -> 4086;
5609 -> 4087;
5609 -> 5594;
5609 -> 4097;
5609 -> 4089;
5610 -> 4240;
5611 -> 5610;
5611 -> 4109;
5612 -> 5611;
5612 -> 4111;
5612 -> 4109;
5613 -> 4107;
5613 -> 4141;
5613 -> 4236;
5613 -> 5612;
5613 -> 4245;
5613 -> 4135;
5613 -> 4136;
5613 -> 5598;
5613 -> 4143;
5613 -> 4140;
5614 -> 4260;
5615 -> 5614;
5615 -> 4155;
5616 -> 5615;
5616 -> 4157;
5616 -> 4155;
5617 -> 4153;
5617 -> 4187;
5617 -> 4256;
5617 -> 5616;
5617 -> 4265;
5617 -> 4181;
5617 -> 4182;
5617 -> 5602;
5617 -> 4189;
5617 -> 4186;
5618 -> 4201;
5619 -> 5618;
5619 -> 4022;
5620 -> 5619;
5620 -> 4024;
5620 -> 4022;
5621 -> 4220;
5622 -> 5621;
5622 -> 4060;
5623 -> 5622;
5623 -> 4062;
5623 -> 4060;
5624 -> 4058;
5624 -> 4090;
5624 -> 4216;
5624 -> 5623;
5624 -> 4225;
5624 -> 4086;
5624 -> 4087;
5624 -> 5609;
5624 -> 4097;
5624 -> 4089;
5625 -> 4240;
5626 -> 5625;
5626 -> 4109;
5627 -> 5626;
5627 -> 4111;
5627 -> 4109;
5628 -> 4107;
5628 -> 4141;
5628 -> 4236;
5628 -> 5627;
5628 -> 4245;
5628 -> 4135;
5628 -> 4136;
5628 -> 5613;
5628 -> 4143;
5628 -> 4140;
5629 -> 4260;
5630 -> 5629;
5630 -> 4155;
5631 -> 5630;
5631 -> 4157;
5631 -> 4155;
5632 -> 4153;
5632 -> 4187;
5632 -> 4256;
5632 -> 5631;
5632 -> 4265;
5632 -> 4181;
5632 -> 4182;
5632 -> 5617;
5632 -> 4189;
5632 -> 4186;
5633 -> 4201;
5634 -> 5633;
5634 -> 4022;
5635 -> 5634;
5635 -> 4024;
5635 -> 4022;
5636 -> 4220;
5637 -> 5636;
5637 -> 4060;
5638 -> 5637;
5638 -> 4062;
5638 -> 4060;
5639 -> 4058;
5639 -> 4090;
5639 -> 4216;
5639 -> 5638;
5639 -> 4225;
5639 -> 4086;
5639 -> 4087;
5639 -> 5624;
5639 -> 4097;
5639 -> 4089;
5640 -> 4240;
5641 -> 5640;
5641 -> 4109;
5642 -> 5641;
5642 -> 4111;
5642 -> 4109;
5643 -> 4107;
5643 -> 4141;
5643 -> 4236;
5643 -> 5642;
5643 -> 4245;
5643 -> 4135;
5643 -> 4136;
5643 -> 5628;
5643 -> 4143;
5643 -> 4140;
5644 -> 4260;
5645 -> 5644;
5645 -> 4155;
5646 -> 5645;
5646 -> 4157;
5646 -> 4155;
5647 -> 4153;
5647 -> 4187;
5647 -> 4256;
5647 -> 5646;
5647 -> 4265;
5647 -> 4181;
5647 -> 4182;
5647 -> 5632;
5647 -> 4189;
5647 -> 4186;
5648 -> 4201;
5649 -> 5648;
5649 -> 4022;
5650 -> 5649;
5650 -> 4024;
5650 -> 4022;
5651 -> 4220;
5652 -> 5651;
5652 -> 4060;
5653 -> 5652;
5653 -> 4062;
5653 -> 4060;
5654 -> 4058;
5654 -> 4090;
5654 -> 4216;
5654 -> 5653;
5654 -> 4225;
5654 -> 4086;
5654 -> 4087;
5654 -> 5639;
5654 -> 4097;
5654 -> 4089;
5655 -> 4240;
5656 -> 5655;
5656 -> 4109;
5657 -> 5656;
5657 -> 4111;
5657 -> 4109;
5658 -> 4107;
5658 -> 4141;
5658 -> 4236;
5658 -> 5657;
5658 -> 4245;
5658 -> 4135;
5658 -> 4136;
5658 -> 5643;
5658 -> 4143;
5658 -> 4140;
5659 -> 4260;
5660 -> 5659;
5660 -> 4155;
5661 -> 5660;
5661 -> 4157;
5661 -> 4155;
5662 -> 4153;
5662 -> 4187;
5662 -> 4256;
5662 -> 5661;
5662 -> 4265;
5662 -> 4181;
5662 -> 4182;
5662 -> 5647;
5662 -> 4189;
5662 -> 4186;
5663 -> 4201;
5664 -> 5663;
5664 -> 4022;
5665 -> 5664;
5665 -> 4024;
5665 -> 4022;
5666 -> 4220;
5667 -> 5666;
5667 -> 4060;
5668 -> 5667;
5668 -> 4062;
5668 -> 4060;
5669 -> 4058;
5669 -> 4090;
5669 -> 4216;
5669 -> 5668;
5669 -> 4225;
5669 -> 4086;
5669 -> 4087;
5669 -> 5654;
5669 -> 4097;
5669 -> 4089;
5670 -> 4240;
5671 -> 5670;
5671 -> 4109;
5672 -> 5671;
5672 -> 4111;
5672 -> 4109;
5673 -> 4107;
5673 -> 4141;
5673 -> 4236;
5673 -> 5672;
5673 -> 4245;
5673 -> 4135;
5673 -> 4136;
5673 -> 5658;
5673 -> 4143;
5673 -> 4140;
5674 -> 4260;
5675 -> 5674;
5675 -> 4155;
5676 -> 5675;
5676 -> 4157;
5676 -> 4155;
5677 -> 4153;
5677 -> 4187;
5677 -> 4256;
5677 -> 5676;
5677 -> 4265;
5677 -> 4181;
5677 -> 4182;
5677 -> 5662;
5677 -> 4189;
5677 -> 4186;
5678 -> 4201;
5679 -> 5678;
5679 -> 4022;
5680 -> 5679;
5680 -> 4024;
5680 -> 4022;
5681 -> 4220;
5682 -> 5681;
5682 -> 4060;
5683 -> 5682;
5683 -> 4062;
5683 -> 4060;
5684 -> 4058;
5684 -> 4090;
5684 -> 4216;
5684 -> 5683;
5684 -> 4225;
5684 -> 4086;
5684 -> 4087;
5684 -> 5669;
5684 -> 4097;
5684 -> 4089;
5685 -> 4240;
5686 -> 5685;
5686 -> 4109;
5687 -> 5686;
5687 -> 4111;
5687 -> 4109;
5688 -> 4107;
5688 -> 4141;
5688 -> 4236;
5688 -> 5687;
5688 -> 4245;
5688 -> 4135;
5688 -> 4136;
5688 -> 5673;
5688 -> 4143;
5688 -> 4140;
5689 -> 4260;
5690 -> 5689;
5690 -> 4155;
5691 -> 5690;
5691 -> 4157;
5691 -> 4155;
5692 -> 4153;
5692 -> 4187;
5692 -> 4256;
5692 -> 5691;
5692 -> 4265;
5692 -> 4181;
5692 -> 4182;
5692 -> 5677;
5692 -> 4189;
5692 -> 4186;
5693 -> 4201;
5694 -> 5693;
5694 -> 4022;
5695 -> 5694;
5695 -> 4024;
5695 -> 4022;
5696 -> 4220;
5697 -> 5696;
5697 -> 4060;
5698 -> 5697;
5698 -> 4062;
5698 -> 4060;
5699 -> 4058;
5699 -> 4090;
5699 -> 4216;
5699 -> 5698;
5699 -> 4225;
5699 -> 4086;
5699 -> 4087;
5699 -> 5684;
5699 -> 4097;
5699 -> 4089;
5700 -> 4240;
5701 -> 5700;
5701 -> 4109;
5702 -> 5701;
5702 -> 4111;
5702 -> 4109;
5703 -> 4107;
5703 -> 4141;
5703 -> 4236;
5703 -> 5702;
5703 -> 4245;
5703 -> 4135;
5703 -> 4136;
5703 -> 5688;
5703 -> 4143;
5703 -> 4140;
5704 -> 4260;
5705 -> 5704;
5705 -> 4155;
5706 -> 5705;
5706 -> 4157;
5706 -> 4155;
5707 -> 4153;
5707 -> 4187;
5707 -> 4256;
5707 -> 5706;
5707 -> 4265;
5707 -> 4181;
5707 -> 4182;
5707 -> 5692;
5707 -> 4189;
5707 -> 4186;
5708 -> 4201;
5709 -> 5708;
5709 -> 4022;
5710 -> 5709;
5710 -> 4024;
5710 -> 4022;
5711 -> 4220;
5712 -> 5711;
5712 -> 4060;
5713 -> 5712;
5713 -> 4062;
5713 -> 4060;
5714 -> 4058;
5714 -> 4090;
5714 -> 4216;
5714 -> 5713;
5714 -> 4225;
5714 -> 4086;
5714 -> 4087;
5714 -> 5699;
5714 -> 4097;
5714 -> 4089;
5715 -> 4240;
5716 -> 5715;
5716 -> 4109;
5717 -> 5716;
5717 -> 4111;
5717 -> 4109;
5718 -> 4107;
5718 -> 4141;
5718 -> 4236;
5718 -> 5717;
5718 -> 4245;
5718 -> 4135;
5718 -> 4136;
5718 -> 5703;
5718 -> 4143;
5718 -> 4140;
5719 -> 4260;
5720 -> 5719;
5720 -> 4155;
5721 -> 5720;
5721 -> 4157;
5721 -> 4155;
5722 -> 4153;
5722 -> 4187;
5722 -> 4256;
5722 -> 5721;
5722 -> 4265;
5722 -> 4181;
5722 -> 4182;
5722 -> 5707;
5722 -> 4189;
5722 -> 4186;
5723 -> 4201;
5724 -> 5723;
5724 -> 4022;
5725 -> 5724;
5725 -> 4024;
5725 -> 4022;
5726 -> 4220;
5727 -> 5726;
5727 -> 4060;
5728 -> 5727;
5728 -> 4062;
5728 -> 4060;
5729 -> 4058;
5729 -> 4090;
5729 -> 4216;
5729 -> 5728;
5729 -> 4225;
5729 -> 4086;
5729 -> 4087;
5729 -> 5714;
5729 -> 4097;
5729 -> 4089;
5730 -> 4240;
5731 -> 5730;
5731 -> 4109;
5732 -> 5731;
5732 -> 4111;
5732 -> 4109;
5733 -> 4107;
5733 -> 4141;
5733 -> 4236;
5733 -> 5732;
5733 -> 4245;
5733 -> 4135;
5733 -> 4136;
5733 -> 5718;
5733 -> 4143;
5733 -> 4140;
5734 -> 4260;
5735 -> 5734;
5735 -> 4155;
5736 -> 5735;
5736 -> 4157;
5736 -> 4155;
5737 -> 4153;
5737 -> 4187;
5737 -> 4256;
5737 -> 5736;
5737 -> 4265;
5737 -> 4181;
5737 -> 4182;
5737 -> 5722;
5737 -> 4189;
5737 -> 4186;
5738 -> 4201;
5739 -> 5738;
5739 -> 4022;
5740 -> 5739;
5740 -> 4024;
5740 -> 4022;
5741 -> 4220;
5742 -> 5741;
5742 -> 4060;
5743 -> 5742;
5743 -> 4062;
5743 -> 4060;
5744 -> 4058;
5744 -> 4090;
5744 -> 4216;
5744 -> 5743;
5744 -> 4225;
5744 -> 4086;
5744 -> 4087;
5744 -> 5729;
5744 -> 4097;
5744 -> 4089;
5745 -> 4240;
5746 -> 5745;
5746 -> 4109;
5747 -> 5746;
5747 -> 4111;
5747 -> 4109;
5748 -> 4107;
5748 -> 4141;
5748 -> 4236;
5748 -> 5747;
5748 -> 4245;
5748 -> 4135;
5748 -> 4136;
5748 -> 5733;
5748 -> 4143;
5748 -> 4140;
5749 -> 4260;
5750 -> 5749;
5750 -> 4155;
5751 -> 5750;
5751 -> 4157;
5751 -> 4155;
5752 -> 4153;
5752 -> 4187;
5752 -> 4256;
5752 -> 5751;
5752 -> 4265;
5752 -> 4181;
5752 -> 4182;
5752 -> 5737;
5752 -> 4189;
5752 -> 4186;
5753 -> 4201;
5754 -> 5753;
5754 -> 4022;
5755 -> 5754;
5755 -> 4024;
5755 -> 4022;
5756 -> 4220;
5757 -> 5756;
5757 -> 4060;
5758 -> 5757;
5758 -> 4062;
5758 -> 4060;
5759 -> 4058;
5759 -> 4090;
5759 -> 4216;
5759 -> 5758;
5759 -> 4225;
5759 -> 4086;
5759 -> 4087;
5759 -> 5744;
5759 -> 4097;
5759 -> 4089;
5760 -> 4240;
5761 -> 5760;
5761 -> 4109;
5762 -> 5761;
5762 -> 4111;
5762 -> 4109;
5763 -> 4107;
5763 -> 4141;
5763 -> 4236;
5763 -> 5762;
5763 -> 4245;
5763 -> 4135;
5763 -> 4136;
5763 -> 5748;
5763 -> 4143;
5763 -> 4140;
5764 -> 4260;
5765 -> 5764;
5765 -> 4155;
5766 -> 5765;
5766 -> 4157;
5766 -> 4155;
5767 -> 4153;
5767 -> 4187;
5767 -> 4256;
5767 -> 5766;
5767 -> 4265;
5767 -> 4181;
5767 -> 4182;
5767 -> 5752;
5767 -> 4189;
5767 -> 4186;
5768 -> 4201;
5769 -> 5768;
5769 -> 4022;
5770 -> 5769;
5770 -> 4024;
5770 -> 4022;
5771 -> 4220;
5772 -> 5771;
5772 -> 4060;
5773 -> 5772;
5773 -> 4062;
5773 -> 4060;
5774 -> 4058;
5774 -> 4090;
5774 -> 4216;
5774 -> 5773;
5774 -> 4225;
5774 -> 4086;
5774 -> 4087;
5774 -> 5759;
5774 -> 4097;
5774 -> 4089;
5775 -> 4240;
5776 -> 5775;
5776 -> 4109;
5777 -> 5776;
5777 -> 4111;
5777 -> 4109;
5778 -> 4107;
5778 -> 4141;
5778 -> 4236;
5778 -> 5777;
5778 -> 4245;
5778 -> 4135;
5778 -> 4136;
5778 -> 5763;
5778 -> 4143;
5778 -> 4140;
5779 -> 4260;
5780 -> 5779;
5780 -> 4155;
5781 -> 5780;
5781 -> 4157;
5781 -> 4155;
5782 -> 4153;
5782 -> 4187;
5782 -> 4256;
5782 -> 5781;
5782 -> 4265;
5782 -> 4181;
5782 -> 4182;
5782 -> 5767;
5782 -> 4189;
5782 -> 4186;
5783 -> 4201;
5784 -> 5783;
5784 -> 4022;
5785 -> 5784;
5785 -> 4024;
5785 -> 4022;
5786 -> 4220;
5787 -> 5786;
5787 -> 4060;
5788 -> 5787;
5788 -> 4062;
5788 -> 4060;
5789 -> 4058;
5789 -> 4090;
5789 -> 4216;
5789 -> 5788;
5789 -> 4225;
5789 -> 4086;
5789 -> 4087;
5789 -> 5774;
5789 -> 4097;
5789 -> 4089;
5790 -> 4240;
5791 -> 5790;
5791 -> 4109;
5792 -> 5791;
5792 -> 4111;
5792 -> 4109;
5793 -> 4107;
5793 -> 4141;
5793 -> 4236;
5793 -> 5792;
5793 -> 4245;
5793 -> 4135;
5793 -> 4136;
5793 -> 5778;
5793 -> 4143;
5793 -> 4140;
5794 -> 4260;
5795 -> 5794;
5795 -> 4155;
5796 -> 5795;
5796 -> 4157;
5796 -> 4155;
5797 -> 4153;
5797 -> 4187;
5797 -> 4256;
5797 -> 5796;
5797 -> 4265;
5797 -> 4181;
5797 -> 4182;
5797 -> 5782;
5797 -> 4189;
5797 -> 4186;
5798 -> 4201;
5799 -> 5798;
5799 -> 4022;
5800 -> 5799;
5800 -> 4024;
5800 -> 4022;
5801 -> 4220;
5802 -> 5801;
5802 -> 4060;
5803 -> 5802;
5803 -> 4062;
5803 -> 4060;
5804 -> 4058;
5804 -> 4090;
5804 -> 4216;
5804 -> 5803;
5804 -> 4225;
5804 -> 4086;
5804 -> 4087;
5804 -> 5789;
5804 -> 4097;
5804 -> 4089;
5805 -> 4240;
5806 -> 5805;
5806 -> 4109;
5807 -> 5806;
5807 -> 4111;
5807 -> 4109;
5808 -> 4107;
5808 -> 4141;
5808 -> 4236;
5808 -> 5807;
5808 -> 4245;
5808 -> 4135;
5808 -> 4136;
5808 -> 5793;
5808 -> 4143;
5808 -> 4140;
5809 -> 4260;
5810 -> 5809;
5810 -> 4155;
5811 -> 5810;
5811 -> 4157;
5811 -> 4155;
5812 -> 4153;
5812 -> 4187;
5812 -> 4256;
5812 -> 5811;
5812 -> 4265;
5812 -> 4181;
5812 -> 4182;
5812 -> 5797;
5812 -> 4189;
5812 -> 4186;
5813 -> 4201;
5814 -> 5813;
5814 -> 4022;
5815 -> 5814;
5815 -> 4024;
5815 -> 4022;
5816 -> 4220;
5817 -> 5816;
5817 -> 4060;
5818 -> 5817;
5818 -> 4062;
5818 -> 4060;
5819 -> 4058;
5819 -> 4090;
5819 -> 4216;
5819 -> 5818;
5819 -> 4225;
5819 -> 4086;
5819 -> 4087;
5819 -> 5804;
5819 -> 4097;
5819 -> 4089;
5820 -> 4240;
5821 -> 5820;
5821 -> 4109;
5822 -> 5821;
5822 -> 4111;
5822 -> 4109;
5823 -> 4107;
5823 -> 4141;
5823 -> 4236;
5823 -> 5822;
5823 -> 4245;
5823 -> 4135;
5823 -> 4136;
5823 -> 5808;
5823 -> 4143;
5823 -> 4140;
5824 -> 4260;
5825 -> 5824;
5825 -> 4155;
5826 -> 5825;
5826 -> 4157;
5826 -> 4155;
5827 -> 4153;
5827 -> 4187;
5827 -> 4256;
5827 -> 5826;
5827 -> 4265;
5827 -> 4181;
5827 -> 4182;
5827 -> 5812;
5827 -> 4189;
5827 -> 4186;
5828 -> 4201;
5829 -> 5828;
5829 -> 4022;
5830 -> 5829;
5830 -> 4024;
5830 -> 4022;
5831 -> 4220;
5832 -> 5831;
5832 -> 4060;
5833 -> 5832;
5833 -> 4062;
5833 -> 4060;
5834 -> 4058;
5834 -> 4090;
5834 -> 4216;
5834 -> 5833;
5834 -> 4225;
5834 -> 4086;
5834 -> 4087;
5834 -> 5819;
5834 -> 4097;
5834 -> 4089;
5835 -> 4240;
5836 -> 5835;
5836 -> 4109;
5837 -> 5836;
5837 -> 4111;
5837 -> 4109;
5838 -> 4107;
5838 -> 4141;
5838 -> 4236;
5838 -> 5837;
5838 -> 4245;
5838 -> 4135;
5838 -> 4136;
5838 -> 5823;
5838 -> 4143;
5838 -> 4140;
5839 -> 4260;
5840 -> 5839;
5840 -> 4155;
5841 -> 5840;
5841 -> 4157;
5841 -> 4155;
5842 -> 4153;
5842 -> 4187;
5842 -> 4256;
5842 -> 5841;
5842 -> 4265;
5842 -> 4181;
5842 -> 4182;
5842 -> 5827;
5842 -> 4189;
5842 -> 4186;
5843 -> 4201;
5844 -> 5843;
5844 -> 4022;
5845 -> 5844;
5845 -> 4024;
5845 -> 4022;
5846 -> 4220;
5847 -> 5846;
5847 -> 4060;
5848 -> 5847;
5848 -> 4062;
5848 -> 4060;
5849 -> 4058;
5849 -> 4090;
5849 -> 4216;
5849 -> 5848;
5849 -> 4225;
5849 -> 4086;
5849 -> 4087;
5849 -> 5834;
5849 -> 4097;
5849 -> 4089;
5850 -> 4240;
5851 -> 5850;
5851 -> 4109;
5852 -> 5851;
5852 -> 4111;
5852 -> 4109;
5853 -> 4107;
5853 -> 4141;
5853 -> 4236;
5853 -> 5852;
5853 -> 4245;
5853 -> 4135;
5853 -> 4136;
5853 -> 5838;
5853 -> 4143;
5853 -> 4140;
5854 -> 4260;
5855 -> 5854;
5855 -> 4155;
5856 -> 5855;
5856 -> 4157;
5856 -> 4155;
5857 -> 4153;
5857 -> 4187;
5857 -> 4256;
5857 -> 5856;
5857 -> 4265;
5857 -> 4181;
5857 -> 4182;
5857 -> 5842;
5857 -> 4189;
5857 -> 4186;
5858 -> 4201;
5859 -> 5858;
5859 -> 4022;
5860 -> 5859;
5860 -> 4024;
5860 -> 4022;
5861 -> 4220;
5862 -> 5861;
5862 -> 4060;
5863 -> 5862;
5863 -> 4062;
5863 -> 4060;
5864 -> 4058;
5864 -> 4090;
5864 -> 4216;
5864 -> 5863;
5864 -> 4225;
5864 -> 4086;
5864 -> 4087;
5864 -> 5849;
5864 -> 4097;
5864 -> 4089;
5865 -> 4240;
5866 -> 5865;
5866 -> 4109;
5867 -> 5866;
5867 -> 4111;
5867 -> 4109;
5868 -> 4107;
5868 -> 4141;
5868 -> 4236;
5868 -> 5867;
5868 -> 4245;
5868 -> 4135;
5868 -> 4136;
5868 -> 5853;
5868 -> 4143;
5868 -> 4140;
5869 -> 4260;
5870 -> 5869;
5870 -> 4155;
5871 -> 5870;
5871 -> 4157;
5871 -> 4155;
5872 -> 4153;
5872 -> 4187;
5872 -> 4256;
5872 -> 5871;
5872 -> 4265;
5872 -> 4181;
5872 -> 4182;
5872 -> 5857;
5872 -> 4189;
5872 -> 4186;
5873 -> 4201;
5874 -> 5873;
5874 -> 4022;
5875 -> 5874;
5875 -> 4024;
5875 -> 4022;
5876 -> 4220;
5877 -> 5876;
5877 -> 4060;
5878 -> 5877;
5878 -> 4062;
5878 -> 4060;
5879 -> 4058;
5879 -> 4090;
5879 -> 4216;
5879 -> 5878;
5879 -> 4225;
5879 -> 4086;
5879 -> 4087;
5879 -> 5864;
5879 -> 4097;
5879 -> 4089;
5880 -> 4240;
5881 -> 5880;
5881 -> 4109;
5882 -> 5881;
5882 -> 4111;
5882 -> 4109;
5883 -> 4107;
5883 -> 4141;
5883 -> 4236;
5883 -> 5882;
5883 -> 4245;
5883 -> 4135;
5883 -> 4136;
5883 -> 5868;
5883 -> 4143;
5883 -> 4140;
5884 -> 4260;
5885 -> 5884;
5885 -> 4155;
5886 -> 5885;
5886 -> 4157;
5886 -> 4155;
5887 -> 4153;
5887 -> 4187;
5887 -> 4256;
5887 -> 5886;
5887 -> 4265;
5887 -> 4181;
5887 -> 4182;
5887 -> 5872;
5887 -> 4189;
5887 -> 4186;
5888 -> 4201;
5889 -> 5888;
5889 -> 4022;
5890 -> 5889;
5890 -> 4024;
5890 -> 4022;
5891 -> 4220;
5892 -> 5891;
5892 -> 4060;
5893 -> 5892;
5893 -> 4062;
5893 -> 4060;
5894 -> 4058;
5894 -> 4090;
5894 -> 4216;
5894 -> 5893;
5894 -> 4225;
5894 -> 4086;
5894 -> 4087;
5894 -> 5879;
5894 -> 4097;
5894 -> 4089;
5895 -> 4240;
5896 -> 5895;
5896 -> 4109;
5897 -> 5896;
5897 -> 4111;
5897 -> 4109;
5898 -> 4107;
5898 -> 4141;
5898 -> 4236;
5898 -> 5897;
5898 -> 4245;
5898 -> 4135;
5898 -> 4136;
5898 -> 5883;
5898 -> 4143;
5898 -> 4140;
5899 -> 4260;
5900 -> 5899;
5900 -> 4155;
5901 -> 5900;
5901 -> 4157;
5901 -> 4155;
5902 -> 4153;
5902 -> 4187;
5902 -> 4256;
5902 -> 5901;
5902 -> 4265;
5902 -> 4181;
5902 -> 4182;
5902 -> 5887;
5902 -> 4189;
5902 -> 4186;
5903 -> 4201;
5904 -> 5903;
5904 -> 4022;
5905 -> 5904;
5905 -> 4024;
5905 -> 4022;
5906 -> 4220;
5907 -> 5906;
5907 -> 4060;
5908 -> 5907;
5908 -> 4062;
5908 -> 4060;
5909 -> 4058;
5909 -> 4090;
5909 -> 4216;
5909 -> 5908;
5909 -> 4225;
5909 -> 4086;
5909 -> 4087;
5909 -> 5894;
5909 -> 4097;
5909 -> 4089;
5910 -> 4240;
5911 -> 5910;
5911 -> 4109;
5912 -> 5911;
5912 -> 4111;
5912 -> 4109;
5913 -> 4107;
5913 -> 4141;
5913 -> 4236;
5913 -> 5912;
5913 -> 4245;
5913 -> 4135;
5913 -> 4136;
5913 -> 5898;
5913 -> 4143;
5913 -> 4140;
5914 -> 4260;
5915 -> 5914;
5915 -> 4155;
5916 -> 5915;
5916 -> 4157;
5916 -> 4155;
5917 -> 4153;
5917 -> 4187;
5917 -> 4256;
5917 -> 5916;
5917 -> 4265;
5917 -> 4181;
5917 -> 4182;
5917 -> 5902;
5917 -> 4189;
5917 -> 4186;
5918 -> 4201;
5919 -> 5918;
5919 -> 4022;
5920 -> 5919;
5920 -> 4024;
5920 -> 4022;
5921 -> 4220;
5922 -> 5921;
5922 -> 4060;
5923 -> 5922;
5923 -> 4062;
5923 -> 4060;
5924 -> 4058;
5924 -> 4090;
5924 -> 4216;
5924 -> 5923;
5924 -> 4225;
5924 -> 4086;
5924 -> 4087;
5924 -> 5909;
5924 -> 4097;
5924 -> 4089;
5925 -> 4240;
5926 -> 5925;
5926 -> 4109;
5927 -> 5926;
5927 -> 4111;
5927 -> 4109;
5928 -> 4107;
5928 -> 4141;
5928 -> 4236;
5928 -> 5927;
5928 -> 4245;
5928 -> 4135;
5928 -> 4136;
5928 -> 5913;
5928 -> 4143;
5928 -> 4140;
5929 -> 4260;
5930 -> 5929;
5930 -> 4155;
5931 -> 5930;
5931 -> 4157;
5931 -> 4155;
5932 -> 4153;
5932 -> 4187;
5932 -> 4256;
5932 -> 5931;
5932 -> 4265;
5932 -> 4181;
5932 -> 4182;
5932 -> 5917;
5932 -> 4189;
5932 -> 4186;
5933 -> 4201;
5934 -> 5933;
5934 -> 4022;
5935 -> 5934;
5935 -> 4024;
5935 -> 4022;
5936 -> 4220;
5937 -> 5936;
5937 -> 4060;
5938 -> 5937;
5938 -> 4062;
5938 -> 4060;
5939 -> 4058;
5939 -> 4090;
5939 -> 4216;
5939 -> 5938;
5939 -> 4225;
5939 -> 4086;
5939 -> 4087;
5939 -> 5924;
5939 -> 4097;
5939 -> 4089;
5940 -> 4240;
5941 -> 5940;
5941 -> 4109;
5942 -> 5941;
5942 -> 4111;
5942 -> 4109;
5943 -> 4107;
5943 -> 4141;
5943 -> 4236;
5943 -> 5942;
5943 -> 4245;
5943 -> 4135;
5943 -> 4136;
5943 -> 5928;
5943 -> 4143;
5943 -> 4140;
5944 -> 4260;
5945 -> 5944;
5945 -> 4155;
5946 -> 5945;
5946 -> 4157;
5946 -> 4155;
5947 -> 4153;
5947 -> 4187;
5947 -> 4256;
5947 -> 5946;
5947 -> 4265;
5947 -> 4181;
5947 -> 4182;
5947 -> 5932;
5947 -> 4189;
5947 -> 4186;
5948 -> 4201;
5949 -> 5948;
5949 -> 4022;
5950 -> 5949;
5950 -> 4024;
5950 -> 4022;
5951 -> 4220;
5952 -> 5951;
5952 -> 4060;
5953 -> 5952;
5953 -> 4062;
5953 -> 4060;
5954 -> 4058;
5954 -> 4090;
5954 -> 4216;
5954 -> 5953;
5954 -> 4225;
5954 -> 4086;
5954 -> 4087;
5954 -> 5939;
5954 -> 4097;
5954 -> 4089;
5955 -> 4240;
5956 -> 5955;
5956 -> 4109;
5957 -> 5956;
5957 -> 4111;
5957 -> 4109;
5958 -> 4107;
5958 -> 4141;
5958 -> 4236;
5958 -> 5957;
5958 -> 4245;
5958 -> 4135;
5958 -> 4136;
5958 -> 5943;
5958 -> 4143;
5958 -> 4140;
5959 -> 4260;
5960 -> 5959;
5960 -> 4155;
5961 -> 5960;
5961 -> 4157;
5961 -> 4155;
5962 -> 4153;
5962 -> 4187;
5962 -> 4256;
5962 -> 5961;
5962 -> 4265;
5962 -> 4181;
5962 -> 4182;
5962 -> 5947;
5962 -> 4189;
5962 -> 4186;
5963 -> 4201;
5964 -> 5963;
5964 -> 4022;
5965 -> 5964;
5965 -> 4024;
5965 -> 4022;
5966 -> 4220;
5967 -> 5966;
5967 -> 4060;
5968 -> 5967;
5968 -> 4062;
5968 -> 4060;
5969 -> 4058;
5969 -> 4090;
5969 -> 4216;
5969 -> 5968;
5969 -> 4225;
5969 -> 4086;
5969 -> 4087;
5969 -> 5954;
5969 -> 4097;
5969 -> 4089;
5970 -> 4240;
5971 -> 5970;
5971 -> 4109;
5972 -> 5971;
5972 -> 4111;
5972 -> 4109;
5973 -> 4107;
5973 -> 4141;
5973 -> 4236;
5973 -> 5972;
5973 -> 4245;
5973 -> 4135;
5973 -> 4136;
5973 -> 5958;
5973 -> 4143;
5973 -> 4140;
5974 -> 4260;
5975 -> 5974;
5975 -> 4155;
5976 -> 5975;
5976 -> 4157;
5976 -> 4155;
5977 -> 4153;
5977 -> 4187;
5977 -> 4256;
5977 -> 5976;
5977 -> 4265;
5977 -> 4181;
5977 -> 4182;
5977 -> 5962;
5977 -> 4189;
5977 -> 4186;
5978 -> 4201;
5979 -> 5978;
5979 -> 4022;
5980 -> 5979;
5980 -> 4024;
5980 -> 4022;
5981 -> 4220;
5982 -> 5981;
5982 -> 4060;
5983 -> 5982;
5983 -> 4062;
5983 -> 4060;
5984 -> 4058;
5984 -> 4090;
5984 -> 4216;
5984 -> 5983;
5984 -> 4225;
5984 -> 4086;
5984 -> 4087;
5984 -> 5969;
5984 -> 4097;
5984 -> 4089;
5985 -> 4240;
5986 -> 5985;
5986 -> 4109;
5987 -> 5986;
5987 -> 4111;
5987 -> 4109;
5988 -> 4107;
5988 -> 4141;
5988 -> 4236;
5988 -> 5987;
5988 -> 4245;
5988 -> 4135;
5988 -> 4136;
5988 -> 5973;
5988 -> 4143;
5988 -> 4140;
5989 -> 4260;
5990 -> 5989;
5990 -> 4155;
5991 -> 5990;
5991 -> 4157;
5991 -> 4155;
5992 -> 4153;
5992 -> 4187;
5992 -> 4256;
5992 -> 5991;
5992 -> 4265;
5992 -> 4181;
5992 -> 4182;
5992 -> 5977;
5992 -> 4189;
5992 -> 4186;
5993 -> 4201;
5994 -> 5993;
5994 -> 4022;
5995 -> 5994;
5995 -> 4024;
5995 -> 4022;
5996 -> 4220;
5997 -> 5996;
5997 -> 4060;
5998 -> 5997;
5998 -> 4062;
5998 -> 4060;
5999 -> 4058;
5999 -> 4090;
5999 -> 4216;
5999 -> 5998;
5999 -> 4225;
5999 -> 4086;
5999 -> 4087;
5999 -> 5984;
5999 -> 4097;
5999 -> 4089;
6000 -> 4240;
6001 -> 6000;
6001 -> 4109;
6002 -> 6001;
6002 -> 4111;
6002 -> 4109;
6003 -> 4107;
6003 -> 4141;
6003 -> 4236;
6003 -> 6002;
6003 -> 4245;
6003 -> 4135;
6003 -> 4136;
6003 -> 5988;
6003 -> 4143;
6003 -> 4140;
6004 -> 4260;
6005 -> 6004;
6005 -> 4155;
6006 -> 6005;
6006 -> 4157;
6006 -> 4155;
6007 -> 4153;
6007 -> 4187;
6007 -> 4256;
6007 -> 6006;
6007 -> 4265;
6007 -> 4181;
6007 -> 4182;
6007 -> 5992;
6007 -> 4189;
6007 -> 4186;
6008 -> 4201;
6009 -> 6008;
6009 -> 4022;
6010 -> 6009;
6010 -> 4024;
6010 -> 4022;
6011 -> 4220;
6012 -> 6011;
6012 -> 4060;
6013 -> 6012;
6013 -> 4062;
6013 -> 4060;
6014 -> 4058;
6014 -> 4090;
6014 -> 4216;
6014 -> 6013;
6014 -> 4225;
6014 -> 4086;
6014 -> 4087;
6014 -> 5999;
6014 -> 4097;
6014 -> 4089;
6015 -> 4240;
6016 -> 6015;
6016 -> 4109;
6017 -> 6016;
6017 -> 4111;
6017 -> 4109;
6018 -> 4107;
6018 -> 4141;
6018 -> 4236;
6018 -> 6017;
6018 -> 4245;
6018 -> 4135;
6018 -> 4136;
6018 -> 6003;
6018 -> 4143;
6018 -> 4140;
6019 -> 4260;
6020 -> 6019;
6020 -> 4155;
6021 -> 6020;
6021 -> 4157;
6021 -> 4155;
6022 -> 4153;
6022 -> 4187;
6022 -> 4256;
6022 -> 6021;
6022 -> 4265;
6022 -> 4181;
6022 -> 4182;
6022 -> 6007;
6022 -> 4189;
6022 -> 4186;
6023 -> 4201;
6024 -> 6023;
6024 -> 4022;
6025 -> 6024;
6025 -> 4024;
6025 -> 4022;
6026 -> 4220;
6027 -> 6026;
6027 -> 4060;
6028 -> 6027;
6028 -> 4062;
6028 -> 4060;
6029 -> 4058;
6029 -> 4090;
6029 -> 4216;
6029 -> 6028;
6029 -> 4225;
6029 -> 4086;
6029 -> 4087;
6029 -> 6014;
6029 -> 4097;
6029 -> 4089;
6030 -> 4240;
6031 -> 6030;
6031 -> 4109;
6032 -> 6031;
6032 -> 4111;
6032 -> 4109;
6033 -> 4107;
6033 -> 4141;
6033 -> 4236;
6033 -> 6032;
6033 -> 4245;
6033 -> 4135;
6033 -> 4136;
6033 -> 6018;
6033 -> 4143;
6033 -> 4140;
6034 -> 4260;
6035 -> 6034;
6035 -> 4155;
6036 -> 6035;
6036 -> 4157;
6036 -> 4155;
6037 -> 4153;
6037 -> 4187;
6037 -> 4256;
6037 -> 6036;
6037 -> 4265;
6037 -> 4181;
6037 -> 4182;
6037 -> 6022;
6037 -> 4189;
6037 -> 4186;
6038 -> 4201;
6039 -> 6038;
6039 -> 4022;
6040 -> 6039;
6040 -> 4024;
6040 -> 4022;
6041 -> 4220;
6042 -> 6041;
6042 -> 4060;
6043 -> 6042;
6043 -> 4062;
6043 -> 4060;
6044 -> 4058;
6044 -> 4090;
6044 -> 4216;
6044 -> 6043;
6044 -> 4225;
6044 -> 4086;
6044 -> 4087;
6044 -> 6029;
6044 -> 4097;
6044 -> 4089;
6045 -> 4240;
6046 -> 6045;
6046 -> 4109;
6047 -> 6046;
6047 -> 4111;
6047 -> 4109;
6048 -> 4107;
6048 -> 4141;
6048 -> 4236;
6048 -> 6047;
6048 -> 4245;
6048 -> 4135;
6048 -> 4136;
6048 -> 6033;
6048 -> 4143;
6048 -> 4140;
6049 -> 4260;
6050 -> 6049;
6050 -> 4155;
6051 -> 6050;
6051 -> 4157;
6051 -> 4155;
6052 -> 4153;
6052 -> 4187;
6052 -> 4256;
6052 -> 6051;
6052 -> 4265;
6052 -> 4181;
6052 -> 4182;
6052 -> 6037;
6052 -> 4189;
6052 -> 4186;
6053 -> 4201;
6054 -> 6053;
6054 -> 4022;
6055 -> 6054;
6055 -> 4024;
6055 -> 4022;
6056 -> 4220;
6057 -> 6056;
6057 -> 4060;
6058 -> 6057;
6058 -> 4062;
6058 -> 4060;
6059 -> 4058;
6059 -> 4090;
6059 -> 4216;
6059 -> 6058;
6059 -> 4225;
6059 -> 4086;
6059 -> 4087;
6059 -> 6044;
6059 -> 4097;
6059 -> 4089;
6060 -> 4240;
6061 -> 6060;
6061 -> 4109;
6062 -> 6061;
6062 -> 4111;
6062 -> 4109;
6063 -> 4107;
6063 -> 4141;
6063 -> 4236;
6063 -> 6062;
6063 -> 4245;
6063 -> 4135;
6063 -> 4136;
6063 -> 6048;
6063 -> 4143;
6063 -> 4140;
6064 -> 4260;
6065 -> 6064;
6065 -> 4155;
6066 -> 6065;
6066 -> 4157;
6066 -> 4155;
6067 -> 4153;
6067 -> 4187;
6067 -> 4256;
6067 -> 6066;
6067 -> 4265;
6067 -> 4181;
6067 -> 4182;
6067 -> 6052;
6067 -> 4189;
6067 -> 4186;
6068 -> 4201;
6069 -> 6068;
6069 -> 4022;
6070 -> 6069;
6070 -> 4024;
6070 -> 4022;
6071 -> 4220;
6072 -> 6071;
6072 -> 4060;
6073 -> 6072;
6073 -> 4062;
6073 -> 4060;
6074 -> 4058;
6074 -> 4090;
6074 -> 4216;
6074 -> 6073;
6074 -> 4225;
6074 -> 4086;
6074 -> 4087;
6074 -> 6059;
6074 -> 4097;
6074 -> 4089;
6075 -> 4240;
6076 -> 6075;
6076 -> 4109;
6077 -> 6076;
6077 -> 4111;
6077 -> 4109;
6078 -> 4107;
6078 -> 4141;
6078 -> 4236;
6078 -> 6077;
6078 -> 4245;
6078 -> 4135;
6078 -> 4136;
6078 -> 6063;
6078 -> 4143;
6078 -> 4140;
6079 -> 4260;
6080 -> 6079;
6080 -> 4155;
6081 -> 6080;
6081 -> 4157;
6081 -> 4155;
6082 -> 4153;
6082 -> 4187;
6082 -> 4256;
6082 -> 6081;
6082 -> 4265;
6082 -> 4181;
6082 -> 4182;
6082 -> 6067;
6082 -> 4189;
6082 -> 4186;
6083 -> 4201;
6084 -> 6083;
6084 -> 4022;
6085 -> 6084;
6085 -> 4024;
6085 -> 4022;
6086 -> 4220;
6087 -> 6086;
6087 -> 4060;
6088 -> 6087;
6088 -> 4062;
6088 -> 4060;
6089 -> 4058;
6089 -> 4090;
6089 -> 4216;
6089 -> 6088;
6089 -> 4225;
6089 -> 4086;
6089 -> 4087;
6089 -> 6074;
6089 -> 4097;
6089 -> 4089;
6090 -> 4240;
6091 -> 6090;
6091 -> 4109;
6092 -> 6091;
6092 -> 4111;
6092 -> 4109;
6093 -> 4107;
6093 -> 4141;
6093 -> 4236;
6093 -> 6092;
6093 -> 4245;
6093 -> 4135;
6093 -> 4136;
6093 -> 6078;
6093 -> 4143;
6093 -> 4140;
6094 -> 4260;
6095 -> 6094;
6095 -> 4155;
6096 -> 6095;
6096 -> 4157;
6096 -> 4155;
6097 -> 4153;
6097 -> 4187;
6097 -> 4256;
6097 -> 6096;
6097 -> 4265;
6097 -> 4181;
6097 -> 4182;
6097 -> 6082;
6097 -> 4189;
6097 -> 4186;
6098 -> 4201;
6099 -> 6098;
6099 -> 4022;
6100 -> 6099;
6100 -> 4024;
6100 -> 4022;
6101 -> 4220;
6102 -> 6101;
6102 -> 4060;
6103 -> 6102;
6103 -> 4062;
6103 -> 4060;
6104 -> 4058;
6104 -> 4090;
6104 -> 4216;
6104 -> 6103;
6104 -> 4225;
6104 -> 4086;
6104 -> 4087;
6104 -> 6089;
6104 -> 4097;
6104 -> 4089;
6105 -> 4240;
6106 -> 6105;
6106 -> 4109;
6107 -> 6106;
6107 -> 4111;
6107 -> 4109;
6108 -> 4107;
6108 -> 4141;
6108 -> 4236;
6108 -> 6107;
6108 -> 4245;
6108 -> 4135;
6108 -> 4136;
6108 -> 6093;
6108 -> 4143;
6108 -> 4140;
6109 -> 4260;
6110 -> 6109;
6110 -> 4155;
6111 -> 6110;
6111 -> 4157;
6111 -> 4155;
6112 -> 4153;
6112 -> 4187;
6112 -> 4256;
6112 -> 6111;
6112 -> 4265;
6112 -> 4181;
6112 -> 4182;
6112 -> 6097;
6112 -> 4189;
6112 -> 4186;
6113 -> 4201;
6114 -> 6113;
6114 -> 4022;
6115 -> 6114;
6115 -> 4024;
6115 -> 4022;
6116 -> 4220;
6117 -> 6116;
6117 -> 4060;
6118 -> 6117;
6118 -> 4062;
6118 -> 4060;
6119 -> 4058;
6119 -> 4090;
6119 -> 4216;
6119 -> 6118;
6119 -> 4225;
6119 -> 4086;
6119 -> 4087;
6119 -> 6104;
6119 -> 4097;
6119 -> 4089;
6120 -> 4240;
6121 -> 6120;
6121 -> 4109;
6122 -> 6121;
6122 -> 4111;
6122 -> 4109;
6123 -> 4107;
6123 -> 4141;
6123 -> 4236;
6123 -> 6122;
6123 -> 4245;
6123 -> 4135;
6123 -> 4136;
6123 -> 6108;
6123 -> 4143;
6123 -> 4140;
6124 -> 4260;
6125 -> 6124;
6125 -> 4155;
6126 -> 6125;
6126 -> 4157;
6126 -> 4155;
6127 -> 4153;
6127 -> 4187;
6127 -> 4256;
6127 -> 6126;
6127 -> 4265;
6127 -> 4181;
6127 -> 4182;
6127 -> 6112;
6127 -> 4189;
6127 -> 4186;
6128 -> 4201;
6129 -> 6128;
6129 -> 4022;
6130 -> 6129;
6130 -> 4024;
6130 -> 4022;
6131 -> 4220;
6132 -> 6131;
6132 -> 4060;
6133 -> 6132;
6133 -> 4062;
6133 -> 4060;
6134 -> 4058;
6134 -> 4090;
6134 -> 4216;
6134 -> 6133;
6134 -> 4225;
6134 -> 4086;
6134 -> 4087;
6134 -> 6119;
6134 -> 4097;
6134 -> 4089;
6135 -> 4240;
6136 -> 6135;
6136 -> 4109;
6137 -> 6136;
6137 -> 4111;
6137 -> 4109;
6138 -> 4107;
6138 -> 4141;
6138 -> 4236;
6138 -> 6137;
6138 -> 4245;
6138 -> 4135;
6138 -> 4136;
6138 -> 6123;
6138 -> 4143;
6138 -> 4140;
6139 -> 4260;
6140 -> 6139;
6140 -> 4155;
6141 -> 6140;
6141 -> 4157;
6141 -> 4155;
6142 -> 4153;
6142 -> 4187;
6142 -> 4256;
6142 -> 6141;
6142 -> 4265;
6142 -> 4181;
6142 -> 4182;
6142 -> 6127;
6142 -> 4189;
6142 -> 4186;
6143 -> 4201;
6144 -> 6143;
6144 -> 4022;
6145 -> 6144;
6145 -> 4024;
6145 -> 4022;
6146 -> 4220;
6147 -> 6146;
6147 -> 4060;
6148 -> 6147;
6148 -> 4062;
6148 -> 4060;
6149 -> 4058;
6149 -> 4090;
6149 -> 4216;
6149 -> 6148;
6149 -> 4225;
6149 -> 4086;
6149 -> 4087;
6149 -> 6134;
6149 -> 4097;
6149 -> 4089;
6150 -> 4240;
6151 -> 6150;
6151 -> 4109;
6152 -> 6151;
6152 -> 4111;
6152 -> 4109;
6153 -> 4107;
6153 -> 4141;
6153 -> 4236;
6153 -> 6152;
6153 -> 4245;
6153 -> 4135;
6153 -> 4136;
6153 -> 6138;
6153 -> 4143;
6153 -> 4140;
6154 -> 4260;
6155 -> 6154;
6155 -> 4155;
6156 -> 6155;
6156 -> 4157;
6156 -> 4155;
6157 -> 4153;
6157 -> 4187;
6157 -> 4256;
6157 -> 6156;
6157 -> 4265;
6157 -> 4181;
6157 -> 4182;
6157 -> 6142;
6157 -> 4189;
6157 -> 4186;
6158 -> 4201;
6159 -> 6158;
6159 -> 4022;
6160 -> 6159;
6160 -> 4024;
6160 -> 4022;
6161 -> 4220;
6162 -> 6161;
6162 -> 4060;
6163 -> 6162;
6163 -> 4062;
6163 -> 4060;
6164 -> 4058;
6164 -> 4090;
6164 -> 4216;
6164 -> 6163;
6164 -> 4225;
6164 -> 4086;
6164 -> 4087;
6164 -> 6149;
6164 -> 4097;
6164 -> 4089;
6165 -> 4240;
6166 -> 6165;
6166 -> 4109;
6167 -> 6166;
6167 -> 4111;
6167 -> 4109;
6168 -> 4107;
6168 -> 4141;
6168 -> 4236;
6168 -> 6167;
6168 -> 4245;
6168 -> 4135;
6168 -> 4136;
6168 -> 6153;
6168 -> 4143;
6168 -> 4140;
6169 -> 4260;
6170 -> 6169;
6170 -> 4155;
6171 -> 6170;
6171 -> 4157;
6171 -> 4155;
6172 -> 4153;
6172 -> 4187;
6172 -> 4256;
6172 -> 6171;
6172 -> 4265;
6172 -> 4181;
6172 -> 4182;
6172 -> 6157;
6172 -> 4189;
6172 -> 4186;
6173 -> 4201;
6174 -> 6173;
6174 -> 4022;
6175 -> 6174;
6175 -> 4024;
6175 -> 4022;
6176 -> 4220;
6177 -> 6176;
6177 -> 4060;
6178 -> 6177;
6178 -> 4062;
6178 -> 4060;
6179 -> 4058;
6179 -> 4090;
6179 -> 4216;
6179 -> 6178;
6179 -> 4225;
6179 -> 4086;
6179 -> 4087;
6179 -> 6164;
6179 -> 4097;
6179 -> 4089;
6180 -> 4240;
6181 -> 6180;
6181 -> 4109;
6182 -> 6181;
6182 -> 4111;
6182 -> 4109;
6183 -> 4107;
6183 -> 4141;
6183 -> 4236;
6183 -> 6182;
6183 -> 4245;
6183 -> 4135;
6183 -> 4136;
6183 -> 6168;
6183 -> 4143;
6183 -> 4140;
6184 -> 4260;
6185 -> 6184;
6185 -> 4155;
6186 -> 6185;
6186 -> 4157;
6186 -> 4155;
6187 -> 4153;
6187 -> 4187;
6187 -> 4256;
6187 -> 6186;
6187 -> 4265;
6187 -> 4181;
6187 -> 4182;
6187 -> 6172;
6187 -> 4189;
6187 -> 4186;
6188 -> 4201;
6189 -> 6188;
6189 -> 4022;
6190 -> 6189;
6190 -> 4024;
6190 -> 4022;
6191 -> 4220;
6192 -> 6191;
6192 -> 4060;
6193 -> 6192;
6193 -> 4062;
6193 -> 4060;
6194 -> 4058;
6194 -> 4090;
6194 -> 4216;
6194 -> 6193;
6194 -> 4225;
6194 -> 4086;
6194 -> 4087;
6194 -> 6179;
6194 -> 4097;
6194 -> 4089;
6195 -> 4240;
6196 -> 6195;
6196 -> 4109;
6197 -> 6196;
6197 -> 4111;
6197 -> 4109;
6198 -> 4107;
6198 -> 4141;
6198 -> 4236;
6198 -> 6197;
6198 -> 4245;
6198 -> 4135;
6198 -> 4136;
6198 -> 6183;
6198 -> 4143;
6198 -> 4140;
6199 -> 4260;
6200 -> 6199;
6200 -> 4155;
6201 -> 6200;
6201 -> 4157;
6201 -> 4155;
6202 -> 4153;
6202 -> 4187;
6202 -> 4256;
6202 -> 6201;
6202 -> 4265;
6202 -> 4181;
6202 -> 4182;
6202 -> 6187;
6202 -> 4189;
6202 -> 4186;
6203 -> 4201;
6204 -> 6203;
6204 -> 4022;
6205 -> 6204;
6205 -> 4024;
6205 -> 4022;
6206 -> 4220;
6207 -> 6206;
6207 -> 4060;
6208 -> 6207;
6208 -> 4062;
6208 -> 4060;
6209 -> 4058;
6209 -> 4090;
6209 -> 4216;
6209 -> 6208;
6209 -> 4225;
6209 -> 4086;
6209 -> 4087;
6209 -> 6194;
6209 -> 4097;
6209 -> 4089;
6210 -> 4240;
6211 -> 6210;
6211 -> 4109;
6212 -> 6211;
6212 -> 4111;
6212 -> 4109;
6213 -> 4107;
6213 -> 4141;
6213 -> 4236;
6213 -> 6212;
6213 -> 4245;
6213 -> 4135;
6213 -> 4136;
6213 -> 6198;
6213 -> 4143;
6213 -> 4140;
6214 -> 4260;
6215 -> 6214;
6215 -> 4155;
6216 -> 6215;
6216 -> 4157;
6216 -> 4155;
6217 -> 4153;
6217 -> 4187;
6217 -> 4256;
6217 -> 6216;
6217 -> 4265;
6217 -> 4181;
6217 -> 4182;
6217 -> 6202;
6217 -> 4189;
6217 -> 4186;
6218 -> 4201;
6219 -> 6218;
6219 -> 4022;
6220 -> 6219;
6220 -> 4024;
6220 -> 4022;
6221 -> 4220;
6222 -> 6221;
6222 -> 4060;
6223 -> 6222;
6223 -> 4062;
6223 -> 4060;
6224 -> 4058;
6224 -> 4090;
6224 -> 4216;
6224 -> 6223;
6224 -> 4225;
6224 -> 4086;
6224 -> 4087;
6224 -> 6209;
6224 -> 4097;
6224 -> 4089;
6225 -> 4240;
6226 -> 6225;
6226 -> 4109;
6227 -> 6226;
6227 -> 4111;
6227 -> 4109;
6228 -> 4107;
6228 -> 4141;
6228 -> 4236;
6228 -> 6227;
6228 -> 4245;
6228 -> 4135;
6228 -> 4136;
6228 -> 6213;
6228 -> 4143;
6228 -> 4140;
6229 -> 4260;
6230 -> 6229;
6230 -> 4155;
6231 -> 6230;
6231 -> 4157;
6231 -> 4155;
6232 -> 4153;
6232 -> 4187;
6232 -> 4256;
6232 -> 6231;
6232 -> 4265;
6232 -> 4181;
6232 -> 4182;
6232 -> 6217;
6232 -> 4189;
6232 -> 4186;
6233 -> 4201;
6234 -> 6233;
6234 -> 4022;
6235 -> 6234;
6235 -> 4024;
6235 -> 4022;
6236 -> 4220;
6237 -> 6236;
6237 -> 4060;
6238 -> 6237;
6238 -> 4062;
6238 -> 4060;
6239 -> 4058;
6239 -> 4090;
6239 -> 4216;
6239 -> 6238;
6239 -> 4225;
6239 -> 4086;
6239 -> 4087;
6239 -> 6224;
6239 -> 4097;
6239 -> 4089;
6240 -> 4240;
6241 -> 6240;
6241 -> 4109;
6242 -> 6241;
6242 -> 4111;
6242 -> 4109;
6243 -> 4107;
6243 -> 4141;
6243 -> 4236;
6243 -> 6242;
6243 -> 4245;
6243 -> 4135;
6243 -> 4136;
6243 -> 6228;
6243 -> 4143;
6243 -> 4140;
6244 -> 4260;
6245 -> 6244;
6245 -> 4155;
6246 -> 6245;
6246 -> 4157;
6246 -> 4155;
6247 -> 4153;
6247 -> 4187;
6247 -> 4256;
6247 -> 6246;
6247 -> 4265;
6247 -> 4181;
6247 -> 4182;
6247 -> 6232;
6247 -> 4189;
6247 -> 4186;
6248 -> 4201;
6249 -> 6248;
6249 -> 4022;
6250 -> 6249;
6250 -> 4024;
6250 -> 4022;
6251 -> 4220;
6252 -> 6251;
6252 -> 4060;
6253 -> 6252;
6253 -> 4062;
6253 -> 4060;
6254 -> 4058;
6254 -> 4090;
6254 -> 4216;
6254 -> 6253;
6254 -> 4225;
6254 -> 4086;
6254 -> 4087;
6254 -> 6239;
6254 -> 4097;
6254 -> 4089;
6255 -> 4240;
6256 -> 6255;
6256 -> 4109;
6257 -> 6256;
6257 -> 4111;
6257 -> 4109;
6258 -> 4107;
6258 -> 4141;
6258 -> 4236;
6258 -> 6257;
6258 -> 4245;
6258 -> 4135;
6258 -> 4136;
6258 -> 6243;
6258 -> 4143;
6258 -> 4140;
6259 -> 4260;
6260 -> 6259;
6260 -> 4155;
6261 -> 6260;
6261 -> 4157;
6261 -> 4155;
6262 -> 4153;
6262 -> 4187;
6262 -> 4256;
6262 -> 6261;
6262 -> 4265;
6262 -> 4181;
6262 -> 4182;
6262 -> 6247;
6262 -> 4189;
6262 -> 4186;
6263 -> 4201;
6264 -> 6263;
6264 -> 4022;
6265 -> 6264;
6265 -> 4024;
6265 -> 4022;
6266 -> 4220;
6267 -> 6266;
6267 -> 4060;
6268 -> 6267;
6268 -> 4062;
6268 -> 4060;
6269 -> 4058;
6269 -> 4090;
6269 -> 4216;
6269 -> 6268;
6269 -> 4225;
6269 -> 4086;
6269 -> 4087;
6269 -> 6254;
6269 -> 4097;
6269 -> 4089;
6270 -> 4240;
6271 -> 6270;
6271 -> 4109;
6272 -> 6271;
6272 -> 4111;
6272 -> 4109;
6273 -> 4107;
6273 -> 4141;
6273 -> 4236;
6273 -> 6272;
6273 -> 4245;
6273 -> 4135;
6273 -> 4136;
6273 -> 6258;
6273 -> 4143;
6273 -> 4140;
6274 -> 4260;
6275 -> 6274;
6275 -> 4155;
6276 -> 6275;
6276 -> 4157;
6276 -> 4155;
6277 -> 4153;
6277 -> 4187;
6277 -> 4256;
6277 -> 6276;
6277 -> 4265;
6277 -> 4181;
6277 -> 4182;
6277 -> 6262;
6277 -> 4189;
6277 -> 4186;
6278 -> 4201;
6279 -> 6278;
6279 -> 4022;
6280 -> 6279;
6280 -> 4024;
6280 -> 4022;
6281 -> 4220;
6282 -> 6281;
6282 -> 4060;
6283 -> 6282;
6283 -> 4062;
6283 -> 4060;
6284 -> 4058;
6284 -> 4090;
6284 -> 4216;
6284 -> 6283;
6284 -> 4225;
6284 -> 4086;
6284 -> 4087;
6284 -> 6269;
6284 -> 4097;
6284 -> 4089;
6285 -> 4240;
6286 -> 6285;
6286 -> 4109;
6287 -> 6286;
6287 -> 4111;
6287 -> 4109;
6288 -> 4107;
6288 -> 4141;
6288 -> 4236;
6288 -> 6287;
6288 -> 4245;
6288 -> 4135;
6288 -> 4136;
6288 -> 6273;
6288 -> 4143;
6288 -> 4140;
6289 -> 4260;
6290 -> 6289;
6290 -> 4155;
6291 -> 6290;
6291 -> 4157;
6291 -> 4155;
6292 -> 4153;
6292 -> 4187;
6292 -> 4256;
6292 -> 6291;
6292 -> 4265;
6292 -> 4181;
6292 -> 4182;
6292 -> 6277;
6292 -> 4189;
6292 -> 4186;
6293 -> 4201;
6294 -> 6293;
6294 -> 4022;
6295 -> 6294;
6295 -> 4024;
6295 -> 4022;
6296 -> 4220;
6297 -> 6296;
6297 -> 4060;
6298 -> 6297;
6298 -> 4062;
6298 -> 4060;
6299 -> 4058;
6299 -> 4090;
6299 -> 4216;
6299 -> 6298;
6299 -> 4225;
6299 -> 4086;
6299 -> 4087;
6299 -> 6284;
6299 -> 4097;
6299 -> 4089;
6300 -> 4240;
6301 -> 6300;
6301 -> 4109;
6302 -> 6301;
6302 -> 4111;
6302 -> 4109;
6303 -> 4107;
6303 -> 4141;
6303 -> 4236;
6303 -> 6302;
6303 -> 4245;
6303 -> 4135;
6303 -> 4136;
6303 -> 6288;
6303 -> 4143;
6303 -> 4140;
6304 -> 4260;
6305 -> 6304;
6305 -> 4155;
6306 -> 6305;
6306 -> 4157;
6306 -> 4155;
6307 -> 4153;
6307 -> 4187;
6307 -> 4256;
6307 -> 6306;
6307 -> 4265;
6307 -> 4181;
6307 -> 4182;
6307 -> 6292;
6307 -> 4189;
6307 -> 4186;
6308 -> 4201;
6309 -> 6308;
6309 -> 4022;
6310 -> 6309;
6310 -> 4024;
6310 -> 4022;
6311 -> 4220;
6312 -> 6311;
6312 -> 4060;
6313 -> 6312;
6313 -> 4062;
6313 -> 4060;
6314 -> 4058;
6314 -> 4090;
6314 -> 4216;
6314 -> 6313;
6314 -> 4225;
6314 -> 4086;
6314 -> 4087;
6314 -> 6299;
6314 -> 4097;
6314 -> 4089;
6315 -> 4240;
6316 -> 6315;
6316 -> 4109;
6317 -> 6316;
6317 -> 4111;
6317 -> 4109;
6318 -> 4107;
6318 -> 4141;
6318 -> 4236;
6318 -> 6317;
6318 -> 4245;
6318 -> 4135;
6318 -> 4136;
6318 -> 6303;
6318 -> 4143;
6318 -> 4140;
6319 -> 4260;
6320 -> 6319;
6320 -> 4155;
6321 -> 6320;
6321 -> 4157;
6321 -> 4155;
6322 -> 4153;
6322 -> 4187;
6322 -> 4256;
6322 -> 6321;
6322 -> 4265;
6322 -> 4181;
6322 -> 4182;
6322 -> 6307;
6322 -> 4189;
6322 -> 4186;
6323 -> 4201;
6324 -> 6323;
6324 -> 4022;
6325 -> 6324;
6325 -> 4024;
6325 -> 4022;
6326 -> 4220;
6327 -> 6326;
6327 -> 4060;
6328 -> 6327;
6328 -> 4062;
6328 -> 4060;
6329 -> 4058;
6329 -> 4090;
6329 -> 4216;
6329 -> 6328;
6329 -> 4225;
6329 -> 4086;
6329 -> 4087;
6329 -> 6314;
6329 -> 4097;
6329 -> 4089;
6330 -> 4240;
6331 -> 6330;
6331 -> 4109;
6332 -> 6331;
6332 -> 4111;
6332 -> 4109;
6333 -> 4107;
6333 -> 4141;
6333 -> 4236;
6333 -> 6332;
6333 -> 4245;
6333 -> 4135;
6333 -> 4136;
6333 -> 6318;
6333 -> 4143;
6333 -> 4140;
6334 -> 4260;
6335 -> 6334;
6335 -> 4155;
6336 -> 6335;
6336 -> 4157;
6336 -> 4155;
6337 -> 4153;
6337 -> 4187;
6337 -> 4256;
6337 -> 6336;
6337 -> 4265;
6337 -> 4181;
6337 -> 4182;
6337 -> 6322;
6337 -> 4189;
6337 -> 4186;
6338 -> 4201;
6339 -> 6338;
6339 -> 4022;
6340 -> 6339;
6340 -> 4024;
6340 -> 4022;
6341 -> 4220;
6342 -> 6341;
6342 -> 4060;
6343 -> 6342;
6343 -> 4062;
6343 -> 4060;
6344 -> 4058;
6344 -> 4090;
6344 -> 4216;
6344 -> 6343;
6344 -> 4225;
6344 -> 4086;
6344 -> 4087;
6344 -> 6329;
6344 -> 4097;
6344 -> 4089;
6345 -> 4240;
6346 -> 6345;
6346 -> 4109;
6347 -> 6346;
6347 -> 4111;
6347 -> 4109;
6348 -> 4107;
6348 -> 4141;
6348 -> 4236;
6348 -> 6347;
6348 -> 4245;
6348 -> 4135;
6348 -> 4136;
6348 -> 6333;
6348 -> 4143;
6348 -> 4140;
6349 -> 4260;
6350 -> 6349;
6350 -> 4155;
6351 -> 6350;
6351 -> 4157;
6351 -> 4155;
6352 -> 4153;
6352 -> 4187;
6352 -> 4256;
6352 -> 6351;
6352 -> 4265;
6352 -> 4181;
6352 -> 4182;
6352 -> 6337;
6352 -> 4189;
6352 -> 4186;
6353 -> 4201;
6354 -> 6353;
6354 -> 4022;
6355 -> 6354;
6355 -> 4024;
6355 -> 4022;
6356 -> 4220;
6357 -> 6356;
6357 -> 4060;
6358 -> 6357;
6358 -> 4062;
6358 -> 4060;
6359 -> 4058;
6359 -> 4090;
6359 -> 4216;
6359 -> 6358;
6359 -> 4225;
6359 -> 4086;
6359 -> 4087;
6359 -> 6344;
6359 -> 4097;
6359 -> 4089;
6360 -> 4240;
6361 -> 6360;
6361 -> 4109;
6362 -> 6361;
6362 -> 4111;
6362 -> 4109;
6363 -> 4107;
6363 -> 4141;
6363 -> 4236;
6363 -> 6362;
6363 -> 4245;
6363 -> 4135;
6363 -> 4136;
6363 -> 6348;
6363 -> 4143;
6363 -> 4140;
6364 -> 4260;
6365 -> 6364;
6365 -> 4155;
6366 -> 6365;
6366 -> 4157;
6366 -> 4155;
6367 -> 4153;
6367 -> 4187;
6367 -> 4256;
6367 -> 6366;
6367 -> 4265;
6367 -> 4181;
6367 -> 4182;
6367 -> 6352;
6367 -> 4189;
6367 -> 4186;
6368 -> 4201;
6369 -> 6368;
6369 -> 4022;
6370 -> 6369;
6370 -> 4024;
6370 -> 4022;
6371 -> 4220;
6372 -> 6371;
6372 -> 4060;
6373 -> 6372;
6373 -> 4062;
6373 -> 4060;
6374 -> 4058;
6374 -> 4090;
6374 -> 4216;
6374 -> 6373;
6374 -> 4225;
6374 -> 4086;
6374 -> 4087;
6374 -> 6359;
6374 -> 4097;
6374 -> 4089;
6375 -> 4240;
6376 -> 6375;
6376 -> 4109;
6377 -> 6376;
6377 -> 4111;
6377 -> 4109;
6378 -> 4107;
6378 -> 4141;
6378 -> 4236;
6378 -> 6377;
6378 -> 4245;
6378 -> 4135;
6378 -> 4136;
6378 -> 6363;
6378 -> 4143;
6378 -> 4140;
6379 -> 4260;
6380 -> 6379;
6380 -> 4155;
6381 -> 6380;
6381 -> 4157;
6381 -> 4155;
6382 -> 4153;
6382 -> 4187;
6382 -> 4256;
6382 -> 6381;
6382 -> 4265;
6382 -> 4181;
6382 -> 4182;
6382 -> 6367;
6382 -> 4189;
6382 -> 4186;
6383 -> 4201;
6384 -> 6383;
6384 -> 4022;
6385 -> 6384;
6385 -> 4024;
6385 -> 4022;
6386 -> 4220;
6387 -> 6386;
6387 -> 4060;
6388 -> 6387;
6388 -> 4062;
6388 -> 4060;
6389 -> 4058;
6389 -> 4090;
6389 -> 4216;
6389 -> 6388;
6389 -> 4225;
6389 -> 4086;
6389 -> 4087;
6389 -> 6374;
6389 -> 4097;
6389 -> 4089;
6390 -> 4240;
6391 -> 6390;
6391 -> 4109;
6392 -> 6391;
6392 -> 4111;
6392 -> 4109;
6393 -> 4107;
6393 -> 4141;
6393 -> 4236;
6393 -> 6392;
6393 -> 4245;
6393 -> 4135;
6393 -> 4136;
6393 -> 6378;
6393 -> 4143;
6393 -> 4140;
6394 -> 4260;
6395 -> 6394;
6395 -> 4155;
6396 -> 6395;
6396 -> 4157;
6396 -> 4155;
6397 -> 4153;
6397 -> 4187;
6397 -> 4256;
6397 -> 6396;
6397 -> 4265;
6397 -> 4181;
6397 -> 4182;
6397 -> 6382;
6397 -> 4189;
6397 -> 4186;
6398 -> 4201;
6399 -> 6398;
6399 -> 4022;
6400 -> 6399;
6400 -> 4024;
6400 -> 4022;
6401 -> 4220;
6402 -> 6401;
6402 -> 4060;
6403 -> 6402;
6403 -> 4062;
6403 -> 4060;
6404 -> 4058;
6404 -> 4090;
6404 -> 4216;
6404 -> 6403;
6404 -> 4225;
6404 -> 4086;
6404 -> 4087;
6404 -> 6389;
6404 -> 4097;
6404 -> 4089;
6405 -> 4240;
6406 -> 6405;
6406 -> 4109;
6407 -> 6406;
6407 -> 4111;
6407 -> 4109;
6408 -> 4107;
6408 -> 4141;
6408 -> 4236;
6408 -> 6407;
6408 -> 4245;
6408 -> 4135;
6408 -> 4136;
6408 -> 6393;
6408 -> 4143;
6408 -> 4140;
6409 -> 4260;
6410 -> 6409;
6410 -> 4155;
6411 -> 6410;
6411 -> 4157;
6411 -> 4155;
6412 -> 4153;
6412 -> 4187;
6412 -> 4256;
6412 -> 6411;
6412 -> 4265;
6412 -> 4181;
6412 -> 4182;
6412 -> 6397;
6412 -> 4189;
6412 -> 4186;
6413 -> 4201;
6414 -> 6413;
6414 -> 4022;
6415 -> 6414;
6415 -> 4024;
6415 -> 4022;
6416 -> 4220;
6417 -> 6416;
6417 -> 4060;
6418 -> 6417;
6418 -> 4062;
6418 -> 4060;
6419 -> 4058;
6419 -> 4090;
6419 -> 4216;
6419 -> 6418;
6419 -> 4225;
6419 -> 4086;
6419 -> 4087;
6419 -> 6404;
6419 -> 4097;
6419 -> 4089;
6420 -> 4240;
6421 -> 6420;
6421 -> 4109;
6422 -> 6421;
6422 -> 4111;
6422 -> 4109;
6423 -> 4107;
6423 -> 4141;
6423 -> 4236;
6423 -> 6422;
6423 -> 4245;
6423 -> 4135;
6423 -> 4136;
6423 -> 6408;
6423 -> 4143;
6423 -> 4140;
6424 -> 4260;
6425 -> 6424;
6425 -> 4155;
6426 -> 6425;
6426 -> 4157;
6426 -> 4155;
6427 -> 4153;
6427 -> 4187;
6427 -> 4256;
6427 -> 6426;
6427 -> 4265;
6427 -> 4181;
6427 -> 4182;
6427 -> 6412;
6427 -> 4189;
6427 -> 4186;
6428 -> 4201;
6429 -> 6428;
6429 -> 4022;
6430 -> 6429;
6430 -> 4024;
6430 -> 4022;
6431 -> 4220;
6432 -> 6431;
6432 -> 4060;
6433 -> 6432;
6433 -> 4062;
6433 -> 4060;
6434 -> 4058;
6434 -> 4090;
6434 -> 4216;
6434 -> 6433;
6434 -> 4225;
6434 -> 4086;
6434 -> 4087;
6434 -> 6419;
6434 -> 4097;
6434 -> 4089;
6435 -> 4240;
6436 -> 6435;
6436 -> 4109;
6437 -> 6436;
6437 -> 4111;
6437 -> 4109;
6438 -> 4107;
6438 -> 4141;
6438 -> 4236;
6438 -> 6437;
6438 -> 4245;
6438 -> 4135;
6438 -> 4136;
6438 -> 6423;
6438 -> 4143;
6438 -> 4140;
6439 -> 4260;
6440 -> 6439;
6440 -> 4155;
6441 -> 6440;
6441 -> 4157;
6441 -> 4155;
6442 -> 4153;
6442 -> 4187;
6442 -> 4256;
6442 -> 6441;
6442 -> 4265;
6442 -> 4181;
6442 -> 4182;
6442 -> 6427;
6442 -> 4189;
6442 -> 4186;
6443 -> 4201;
6444 -> 6443;
6444 -> 4022;
6445 -> 6444;
6445 -> 4024;
6445 -> 4022;
6446 -> 4220;
6447 -> 6446;
6447 -> 4060;
6448 -> 6447;
6448 -> 4062;
6448 -> 4060;
6449 -> 4058;
6449 -> 4090;
6449 -> 4216;
6449 -> 6448;
6449 -> 4225;
6449 -> 4086;
6449 -> 4087;
6449 -> 6434;
6449 -> 4097;
6449 -> 4089;
6450 -> 4240;
6451 -> 6450;
6451 -> 4109;
6452 -> 6451;
6452 -> 4111;
6452 -> 4109;
6453 -> 4107;
6453 -> 4141;
6453 -> 4236;
6453 -> 6452;
6453 -> 4245;
6453 -> 4135;
6453 -> 4136;
6453 -> 6438;
6453 -> 4143;
6453 -> 4140;
6454 -> 4260;
6455 -> 6454;
6455 -> 4155;
6456 -> 6455;
6456 -> 4157;
6456 -> 4155;
6457 -> 4153;
6457 -> 4187;
6457 -> 4256;
6457 -> 6456;
6457 -> 4265;
6457 -> 4181;
6457 -> 4182;
6457 -> 6442;
6457 -> 4189;
6457 -> 4186;
6458 -> 4201;
6459 -> 6458;
6459 -> 4022;
6460 -> 6459;
6460 -> 4024;
6460 -> 4022;
6461 -> 4220;
6462 -> 6461;
6462 -> 4060;
6463 -> 6462;
6463 -> 4062;
6463 -> 4060;
6464 -> 4058;
6464 -> 4090;
6464 -> 4216;
6464 -> 6463;
6464 -> 4225;
6464 -> 4086;
6464 -> 4087;
6464 -> 6449;
6464 -> 4097;
6464 -> 4089;
6465 -> 4240;
6466 -> 6465;
6466 -> 4109;
6467 -> 6466;
6467 -> 4111;
6467 -> 4109;
6468 -> 4107;
6468 -> 4141;
6468 -> 4236;
6468 -> 6467;
6468 -> 4245;
6468 -> 4135;
6468 -> 4136;
6468 -> 6453;
6468 -> 4143;
6468 -> 4140;
6469 -> 4260;
6470 -> 6469;
6470 -> 4155;
6471 -> 6470;
6471 -> 4157;
6471 -> 4155;
6472 -> 4153;
6472 -> 4187;
6472 -> 4256;
6472 -> 6471;
6472 -> 4265;
6472 -> 4181;
6472 -> 4182;
6472 -> 6457;
6472 -> 4189;
6472 -> 4186;
6473 -> 4201;
6474 -> 6473;
6474 -> 4022;
6475 -> 6474;
6475 -> 4024;
6475 -> 4022;
6476 -> 4220;
6477 -> 6476;
6477 -> 4060;
6478 -> 6477;
6478 -> 4062;
6478 -> 4060;
6479 -> 4058;
6479 -> 4090;
6479 -> 4216;
6479 -> 6478;
6479 -> 4225;
6479 -> 4086;
6479 -> 4087;
6479 -> 6464;
6479 -> 4097;
6479 -> 4089;
6480 -> 4240;
6481 -> 6480;
6481 -> 4109;
6482 -> 6481;
6482 -> 4111;
6482 -> 4109;
6483 -> 4107;
6483 -> 4141;
6483 -> 4236;
6483 -> 6482;
6483 -> 4245;
6483 -> 4135;
6483 -> 4136;
6483 -> 6468;
6483 -> 4143;
6483 -> 4140;
6484 -> 4260;
6485 -> 6484;
6485 -> 4155;
6486 -> 6485;
6486 -> 4157;
6486 -> 4155;
6487 -> 4153;
6487 -> 4187;
6487 -> 4256;
6487 -> 6486;
6487 -> 4265;
6487 -> 4181;
6487 -> 4182;
6487 -> 6472;
6487 -> 4189;
6487 -> 4186;
6488 -> 4201;
6489 -> 6488;
6489 -> 4022;
6490 -> 6489;
6490 -> 4024;
6490 -> 4022;
6491 -> 4220;
6492 -> 6491;
6492 -> 4060;
6493 -> 6492;
6493 -> 4062;
6493 -> 4060;
6494 -> 4058;
6494 -> 4090;
6494 -> 4216;
6494 -> 6493;
6494 -> 4225;
6494 -> 4086;
6494 -> 4087;
6494 -> 6479;
6494 -> 4097;
6494 -> 4089;
6495 -> 4240;
6496 -> 6495;
6496 -> 4109;
6497 -> 6496;
6497 -> 4111;
6497 -> 4109;
6498 -> 4107;
6498 -> 4141;
6498 -> 4236;
6498 -> 6497;
6498 -> 4245;
6498 -> 4135;
6498 -> 4136;
6498 -> 6483;
6498 -> 4143;
6498 -> 4140;
6499 -> 4260;
6500 -> 6499;
6500 -> 4155;
6501 -> 6500;
6501 -> 4157;
6501 -> 4155;
6502 -> 4153;
6502 -> 4187;
6502 -> 4256;
6502 -> 6501;
6502 -> 4265;
6502 -> 4181;
6502 -> 4182;
6502 -> 6487;
6502 -> 4189;
6502 -> 4186;
6503 -> 4201;
6504 -> 6503;
6504 -> 4022;
6505 -> 6504;
6505 -> 4024;
6505 -> 4022;
6506 -> 4220;
6507 -> 6506;
6507 -> 4060;
6508 -> 6507;
6508 -> 4062;
6508 -> 4060;
6509 -> 4058;
6509 -> 4090;
6509 -> 4216;
6509 -> 6508;
6509 -> 4225;
6509 -> 4086;
6509 -> 4087;
6509 -> 6494;
6509 -> 4097;
6509 -> 4089;
6510 -> 4240;
6511 -> 6510;
6511 -> 4109;
6512 -> 6511;
6512 -> 4111;
6512 -> 4109;
6513 -> 4107;
6513 -> 4141;
6513 -> 4236;
6513 -> 6512;
6513 -> 4245;
6513 -> 4135;
6513 -> 4136;
6513 -> 6498;
6513 -> 4143;
6513 -> 4140;
6514 -> 4260;
6515 -> 6514;
6515 -> 4155;
6516 -> 6515;
6516 -> 4157;
6516 -> 4155;
6517 -> 4153;
6517 -> 4187;
6517 -> 4256;
6517 -> 6516;
6517 -> 4265;
6517 -> 4181;
6517 -> 4182;
6517 -> 6502;
6517 -> 4189;
6517 -> 4186;
6518 -> 4201;
6519 -> 6518;
6519 -> 4022;
6520 -> 6519;
6520 -> 4024;
6520 -> 4022;
6521 -> 4220;
6522 -> 6521;
6522 -> 4060;
6523 -> 6522;
6523 -> 4062;
6523 -> 4060;
6524 -> 4058;
6524 -> 4090;
6524 -> 4216;
6524 -> 6523;
6524 -> 4225;
6524 -> 4086;
6524 -> 4087;
6524 -> 6509;
6524 -> 4097;
6524 -> 4089;
6525 -> 4240;
6526 -> 6525;
6526 -> 4109;
6527 -> 6526;
6527 -> 4111;
6527 -> 4109;
6528 -> 4107;
6528 -> 4141;
6528 -> 4236;
6528 -> 6527;
6528 -> 4245;
6528 -> 4135;
6528 -> 4136;
6528 -> 6513;
6528 -> 4143;
6528 -> 4140;
6529 -> 4260;
6530 -> 6529;
6530 -> 4155;
6531 -> 6530;
6531 -> 4157;
6531 -> 4155;
6532 -> 4153;
6532 -> 4187;
6532 -> 4256;
6532 -> 6531;
6532 -> 4265;
6532 -> 4181;
6532 -> 4182;
6532 -> 6517;
6532 -> 4189;
6532 -> 4186;
6533 -> 4201;
6534 -> 6533;
6534 -> 4022;
6535 -> 6534;
6535 -> 4024;
6535 -> 4022;
6536 -> 4220;
6537 -> 6536;
6537 -> 4060;
6538 -> 6537;
6538 -> 4062;
6538 -> 4060;
6539 -> 4058;
6539 -> 4090;
6539 -> 4216;
6539 -> 6538;
6539 -> 4225;
6539 -> 4086;
6539 -> 4087;
6539 -> 6524;
6539 -> 4097;
6539 -> 4089;
6540 -> 4240;
6541 -> 6540;
6541 -> 4109;
6542 -> 6541;
6542 -> 4111;
6542 -> 4109;
6543 -> 4107;
6543 -> 4141;
6543 -> 4236;
6543 -> 6542;
6543 -> 4245;
6543 -> 4135;
6543 -> 4136;
6543 -> 6528;
6543 -> 4143;
6543 -> 4140;
6544 -> 4260;
6545 -> 6544;
6545 -> 4155;
6546 -> 6545;
6546 -> 4157;
6546 -> 4155;
6547 -> 4153;
6547 -> 4187;
6547 -> 4256;
6547 -> 6546;
6547 -> 4265;
6547 -> 4181;
6547 -> 4182;
6547 -> 6532;
6547 -> 4189;
6547 -> 4186;
6548 -> 4201;
6549 -> 6548;
6549 -> 4022;
6550 -> 6549;
6550 -> 4024;
6550 -> 4022;
6551 -> 4220;
6552 -> 6551;
6552 -> 4060;
6553 -> 6552;
6553 -> 4062;
6553 -> 4060;
6554 -> 4058;
6554 -> 4090;
6554 -> 4216;
6554 -> 6553;
6554 -> 4225;
6554 -> 4086;
6554 -> 4087;
6554 -> 6539;
6554 -> 4097;
6554 -> 4089;
6555 -> 4240;
6556 -> 6555;
6556 -> 4109;
6557 -> 6556;
6557 -> 4111;
6557 -> 4109;
6558 -> 4107;
6558 -> 4141;
6558 -> 4236;
6558 -> 6557;
6558 -> 4245;
6558 -> 4135;
6558 -> 4136;
6558 -> 6543;
6558 -> 4143;
6558 -> 4140;
6559 -> 4260;
6560 -> 6559;
6560 -> 4155;
6561 -> 6560;
6561 -> 4157;
6561 -> 4155;
6562 -> 4153;
6562 -> 4187;
6562 -> 4256;
6562 -> 6561;
6562 -> 4265;
6562 -> 4181;
6562 -> 4182;
6562 -> 6547;
6562 -> 4189;
6562 -> 4186;
6563 -> 4201;
6564 -> 6563;
6564 -> 4022;
6565 -> 6564;
6565 -> 4024;
6565 -> 4022;
6566 -> 4220;
6567 -> 6566;
6567 -> 4060;
6568 -> 6567;
6568 -> 4062;
6568 -> 4060;
6569 -> 4058;
6569 -> 4090;
6569 -> 4216;
6569 -> 6568;
6569 -> 4225;
6569 -> 4086;
6569 -> 4087;
6569 -> 6554;
6569 -> 4097;
6569 -> 4089;
6570 -> 4240;
6571 -> 6570;
6571 -> 4109;
6572 -> 6571;
6572 -> 4111;
6572 -> 4109;
6573 -> 4107;
6573 -> 4141;
6573 -> 4236;
6573 -> 6572;
6573 -> 4245;
6573 -> 4135;
6573 -> 4136;
6573 -> 6558;
6573 -> 4143;
6573 -> 4140;
6574 -> 4260;
6575 -> 6574;
6575 -> 4155;
6576 -> 6575;
6576 -> 4157;
6576 -> 4155;
6577 -> 4153;
6577 -> 4187;
6577 -> 4256;
6577 -> 6576;
6577 -> 4265;
6577 -> 4181;
6577 -> 4182;
6577 -> 6562;
6577 -> 4189;
6577 -> 4186;
6578 -> 4201;
6579 -> 6578;
6579 -> 4022;
6580 -> 6579;
6580 -> 4024;
6580 -> 4022;
6581 -> 4220;
6582 -> 6581;
6582 -> 4060;
6583 -> 6582;
6583 -> 4062;
6583 -> 4060;
6584 -> 4058;
6584 -> 4090;
6584 -> 4216;
6584 -> 6583;
6584 -> 4225;
6584 -> 4086;
6584 -> 4087;
6584 -> 6569;
6584 -> 4097;
6584 -> 4089;
6585 -> 4240;
6586 -> 6585;
6586 -> 4109;
6587 -> 6586;
6587 -> 4111;
6587 -> 4109;
6588 -> 4107;
6588 -> 4141;
6588 -> 4236;
6588 -> 6587;
6588 -> 4245;
6588 -> 4135;
6588 -> 4136;
6588 -> 6573;
6588 -> 4143;
6588 -> 4140;
6589 -> 4260;
6590 -> 6589;
6590 -> 4155;
6591 -> 6590;
6591 -> 4157;
6591 -> 4155;
6592 -> 4153;
6592 -> 4187;
6592 -> 4256;
6592 -> 6591;
6592 -> 4265;
6592 -> 4181;
6592 -> 4182;
6592 -> 6577;
6592 -> 4189;
6592 -> 4186;
6593 -> 4201;
6594 -> 6593;
6594 -> 4022;
6595 -> 6594;
6595 -> 4024;
6595 -> 4022;
6596 -> 4220;
6597 -> 6596;
6597 -> 4060;
6598 -> 6597;
6598 -> 4062;
6598 -> 4060;
6599 -> 4058;
6599 -> 4090;
6599 -> 4216;
6599 -> 6598;
6599 -> 4225;
6599 -> 4086;
6599 -> 4087;
6599 -> 6584;
6599 -> 4097;
6599 -> 4089;
6600 -> 4240;
6601 -> 6600;
6601 -> 4109;
6602 -> 6601;
6602 -> 4111;
6602 -> 4109;
6603 -> 4107;
6603 -> 4141;
6603 -> 4236;
6603 -> 6602;
6603 -> 4245;
6603 -> 4135;
6603 -> 4136;
6603 -> 6588;
6603 -> 4143;
6603 -> 4140;
6604 -> 4260;
6605 -> 6604;
6605 -> 4155;
6606 -> 6605;
6606 -> 4157;
6606 -> 4155;
6607 -> 4153;
6607 -> 4187;
6607 -> 4256;
6607 -> 6606;
6607 -> 4265;
6607 -> 4181;
6607 -> 4182;
6607 -> 6592;
6607 -> 4189;
6607 -> 4186;
6608 -> 4201;
6609 -> 6608;
6609 -> 4022;
6610 -> 6609;
6610 -> 4024;
6610 -> 4022;
6611 -> 4220;
6612 -> 6611;
6612 -> 4060;
6613 -> 6612;
6613 -> 4062;
6613 -> 4060;
6614 -> 4058;
6614 -> 4090;
6614 -> 4216;
6614 -> 6613;
6614 -> 4225;
6614 -> 4086;
6614 -> 4087;
6614 -> 6599;
6614 -> 4097;
6614 -> 4089;
6615 -> 4240;
6616 -> 6615;
6616 -> 4109;
6617 -> 6616;
6617 -> 4111;
6617 -> 4109;
6618 -> 4107;
6618 -> 4141;
6618 -> 4236;
6618 -> 6617;
6618 -> 4245;
6618 -> 4135;
6618 -> 4136;
6618 -> 6603;
6618 -> 4143;
6618 -> 4140;
6619 -> 4260;
6620 -> 6619;
6620 -> 4155;
6621 -> 6620;
6621 -> 4157;
6621 -> 4155;
6622 -> 4153;
6622 -> 4187;
6622 -> 4256;
6622 -> 6621;
6622 -> 4265;
6622 -> 4181;
6622 -> 4182;
6622 -> 6607;
6622 -> 4189;
6622 -> 4186;
6623 -> 4201;
6624 -> 6623;
6624 -> 4022;
6625 -> 6624;
6625 -> 4024;
6625 -> 4022;
6626 -> 4220;
6627 -> 6626;
6627 -> 4060;
6628 -> 6627;
6628 -> 4062;
6628 -> 4060;
6629 -> 4058;
6629 -> 4090;
6629 -> 4216;
6629 -> 6628;
6629 -> 4225;
6629 -> 4086;
6629 -> 4087;
6629 -> 6614;
6629 -> 4097;
6629 -> 4089;
6630 -> 4240;
6631 -> 6630;
6631 -> 4109;
6632 -> 6631;
6632 -> 4111;
6632 -> 4109;
6633 -> 4107;
6633 -> 4141;
6633 -> 4236;
6633 -> 6632;
6633 -> 4245;
6633 -> 4135;
6633 -> 4136;
6633 -> 6618;
6633 -> 4143;
6633 -> 4140;
6634 -> 4260;
6635 -> 6634;
6635 -> 4155;
6636 -> 6635;
6636 -> 4157;
6636 -> 4155;
6637 -> 4153;
6637 -> 4187;
6637 -> 4256;
6637 -> 6636;
6637 -> 4265;
6637 -> 4181;
6637 -> 4182;
6637 -> 6622;
6637 -> 4189;
6637 -> 4186;
6638 -> 4201;
6639 -> 6638;
6639 -> 4022;
6640 -> 6639;
6640 -> 4024;
6640 -> 4022;
6641 -> 4220;
6642 -> 6641;
6642 -> 4060;
6643 -> 6642;
6643 -> 4062;
6643 -> 4060;
6644 -> 4058;
6644 -> 4090;
6644 -> 4216;
6644 -> 6643;
6644 -> 4225;
6644 -> 4086;
6644 -> 4087;
6644 -> 6629;
6644 -> 4097;
6644 -> 4089;
6645 -> 4240;
6646 -> 6645;
6646 -> 4109;
6647 -> 6646;
6647 -> 4111;
6647 -> 4109;
6648 -> 4107;
6648 -> 4141;
6648 -> 4236;
6648 -> 6647;
6648 -> 4245;
6648 -> 4135;
6648 -> 4136;
6648 -> 6633;
6648 -> 4143;
6648 -> 4140;
6649 -> 4260;
6650 -> 6649;
6650 -> 4155;
6651 -> 6650;
6651 -> 4157;
6651 -> 4155;
6652 -> 4153;
6652 -> 4187;
6652 -> 4256;
6652 -> 6651;
6652 -> 4265;
6652 -> 4181;
6652 -> 4182;
6652 -> 6637;
6652 -> 4189;
6652 -> 4186;
6653 -> 4201;
6654 -> 6653;
6654 -> 4022;
6655 -> 6654;
6655 -> 4024;
6655 -> 4022;
6656 -> 4220;
6657 -> 6656;
6657 -> 4060;
6658 -> 6657;
6658 -> 4062;
6658 -> 4060;
6659 -> 4058;
6659 -> 4090;
6659 -> 4216;
6659 -> 6658;
6659 -> 4225;
6659 -> 4086;
6659 -> 4087;
6659 -> 6644;
6659 -> 4097;
6659 -> 4089;
6660 -> 4240;
6661 -> 6660;
6661 -> 4109;
6662 -> 6661;
6662 -> 4111;
6662 -> 4109;
6663 -> 4107;
6663 -> 4141;
6663 -> 4236;
6663 -> 6662;
6663 -> 4245;
6663 -> 4135;
6663 -> 4136;
6663 -> 6648;
6663 -> 4143;
6663 -> 4140;
6664 -> 4260;
6665 -> 6664;
6665 -> 4155;
6666 -> 6665;
6666 -> 4157;
6666 -> 4155;
6667 -> 4153;
6667 -> 4187;
6667 -> 4256;
6667 -> 6666;
6667 -> 4265;
6667 -> 4181;
6667 -> 4182;
6667 -> 6652;
6667 -> 4189;
6667 -> 4186;
6668 -> 4201;
6669 -> 6668;
6669 -> 4022;
6670 -> 6669;
6670 -> 4024;
6670 -> 4022;
6671 -> 4220;
6672 -> 6671;
6672 -> 4060;
6673 -> 6672;
6673 -> 4062;
6673 -> 4060;
6674 -> 4058;
6674 -> 4090;
6674 -> 4216;
6674 -> 6673;
6674 -> 4225;
6674 -> 4086;
6674 -> 4087;
6674 -> 6659;
6674 -> 4097;
6674 -> 4089;
6675 -> 4240;
6676 -> 6675;
6676 -> 4109;
6677 -> 6676;
6677 -> 4111;
6677 -> 4109;
6678 -> 4107;
6678 -> 4141;
6678 -> 4236;
6678 -> 6677;
6678 -> 4245;
6678 -> 4135;
6678 -> 4136;
6678 -> 6663;
6678 -> 4143;
6678 -> 4140;
6679 -> 4260;
6680 -> 6679;
6680 -> 4155;
6681 -> 6680;
6681 -> 4157;
6681 -> 4155;
6682 -> 4153;
6682 -> 4187;
6682 -> 4256;
6682 -> 6681;
6682 -> 4265;
6682 -> 4181;
6682 -> 4182;
6682 -> 6667;
6682 -> 4189;
6682 -> 4186;
6683 -> 4201;
6684 -> 6683;
6684 -> 4022;
6685 -> 6684;
6685 -> 4024;
6685 -> 4022;
6686 -> 4220;
6687 -> 6686;
6687 -> 4060;
6688 -> 6687;
6688 -> 4062;
6688 -> 4060;
6689 -> 4058;
6689 -> 4090;
6689 -> 4216;
6689 -> 6688;
6689 -> 4225;
6689 -> 4086;
6689 -> 4087;
6689 -> 6674;
6689 -> 4097;
6689 -> 4089;
6690 -> 4240;
6691 -> 6690;
6691 -> 4109;
6692 -> 6691;
6692 -> 4111;
6692 -> 4109;
6693 -> 4107;
6693 -> 4141;
6693 -> 4236;
6693 -> 6692;
6693 -> 4245;
6693 -> 4135;
6693 -> 4136;
6693 -> 6678;
6693 -> 4143;
6693 -> 4140;
6694 -> 4260;
6695 -> 6694;
6695 -> 4155;
6696 -> 6695;
6696 -> 4157;
6696 -> 4155;
6697 -> 4153;
6697 -> 4187;
6697 -> 4256;
6697 -> 6696;
6697 -> 4265;
6697 -> 4181;
6697 -> 4182;
6697 -> 6682;
6697 -> 4189;
6697 -> 4186;
6698 -> 4201;
6699 -> 6698;
6699 -> 4022;
6700 -> 6699;
6700 -> 4024;
6700 -> 4022;
6701 -> 4220;
6702 -> 6701;
6702 -> 4060;
6703 -> 6702;
6703 -> 4062;
6703 -> 4060;
6704 -> 4058;
6704 -> 4090;
6704 -> 4216;
6704 -> 6703;
6704 -> 4225;
6704 -> 4086;
6704 -> 4087;
6704 -> 6689;
6704 -> 4097;
6704 -> 4089;
6705 -> 4240;
6706 -> 6705;
6706 -> 4109;
6707 -> 6706;
6707 -> 4111;
6707 -> 4109;
6708 -> 4107;
6708 -> 4141;
6708 -> 4236;
6708 -> 6707;
6708 -> 4245;
6708 -> 4135;
6708 -> 4136;
6708 -> 6693;
6708 -> 4143;
6708 -> 4140;
6709 -> 4260;
6710 -> 6709;
6710 -> 4155;
6711 -> 6710;
6711 -> 4157;
6711 -> 4155;
6712 -> 4153;
6712 -> 4187;
6712 -> 4256;
6712 -> 6711;
6712 -> 4265;
6712 -> 4181;
6712 -> 4182;
6712 -> 6697;
6712 -> 4189;
6712 -> 4186;
6713 -> 4201;
6714 -> 6713;
6714 -> 4022;
6715 -> 6714;
6715 -> 4024;
6715 -> 4022;
6716 -> 4220;
6717 -> 6716;
6717 -> 4060;
6718 -> 6717;
6718 -> 4062;
6718 -> 4060;
6719 -> 4058;
6719 -> 4090;
6719 -> 4216;
6719 -> 6718;
6719 -> 4225;
6719 -> 4086;
6719 -> 4087;
6719 -> 6704;
6719 -> 4097;
6719 -> 4089;
6720 -> 4240;
6721 -> 6720;
6721 -> 4109;
6722 -> 6721;
6722 -> 4111;
6722 -> 4109;
6723 -> 4107;
6723 -> 4141;
6723 -> 4236;
6723 -> 6722;
6723 -> 4245;
6723 -> 4135;
6723 -> 4136;
6723 -> 6708;
6723 -> 4143;
6723 -> 4140;
6724 -> 4260;
6725 -> 6724;
6725 -> 4155;
6726 -> 6725;
6726 -> 4157;
6726 -> 4155;
6727 -> 4153;
6727 -> 4187;
6727 -> 4256;
6727 -> 6726;
6727 -> 4265;
6727 -> 4181;
6727 -> 4182;
6727 -> 6712;
6727 -> 4189;
6727 -> 4186;
6728 -> 4201;
6729 -> 6728;
6729 -> 4022;
6730 -> 6729;
6730 -> 4024;
6730 -> 4022;
6731 -> 4220;
6732 -> 6731;
6732 -> 4060;
6733 -> 6732;
6733 -> 4062;
6733 -> 4060;
6734 -> 4058;
6734 -> 4090;
6734 -> 4216;
6734 -> 6733;
6734 -> 4225;
6734 -> 4086;
6734 -> 4087;
6734 -> 6719;
6734 -> 4097;
6734 -> 4089;
6735 -> 4240;
6736 -> 6735;
6736 -> 4109;
6737 -> 6736;
6737 -> 4111;
6737 -> 4109;
6738 -> 4107;
6738 -> 4141;
6738 -> 4236;
6738 -> 6737;
6738 -> 4245;
6738 -> 4135;
6738 -> 4136;
6738 -> 6723;
6738 -> 4143;
6738 -> 4140;
6739 -> 4260;
6740 -> 6739;
6740 -> 4155;
6741 -> 6740;
6741 -> 4157;
6741 -> 4155;
6742 -> 4153;
6742 -> 4187;
6742 -> 4256;
6742 -> 6741;
6742 -> 4265;
6742 -> 4181;
6742 -> 4182;
6742 -> 6727;
6742 -> 4189;
6742 -> 4186;
6743 -> 4201;
6744 -> 6743;
6744 -> 4022;
6745 -> 6744;
6745 -> 4024;
6745 -> 4022;
6746 -> 4220;
6747 -> 6746;
6747 -> 4060;
6748 -> 6747;
6748 -> 4062;
6748 -> 4060;
6749 -> 4058;
6749 -> 4090;
6749 -> 4216;
6749 -> 6748;
6749 -> 4225;
6749 -> 4086;
6749 -> 4087;
6749 -> 6734;
6749 -> 4097;
6749 -> 4089;
6750 -> 4240;
6751 -> 6750;
6751 -> 4109;
6752 -> 6751;
6752 -> 4111;
6752 -> 4109;
6753 -> 4107;
6753 -> 4141;
6753 -> 4236;
6753 -> 6752;
6753 -> 4245;
6753 -> 4135;
6753 -> 4136;
6753 -> 6738;
6753 -> 4143;
6753 -> 4140;
6754 -> 4260;
6755 -> 6754;
6755 -> 4155;
6756 -> 6755;
6756 -> 4157;
6756 -> 4155;
6757 -> 4153;
6757 -> 4187;
6757 -> 4256;
6757 -> 6756;
6757 -> 4265;
6757 -> 4181;
6757 -> 4182;
6757 -> 6742;
6757 -> 4189;
6757 -> 4186;
6758 -> 4201;
6759 -> 6758;
6759 -> 4022;
6760 -> 6759;
6760 -> 4024;
6760 -> 4022;
6761 -> 4220;
6762 -> 6761;
6762 -> 4060;
6763 -> 6762;
6763 -> 4062;
6763 -> 4060;
6764 -> 4058;
6764 -> 4090;
6764 -> 4216;
6764 -> 6763;
6764 -> 4225;
6764 -> 4086;
6764 -> 4087;
6764 -> 6749;
6764 -> 4097;
6764 -> 4089;
6765 -> 4240;
6766 -> 6765;
6766 -> 4109;
6767 -> 6766;
6767 -> 4111;
6767 -> 4109;
6768 -> 4107;
6768 -> 4141;
6768 -> 4236;
6768 -> 6767;
6768 -> 4245;
6768 -> 4135;
6768 -> 4136;
6768 -> 6753;
6768 -> 4143;
6768 -> 4140;
6769 -> 4260;
6770 -> 6769;
6770 -> 4155;
6771 -> 6770;
6771 -> 4157;
6771 -> 4155;
6772 -> 4153;
6772 -> 4187;
6772 -> 4256;
6772 -> 6771;
6772 -> 4265;
6772 -> 4181;
6772 -> 4182;
6772 -> 6757;
6772 -> 4189;
6772 -> 4186;
6773 -> 4201;
6774 -> 6773;
6774 -> 4022;
6775 -> 6774;
6775 -> 4024;
6775 -> 4022;
6776 -> 4220;
6777 -> 6776;
6777 -> 4060;
6778 -> 6777;
6778 -> 4062;
6778 -> 4060;
6779 -> 4058;
6779 -> 4090;
6779 -> 4216;
6779 -> 6778;
6779 -> 4225;
6779 -> 4086;
6779 -> 4087;
6779 -> 6764;
6779 -> 4097;
6779 -> 4089;
6780 -> 4240;
6781 -> 6780;
6781 -> 4109;
6782 -> 6781;
6782 -> 4111;
6782 -> 4109;
6783 -> 4107;
6783 -> 4141;
6783 -> 4236;
6783 -> 6782;
6783 -> 4245;
6783 -> 4135;
6783 -> 4136;
6783 -> 6768;
6783 -> 4143;
6783 -> 4140;
6784 -> 4260;
6785 -> 6784;
6785 -> 4155;
6786 -> 6785;
6786 -> 4157;
6786 -> 4155;
6787 -> 4153;
6787 -> 4187;
6787 -> 4256;
6787 -> 6786;
6787 -> 4265;
6787 -> 4181;
6787 -> 4182;
6787 -> 6772;
6787 -> 4189;
6787 -> 4186;
6788 -> 4201;
6789 -> 6788;
6789 -> 4022;
6790 -> 6789;
6790 -> 4024;
6790 -> 4022;
6791 -> 4220;
6792 -> 6791;
6792 -> 4060;
6793 -> 6792;
6793 -> 4062;
6793 -> 4060;
6794 -> 4058;
6794 -> 4090;
6794 -> 4216;
6794 -> 6793;
6794 -> 4225;
6794 -> 4086;
6794 -> 4087;
6794 -> 6779;
6794 -> 4097;
6794 -> 4089;
6795 -> 4240;
6796 -> 6795;
6796 -> 4109;
6797 -> 6796;
6797 -> 4111;
6797 -> 4109;
6798 -> 4107;
6798 -> 4141;
6798 -> 4236;
6798 -> 6797;
6798 -> 4245;
6798 -> 4135;
6798 -> 4136;
6798 -> 6783;
6798 -> 4143;
6798 -> 4140;
6799 -> 4260;
6800 -> 6799;
6800 -> 4155;
6801 -> 6800;
6801 -> 4157;
6801 -> 4155;
6802 -> 4153;
6802 -> 4187;
6802 -> 4256;
6802 -> 6801;
6802 -> 4265;
6802 -> 4181;
6802 -> 4182;
6802 -> 6787;
6802 -> 4189;
6802 -> 4186;
6803 -> 4201;
6804 -> 6803;
6804 -> 4022;
6805 -> 6804;
6805 -> 4024;
6805 -> 4022;
6806 -> 4220;
6807 -> 6806;
6807 -> 4060;
6808 -> 6807;
6808 -> 4062;
6808 -> 4060;
6809 -> 4058;
6809 -> 4090;
6809 -> 4216;
6809 -> 6808;
6809 -> 4225;
6809 -> 4086;
6809 -> 4087;
6809 -> 6794;
6809 -> 4097;
6809 -> 4089;
6810 -> 4240;
6811 -> 6810;
6811 -> 4109;
6812 -> 6811;
6812 -> 4111;
6812 -> 4109;
6813 -> 4107;
6813 -> 4141;
6813 -> 4236;
6813 -> 6812;
6813 -> 4245;
6813 -> 4135;
6813 -> 4136;
6813 -> 6798;
6813 -> 4143;
6813 -> 4140;
6814 -> 4260;
6815 -> 6814;
6815 -> 4155;
6816 -> 6815;
6816 -> 4157;
6816 -> 4155;
6817 -> 4153;
6817 -> 4187;
6817 -> 4256;
6817 -> 6816;
6817 -> 4265;
6817 -> 4181;
6817 -> 4182;
6817 -> 6802;
6817 -> 4189;
6817 -> 4186;
6818 -> 4201;
6819 -> 6818;
6819 -> 4022;
6820 -> 6819;
6820 -> 4024;
6820 -> 4022;
6821 -> 4220;
6822 -> 6821;
6822 -> 4060;
6823 -> 6822;
6823 -> 4062;
6823 -> 4060;
6824 -> 4058;
6824 -> 4090;
6824 -> 4216;
6824 -> 6823;
6824 -> 4225;
6824 -> 4086;
6824 -> 4087;
6824 -> 6809;
6824 -> 4097;
6824 -> 4089;
6825 -> 4240;
6826 -> 6825;
6826 -> 4109;
6827 -> 6826;
6827 -> 4111;
6827 -> 4109;
6828 -> 4107;
6828 -> 4141;
6828 -> 4236;
6828 -> 6827;
6828 -> 4245;
6828 -> 4135;
6828 -> 4136;
6828 -> 6813;
6828 -> 4143;
6828 -> 4140;
6829 -> 4260;
6830 -> 6829;
6830 -> 4155;
6831 -> 6830;
6831 -> 4157;
6831 -> 4155;
6832 -> 4153;
6832 -> 4187;
6832 -> 4256;
6832 -> 6831;
6832 -> 4265;
6832 -> 4181;
6832 -> 4182;
6832 -> 6817;
6832 -> 4189;
6832 -> 4186;
6833 -> 4201;
6834 -> 6833;
6834 -> 4022;
6835 -> 6834;
6835 -> 4024;
6835 -> 4022;
6836 -> 4220;
6837 -> 6836;
6837 -> 4060;
6838 -> 6837;
6838 -> 4062;
6838 -> 4060;
6839 -> 4058;
6839 -> 4090;
6839 -> 4216;
6839 -> 6838;
6839 -> 4225;
6839 -> 4086;
6839 -> 4087;
6839 -> 6824;
6839 -> 4097;
6839 -> 4089;
6840 -> 4240;
6841 -> 6840;
6841 -> 4109;
6842 -> 6841;
6842 -> 4111;
6842 -> 4109;
6843 -> 4107;
6843 -> 4141;
6843 -> 4236;
6843 -> 6842;
6843 -> 4245;
6843 -> 4135;
6843 -> 4136;
6843 -> 6828;
6843 -> 4143;
6843 -> 4140;
6844 -> 4260;
6845 -> 6844;
6845 -> 4155;
6846 -> 6845;
6846 -> 4157;
6846 -> 4155;
6847 -> 4153;
6847 -> 4187;
6847 -> 4256;
6847 -> 6846;
6847 -> 4265;
6847 -> 4181;
6847 -> 4182;
6847 -> 6832;
6847 -> 4189;
6847 -> 4186;
6848 -> 4201;
6849 -> 6848;
6849 -> 4022;
6850 -> 6849;
6850 -> 4024;
6850 -> 4022;
6851 -> 4220;
6852 -> 6851;
6852 -> 4060;
6853 -> 6852;
6853 -> 4062;
6853 -> 4060;
6854 -> 4058;
6854 -> 4090;
6854 -> 4216;
6854 -> 6853;
6854 -> 4225;
6854 -> 4086;
6854 -> 4087;
6854 -> 6839;
6854 -> 4097;
6854 -> 4089;
6855 -> 4240;
6856 -> 6855;
6856 -> 4109;
6857 -> 6856;
6857 -> 4111;
6857 -> 4109;
6858 -> 4107;
6858 -> 4141;
6858 -> 4236;
6858 -> 6857;
6858 -> 4245;
6858 -> 4135;
6858 -> 4136;
6858 -> 6843;
6858 -> 4143;
6858 -> 4140;
6859 -> 4260;
6860 -> 6859;
6860 -> 4155;
6861 -> 6860;
6861 -> 4157;
6861 -> 4155;
6862 -> 4153;
6862 -> 4187;
6862 -> 4256;
6862 -> 6861;
6862 -> 4265;
6862 -> 4181;
6862 -> 4182;
6862 -> 6847;
6862 -> 4189;
6862 -> 4186;
6863 -> 4201;
6864 -> 6863;
6864 -> 4022;
6865 -> 6864;
6865 -> 4024;
6865 -> 4022;
6866 -> 4220;
6867 -> 6866;
6867 -> 4060;
6868 -> 6867;
6868 -> 4062;
6868 -> 4060;
6869 -> 4058;
6869 -> 4090;
6869 -> 4216;
6869 -> 6868;
6869 -> 4225;
6869 -> 4086;
6869 -> 4087;
6869 -> 6854;
6869 -> 4097;
6869 -> 4089;
6870 -> 4240;
6871 -> 6870;
6871 -> 4109;
6872 -> 6871;
6872 -> 4111;
6872 -> 4109;
6873 -> 4107;
6873 -> 4141;
6873 -> 4236;
6873 -> 6872;
6873 -> 4245;
6873 -> 4135;
6873 -> 4136;
6873 -> 6858;
6873 -> 4143;
6873 -> 4140;
6874 -> 4260;
6875 -> 6874;
6875 -> 4155;
6876 -> 6875;
6876 -> 4157;
6876 -> 4155;
6877 -> 4153;
6877 -> 4187;
6877 -> 4256;
6877 -> 6876;
6877 -> 4265;
6877 -> 4181;
6877 -> 4182;
6877 -> 6862;
6877 -> 4189;
6877 -> 4186;
6878 -> 4201;
6879 -> 6878;
6879 -> 4022;
6880 -> 6879;
6880 -> 4024;
6880 -> 4022;
6881 -> 4220;
6882 -> 6881;
6882 -> 4060;
6883 -> 6882;
6883 -> 4062;
6883 -> 4060;
6884 -> 4058;
6884 -> 4090;
6884 -> 4216;
6884 -> 6883;
6884 -> 4225;
6884 -> 4086;
6884 -> 4087;
6884 -> 6869;
6884 -> 4097;
6884 -> 4089;
6885 -> 4240;
6886 -> 6885;
6886 -> 4109;
6887 -> 6886;
6887 -> 4111;
6887 -> 4109;
6888 -> 4107;
6888 -> 4141;
6888 -> 4236;
6888 -> 6887;
6888 -> 4245;
6888 -> 4135;
6888 -> 4136;
6888 -> 6873;
6888 -> 4143;
6888 -> 4140;
6889 -> 4260;
6890 -> 6889;
6890 -> 4155;
6891 -> 6890;
6891 -> 4157;
6891 -> 4155;
6892 -> 4153;
6892 -> 4187;
6892 -> 4256;
6892 -> 6891;
6892 -> 4265;
6892 -> 4181;
6892 -> 4182;
6892 -> 6877;
6892 -> 4189;
6892 -> 4186;
6893 -> 4201;
6894 -> 6893;
6894 -> 4022;
6895 -> 6894;
6895 -> 4024;
6895 -> 4022;
6896 -> 4220;
6897 -> 6896;
6897 -> 4060;
6898 -> 6897;
6898 -> 4062;
6898 -> 4060;
6899 -> 4058;
6899 -> 4090;
6899 -> 4216;
6899 -> 6898;
6899 -> 4225;
6899 -> 4086;
6899 -> 4087;
6899 -> 6884;
6899 -> 4097;
6899 -> 4089;
6900 -> 4240;
6901 -> 6900;
6901 -> 4109;
6902 -> 6901;
6902 -> 4111;
6902 -> 4109;
6903 -> 4107;
6903 -> 4141;
6903 -> 4236;
6903 -> 6902;
6903 -> 4245;
6903 -> 4135;
6903 -> 4136;
6903 -> 6888;
6903 -> 4143;
6903 -> 4140;
6904 -> 4260;
6905 -> 6904;
6905 -> 4155;
6906 -> 6905;
6906 -> 4157;
6906 -> 4155;
6907 -> 4153;
6907 -> 4187;
6907 -> 4256;
6907 -> 6906;
6907 -> 4265;
6907 -> 4181;
6907 -> 4182;
6907 -> 6892;
6907 -> 4189;
6907 -> 4186;
6908 -> 4201;
6909 -> 6908;
6909 -> 4022;
6910 -> 6909;
6910 -> 4024;
6910 -> 4022;
6911 -> 4220;
6912 -> 6911;
6912 -> 4060;
6913 -> 6912;
6913 -> 4062;
6913 -> 4060;
6914 -> 4058;
6914 -> 4090;
6914 -> 4216;
6914 -> 6913;
6914 -> 4225;
6914 -> 4086;
6914 -> 4087;
6914 -> 6899;
6914 -> 4097;
6914 -> 4089;
6915 -> 4240;
6916 -> 6915;
6916 -> 4109;
6917 -> 6916;
6917 -> 4111;
6917 -> 4109;
6918 -> 4107;
6918 -> 4141;
6918 -> 4236;
6918 -> 6917;
6918 -> 4245;
6918 -> 4135;
6918 -> 4136;
6918 -> 6903;
6918 -> 4143;
6918 -> 4140;
6919 -> 4260;
6920 -> 6919;
6920 -> 4155;
6921 -> 6920;
6921 -> 4157;
6921 -> 4155;
6922 -> 4153;
6922 -> 4187;
6922 -> 4256;
6922 -> 6921;
6922 -> 4265;
6922 -> 4181;
6922 -> 4182;
6922 -> 6907;
6922 -> 4189;
6922 -> 4186;
6923 -> 4201;
6924 -> 6923;
6924 -> 4022;
6925 -> 6924;
6925 -> 4024;
6925 -> 4022;
6926 -> 4220;
6927 -> 6926;
6927 -> 4060;
6928 -> 6927;
6928 -> 4062;
6928 -> 4060;
6929 -> 4058;
6929 -> 4090;
6929 -> 4216;
6929 -> 6928;
6929 -> 4225;
6929 -> 4086;
6929 -> 4087;
6929 -> 6914;
6929 -> 4097;
6929 -> 4089;
6930 -> 4240;
6931 -> 6930;
6931 -> 4109;
6932 -> 6931;
6932 -> 4111;
6932 -> 4109;
6933 -> 4107;
6933 -> 4141;
6933 -> 4236;
6933 -> 6932;
6933 -> 4245;
6933 -> 4135;
6933 -> 4136;
6933 -> 6918;
6933 -> 4143;
6933 -> 4140;
6934 -> 4260;
6935 -> 6934;
6935 -> 4155;
6936 -> 6935;
6936 -> 4157;
6936 -> 4155;
6937 -> 4153;
6937 -> 4187;
6937 -> 4256;
6937 -> 6936;
6937 -> 4265;
6937 -> 4181;
6937 -> 4182;
6937 -> 6922;
6937 -> 4189;
6937 -> 4186;
6938 -> 4201;
6939 -> 6938;
6939 -> 4022;
6940 -> 6939;
6940 -> 4024;
6940 -> 4022;
6941 -> 4220;
6942 -> 6941;
6942 -> 4060;
6943 -> 6942;
6943 -> 4062;
6943 -> 4060;
6944 -> 4058;
6944 -> 4090;
6944 -> 4216;
6944 -> 6943;
6944 -> 4225;
6944 -> 4086;
6944 -> 4087;
6944 -> 6929;
6944 -> 4097;
6944 -> 4089;
6945 -> 4240;
6946 -> 6945;
6946 -> 4109;
6947 -> 6946;
6947 -> 4111;
6947 -> 4109;
6948 -> 4107;
6948 -> 4141;
6948 -> 4236;
6948 -> 6947;
6948 -> 4245;
6948 -> 4135;
6948 -> 4136;
6948 -> 6933;
6948 -> 4143;
6948 -> 4140;
6949 -> 4260;
6950 -> 6949;
6950 -> 4155;
6951 -> 6950;
6951 -> 4157;
6951 -> 4155;
6952 -> 4153;
6952 -> 4187;
6952 -> 4256;
6952 -> 6951;
6952 -> 4265;
6952 -> 4181;
6952 -> 4182;
6952 -> 6937;
6952 -> 4189;
6952 -> 4186;
6953 -> 4201;
6954 -> 6953;
6954 -> 4022;
6955 -> 6954;
6955 -> 4024;
6955 -> 4022;
6956 -> 4220;
6957 -> 6956;
6957 -> 4060;
6958 -> 6957;
6958 -> 4062;
6958 -> 4060;
6959 -> 4058;
6959 -> 4090;
6959 -> 4216;
6959 -> 6958;
6959 -> 4225;
6959 -> 4086;
6959 -> 4087;
6959 -> 6944;
6959 -> 4097;
6959 -> 4089;
6960 -> 4240;
6961 -> 6960;
6961 -> 4109;
6962 -> 6961;
6962 -> 4111;
6962 -> 4109;
6963 -> 4107;
6963 -> 4141;
6963 -> 4236;
6963 -> 6962;
6963 -> 4245;
6963 -> 4135;
6963 -> 4136;
6963 -> 6948;
6963 -> 4143;
6963 -> 4140;
6964 -> 4260;
6965 -> 6964;
6965 -> 4155;
6966 -> 6965;
6966 -> 4157;
6966 -> 4155;
6967 -> 4153;
6967 -> 4187;
6967 -> 4256;
6967 -> 6966;
6967 -> 4265;
6967 -> 4181;
6967 -> 4182;
6967 -> 6952;
6967 -> 4189;
6967 -> 4186;
6968 -> 4201;
6969 -> 6968;
6969 -> 4022;
6970 -> 6969;
6970 -> 4024;
6970 -> 4022;
6971 -> 4220;
6972 -> 6971;
6972 -> 4060;
6973 -> 6972;
6973 -> 4062;
6973 -> 4060;
6974 -> 4058;
6974 -> 4090;
6974 -> 4216;
6974 -> 6973;
6974 -> 4225;
6974 -> 4086;
6974 -> 4087;
6974 -> 6959;
6974 -> 4097;
6974 -> 4089;
6975 -> 4240;
6976 -> 6975;
6976 -> 4109;
6977 -> 6976;
6977 -> 4111;
6977 -> 4109;
6978 -> 4107;
6978 -> 4141;
6978 -> 4236;
6978 -> 6977;
6978 -> 4245;
6978 -> 4135;
6978 -> 4136;
6978 -> 6963;
6978 -> 4143;
6978 -> 4140;
6979 -> 4260;
6980 -> 6979;
6980 -> 4155;
6981 -> 6980;
6981 -> 4157;
6981 -> 4155;
6982 -> 4153;
6982 -> 4187;
6982 -> 4256;
6982 -> 6981;
6982 -> 4265;
6982 -> 4181;
6982 -> 4182;
6982 -> 6967;
6982 -> 4189;
6982 -> 4186;
6983 -> 4201;
6984 -> 6983;
6984 -> 4022;
6985 -> 6984;
6985 -> 4024;
6985 -> 4022;
6986 -> 4220;
6987 -> 6986;
6987 -> 4060;
6988 -> 6987;
6988 -> 4062;
6988 -> 4060;
6989 -> 4058;
6989 -> 4090;
6989 -> 4216;
6989 -> 6988;
6989 -> 4225;
6989 -> 4086;
6989 -> 4087;
6989 -> 6974;
6989 -> 4097;
6989 -> 4089;
6990 -> 4240;
6991 -> 6990;
6991 -> 4109;
6992 -> 6991;
6992 -> 4111;
6992 -> 4109;
6993 -> 4107;
6993 -> 4141;
6993 -> 4236;
6993 -> 6992;
6993 -> 4245;
6993 -> 4135;
6993 -> 4136;
6993 -> 6978;
6993 -> 4143;
6993 -> 4140;
6994 -> 4260;
6995 -> 6994;
6995 -> 4155;
6996 -> 6995;
6996 -> 4157;
6996 -> 4155;
6997 -> 4153;
6997 -> 4187;
6997 -> 4256;
6997 -> 6996;
6997 -> 4265;
6997 -> 4181;
6997 -> 4182;
6997 -> 6982;
6997 -> 4189;
6997 -> 4186;
6998 -> 4201;
6999 -> 6998;
6999 -> 4022;
7000 -> 6999;
7000 -> 4024;
7000 -> 4022;
7001 -> 4220;
7002 -> 7001;
7002 -> 4060;
7003 -> 7002;
7003 -> 4062;
7003 -> 4060;
7004 -> 4058;
7004 -> 4090;
7004 -> 4216;
7004 -> 7003;
7004 -> 4225;
7004 -> 4086;
7004 -> 4087;
7004 -> 6989;
7004 -> 4097;
7004 -> 4089;
7005 -> 4240;
7006 -> 7005;
7006 -> 4109;
7007 -> 7006;
7007 -> 4111;
7007 -> 4109;
7008 -> 4107;
7008 -> 4141;
7008 -> 4236;
7008 -> 7007;
7008 -> 4245;
7008 -> 4135;
7008 -> 4136;
7008 -> 6993;
7008 -> 4143;
7008 -> 4140;
7009 -> 4260;
7010 -> 7009;
7010 -> 4155;
7011 -> 7010;
7011 -> 4157;
7011 -> 4155;
7012 -> 4153;
7012 -> 4187;
7012 -> 4256;
7012 -> 7011;
7012 -> 4265;
7012 -> 4181;
7012 -> 4182;
7012 -> 6997;
7012 -> 4189;
7012 -> 4186;
7013 -> 4201;
7014 -> 7013;
7014 -> 4022;
7015 -> 7014;
7015 -> 4024;
7015 -> 4022;
7016 -> 4220;
7017 -> 7016;
7017 -> 4060;
7018 -> 7017;
7018 -> 4062;
7018 -> 4060;
7019 -> 4058;
7019 -> 4090;
7019 -> 4216;
7019 -> 7018;
7019 -> 4225;
7019 -> 4086;
7019 -> 4087;
7019 -> 7004;
7019 -> 4097;
7019 -> 4089;
7020 -> 4240;
7021 -> 7020;
7021 -> 4109;
7022 -> 7021;
7022 -> 4111;
7022 -> 4109;
7023 -> 4107;
7023 -> 4141;
7023 -> 4236;
7023 -> 7022;
7023 -> 4245;
7023 -> 4135;
7023 -> 4136;
7023 -> 7008;
7023 -> 4143;
7023 -> 4140;
7024 -> 4260;
7025 -> 7024;
7025 -> 4155;
7026 -> 7025;
7026 -> 4157;
7026 -> 4155;
7027 -> 4153;
7027 -> 4187;
7027 -> 4256;
7027 -> 7026;
7027 -> 4265;
7027 -> 4181;
7027 -> 4182;
7027 -> 7012;
7027 -> 4189;
7027 -> 4186;
7028 -> 4201;
7029 -> 7028;
7029 -> 4022;
7030 -> 7029;
7030 -> 4024;
7030 -> 4022;
7031 -> 4220;
7032 -> 7031;
7032 -> 4060;
7033 -> 7032;
7033 -> 4062;
7033 -> 4060;
7034 -> 4058;
7034 -> 4090;
7034 -> 4216;
7034 -> 7033;
7034 -> 4225;
7034 -> 4086;
7034 -> 4087;
7034 -> 7019;
7034 -> 4097;
7034 -> 4089;
7035 -> 4240;
7036 -> 7035;
7036 -> 4109;
7037 -> 7036;
7037 -> 4111;
7037 -> 4109;
7038 -> 4107;
7038 -> 4141;
7038 -> 4236;
7038 -> 7037;
7038 -> 4245;
7038 -> 4135;
7038 -> 4136;
7038 -> 7023;
7038 -> 4143;
7038 -> 4140;
7039 -> 4260;
7040 -> 7039;
7040 -> 4155;
7041 -> 7040;
7041 -> 4157;
7041 -> 4155;
7042 -> 4153;
7042 -> 4187;
7042 -> 4256;
7042 -> 7041;
7042 -> 4265;
7042 -> 4181;
7042 -> 4182;
7042 -> 7027;
7042 -> 4189;
7042 -> 4186;
7043 -> 4201;
7044 -> 7043;
7044 -> 4022;
7045 -> 7044;
7045 -> 4024;
7045 -> 4022;
7046 -> 4220;
7047 -> 7046;
7047 -> 4060;
7048 -> 7047;
7048 -> 4062;
7048 -> 4060;
7049 -> 4058;
7049 -> 4090;
7049 -> 4216;
7049 -> 7048;
7049 -> 4225;
7049 -> 4086;
7049 -> 4087;
7049 -> 7034;
7049 -> 4097;
7049 -> 4089;
7050 -> 4240;
7051 -> 7050;
7051 -> 4109;
7052 -> 7051;
7052 -> 4111;
7052 -> 4109;
7053 -> 4107;
7053 -> 4141;
7053 -> 4236;
7053 -> 7052;
7053 -> 4245;
7053 -> 4135;
7053 -> 4136;
7053 -> 7038;
7053 -> 4143;
7053 -> 4140;
7054 -> 4260;
7055 -> 7054;
7055 -> 4155;
7056 -> 7055;
7056 -> 4157;
7056 -> 4155;
7057 -> 4153;
7057 -> 4187;
7057 -> 4256;
7057 -> 7056;
7057 -> 4265;
7057 -> 4181;
7057 -> 4182;
7057 -> 7042;
7057 -> 4189;
7057 -> 4186;
7058 -> 4201;
7059 -> 7058;
7059 -> 4022;
7060 -> 7059;
7060 -> 4024;
7060 -> 4022;
7061 -> 4220;
7062 -> 7061;
7062 -> 4060;
7063 -> 7062;
7063 -> 4062;
7063 -> 4060;
7064 -> 4058;
7064 -> 4090;
7064 -> 4216;
7064 -> 7063;
7064 -> 4225;
7064 -> 4086;
7064 -> 4087;
7064 -> 7049;
7064 -> 4097;
7064 -> 4089;
7065 -> 4240;
7066 -> 7065;
7066 -> 4109;
7067 -> 7066;
7067 -> 4111;
7067 -> 4109;
7068 -> 4107;
7068 -> 4141;
7068 -> 4236;
7068 -> 7067;
7068 -> 4245;
7068 -> 4135;
7068 -> 4136;
7068 -> 7053;
7068 -> 4143;
7068 -> 4140;
7069 -> 4260;
7070 -> 7069;
7070 -> 4155;
7071 -> 7070;
7071 -> 4157;
7071 -> 4155;
7072 -> 4153;
7072 -> 4187;
7072 -> 4256;
7072 -> 7071;
7072 -> 4265;
7072 -> 4181;
7072 -> 4182;
7072 -> 7057;
7072 -> 4189;
7072 -> 4186;
7073 -> 4201;
7074 -> 7073;
7074 -> 4022;
7075 -> 7074;
7075 -> 4024;
7075 -> 4022;
7076 -> 4220;
7077 -> 7076;
7077 -> 4060;
7078 -> 7077;
7078 -> 4062;
7078 -> 4060;
7079 -> 4058;
7079 -> 4090;
7079 -> 4216;
7079 -> 7078;
7079 -> 4225;
7079 -> 4086;
7079 -> 4087;
7079 -> 7064;
7079 -> 4097;
7079 -> 4089;
7080 -> 4240;
7081 -> 7080;
7081 -> 4109;
7082 -> 7081;
7082 -> 4111;
7082 -> 4109;
7083 -> 4107;
7083 -> 4141;
7083 -> 4236;
7083 -> 7082;
7083 -> 4245;
7083 -> 4135;
7083 -> 4136;
7083 -> 7068;
7083 -> 4143;
7083 -> 4140;
7084 -> 4260;
7085 -> 7084;
7085 -> 4155;
7086 -> 7085;
7086 -> 4157;
7086 -> 4155;
7087 -> 4153;
7087 -> 4187;
7087 -> 4256;
7087 -> 7086;
7087 -> 4265;
7087 -> 4181;
7087 -> 4182;
7087 -> 7072;
7087 -> 4189;
7087 -> 4186;
7088 -> 4201;
7089 -> 7088;
7089 -> 4022;
7090 -> 7089;
7090 -> 4024;
7090 -> 4022;
7091 -> 4220;
7092 -> 7091;
7092 -> 4060;
7093 -> 7092;
7093 -> 4062;
7093 -> 4060;
7094 -> 4058;
7094 -> 4090;
7094 -> 4216;
7094 -> 7093;
7094 -> 4225;
7094 -> 4086;
7094 -> 4087;
7094 -> 7079;
7094 -> 4097;
7094 -> 4089;
7095 -> 4240;
7096 -> 7095;
7096 -> 4109;
7097 -> 7096;
7097 -> 4111;
7097 -> 4109;
7098 -> 4107;
7098 -> 4141;
7098 -> 4236;
7098 -> 7097;
7098 -> 4245;
7098 -> 4135;
7098 -> 4136;
7098 -> 7083;
7098 -> 4143;
7098 -> 4140;
7099 -> 4260;
7100 -> 7099;
7100 -> 4155;
7101 -> 7100;
7101 -> 4157;
7101 -> 4155;
7102 -> 4153;
7102 -> 4187;
7102 -> 4256;
7102 -> 7101;
7102 -> 4265;
7102 -> 4181;
7102 -> 4182;
7102 -> 7087;
7102 -> 4189;
7102 -> 4186;
7103 -> 4201;
7104 -> 7103;
7104 -> 4022;
7105 -> 7104;
7105 -> 4024;
7105 -> 4022;
7106 -> 4220;
7107 -> 7106;
7107 -> 4060;
7108 -> 7107;
7108 -> 4062;
7108 -> 4060;
7109 -> 4058;
7109 -> 4090;
7109 -> 4216;
7109 -> 7108;
7109 -> 4225;
7109 -> 4086;
7109 -> 4087;
7109 -> 7094;
7109 -> 4097;
7109 -> 4089;
7110 -> 4240;
7111 -> 7110;
7111 -> 4109;
7112 -> 7111;
7112 -> 4111;
7112 -> 4109;
7113 -> 4107;
7113 -> 4141;
7113 -> 4236;
7113 -> 7112;
7113 -> 4245;
7113 -> 4135;
7113 -> 4136;
7113 -> 7098;
7113 -> 4143;
7113 -> 4140;
7114 -> 4260;
7115 -> 7114;
7115 -> 4155;
7116 -> 7115;
7116 -> 4157;
7116 -> 4155;
7117 -> 4153;
7117 -> 4187;
7117 -> 4256;
7117 -> 7116;
7117 -> 4265;
7117 -> 4181;
7117 -> 4182;
7117 -> 7102;
7117 -> 4189;
7117 -> 4186;
7118 -> 4201;
7119 -> 7118;
7119 -> 4022;
7120 -> 7119;
7120 -> 4024;
7120 -> 4022;
7121 -> 4220;
7122 -> 7121;
7122 -> 4060;
7123 -> 7122;
7123 -> 4062;
7123 -> 4060;
7124 -> 4058;
7124 -> 4090;
7124 -> 4216;
7124 -> 7123;
7124 -> 4225;
7124 -> 4086;
7124 -> 4087;
7124 -> 7109;
7124 -> 4097;
7124 -> 4089;
7125 -> 4240;
7126 -> 7125;
7126 -> 4109;
7127 -> 7126;
7127 -> 4111;
7127 -> 4109;
7128 -> 4107;
7128 -> 4141;
7128 -> 4236;
7128 -> 7127;
7128 -> 4245;
7128 -> 4135;
7128 -> 4136;
7128 -> 7113;
7128 -> 4143;
7128 -> 4140;
7129 -> 4260;
7130 -> 7129;
7130 -> 4155;
7131 -> 7130;
7131 -> 4157;
7131 -> 4155;
7132 -> 4153;
7132 -> 4187;
7132 -> 4256;
7132 -> 7131;
7132 -> 4265;
7132 -> 4181;
7132 -> 4182;
7132 -> 7117;
7132 -> 4189;
7132 -> 4186;
7133 -> 4201;
7134 -> 7133;
7134 -> 4022;
7135 -> 7134;
7135 -> 4024;
7135 -> 4022;
7136 -> 4220;
7137 -> 7136;
7137 -> 4060;
7138 -> 7137;
7138 -> 4062;
7138 -> 4060;
7139 -> 4058;
7139 -> 4090;
7139 -> 4216;
7139 -> 7138;
7139 -> 4225;
7139 -> 4086;
7139 -> 4087;
7139 -> 7124;
7139 -> 4097;
7139 -> 4089;
7140 -> 4240;
7141 -> 7140;
7141 -> 4109;
7142 -> 7141;
7142 -> 4111;
7142 -> 4109;
7143 -> 4107;
7143 -> 4141;
7143 -> 4236;
7143 -> 7142;
7143 -> 4245;
7143 -> 4135;
7143 -> 4136;
7143 -> 7128;
7143 -> 4143;
7143 -> 4140;
7144 -> 4260;
7145 -> 7144;
7145 -> 4155;
7146 -> 7145;
7146 -> 4157;
7146 -> 4155;
7147 -> 4153;
7147 -> 4187;
7147 -> 4256;
7147 -> 7146;
7147 -> 4265;
7147 -> 4181;
7147 -> 4182;
7147 -> 7132;
7147 -> 4189;
7147 -> 4186;
7148 -> 4201;
7149 -> 7148;
7149 -> 4022;
7150 -> 7149;
7150 -> 4024;
7150 -> 4022;
7151 -> 4220;
7152 -> 7151;
7152 -> 4060;
7153 -> 7152;
7153 -> 4062;
7153 -> 4060;
7154 -> 4058;
7154 -> 4090;
7154 -> 4216;
7154 -> 7153;
7154 -> 4225;
7154 -> 4086;
7154 -> 4087;
7154 -> 7139;
7154 -> 4097;
7154 -> 4089;
7155 -> 4240;
7156 -> 7155;
7156 -> 4109;
7157 -> 7156;
7157 -> 4111;
7157 -> 4109;
7158 -> 4107;
7158 -> 4141;
7158 -> 4236;
7158 -> 7157;
7158 -> 4245;
7158 -> 4135;
7158 -> 4136;
7158 -> 7143;
7158 -> 4143;
7158 -> 4140;
7159 -> 4260;
7160 -> 7159;
7160 -> 4155;
7161 -> 7160;
7161 -> 4157;
7161 -> 4155;
7162 -> 4153;
7162 -> 4187;
7162 -> 4256;
7162 -> 7161;
7162 -> 4265;
7162 -> 4181;
7162 -> 4182;
7162 -> 7147;
7162 -> 4189;
7162 -> 4186;
7163 -> 4201;
7164 -> 7163;
7164 -> 4022;
7165 -> 7164;
7165 -> 4024;
7165 -> 4022;
7166 -> 4220;
7167 -> 7166;
7167 -> 4060;
7168 -> 7167;
7168 -> 4062;
7168 -> 4060;
7169 -> 4058;
7169 -> 4090;
7169 -> 4216;
7169 -> 7168;
7169 -> 4225;
7169 -> 4086;
7169 -> 4087;
7169 -> 7154;
7169 -> 4097;
7169 -> 4089;
7170 -> 4240;
7171 -> 7170;
7171 -> 4109;
7172 -> 7171;
7172 -> 4111;
7172 -> 4109;
7173 -> 4107;
7173 -> 4141;
7173 -> 4236;
7173 -> 7172;
7173 -> 4245;
7173 -> 4135;
7173 -> 4136;
7173 -> 7158;
7173 -> 4143;
7173 -> 4140;
7174 -> 4260;
7175 -> 7174;
7175 -> 4155;
7176 -> 7175;
7176 -> 4157;
7176 -> 4155;
7177 -> 4153;
7177 -> 4187;
7177 -> 4256;
7177 -> 7176;
7177 -> 4265;
7177 -> 4181;
7177 -> 4182;
7177 -> 7162;
7177 -> 4189;
7177 -> 4186;
7178 -> 4201;
7179 -> 7178;
7179 -> 4022;
7180 -> 7179;
7180 -> 4024;
7180 -> 4022;
7181 -> 4220;
7182 -> 7181;
7182 -> 4060;
7183 -> 7182;
7183 -> 4062;
7183 -> 4060;
7184 -> 4058;
7184 -> 4090;
7184 -> 4216;
7184 -> 7183;
7184 -> 4225;
7184 -> 4086;
7184 -> 4087;
7184 -> 7169;
7184 -> 4097;
7184 -> 4089;
7185 -> 4240;
7186 -> 7185;
7186 -> 4109;
7187 -> 7186;
7187 -> 4111;
7187 -> 4109;
7188 -> 4107;
7188 -> 4141;
7188 -> 4236;
7188 -> 7187;
7188 -> 4245;
7188 -> 4135;
7188 -> 4136;
7188 -> 7173;
7188 -> 4143;
7188 -> 4140;
7189 -> 4260;
7190 -> 7189;
7190 -> 4155;
7191 -> 7190;
7191 -> 4157;
7191 -> 4155;
7192 -> 4153;
7192 -> 4187;
7192 -> 4256;
7192 -> 7191;
7192 -> 4265;
7192 -> 4181;
7192 -> 4182;
7192 -> 7177;
7192 -> 4189;
7192 -> 4186;
7193 -> 4201;
7194 -> 7193;
7194 -> 4022;
7195 -> 7194;
7195 -> 4024;
7195 -> 4022;
7196 -> 4220;
7197 -> 7196;
7197 -> 4060;
7198 -> 7197;
7198 -> 4062;
7198 -> 4060;
7199 -> 4058;
7199 -> 4090;
7199 -> 4216;
7199 -> 7198;
7199 -> 4225;
7199 -> 4086;
7199 -> 4087;
7199 -> 7184;
7199 -> 4097;
7199 -> 4089;
7200 -> 4240;
7201 -> 7200;
7201 -> 4109;
7202 -> 7201;
7202 -> 4111;
7202 -> 4109;
7203 -> 4107;
7203 -> 4141;
7203 -> 4236;
7203 -> 7202;
7203 -> 4245;
7203 -> 4135;
7203 -> 4136;
7203 -> 7188;
7203 -> 4143;
7203 -> 4140;
7204 -> 4260;
7205 -> 7204;
7205 -> 4155;
7206 -> 7205;
7206 -> 4157;
7206 -> 4155;
7207 -> 4153;
7207 -> 4187;
7207 -> 4256;
7207 -> 7206;
7207 -> 4265;
7207 -> 4181;
7207 -> 4182;
7207 -> 7192;
7207 -> 4189;
7207 -> 4186;
7208 -> 4201;
7209 -> 7208;
7209 -> 4022;
7210 -> 7209;
7210 -> 4024;
7210 -> 4022;
7211 -> 4220;
7212 -> 7211;
7212 -> 4060;
7213 -> 7212;
7213 -> 4062;
7213 -> 4060;
7214 -> 4058;
7214 -> 4090;
7214 -> 4216;
7214 -> 7213;
7214 -> 4225;
7214 -> 4086;
7214 -> 4087;
7214 -> 7199;
7214 -> 4097;
7214 -> 4089;
7215 -> 4240;
7216 -> 7215;
7216 -> 4109;
7217 -> 7216;
7217 -> 4111;
7217 -> 4109;
7218 -> 4107;
7218 -> 4141;
7218 -> 4236;
7218 -> 7217;
7218 -> 4245;
7218 -> 4135;
7218 -> 4136;
7218 -> 7203;
7218 -> 4143;
7218 -> 4140;
7219 -> 4260;
7220 -> 7219;
7220 -> 4155;
7221 -> 7220;
7221 -> 4157;
7221 -> 4155;
7222 -> 4153;
7222 -> 4187;
7222 -> 4256;
7222 -> 7221;
7222 -> 4265;
7222 -> 4181;
7222 -> 4182;
7222 -> 7207;
7222 -> 4189;
7222 -> 4186;
7223 -> 4201;
7224 -> 7223;
7224 -> 4022;
7225 -> 7224;
7225 -> 4024;
7225 -> 4022;
7226 -> 4220;
7227 -> 7226;
7227 -> 4060;
7228 -> 7227;
7228 -> 4062;
7228 -> 4060;
7229 -> 4058;
7229 -> 4090;
7229 -> 4216;
7229 -> 7228;
7229 -> 4225;
7229 -> 4086;
7229 -> 4087;
7229 -> 7214;
7229 -> 4097;
7229 -> 4089;
7230 -> 4240;
7231 -> 7230;
7231 -> 4109;
7232 -> 7231;
7232 -> 4111;
7232 -> 4109;
7233 -> 4107;
7233 -> 4141;
7233 -> 4236;
7233 -> 7232;
7233 -> 4245;
7233 -> 4135;
7233 -> 4136;
7233 -> 7218;
7233 -> 4143;
7233 -> 4140;
7234 -> 4260;
7235 -> 7234;
7235 -> 4155;
7236 -> 7235;
7236 -> 4157;
7236 -> 4155;
7237 -> 4153;
7237 -> 4187;
7237 -> 4256;
7237 -> 7236;
7237 -> 4265;
7237 -> 4181;
7237 -> 4182;
7237 -> 7222;
7237 -> 4189;
7237 -> 4186;
7238 -> 4201;
7239 -> 7238;
7239 -> 4022;
7240 -> 7239;
7240 -> 4024;
7240 -> 4022;
7241 -> 4220;
7242 -> 7241;
7242 -> 4060;
7243 -> 7242;
7243 -> 4062;
7243 -> 4060;
7244 -> 4058;
7244 -> 4090;
7244 -> 4216;
7244 -> 7243;
7244 -> 4225;
7244 -> 4086;
7244 -> 4087;
7244 -> 7229;
7244 -> 4097;
7244 -> 4089;
7245 -> 4240;
7246 -> 7245;
7246 -> 4109;
7247 -> 7246;
7247 -> 4111;
7247 -> 4109;
7248 -> 4107;
7248 -> 4141;
7248 -> 4236;
7248 -> 7247;
7248 -> 4245;
7248 -> 4135;
7248 -> 4136;
7248 -> 7233;
7248 -> 4143;
7248 -> 4140;
7249 -> 4260;
7250 -> 7249;
7250 -> 4155;
7251 -> 7250;
7251 -> 4157;
7251 -> 4155;
7252 -> 4153;
7252 -> 4187;
7252 -> 4256;
7252 -> 7251;
7252 -> 4265;
7252 -> 4181;
7252 -> 4182;
7252 -> 7237;
7252 -> 4189;
7252 -> 4186;
7253 -> 4201;
7254 -> 7253;
7254 -> 4022;
7255 -> 7254;
7255 -> 4024;
7255 -> 4022;
7256 -> 4220;
7257 -> 7256;
7257 -> 4060;
7258 -> 7257;
7258 -> 4062;
7258 -> 4060;
7259 -> 4058;
7259 -> 4090;
7259 -> 4216;
7259 -> 7258;
7259 -> 4225;
7259 -> 4086;
7259 -> 4087;
7259 -> 7244;
7259 -> 4097;
7259 -> 4089;
7260 -> 4240;
7261 -> 7260;
7261 -> 4109;
7262 -> 7261;
7262 -> 4111;
7262 -> 4109;
7263 -> 4107;
7263 -> 4141;
7263 -> 4236;
7263 -> 7262;
7263 -> 4245;
7263 -> 4135;
7263 -> 4136;
7263 -> 7248;
7263 -> 4143;
7263 -> 4140;
7264 -> 4260;
7265 -> 7264;
7265 -> 4155;
7266 -> 7265;
7266 -> 4157;
7266 -> 4155;
7267 -> 4153;
7267 -> 4187;
7267 -> 4256;
7267 -> 7266;
7267 -> 4265;
7267 -> 4181;
7267 -> 4182;
7267 -> 7252;
7267 -> 4189;
7267 -> 4186;
7268 -> 4201;
7269 -> 7268;
7269 -> 4022;
7270 -> 7269;
7270 -> 4024;
7270 -> 4022;
7271 -> 4220;
7272 -> 7271;
7272 -> 4060;
7273 -> 7272;
7273 -> 4062;
7273 -> 4060;
7274 -> 4058;
7274 -> 4090;
7274 -> 4216;
7274 -> 7273;
7274 -> 4225;
7274 -> 4086;
7274 -> 4087;
7274 -> 7259;
7274 -> 4097;
7274 -> 4089;
7275 -> 4240;
7276 -> 7275;
7276 -> 4109;
7277 -> 7276;
7277 -> 4111;
7277 -> 4109;
7278 -> 4107;
7278 -> 4141;
7278 -> 4236;
7278 -> 7277;
7278 -> 4245;
7278 -> 4135;
7278 -> 4136;
7278 -> 7263;
7278 -> 4143;
7278 -> 4140;
7279 -> 4260;
7280 -> 7279;
7280 -> 4155;
7281 -> 7280;
7281 -> 4157;
7281 -> 4155;
7282 -> 4153;
7282 -> 4187;
7282 -> 4256;
7282 -> 7281;
7282 -> 4265;
7282 -> 4181;
7282 -> 4182;
7282 -> 7267;
7282 -> 4189;
7282 -> 4186;
7283 -> 4201;
7284 -> 7283;
7284 -> 4022;
7285 -> 7284;
7285 -> 4024;
7285 -> 4022;
7286 -> 4220;
7287 -> 7286;
7287 -> 4060;
7288 -> 7287;
7288 -> 4062;
7288 -> 4060;
7289 -> 4058;
7289 -> 4090;
7289 -> 4216;
7289 -> 7288;
7289 -> 4225;
7289 -> 4086;
7289 -> 4087;
7289 -> 7274;
7289 -> 4097;
7289 -> 4089;
7290 -> 4240;
7291 -> 7290;
7291 -> 4109;
7292 -> 7291;
7292 -> 4111;
7292 -> 4109;
7293 -> 4107;
7293 -> 4141;
7293 -> 4236;
7293 -> 7292;
7293 -> 4245;
7293 -> 4135;
7293 -> 4136;
7293 -> 7278;
7293 -> 4143;
7293 -> 4140;
7294 -> 4260;
7295 -> 7294;
7295 -> 4155;
7296 -> 7295;
7296 -> 4157;
7296 -> 4155;
7297 -> 4153;
7297 -> 4187;
7297 -> 4256;
7297 -> 7296;
7297 -> 4265;
7297 -> 4181;
7297 -> 4182;
7297 -> 7282;
7297 -> 4189;
7297 -> 4186;
7298 -> 4201;
7299 -> 7298;
7299 -> 4022;
7300 -> 7299;
7300 -> 4024;
7300 -> 4022;
7301 -> 4220;
7302 -> 7301;
7302 -> 4060;
7303 -> 7302;
7303 -> 4062;
7303 -> 4060;
7304 -> 4058;
7304 -> 4090;
7304 -> 4216;
7304 -> 7303;
7304 -> 4225;
7304 -> 4086;
7304 -> 4087;
7304 -> 7289;
7304 -> 4097;
7304 -> 4089;
7305 -> 4240;
7306 -> 7305;
7306 -> 4109;
7307 -> 7306;
7307 -> 4111;
7307 -> 4109;
7308 -> 4107;
7308 -> 4141;
7308 -> 4236;
7308 -> 7307;
7308 -> 4245;
7308 -> 4135;
7308 -> 4136;
7308 -> 7293;
7308 -> 4143;
7308 -> 4140;
7309 -> 4260;
7310 -> 7309;
7310 -> 4155;
7311 -> 7310;
7311 -> 4157;
7311 -> 4155;
7312 -> 4153;
7312 -> 4187;
7312 -> 4256;
7312 -> 7311;
7312 -> 4265;
7312 -> 4181;
7312 -> 4182;
7312 -> 7297;
7312 -> 4189;
7312 -> 4186;
7313 -> 4201;
7314 -> 7313;
7314 -> 4022;
7315 -> 7314;
7315 -> 4024;
7315 -> 4022;
7316 -> 4220;
7317 -> 7316;
7317 -> 4060;
7318 -> 7317;
7318 -> 4062;
7318 -> 4060;
7319 -> 4058;
7319 -> 4090;
7319 -> 4216;
7319 -> 7318;
7319 -> 4225;
7319 -> 4086;
7319 -> 4087;
7319 -> 7304;
7319 -> 4097;
7319 -> 4089;
7320 -> 4240;
7321 -> 7320;
7321 -> 4109;
7322 -> 7321;
7322 -> 4111;
7322 -> 4109;
7323 -> 4107;
7323 -> 4141;
7323 -> 4236;
7323 -> 7322;
7323 -> 4245;
7323 -> 4135;
7323 -> 4136;
7323 -> 7308;
7323 -> 4143;
7323 -> 4140;
7324 -> 4260;
7325 -> 7324;
7325 -> 4155;
7326 -> 7325;
7326 -> 4157;
7326 -> 4155;
7327 -> 4153;
7327 -> 4187;
7327 -> 4256;
7327 -> 7326;
7327 -> 4265;
7327 -> 4181;
7327 -> 4182;
7327 -> 7312;
7327 -> 4189;
7327 -> 4186;
7328 -> 4201;
7329 -> 7328;
7329 -> 4022;
7330 -> 7329;
7330 -> 4024;
7330 -> 4022;
7331 -> 4220;
7332 -> 7331;
7332 -> 4060;
7333 -> 7332;
7333 -> 4062;
7333 -> 4060;
7334 -> 4058;
7334 -> 4090;
7334 -> 4216;
7334 -> 7333;
7334 -> 4225;
7334 -> 4086;
7334 -> 4087;
7334 -> 7319;
7334 -> 4097;
7334 -> 4089;
7335 -> 4240;
7336 -> 7335;
7336 -> 4109;
7337 -> 7336;
7337 -> 4111;
7337 -> 4109;
7338 -> 4107;
7338 -> 4141;
7338 -> 4236;
7338 -> 7337;
7338 -> 4245;
7338 -> 4135;
7338 -> 4136;
7338 -> 7323;
7338 -> 4143;
7338 -> 4140;
7339 -> 4260;
7340 -> 7339;
7340 -> 4155;
7341 -> 7340;
7341 -> 4157;
7341 -> 4155;
7342 -> 4153;
7342 -> 4187;
7342 -> 4256;
7342 -> 7341;
7342 -> 4265;
7342 -> 4181;
7342 -> 4182;
7342 -> 7327;
7342 -> 4189;
7342 -> 4186;
7343 -> 4201;
7344 -> 7343;
7344 -> 4022;
7345 -> 7344;
7345 -> 4024;
7345 -> 4022;
7346 -> 4220;
7347 -> 7346;
7347 -> 4060;
7348 -> 7347;
7348 -> 4062;
7348 -> 4060;
7349 -> 4058;
7349 -> 4090;
7349 -> 4216;
7349 -> 7348;
7349 -> 4225;
7349 -> 4086;
7349 -> 4087;
7349 -> 7334;
7349 -> 4097;
7349 -> 4089;
7350 -> 4240;
7351 -> 7350;
7351 -> 4109;
7352 -> 7351;
7352 -> 4111;
7352 -> 4109;
7353 -> 4107;
7353 -> 4141;
7353 -> 4236;
7353 -> 7352;
7353 -> 4245;
7353 -> 4135;
7353 -> 4136;
7353 -> 7338;
7353 -> 4143;
7353 -> 4140;
7354 -> 4260;
7355 -> 7354;
7355 -> 4155;
7356 -> 7355;
7356 -> 4157;
7356 -> 4155;
7357 -> 4153;
7357 -> 4187;
7357 -> 4256;
7357 -> 7356;
7357 -> 4265;
7357 -> 4181;
7357 -> 4182;
7357 -> 7342;
7357 -> 4189;
7357 -> 4186;
7358 -> 4201;
7359 -> 7358;
7359 -> 4022;
7360 -> 7359;
7360 -> 4024;
7360 -> 4022;
7361 -> 4220;
7362 -> 7361;
7362 -> 4060;
7363 -> 7362;
7363 -> 4062;
7363 -> 4060;
7364 -> 4058;
7364 -> 4090;
7364 -> 4216;
7364 -> 7363;
7364 -> 4225;
7364 -> 4086;
7364 -> 4087;
7364 -> 7349;
7364 -> 4097;
7364 -> 4089;
7365 -> 4240;
7366 -> 7365;
7366 -> 4109;
7367 -> 7366;
7367 -> 4111;
7367 -> 4109;
7368 -> 4107;
7368 -> 4141;
7368 -> 4236;
7368 -> 7367;
7368 -> 4245;
7368 -> 4135;
7368 -> 4136;
7368 -> 7353;
7368 -> 4143;
7368 -> 4140;
7369 -> 4260;
7370 -> 7369;
7370 -> 4155;
7371 -> 7370;
7371 -> 4157;
7371 -> 4155;
7372 -> 4153;
7372 -> 4187;
7372 -> 4256;
7372 -> 7371;
7372 -> 4265;
7372 -> 4181;
7372 -> 4182;
7372 -> 7357;
7372 -> 4189;
7372 -> 4186;
7373 -> 4201;
7374 -> 7373;
7374 -> 4022;
7375 -> 7374;
7375 -> 4024;
7375 -> 4022;
7376 -> 4220;
7377 -> 7376;
7377 -> 4060;
7378 -> 7377;
7378 -> 4062;
7378 -> 4060;
7379 -> 4058;
7379 -> 4090;
7379 -> 4216;
7379 -> 7378;
7379 -> 4225;
7379 -> 4086;
7379 -> 4087;
7379 -> 7364;
7379 -> 4097;
7379 -> 4089;
7380 -> 4240;
7381 -> 7380;
7381 -> 4109;
7382 -> 7381;
7382 -> 4111;
7382 -> 4109;
7383 -> 4107;
7383 -> 4141;
7383 -> 4236;
7383 -> 7382;
7383 -> 4245;
7383 -> 4135;
7383 -> 4136;
7383 -> 7368;
7383 -> 4143;
7383 -> 4140;
7384 -> 4260;
7385 -> 7384;
7385 -> 4155;
7386 -> 7385;
7386 -> 4157;
7386 -> 4155;
7387 -> 4153;
7387 -> 4187;
7387 -> 4256;
7387 -> 7386;
7387 -> 4265;
7387 -> 4181;
7387 -> 4182;
7387 -> 7372;
7387 -> 4189;
7387 -> 4186;
7388 -> 4201;
7389 -> 7388;
7389 -> 4022;
7390 -> 7389;
7390 -> 4024;
7390 -> 4022;
7391 -> 4220;
7392 -> 7391;
7392 -> 4060;
7393 -> 7392;
7393 -> 4062;
7393 -> 4060;
7394 -> 4058;
7394 -> 4090;
7394 -> 4216;
7394 -> 7393;
7394 -> 4225;
7394 -> 4086;
7394 -> 4087;
7394 -> 7379;
7394 -> 4097;
7394 -> 4089;
7395 -> 4240;
7396 -> 7395;
7396 -> 4109;
7397 -> 7396;
7397 -> 4111;
7397 -> 4109;
7398 -> 4107;
7398 -> 4141;
7398 -> 4236;
7398 -> 7397;
7398 -> 4245;
7398 -> 4135;
7398 -> 4136;
7398 -> 7383;
7398 -> 4143;
7398 -> 4140;
7399 -> 4260;
7400 -> 7399;
7400 -> 4155;
7401 -> 7400;
7401 -> 4157;
7401 -> 4155;
7402 -> 4153;
7402 -> 4187;
7402 -> 4256;
7402 -> 7401;
7402 -> 4265;
7402 -> 4181;
7402 -> 4182;
7402 -> 7387;
7402 -> 4189;
7402 -> 4186;
7403 -> 4201;
7404 -> 7403;
7404 -> 4022;
7405 -> 7404;
7405 -> 4024;
7405 -> 4022;
7406 -> 4220;
7407 -> 7406;
7407 -> 4060;
7408 -> 7407;
7408 -> 4062;
7408 -> 4060;
7409 -> 4058;
7409 -> 4090;
7409 -> 4216;
7409 -> 7408;
7409 -> 4225;
7409 -> 4086;
7409 -> 4087;
7409 -> 7394;
7409 -> 4097;
7409 -> 4089;
7410 -> 4240;
7411 -> 7410;
7411 -> 4109;
7412 -> 7411;
7412 -> 4111;
7412 -> 4109;
7413 -> 4107;
7413 -> 4141;
7413 -> 4236;
7413 -> 7412;
7413 -> 4245;
7413 -> 4135;
7413 -> 4136;
7413 -> 7398;
7413 -> 4143;
7413 -> 4140;
7414 -> 4260;
7415 -> 7414;
7415 -> 4155;
7416 -> 7415;
7416 -> 4157;
7416 -> 4155;
7417 -> 4153;
7417 -> 4187;
7417 -> 4256;
7417 -> 7416;
7417 -> 4265;
7417 -> 4181;
7417 -> 4182;
7417 -> 7402;
7417 -> 4189;
7417 -> 4186;
7418 -> 3996;
7418 -> 3994;
7419 -> 3995;
7419 -> 3994;
7420 -> 3997;
7420 -> 3994;
7421 -> 3994;
7422 -> 7418;
7422 -> 7421;
7423 -> 7419;
7423 -> 7421;
7424 -> 7420;
7424 -> 7421;
7425 -> 7422;
7425 -> 3999;
7425 -> 7421;
7426 -> 7421;
7427 -> 7423;
7427 -> 7426;
7427 -> 7421;
7428 -> 7427;
7429 -> 7424;
7429 -> 7428;
7429 -> 7427;
7430 -> 4003;
7430 -> 4002;
7430 -> 7422;
7430 -> 7429;
7431 -> 3979;
7432 -> 3983;
7432 -> 7431;
7432 -> 3979;
7433 -> 7430;
7433 -> 3979;
7434 -> 7433;
7434 -> 3763;
7435 -> 3763;
7436 -> 7434;
7436 -> 7435;
7437 -> 3752;
7437 -> 7435;
7438 -> 7435;
7439 -> 7436;
7439 -> 7438;
7439 -> 7435;
7440 -> 7437;
7440 -> 3723;
7440 -> 3759;
7440 -> 3758;
7440 -> 7435;
7441 -> 7437;
7441 -> 3759;
7441 -> 3758;
7441 -> 3723;
7441 -> 7435;
7442 -> 7436;
7442 -> 7441;
7442 -> 7435;
7443 -> 7437;
7443 -> 3723;
7443 -> 7435;
7444 -> 3763;
7445 -> 3763;
7446 -> 7433;
7446 -> 7445;
7447 -> 7446;
7447 -> 7445;
7448 -> 7447;
7448 -> 3763;
7449 -> 3750;
7450 -> 3687;
7451 -> 7450;
7451 -> 3693;
7451 -> 3687;
7452 -> 3693;
7452 -> 3687;
7453 -> 3693;
7453 -> 3687;
7454 -> 3693;
7454 -> 3687;
7455 -> 3693;
7455 -> 3687;
7456 -> 3693;
7456 -> 3687;
7457 -> 3693;
7457 -> 3687;
7458 -> 3687;
7459 -> 7458;
7459 -> 3693;
7459 -> 3687;
7460 -> 3693;
7460 -> 7459;
7460 -> 3687;
7461 -> 3687;
7462 -> 7461;
7462 -> 3693;
7462 -> 3687;
7463 -> 3686;
7463 -> 3535;
7464 -> 3535;
7465 -> 7463;
7465 -> 7464;
7466 -> 7465;
7466 -> 7464;
7467 -> 0;
7467 -> 7464;
7468 -> 7464;
7469 -> 7466;
7469 -> 7468;
7470 -> 7467;
7470 -> 7468;
7471 -> 7465;
7471 -> 7468;
7472 -> 7468;
7473 -> 7471;
7473 -> 7454;
7473 -> 7472;
7473 -> 7468;
7474 -> 7469;
7474 -> 7468;
7475 -> 7468;
7476 -> 7474;
7476 -> 7475;
7477 -> 7475;
7478 -> 7475;
7479 -> 7476;
7479 -> 7474;
7479 -> 7475;
7480 -> 7475;
7481 -> 7475;
7482 -> 7479;
7482 -> 7481;
7483 -> 7480;
7483 -> 7481;
7484 -> 7482;
7484 -> 7474;
7484 -> 7481;
7485 -> 7484;
7485 -> 7483;
7485 -> 7481;
7486 -> 7482;
7486 -> 7484;
7486 -> 7481;
7487 -> 7486;
7487 -> 7483;
7487 -> 7481;
7488 -> 7482;
7488 -> 7486;
7488 -> 7481;
7489 -> 7488;
7489 -> 7483;
7489 -> 7481;
7490 -> 7482;
7490 -> 7488;
7490 -> 7481;
7491 -> 7490;
7491 -> 7483;
7491 -> 7481;
7492 -> 7477;
7492 -> 7475;
7493 -> 7480;
7493 -> 7475;
7494 -> 7478;
7494 -> 7475;
7495 -> 0;
7495 -> 7475;
7496 -> 7492;
7496 -> 7493;
7496 -> 7494;
7496 -> 7495;
7496 -> 7476;
7496 -> 7490;
7496 -> 7484;
7496 -> 7486;
7496 -> 7488;
7496 -> 7485;
7496 -> 7487;
7496 -> 7489;
7496 -> 7491;
7496 -> 7475;
7497 -> 7475;
7498 -> 7496;
7498 -> 7497;
7499 -> 7498;
7499 -> 7496;
7499 -> 7497;
7500 -> 7496;
7500 -> 7497;
7501 -> 7497;
7502 -> 7500;
7502 -> 7501;
7503 -> 7502;
7503 -> 7499;
7503 -> 7501;
7504 -> 7501;
7505 -> 7502;
7505 -> 7499;
7505 -> 7504;
7505 -> 7501;
7506 -> 7502;
7506 -> 7499;
7506 -> 7505;
7507 -> 7506;
7507 -> 7497;
7508 -> 7507;
7508 -> 7500;
7508 -> 7497;
7509 -> 7496;
7509 -> 7497;
7510 -> 7509;
7510 -> 7508;
7510 -> 7497;
7511 -> 7496;
7511 -> 7497;
7512 -> 7496;
7512 -> 7497;
7513 -> 7497;
7514 -> 7511;
7514 -> 7510;
7514 -> 7513;
7514 -> 7497;
7515 -> 0;
7515 -> 7475;
7516 -> 7475;
7517 -> 7515;
7517 -> 7516;
7518 -> 7476;
7518 -> 7516;
7519 -> 7517;
7519 -> 7516;
7520 -> 7516;
7521 -> 7519;
7521 -> 7520;
7522 -> 7521;
7522 -> 0;
7522 -> 7520;
7523 -> 7522;
7524 -> 7516;
7525 -> 7518;
7525 -> 7524;
7526 -> 7525;
7526 -> 7510;
7526 -> 7524;
7527 -> 7526;
7527 -> 7516;
7528 -> 7516;
7529 -> 7527;
7529 -> 7528;
7530 -> 7529;
7530 -> 7516;
7531 -> 7530;
7531 -> 7517;
7531 -> 7516;
7532 -> 7531;
7533 -> 7518;
7533 -> 7532;
7534 -> 7532;
7535 -> 7533;
7535 -> 7510;
7535 -> 7534;
7536 -> 7534;
7537 -> 7536;
7537 -> 7532;
7538 -> 7537;
7538 -> 7533;
7538 -> 7532;
7539 -> 7532;
7540 -> 7539;
7540 -> 7533;
7540 -> 7532;
7541 -> 7532;
7542 -> 7533;
7542 -> 7510;
7542 -> 7541;
7542 -> 7532;
7543 -> 7533;
7543 -> 7510;
7543 -> 7532;
7544 -> 7531;
7545 -> 7527;
7545 -> 7531;
7546 -> 7510;
7546 -> 7475;
7547 -> 7545;
7547 -> 7475;
7548 -> 7546;
7548 -> 7547;
7548 -> 7476;
7548 -> 7510;
7548 -> 7538;
7548 -> 7540;
7548 -> 7543;
7548 -> 7475;
7549 -> 7475;
7550 -> 7548;
7550 -> 7549;
7551 -> 7548;
7551 -> 7549;
7552 -> 7550;
7552 -> 7549;
7553 -> 7549;
7554 -> 7553;
7554 -> 7552;
7554 -> 7549;
7555 -> 7553;
7555 -> 7549;
7556 -> 7555;
7556 -> 7554;
7556 -> 7549;
7557 -> 7548;
7557 -> 7549;
7558 -> 7548;
7558 -> 7549;
7559 -> 7557;
7559 -> 7556;
7559 -> 7549;
7560 -> 7557;
7560 -> 7556;
7560 -> 7549;
7561 -> 7475;
7562 -> 7510;
7562 -> 7561;
7562 -> 7475;
7563 -> 7556;
7563 -> 7475;
7564 -> 7476;
7564 -> 7556;
7564 -> 7475;
7565 -> 7475;
7566 -> 7564;
7566 -> 7565;
7567 -> 7510;
7567 -> 7565;
7568 -> 7567;
7568 -> 7510;
7568 -> 7565;
7569 -> 7566;
7569 -> 7568;
7569 -> 7556;
7569 -> 7510;
7569 -> 7565;
7570 -> 7567;
7570 -> 7510;
7570 -> 7565;
7571 -> 7566;
7571 -> 7570;
7571 -> 7569;
7571 -> 7510;
7571 -> 7565;
7572 -> 7567;
7572 -> 7510;
7572 -> 7565;
7573 -> 7566;
7573 -> 7572;
7573 -> 7571;
7573 -> 7510;
7573 -> 7565;
7574 -> 7567;
7574 -> 7510;
7574 -> 7565;
7575 -> 7566;
7575 -> 7574;
7575 -> 7573;
7575 -> 7510;
7575 -> 7565;
7576 -> 7475;
7577 -> 7474;
7577 -> 7563;
7577 -> 7575;
7577 -> 7468;
7578 -> 7577;
7578 -> 3535;
7579 -> 7578;
7579 -> 3535;
7580 -> 7578;
7580 -> 7577;
7580 -> 3535;
7581 -> 3535;
7582 -> 7580;
7582 -> 7581;
7583 -> 7580;
7583 -> 7581;
7584 -> 7580;
7584 -> 7581;
7585 -> 7579;
7585 -> 7581;
7586 -> 7582;
7586 -> 7581;
7587 -> 7583;
7587 -> 7581;
7588 -> 7584;
7588 -> 7581;
7589 -> 7581;
7590 -> 7589;
7590 -> 7586;
7590 -> 7587;
7590 -> 7588;
7590 -> 7580;
7590 -> 7581;
7591 -> 7590;
7591 -> 3524;
7592 -> 3524;
7593 -> 7591;
7593 -> 7592;
7594 -> 3525;
7594 -> 7592;
7595 -> 7593;
7595 -> 7592;
7596 -> 7594;
7596 -> 7592;
7597 -> 7595;
7597 -> 7596;
7597 -> 7592;
7598 -> 7595;
7598 -> 7596;
7598 -> 7590;
7598 -> 3526;
7598 -> 3527;
7598 -> 3528;
7598 -> 3529;
7598 -> 3530;
7598 -> 3531;
7598 -> 3532;
7598 -> 7592;
7599 -> 7592;
7600 -> 7599;
7601 -> 7598;
7601 -> 3525;
7601 -> 3524;
7602 -> 3524;
7603 -> 3520;
7603 -> 3519;
7604 -> 3521;
7604 -> 3519;
7605 -> 3522;
7605 -> 3519;
7606 -> 3523;
7606 -> 3519;
7607 -> 3519;
7608 -> 7603;
7608 -> 7607;
7609 -> 7604;
7609 -> 7607;
7610 -> 7605;
7610 -> 7607;
7611 -> 7606;
7611 -> 7607;
7612 -> 7608;
7612 -> 7607;
7613 -> 7609;
7613 -> 7607;
7614 -> 7610;
7614 -> 7607;
7615 -> 7607;
7616 -> 7611;
7616 -> 7607;
7617 -> 7607;
7618 -> 7612;
7618 -> 7617;
7619 -> 7613;
7619 -> 7617;
7620 -> 7614;
7620 -> 7617;
7621 -> 7615;
7621 -> 7617;
7622 -> 7616;
7622 -> 7617;
7623 -> 7618;
7623 -> 7617;
7624 -> 7619;
7624 -> 7617;
7625 -> 7620;
7625 -> 7617;
7626 -> 7621;
7626 -> 7617;
7627 -> 7617;
7628 -> 7627;
7628 -> 7617;
7629 -> 7622;
7629 -> 7617;
7630 -> 7617;
7631 -> 7623;
7631 -> 7630;
7632 -> 7624;
7632 -> 7630;
7633 -> 7625;
7633 -> 7630;
7634 -> 7626;
7634 -> 7630;
7635 -> 7628;
7635 -> 7630;
7636 -> 7629;
7636 -> 7630;
7637 -> 7630;
7638 -> 7631;
7638 -> 7637;
7638 -> 7630;
7639 -> 7632;
7639 -> 7630;
7640 -> 7631;
7640 -> 7630;
7641 -> 7639;
7641 -> 7630;
7642 -> 7630;
7643 -> 7630;
7644 -> 7640;
7644 -> 7643;
7645 -> 7641;
7645 -> 7643;
7646 -> 7642;
7646 -> 7643;
7647 -> 7642;
7647 -> 7643;
7648 -> 7642;
7648 -> 7643;
7649 -> 7644;
7649 -> 7643;
7650 -> 7643;
7651 -> 7649;
7651 -> 7650;
7652 -> 7648;
7652 -> 7650;
7653 -> 7652;
7653 -> 7650;
7654 -> 7652;
7654 -> 7650;
7655 -> 7651;
7655 -> 7650;
7656 -> 7650;
7657 -> 7650;
7658 -> 7655;
7658 -> 7657;
7659 -> 7656;
7659 -> 7657;
7660 -> 7659;
7660 -> 7657;
7661 -> 7659;
7661 -> 7657;
7662 -> 7659;
7662 -> 7657;
7663 -> 7659;
7663 -> 7657;
7664 -> 7659;
7664 -> 7657;
7665 -> 7659;
7665 -> 7657;
7666 -> 7659;
7666 -> 7657;
7667 -> 7659;
7667 -> 7657;
7668 -> 7658;
7668 -> 7659;
7668 -> 7657;
7669 -> 7657;
7670 -> 7669;
7670 -> 7659;
7670 -> 7657;
7671 -> 7657;
7672 -> 7671;
7672 -> 7659;
7672 -> 7657;
7673 -> 7658;
7673 -> 3987;
7673 -> 7659;
7673 -> 7657;
7674 -> 7657;
7675 -> 7674;
7675 -> 7659;
7675 -> 7657;
7676 -> 3606;
7676 -> 3987;
7676 -> 7657;
7677 -> 7657;
7678 -> 7677;
7678 -> 7659;
7678 -> 7657;
7679 -> 7656;
7679 -> 7652;
7679 -> 7650;
7680 -> 7648;
7680 -> 7643;
7681 -> 7648;
7681 -> 7643;
7682 -> 7648;
7682 -> 7643;
7683 -> 7648;
7683 -> 7643;
7684 -> 7648;
7684 -> 7643;
7685 -> 7648;
7685 -> 7643;
7686 -> 7648;
7686 -> 7643;
7687 -> 7648;
7687 -> 7643;
7688 -> 7648;
7688 -> 7643;
7689 -> 7648;
7689 -> 7643;
7690 -> 7643;
7691 -> 7690;
7691 -> 7643;
7692 -> 7691;
7692 -> 7648;
7692 -> 7643;
7693 -> 7643;
7694 -> 7693;
7694 -> 7643;
7695 -> 7694;
7695 -> 7648;
7695 -> 7643;
7696 -> 7648;
7696 -> 7643;
7697 -> 7648;
7697 -> 7643;
7698 -> 7643;
7699 -> 7645;
7699 -> 7698;
7699 -> 7643;
7700 -> 7645;
7700 -> 7648;
7700 -> 7643;
7701 -> 7643;
7702 -> 7701;
7702 -> 7648;
7702 -> 7643;
7703 -> 7643;
7704 -> 7703;
7704 -> 7648;
7704 -> 7643;
7705 -> 7643;
7706 -> 7643;
7707 -> 7705;
7707 -> 7706;
7708 -> 7707;
7708 -> 7706;
7709 -> 7707;
7709 -> 7706;
7710 -> 7707;
7710 -> 7706;
7711 -> 7706;
7712 -> 7711;
7712 -> 7707;
7712 -> 7706;
7713 -> 7706;
7714 -> 7713;
7714 -> 7707;
7714 -> 7706;
7715 -> 7705;
7715 -> 7648;
7715 -> 7643;
7716 -> 7648;
7716 -> 7643;
7717 -> 7646;
7717 -> 7648;
7717 -> 7643;
7718 -> 7647;
7718 -> 7648;
7718 -> 7643;
7719 -> 7642;
7719 -> 7630;
7720 -> 7630;
7721 -> 7636;
7721 -> 7630;
7722 -> 7630;
7723 -> 7719;
7723 -> 7722;
7724 -> 7720;
7724 -> 7722;
7725 -> 7720;
7725 -> 7722;
7726 -> 7721;
7726 -> 7722;
7727 -> 7720;
7727 -> 7722;
7728 -> 7720;
7728 -> 7722;
7729 -> 7723;
7729 -> 7722;
7730 -> 7726;
7730 -> 7722;
7731 -> 7724;
7731 -> 7722;
7732 -> 7725;
7732 -> 7722;
7733 -> 7722;
7734 -> 7722;
7735 -> 7727;
7735 -> 7722;
7736 -> 7722;
7737 -> 7729;
7737 -> 7736;
7738 -> 7730;
7738 -> 7736;
7739 -> 7731;
7739 -> 7736;
7740 -> 7732;
7740 -> 7736;
7741 -> 7733;
7741 -> 7736;
7742 -> 7734;
7742 -> 7736;
7743 -> 7735;
7743 -> 7736;
7744 -> 7728;
7744 -> 7736;
7745 -> 7744;
7745 -> 7736;
7746 -> 7744;
7746 -> 7736;
7747 -> 7744;
7747 -> 7736;
7748 -> 7744;
7748 -> 7736;
7749 -> 7744;
7749 -> 7736;
7750 -> 7744;
7750 -> 7736;
7751 -> 7744;
7751 -> 7736;
7752 -> 7744;
7752 -> 7736;
7753 -> 7744;
7753 -> 7736;
7754 -> 7744;
7754 -> 7736;
7755 -> 7744;
7755 -> 7736;
7756 -> 7744;
7756 -> 7736;
7757 -> 7744;
7757 -> 7736;
7758 -> 7737;
7758 -> 7744;
7758 -> 7736;
7759 -> 7738;
7759 -> 7744;
7759 -> 7736;
7760 -> 7741;
7760 -> 7744;
7760 -> 7736;
7761 -> 7743;
7761 -> 7744;
7761 -> 7736;
7762 -> 7736;
7763 -> 7762;
7763 -> 7744;
7763 -> 7736;
7764 -> 7736;
7765 -> 7739;
7765 -> 7764;
7765 -> 7736;
7766 -> 7765;
7766 -> 7744;
7766 -> 7736;
7767 -> 7736;
7768 -> 7744;
7768 -> 7767;
7769 -> 7768;
7769 -> 7766;
7769 -> 7767;
7770 -> 7769;
7770 -> 7736;
7771 -> 7770;
7771 -> 7741;
7771 -> 7736;
7772 -> 7771;
7773 -> 7772;
7773 -> 7744;
7773 -> 7771;
7774 -> 7771;
7775 -> 7774;
7775 -> 7744;
7775 -> 7771;
7776 -> 7736;
7777 -> 7744;
7777 -> 7776;
7778 -> 7777;
7778 -> 7766;
7778 -> 7776;
7779 -> 7778;
7779 -> 7736;
7780 -> 7742;
7780 -> 7779;
7780 -> 7736;
7781 -> 7780;
7781 -> 7743;
7781 -> 7736;
7782 -> 7781;
7783 -> 7744;
7783 -> 7782;
7784 -> 7782;
7785 -> 7782;
7786 -> 7783;
7786 -> 7758;
7786 -> 7679;
7786 -> 7785;
7787 -> 7786;
7787 -> 7668;
7787 -> 7785;
7788 -> 7787;
7788 -> 7782;
7789 -> 7788;
7789 -> 7676;
7789 -> 7784;
7789 -> 7782;
7790 -> 7789;
7790 -> 7782;
7791 -> 7790;
7791 -> 7783;
7791 -> 7782;
7792 -> 7783;
7792 -> 7758;
7792 -> 7782;
7793 -> 7783;
7793 -> 7759;
7793 -> 7782;
7794 -> 7782;
7795 -> 7793;
7795 -> 7789;
7796 -> 3768;
7796 -> 7789;
7797 -> 7789;
7797 -> 7679;
7797 -> 7654;
7797 -> 7700;
7797 -> 7795;
7797 -> 7702;
7797 -> 7704;
7797 -> 7684;
7797 -> 7715;
7797 -> 7717;
7797 -> 7718;
7797 -> 7688;
7797 -> 7689;
7797 -> 7692;
7797 -> 7695;
7797 -> 7696;
7797 -> 7716;
7797 -> 7668;
7797 -> 7670;
7797 -> 7672;
7797 -> 7673;
7797 -> 7676;
7797 -> 7665;
7797 -> 7678;
7797 -> 7675;
7797 -> 7674;
7797 -> 7691;
7797 -> 7694;
7797 -> 7701;
7797 -> 7703;
7797 -> 7712;
7797 -> 7714;
7797 -> 7711;
7797 -> 7713;
7798 -> 7795;
7799 -> 7795;
7800 -> 7795;
7800 -> 7797;
7800 -> 7799;
7801 -> 7800;
7801 -> 7795;
7802 -> 7795;
7803 -> 7802;
7803 -> 7795;
7804 -> 7795;
7805 -> 7795;
7806 -> 7795;
7806 -> 7797;
7806 -> 7805;
7807 -> 7806;
7808 -> 7806;
7808 -> 7797;
7808 -> 7795;
7809 -> 7806;
7809 -> 7797;
7810 -> 7806;
7810 -> 7797;
7810 -> 7795;
7811 -> 7806;
7811 -> 7797;
7812 -> 7809;
7812 -> 7806;
7813 -> 7806;
7813 -> 7812;
7813 -> 7809;
7814 -> 7813;
7814 -> 7806;
7815 -> 7806;
7816 -> 7809;
7816 -> 7815;
7816 -> 7806;
7817 -> 7806;
7817 -> 7812;
7817 -> 7814;
7817 -> 7805;
7818 -> 7817;
7818 -> 7795;
7819 -> 7795;
7820 -> 7818;
7820 -> 7819;
7820 -> 7795;
7821 -> 7820;
7822 -> 7818;
7822 -> 7795;
7823 -> 7822;
7824 -> 7795;
7824 -> 7823;
7825 -> 7823;
7826 -> 7823;
7827 -> 7824;
7827 -> 7812;
7827 -> 7826;
7828 -> 7827;
7828 -> 7823;
7829 -> 7828;
7830 -> 7824;
7830 -> 7812;
7830 -> 7829;
7831 -> 7830;
7831 -> 7812;
7831 -> 7829;
7832 -> 7828;
7833 -> 7828;
7834 -> 7833;
7834 -> 7812;
7834 -> 7831;
7834 -> 7814;
7835 -> 7833;
7835 -> 7812;
7835 -> 7814;
7835 -> 7831;
7836 -> 7835;
7836 -> 7828;
7837 -> 7828;
7838 -> 7836;
7839 -> 7836;
7840 -> 2896;
7840 -> 7836;
7841 -> 7840;
7841 -> 7822;
7842 -> 7797;
7842 -> 7822;
7843 -> 7822;
7844 -> 7841;
7844 -> 7843;
7845 -> 7842;
7845 -> 7843;
7846 -> 7795;
7846 -> 7843;
7847 -> 7843;
7848 -> 7846;
7848 -> 7847;
7849 -> 7847;
7850 -> 7848;
7850 -> 7812;
7850 -> 7849;
7850 -> 7847;
7851 -> 7850;
7851 -> 7843;
7852 -> 7843;
7853 -> 7845;
7853 -> 7852;
7853 -> 7843;
7854 -> 7844;
7854 -> 7843;
7855 -> 7845;
7855 -> 7854;
7855 -> 7812;
7855 -> 7814;
7855 -> 7831;
7855 -> 7838;
7855 -> 7417;
7855 -> 4189;
7855 -> 7843;
7856 -> 7822;
7857 -> 7802;
7857 -> 7822;
7858 -> 7822;
7859 -> 7855;
7859 -> 7819;
7859 -> 7795;
7860 -> 7859;
7861 -> 7855;
7862 -> 7795;
7863 -> 7855;
7863 -> 7795;
7864 -> 7855;
7864 -> 7795;
7865 -> 0;
7865 -> 7863;
7865 -> 7795;
7866 -> 7863;
7866 -> 7795;
7867 -> 7795;
7868 -> 7866;
7868 -> 7867;
7869 -> 7864;
7869 -> 7867;
7870 -> 7868;
7870 -> 7867;
7871 -> 7870;
7871 -> 7869;
7871 -> 7855;
7871 -> 7865;
7871 -> 7867;
7872 -> 7867;
7873 -> 7871;
7873 -> 7872;
7874 -> 7871;
7874 -> 7872;
7875 -> 7871;
7875 -> 7872;
7876 -> 7871;
7876 -> 7872;
7877 -> 7873;
7877 -> 7872;
7878 -> 7874;
7878 -> 7872;
7879 -> 7875;
7879 -> 7872;
7880 -> 7876;
7880 -> 7871;
7880 -> 7877;
7880 -> 7878;
7880 -> 7879;
7880 -> 7872;
7881 -> 7880;
7882 -> 0;
7882 -> 7881;
7883 -> 7881;
7884 -> 7882;
7884 -> 7883;
7885 -> 7864;
7885 -> 7883;
7886 -> 7885;
7886 -> 7880;
7886 -> 7883;
7887 -> 7883;
7888 -> 7886;
7888 -> 7887;
7889 -> 7888;
7889 -> 0;
7889 -> 7887;
7890 -> 7889;
7890 -> 7884;
7890 -> 7883;
7891 -> 7880;
7891 -> 7890;
7892 -> 7890;
7893 -> 7891;
7893 -> 7892;
7894 -> 7891;
7894 -> 7892;
7895 -> 7864;
7895 -> 7880;
7895 -> 7892;
7896 -> 7893;
7896 -> 3663;
7896 -> 7892;
7897 -> 7893;
7897 -> 7892;
7898 -> 7897;
7898 -> 7895;
7898 -> 7880;
7898 -> 7892;
7899 -> 7892;
7900 -> 7898;
7900 -> 7899;
7901 -> 7900;
7901 -> 7899;
7902 -> 0;
7902 -> 7901;
7903 -> 7902;
7903 -> 0;
7903 -> 7892;
7904 -> 7880;
7904 -> 7902;
7904 -> 7903;
7905 -> 7903;
7906 -> 7904;
7906 -> 7905;
7907 -> 7906;
7907 -> 7905;
7908 -> 7907;
7909 -> 7880;
7909 -> 7902;
7909 -> 0;
7909 -> 7881;
7910 -> 7880;
7911 -> 7880;
7911 -> 7910;
7911 -> 7902;
7911 -> 7795;
7912 -> 7855;
7912 -> 7795;
7913 -> 7795;
7914 -> 7912;
7914 -> 7913;
7915 -> 7913;
7916 -> 7913;
7917 -> 7914;
7917 -> 7916;
7917 -> 7913;
7918 -> 7917;
7919 -> 7918;
7919 -> 7914;
7919 -> 7911;
7919 -> 7917;
7920 -> 7914;
7920 -> 7918;
7920 -> 7911;
7920 -> 7919;
7921 -> 7915;
7921 -> 7920;
7921 -> 7919;
7922 -> 7921;
7922 -> 7913;
7923 -> 7795;
7924 -> 7922;
7924 -> 7923;
7925 -> 7795;
7925 -> 7923;
7926 -> 7923;
7927 -> 7925;
7927 -> 7920;
7927 -> 7926;
7927 -> 7923;
7928 -> 7927;
7929 -> 7795;
7930 -> 7920;
7930 -> 7819;
7930 -> 7795;
7931 -> 7795;
7931 -> 7920;
7931 -> 7930;
7932 -> 7930;
7933 -> 7931;
7933 -> 7932;
7934 -> 7933;
7934 -> 7931;
7934 -> 7932;
7935 -> 7920;
7935 -> 7930;
7936 -> 7930;
7937 -> 7934;
7937 -> 7936;
7938 -> 7935;
7938 -> 7936;
7939 -> 7795;
7939 -> 7936;
7940 -> 7936;
7941 -> 7939;
7941 -> 7940;
7942 -> 7940;
7943 -> 7941;
7943 -> 7934;
7943 -> 7942;
7943 -> 7940;
7944 -> 7943;
7944 -> 7936;
7945 -> 7936;
7946 -> 7938;
7946 -> 7945;
7946 -> 7936;
7947 -> 7937;
7948 -> 7937;
7949 -> 7911;
7949 -> 7795;
7950 -> 7928;
7950 -> 7795;
7951 -> 7795;
7952 -> 7949;
7952 -> 7911;
7952 -> 0;
7952 -> 7795;
7953 -> 7795;
7954 -> 7949;
7954 -> 7911;
7954 -> 7795;
7955 -> 7949;
7955 -> 7911;
7955 -> 7954;
7956 -> 7949;
7956 -> 7911;
7956 -> 7955;
7957 -> 7955;
7958 -> 7956;
7958 -> 7957;
7959 -> 7958;
7959 -> 0;
7959 -> 7957;
7960 -> 7937;
7960 -> 7955;
7961 -> 7949;
7961 -> 7911;
7961 -> 7955;
7962 -> 7955;
7963 -> 7960;
7963 -> 7962;
7964 -> 7961;
7964 -> 7962;
7965 -> 7960;
7965 -> 7962;
7966 -> 7964;
7966 -> 7962;
7967 -> 7963;
7967 -> 7962;
7968 -> 7965;
7968 -> 7962;
7969 -> 7962;
7970 -> 7966;
7970 -> 7969;
7971 -> 7967;
7971 -> 7969;
7972 -> 7968;
7972 -> 7969;
7973 -> 7970;
7973 -> 3999;
7973 -> 7969;
7974 -> 7969;
7975 -> 7971;
7975 -> 7974;
7975 -> 7969;
7976 -> 7971;
7976 -> 3458;
7976 -> 7969;
7977 -> 7970;
7977 -> 7969;
7978 -> 7971;
7978 -> 7969;
7979 -> 7972;
7979 -> 7969;
7980 -> 7969;
7981 -> 7969;
7982 -> 7977;
7982 -> 7981;
7983 -> 7978;
7983 -> 7981;
7984 -> 7979;
7984 -> 7981;
7985 -> 7980;
7985 -> 7981;
7986 -> 7981;
7987 -> 7983;
7987 -> 7986;
7987 -> 7981;
7988 -> 7983;
7988 -> 7987;
7989 -> 7985;
7989 -> 7988;
7989 -> 7982;
7989 -> 7937;
7989 -> 7987;
7990 -> 7983;
7990 -> 7985;
7990 -> 7987;
7991 -> 7985;
7991 -> 7984;
7991 -> 7989;
7991 -> 7990;
7992 -> 7980;
7992 -> 7962;
7993 -> 7992;
7993 -> 7955;
7994 -> 7795;
7995 -> 7950;
7995 -> 7994;
7995 -> 7795;
7996 -> 7993;
7996 -> 7795;
7997 -> 7996;
7997 -> 7789;
7998 -> 7789;
7999 -> 7997;
7999 -> 7998;
8000 -> 7783;
8000 -> 7998;
8001 -> 7998;
8002 -> 7999;
8002 -> 8001;
8002 -> 7998;
8003 -> 8000;
8003 -> 7754;
8003 -> 7791;
8003 -> 7790;
8003 -> 7998;
8004 -> 8000;
8004 -> 7791;
8004 -> 7790;
8004 -> 7754;
8004 -> 7998;
8005 -> 7999;
8005 -> 8004;
8005 -> 7998;
8006 -> 8000;
8006 -> 7754;
8006 -> 7998;
8007 -> 7789;
8008 -> 7789;
8009 -> 7996;
8009 -> 8008;
8010 -> 8009;
8010 -> 7991;
8010 -> 8008;
8011 -> 8010;
8011 -> 7789;
8012 -> 7991;
8013 -> 7991;
8014 -> 8013;
8014 -> 7991;
8015 -> 7991;
8016 -> 7991;
8017 -> 7991;
8018 -> 7991;
8019 -> 7991;
8020 -> 7991;
8021 -> 8015;
8021 -> 7991;
8022 -> 8016;
8022 -> 7991;
8023 -> 8017;
8023 -> 7991;
8024 -> 8018;
8024 -> 7991;
8025 -> 8020;
8025 -> 8014;
8025 -> 8021;
8025 -> 8022;
8025 -> 8023;
8025 -> 8024;
8025 -> 7991;
8026 -> 7991;
8027 -> 8025;
8027 -> 8026;
8027 -> 7991;
8028 -> 8019;
8028 -> 8025;
8028 -> 8027;
8029 -> 8027;
8030 -> 8028;
8030 -> 8029;
8031 -> 8029;
8032 -> 8030;
8032 -> 8028;
8032 -> 8031;
8033 -> 8032;
8033 -> 8029;
8034 -> 8029;
8035 -> 8030;
8035 -> 8028;
8035 -> 8034;
8036 -> 8035;
8036 -> 8029;
8037 -> 8029;
8038 -> 8036;
8038 -> 8037;
8039 -> 8030;
8039 -> 8028;
8039 -> 8037;
8040 -> 8029;
8041 -> 8029;
8042 -> 8030;
8042 -> 8041;
8043 -> 8042;
8043 -> 8028;
8043 -> 8038;
8043 -> 8041;
8044 -> 8041;
8045 -> 8042;
8045 -> 8043;
8045 -> 8044;
8046 -> 8045;
8046 -> 8041;
8047 -> 8041;
8048 -> 8047;
8048 -> 8041;
8049 -> 8041;
8050 -> 8041;
8051 -> 8043;
8052 -> 8043;
8053 -> 8041;
8054 -> 8043;
8055 -> 8043;
8055 -> 3663;
8056 -> 0;
8056 -> 8043;
8057 -> 8043;
8058 -> 8057;
8058 -> 8043;
8059 -> 0;
8059 -> 8058;
8060 -> 8043;
8060 -> 8059;
8060 -> 8056;
8061 -> 8060;
8061 -> 0;
8061 -> 8043;
8062 -> 0;
8062 -> 8043;
8062 -> 8061;
8063 -> 0;
8063 -> 8043;
8063 -> 8061;
8064 -> 8043;
8064 -> 8060;
8064 -> 8062;
8064 -> 0;
8065 -> 8043;
8065 -> 8060;
8065 -> 8062;
8065 -> 8063;
8065 -> 8041;
8066 -> 8041;
8067 -> 8066;
8067 -> 8041;
8068 -> 8041;
8069 -> 8067;
8069 -> 8068;
8070 -> 8042;
8070 -> 8068;
8071 -> 8068;
8072 -> 8070;
8072 -> 8065;
8072 -> 8071;
8072 -> 8068;
8073 -> 8072;
8074 -> 8041;
8075 -> 8065;
8076 -> 8065;
8077 -> 8065;
8078 -> 8065;
8079 -> 8042;
8079 -> 8065;
8080 -> 8065;
8081 -> 8079;
8081 -> 8080;
8082 -> 8080;
8083 -> 8081;
8083 -> 8065;
8083 -> 8042;
8083 -> 8082;
8083 -> 8080;
8084 -> 8083;
8084 -> 8065;
8085 -> 8065;
8086 -> 8047;
8086 -> 8065;
8087 -> 8086;
8088 -> 8073;
8088 -> 8041;
8089 -> 8042;
8089 -> 8041;
8090 -> 8065;
8090 -> 0;
8090 -> 8041;
8091 -> 8041;
8092 -> 8065;
8092 -> 8091;
8092 -> 8041;
8093 -> 8041;
8094 -> 8065;
8095 -> 8065;
8096 -> 8094;
8096 -> 8095;
8097 -> 8094;
8097 -> 8095;
8098 -> 8094;
8098 -> 8095;
8099 -> 8094;
8099 -> 8095;
8100 -> 8094;
8100 -> 8095;
8101 -> 8096;
8101 -> 8095;
8102 -> 8097;
8102 -> 8095;
8103 -> 8098;
8103 -> 8095;
8104 -> 8099;
8104 -> 8095;
8105 -> 8100;
8105 -> 8095;
8106 -> 8095;
8107 -> 8101;
8107 -> 8106;
8108 -> 8102;
8108 -> 8106;
8109 -> 8103;
8109 -> 8106;
8110 -> 8104;
8110 -> 8106;
8111 -> 8105;
8111 -> 8106;
8112 -> 8107;
8112 -> 0;
8112 -> 8106;
8113 -> 8110;
8113 -> 8109;
8113 -> 8106;
8114 -> 8112;
8114 -> 8113;
8114 -> 8106;
8115 -> 8108;
8115 -> 8114;
8116 -> 8109;
8116 -> 8114;
8117 -> 8111;
8117 -> 8114;
8118 -> 8114;
8119 -> 8115;
8119 -> 8118;
8120 -> 8116;
8120 -> 8118;
8121 -> 8117;
8121 -> 8118;
8122 -> 8118;
8123 -> 8119;
8123 -> 8122;
8123 -> 8118;
8124 -> 8123;
8125 -> 8121;
8125 -> 8124;
8125 -> 8123;
8127 -> 8120;
8127 -> 8125;
8128 -> 8121;
8128 -> 8125;
8129 -> 8125;
8130 -> 8125;
8131 -> 8127;
8131 -> 8130;
8132 -> 8128;
8132 -> 8130;
8133 -> 8129;
8133 -> 8130;
8135 -> 8131;
8135 -> 8130;
8136 -> 8130;
8137 -> 8135;
8137 -> 8136;
8138 -> 8133;
8138 -> 8136;
8139 -> 0;
8139 -> 8136;
8140 -> 8137;
8140 -> 8136;
8141 -> 8136;
8142 -> 8139;
8142 -> 8141;
8143 -> 8140;
8143 -> 8141;
8144 -> 8138;
8144 -> 8141;
8145 -> 8142;
8145 -> 8141;
8146 -> 8143;
8146 -> 8141;
8147 -> 8141;
8148 -> 8145;
8148 -> 8147;
8149 -> 8146;
8149 -> 8147;
8150 -> 8144;
8150 -> 8147;
8151 -> 8148;
8151 -> 8147;
8152 -> 8149;
8152 -> 8147;
8153 -> 8147;
8154 -> 8153;
8154 -> 8151;
8154 -> 8152;
8154 -> 8147;
8155 -> 8153;
8155 -> 8147;
8156 -> 8155;
8156 -> 8154;
8156 -> 8147;
8157 -> 8144;
8157 -> 8156;
8157 -> 0;
8157 -> 8141;
8158 -> 8157;
8158 -> 8144;
8158 -> 8141;
8159 -> 8138;
8159 -> 8136;
8160 -> 8137;
8160 -> 8138;
8160 -> 8136;
8161 -> 8133;
8161 -> 8130;
8162 -> 8130;
8163 -> 8132;
8163 -> 8162;
8163 -> 8130;
8164 -> 8132;
8164 -> 8163;
8165 -> 8133;
8165 -> 8164;
8165 -> 8156;
8165 -> 8158;
8165 -> 8159;
8165 -> 8160;
8165 -> 8161;
8165 -> 8065;
8165 -> 8163;
8166 -> 8132;
8166 -> 8133;
8166 -> 8163;
8167 -> 8041;
8168 -> 8088;
8168 -> 8167;
8168 -> 8041;
8169 -> 8129;
8169 -> 8041;
8170 -> 8169;
8170 -> 8029;
8171 -> 8033;
8171 -> 8170;
8171 -> 8165;
8171 -> 8029;
8172 -> 8170;
8172 -> 8029;
8173 -> 8028;
8173 -> 8172;
8173 -> 8165;
8173 -> 8166;
8173 -> 8027;
8174 -> 8015;
8174 -> 8027;
8175 -> 8016;
8175 -> 8027;
8176 -> 8017;
8176 -> 8027;
8177 -> 8018;
8177 -> 8027;
8178 -> 8173;
8178 -> 8027;
8179 -> 8173;
8179 -> 7991;
8180 -> 7991;
8180 -> 8179;
8180 -> 8178;
8181 -> 8180;
8181 -> 7789;
8182 -> 8181;
8182 -> 7998;
8183 -> 8182;
8183 -> 8001;
8183 -> 7998;
8184 -> 8000;
8184 -> 8006;
8184 -> 7791;
8184 -> 7790;
8184 -> 7998;
8185 -> 8000;
8185 -> 7791;
8185 -> 7790;
8185 -> 8006;
8185 -> 7998;
8186 -> 8182;
8186 -> 8185;
8186 -> 7998;
8187 -> 8180;
8187 -> 8008;
8188 -> 8187;
8188 -> 7789;
8189 -> 8180;
8190 -> 8180;
8191 -> 8190;
8191 -> 8180;
8192 -> 8180;
8193 -> 8192;
8193 -> 8180;
8194 -> 8192;
8194 -> 8180;
8195 -> 8194;
8195 -> 8180;
8196 -> 8180;
8197 -> 8180;
8198 -> 8180;
8199 -> 8180;
8200 -> 8180;
8201 -> 8200;
8201 -> 8180;
8202 -> 8180;
8203 -> 8201;
8203 -> 8202;
8204 -> 8180;
8204 -> 8202;
8205 -> 8202;
8206 -> 8204;
8206 -> 8192;
8206 -> 8205;
8206 -> 8202;
8207 -> 8206;
8208 -> 8180;
8209 -> 8180;
8210 -> 8209;
8210 -> 8180;
8211 -> 8192;
8212 -> 8192;
8213 -> 8192;
8214 -> 8192;
8215 -> 8180;
8215 -> 8192;
8216 -> 8192;
8217 -> 8215;
8217 -> 8216;
8218 -> 8216;
8219 -> 8217;
8219 -> 8192;
8219 -> 8180;
8219 -> 8218;
8219 -> 8216;
8220 -> 8219;
8220 -> 8192;
8221 -> 8192;
8222 -> 8209;
8222 -> 8192;
8223 -> 8222;
8224 -> 8207;
8224 -> 8180;
8225 -> 8180;
8226 -> 8192;
8226 -> 0;
8226 -> 8180;
8227 -> 8180;
8228 -> 8192;
8229 -> 8192;
8230 -> 8228;
8230 -> 8229;
8231 -> 8230;
8231 -> 0;
8231 -> 8229;
8232 -> 8192;
8232 -> 3999;
8233 -> 8192;
8234 -> 8233;
8235 -> 8192;
8235 -> 3037;
8235 -> 8234;
8236 -> 8192;
8236 -> 2896;
8236 -> 8235;
8237 -> 4015;
8237 -> 4014;
8237 -> 8192;
8237 -> 8236;
8238 -> 8180;
8239 -> 8224;
8239 -> 8238;
8239 -> 8180;
8240 -> 8191;
8240 -> 8237;
8240 -> 8180;
8241 -> 8237;
8241 -> 7789;
8242 -> 8241;
8242 -> 7998;
8243 -> 8242;
8243 -> 8001;
8243 -> 7998;
8244 -> 8242;
8244 -> 8185;
8244 -> 7998;
8245 -> 8237;
8245 -> 8008;
8246 -> 8245;
8246 -> 7789;
8247 -> 8237;
8248 -> 8237;
8249 -> 8248;
8249 -> 8237;
8250 -> 8237;
8251 -> 8237;
8252 -> 8251;
8252 -> 8237;
8253 -> 8237;
8254 -> 8237;
8254 -> 8248;
8255 -> 8237;
8255 -> 8248;
8256 -> 8237;
8256 -> 8248;
8257 -> 8237;
8257 -> 8248;
8258 -> 8237;
8258 -> 8248;
8259 -> 8237;
8259 -> 8248;
8260 -> 8254;
8260 -> 8248;
8261 -> 8255;
8261 -> 8248;
8262 -> 8256;
8262 -> 8248;
8263 -> 8257;
8263 -> 8248;
8264 -> 8259;
8264 -> 8248;
8264 -> 8260;
8264 -> 8261;
8264 -> 8262;
8264 -> 8263;
8265 -> 8248;
8266 -> 8264;
8266 -> 8265;
8266 -> 8248;
8267 -> 8258;
8267 -> 8264;
8267 -> 8266;
8268 -> 8266;
8269 -> 8267;
8269 -> 8268;
8270 -> 8268;
8271 -> 8268;
8272 -> 8270;
8272 -> 8271;
8273 -> 8269;
8273 -> 8267;
8273 -> 8271;
8274 -> 8271;
8275 -> 8273;
8275 -> 8274;
8276 -> 8275;
8276 -> 8271;
8277 -> 8271;
8278 -> 8273;
8278 -> 8277;
8279 -> 8278;
8279 -> 8271;
8280 -> 8272;
8280 -> 8271;
8281 -> 8271;
8282 -> 8276;
8282 -> 8281;
8283 -> 8279;
8283 -> 8281;
8284 -> 8280;
8284 -> 8281;
8285 -> 8273;
8285 -> 8281;
8286 -> 8282;
8286 -> 8285;
8286 -> 8267;
8286 -> 8281;
8287 -> 8283;
8287 -> 8281;
8288 -> 8285;
8288 -> 8267;
8288 -> 8286;
8288 -> 8287;
8289 -> 8287;
8290 -> 8288;
8290 -> 8289;
8290 -> 8287;
8291 -> 8287;
8292 -> 8288;
8292 -> 8291;
8292 -> 8287;
8293 -> 8284;
8293 -> 8281;
8294 -> 8285;
8294 -> 8267;
8294 -> 8293;
8295 -> 8286;
8295 -> 8293;
8296 -> 8283;
8296 -> 8293;
8297 -> 8293;
8298 -> 8294;
8298 -> 8297;
8299 -> 8295;
8299 -> 8297;
8300 -> 8296;
8300 -> 8297;
8301 -> 8285;
8301 -> 8297;
8302 -> 8301;
8302 -> 8267;
8302 -> 8298;
8302 -> 8299;
8302 -> 8300;
8302 -> 8297;
8303 -> 8268;
8304 -> 8302;
8304 -> 8303;
8305 -> 8270;
8305 -> 8303;
8306 -> 8303;
8306 -> 0;
8307 -> 8254;
8307 -> 8266;
8308 -> 8255;
8308 -> 8266;
8309 -> 8256;
8309 -> 8266;
8310 -> 8257;
8310 -> 8266;
8311 -> 8304;
8311 -> 8266;
8312 -> 8304;
8312 -> 8248;
8313 -> 8237;
8313 -> 8312;
8313 -> 8311;
8314 -> 8237;
8315 -> 8237;
8316 -> 8314;
8316 -> 8315;
8317 -> 8315;
8318 -> 8316;
8318 -> 8313;
8318 -> 8317;
8318 -> 8315;
8319 -> 8318;
8319 -> 8237;
8320 -> 8237;
8321 -> 8248;
8321 -> 8320;
8321 -> 8237;
8322 -> 8313;
8323 -> 8313;
8324 -> 8237;
8325 -> 8313;
8326 -> 8313;
8326 -> 3663;
8327 -> 0;
8327 -> 8313;
8328 -> 8313;
8328 -> 8327;
8329 -> 8327;
8330 -> 8328;
8330 -> 8329;
8331 -> 8330;
8331 -> 8329;
8332 -> 8331;
8333 -> 8313;
8333 -> 8327;
8333 -> 0;
8334 -> 8237;
8335 -> 8334;
8335 -> 8327;
8336 -> 8335;
8336 -> 8237;
8337 -> 8237;
8338 -> 8336;
8338 -> 8337;
8339 -> 8237;
8339 -> 8337;
8340 -> 8337;
8341 -> 8339;
8341 -> 8327;
8341 -> 8340;
8341 -> 8337;
8342 -> 8341;
8343 -> 8237;
8343 -> 8327;
8344 -> 8327;
8345 -> 8343;
8345 -> 8344;
8346 -> 8344;
8347 -> 8345;
8347 -> 8327;
8347 -> 8346;
8347 -> 8344;
8348 -> 8347;
8348 -> 8327;
8349 -> 8327;
8350 -> 8327;
8351 -> 8327;
8352 -> 8342;
8352 -> 8237;
8353 -> 8237;
8354 -> 8327;
8354 -> 0;
8354 -> 8237;
8355 -> 8237;
8356 -> 8327;
8357 -> 8327;
8358 -> 8356;
8358 -> 8357;
8359 -> 8358;
8359 -> 0;
8359 -> 8357;
8360 -> 8327;
8360 -> 3999;
8361 -> 8327;
8361 -> 3458;
8362 -> 8237;
8363 -> 8352;
8363 -> 8362;
8363 -> 8237;
8364 -> 8249;
8364 -> 8327;
8364 -> 8237;
8365 -> 8327;
8365 -> 7789;
8366 -> 8365;
8366 -> 7998;
8367 -> 8366;
8367 -> 8001;
8367 -> 7998;
8368 -> 8366;
8368 -> 8185;
8368 -> 7998;
8369 -> 8327;
8369 -> 8008;
8370 -> 8369;
8370 -> 7789;
8371 -> 8327;
8372 -> 8327;
8373 -> 8327;
8374 -> 8327;
8375 -> 8374;
8375 -> 8327;
8376 -> 8327;
8377 -> 8327;
8378 -> 8327;
8379 -> 8327;
8379 -> 3663;
8380 -> 8327;
8380 -> 0;
8381 -> 8327;
8382 -> 8381;
8382 -> 8327;
8383 -> 8327;
8384 -> 8382;
8384 -> 8383;
8385 -> 8327;
8385 -> 8383;
8386 -> 8383;
8387 -> 8385;
8387 -> 8327;
8387 -> 8386;
8387 -> 8383;
8388 -> 8387;
8389 -> 8327;
8390 -> 8389;
8390 -> 8344;
8391 -> 8390;
8391 -> 8327;
8391 -> 8346;
8391 -> 8344;
8392 -> 8391;
8392 -> 8327;
8393 -> 8388;
8393 -> 8327;
8394 -> 8327;
8395 -> 8327;
8395 -> 0;
8396 -> 8327;
8397 -> 8327;
8398 -> 8327;
8399 -> 8393;
8399 -> 8398;
8399 -> 8327;
8400 -> 8372;
8400 -> 8327;
8401 -> 4011;
8401 -> 4010;
8401 -> 8327;
8402 -> 8372;
8402 -> 8401;
8402 -> 8327;
8403 -> 8401;
8403 -> 7789;
8404 -> 8403;
8404 -> 7998;
8405 -> 8404;
8405 -> 8001;
8405 -> 7998;
8406 -> 8404;
8406 -> 8185;
8406 -> 7998;
8407 -> 8401;
8407 -> 8008;
8408 -> 8407;
8408 -> 7789;
8409 -> 8401;
8410 -> 8401;
8411 -> 8401;
8412 -> 8401;
8413 -> 8412;
8413 -> 8401;
8414 -> 8401;
8415 -> 8401;
8416 -> 8401;
8417 -> 8401;
8418 -> 8401;
8419 -> 8418;
8419 -> 8401;
8420 -> 8401;
8421 -> 8419;
8421 -> 8420;
8422 -> 8401;
8422 -> 8420;
8423 -> 8420;
8424 -> 8422;
8424 -> 8401;
8424 -> 8423;
8424 -> 8420;
8425 -> 8424;
8426 -> 8401;
8427 -> 8401;
8428 -> 8401;
8429 -> 8401;
8430 -> 8401;
8431 -> 8429;
8431 -> 8430;
8432 -> 8430;
8433 -> 8431;
8433 -> 8401;
8433 -> 8432;
8433 -> 8430;
8434 -> 8433;
8434 -> 8401;
8435 -> 8401;
8436 -> 8412;
8436 -> 8401;
8437 -> 8436;
8438 -> 8425;
8438 -> 8401;
8439 -> 8401;
8440 -> 8401;
8440 -> 0;
8441 -> 8401;
8442 -> 8401;
8443 -> 8401;
8444 -> 8442;
8444 -> 8443;
8445 -> 8444;
8445 -> 0;
8445 -> 8443;
8446 -> 8401;
8446 -> 3999;
8447 -> 8401;
8448 -> 8438;
8448 -> 8447;
8448 -> 8401;
8449 -> 8410;
8449 -> 8401;
8450 -> 8401;
8451 -> 8401;
8451 -> 3663;
8452 -> 8401;
8452 -> 0;
8453 -> 8401;
8454 -> 8401;
8455 -> 8401;
8456 -> 8454;
8456 -> 8455;
8457 -> 8456;
8457 -> 8455;
8458 -> 8455;
8459 -> 8455;
8460 -> 8457;
8460 -> 8459;
8461 -> 8458;
8461 -> 8459;
8462 -> 8458;
8462 -> 8401;
8463 -> 8410;
8463 -> 8462;
8463 -> 8460;
8463 -> 8401;
8464 -> 8460;
8464 -> 7789;
8465 -> 8464;
8465 -> 7998;
8466 -> 8465;
8466 -> 8001;
8466 -> 7998;
8467 -> 8465;
8467 -> 8185;
8467 -> 7998;
8468 -> 8460;
8468 -> 8008;
8469 -> 8468;
8469 -> 7789;
8470 -> 8460;
8471 -> 8460;
8472 -> 8460;
8473 -> 8460;
8474 -> 8473;
8474 -> 8460;
8475 -> 8460;
8476 -> 8460;
8477 -> 8460;
8478 -> 8460;
8479 -> 8460;
8480 -> 8479;
8480 -> 8460;
8481 -> 8460;
8482 -> 8480;
8482 -> 8481;
8483 -> 8460;
8483 -> 8481;
8484 -> 8481;
8485 -> 8483;
8485 -> 8460;
8485 -> 8484;
8485 -> 8481;
8486 -> 8485;
8487 -> 8486;
8487 -> 8460;
8488 -> 8460;
8489 -> 8460;
8489 -> 0;
8490 -> 8460;
8491 -> 8460;
8492 -> 8460;
8493 -> 8491;
8493 -> 8492;
8494 -> 8493;
8494 -> 0;
8494 -> 8492;
8495 -> 8460;
8495 -> 3999;
8496 -> 4003;
8496 -> 4002;
8496 -> 8460;
8497 -> 8460;
8498 -> 8487;
8498 -> 8497;
8498 -> 8460;
8499 -> 8471;
8499 -> 8496;
8499 -> 8460;
8500 -> 8496;
8500 -> 7789;
8501 -> 8500;
8501 -> 7998;
8502 -> 8501;
8502 -> 8001;
8502 -> 7998;
8503 -> 8501;
8503 -> 8185;
8503 -> 7998;
8504 -> 8496;
8504 -> 8008;
8505 -> 8504;
8505 -> 7789;
8506 -> 8496;
8507 -> 8496;
8508 -> 8496;
8509 -> 8496;
8510 -> 8509;
8510 -> 8496;
8511 -> 8496;
8512 -> 8496;
8513 -> 8496;
8514 -> 8496;
8515 -> 8496;
8516 -> 8515;
8516 -> 8496;
8517 -> 8496;
8518 -> 8516;
8518 -> 8517;
8519 -> 8496;
8519 -> 8517;
8520 -> 8517;
8521 -> 8519;
8521 -> 8496;
8521 -> 8520;
8521 -> 8517;
8522 -> 8521;
8523 -> 8496;
8524 -> 8496;
8525 -> 8523;
8525 -> 8524;
8526 -> 8524;
8527 -> 8525;
8527 -> 8496;
8527 -> 8526;
8527 -> 8524;
8528 -> 8527;
8528 -> 8496;
8529 -> 8496;
8530 -> 8522;
8530 -> 8496;
8531 -> 8496;
8532 -> 8496;
8532 -> 0;
8533 -> 8496;
8534 -> 8496;
8535 -> 8496;
8536 -> 8534;
8536 -> 8535;
8537 -> 8536;
8537 -> 0;
8537 -> 8535;
8538 -> 8496;
8538 -> 3999;
8539 -> 8496;
8540 -> 8530;
8540 -> 8539;
8540 -> 8496;
8541 -> 8507;
8541 -> 8496;
8542 -> 8496;
8543 -> 8496;
8544 -> 8496;
8545 -> 8509;
8545 -> 8496;
8546 -> 8545;
8547 -> 8496;
8547 -> 8512;
8548 -> 8512;
8549 -> 8547;
8549 -> 8548;
8550 -> 8548;
8551 -> 8549;
8551 -> 8550;
8551 -> 8548;
8552 -> 8549;
8552 -> 8548;
8553 -> 8496;
8553 -> 8551;
8554 -> 8551;
8555 -> 8553;
8555 -> 8554;
8556 -> 8554;
8557 -> 8555;
8557 -> 8556;
8557 -> 8554;
8558 -> 8496;
8559 -> 8496;
8560 -> 8496;
8561 -> 8559;
8561 -> 8560;
8562 -> 8559;
8562 -> 8560;
8563 -> 8559;
8563 -> 8560;
8564 -> 8562;
8564 -> 3999;
8564 -> 8560;
8565 -> 8562;
8565 -> 7789;
8566 -> 8565;
8566 -> 7998;
8567 -> 8566;
8567 -> 8001;
8567 -> 7998;
8568 -> 8566;
8568 -> 8185;
8568 -> 7998;
8569 -> 8562;
8569 -> 8008;
8570 -> 8569;
8570 -> 7789;
8571 -> 7781;
8572 -> 7722;
8573 -> 8572;
8573 -> 7728;
8573 -> 7722;
8574 -> 7728;
8574 -> 7722;
8575 -> 7728;
8575 -> 7722;
8576 -> 7728;
8576 -> 7722;
8577 -> 7728;
8577 -> 7722;
8578 -> 7728;
8578 -> 7722;
8579 -> 7728;
8579 -> 7722;
8580 -> 7722;
8581 -> 8580;
8581 -> 7728;
8581 -> 7722;
8582 -> 7728;
8582 -> 8581;
8582 -> 7722;
8583 -> 7722;
8584 -> 8583;
8584 -> 7728;
8584 -> 7722;
8585 -> 7630;
8586 -> 7720;
8586 -> 8585;
8587 -> 8586;
8587 -> 8585;
8588 -> 0;
8588 -> 8585;
8589 -> 8585;
8590 -> 8587;
8590 -> 8589;
8591 -> 8588;
8591 -> 8589;
8592 -> 8586;
8592 -> 8589;
8593 -> 8589;
8594 -> 8592;
8594 -> 8576;
8594 -> 8593;
8594 -> 8589;
8595 -> 8590;
8595 -> 8589;
8596 -> 8589;
8597 -> 8595;
8597 -> 8596;
8598 -> 8596;
8599 -> 8596;
8600 -> 8597;
8600 -> 8595;
8600 -> 8596;
8601 -> 8596;
8602 -> 8596;
8603 -> 8600;
8603 -> 8602;
8604 -> 8601;
8604 -> 8602;
8605 -> 8603;
8605 -> 8595;
8605 -> 8602;
8606 -> 8605;
8606 -> 8604;
8606 -> 8602;
8607 -> 8603;
8607 -> 8605;
8607 -> 8602;
8608 -> 8607;
8608 -> 8604;
8608 -> 8602;
8609 -> 8603;
8609 -> 8607;
8609 -> 8602;
8610 -> 8609;
8610 -> 8604;
8610 -> 8602;
8611 -> 8603;
8611 -> 8609;
8611 -> 8602;
8612 -> 8611;
8612 -> 8604;
8612 -> 8602;
8613 -> 8598;
8613 -> 8596;
8614 -> 8601;
8614 -> 8596;
8615 -> 8599;
8615 -> 8596;
8616 -> 0;
8616 -> 8596;
8617 -> 8613;
8617 -> 8614;
8617 -> 8615;
8617 -> 8616;
8617 -> 8597;
8617 -> 8611;
8617 -> 8605;
8617 -> 8607;
8617 -> 8609;
8617 -> 8606;
8617 -> 8608;
8617 -> 8610;
8617 -> 8612;
8617 -> 8596;
8618 -> 8596;
8619 -> 8617;
8619 -> 8618;
8620 -> 8619;
8620 -> 8617;
8620 -> 8618;
8621 -> 8617;
8621 -> 8618;
8622 -> 8618;
8623 -> 8621;
8623 -> 8622;
8624 -> 8623;
8624 -> 8620;
8624 -> 8622;
8625 -> 8622;
8626 -> 8623;
8626 -> 8620;
8626 -> 8625;
8626 -> 8622;
8627 -> 8623;
8627 -> 8620;
8627 -> 8626;
8628 -> 8627;
8628 -> 8618;
8629 -> 8628;
8629 -> 8621;
8629 -> 8618;
8630 -> 8617;
8630 -> 8618;
8631 -> 8630;
8631 -> 8629;
8631 -> 8618;
8632 -> 8617;
8632 -> 8618;
8633 -> 8617;
8633 -> 8618;
8634 -> 8618;
8635 -> 8632;
8635 -> 8631;
8635 -> 8634;
8635 -> 8618;
8636 -> 8633;
8636 -> 8618;
8637 -> 8633;
8637 -> 8618;
8638 -> 8633;
8638 -> 8618;
8639 -> 8638;
8639 -> 8631;
8639 -> 8618;
8640 -> 8638;
8640 -> 8631;
8640 -> 8639;
8640 -> 8618;
8641 -> 8636;
8641 -> 8618;
8642 -> 8637;
8642 -> 8618;
8643 -> 8618;
8644 -> 8641;
8644 -> 8643;
8645 -> 8642;
8645 -> 8643;
8646 -> 8638;
8646 -> 8643;
8647 -> 8643;
8648 -> 8646;
8648 -> 8647;
8649 -> 8648;
8649 -> 8631;
8649 -> 8647;
8650 -> 8649;
8650 -> 8643;
8651 -> 8643;
8652 -> 8650;
8652 -> 8651;
8653 -> 0;
8653 -> 8643;
8654 -> 8643;
8655 -> 8653;
8655 -> 8654;
8656 -> 8646;
8656 -> 8654;
8657 -> 8655;
8657 -> 8654;
8658 -> 8654;
8659 -> 8657;
8659 -> 8658;
8660 -> 8659;
8660 -> 0;
8660 -> 8658;
8661 -> 8660;
8662 -> 8654;
8663 -> 8656;
8663 -> 8662;
8664 -> 8663;
8664 -> 8631;
8664 -> 8662;
8665 -> 8664;
8665 -> 8654;
8666 -> 8654;
8667 -> 8665;
8667 -> 8666;
8668 -> 8667;
8668 -> 8654;
8669 -> 8668;
8669 -> 8655;
8669 -> 8654;
8670 -> 8669;
8671 -> 8656;
8671 -> 8670;
8672 -> 8670;
8673 -> 8671;
8673 -> 8631;
8673 -> 8672;
8674 -> 8673;
8674 -> 8631;
8674 -> 8672;
8675 -> 8674;
8675 -> 8670;
8676 -> 8675;
8676 -> 8671;
8676 -> 8670;
8677 -> 8670;
8678 -> 8677;
8678 -> 8671;
8678 -> 8670;
8679 -> 8670;
8680 -> 8671;
8680 -> 8631;
8680 -> 8679;
8680 -> 8670;
8681 -> 8671;
8681 -> 8631;
8681 -> 8670;
8682 -> 8669;
8683 -> 8665;
8683 -> 8669;
8684 -> 8643;
8685 -> 8646;
8685 -> 8684;
8686 -> 8684;
8687 -> 8685;
8687 -> 8686;
8688 -> 8686;
8689 -> 8687;
8689 -> 8631;
8689 -> 8688;
8690 -> 8689;
8690 -> 8631;
8690 -> 8688;
8691 -> 8690;
8691 -> 8686;
8692 -> 8691;
8692 -> 8684;
8693 -> 8692;
8693 -> 8643;
8694 -> 8643;
8695 -> 8643;
8696 -> 8694;
8696 -> 8695;
8697 -> 8646;
8697 -> 8695;
8698 -> 8696;
8698 -> 8695;
8699 -> 8695;
8700 -> 8698;
8700 -> 8699;
8701 -> 8697;
8701 -> 8699;
8702 -> 8700;
8702 -> 8699;
8703 -> 8699;
8704 -> 8702;
8704 -> 8703;
8705 -> 8701;
8705 -> 8703;
8706 -> 8703;
8707 -> 8703;
8708 -> 8706;
8708 -> 8707;
8709 -> 8705;
8709 -> 8707;
8710 -> 8707;
8711 -> 8709;
8711 -> 8710;
8712 -> 8710;
8713 -> 8711;
8713 -> 8712;
8714 -> 8713;
8714 -> 8631;
8714 -> 8712;
8715 -> 8714;
8715 -> 8710;
8716 -> 8715;
8717 -> 8716;
8717 -> 8707;
8718 -> 8708;
8718 -> 8707;
8719 -> 8707;
8720 -> 8718;
8720 -> 8719;
8721 -> 8709;
8721 -> 8719;
8722 -> 8719;
8723 -> 8721;
8723 -> 8722;
8724 -> 8722;
8725 -> 8723;
8725 -> 8724;
8726 -> 8725;
8726 -> 8631;
8726 -> 8681;
8726 -> 8724;
8727 -> 8724;
8728 -> 8725;
8728 -> 8631;
8728 -> 8727;
8728 -> 8724;
8729 -> 8725;
8729 -> 8631;
8729 -> 8639;
8729 -> 8676;
8729 -> 8678;
8729 -> 8681;
8729 -> 8728;
8730 -> 8729;
8730 -> 8719;
8731 -> 8719;
8732 -> 8730;
8732 -> 8731;
8733 -> 8732;
8733 -> 0;
8733 -> 8719;
8734 -> 8733;
8735 -> 8721;
8735 -> 8734;
8736 -> 8734;
8737 -> 8735;
8737 -> 8736;
8738 -> 8737;
8738 -> 8734;
8739 -> 8734;
8740 -> 8738;
8740 -> 8739;
8741 -> 8739;
8742 -> 8740;
8742 -> 8741;
8743 -> 8742;
8743 -> 8739;
8744 -> 8734;
8745 -> 8744;
8745 -> 8733;
8746 -> 8733;
8747 -> 8721;
8747 -> 8746;
8748 -> 8746;
8749 -> 8747;
8749 -> 8748;
8750 -> 8749;
8750 -> 8631;
8750 -> 8639;
8750 -> 8676;
8750 -> 8678;
8750 -> 8729;
8750 -> 8681;
8750 -> 8748;
8751 -> 8750;
8751 -> 8746;
8752 -> 8751;
8752 -> 8733;
8753 -> 8745;
8753 -> 8752;
8753 -> 8733;
8754 -> 8733;
8755 -> 8721;
8755 -> 8754;
8756 -> 8754;
8757 -> 8755;
8757 -> 8756;
8758 -> 8757;
8758 -> 8754;
8759 -> 8754;
8760 -> 8755;
8760 -> 8759;
8761 -> 8760;
8761 -> 8631;
8761 -> 8678;
8761 -> 8729;
8761 -> 8759;
8762 -> 8761;
8762 -> 8631;
8762 -> 8759;
8763 -> 8759;
8764 -> 8760;
8764 -> 8631;
8764 -> 8763;
8764 -> 8759;
8765 -> 8754;
8766 -> 8758;
8766 -> 8754;
8767 -> 8766;
8767 -> 8733;
8768 -> 8733;
8769 -> 8768;
8769 -> 8631;
8769 -> 8639;
8769 -> 8676;
8769 -> 8762;
8769 -> 8678;
8769 -> 8729;
8769 -> 8760;
8769 -> 8681;
8770 -> 8769;
8770 -> 8733;
8771 -> 8767;
8771 -> 8733;
8772 -> 8771;
8772 -> 8707;
8773 -> 8772;
8773 -> 8707;
8774 -> 8707;
8775 -> 8773;
8775 -> 8774;
8776 -> 8773;
8776 -> 8774;
8777 -> 8775;
8777 -> 8774;
8778 -> 8774;
8779 -> 8778;
8779 -> 8777;
8779 -> 8774;
8780 -> 8778;
8780 -> 8774;
8781 -> 8780;
8781 -> 8779;
8781 -> 8774;
8782 -> 8781;
8782 -> 8703;
8783 -> 8782;
8783 -> 8781;
8783 -> 8703;
8784 -> 8782;
8784 -> 8703;
8785 -> 8703;
8786 -> 8705;
8786 -> 8785;
8787 -> 8785;
8788 -> 8786;
8788 -> 8787;
8789 -> 8788;
8789 -> 8631;
8789 -> 8681;
8789 -> 8760;
8789 -> 8787;
8790 -> 8787;
8791 -> 8788;
8791 -> 8631;
8791 -> 8790;
8791 -> 8787;
8792 -> 8788;
8792 -> 8631;
8792 -> 8639;
8792 -> 8676;
8792 -> 8762;
8792 -> 8678;
8792 -> 8729;
8792 -> 8760;
8792 -> 8681;
8792 -> 8781;
8792 -> 8791;
8793 -> 8792;
8793 -> 8703;
8794 -> 8703;
8795 -> 8793;
8795 -> 8794;
8796 -> 8784;
8796 -> 8703;
8797 -> 8796;
8797 -> 8699;
8798 -> 8699;
8799 -> 8701;
8799 -> 8798;
8800 -> 8799;
8800 -> 8631;
8800 -> 8678;
8800 -> 8729;
8800 -> 8760;
8800 -> 8792;
8800 -> 8798;
8801 -> 8800;
8801 -> 8699;
8802 -> 8699;
8803 -> 8801;
8803 -> 8802;
8804 -> 8797;
8804 -> 8699;
8805 -> 8804;
8805 -> 8695;
8806 -> 8695;
8807 -> 8697;
8807 -> 8806;
8808 -> 8806;
8809 -> 8807;
8809 -> 8808;
8810 -> 8809;
8810 -> 8631;
8810 -> 8678;
8810 -> 8729;
8810 -> 8760;
8810 -> 8792;
8810 -> 8808;
8811 -> 8810;
8811 -> 8806;
8812 -> 8806;
8813 -> 8811;
8813 -> 8812;
8814 -> 8806;
8815 -> 8807;
8815 -> 8814;
8816 -> 8815;
8816 -> 8631;
8816 -> 8678;
8816 -> 8729;
8816 -> 8760;
8816 -> 8792;
8816 -> 8814;
8817 -> 8816;
8817 -> 8806;
8818 -> 8806;
8819 -> 8817;
8819 -> 8818;
8820 -> 8813;
8820 -> 8819;
8820 -> 8806;
8821 -> 8820;
8821 -> 8695;
8822 -> 8695;
8823 -> 8697;
8823 -> 8822;
8824 -> 8823;
8824 -> 8631;
8824 -> 8678;
8824 -> 8729;
8824 -> 8760;
8824 -> 8792;
8824 -> 8822;
8825 -> 8824;
8825 -> 8695;
8826 -> 8695;
8827 -> 8825;
8827 -> 8826;
8828 -> 8821;
8828 -> 8827;
8828 -> 8695;
8829 -> 8805;
8829 -> 8695;
8830 -> 8829;
8830 -> 8643;
8831 -> 8643;
8832 -> 8643;
8833 -> 8646;
8833 -> 8832;
8834 -> 8833;
8834 -> 8631;
8834 -> 8678;
8834 -> 8729;
8834 -> 8760;
8834 -> 8792;
8834 -> 8832;
8835 -> 8834;
8835 -> 8643;
8836 -> 8643;
8837 -> 8835;
8837 -> 8836;
8838 -> 0;
8838 -> 8837;
8839 -> 8837;
8840 -> 8838;
8840 -> 8839;
8841 -> 8840;
8841 -> 8839;
8842 -> 8839;
8843 -> 8841;
8843 -> 8842;
8844 -> 8843;
8844 -> 0;
8844 -> 8842;
8845 -> 8844;
8846 -> 8840;
8847 -> 8840;
8848 -> 8839;
8848 -> 8840;
8849 -> 8646;
8849 -> 8631;
8849 -> 8643;
8850 -> 8643;
8851 -> 8643;
8852 -> 8849;
8852 -> 8851;
8853 -> 8850;
8853 -> 8851;
8854 -> 8852;
8854 -> 8781;
8854 -> 8851;
8855 -> 8643;
8856 -> 8848;
8856 -> 8643;
8857 -> 8850;
8857 -> 8643;
8858 -> 8855;
8858 -> 8643;
8859 -> 0;
8859 -> 8643;
8860 -> 8856;
8860 -> 8857;
8860 -> 8858;
8860 -> 8859;
8860 -> 8646;
8860 -> 8631;
8860 -> 8639;
8860 -> 8676;
8860 -> 8762;
8860 -> 8840;
8860 -> 8678;
8860 -> 8729;
8860 -> 8760;
8860 -> 8792;
8860 -> 8681;
8860 -> 8854;
8860 -> 8781;
8860 -> 8643;
8861 -> 8643;
8862 -> 8861;
8863 -> 8860;
8863 -> 8862;
8864 -> 8862;
8865 -> 8860;
8865 -> 8861;
8866 -> 8860;
8866 -> 8861;
8867 -> 8866;
8867 -> 8860;
8867 -> 8861;
8868 -> 8866;
8868 -> 8860;
8868 -> 8867;
8868 -> 8861;
8869 -> 8865;
8869 -> 8861;
8870 -> 8869;
8870 -> 8866;
8870 -> 8860;
8870 -> 8867;
8870 -> 8861;
8871 -> 8861;
8872 -> 8870;
8872 -> 8871;
8873 -> 8871;
8874 -> 8872;
8874 -> 8873;
8875 -> 8874;
8875 -> 8870;
8875 -> 8873;
8876 -> 8875;
8876 -> 8871;
8877 -> 8876;
8878 -> 8870;
8878 -> 8871;
8879 -> 8878;
8879 -> 8877;
8879 -> 8871;
8880 -> 8878;
8880 -> 8879;
8880 -> 8871;
8881 -> 8878;
8881 -> 8879;
8881 -> 0;
8881 -> 8871;
8882 -> 8881;
8882 -> 8878;
8882 -> 8871;
8883 -> 8871;
8884 -> 8878;
8884 -> 8883;
8885 -> 8883;
8886 -> 8884;
8886 -> 8885;
8887 -> 8886;
8887 -> 8879;
8887 -> 8885;
8888 -> 8887;
8888 -> 8883;
8889 -> 8883;
8890 -> 8888;
8890 -> 8889;
8891 -> 8890;
8891 -> 8871;
8892 -> 8880;
8892 -> 8878;
8892 -> 8871;
8893 -> 8879;
8893 -> 8882;
8893 -> 8892;
8893 -> 8871;
8894 -> 8879;
8894 -> 8871;
8895 -> 8878;
8895 -> 8893;
8895 -> 8894;
8895 -> 8871;
8896 -> 8870;
8896 -> 8871;
8897 -> 8870;
8897 -> 8871;
8898 -> 8870;
8898 -> 8871;
8899 -> 8871;
8900 -> 8899;
8901 -> 8898;
8901 -> 8900;
8902 -> 8901;
8902 -> 8895;
8902 -> 8900;
8903 -> 8902;
8903 -> 8899;
8904 -> 8899;
8905 -> 8903;
8905 -> 8904;
8906 -> 8904;
8907 -> 8905;
8907 -> 8906;
8908 -> 8904;
8909 -> 8905;
8909 -> 8908;
8910 -> 8908;
8911 -> 8909;
8911 -> 8910;
8912 -> 8911;
8912 -> 8908;
8913 -> 8907;
8913 -> 8912;
8913 -> 8904;
8914 -> 8913;
8914 -> 0;
8914 -> 8899;
8915 -> 8870;
8915 -> 8871;
8916 -> 8871;
8917 -> 8915;
8917 -> 8916;
8918 -> 8917;
8918 -> 8895;
8918 -> 8916;
8919 -> 8918;
8919 -> 8871;
8920 -> 8871;
8921 -> 8919;
8921 -> 8920;
8922 -> 8921;
8923 -> 8870;
8923 -> 8871;
8924 -> 8870;
8924 -> 8871;
8925 -> 8870;
8925 -> 8871;
8926 -> 8871;
8927 -> 8925;
8927 -> 8926;
8928 -> 8927;
8928 -> 8922;
8928 -> 8926;
8929 -> 8928;
8929 -> 8871;
8930 -> 8925;
8930 -> 8922;
8930 -> 8871;
8931 -> 8871;
8932 -> 8925;
8932 -> 8931;
8933 -> 8932;
8933 -> 8930;
8933 -> 8931;
8934 -> 8933;
8934 -> 8871;
8935 -> 8871;
8936 -> 8934;
8936 -> 8935;
8937 -> 8924;
8937 -> 8936;
8938 -> 0;
8938 -> 8936;
8939 -> 8936;
8940 -> 8937;
8940 -> 8939;
8941 -> 8938;
8941 -> 8939;
8942 -> 8938;
8942 -> 8939;
8943 -> 8925;
8943 -> 8939;
8944 -> 8939;
8945 -> 8940;
8945 -> 8930;
8945 -> 8939;
8946 -> 8936;
8947 -> 8923;
8947 -> 8936;
8948 -> 8924;
8948 -> 8936;
8949 -> 8936;
8950 -> 8947;
8950 -> 8949;
8951 -> 8948;
8951 -> 8949;
8952 -> 8925;
8952 -> 8949;
8953 -> 8949;
8954 -> 8952;
8954 -> 8953;
8955 -> 8954;
8955 -> 8949;
8956 -> 8949;
8957 -> 8955;
8957 -> 8956;
8958 -> 8949;
8959 -> 8952;
8959 -> 8958;
8960 -> 8959;
8960 -> 8949;
8961 -> 8949;
8962 -> 8952;
8962 -> 8961;
8963 -> 8961;
8964 -> 8962;
8964 -> 8930;
8964 -> 8963;
8964 -> 8961;
8965 -> 8961;
8966 -> 8962;
8966 -> 8949;
8967 -> 8949;
8968 -> 8966;
8968 -> 8967;
8969 -> 8967;
8970 -> 8968;
8970 -> 8969;
8971 -> 8970;
8971 -> 8967;
8972 -> 8967;
8973 -> 8968;
8973 -> 8972;
8974 -> 8972;
8975 -> 8973;
8975 -> 8974;
8976 -> 8975;
8976 -> 8972;
8977 -> 8976;
8977 -> 8967;
8978 -> 8971;
8978 -> 8977;
8978 -> 8967;
8979 -> 8968;
8979 -> 8967;
8980 -> 8952;
8980 -> 8930;
8980 -> 8949;
8981 -> 8949;
8982 -> 8979;
8982 -> 8981;
8983 -> 8982;
8983 -> 8949;
8984 -> 8952;
8984 -> 8930;
8984 -> 8949;
8985 -> 8952;
8985 -> 8930;
8985 -> 0;
8985 -> 8949;
8986 -> 8985;
8986 -> 8952;
8986 -> 8949;
8987 -> 8949;
8988 -> 8949;
8989 -> 8987;
8989 -> 8988;
8990 -> 8952;
8990 -> 8988;
8991 -> 8990;
8991 -> 8930;
8991 -> 8962;
8991 -> 8988;
8992 -> 8990;
8992 -> 8930;
8992 -> 8962;
8992 -> 8986;
8993 -> 8992;
8994 -> 8990;
8994 -> 8993;
8995 -> 8993;
8996 -> 8994;
8996 -> 8995;
8997 -> 8996;
8997 -> 8993;
8998 -> 8993;
8999 -> 8997;
8999 -> 8998;
9000 -> 8998;
9001 -> 8999;
9001 -> 9000;
9002 -> 9001;
9002 -> 8998;
9003 -> 8993;
9004 -> 9003;
9004 -> 8992;
9005 -> 8992;
9006 -> 8990;
9006 -> 9005;
9007 -> 9005;
9008 -> 9006;
9008 -> 9007;
9009 -> 9008;
9009 -> 8930;
9009 -> 8962;
9009 -> 8992;
9009 -> 8986;
9009 -> 9007;
9010 -> 9009;
9010 -> 9005;
9011 -> 9010;
9011 -> 8992;
9012 -> 9004;
9012 -> 9011;
9012 -> 8992;
9013 -> 8992;
9014 -> 8992;
9015 -> 8992;
9016 -> 9015;
9016 -> 8992;
9017 -> 8992;
9017 -> 8949;
9018 -> 8949;
9019 -> 8952;
9019 -> 9018;
9020 -> 9018;
9021 -> 9019;
9021 -> 9020;
9022 -> 9021;
9022 -> 8930;
9022 -> 8962;
9022 -> 8992;
9022 -> 9020;
9023 -> 9021;
9023 -> 8930;
9023 -> 8962;
9023 -> 8992;
9023 -> 8986;
9024 -> 9023;
9024 -> 9018;
9025 -> 9018;
9026 -> 9024;
9026 -> 9025;
9027 -> 9026;
9028 -> 9027;
9028 -> 8949;
9029 -> 8949;
9030 -> 8979;
9030 -> 9029;
9031 -> 9030;
9031 -> 8949;
9032 -> 9031;
9032 -> 8949;
9033 -> 8979;
9033 -> 8949;
9034 -> 9032;
9034 -> 8949;
9035 -> 8949;
9036 -> 9033;
9036 -> 9035;
9037 -> 9034;
9037 -> 9035;
9038 -> 8952;
9038 -> 9035;
9039 -> 9035;
9040 -> 9038;
9040 -> 9039;
9041 -> 9040;
9041 -> 8930;
9041 -> 8962;
9041 -> 8992;
9041 -> 9023;
9041 -> 9039;
9042 -> 9041;
9042 -> 9035;
9043 -> 9035;
9044 -> 9042;
9044 -> 9043;
9045 -> 9044;
9046 -> 9045;
9046 -> 8949;
9047 -> 8984;
9047 -> 8952;
9047 -> 8949;
9048 -> 8949;
9049 -> 8949;
9050 -> 8949;
9051 -> 8949;
9052 -> 8952;
9052 -> 9051;
9053 -> 9052;
9053 -> 8930;
9053 -> 8962;
9053 -> 8992;
9053 -> 9023;
9053 -> 9051;
9054 -> 9053;
9054 -> 8949;
9055 -> 8949;
9056 -> 9054;
9056 -> 9055;
9057 -> 9055;
9058 -> 9056;
9058 -> 9057;
9059 -> 9058;
9059 -> 9055;
9060 -> 8980;
9060 -> 8952;
9060 -> 8949;
9061 -> 8949;
9062 -> 8949;
9063 -> 8949;
9064 -> 8949;
9065 -> 8979;
9065 -> 9064;
9066 -> 9065;
9066 -> 8949;
9067 -> 0;
9067 -> 9066;
9068 -> 9066;
9069 -> 9067;
9069 -> 9068;
9070 -> 9069;
9070 -> 9068;
9071 -> 9068;
9072 -> 9070;
9072 -> 9071;
9073 -> 9072;
9073 -> 0;
9073 -> 9071;
9074 -> 9073;
9075 -> 9068;
9075 -> 8930;
9075 -> 8962;
9075 -> 8992;
9075 -> 9023;
9076 -> 9075;
9076 -> 9069;
9076 -> 9068;
9077 -> 9076;
9078 -> 9076;
9079 -> 9017;
9079 -> 8930;
9079 -> 9076;
9079 -> 9066;
9080 -> 9048;
9080 -> 9066;
9081 -> 8952;
9081 -> 8930;
9081 -> 8962;
9081 -> 8992;
9081 -> 9076;
9081 -> 9023;
9081 -> 8986;
9081 -> 9047;
9081 -> 9060;
9081 -> 9080;
9082 -> 9080;
9083 -> 9082;
9084 -> 9083;
9084 -> 9081;
9085 -> 9083;
9085 -> 9081;
9086 -> 9085;
9086 -> 9082;
9087 -> 9082;
9088 -> 9086;
9088 -> 9087;
9089 -> 9088;
9089 -> 9082;
9090 -> 9082;
9091 -> 9089;
9091 -> 9090;
9092 -> 9091;
9092 -> 9090;
9093 -> 9092;
9094 -> 9088;
9094 -> 0;
9094 -> 9093;
9095 -> 9076;
9095 -> 9081;
9095 -> 9066;
9096 -> 0;
9096 -> 9095;
9097 -> 9095;
9098 -> 9096;
9098 -> 9097;
9099 -> 9098;
9099 -> 9097;
9100 -> 9097;
9101 -> 9099;
9101 -> 9100;
9102 -> 9101;
9102 -> 0;
9102 -> 9100;
9103 -> 9102;
9104 -> 9097;
9104 -> 9081;
9104 -> 9085;
9105 -> 9104;
9105 -> 9098;
9105 -> 9097;
9106 -> 9105;
9107 -> 9105;
9108 -> 0;
9108 -> 9066;
9109 -> 9066;
9110 -> 9108;
9110 -> 9109;
9111 -> 8952;
9111 -> 9109;
9112 -> 9109;
9113 -> 9111;
9113 -> 9112;
9114 -> 9113;
9114 -> 9081;
9114 -> 9105;
9114 -> 9112;
9115 -> 9113;
9115 -> 9081;
9115 -> 9112;
9116 -> 9113;
9116 -> 9081;
9116 -> 9085;
9116 -> 9105;
9116 -> 9115;
9117 -> 9109;
9118 -> 9116;
9118 -> 9117;
9119 -> 9118;
9119 -> 9110;
9119 -> 9109;
9120 -> 9119;
9121 -> 9120;
9121 -> 9109;
9122 -> 8951;
9122 -> 9081;
9122 -> 9085;
9122 -> 9105;
9122 -> 9116;
9122 -> 8949;
9123 -> 9081;
9123 -> 8949;
9124 -> 9050;
9124 -> 8949;
9125 -> 8949;
9126 -> 8979;
9126 -> 9125;
9127 -> 9126;
9127 -> 9122;
9127 -> 9125;
9128 -> 9127;
9128 -> 8949;
9129 -> 9032;
9129 -> 9128;
9130 -> 9128;
9131 -> 9128;
9132 -> 8950;
9132 -> 9128;
9133 -> 9122;
9133 -> 9128;
9134 -> 8979;
9134 -> 9128;
9135 -> 9017;
9135 -> 9128;
9136 -> 9028;
9136 -> 9128;
9137 -> 9046;
9137 -> 9128;
9138 -> 9124;
9138 -> 9128;
9139 -> 9076;
9139 -> 9128;
9140 -> 9123;
9140 -> 9128;
9141 -> 9105;
9141 -> 9128;
9142 -> 9121;
9142 -> 9128;
9143 -> 9132;
9143 -> 9133;
9143 -> 9134;
9143 -> 9135;
9143 -> 9136;
9143 -> 9137;
9143 -> 9138;
9143 -> 9139;
9143 -> 9140;
9143 -> 9141;
9143 -> 9142;
9143 -> 8952;
9143 -> 9122;
9143 -> 8922;
9143 -> 9050;
9143 -> 9081;
9143 -> 9128;
9144 -> 9128;
9145 -> 9143;
9145 -> 9144;
9146 -> 9143;
9146 -> 9144;
9147 -> 9145;
9147 -> 9143;
9147 -> 9144;
9148 -> 9145;
9148 -> 9143;
9148 -> 9144;
9149 -> 9081;
9149 -> 9128;
9150 -> 9081;
9150 -> 9149;
9151 -> 8952;
9151 -> 9143;
9151 -> 9150;
9151 -> 9081;
9151 -> 9149;
9152 -> 9050;
9152 -> 9128;
9153 -> 8866;
9153 -> 9151;
9153 -> 8861;
9154 -> 9151;
9154 -> 8861;
9155 -> 8860;
9155 -> 9154;
9155 -> 9151;
9155 -> 9153;
9155 -> 8643;
9156 -> 8860;
9156 -> 8861;
9157 -> 8861;
9158 -> 9156;
9158 -> 9155;
9158 -> 9157;
9158 -> 8861;
9159 -> 8866;
9159 -> 9155;
9159 -> 8861;
9160 -> 9155;
9160 -> 8883;
9161 -> 9160;
9161 -> 8885;
9162 -> 9161;
9162 -> 8883;
9163 -> 9162;
9163 -> 8889;
9164 -> 9163;
9164 -> 8871;
9165 -> 9155;
9165 -> 8871;
9166 -> 9155;
9166 -> 8871;
9167 -> 9155;
9167 -> 8871;
9168 -> 9167;
9168 -> 8900;
9169 -> 9168;
9169 -> 8899;
9170 -> 9169;
9170 -> 8904;
9171 -> 9170;
9171 -> 8906;
9172 -> 9170;
9172 -> 8908;
9173 -> 9172;
9173 -> 8910;
9174 -> 9173;
9174 -> 8908;
9175 -> 9171;
9175 -> 9174;
9175 -> 8904;
9176 -> 9175;
9176 -> 0;
9176 -> 8899;
9177 -> 9155;
9177 -> 8926;
9178 -> 9177;
9178 -> 8871;
9179 -> 9155;
9180 -> 0;
9180 -> 9155;
9181 -> 9155;
9182 -> 9179;
9182 -> 9181;
9183 -> 9180;
9183 -> 9181;
9184 -> 9180;
9184 -> 9181;
9185 -> 9155;
9185 -> 9181;
9186 -> 9181;
9187 -> 9182;
9187 -> 9155;
9187 -> 9181;
9188 -> 9155;
9189 -> 9188;
9189 -> 9155;
9190 -> 9155;
9191 -> 9189;
9191 -> 9190;
9192 -> 9155;
9193 -> 9192;
9193 -> 9155;
9194 -> 9155;
9195 -> 9155;
9196 -> 9155;
9197 -> 9188;
9197 -> 9196;
9198 -> 9197;
9198 -> 9155;
9199 -> 9155;
9200 -> 9188;
9200 -> 9199;
9201 -> 9199;
9202 -> 9200;
9202 -> 9201;
9203 -> 9202;
9203 -> 9199;
9204 -> 9203;
9204 -> 9155;
9205 -> 9198;
9205 -> 9204;
9205 -> 9155;
9206 -> 9155;
9207 -> 9188;
9207 -> 9206;
9208 -> 9207;
9208 -> 9155;
9209 -> 9155;
9210 -> 9188;
9210 -> 9155;
9211 -> 9188;
9212 -> 9155;
9212 -> 9211;
9213 -> 9211;
9214 -> 9212;
9214 -> 9213;
9215 -> 9214;
9215 -> 9211;
9216 -> 9211;
9217 -> 9215;
9217 -> 9216;
9218 -> 9216;
9219 -> 9217;
9219 -> 9218;
9220 -> 9219;
9220 -> 9216;
9221 -> 9211;
9222 -> 9221;
9222 -> 9188;
9223 -> 9188;
9224 -> 9155;
9224 -> 9223;
9225 -> 9223;
9226 -> 9224;
9226 -> 9225;
9227 -> 9226;
9227 -> 9155;
9227 -> 9188;
9227 -> 9225;
9228 -> 9227;
9228 -> 9223;
9229 -> 9228;
9229 -> 9188;
9230 -> 9222;
9230 -> 9229;
9230 -> 9188;
9231 -> 9188;
9232 -> 9188;
9233 -> 9188;
9234 -> 9233;
9234 -> 9188;
9235 -> 9155;
9236 -> 9188;
9236 -> 9235;
9237 -> 9236;
9237 -> 9155;
9238 -> 9237;
9238 -> 9155;
9239 -> 9188;
9239 -> 9155;
9240 -> 9238;
9240 -> 9155;
9241 -> 9155;
9242 -> 9241;
9242 -> 9155;
9242 -> 9188;
9243 -> 9241;
9243 -> 9155;
9243 -> 9188;
9244 -> 9241;
9245 -> 9241;
9245 -> 9155;
9245 -> 9188;
9246 -> 9241;
9247 -> 9242;
9247 -> 9155;
9248 -> 9155;
9248 -> 9188;
9248 -> 9243;
9248 -> 9241;
9248 -> 9245;
9249 -> 9155;
9250 -> 9155;
9251 -> 9249;
9251 -> 9250;
9252 -> 9155;
9252 -> 9250;
9253 -> 9250;
9254 -> 9252;
9254 -> 9253;
9255 -> 9254;
9255 -> 9248;
9255 -> 9253;
9256 -> 9254;
9256 -> 9248;
9256 -> 9253;
9257 -> 9256;
9257 -> 9250;
9258 -> 9250;
9259 -> 9257;
9259 -> 9258;
9260 -> 9251;
9260 -> 9250;
9261 -> 9260;
9261 -> 9252;
9261 -> 9248;
9261 -> 9256;
9261 -> 9250;
9262 -> 9250;
9263 -> 9261;
9263 -> 9262;
9264 -> 9261;
9264 -> 9262;
9265 -> 9261;
9265 -> 9262;
9266 -> 9262;
9267 -> 9265;
9267 -> 9266;
9268 -> 9267;
9268 -> 9262;
9269 -> 9262;
9270 -> 9268;
9270 -> 9269;
9271 -> 9262;
9272 -> 9270;
9272 -> 9271;
9273 -> 9272;
9273 -> 9271;
9274 -> 9271;
9275 -> 9273;
9275 -> 9274;
9276 -> 9275;
9276 -> 9274;
9277 -> 9276;
9278 -> 9262;
9279 -> 9265;
9279 -> 9278;
9280 -> 9278;
9281 -> 9279;
9281 -> 9280;
9282 -> 9281;
9282 -> 9278;
9283 -> 9278;
9284 -> 9282;
9284 -> 9283;
9285 -> 9284;
9286 -> 9279;
9286 -> 9285;
9287 -> 9285;
9288 -> 9286;
9288 -> 9287;
9289 -> 9288;
9289 -> 9285;
9290 -> 9285;
9291 -> 9289;
9291 -> 9290;
9292 -> 9290;
9293 -> 9291;
9293 -> 9292;
9294 -> 9293;
9294 -> 9290;
9295 -> 9285;
9296 -> 9295;
9296 -> 9284;
9297 -> 9284;
9298 -> 9279;
9298 -> 9297;
9299 -> 9297;
9300 -> 9298;
9300 -> 9299;
9301 -> 9300;
9301 -> 9261;
9301 -> 9299;
9302 -> 9301;
9302 -> 9297;
9303 -> 9302;
9303 -> 9284;
9304 -> 9296;
9304 -> 9303;
9304 -> 9284;
9305 -> 9284;
9306 -> 9279;
9306 -> 9305;
9307 -> 9305;
9308 -> 9306;
9308 -> 9307;
9309 -> 9308;
9309 -> 9305;
9310 -> 9305;
9311 -> 9309;
9311 -> 9310;
9312 -> 9310;
9313 -> 9311;
9313 -> 9312;
9314 -> 9313;
9314 -> 9310;
9315 -> 9314;
9315 -> 9284;
9316 -> 9304;
9316 -> 9315;
9316 -> 9284;
9317 -> 9316;
9318 -> 9317;
9318 -> 9262;
9319 -> 9264;
9319 -> 9318;
9320 -> 9318;
9321 -> 9319;
9321 -> 9320;
9322 -> 9321;
9322 -> 9320;
9323 -> 9322;
9323 -> 9320;
9324 -> 9323;
9324 -> 9320;
9325 -> 9324;
9325 -> 9320;
9326 -> 9320;
9327 -> 9326;
9327 -> 9320;
9328 -> 9320;
9329 -> 9328;
9329 -> 9320;
9330 -> 9327;
9330 -> 9320;
9331 -> 9320;
9332 -> 9320;
9332 -> 9331;
9333 -> 9331;
9334 -> 9332;
9334 -> 9333;
9335 -> 9334;
9335 -> 9331;
9336 -> 9331;
9337 -> 9335;
9337 -> 9336;
9338 -> 9331;
9338 -> 9320;
9339 -> 9320;
9340 -> 9339;
9340 -> 9320;
9341 -> 9338;
9341 -> 9340;
9341 -> 9320;
9342 -> 9320;
9342 -> 9261;
9343 -> 9320;
9344 -> 9320;
9345 -> 9320;
9346 -> 9320;
9347 -> 9346;
9347 -> 9261;
9347 -> 9343;
9347 -> 9320;
9348 -> 9347;
9348 -> 9320;
9349 -> 9343;
9349 -> 9320;
9350 -> 9349;
9350 -> 9343;
9350 -> 9320;
9351 -> 9349;
9351 -> 9320;
9352 -> 9320;
9352 -> 9343;
9353 -> 9343;
9353 -> 9320;
9354 -> 9320;
9355 -> 9353;
9355 -> 9354;
9356 -> 9351;
9356 -> 9320;
9357 -> 9356;
9357 -> 9320;
9358 -> 9320;
9359 -> 9358;
9359 -> 9343;
9360 -> 9359;
9360 -> 9320;
9361 -> 9320;
9362 -> 9360;
9362 -> 9361;
9363 -> 9357;
9363 -> 9320;
9364 -> 9363;
9364 -> 9320;
9365 -> 9320;
9366 -> 9320;
9366 -> 9365;
9367 -> 9365;
9368 -> 9366;
9368 -> 9367;
9369 -> 9368;
9369 -> 9343;
9369 -> 9367;
9370 -> 9369;
9370 -> 9365;
9371 -> 9365;
9372 -> 9370;
9372 -> 9371;
9373 -> 9365;
9374 -> 9366;
9374 -> 9373;
9375 -> 9374;
9375 -> 9343;
9375 -> 9373;
9376 -> 9375;
9376 -> 9365;
9377 -> 9365;
9378 -> 9376;
9378 -> 9377;
9379 -> 9372;
9379 -> 9378;
9379 -> 9365;
9380 -> 9379;
9380 -> 9320;
9381 -> 9320;
9382 -> 9381;
9382 -> 9343;
9383 -> 9382;
9383 -> 9320;
9384 -> 9320;
9385 -> 9383;
9385 -> 9384;
9386 -> 9380;
9386 -> 9385;
9386 -> 9320;
9387 -> 9364;
9387 -> 9320;
9388 -> 9387;
9388 -> 9318;
9389 -> 9261;
9389 -> 9262;
9390 -> 9261;
9390 -> 9262;
9391 -> 9261;
9391 -> 9262;
9392 -> 9262;
9393 -> 9391;
9393 -> 9392;
9394 -> 9393;
9394 -> 9388;
9394 -> 9392;
9395 -> 9394;
9395 -> 9262;
9396 -> 9395;
9396 -> 9389;
9396 -> 9262;
9397 -> 9395;
9397 -> 9396;
9398 -> 9396;
9399 -> 9397;
9399 -> 9398;
9399 -> 9250;
9400 -> 9397;
9400 -> 9262;
9401 -> 9397;
9401 -> 9262;
9402 -> 9262;
9403 -> 9262;
9404 -> 0;
9404 -> 9262;
9405 -> 9262;
9406 -> 9404;
9406 -> 9405;
9407 -> 9401;
9407 -> 9405;
9408 -> 9406;
9408 -> 9405;
9409 -> 9405;
9410 -> 9408;
9410 -> 9409;
9411 -> 9410;
9411 -> 0;
9411 -> 9409;
9412 -> 9411;
9413 -> 9407;
9413 -> 9406;
9413 -> 9405;
9414 -> 9413;
9415 -> 9413;
9416 -> 9413;
9417 -> 9401;
9417 -> 9262;
9418 -> 0;
9418 -> 9262;
9419 -> 9262;
9420 -> 9418;
9420 -> 9419;
9421 -> 9420;
9421 -> 9419;
9422 -> 9419;
9423 -> 9421;
9423 -> 9422;
9424 -> 9423;
9424 -> 3999;
9424 -> 9422;
9425 -> 4003;
9425 -> 4002;
9425 -> 9423;
9425 -> 9422;
9426 -> 9425;
9426 -> 9401;
9426 -> 9262;
9427 -> 9262;
9428 -> 9426;
9428 -> 9427;
9429 -> 9426;
9429 -> 9427;
9430 -> 9426;
9430 -> 9427;
9431 -> 9426;
9431 -> 9427;
9432 -> 9428;
9432 -> 9427;
9433 -> 9429;
9433 -> 9427;
9434 -> 9430;
9434 -> 9427;
9435 -> 9427;
9436 -> 9434;
9436 -> 9435;
9437 -> 9435;
9438 -> 9436;
9438 -> 9426;
9438 -> 9435;
9439 -> 9436;
9439 -> 9426;
9439 -> 9435;
9440 -> 9437;
9440 -> 9435;
9441 -> 9440;
9441 -> 9427;
9442 -> 9431;
9442 -> 9427;
9443 -> 9432;
9443 -> 9433;
9443 -> 9441;
9443 -> 9442;
9443 -> 9426;
9443 -> 9427;
9444 -> 9443;
9444 -> 9427;
9445 -> 9443;
9445 -> 9427;
9446 -> 9444;
9446 -> 9427;
9447 -> 9444;
9447 -> 9427;
9448 -> 9262;
9449 -> 9448;
9449 -> 9262;
9450 -> 9262;
9451 -> 9262;
9452 -> 9449;
9452 -> 9451;
9453 -> 9450;
9453 -> 9451;
9454 -> 9401;
9454 -> 9451;
9455 -> 9451;
9456 -> 9454;
9456 -> 9452;
9456 -> 9451;
9457 -> 9456;
9458 -> 9262;
9459 -> 9401;
9459 -> 9458;
9460 -> 9459;
9460 -> 9458;
9461 -> 9459;
9461 -> 9262;
9462 -> 9262;
9463 -> 9461;
9463 -> 9462;
9464 -> 9457;
9464 -> 9463;
9464 -> 9262;
9465 -> 9262;
9466 -> 9417;
9466 -> 9465;
9466 -> 9262;
9467 -> 9466;
9468 -> 9443;
9468 -> 9466;
9469 -> 9467;
9469 -> 9402;
9469 -> 9262;
9470 -> 0;
9470 -> 9262;
9471 -> 9262;
9472 -> 9470;
9472 -> 9471;
9473 -> 9401;
9473 -> 9471;
9474 -> 9472;
9474 -> 9471;
9475 -> 9471;
9476 -> 9474;
9476 -> 9475;
9477 -> 9476;
9477 -> 0;
9477 -> 9475;
9478 -> 9477;
9479 -> 9473;
9479 -> 9472;
9479 -> 9471;
9480 -> 9479;
9481 -> 9479;
9482 -> 9413;
9482 -> 9262;
9483 -> 9417;
9483 -> 9262;
9484 -> 9479;
9484 -> 9262;
9485 -> 9482;
9485 -> 9483;
9485 -> 9484;
9485 -> 9401;
9485 -> 9468;
9485 -> 9262;
9486 -> 9262;
9487 -> 9485;
9487 -> 9486;
9488 -> 9485;
9488 -> 9486;
9489 -> 9485;
9489 -> 9486;
9490 -> 9485;
9490 -> 9486;
9491 -> 9485;
9491 -> 9486;
9492 -> 9485;
9492 -> 9486;
9493 -> 9487;
9493 -> 9486;
9494 -> 9488;
9494 -> 9486;
9495 -> 9489;
9495 -> 9486;
9496 -> 9490;
9496 -> 9486;
9497 -> 9491;
9497 -> 9486;
9498 -> 9486;
9499 -> 9497;
9499 -> 9498;
9500 -> 9498;
9501 -> 9499;
9501 -> 9485;
9501 -> 9498;
9502 -> 9499;
9502 -> 9485;
9502 -> 9498;
9503 -> 9500;
9503 -> 9498;
9504 -> 9503;
9504 -> 9486;
9505 -> 9492;
9505 -> 9486;
9506 -> 9493;
9506 -> 9494;
9506 -> 9495;
9506 -> 9496;
9506 -> 9504;
9506 -> 9505;
9506 -> 9485;
9506 -> 9486;
9507 -> 9506;
9507 -> 9486;
9508 -> 9506;
9508 -> 9486;
9509 -> 9507;
9509 -> 9486;
9510 -> 9507;
9510 -> 9486;
9511 -> 9417;
9511 -> 9262;
9512 -> 9401;
9512 -> 9511;
9512 -> 9506;
9512 -> 9262;
9513 -> 9402;
9513 -> 9506;
9513 -> 9512;
9513 -> 9250;
9514 -> 9402;
9514 -> 9458;
9515 -> 9514;
9515 -> 9458;
9516 -> 9402;
9516 -> 9262;
9517 -> 9402;
9517 -> 9262;
9518 -> 9402;
9518 -> 9262;
9519 -> 9402;
9519 -> 9262;
9520 -> 9402;
9520 -> 9262;
9521 -> 9516;
9521 -> 9262;
9522 -> 9517;
9522 -> 9262;
9523 -> 9518;
9523 -> 9262;
9524 -> 9519;
9524 -> 9262;
9525 -> 9262;
9526 -> 9524;
9526 -> 9525;
9527 -> 9525;
9528 -> 9526;
9528 -> 9525;
9529 -> 9526;
9529 -> 9525;
9530 -> 9527;
9530 -> 9525;
9531 -> 9530;
9531 -> 9262;
9532 -> 9520;
9532 -> 9262;
9533 -> 9521;
9533 -> 9522;
9533 -> 9523;
9533 -> 9531;
9533 -> 9532;
9533 -> 9262;
9534 -> 9427;
9534 -> 9533;
9534 -> 9262;
9535 -> 9533;
9535 -> 9262;
9536 -> 9533;
9536 -> 9262;
9537 -> 9535;
9537 -> 9262;
9538 -> 9535;
9538 -> 9262;
9539 -> 9533;
9539 -> 9262;
9540 -> 9533;
9540 -> 9262;
9541 -> 9533;
9541 -> 9262;
9542 -> 9541;
9542 -> 9392;
9543 -> 9542;
9543 -> 9392;
9544 -> 9543;
9544 -> 9262;
9545 -> 9544;
9545 -> 9539;
9545 -> 9262;
9546 -> 9544;
9546 -> 9545;
9547 -> 9545;
9548 -> 9546;
9548 -> 9547;
9548 -> 9250;
9549 -> 9252;
9549 -> 9260;
9549 -> 9388;
9549 -> 9398;
9549 -> 9397;
9549 -> 9506;
9549 -> 9514;
9549 -> 9402;
9549 -> 9533;
9549 -> 9547;
9549 -> 9546;
9549 -> 9513;
9549 -> 9534;
9549 -> 9250;
9550 -> 9155;
9551 -> 9155;
9552 -> 9551;
9552 -> 9549;
9553 -> 9552;
9553 -> 9155;
9554 -> 9155;
9555 -> 9553;
9555 -> 9554;
9556 -> 9550;
9556 -> 9155;
9557 -> 9549;
9557 -> 9556;
9558 -> 9556;
9559 -> 9557;
9559 -> 9558;
9560 -> 9558;
9561 -> 9559;
9561 -> 9560;
9562 -> 9560;
9563 -> 9561;
9563 -> 9557;
9563 -> 9560;
9564 -> 9561;
9564 -> 9557;
9564 -> 9560;
9565 -> 9562;
9565 -> 9560;
9566 -> 9565;
9566 -> 9558;
9567 -> 9559;
9567 -> 9558;
9568 -> 9559;
9568 -> 9558;
9569 -> 9567;
9569 -> 9558;
9570 -> 9567;
9570 -> 9558;
9571 -> 9155;
9572 -> 9571;
9573 -> 9572;
9573 -> 9559;
9574 -> 9573;
9574 -> 9571;
9575 -> 9571;
9576 -> 9574;
9576 -> 9575;
9577 -> 9247;
9577 -> 9155;
9578 -> 9248;
9578 -> 9155;
9579 -> 9577;
9579 -> 9578;
9579 -> 9155;
9579 -> 9559;
9580 -> 9155;
9581 -> 9579;
9581 -> 9580;
9582 -> 9580;
9583 -> 9581;
9583 -> 9582;
9584 -> 9582;
9585 -> 9583;
9585 -> 9579;
9585 -> 9582;
9586 -> 9583;
9586 -> 9579;
9586 -> 9582;
9587 -> 9584;
9587 -> 9582;
9588 -> 9587;
9588 -> 9580;
9589 -> 9581;
9589 -> 9580;
9590 -> 9581;
9590 -> 9580;
9591 -> 9589;
9591 -> 9580;
9592 -> 9589;
9592 -> 9580;
9593 -> 9248;
9593 -> 9155;
9594 -> 9155;
9594 -> 9581;
9594 -> 9593;
9595 -> 9155;
9596 -> 9155;
9597 -> 9596;
9597 -> 9594;
9598 -> 9597;
9598 -> 9155;
9599 -> 9155;
9600 -> 9598;
9600 -> 9599;
9601 -> 9599;
9602 -> 9155;
9603 -> 9155;
9604 -> 9155;
9605 -> 9594;
9606 -> 9594;
9607 -> 9605;
9607 -> 9606;
9608 -> 9607;
9608 -> 0;
9608 -> 9606;
9609 -> 9608;
9610 -> 9594;
9611 -> 9594;
9612 -> 9594;
9613 -> 9188;
9613 -> 9594;
9614 -> 9594;
9615 -> 9594;
9616 -> 9594;
9617 -> 9615;
9617 -> 9616;
9618 -> 9617;
9618 -> 9594;
9619 -> 9594;
9620 -> 9618;
9620 -> 9619;
9621 -> 9620;
9621 -> 9619;
9622 -> 9621;
9623 -> 9617;
9623 -> 0;
9623 -> 9622;
9624 -> 9238;
9624 -> 9594;
9625 -> 9594;
9626 -> 9594;
9627 -> 9594;
9628 -> 9594;
9629 -> 9627;
9629 -> 9594;
9630 -> 9627;
9630 -> 9594;
9631 -> 9155;
9631 -> 9594;
9632 -> 9156;
9632 -> 9594;
9632 -> 9157;
9632 -> 8861;
9633 -> 0;
9633 -> 8643;
9634 -> 8643;
9635 -> 9633;
9635 -> 9634;
9636 -> 8646;
9636 -> 9634;
9637 -> 9635;
9637 -> 9634;
9638 -> 9634;
9639 -> 9637;
9639 -> 9638;
9640 -> 9639;
9640 -> 0;
9640 -> 9638;
9641 -> 9640;
9642 -> 9634;
9643 -> 9636;
9643 -> 9642;
9644 -> 9643;
9644 -> 9594;
9644 -> 9642;
9645 -> 9634;
9646 -> 9644;
9646 -> 9635;
9646 -> 9634;
9647 -> 9646;
9648 -> 9646;
9649 -> 0;
9649 -> 8643;
9650 -> 8643;
9651 -> 9649;
9651 -> 9650;
9652 -> 8646;
9652 -> 9650;
9653 -> 9650;
9654 -> 9652;
9654 -> 9653;
9655 -> 9653;
9656 -> 9654;
9656 -> 9655;
9657 -> 9656;
9657 -> 9594;
9657 -> 9646;
9657 -> 9655;
9658 -> 9655;
9659 -> 9656;
9659 -> 9594;
9659 -> 9658;
9659 -> 9655;
9660 -> 9656;
9660 -> 9594;
9660 -> 9646;
9660 -> 9659;
9661 -> 9650;
9662 -> 9660;
9662 -> 9651;
9662 -> 9650;
9663 -> 8643;
9664 -> 9594;
9664 -> 9663;
9664 -> 8643;
9665 -> 8644;
9665 -> 8643;
9666 -> 8645;
9666 -> 9594;
9666 -> 9646;
9666 -> 9660;
9666 -> 8643;
9667 -> 8683;
9667 -> 8643;
9668 -> 8830;
9668 -> 8643;
9669 -> 9594;
9669 -> 8643;
9670 -> 9646;
9670 -> 8643;
9671 -> 9662;
9671 -> 8643;
9672 -> 9665;
9672 -> 9666;
9672 -> 9667;
9672 -> 9668;
9672 -> 9669;
9672 -> 9670;
9672 -> 9671;
9672 -> 8646;
9672 -> 8631;
9672 -> 8643;
9673 -> 8643;
9674 -> 9673;
9675 -> 9674;
9675 -> 9673;
9676 -> 9672;
9676 -> 9673;
9677 -> 9672;
9677 -> 9673;
9678 -> 9676;
9678 -> 9672;
9678 -> 9673;
9679 -> 9676;
9679 -> 9672;
9679 -> 9673;
9680 -> 8646;
9680 -> 9672;
9680 -> 8643;
9681 -> 8643;
9682 -> 9680;
9682 -> 9681;
9683 -> 9594;
9683 -> 9681;
9684 -> 9683;
9684 -> 9594;
9684 -> 9681;
9685 -> 9682;
9685 -> 9684;
9685 -> 9672;
9685 -> 9594;
9685 -> 9681;
9686 -> 9683;
9686 -> 9594;
9686 -> 9681;
9687 -> 9682;
9687 -> 9686;
9687 -> 9685;
9687 -> 9594;
9687 -> 9681;
9688 -> 9683;
9688 -> 9594;
9688 -> 9681;
9689 -> 9682;
9689 -> 9688;
9689 -> 9687;
9689 -> 9594;
9689 -> 9681;
9690 -> 9683;
9690 -> 9594;
9690 -> 9681;
9691 -> 9682;
9691 -> 9690;
9691 -> 9689;
9691 -> 9594;
9691 -> 9681;
9692 -> 8643;
9693 -> 8638;
9693 -> 9691;
9693 -> 8618;
9694 -> 9672;
9694 -> 8618;
9695 -> 8633;
9695 -> 9694;
9695 -> 9691;
9695 -> 9693;
9695 -> 8596;
9696 -> 8633;
9696 -> 8618;
9697 -> 8633;
9697 -> 8618;
9698 -> 8633;
9698 -> 8618;
9699 -> 9698;
9699 -> 9695;
9699 -> 8634;
9699 -> 8618;
9700 -> 0;
9700 -> 8596;
9701 -> 8596;
9702 -> 9700;
9702 -> 9701;
9703 -> 8597;
9703 -> 9701;
9704 -> 9702;
9704 -> 9701;
9705 -> 9701;
9706 -> 9704;
9706 -> 9705;
9707 -> 9706;
9707 -> 0;
9707 -> 9705;
9708 -> 9707;
9709 -> 9701;
9710 -> 9703;
9710 -> 9709;
9711 -> 9710;
9711 -> 9695;
9711 -> 9709;
9712 -> 9701;
9713 -> 9711;
9713 -> 9702;
9713 -> 9701;
9714 -> 9713;
9714 -> 9695;
9715 -> 9713;
9716 -> 9713;
9717 -> 9695;
9717 -> 8596;
9718 -> 9713;
9718 -> 8596;
9719 -> 8596;
9720 -> 9719;
9721 -> 9720;
9721 -> 9719;
9722 -> 9718;
9722 -> 9719;
9723 -> 9718;
9723 -> 9719;
9724 -> 9722;
9724 -> 9718;
9724 -> 9719;
9725 -> 9722;
9725 -> 9718;
9725 -> 9719;
9726 -> 8596;
9727 -> 9695;
9727 -> 9726;
9727 -> 8596;
9728 -> 9718;
9728 -> 8596;
9729 -> 8597;
9729 -> 9718;
9729 -> 8596;
9730 -> 8596;
9731 -> 9729;
9731 -> 9730;
9732 -> 9695;
9732 -> 9730;
9733 -> 8596;
9734 -> 8595;
9734 -> 9728;
9734 -> 9731;
9734 -> 8589;
9735 -> 9734;
9735 -> 7630;
9736 -> 7630;
9737 -> 9735;
9737 -> 9736;
9738 -> 9735;
9738 -> 9736;
9739 -> 9735;
9739 -> 9736;
9740 -> 9735;
9740 -> 9736;
9741 -> 9737;
9741 -> 9736;
9742 -> 9738;
9742 -> 9736;
9743 -> 9739;
9743 -> 9736;
9744 -> 9736;
9745 -> 9744;
9745 -> 9741;
9745 -> 9742;
9745 -> 9743;
9745 -> 9735;
9745 -> 9736;
9746 -> 7631;
9746 -> 7630;
9747 -> 7631;
9747 -> 8496;
9747 -> 7630;
9748 -> 7633;
9748 -> 7630;
9749 -> 7639;
9749 -> 7630;
9750 -> 9745;
9750 -> 7630;
9751 -> 7630;
9752 -> 7720;
9752 -> 9751;
9753 -> 9751;
9754 -> 9752;
9754 -> 7758;
9754 -> 9753;
9755 -> 9754;
9755 -> 8496;
9755 -> 9753;
9756 -> 9755;
9756 -> 9751;
9757 -> 9756;
9757 -> 7630;
9758 -> 7634;
9758 -> 7630;
9759 -> 7630;
9760 -> 7630;
9761 -> 9746;
9761 -> 9760;
9762 -> 9747;
9762 -> 9760;
9763 -> 9747;
9763 -> 9760;
9764 -> 9748;
9764 -> 9760;
9765 -> 9749;
9765 -> 9760;
9766 -> 9750;
9766 -> 9760;
9767 -> 9757;
9767 -> 9760;
9768 -> 9758;
9768 -> 9760;
9769 -> 9759;
9769 -> 9760;
9770 -> 9759;
9770 -> 9760;
9771 -> 9760;
9772 -> 9770;
9772 -> 9771;
9773 -> 9771;
9774 -> 9773;
9774 -> 9771;
9775 -> 9773;
9775 -> 9771;
9776 -> 9773;
9776 -> 9771;
9777 -> 9773;
9777 -> 9771;
9778 -> 0;
9778 -> 9773;
9778 -> 9771;
9779 -> 9770;
9779 -> 9760;
9780 -> 9770;
9780 -> 9760;
9781 -> 9770;
9781 -> 9760;
9782 -> 9770;
9782 -> 9760;
9783 -> 9770;
9783 -> 9760;
9784 -> 9770;
9784 -> 9760;
9785 -> 9770;
9785 -> 9760;
9786 -> 9770;
9786 -> 9760;
9787 -> 9760;
9788 -> 9766;
9788 -> 9787;
9788 -> 9760;
9789 -> 9760;
9790 -> 9765;
9790 -> 9789;
9790 -> 9760;
9791 -> 9760;
9792 -> 9761;
9792 -> 9791;
9792 -> 9760;
9793 -> 9761;
9793 -> 8496;
9793 -> 9762;
9793 -> 9760;
9794 -> 9761;
9794 -> 8496;
9794 -> 9763;
9794 -> 9760;
9795 -> 9793;
9795 -> 9794;
9795 -> 9760;
9796 -> 9761;
9796 -> 9770;
9796 -> 9760;
9797 -> 9762;
9797 -> 9760;
9798 -> 9797;
9798 -> 9770;
9798 -> 9760;
9799 -> 9763;
9799 -> 9770;
9799 -> 9760;
9800 -> 9765;
9800 -> 9770;
9800 -> 9760;
9801 -> 9764;
9801 -> 9760;
9802 -> 9801;
9802 -> 9770;
9802 -> 9760;
9803 -> 9769;
9803 -> 9760;
9804 -> 9766;
9804 -> 9803;
9805 -> 9803;
9806 -> 9804;
9806 -> 9805;
9807 -> 9770;
9807 -> 9805;
9808 -> 9806;
9808 -> 9805;
9809 -> 9807;
9809 -> 9805;
9810 -> 9808;
9810 -> 9809;
9810 -> 9805;
9811 -> 9808;
9811 -> 9809;
9811 -> 9745;
9811 -> 9773;
9811 -> 9774;
9811 -> 9775;
9811 -> 9776;
9811 -> 9777;
9811 -> 9778;
9811 -> 9779;
9811 -> 9800;
9811 -> 9780;
9811 -> 9802;
9811 -> 9781;
9811 -> 9782;
9811 -> 9783;
9811 -> 9798;
9811 -> 9784;
9811 -> 9799;
9811 -> 9785;
9811 -> 9786;
9811 -> 9796;
9811 -> 8496;
9811 -> 9805;
9812 -> 9805;
9813 -> 9812;
9814 -> 9811;
9814 -> 9770;
9814 -> 9760;
9815 -> 9760;
9816 -> 9766;
9816 -> 9815;
9817 -> 9816;
9817 -> 9811;
9817 -> 9814;
9817 -> 9815;
9818 -> 9817;
9818 -> 9760;
9819 -> 9818;
9819 -> 9770;
9819 -> 9760;
9820 -> 0;
9820 -> 9760;
9821 -> 9820;
9821 -> 9768;
9821 -> 9760;
9822 -> 9821;
9822 -> 9770;
9822 -> 9760;
9823 -> 9767;
9823 -> 9760;
9824 -> 9760;
9825 -> 9823;
9825 -> 9824;
9826 -> 9770;
9826 -> 9824;
9827 -> 9825;
9827 -> 9826;
9827 -> 9824;
9828 -> 9824;
9829 -> 9828;
9829 -> 9826;
9829 -> 9824;
9830 -> 9760;
9831 -> 9759;
9831 -> 7630;
9832 -> 7630;
9833 -> 9831;
9833 -> 9832;
9833 -> 9811;
9833 -> 9814;
9833 -> 9819;
9833 -> 9822;
9833 -> 9827;
9833 -> 9829;
9833 -> 0;
9833 -> 8496;
9833 -> 7630;
9834 -> 9833;
9834 -> 9832;
9835 -> 9833;
9835 -> 9832;
9836 -> 9834;
9836 -> 9832;
9837 -> 9832;
9838 -> 9836;
9838 -> 9837;
9839 -> 9835;
9839 -> 9837;
9840 -> 9839;
9840 -> 9833;
9840 -> 9837;
9841 -> 9840;
9841 -> 9832;
9842 -> 9833;
9842 -> 9832;
9843 -> 9833;
9843 -> 9832;
9844 -> 9832;
9845 -> 9843;
9845 -> 9841;
9845 -> 9844;
9845 -> 9832;
9846 -> 9843;
9846 -> 9841;
9846 -> 9832;
9847 -> 9833;
9847 -> 9832;
9848 -> 9832;
9849 -> 9833;
9849 -> 9848;
9849 -> 9846;
9849 -> 7630;
9850 -> 9833;
9850 -> 9832;
9851 -> 9833;
9851 -> 9832;
9852 -> 9833;
9852 -> 9832;
9853 -> 9833;
9853 -> 9832;
9854 -> 9851;
9854 -> 9832;
9855 -> 9854;
9856 -> 9853;
9856 -> 9855;
9857 -> 9856;
9857 -> 9849;
9857 -> 9855;
9858 -> 9857;
9858 -> 9854;
9859 -> 9854;
9860 -> 9858;
9860 -> 9859;
9860 -> 9854;
9861 -> 9850;
9861 -> 9860;
9862 -> 9860;
9863 -> 9861;
9863 -> 9862;
9864 -> 9862;
9865 -> 9861;
9865 -> 9864;
9865 -> 9860;
9866 -> 9861;
9866 -> 9862;
9867 -> 9861;
9867 -> 9862;
9868 -> 9867;
9868 -> 9865;
9868 -> 9862;
9869 -> 9866;
9869 -> 9868;
9869 -> 9865;
9869 -> 9862;
9870 -> 9832;
9871 -> 9853;
9871 -> 9870;
9872 -> 9870;
9873 -> 9871;
9873 -> 9869;
9873 -> 9872;
9874 -> 9870;
9875 -> 9873;
9875 -> 9832;
9876 -> 9852;
9876 -> 9832;
9877 -> 9876;
9878 -> 9853;
9878 -> 9877;
9879 -> 9878;
9879 -> 9875;
9879 -> 9877;
9880 -> 9879;
9880 -> 9876;
9881 -> 9876;
9882 -> 9880;
9882 -> 9881;
9882 -> 9876;
9883 -> 9850;
9883 -> 9882;
9884 -> 9882;
9885 -> 9883;
9885 -> 9884;
9886 -> 9853;
9886 -> 9855;
9887 -> 9855;
9888 -> 9887;
9888 -> 9854;
9889 -> 9888;
9889 -> 9859;
9889 -> 9854;
9890 -> 9853;
9890 -> 9870;
9891 -> 9890;
9891 -> 9883;
9891 -> 9870;
9892 -> 9853;
9892 -> 9877;
9893 -> 9891;
9894 -> 9853;
9894 -> 9877;
9895 -> 9877;
9895 -> 9876;
9896 -> 9895;
9896 -> 9881;
9896 -> 9876;
9897 -> 9759;
9897 -> 7630;
9898 -> 9897;
9898 -> 7607;
9899 -> 9898;
9899 -> 3519;
9900 -> 9899;
9900 -> 279;
9901 -> 279;
9902 -> 9900;
9902 -> 9901;
9903 -> 9901;
9904 -> 9901;
9905 -> 9904;
9905 -> 9902;
9905 -> 9891;
9905 -> 9901;
9906 -> 9905;
9906 -> 9904;
9907 -> 9904;
9908 -> 9906;
9908 -> 9907;
9909 -> 9903;
9909 -> 9901;
9910 -> 9901;
9911 -> 9909;
9911 -> 9910;
9911 -> 9906;
9911 -> 9903;
9911 -> 9901;
9912 -> 9911;
9912 -> 9910;
9913 -> 9912;
9913 -> 9911;
9913 -> 3563;
9913 -> 9910;
9914 -> 9912;
9914 -> 9911;
9914 -> 9913;
9914 -> 9910;
9915 -> 9911;
9915 -> 9910;
9916 -> 9911;
9916 -> 9910;
9917 -> 9915;
9917 -> 9910;
9918 -> 9916;
9918 -> 9917;
9918 -> 9914;
9918 -> 9910;
9919 -> 9916;
9919 -> 9918;
9919 -> 9910;
9920 -> 9910;
9921 -> 9919;
9921 -> 9920;
9922 -> 9920;
9923 -> 9921;
9923 -> 9922;
9924 -> 9923;
9924 -> 0;
9924 -> 9920;
9925 -> 9924;
9925 -> 9920;
9926 -> 9919;
9926 -> 9920;
9927 -> 9919;
9927 -> 9920;
9928 -> 9926;
9928 -> 9920;
9929 -> 9927;
9929 -> 9928;
9929 -> 9925;
9929 -> 9920;
9930 -> 9927;
9930 -> 9929;
9930 -> 9920;
9931 -> 9916;
9931 -> 9930;
9931 -> 9910;
9932 -> 9910;
9933 -> 9932;
9934 -> 9931;
9934 -> 3563;
9934 -> 9932;
9935 -> 9911;
9935 -> 9910;
9936 -> 9911;
9936 -> 9910;
9937 -> 9935;
9937 -> 9910;
9938 -> 9910;
9939 -> 9937;
9939 -> 9938;
9940 -> 9936;
9940 -> 9938;
9941 -> 9939;
9941 -> 9938;
9942 -> 9940;
9942 -> 9941;
9942 -> 9934;
9942 -> 9938;
9943 -> 9940;
9943 -> 9942;
9943 -> 9938;
9944 -> 9910;
9945 -> 9936;
9945 -> 9943;
9945 -> 9910;
9946 -> 9910;
9947 -> 9946;
9948 -> 9911;
9948 -> 9910;
9949 -> 9911;
9949 -> 9910;
9950 -> 9948;
9950 -> 9910;
9951 -> 9901;
9952 -> 9951;
9952 -> 9903;
9952 -> 9901;
9953 -> 9903;
9953 -> 9901;
9954 -> 9901;
9955 -> 9901;
9956 -> 9953;
9956 -> 9955;
9957 -> 9954;
9957 -> 9955;
9958 -> 9955;
9959 -> 9956;
9959 -> 9958;
9959 -> 9955;
9960 -> 9956;
9960 -> 9945;
9960 -> 9955;
9961 -> 9956;
9961 -> 9955;
9962 -> 9955;
9963 -> 9957;
9963 -> 9955;
9964 -> 9961;
9964 -> 9962;
9964 -> 9963;
9964 -> 9945;
9964 -> 9952;
9964 -> 9954;
9964 -> 9955;
9965 -> 9955;
9966 -> 9964;
9966 -> 9965;
9966 -> 9955;
9967 -> 9964;
9967 -> 9955;
9968 -> 9955;
9969 -> 9967;
9969 -> 9968;
9970 -> 9967;
9970 -> 9968;
9971 -> 9969;
9971 -> 9968;
9972 -> 9968;
9973 -> 9972;
9973 -> 9971;
9973 -> 9967;
9973 -> 9968;
9974 -> 9967;
9974 -> 9968;
9975 -> 9967;
9975 -> 9968;
9976 -> 9974;
9976 -> 9968;
9977 -> 9968;
9978 -> 9976;
9978 -> 9977;
9979 -> 9975;
9979 -> 9977;
9980 -> 9978;
9980 -> 9977;
9981 -> 9977;
9982 -> 9980;
9982 -> 9981;
9983 -> 9979;
9983 -> 9981;
9984 -> 9982;
9984 -> 9981;
9985 -> 9981;
9986 -> 9985;
9986 -> 9984;
9986 -> 9973;
9986 -> 9981;
9987 -> 9977;
9988 -> 9979;
9988 -> 9987;
9989 -> 9987;
9990 -> 9988;
9990 -> 9986;
9990 -> 9989;
9991 -> 9987;
9992 -> 9990;
9992 -> 9977;
9993 -> 9977;
9994 -> 9992;
9994 -> 9993;
9994 -> 9977;
9995 -> 9992;
9995 -> 9979;
9995 -> 9994;
9996 -> 9979;
9996 -> 9986;
9996 -> 0;
9996 -> 9977;
9997 -> 9996;
9997 -> 9979;
9997 -> 9977;
9998 -> 9974;
9998 -> 9968;
9999 -> 9974;
9999 -> 9986;
9999 -> 9995;
9999 -> 9997;
9999 -> 9975;
9999 -> 9968;
10000 -> 9968;
10001 -> 9999;
10001 -> 10000;
10002 -> 9998;
10002 -> 10000;
10003 -> 10001;
10003 -> 10000;
10004 -> 10000;
10005 -> 10003;
10005 -> 10004;
10006 -> 10002;
10006 -> 10004;
10007 -> 10004;
10008 -> 10001;
10008 -> 10005;
10008 -> 10002;
10008 -> 10000;
10009 -> 10008;
10009 -> 10002;
10009 -> 10000;
10010 -> 10002;
10010 -> 10008;
10010 -> 10009;
10010 -> 10000;
10011 -> 10000;
10012 -> 9968;
10013 -> 10010;
10013 -> 10012;
10013 -> 9968;
10014 -> 10010;
10014 -> 10013;
10015 -> 10010;
10015 -> 9975;
10015 -> 10013;
10016 -> 9974;
10016 -> 9968;
10017 -> 9974;
10017 -> 10014;
10017 -> 10015;
10017 -> 9968;
10018 -> 9968;
10019 -> 10016;
10019 -> 10018;
10020 -> 10018;
10021 -> 10019;
10021 -> 10020;
10022 -> 10020;
10023 -> 10018;
10024 -> 9968;
10025 -> 10017;
10025 -> 10024;
10025 -> 9968;
10026 -> 10017;
10026 -> 10025;
10027 -> 10017;
10027 -> 9975;
10027 -> 10025;
10028 -> 9967;
10028 -> 10026;
10028 -> 10027;
10028 -> 9955;
10029 -> 9967;
10029 -> 9968;
10030 -> 9967;
10030 -> 9968;
10031 -> 10029;
10031 -> 9968;
10032 -> 9968;
10033 -> 10031;
10033 -> 10032;
10034 -> 10030;
10034 -> 10032;
10035 -> 10033;
10035 -> 10032;
10036 -> 10032;
10037 -> 10035;
10037 -> 10036;
10038 -> 10034;
10038 -> 10036;
10039 -> 10037;
10039 -> 10036;
10040 -> 10036;
10041 -> 10039;
10041 -> 10040;
10042 -> 10038;
10042 -> 10040;
10043 -> 10041;
10043 -> 10040;
10044 -> 10040;
10045 -> 10044;
10045 -> 10043;
10045 -> 10028;
10045 -> 10040;
10046 -> 10036;
10047 -> 10038;
10047 -> 10046;
10048 -> 10036;
10049 -> 10033;
10049 -> 10045;
10049 -> 10034;
10049 -> 10032;
10050 -> 10049;
10050 -> 10034;
10050 -> 10032;
10051 -> 10034;
10051 -> 10049;
10051 -> 10050;
10051 -> 10032;
10052 -> 10029;
10052 -> 9968;
10053 -> 10029;
10053 -> 10049;
10053 -> 10050;
10053 -> 10051;
10053 -> 10030;
10053 -> 9968;
10054 -> 9968;
10055 -> 10052;
10055 -> 10054;
10056 -> 10054;
10057 -> 10055;
10057 -> 10056;
10058 -> 10056;
10059 -> 10054;
10060 -> 9968;
10061 -> 10053;
10061 -> 10060;
10061 -> 9968;
10062 -> 10053;
10062 -> 10061;
10063 -> 10053;
10063 -> 10030;
10063 -> 10061;
10064 -> 9967;
10064 -> 10062;
10064 -> 10063;
10064 -> 9955;
10065 -> 9967;
10065 -> 9968;
10066 -> 9967;
10066 -> 9968;
10067 -> 10065;
10067 -> 9968;
10068 -> 9968;
10069 -> 10067;
10069 -> 10068;
10070 -> 10066;
10070 -> 10068;
10071 -> 10069;
10071 -> 10068;
10072 -> 10068;
10073 -> 10071;
10073 -> 10072;
10074 -> 10070;
10074 -> 10072;
10075 -> 10073;
10075 -> 10072;
10076 -> 10072;
10077 -> 10068;
10078 -> 10070;
10078 -> 10077;
10079 -> 10068;
10080 -> 9967;
10080 -> 9968;
10081 -> 9967;
10081 -> 9968;
10082 -> 10080;
10082 -> 9968;
10083 -> 9968;
10084 -> 10082;
10084 -> 10083;
10085 -> 10081;
10085 -> 10083;
10086 -> 10084;
10086 -> 10083;
10087 -> 10083;
10088 -> 9968;
10089 -> 10081;
10089 -> 10088;
10090 -> 10088;
10091 -> 10088;
10092 -> 9968;
10093 -> 10064;
10093 -> 9955;
10094 -> 9955;
10095 -> 10094;
10096 -> 9902;
10096 -> 9901;
10097 -> 10096;
10097 -> 275;
10098 -> 10097;
10098 -> 276;
10098 -> 275;
10099 -> 276;
10099 -> 260;
10100 -> 260;
10101 -> 263;
10101 -> 10100;
10101 -> 260;
10102 -> 10099;
10102 -> 10101;
10103 -> 10101;
10104 -> 10102;
10104 -> 10103;
10104 -> 276;
10104 -> 10098;
10104 -> 10093;
10104 -> 10101;
10105 -> 10103;
10106 -> 10104;
10106 -> 10105;
10107 -> 10103;
10108 -> 10104;
10108 -> 10103;
10109 -> 10103;
10110 -> 10104;
10110 -> 10101;
10111 -> 1141;
10111 -> 10110;
10112 -> 0;
10112 -> 260;
10113 -> 268;
10113 -> 260;
10114 -> 265;
10114 -> 10099;
10114 -> 262;
10114 -> 10111;
10114 -> 260;
10115 -> 10114;
10115 -> 260;
10116 -> 260;
10117 -> 10115;
10117 -> 10116;
10118 -> 0;
10118 -> 10116;
10119 -> 10118;
10120 -> 260;
10121 -> 10114;
10121 -> 10104;
10121 -> 233;
10121 -> 0;
10121 -> 2608;
10121 -> 2636;
10121 -> 2609;
10121 -> 2637;
10121 -> 2631;
10121 -> 2638;
10121 -> 2632;
10121 -> 2606;
10121 -> 2639;
10121 -> 230;
10121 -> 260;
10122 -> 260;
10123 -> 10122;
10124 -> 10121;
10124 -> 10123;
10124 -> 260;
10125 -> 0;
10127 -> 10125;
10127 -> 10126;
10128 -> 10126;
10129 -> 10126;
10130 -> 10126;
10131 -> 10126;
10132 -> 10126;
10133 -> 10126;
10134 -> 10126;
10135 -> 10126;
10136 -> 10126;
10137 -> 10126;
10138 -> 10126;
10139 -> 10126;
10140 -> 10126;
10141 -> 10126;
10142 -> 10126;
10143 -> 10126;
10144 -> 10126;
10145 -> 10126;
10146 -> 10126;
10147 -> 10126;
10148 -> 10126;
10149 -> 10126;
10150 -> 10126;
10151 -> 10126;
10152 -> 10126;
10153 -> 10126;
10154 -> 10126;
10155 -> 10127;
10155 -> 10126;
10156 -> 10128;
10156 -> 10126;
10157 -> 10129;
10157 -> 10126;
10158 -> 10130;
10158 -> 10126;
10159 -> 10131;
10159 -> 10126;
10160 -> 10132;
10160 -> 10126;
10161 -> 10133;
10161 -> 10126;
10162 -> 10134;
10162 -> 10126;
10163 -> 10135;
10163 -> 10126;
10164 -> 10136;
10164 -> 10126;
10165 -> 10137;
10165 -> 10126;
10166 -> 10138;
10166 -> 10126;
10167 -> 10139;
10167 -> 10126;
10168 -> 10140;
10168 -> 10126;
10169 -> 10141;
10169 -> 10126;
10170 -> 10142;
10170 -> 10126;
10171 -> 10143;
10171 -> 10126;
10172 -> 10144;
10172 -> 10126;
10173 -> 10145;
10173 -> 10126;
10174 -> 10126;
10175 -> 10126;
10176 -> 10146;
10176 -> 10126;
10177 -> 10147;
10177 -> 10126;
10178 -> 10126;
10179 -> 10148;
10179 -> 10126;
10180 -> 10149;
10180 -> 10126;
10181 -> 10150;
10181 -> 10126;
10182 -> 10152;
10182 -> 10126;
10183 -> 10126;
10184 -> 10151;
10184 -> 10126;
10185 -> 0;
10185 -> 10126;
10186 -> 10153;
10186 -> 10126;
10187 -> 10155;
10187 -> 10154;
10188 -> 10156;
10188 -> 10154;
10189 -> 10157;
10189 -> 10154;
10190 -> 10158;
10190 -> 10154;
10191 -> 10159;
10191 -> 10154;
10192 -> 10160;
10192 -> 10154;
10193 -> 10161;
10193 -> 10154;
10194 -> 10162;
10194 -> 10154;
10195 -> 10163;
10195 -> 10154;
10196 -> 10164;
10196 -> 10154;
10197 -> 10165;
10197 -> 10154;
10198 -> 10166;
10198 -> 10154;
10199 -> 10167;
10199 -> 10154;
10200 -> 10168;
10200 -> 10154;
10201 -> 10169;
10201 -> 10154;
10202 -> 10170;
10202 -> 10154;
10203 -> 10171;
10203 -> 10154;
10204 -> 10172;
10204 -> 10154;
10205 -> 10173;
10205 -> 10154;
10206 -> 10174;
10206 -> 10154;
10207 -> 10175;
10207 -> 10154;
10208 -> 10176;
10208 -> 10154;
10209 -> 10177;
10209 -> 10154;
10210 -> 10178;
10210 -> 10154;
10211 -> 10179;
10211 -> 10154;
10212 -> 10180;
10212 -> 10154;
10213 -> 10181;
10213 -> 10154;
10214 -> 10182;
10214 -> 10154;
10215 -> 10183;
10215 -> 10154;
10216 -> 10184;
10216 -> 10154;
10217 -> 10185;
10217 -> 10154;
10218 -> 10186;
10218 -> 10154;
10219 -> 10154;
10220 -> 10187;
10220 -> 10154;
10221 -> 10188;
10221 -> 10154;
10222 -> 10189;
10222 -> 10154;
10223 -> 10190;
10223 -> 10154;
10224 -> 10191;
10224 -> 10154;
10225 -> 10196;
10225 -> 10154;
10226 -> 10197;
10226 -> 10154;
10227 -> 10198;
10227 -> 10154;
10228 -> 10199;
10228 -> 10154;
10229 -> 10216;
10229 -> 10154;
10230 -> 10193;
10230 -> 10154;
10231 -> 10194;
10231 -> 10154;
10232 -> 10200;
10232 -> 10154;
10233 -> 10201;
10233 -> 10154;
10234 -> 10202;
10234 -> 10154;
10235 -> 10203;
10235 -> 10154;
10236 -> 10235;
10236 -> 10154;
10237 -> 10204;
10237 -> 10154;
10238 -> 10205;
10238 -> 10154;
10239 -> 10206;
10239 -> 10154;
10240 -> 10207;
10240 -> 10154;
10241 -> 10208;
10241 -> 10154;
10242 -> 10209;
10242 -> 10154;
10243 -> 10210;
10243 -> 10154;
10244 -> 10211;
10244 -> 10154;
10245 -> 10212;
10245 -> 10154;
10246 -> 10213;
10246 -> 10154;
10247 -> 10214;
10247 -> 10154;
10248 -> 10215;
10248 -> 10154;
10249 -> 10219;
10249 -> 10220;
10249 -> 10221;
10249 -> 10222;
10249 -> 10223;
10249 -> 10224;
10249 -> 10225;
10249 -> 10226;
10249 -> 10227;
10249 -> 10228;
10249 -> 10229;
10249 -> 10230;
10249 -> 10231;
10249 -> 10232;
10249 -> 10233;
10249 -> 10234;
10249 -> 10236;
10249 -> 10237;
10249 -> 10238;
10249 -> 10239;
10249 -> 10240;
10249 -> 10241;
10249 -> 10242;
10249 -> 10243;
10249 -> 10244;
10249 -> 10245;
10249 -> 10246;
10249 -> 10247;
10249 -> 10248;
10249 -> 10126;
10249 -> 10174;
10249 -> 10154;
10250 -> 10219;
10250 -> 10154;
10251 -> 10219;
10251 -> 10154;
10252 -> 10219;
10252 -> 10154;
10253 -> 10192;
10253 -> 10154;
10254 -> 10253;
10254 -> 10219;
10254 -> 10154;
10255 -> 10195;
10255 -> 10219;
10255 -> 10154;
10256 -> 10217;
10256 -> 10219;
10256 -> 10154;
10257 -> 10218;
10257 -> 10219;
10257 -> 10154;
10258 -> 10126;
10259 -> 0;
10261 -> 10259;
10261 -> 10260;
10262 -> 10260;
10263 -> 10260;
10264 -> 10260;
10265 -> 10260;
10266 -> 10260;
10267 -> 10260;
10268 -> 10260;
10269 -> 10260;
10270 -> 10260;
10271 -> 10260;
10272 -> 10260;
10273 -> 10260;
10274 -> 10260;
10275 -> 10260;
10276 -> 10260;
10277 -> 10260;
10278 -> 10260;
10279 -> 10260;
10280 -> 10260;
10281 -> 10260;
10282 -> 10260;
10283 -> 10260;
10284 -> 10260;
10285 -> 10260;
10286 -> 10260;
10287 -> 10260;
10288 -> 10260;
10289 -> 10261;
10289 -> 10260;
10290 -> 10262;
10290 -> 10260;
10291 -> 10263;
10291 -> 10260;
10292 -> 10264;
10292 -> 10260;
10293 -> 10265;
10293 -> 10260;
10294 -> 10266;
10294 -> 10260;
10295 -> 10267;
10295 -> 10260;
10296 -> 10268;
10296 -> 10260;
10297 -> 10269;
10297 -> 10260;
10298 -> 10270;
10298 -> 10260;
10299 -> 10271;
10299 -> 10260;
10300 -> 10272;
10300 -> 10260;
10301 -> 10273;
10301 -> 10260;
10302 -> 10274;
10302 -> 10260;
10303 -> 10275;
10303 -> 10260;
10304 -> 10276;
10304 -> 10260;
10305 -> 10277;
10305 -> 10260;
10306 -> 10278;
10306 -> 10260;
10307 -> 10279;
10307 -> 10260;
10308 -> 10260;
10309 -> 10260;
10310 -> 10280;
10310 -> 10260;
10311 -> 10281;
10311 -> 10260;
10312 -> 10260;
10313 -> 10282;
10313 -> 10260;
10314 -> 10283;
10314 -> 10260;
10315 -> 10284;
10315 -> 10260;
10316 -> 10286;
10316 -> 10260;
10317 -> 10260;
10318 -> 10285;
10318 -> 10260;
10319 -> 0;
10319 -> 10260;
10320 -> 10287;
10320 -> 10260;
10321 -> 10289;
10321 -> 10288;
10322 -> 10290;
10322 -> 10288;
10323 -> 10291;
10323 -> 10288;
10324 -> 10292;
10324 -> 10288;
10325 -> 10293;
10325 -> 10288;
10326 -> 10294;
10326 -> 10288;
10327 -> 10295;
10327 -> 10288;
10328 -> 10296;
10328 -> 10288;
10329 -> 10297;
10329 -> 10288;
10330 -> 10298;
10330 -> 10288;
10331 -> 10299;
10331 -> 10288;
10332 -> 10300;
10332 -> 10288;
10333 -> 10301;
10333 -> 10288;
10334 -> 10302;
10334 -> 10288;
10335 -> 10303;
10335 -> 10288;
10336 -> 10304;
10336 -> 10288;
10337 -> 10305;
10337 -> 10288;
10338 -> 10306;
10338 -> 10288;
10339 -> 10307;
10339 -> 10288;
10340 -> 10308;
10340 -> 10288;
10341 -> 10309;
10341 -> 10288;
10342 -> 10310;
10342 -> 10288;
10343 -> 10311;
10343 -> 10288;
10344 -> 10312;
10344 -> 10288;
10345 -> 10313;
10345 -> 10288;
10346 -> 10314;
10346 -> 10288;
10347 -> 10315;
10347 -> 10288;
10348 -> 10316;
10348 -> 10288;
10349 -> 10317;
10349 -> 10288;
10350 -> 10318;
10350 -> 10288;
10351 -> 10319;
10351 -> 10288;
10352 -> 10320;
10352 -> 10288;
10353 -> 10288;
10354 -> 10321;
10354 -> 10288;
10355 -> 10322;
10355 -> 10288;
10356 -> 10323;
10356 -> 10288;
10357 -> 10324;
10357 -> 10288;
10358 -> 10325;
10358 -> 10288;
10359 -> 10330;
10359 -> 10288;
10360 -> 10331;
10360 -> 10288;
10361 -> 10332;
10361 -> 10288;
10362 -> 10333;
10362 -> 10288;
10363 -> 10350;
10363 -> 10288;
10364 -> 10327;
10364 -> 10288;
10365 -> 10328;
10365 -> 10288;
10366 -> 10334;
10366 -> 10288;
10367 -> 10335;
10367 -> 10288;
10368 -> 10336;
10368 -> 10288;
10369 -> 10337;
10369 -> 10288;
10370 -> 10369;
10370 -> 10288;
10371 -> 10338;
10371 -> 10288;
10372 -> 10339;
10372 -> 10288;
10373 -> 10340;
10373 -> 10288;
10374 -> 10341;
10374 -> 10288;
10375 -> 10342;
10375 -> 10288;
10376 -> 10343;
10376 -> 10288;
10377 -> 10344;
10377 -> 10288;
10378 -> 10345;
10378 -> 10288;
10379 -> 10346;
10379 -> 10288;
10380 -> 10347;
10380 -> 10288;
10381 -> 10348;
10381 -> 10288;
10382 -> 10349;
10382 -> 10288;
10383 -> 10353;
10383 -> 10354;
10383 -> 10355;
10383 -> 10356;
10383 -> 10357;
10383 -> 10358;
10383 -> 10359;
10383 -> 10360;
10383 -> 10361;
10383 -> 10362;
10383 -> 10363;
10383 -> 10364;
10383 -> 10365;
10383 -> 10366;
10383 -> 10367;
10383 -> 10368;
10383 -> 10370;
10383 -> 10371;
10383 -> 10372;
10383 -> 10373;
10383 -> 10374;
10383 -> 10375;
10383 -> 10376;
10383 -> 10377;
10383 -> 10378;
10383 -> 10379;
10383 -> 10380;
10383 -> 10381;
10383 -> 10382;
10383 -> 10260;
10383 -> 10308;
10383 -> 10288;
10384 -> 10353;
10384 -> 10288;
10385 -> 10353;
10385 -> 10288;
10386 -> 10353;
10386 -> 10288;
10387 -> 10326;
10387 -> 10288;
10388 -> 10387;
10388 -> 10353;
10388 -> 10288;
10389 -> 10329;
10389 -> 10353;
10389 -> 10288;
10390 -> 10351;
10390 -> 10353;
10390 -> 10288;
10391 -> 10352;
10391 -> 10353;
10391 -> 10288;
10394 -> 10392;
10394 -> 10393;
10395 -> 10260;
10395 -> 10393;
10396 -> 10394;
10396 -> 10395;
10396 -> 10383;
10396 -> 10393;
10397 -> 10395;
10397 -> 10393;
10398 -> 10393;
10399 -> 10393;
10400 -> 10397;
10400 -> 10399;
10401 -> 10398;
10401 -> 10399;
10402 -> 10400;
10402 -> 10383;
10402 -> 10399;
10403 -> 10400;
10403 -> 10383;
10403 -> 10399;
10404 -> 10400;
10404 -> 10383;
10404 -> 10399;
10405 -> 10400;
10405 -> 10383;
10405 -> 10399;
10406 -> 10400;
10406 -> 10383;
10406 -> 10388;
10406 -> 10399;
10407 -> 10400;
10407 -> 10383;
10407 -> 10399;
10408 -> 10400;
10408 -> 10383;
10408 -> 10399;
10409 -> 10400;
10409 -> 10383;
10409 -> 10384;
10409 -> 10389;
10409 -> 10399;
10410 -> 10400;
10410 -> 10383;
10410 -> 10399;
10411 -> 10400;
10411 -> 10383;
10411 -> 10399;
10412 -> 10400;
10412 -> 10383;
10412 -> 10399;
10413 -> 10400;
10413 -> 10383;
10413 -> 10399;
10414 -> 10400;
10414 -> 10383;
10414 -> 10399;
10415 -> 10400;
10415 -> 10383;
10415 -> 10399;
10416 -> 10400;
10416 -> 10383;
10416 -> 10399;
10417 -> 10400;
10417 -> 10383;
10417 -> 10399;
10418 -> 10400;
10418 -> 10383;
10418 -> 10399;
10419 -> 10400;
10419 -> 10383;
10419 -> 10399;
10420 -> 10400;
10420 -> 10383;
10420 -> 10399;
10421 -> 10400;
10421 -> 10383;
10421 -> 10399;
10422 -> 10400;
10422 -> 10383;
10422 -> 10399;
10423 -> 10400;
10423 -> 10383;
10423 -> 10399;
10424 -> 10400;
10424 -> 10383;
10424 -> 10399;
10425 -> 10400;
10425 -> 10383;
10425 -> 10399;
10426 -> 10400;
10426 -> 10383;
10426 -> 10399;
10427 -> 10400;
10427 -> 10383;
10427 -> 10399;
10428 -> 10400;
10428 -> 10383;
10428 -> 10399;
10429 -> 10400;
10429 -> 10383;
10429 -> 10399;
10430 -> 10400;
10430 -> 10383;
10430 -> 10399;
10431 -> 10400;
10431 -> 10383;
10431 -> 10399;
10432 -> 10400;
10432 -> 10383;
10432 -> 10385;
10432 -> 10390;
10432 -> 10399;
10433 -> 10400;
10433 -> 10383;
10433 -> 10386;
10433 -> 10391;
10433 -> 10399;
10434 -> 10399;
10435 -> 10402;
10435 -> 10434;
10436 -> 10403;
10436 -> 10434;
10437 -> 10404;
10437 -> 10434;
10438 -> 10405;
10438 -> 10434;
10439 -> 10406;
10439 -> 10434;
10440 -> 10407;
10440 -> 10434;
10441 -> 10408;
10441 -> 10434;
10442 -> 10409;
10442 -> 10434;
10443 -> 10410;
10443 -> 10434;
10444 -> 10411;
10444 -> 10434;
10445 -> 10412;
10445 -> 10434;
10446 -> 10413;
10446 -> 10434;
10447 -> 10414;
10447 -> 10434;
10448 -> 10415;
10448 -> 10434;
10449 -> 10416;
10449 -> 10434;
10450 -> 10417;
10450 -> 10434;
10451 -> 10418;
10451 -> 10434;
10452 -> 10419;
10452 -> 10434;
10453 -> 10420;
10453 -> 10434;
10454 -> 10421;
10454 -> 10434;
10455 -> 10422;
10455 -> 10434;
10456 -> 10423;
10456 -> 10434;
10457 -> 10424;
10457 -> 10434;
10458 -> 10425;
10458 -> 10434;
10459 -> 10426;
10459 -> 10434;
10460 -> 10427;
10460 -> 10434;
10461 -> 10428;
10461 -> 10434;
10462 -> 10429;
10462 -> 10434;
10463 -> 10430;
10463 -> 10434;
10464 -> 10431;
10464 -> 10434;
10465 -> 10432;
10465 -> 10434;
10466 -> 10433;
10466 -> 10434;
10467 -> 10401;
10467 -> 10434;
10468 -> 10434;
10469 -> 10468;
10469 -> 10435;
10469 -> 10436;
10469 -> 10437;
10469 -> 10438;
10469 -> 10439;
10469 -> 10444;
10469 -> 10445;
10469 -> 10446;
10469 -> 10447;
10469 -> 10464;
10469 -> 10441;
10469 -> 10442;
10469 -> 10448;
10469 -> 10449;
10469 -> 10450;
10469 -> 10451;
10469 -> 10452;
10469 -> 10453;
10469 -> 10454;
10469 -> 10455;
10469 -> 10456;
10469 -> 10457;
10469 -> 10458;
10469 -> 10459;
10469 -> 10460;
10469 -> 10461;
10469 -> 10462;
10469 -> 10463;
10469 -> 10383;
10469 -> 10384;
10469 -> 10389;
10469 -> 10385;
10469 -> 10390;
10469 -> 10386;
10469 -> 10391;
10469 -> 10388;
10469 -> 10387;
10469 -> 10434;
10470 -> 10468;
10470 -> 10434;
10471 -> 10468;
10471 -> 10434;
10472 -> 10468;
10472 -> 10434;
10473 -> 10440;
10473 -> 10434;
10474 -> 10473;
10474 -> 10468;
10474 -> 10434;
10475 -> 10443;
10475 -> 10468;
10475 -> 10434;
10476 -> 10394;
10476 -> 10398;
10476 -> 10393;
10477 -> 10398;
10478 -> 10121;
10478 -> 10122;
10479 -> 10121;
10479 -> 10122;
10480 -> 10121;
10480 -> 10122;
10481 -> 10121;
10481 -> 10122;
10482 -> 10478;
10482 -> 10122;
10483 -> 10481;
10483 -> 10122;
10484 -> 10479;
10484 -> 10122;
10485 -> 10480;
10485 -> 10122;
10486 -> 10122;
10487 -> 10122;
10488 -> 10482;
10488 -> 10487;
10489 -> 10483;
10489 -> 10487;
10490 -> 10484;
10490 -> 10487;
10491 -> 10485;
10491 -> 10487;
10492 -> 10486;
10492 -> 10487;
10493 -> 10486;
10493 -> 10487;
10494 -> 10486;
10494 -> 10487;
10495 -> 10486;
10495 -> 10487;
10496 -> 10487;
10497 -> 10489;
10497 -> 10496;
10497 -> 10487;
10498 -> 10495;
10498 -> 10487;
10499 -> 10491;
10499 -> 10487;
10500 -> 10499;
10500 -> 10124;
10500 -> 10487;
10501 -> 10488;
10501 -> 10487;
10502 -> 10489;
10502 -> 10487;
10503 -> 10500;
10503 -> 10487;
10504 -> 10492;
10504 -> 10487;
10505 -> 10493;
10505 -> 10487;
10506 -> 10494;
10506 -> 10487;
10507 -> 10495;
10507 -> 10487;
10508 -> 10487;
10509 -> 0;
10509 -> 10487;
10510 -> 10489;
10510 -> 10500;
10510 -> 10487;
10512 -> 10511;
10513 -> 10511;
10515 -> 10513;
10516 -> 10514;
10516 -> 10515;
10516 -> 10512;
10517 -> 10513;
10517 -> 10487;
10518 -> 10487;
10519 -> 10509;
10519 -> 10518;
10520 -> 10510;
10520 -> 10518;
10521 -> 10510;
10521 -> 10518;
10522 -> 10517;
10522 -> 10518;
10523 -> 10507;
10523 -> 10518;
10524 -> 10508;
10524 -> 10518;
10525 -> 10508;
10525 -> 10518;
10526 -> 10519;
10526 -> 10518;
10527 -> 10520;
10527 -> 10518;
10528 -> 10521;
10528 -> 10518;
10529 -> 10522;
10529 -> 10518;
10530 -> 10523;
10530 -> 10518;
10531 -> 10518;
10532 -> 10531;
10532 -> 10526;
10532 -> 10527;
10532 -> 10528;
10532 -> 10529;
10532 -> 10530;
10532 -> 0;
10532 -> 10500;
10532 -> 10516;
10532 -> 10518;
10533 -> 10531;
10533 -> 10518;
10534 -> 10524;
10534 -> 10531;
10534 -> 10518;
10535 -> 10487;
10536 -> 10501;
10536 -> 10535;
10537 -> 10502;
10537 -> 10535;
10538 -> 10503;
10538 -> 10535;
10539 -> 10504;
10539 -> 10535;
10540 -> 10505;
10540 -> 10535;
10541 -> 10506;
10541 -> 10535;
10542 -> 10507;
10542 -> 10535;
10543 -> 10508;
10543 -> 10535;
10544 -> 10508;
10544 -> 10535;
10545 -> 10508;
10545 -> 10535;
10546 -> 10508;
10546 -> 10535;
10547 -> 10508;
10547 -> 10535;
10548 -> 10508;
10548 -> 10535;
10549 -> 10536;
10549 -> 10535;
10550 -> 10537;
10550 -> 10535;
10551 -> 10538;
10551 -> 10535;
10552 -> 10539;
10552 -> 10535;
10553 -> 10540;
10553 -> 10535;
10554 -> 10541;
10554 -> 10535;
10555 -> 10542;
10555 -> 10535;
10556 -> 10543;
10556 -> 10535;
10557 -> 10544;
10557 -> 10535;
10558 -> 10545;
10558 -> 10535;
10559 -> 10545;
10559 -> 10532;
10559 -> 10535;
10560 -> 10559;
10560 -> 10532;
10560 -> 10533;
10560 -> 10534;
10560 -> 10535;
10561 -> 10546;
10561 -> 10535;
10562 -> 10547;
10562 -> 10535;
10563 -> 10535;
10564 -> 10549;
10564 -> 10563;
10565 -> 10550;
10565 -> 10563;
10566 -> 10551;
10566 -> 10563;
10567 -> 10552;
10567 -> 10563;
10568 -> 10553;
10568 -> 10563;
10569 -> 10554;
10569 -> 10563;
10570 -> 10555;
10570 -> 10563;
10571 -> 10556;
10571 -> 10563;
10572 -> 10557;
10572 -> 10563;
10573 -> 10558;
10573 -> 10563;
10574 -> 10560;
10574 -> 10563;
10575 -> 10561;
10575 -> 10563;
10576 -> 10562;
10576 -> 10563;
10577 -> 10548;
10577 -> 10563;
10578 -> 10564;
10578 -> 10563;
10579 -> 10566;
10579 -> 10563;
10580 -> 10574;
10580 -> 10563;
10581 -> 10570;
10581 -> 10563;
10582 -> 10575;
10582 -> 10563;
10583 -> 10576;
10583 -> 10563;
10584 -> 10563;
10585 -> 10584;
10585 -> 10578;
10585 -> 10579;
10585 -> 10580;
10585 -> 10581;
10585 -> 10582;
10585 -> 10583;
10585 -> 10500;
10585 -> 10560;
10585 -> 10563;
10586 -> 10584;
10586 -> 10563;
10587 -> 10584;
10587 -> 10563;
10588 -> 10584;
10588 -> 10563;
10589 -> 10584;
10589 -> 10563;
10590 -> 10584;
10590 -> 10563;
10591 -> 10584;
10591 -> 10563;
10592 -> 10584;
10592 -> 10563;
10593 -> 10584;
10593 -> 10563;
10594 -> 10584;
10594 -> 10563;
10595 -> 10584;
10595 -> 10563;
10596 -> 10584;
10596 -> 10563;
10597 -> 10584;
10597 -> 10563;
10598 -> 10584;
10598 -> 10563;
10599 -> 10584;
10599 -> 10563;
10600 -> 10584;
10600 -> 10563;
10601 -> 10584;
10601 -> 10563;
10602 -> 10584;
10602 -> 10563;
10603 -> 10584;
10603 -> 10563;
10604 -> 10584;
10604 -> 10563;
10605 -> 10584;
10605 -> 10563;
10606 -> 10584;
10606 -> 10563;
10607 -> 10584;
10607 -> 10563;
10608 -> 10584;
10608 -> 10563;
10609 -> 10584;
10609 -> 10563;
10610 -> 10584;
10610 -> 10563;
10611 -> 10584;
10611 -> 10563;
10612 -> 10563;
10613 -> 10612;
10613 -> 10584;
10613 -> 10563;
10614 -> 10584;
10614 -> 10563;
10615 -> 10584;
10615 -> 10563;
10616 -> 10584;
10616 -> 10563;
10617 -> 10584;
10617 -> 10563;
10618 -> 10584;
10618 -> 10563;
10619 -> 10584;
10619 -> 10563;
10620 -> 10584;
10620 -> 10563;
10621 -> 10563;
10622 -> 10563;
10623 -> 10620;
10623 -> 10622;
10624 -> 10621;
10624 -> 10622;
10626 -> 10625;
10627 -> 10625;
10628 -> 10622;
10629 -> 10624;
10629 -> 10628;
10630 -> 10628;
10631 -> 10624;
10631 -> 10622;
10632 -> 10623;
10632 -> 10624;
10632 -> 10622;
10633 -> 10621;
10633 -> 10584;
10633 -> 10563;
10634 -> 10565;
10634 -> 10584;
10634 -> 10563;
10635 -> 10584;
10635 -> 10563;
10636 -> 10563;
10637 -> 10563;
10638 -> 10635;
10638 -> 10637;
10639 -> 10636;
10639 -> 10637;
10640 -> 10639;
10640 -> 10637;
10641 -> 10639;
10641 -> 10637;
10642 -> 10639;
10642 -> 10637;
10643 -> 10638;
10643 -> 10639;
10643 -> 10637;
10644 -> 10636;
10644 -> 10584;
10644 -> 10563;
10645 -> 10584;
10645 -> 10585;
10645 -> 10563;
10646 -> 10645;
10646 -> 10585;
10646 -> 10586;
10646 -> 10634;
10646 -> 10587;
10646 -> 10588;
10646 -> 10589;
10646 -> 10590;
10646 -> 10591;
10646 -> 10592;
10646 -> 10593;
10646 -> 10594;
10646 -> 10595;
10646 -> 10596;
10646 -> 10644;
10646 -> 10597;
10646 -> 10598;
10646 -> 10599;
10646 -> 10600;
10646 -> 10601;
10646 -> 10602;
10646 -> 10603;
10646 -> 10604;
10646 -> 10605;
10646 -> 10606;
10646 -> 10607;
10646 -> 10608;
10646 -> 10609;
10646 -> 10610;
10646 -> 10611;
10646 -> 10613;
10646 -> 10614;
10646 -> 10633;
10646 -> 10615;
10646 -> 10616;
10646 -> 10617;
10646 -> 10618;
10646 -> 10619;
10646 -> 10612;
10646 -> 10630;
10646 -> 10631;
10646 -> 10632;
10646 -> 10643;
10646 -> 10641;
10646 -> 10642;
10646 -> 10563;
10647 -> 10646;
10647 -> 10584;
10647 -> 10563;
10648 -> 10584;
10648 -> 10646;
10648 -> 10563;
10649 -> 10648;
10649 -> 10646;
10649 -> 10647;
10649 -> 10563;
10650 -> 10649;
10650 -> 10584;
10650 -> 10563;
10651 -> 10584;
10651 -> 10649;
10651 -> 10563;
10652 -> 10651;
10652 -> 10649;
10652 -> 10650;
10652 -> 10563;
10653 -> 10652;
10653 -> 10584;
10653 -> 10563;
10654 -> 10584;
10654 -> 10652;
10654 -> 10563;
10655 -> 10654;
10655 -> 10652;
10655 -> 10653;
10655 -> 10563;
10656 -> 10655;
10656 -> 10584;
10656 -> 10563;
10657 -> 10584;
10657 -> 10563;
10658 -> 10563;
10659 -> 10563;
10660 -> 10657;
10660 -> 10659;
10661 -> 10658;
10661 -> 10659;
10662 -> 10659;
10663 -> 10662;
10663 -> 10659;
10664 -> 10662;
10664 -> 10659;
10665 -> 10662;
10665 -> 10659;
10666 -> 10659;
10667 -> 10666;
10667 -> 10662;
10667 -> 10659;
10668 -> 10659;
10669 -> 10660;
10669 -> 10668;
10669 -> 10659;
10670 -> 10660;
10670 -> 10662;
10670 -> 10659;
10671 -> 10658;
10671 -> 10584;
10671 -> 10563;
10672 -> 10573;
10672 -> 10655;
10672 -> 10563;
10673 -> 10563;
10674 -> 10672;
10674 -> 10673;
10675 -> 10673;
10676 -> 10674;
10676 -> 10673;
10677 -> 10676;
10677 -> 10655;
10677 -> 10656;
10677 -> 10671;
10677 -> 10673;
10678 -> 0;
10678 -> 10673;
10679 -> 10673;
10680 -> 10678;
10680 -> 10679;
10681 -> 10680;
10681 -> 10679;
10682 -> 0;
10682 -> 10681;
10683 -> 10682;
10683 -> 10675;
10683 -> 10673;
10684 -> 10683;
10684 -> 10563;
10685 -> 10684;
10685 -> 10584;
10685 -> 10563;
10686 -> 10570;
10686 -> 10563;
10687 -> 10686;
10688 -> 10567;
10688 -> 10687;
10688 -> 10686;
10689 -> 10568;
10689 -> 10687;
10689 -> 10686;
10690 -> 10688;
10690 -> 10689;
10690 -> 10686;
10691 -> 10569;
10691 -> 10687;
10691 -> 10686;
10692 -> 10690;
10692 -> 10691;
10692 -> 10686;
10693 -> 10572;
10693 -> 10563;
10694 -> 10584;
10694 -> 10655;
10694 -> 10656;
10694 -> 10671;
10694 -> 10685;
10694 -> 10662;
10694 -> 10663;
10694 -> 10670;
10694 -> 10664;
10694 -> 10665;
10694 -> 10667;
10694 -> 10666;
10694 -> 10693;
10695 -> 10693;
10696 -> 10584;
10696 -> 10695;
10697 -> 10696;
10697 -> 10694;
10697 -> 10695;
10698 -> 10571;
10698 -> 10693;
10699 -> 10693;
10700 -> 10693;
10701 -> 10694;
10701 -> 10700;
10702 -> 10697;
10702 -> 10700;
10703 -> 10698;
10703 -> 10700;
10704 -> 10699;
10704 -> 10700;
10705 -> 10701;
10705 -> 10700;
10706 -> 10702;
10706 -> 10700;
10707 -> 10703;
10707 -> 10700;
10708 -> 10700;
10709 -> 10708;
10709 -> 10705;
10709 -> 10706;
10709 -> 10707;
10709 -> 10694;
10709 -> 10700;
10710 -> 10699;
10710 -> 10584;
10710 -> 10693;
10711 -> 10573;
10711 -> 10584;
10711 -> 10563;
10712 -> 10584;
10712 -> 10709;
10712 -> 10563;
10713 -> 10563;
10714 -> 10584;
10714 -> 10709;
10714 -> 10713;
10714 -> 10563;
10715 -> 10487;
10716 -> 10490;
10716 -> 10715;
10716 -> 10487;
10717 -> 10490;
10717 -> 10716;
10718 -> 10716;
10719 -> 10717;
10719 -> 10718;
10720 -> 10508;
10720 -> 10718;
10721 -> 10718;
10722 -> 10719;
10722 -> 10721;
10722 -> 10718;
10723 -> 10719;
10723 -> 10718;
10724 -> 10723;
10724 -> 10709;
10724 -> 10710;
10724 -> 10711;
10724 -> 10718;
10725 -> 10718;
10726 -> 10720;
10726 -> 10724;
10726 -> 10718;
10727 -> 10725;
10727 -> 10718;
10728 -> 10726;
10728 -> 10724;
10728 -> 10718;
10729 -> 10727;
10729 -> 10728;
10729 -> 10725;
10729 -> 10724;
10729 -> 10718;
10730 -> 10718;
10731 -> 10718;
10732 -> 10719;
10732 -> 10718;
10733 -> 10732;
10733 -> 10729;
10733 -> 10718;
10734 -> 10733;
10735 -> 10733;
10736 -> 10733;
10736 -> 10735;
10737 -> 10736;
10737 -> 10733;
10737 -> 10735;
10738 -> 10737;
10738 -> 10733;
10739 -> 10733;
10740 -> 10720;
10740 -> 10739;
10740 -> 10733;
10741 -> 10733;
10742 -> 10725;
10742 -> 10741;
10742 -> 10739;
10742 -> 10733;
10743 -> 10733;
10744 -> 10733;
10744 -> 10743;
10745 -> 10743;
10746 -> 10744;
10746 -> 10745;
10747 -> 10746;
10747 -> 10742;
10747 -> 10745;
10748 -> 10747;
10748 -> 10743;
10749 -> 10743;
10750 -> 10744;
10750 -> 10749;
10751 -> 10750;
10751 -> 10742;
10751 -> 10749;
10752 -> 10751;
10752 -> 10743;
10753 -> 10743;
10754 -> 10753;
10754 -> 10733;
10755 -> 10730;
10755 -> 10754;
10755 -> 10733;
10756 -> 10731;
10756 -> 10733;
10757 -> 10725;
10757 -> 10742;
10757 -> 10718;
10758 -> 10720;
10758 -> 10757;
10758 -> 10718;
10759 -> 10719;
10759 -> 10718;
10760 -> 10718;
10761 -> 10759;
10761 -> 10760;
10762 -> 10726;
10762 -> 10760;
10763 -> 10762;
10763 -> 10757;
10763 -> 10760;
10764 -> 10762;
10764 -> 10757;
10764 -> 10760;
10765 -> 10762;
10765 -> 10757;
10765 -> 10760;
10766 -> 10762;
10766 -> 10757;
10766 -> 10760;
10767 -> 10762;
10767 -> 10757;
10767 -> 10760;
10768 -> 10761;
10768 -> 10760;
10769 -> 10762;
10769 -> 10757;
10769 -> 10768;
10769 -> 10760;
10770 -> 10760;
10771 -> 10767;
10771 -> 10770;
10771 -> 10760;
10772 -> 10769;
10772 -> 10771;
10773 -> 10771;
10774 -> 10772;
10774 -> 10773;
10775 -> 10762;
10775 -> 10773;
10776 -> 10774;
10776 -> 10773;
10777 -> 10775;
10777 -> 10769;
10777 -> 10773;
10778 -> 10773;
10779 -> 10773;
10780 -> 10776;
10780 -> 10779;
10781 -> 10777;
10781 -> 10779;
10782 -> 10777;
10782 -> 10779;
10783 -> 10777;
10783 -> 10779;
10784 -> 10777;
10784 -> 10779;
10785 -> 10778;
10785 -> 10779;
10786 -> 10778;
10786 -> 10779;
10787 -> 10779;
10787 -> 10780;
10787 -> 10781;
10787 -> 10782;
10787 -> 10783;
10787 -> 10784;
10787 -> 10769;
10788 -> 10778;
10788 -> 10771;
10789 -> 10788;
10789 -> 10718;
10790 -> 10720;
10790 -> 10787;
10790 -> 10718;
10791 -> 10755;
10791 -> 10718;
10792 -> 10789;
10792 -> 10718;
10793 -> 10718;
10794 -> 10790;
10794 -> 10793;
10795 -> 10791;
10795 -> 10793;
10796 -> 10792;
10796 -> 10793;
10797 -> 10720;
10797 -> 10793;
10798 -> 10797;
10798 -> 10787;
10798 -> 10793;
10799 -> 10793;
10800 -> 10797;
10800 -> 10799;
10801 -> 10800;
10801 -> 10787;
10801 -> 10799;
10802 -> 10801;
10802 -> 10799;
10803 -> 10802;
10803 -> 10793;
10804 -> 10797;
10804 -> 10787;
10804 -> 10779;
10804 -> 10785;
10804 -> 10793;
10805 -> 10793;
10806 -> 10804;
10806 -> 10805;
10807 -> 10806;
10807 -> 10804;
10807 -> 10805;
10808 -> 10793;
10809 -> 10807;
10809 -> 10808;
10810 -> 10794;
10810 -> 10793;
10811 -> 10795;
10811 -> 10793;
10812 -> 10796;
10812 -> 10793;
10813 -> 10793;
10814 -> 10793;
10815 -> 10798;
10815 -> 10814;
10816 -> 10798;
10816 -> 10814;
10817 -> 10798;
10817 -> 10814;
10818 -> 10803;
10818 -> 10814;
10819 -> 10807;
10819 -> 10814;
10820 -> 10809;
10820 -> 10814;
10821 -> 10809;
10821 -> 10814;
10822 -> 10810;
10822 -> 10814;
10823 -> 10811;
10823 -> 10814;
10824 -> 10812;
10824 -> 10814;
10825 -> 10809;
10825 -> 10814;
10826 -> 10813;
10826 -> 10814;
10827 -> 10813;
10827 -> 10814;
10828 -> 10818;
10828 -> 10814;
10829 -> 10819;
10829 -> 10814;
10830 -> 10820;
10830 -> 10814;
10831 -> 10824;
10831 -> 10809;
10831 -> 10814;
10832 -> 10814;
10833 -> 10831;
10833 -> 10832;
10834 -> 10832;
10835 -> 10833;
10835 -> 10834;
10836 -> 10835;
10836 -> 10831;
10836 -> 10834;
10837 -> 10836;
10837 -> 10832;
10838 -> 10826;
10838 -> 10814;
10839 -> 10814;
10840 -> 10828;
10840 -> 10839;
10841 -> 10829;
10841 -> 10839;
10842 -> 10830;
10842 -> 10839;
10843 -> 10838;
10843 -> 10839;
10844 -> 10827;
10844 -> 10839;
10845 -> 10843;
10845 -> 10839;
10846 -> 10839;
10847 -> 10846;
10847 -> 10839;
10848 -> 10846;
10848 -> 10839;
10849 -> 10846;
10849 -> 10839;
10850 -> 10846;
10850 -> 10839;
10851 -> 10846;
10851 -> 10839;
10852 -> 10846;
10852 -> 10839;
10853 -> 10846;
10853 -> 10839;
10854 -> 10846;
10854 -> 10839;
10855 -> 10846;
10855 -> 10839;
10856 -> 10846;
10856 -> 10839;
10857 -> 10846;
10857 -> 10839;
10858 -> 10846;
10858 -> 10839;
10859 -> 10846;
10859 -> 10839;
10860 -> 10846;
10860 -> 10839;
10861 -> 10846;
10861 -> 10839;
10862 -> 10846;
10862 -> 10839;
10863 -> 10846;
10863 -> 10839;
10864 -> 10846;
10864 -> 10839;
10865 -> 10846;
10865 -> 10839;
10866 -> 10846;
10866 -> 10839;
10867 -> 10846;
10867 -> 10839;
10868 -> 10846;
10868 -> 10839;
10869 -> 10846;
10869 -> 10839;
10870 -> 10846;
10870 -> 10839;
10871 -> 10846;
10871 -> 10839;
10872 -> 10846;
10872 -> 10839;
10873 -> 10839;
10874 -> 10873;
10874 -> 10846;
10874 -> 10839;
10875 -> 10846;
10875 -> 10839;
10876 -> 10846;
10876 -> 10839;
10877 -> 10846;
10877 -> 10839;
10878 -> 10846;
10878 -> 10839;
10879 -> 10846;
10879 -> 10839;
10880 -> 10846;
10880 -> 10839;
10881 -> 10846;
10881 -> 10839;
10882 -> 10839;
10883 -> 10839;
10884 -> 10881;
10884 -> 10883;
10885 -> 10882;
10885 -> 10883;
10886 -> 10883;
10887 -> 10885;
10887 -> 10886;
10888 -> 10886;
10889 -> 10885;
10889 -> 10883;
10890 -> 10884;
10890 -> 10885;
10890 -> 10883;
10891 -> 10882;
10891 -> 10846;
10891 -> 10839;
10892 -> 10846;
10892 -> 10839;
10893 -> 10839;
10894 -> 10839;
10895 -> 10892;
10895 -> 10894;
10896 -> 10893;
10896 -> 10894;
10897 -> 10896;
10897 -> 10894;
10898 -> 10896;
10898 -> 10894;
10899 -> 10896;
10899 -> 10894;
10900 -> 10895;
10900 -> 10896;
10900 -> 10894;
10901 -> 10893;
10901 -> 10846;
10901 -> 10839;
10902 -> 10846;
10902 -> 10839;
10903 -> 10839;
10904 -> 10839;
10905 -> 10902;
10905 -> 10904;
10906 -> 10903;
10906 -> 10904;
10907 -> 10904;
10908 -> 10907;
10908 -> 10904;
10909 -> 10907;
10909 -> 10904;
10910 -> 10907;
10910 -> 10904;
10911 -> 10904;
10912 -> 10911;
10912 -> 10907;
10912 -> 10904;
10913 -> 10904;
10914 -> 10905;
10914 -> 10913;
10914 -> 10904;
10915 -> 10905;
10915 -> 10907;
10915 -> 10904;
10916 -> 10903;
10916 -> 10846;
10916 -> 10839;
10917 -> 10839;
10918 -> 10837;
10918 -> 10917;
10919 -> 10917;
10920 -> 10918;
10920 -> 10917;
10921 -> 10920;
10921 -> 10837;
10921 -> 10907;
10921 -> 10911;
10921 -> 10916;
10921 -> 10908;
10921 -> 10915;
10921 -> 10909;
10921 -> 10910;
10921 -> 10912;
10922 -> 10920;
10923 -> 10921;
10923 -> 10922;
10924 -> 10920;
10925 -> 10923;
10925 -> 10924;
10926 -> 10821;
10926 -> 10839;
10927 -> 10926;
10928 -> 10840;
10928 -> 10927;
10928 -> 10926;
10929 -> 10841;
10929 -> 10927;
10929 -> 10926;
10930 -> 10928;
10930 -> 10929;
10930 -> 10926;
10931 -> 10842;
10931 -> 10927;
10931 -> 10926;
10932 -> 10930;
10932 -> 10931;
10932 -> 10926;
10933 -> 10822;
10933 -> 10823;
10934 -> 10846;
10934 -> 10823;
10935 -> 10822;
10935 -> 10934;
10935 -> 10923;
10935 -> 10925;
10935 -> 10823;
10936 -> 10822;
10936 -> 10846;
10936 -> 10823;
10937 -> 10846;
10937 -> 10935;
10937 -> 10839;
10938 -> 10839;
10939 -> 10846;
10939 -> 10935;
10939 -> 10938;
10939 -> 10839;
10940 -> 10813;
10940 -> 10718;
10941 -> 10940;
10941 -> 10716;
10942 -> 10941;
10942 -> 10935;
10942 -> 10487;
10943 -> 10941;
10943 -> 10487;
10944 -> 10121;
10944 -> 10943;
10944 -> 10935;
10944 -> 10936;
10944 -> 10824;
10944 -> 260;
10945 -> 10944;
10945 -> 260;
10946 -> 260;
10947 -> 10945;
10947 -> 10946;
10948 -> 10946;
10949 -> 10947;
10949 -> 10948;
10950 -> 10948;
10951 -> 10949;
10951 -> 10944;
10951 -> 10950;
10952 -> 10950;
10953 -> 10951;
10953 -> 10944;
10953 -> 10952;
10953 -> 10950;
10954 -> 10951;
10954 -> 10944;
10954 -> 10953;
10955 -> 10953;
10956 -> 10954;
10956 -> 10955;
10957 -> 10954;
10957 -> 10955;
10958 -> 10954;
10958 -> 10955;
10959 -> 10954;
10959 -> 10955;
10960 -> 10954;
10960 -> 10955;
10961 -> 10955;
10962 -> 10955;
10963 -> 10955;
10964 -> 10955;
10965 -> 10955;
10966 -> 0;
10968 -> 10967;
10970 -> 10969;
10972 -> 10966;
10972 -> 10971;
10973 -> 10968;
10973 -> 10971;
10974 -> 10970;
10974 -> 10971;
10975 -> 10971;
10976 -> 10975;
10976 -> 10971;
10977 -> 10975;
10977 -> 10971;
10978 -> 10975;
10978 -> 10971;
10979 -> 10975;
10979 -> 10971;
10980 -> 10975;
10980 -> 10971;
10981 -> 10975;
10981 -> 10971;
10982 -> 10975;
10982 -> 10971;
10983 -> 10972;
10983 -> 10975;
10983 -> 10971;
10984 -> 10973;
10984 -> 10975;
10984 -> 10971;
10985 -> 10975;
10985 -> 10971;
10986 -> 10971;
10987 -> 10971;
10988 -> 10985;
10988 -> 10987;
10989 -> 10986;
10989 -> 10987;
10990 -> 10989;
10990 -> 10987;
10991 -> 10989;
10991 -> 10987;
10992 -> 10989;
10992 -> 10987;
10993 -> 10989;
10993 -> 10987;
10994 -> 10988;
10994 -> 10983;
10994 -> 0;
10994 -> 10987;
10995 -> 10994;
10995 -> 10989;
10995 -> 10987;
10996 -> 10989;
10996 -> 10995;
10996 -> 10994;
10996 -> 10987;
10997 -> 10996;
10997 -> 10989;
10997 -> 10987;
10998 -> 10989;
10998 -> 10995;
10998 -> 10996;
10998 -> 10987;
10999 -> 10998;
10999 -> 10989;
10999 -> 10987;
11000 -> 10989;
11000 -> 10995;
11000 -> 10998;
11000 -> 10987;
11001 -> 11000;
11001 -> 10989;
11001 -> 10987;
11002 -> 10986;
11002 -> 10974;
11002 -> 10971;
11003 -> 11002;
11003 -> 10975;
11003 -> 10971;
11004 -> 10975;
11004 -> 10971;
11005 -> 11004;
11005 -> 10975;
11005 -> 10971;
11006 -> 10975;
11006 -> 10971;
11007 -> 11006;
11007 -> 10975;
11007 -> 10971;
11008 -> 10975;
11008 -> 10971;
11009 -> 11008;
11009 -> 10975;
11009 -> 10971;
11010 -> 10971;
11011 -> 0;
11012 -> 11011;
11013 -> 0;
11014 -> 11013;
11015 -> 11010;
11015 -> 10955;
11016 -> 10956;
11016 -> 10955;
11017 -> 10961;
11017 -> 11016;
11018 -> 11016;
11019 -> 10957;
11019 -> 11016;
11020 -> 10958;
11020 -> 11016;
11021 -> 10959;
11021 -> 11016;
11022 -> 10960;
11022 -> 11016;
11023 -> 10962;
11023 -> 11016;
11024 -> 10963;
11024 -> 11016;
11025 -> 10964;
11025 -> 11016;
11026 -> 10965;
11026 -> 11016;
11027 -> 11015;
11027 -> 11016;
11028 -> 11016;
11029 -> 11017;
11029 -> 11028;
11030 -> 11018;
11030 -> 11028;
11031 -> 11019;
11031 -> 11028;
11032 -> 11020;
11032 -> 11028;
11033 -> 11021;
11033 -> 11028;
11034 -> 11022;
11034 -> 11028;
11035 -> 11023;
11035 -> 11028;
11036 -> 11024;
11036 -> 11028;
11037 -> 11025;
11037 -> 11028;
11038 -> 11026;
11038 -> 11028;
11039 -> 11027;
11039 -> 11028;
11040 -> 11030;
11040 -> 10944;
11040 -> 11028;
11041 -> 11028;
11042 -> 11040;
11042 -> 11041;
11043 -> 11042;
11043 -> 0;
11043 -> 11028;
11044 -> 11030;
11044 -> 11028;
11045 -> 11031;
11045 -> 11028;
11046 -> 11034;
11046 -> 11028;
11047 -> 11038;
11047 -> 11028;
11048 -> 11039;
11048 -> 11028;
11049 -> 11028;
11050 -> 11044;
11050 -> 11049;
11051 -> 11045;
11051 -> 11049;
11052 -> 11046;
11052 -> 11049;
11053 -> 11047;
11053 -> 11049;
11054 -> 11048;
11054 -> 11049;
11055 -> 11050;
11055 -> 11051;
11055 -> 11052;
11055 -> 11049;
11056 -> 11055;
11056 -> 11042;
11056 -> 11049;
11057 -> 11050;
11057 -> 11049;
11058 -> 11056;
11058 -> 11049;
11059 -> 11053;
11059 -> 11057;
11059 -> 11058;
11059 -> 10965;
11059 -> 11056;
11059 -> 11049;
11060 -> 11056;
11060 -> 11049;
11061 -> 11049;
11062 -> 11060;
11062 -> 11061;
11063 -> 11054;
11063 -> 11061;
11064 -> 11061;
11065 -> 11063;
11065 -> 10984;
11065 -> 11064;
11065 -> 11061;
11066 -> 11063;
11066 -> 10983;
11066 -> 11065;
11067 -> 11062;
11067 -> 11065;
11068 -> 11063;
11068 -> 11003;
11068 -> 11065;
11069 -> 11065;
11070 -> 11065;
11071 -> 11066;
11071 -> 11070;
11072 -> 11067;
11072 -> 11070;
11073 -> 11068;
11073 -> 11070;
11074 -> 11069;
11074 -> 11070;
11075 -> 11074;
11075 -> 11070;
11076 -> 11074;
11076 -> 11070;
11077 -> 11074;
11077 -> 11070;
11078 -> 11074;
11078 -> 11070;
11079 -> 11074;
11079 -> 11070;
11080 -> 11074;
11080 -> 11070;
11081 -> 11074;
11081 -> 11070;
11082 -> 11074;
11082 -> 11070;
11083 -> 11082;
11083 -> 11074;
11083 -> 11070;
11084 -> 11074;
11084 -> 11070;
11085 -> 11084;
11085 -> 11074;
11085 -> 11070;
11086 -> 11074;
11086 -> 11070;
11087 -> 11086;
11087 -> 11074;
11087 -> 11070;
11088 -> 11069;
11088 -> 11049;
11089 -> 11028;
11090 -> 11030;
11090 -> 11028;
11091 -> 11029;
11091 -> 11090;
11091 -> 10961;
11091 -> 11059;
11091 -> 11028;
11092 -> 11030;
11092 -> 11028;
11093 -> 11035;
11093 -> 10962;
11093 -> 11028;
11094 -> 11035;
11094 -> 11092;
11094 -> 11093;
11094 -> 10962;
11094 -> 11091;
11094 -> 11028;
11095 -> 10961;
11095 -> 11094;
11095 -> 10955;
11096 -> 10962;
11096 -> 11094;
11096 -> 10955;
11097 -> 10963;
11097 -> 10955;
11098 -> 10964;
11098 -> 10955;
11099 -> 11088;
11099 -> 10955;
11100 -> 10955;
11101 -> 10955;
11102 -> 11095;
11102 -> 11101;
11103 -> 11096;
11103 -> 11101;
11104 -> 11097;
11104 -> 11101;
11105 -> 11098;
11105 -> 11101;
11106 -> 11096;
11106 -> 11101;
11107 -> 11099;
11107 -> 11101;
11108 -> 11100;
11108 -> 11101;
11109 -> 11108;
11109 -> 11101;
11110 -> 11108;
11110 -> 11101;
11111 -> 11108;
11111 -> 11101;
11112 -> 11108;
11112 -> 11101;
11113 -> 11108;
11113 -> 11101;
11114 -> 11102;
11114 -> 11101;
11115 -> 11102;
11115 -> 11095;
11115 -> 11101;
11116 -> 11102;
11116 -> 11101;
11117 -> 11106;
11117 -> 11114;
11117 -> 11101;
11118 -> 0;
11118 -> 11101;
11119 -> 11102;
11119 -> 11108;
11119 -> 11101;
11120 -> 11103;
11120 -> 11108;
11120 -> 11101;
11121 -> 11104;
11121 -> 11108;
11121 -> 11101;
11122 -> 11105;
11122 -> 11108;
11122 -> 11101;
11123 -> 11106;
11123 -> 11108;
11123 -> 11101;
11124 -> 11107;
11124 -> 11108;
11124 -> 11101;
11125 -> 11100;
11125 -> 10953;
11126 -> 10953;
11127 -> 10954;
11127 -> 11125;
11127 -> 11126;
11127 -> 11120;
11127 -> 11121;
11127 -> 11122;
11127 -> 11123;
11127 -> 11124;
11127 -> 11119;
11127 -> 11117;
11127 -> 11095;
11127 -> 11097;
11127 -> 11098;
11127 -> 11071;
11127 -> 11072;
11127 -> 11073;
11127 -> 11078;
11127 -> 11083;
11127 -> 11085;
11127 -> 11087;
11127 -> 0;
11127 -> 10995;
11127 -> 10997;
11127 -> 10999;
11127 -> 11001;
11127 -> 11000;
11127 -> 11082;
11127 -> 11084;
11127 -> 11086;
11127 -> 10953;
11128 -> 10951;
11128 -> 11127;
11128 -> 10950;
11129 -> 11128;
11129 -> 10948;
11130 -> 11129;
11130 -> 10946;
11131 -> 11130;
11131 -> 11127;
11131 -> 10946;
11132 -> 10946;
11133 -> 11130;
11133 -> 11132;
11133 -> 11127;
11133 -> 10946;
11134 -> 10946;
11135 -> 11133;
11135 -> 11134;
11136 -> 11134;
11137 -> 0;
11137 -> 10946;
11138 -> 10946;
11139 -> 11137;
11139 -> 11138;
11140 -> 11135;
11140 -> 11138;
11141 -> 11139;
11141 -> 11138;
11142 -> 11138;
11143 -> 11141;
11143 -> 11142;
11144 -> 11143;
11144 -> 11142;
11145 -> 11144;
11146 -> 11138;
11147 -> 11145;
11147 -> 11146;
11147 -> 11138;
11148 -> 11140;
11148 -> 11135;
11148 -> 11138;
11149 -> 11139;
11149 -> 11138;
11150 -> 11138;
11151 -> 11149;
11151 -> 11150;
11152 -> 11151;
11152 -> 11150;
11153 -> 11150;
11154 -> 11152;
11154 -> 11153;
11155 -> 11154;
11155 -> 11153;
11156 -> 11155;
11157 -> 11150;
11158 -> 11151;
11158 -> 11150;
11159 -> 0;
11159 -> 11158;
11160 -> 11148;
11160 -> 11159;
11160 -> 11138;
11161 -> 267;
11161 -> 11160;
11161 -> 260;
11162 -> 10944;
11162 -> 260;
11163 -> 1;
11164 -> 11162;
11164 -> 11163;
11165 -> 11164;
11165 -> 11135;
11165 -> 11163;
11166 -> 11165;
11167 -> 11166;
11167 -> 11165;
11168 -> 11165;
11169 -> 11167;
11169 -> 11168;
11170 -> 11164;
11170 -> 11168;
11171 -> 11168;
11172 -> 11170;
11172 -> 11171;
11173 -> 11171;
11174 -> 11172;
11174 -> 11173;
11175 -> 11173;
11176 -> 11174;
11176 -> 11175;
11177 -> 11176;
11177 -> 11135;
11177 -> 11175;
11178 -> 11176;
11178 -> 11177;
11179 -> 11177;
11180 -> 11178;
11180 -> 11179;
11181 -> 11176;
11181 -> 11135;
11181 -> 11179;
11182 -> 11180;
11182 -> 11179;
11183 -> 11179;
11184 -> 11182;
11184 -> 11183;
11185 -> 11181;
11185 -> 11183;
11186 -> 11183;
11187 -> 11183;
11188 -> 11183;
11189 -> 11184;
11189 -> 11188;
11190 -> 11189;
11190 -> 11183;
11191 -> 11183;
11192 -> 11183;
11193 -> 11192;
11193 -> 11183;
11194 -> 11183;
11195 -> 11194;
11195 -> 11183;
11196 -> 11183;
11197 -> 11196;
11197 -> 11183;
11198 -> 11183;
11199 -> 11198;
11199 -> 11183;
11200 -> 11184;
11200 -> 11183;
11201 -> 11187;
11201 -> 11183;
11202 -> 11198;
11202 -> 11183;
11203 -> 11191;
11203 -> 11183;
11204 -> 11192;
11204 -> 11183;
11205 -> 11194;
11205 -> 11183;
11206 -> 11196;
11206 -> 11183;
11207 -> 11186;
11207 -> 11183;
11208 -> 11200;
11208 -> 11201;
11208 -> 11202;
11208 -> 11203;
11208 -> 11204;
11208 -> 11205;
11208 -> 11206;
11208 -> 11207;
11208 -> 11185;
11208 -> 11135;
11208 -> 11187;
11208 -> 11186;
11208 -> 11199;
11208 -> 11193;
11208 -> 11195;
11208 -> 11197;
11208 -> 11183;
11209 -> 11183;
11210 -> 11208;
11210 -> 11209;
11211 -> 11209;
11212 -> 11210;
11212 -> 11211;
11213 -> 11211;
11214 -> 11212;
11214 -> 11208;
11214 -> 11213;
11215 -> 11214;
11215 -> 11211;
11216 -> 11215;
11216 -> 11209;
11217 -> 11209;
11218 -> 11216;
11218 -> 11217;
11219 -> 11218;
11219 -> 11208;
11219 -> 11217;
11220 -> 11217;
11221 -> 11219;
11221 -> 11220;
11222 -> 11221;
11222 -> 11219;
11222 -> 11220;
11223 -> 11220;
11224 -> 11222;
11224 -> 11223;
11225 -> 11224;
11225 -> 11223;
11226 -> 11223;
11227 -> 11223;
11228 -> 11225;
11228 -> 11227;
11229 -> 11226;
11229 -> 11227;
11230 -> 11228;
11230 -> 11222;
11230 -> 11227;
11231 -> 0;
11231 -> 11230;
11232 -> 11227;
11233 -> 11231;
11233 -> 11232;
11234 -> 11229;
11234 -> 11232;
11235 -> 11233;
11235 -> 11232;
11236 -> 11232;
11237 -> 11235;
11237 -> 11236;
11238 -> 11234;
11238 -> 11236;
11239 -> 11238;
11239 -> 11236;
11240 -> 11237;
11240 -> 11238;
11240 -> 11236;
11241 -> 11228;
11241 -> 11229;
11241 -> 11227;
11242 -> 11226;
11242 -> 11220;
11243 -> 11222;
11243 -> 11242;
11243 -> 11240;
11243 -> 11241;
11243 -> 11220;
11244 -> 11222;
11244 -> 11223;
11245 -> 11244;
11245 -> 11243;
11245 -> 11223;
11246 -> 11220;
11247 -> 11221;
11247 -> 11245;
11247 -> 11246;
11247 -> 11220;
11249 -> 11248;
11250 -> 11249;
11251 -> 11245;
11251 -> 11247;
11252 -> 11221;
11252 -> 11245;
11252 -> 11247;
11253 -> 11247;
11254 -> 11252;
11254 -> 11253;
11255 -> 11252;
11255 -> 11253;
11256 -> 11252;
11256 -> 11253;
11257 -> 11254;
11257 -> 11253;
11258 -> 11255;
11258 -> 11253;
11259 -> 11256;
11259 -> 11253;
11260 -> 11253;
11261 -> 11253;
11262 -> 11257;
11262 -> 11261;
11263 -> 11258;
11263 -> 11261;
11264 -> 11259;
11264 -> 11261;
11265 -> 11260;
11265 -> 11261;
11266 -> 11261;
11267 -> 11265;
11267 -> 11266;
11268 -> 11265;
11268 -> 11261;
11269 -> 11265;
11269 -> 11261;
11270 -> 11265;
11270 -> 11261;
11271 -> 11262;
11271 -> 11265;
11271 -> 11261;
11272 -> 11263;
11272 -> 11265;
11272 -> 11261;
11273 -> 11264;
11273 -> 11265;
11273 -> 11261;
11274 -> 11253;
11275 -> 11274;
11275 -> 11254;
11275 -> 11252;
11275 -> 11253;
11276 -> 11275;
11276 -> 11274;
11277 -> 11253;
11278 -> 11275;
11278 -> 11277;
11279 -> 11260;
11279 -> 11277;
11280 -> 11277;
11281 -> 11278;
11281 -> 11280;
11281 -> 11277;
11282 -> 11279;
11282 -> 11281;
11283 -> 11282;
11283 -> 11278;
11283 -> 11271;
11283 -> 11272;
11283 -> 11273;
11283 -> 11275;
11283 -> 11281;
11284 -> 11281;
11285 -> 11283;
11285 -> 11284;
11286 -> 11283;
11286 -> 11284;
11287 -> 11286;
11287 -> 11283;
11287 -> 11284;
11288 -> 11284;
11289 -> 11287;
11289 -> 11288;
11290 -> 11285;
11290 -> 11284;
11291 -> 11285;
11291 -> 11289;
11291 -> 11284;
11292 -> 11284;
11293 -> 11290;
11293 -> 11292;
11294 -> 11291;
11294 -> 11292;
11295 -> 11291;
11295 -> 11292;
11296 -> 11286;
11296 -> 11292;
11297 -> 11292;
11298 -> 11293;
11298 -> 11297;
11299 -> 11298;
11299 -> 11289;
11299 -> 11297;
11300 -> 11299;
11300 -> 11292;
11301 -> 11292;
11302 -> 11293;
11302 -> 11301;
11303 -> 11302;
11303 -> 11289;
11303 -> 11301;
11304 -> 11303;
11304 -> 11292;
11305 -> 11296;
11305 -> 11289;
11305 -> 11292;
11306 -> 11292;
11307 -> 11305;
11307 -> 11306;
11308 -> 11304;
11308 -> 11307;
11308 -> 11292;
11309 -> 11300;
11309 -> 11308;
11309 -> 11292;
11310 -> 11292;
11311 -> 11294;
11311 -> 11289;
11311 -> 11310;
11311 -> 11292;
11312 -> 11292;
11313 -> 11292;
11314 -> 11293;
11314 -> 11313;
11315 -> 11314;
11315 -> 11307;
11315 -> 11313;
11316 -> 11315;
11316 -> 11292;
11317 -> 11296;
11317 -> 11307;
11317 -> 11292;
11318 -> 11292;
11319 -> 11317;
11319 -> 11318;
11320 -> 11316;
11320 -> 11319;
11320 -> 11292;
11321 -> 11292;
11322 -> 11292;
11323 -> 11292;
11324 -> 11292;
11325 -> 11292;
11326 -> 11294;
11326 -> 11292;
11327 -> 11326;
11328 -> 11326;
11329 -> 11327;
11329 -> 11328;
11330 -> 11296;
11330 -> 11328;
11331 -> 11330;
11331 -> 11329;
11332 -> 11331;
11332 -> 11329;
11332 -> 11319;
11332 -> 11289;
11333 -> 11332;
11333 -> 11329;
11334 -> 11332;
11334 -> 11329;
11335 -> 11333;
11335 -> 11329;
11336 -> 11333;
11336 -> 11332;
11336 -> 11329;
11337 -> 11329;
11338 -> 11333;
11338 -> 11337;
11339 -> 11338;
11339 -> 11332;
11339 -> 11337;
11340 -> 11339;
11340 -> 11329;
11341 -> 11329;
11342 -> 11335;
11342 -> 11341;
11343 -> 11336;
11343 -> 11341;
11344 -> 11340;
11344 -> 11341;
11345 -> 11334;
11345 -> 11341;
11346 -> 11341;
11347 -> 11342;
11347 -> 11346;
11348 -> 11341;
11349 -> 11343;
11349 -> 11332;
11349 -> 11348;
11349 -> 11341;
11350 -> 11341;
11351 -> 11341;
11352 -> 11342;
11352 -> 11351;
11353 -> 11341;
11354 -> 11341;
11355 -> 11341;
11356 -> 11341;
11357 -> 11341;
11358 -> 11345;
11358 -> 11343;
11359 -> 11358;
11359 -> 11343;
11360 -> 11358;
11360 -> 11343;
11361 -> 11359;
11361 -> 11343;
11362 -> 0;
11362 -> 11343;
11363 -> 11343;
11364 -> 11361;
11364 -> 11363;
11365 -> 11362;
11365 -> 11363;
11366 -> 11360;
11366 -> 11363;
11367 -> 11364;
11367 -> 11358;
11367 -> 11363;
11368 -> 11367;
11368 -> 11363;
11369 -> 11363;
11370 -> 11364;
11370 -> 11367;
11370 -> 11369;
11370 -> 11363;
11371 -> 11363;
11372 -> 11363;
11373 -> 11364;
11373 -> 11372;
11374 -> 11372;
11375 -> 11373;
11375 -> 11367;
11375 -> 11374;
11375 -> 11372;
11376 -> 11375;
11376 -> 11372;
11377 -> 11376;
11377 -> 11363;
11378 -> 11363;
11379 -> 0;
11380 -> 0;
11380 -> 11379;
11381 -> 0;
11382 -> 11380;
11382 -> 0;
11382 -> 11381;
11383 -> 11382;
11384 -> 11364;
11384 -> 11367;
11384 -> 11377;
11385 -> 11371;
11385 -> 11377;
11386 -> 11377;
11387 -> 11384;
11387 -> 11386;
11388 -> 11385;
11388 -> 11386;
11389 -> 11386;
11390 -> 11387;
11390 -> 11367;
11390 -> 11389;
11390 -> 11386;
11391 -> 11377;
11392 -> 11364;
11392 -> 11367;
11392 -> 11363;
11393 -> 11368;
11393 -> 11363;
11394 -> 11363;
11395 -> 11363;
11396 -> 11392;
11396 -> 11395;
11397 -> 11393;
11397 -> 11395;
11398 -> 11394;
11398 -> 11395;
11399 -> 11395;
11400 -> 11395;
11401 -> 11395;
11402 -> 11250;
11402 -> 11249;
11402 -> 11395;
11403 -> 11396;
11403 -> 11395;
11404 -> 11399;
11404 -> 11395;
11405 -> 11400;
11405 -> 11395;
11406 -> 11401;
11406 -> 11395;
11407 -> 11402;
11407 -> 11395;
11408 -> 11395;
11409 -> 11407;
11409 -> 11408;
11410 -> 11409;
11410 -> 11402;
11410 -> 11408;
11411 -> 11409;
11411 -> 11410;
11411 -> 11408;
11412 -> 11409;
11412 -> 11408;
11413 -> 11250;
11413 -> 11412;
11413 -> 11411;
11413 -> 11408;
11414 -> 11410;
11414 -> 11408;
11415 -> 11414;
11415 -> 11363;
11416 -> 11397;
11416 -> 0;
11416 -> 11363;
11417 -> 11363;
11418 -> 11364;
11418 -> 11363;
11419 -> 11364;
11419 -> 11367;
11419 -> 11363;
11420 -> 11364;
11420 -> 11367;
11420 -> 11363;
11421 -> 11363;
11422 -> 11420;
11422 -> 11421;
11423 -> 11420;
11423 -> 11421;
11424 -> 0;
11424 -> 11421;
11425 -> 11421;
11426 -> 11421;
11427 -> 11422;
11427 -> 11421;
11428 -> 11424;
11428 -> 0;
11428 -> 11421;
11429 -> 11424;
11429 -> 11421;
11430 -> 11429;
11430 -> 11363;
11431 -> 11420;
11431 -> 11430;
11431 -> 11363;
11432 -> 11371;
11432 -> 11363;
11433 -> 11431;
11433 -> 11432;
11433 -> 11371;
11433 -> 11363;
11434 -> 11365;
11434 -> 11363;
11435 -> 11364;
11435 -> 11433;
11435 -> 11363;
11436 -> 11363;
11437 -> 11435;
11437 -> 11436;
11438 -> 11436;
11438 -> 11363;
11439 -> 11435;
11439 -> 11438;
11439 -> 11363;
11440 -> 11435;
11440 -> 11436;
11441 -> 11436;
11442 -> 11440;
11442 -> 11441;
11443 -> 11442;
11443 -> 11439;
11443 -> 11441;
11444 -> 11443;
11444 -> 11436;
11445 -> 11435;
11445 -> 11436;
11446 -> 11436;
11447 -> 11445;
11447 -> 11444;
11447 -> 11446;
11447 -> 11436;
11448 -> 11447;
11448 -> 11436;
11449 -> 11433;
11449 -> 11363;
11450 -> 11363;
11451 -> 11448;
11451 -> 11450;
11452 -> 11448;
11452 -> 11450;
11453 -> 11451;
11453 -> 11450;
11454 -> 11450;
11455 -> 11450;
11456 -> 11453;
11456 -> 11455;
11457 -> 11454;
11457 -> 11455;
11458 -> 11455;
11459 -> 11458;
11459 -> 11455;
11460 -> 11456;
11460 -> 11458;
11460 -> 11455;
11461 -> 11454;
11461 -> 11363;
11462 -> 11448;
11462 -> 11461;
11462 -> 11458;
11462 -> 11459;
11462 -> 11460;
11462 -> 11363;
11463 -> 11397;
11463 -> 11363;
11464 -> 11364;
11464 -> 11363;
11465 -> 11366;
11465 -> 11462;
11465 -> 11464;
11465 -> 11363;
11466 -> 11363;
11467 -> 11465;
11467 -> 11466;
11468 -> 11466;
11468 -> 11363;
11469 -> 11465;
11469 -> 11468;
11469 -> 11363;
11470 -> 11363;
11471 -> 11469;
11471 -> 11470;
11472 -> 11470;
11473 -> 11471;
11473 -> 11472;
11474 -> 11473;
11474 -> 11472;
11475 -> 11472;
11476 -> 11474;
11476 -> 11475;
11477 -> 11475;
11478 -> 11475;
11479 -> 11475;
11480 -> 11476;
11480 -> 11469;
11480 -> 11479;
11481 -> 11479;
11482 -> 11480;
11482 -> 11481;
11482 -> 11479;
11483 -> 11479;
11484 -> 11476;
11484 -> 11483;
11485 -> 11484;
11485 -> 11469;
11485 -> 11483;
11486 -> 11485;
11486 -> 11479;
11487 -> 11479;
11488 -> 11486;
11488 -> 11487;
11488 -> 11479;
11489 -> 11486;
11489 -> 11469;
11489 -> 11479;
11490 -> 11479;
11491 -> 11489;
11491 -> 11490;
11491 -> 11479;
11492 -> 11479;
11493 -> 11476;
11493 -> 11479;
11494 -> 11486;
11494 -> 11479;
11495 -> 11494;
11495 -> 11493;
11495 -> 11479;
11496 -> 11495;
11496 -> 11481;
11496 -> 11479;
11497 -> 11494;
11497 -> 11493;
11497 -> 11483;
11498 -> 11497;
11498 -> 11487;
11498 -> 11479;
11499 -> 11497;
11499 -> 11493;
11499 -> 11479;
11500 -> 11499;
11500 -> 11490;
11500 -> 11479;
11501 -> 11499;
11501 -> 11494;
11501 -> 11500;
11502 -> 11475;
11503 -> 11492;
11503 -> 11502;
11503 -> 11475;
11504 -> 11503;
11505 -> 11499;
11505 -> 11504;
11505 -> 11503;
11506 -> 11492;
11506 -> 11503;
11507 -> 11506;
11507 -> 11493;
11507 -> 11501;
11507 -> 11503;
11508 -> 11507;
11508 -> 11493;
11508 -> 11501;
11509 -> 11507;
11510 -> 11508;
11510 -> 11509;
11510 -> 11507;
11511 -> 11499;
11511 -> 11507;
11512 -> 11492;
11512 -> 11493;
11512 -> 11501;
11512 -> 11511;
11512 -> 11503;
11513 -> 11499;
11513 -> 11475;
11514 -> 11513;
11514 -> 11473;
11514 -> 11512;
11514 -> 11472;
11515 -> 11472;
11516 -> 11514;
11516 -> 11515;
11516 -> 11472;
11517 -> 11514;
11517 -> 11472;
11518 -> 11517;
11518 -> 11470;
11519 -> 11469;
11519 -> 11470;
11520 -> 11470;
11521 -> 11519;
11521 -> 11520;
11522 -> 11520;
11523 -> 11522;
11523 -> 11470;
11524 -> 11470;
11525 -> 11523;
11525 -> 11524;
11525 -> 11470;
11526 -> 11525;
11526 -> 11470;
11527 -> 11469;
11527 -> 11526;
11527 -> 11518;
11527 -> 11363;
11528 -> 11469;
11528 -> 11470;
11529 -> 11470;
11530 -> 11528;
11530 -> 11529;
11531 -> 11530;
11531 -> 11527;
11531 -> 11529;
11532 -> 11531;
11532 -> 11470;
11533 -> 11415;
11533 -> 11363;
11534 -> 11363;
11535 -> 11464;
11535 -> 11534;
11536 -> 11366;
11536 -> 11534;
11537 -> 11534;
11538 -> 11535;
11538 -> 11532;
11538 -> 11537;
11538 -> 11534;
11539 -> 0;
11539 -> 11538;
11540 -> 11363;
11541 -> 11434;
11541 -> 11540;
11542 -> 11448;
11542 -> 11540;
11543 -> 11449;
11543 -> 11540;
11544 -> 11462;
11544 -> 11540;
11545 -> 11463;
11545 -> 11540;
11546 -> 11465;
11546 -> 11540;
11547 -> 11532;
11547 -> 11540;
11548 -> 11533;
11548 -> 11540;
11549 -> 11539;
11549 -> 11540;
11550 -> 11532;
11550 -> 11540;
11551 -> 11470;
11551 -> 11540;
11552 -> 11542;
11552 -> 11540;
11553 -> 11546;
11553 -> 11540;
11554 -> 11547;
11554 -> 11540;
11555 -> 11550;
11555 -> 11540;
11556 -> 11540;
11557 -> 11552;
11557 -> 11556;
11558 -> 11553;
11558 -> 11556;
11559 -> 11554;
11559 -> 11556;
11560 -> 11555;
11560 -> 11556;
11561 -> 11551;
11561 -> 11556;
11562 -> 11557;
11562 -> 11556;
11563 -> 11556;
11564 -> 11562;
11564 -> 11563;
11565 -> 11561;
11565 -> 11563;
11566 -> 11561;
11566 -> 11556;
11567 -> 11561;
11567 -> 11556;
11568 -> 11558;
11568 -> 11561;
11568 -> 11556;
11569 -> 11559;
11569 -> 11561;
11569 -> 11556;
11570 -> 11560;
11570 -> 11561;
11570 -> 11556;
11571 -> 11551;
11571 -> 11540;
11572 -> 11551;
11572 -> 11540;
11573 -> 11551;
11573 -> 11540;
11574 -> 11551;
11574 -> 11540;
11575 -> 11551;
11575 -> 11540;
11576 -> 11541;
11576 -> 0;
11576 -> 11540;
11577 -> 11541;
11577 -> 11551;
11577 -> 11540;
11578 -> 11543;
11578 -> 11551;
11578 -> 11540;
11579 -> 11544;
11579 -> 11551;
11579 -> 11540;
11580 -> 11548;
11580 -> 11551;
11580 -> 11540;
11581 -> 11549;
11581 -> 11551;
11581 -> 11540;
11582 -> 11545;
11582 -> 11551;
11582 -> 11540;
11583 -> 11470;
11583 -> 11343;
11584 -> 11358;
11584 -> 11583;
11584 -> 11532;
11584 -> 11564;
11584 -> 11568;
11584 -> 11569;
11584 -> 11570;
11584 -> 11577;
11584 -> 11582;
11584 -> 11578;
11584 -> 11579;
11584 -> 11580;
11584 -> 11581;
11584 -> 11413;
11584 -> 0;
11584 -> 11343;
11585 -> 11343;
11586 -> 11584;
11586 -> 11585;
11586 -> 11343;
11587 -> 11584;
11587 -> 11586;
11588 -> 11357;
11588 -> 11587;
11588 -> 11584;
11588 -> 11586;
11589 -> 11588;
11589 -> 11363;
11590 -> 11363;
11591 -> 11589;
11591 -> 11590;
11592 -> 11589;
11592 -> 11590;
11593 -> 11589;
11593 -> 11590;
11594 -> 11589;
11594 -> 11590;
11595 -> 11588;
11595 -> 0;
11595 -> 11591;
11596 -> 11588;
11596 -> 11372;
11597 -> 11596;
11597 -> 11591;
11597 -> 11374;
11597 -> 11372;
11598 -> 11597;
11598 -> 11363;
11599 -> 11588;
11599 -> 11591;
11599 -> 11598;
11600 -> 11371;
11600 -> 11598;
11601 -> 11598;
11602 -> 11599;
11602 -> 11601;
11603 -> 11600;
11603 -> 11601;
11604 -> 11601;
11605 -> 11602;
11605 -> 11591;
11605 -> 11604;
11605 -> 11601;
11606 -> 11598;
11607 -> 11591;
11607 -> 11395;
11608 -> 11607;
11608 -> 11395;
11609 -> 11595;
11609 -> 0;
11609 -> 11363;
11610 -> 11588;
11610 -> 11363;
11611 -> 11588;
11611 -> 11591;
11611 -> 11363;
11612 -> 11591;
11612 -> 11421;
11613 -> 11591;
11613 -> 11421;
11614 -> 11612;
11614 -> 11421;
11615 -> 11591;
11615 -> 11436;
11616 -> 11591;
11616 -> 11450;
11617 -> 11591;
11617 -> 11466;
11618 -> 11591;
11618 -> 11479;
11619 -> 11618;
11619 -> 11481;
11619 -> 11479;
11620 -> 11591;
11620 -> 11487;
11620 -> 11479;
11621 -> 11477;
11621 -> 11502;
11621 -> 11475;
11622 -> 11591;
11622 -> 11515;
11622 -> 11472;
11623 -> 11591;
11623 -> 11470;
11624 -> 11623;
11624 -> 11520;
11625 -> 11588;
11625 -> 11534;
11626 -> 11356;
11626 -> 11341;
11627 -> 11350;
11627 -> 11341;
11628 -> 11357;
11628 -> 11595;
11628 -> 11341;
11629 -> 11333;
11629 -> 11595;
11629 -> 11329;
11630 -> 11333;
11630 -> 11629;
11630 -> 11329;
11631 -> 11333;
11631 -> 11630;
11631 -> 11329;
11632 -> 11329;
11633 -> 11631;
11633 -> 11632;
11634 -> 11631;
11634 -> 11632;
11635 -> 11631;
11635 -> 11632;
11636 -> 11631;
11636 -> 11632;
11637 -> 11333;
11637 -> 11329;
11638 -> 11329;
11639 -> 11633;
11639 -> 11329;
11640 -> 11329;
11641 -> 11633;
11641 -> 11640;
11641 -> 11329;
11642 -> 11329;
11643 -> 11333;
11643 -> 11633;
11643 -> 11329;
11644 -> 11329;
11645 -> 11643;
11645 -> 11644;
11646 -> 11644;
11647 -> 11645;
11647 -> 11646;
11648 -> 11647;
11648 -> 11644;
11649 -> 11644;
11650 -> 11649;
11650 -> 11329;
11651 -> 11333;
11651 -> 11633;
11651 -> 11329;
11652 -> 11329;
11653 -> 11651;
11653 -> 11652;
11654 -> 11652;
11655 -> 11653;
11655 -> 11654;
11656 -> 11655;
11656 -> 11652;
11657 -> 11652;
11658 -> 11657;
11658 -> 11329;
11659 -> 11329;
11660 -> 11333;
11660 -> 11633;
11660 -> 11659;
11660 -> 11329;
11661 -> 11333;
11661 -> 11633;
11661 -> 11329;
11662 -> 11329;
11663 -> 11661;
11663 -> 11662;
11664 -> 11663;
11664 -> 11661;
11664 -> 11662;
11665 -> 11329;
11666 -> 11329;
11667 -> 11633;
11667 -> 11666;
11668 -> 11667;
11668 -> 11666;
11669 -> 11668;
11669 -> 11329;
11670 -> 11669;
11670 -> 11664;
11670 -> 11329;
11671 -> 11329;
11672 -> 11670;
11672 -> 11671;
11673 -> 11671;
11673 -> 11329;
11674 -> 11670;
11674 -> 11673;
11674 -> 11329;
11675 -> 11670;
11675 -> 11671;
11676 -> 11671;
11677 -> 11670;
11677 -> 11671;
11678 -> 11670;
11678 -> 11671;
11679 -> 11671;
11680 -> 11671;
11681 -> 11679;
11681 -> 11680;
11682 -> 11680;
11683 -> 11682;
11683 -> 11680;
11684 -> 11679;
11684 -> 11329;
11685 -> 11629;
11685 -> 11329;
11686 -> 11630;
11686 -> 11329;
11687 -> 11637;
11687 -> 11329;
11688 -> 11334;
11688 -> 11675;
11688 -> 11687;
11688 -> 11329;
11689 -> 11633;
11689 -> 11329;
11690 -> 11329;
11691 -> 11690;
11692 -> 11691;
11693 -> 11692;
11694 -> 11692;
11695 -> 11692;
11696 -> 11688;
11696 -> 11695;
11697 -> 11695;
11698 -> 11696;
11698 -> 11697;
11698 -> 11695;
11699 -> 11695;
11700 -> 11695;
11701 -> 11688;
11701 -> 11700;
11701 -> 11695;
11702 -> 11695;
11703 -> 11692;
11704 -> 11693;
11704 -> 11703;
11704 -> 11692;
11705 -> 11691;
11706 -> 11688;
11706 -> 11705;
11706 -> 11691;
11707 -> 11688;
11707 -> 11690;
11708 -> 11690;
11709 -> 11707;
11709 -> 11708;
11710 -> 11708;
11711 -> 11710;
11711 -> 11690;
11712 -> 11690;
11713 -> 11711;
11713 -> 11712;
11713 -> 11690;
11714 -> 11713;
11714 -> 11690;
11715 -> 11688;
11715 -> 11690;
11716 -> 11690;
11717 -> 11715;
11717 -> 11716;
11718 -> 11717;
11718 -> 11690;
11719 -> 11690;
11720 -> 11718;
11720 -> 11719;
11720 -> 11690;
11721 -> 11720;
11721 -> 11690;
11722 -> 11718;
11722 -> 11688;
11722 -> 11721;
11723 -> 11628;
11723 -> 11329;
11724 -> 11642;
11724 -> 11329;
11725 -> 11329;
11726 -> 11675;
11726 -> 11725;
11727 -> 11685;
11727 -> 11725;
11728 -> 11686;
11728 -> 11725;
11729 -> 11688;
11729 -> 11725;
11730 -> 11722;
11730 -> 11725;
11731 -> 11723;
11731 -> 11725;
11732 -> 11724;
11732 -> 11725;
11733 -> 11727;
11733 -> 11728;
11733 -> 11725;
11734 -> 11726;
11734 -> 11733;
11735 -> 11729;
11735 -> 11733;
11736 -> 11730;
11736 -> 11733;
11737 -> 11731;
11737 -> 11733;
11738 -> 11732;
11738 -> 11733;
11739 -> 11733;
11740 -> 11733;
11741 -> 11734;
11741 -> 11740;
11742 -> 11735;
11742 -> 11740;
11743 -> 11736;
11743 -> 11740;
11744 -> 11737;
11744 -> 11740;
11745 -> 11738;
11745 -> 11740;
11746 -> 11739;
11746 -> 11740;
11747 -> 11741;
11747 -> 11740;
11748 -> 11742;
11748 -> 11740;
11749 -> 11743;
11749 -> 11740;
11750 -> 11745;
11750 -> 11740;
11751 -> 11740;
11752 -> 11747;
11752 -> 11751;
11753 -> 11748;
11753 -> 11751;
11754 -> 11749;
11754 -> 11751;
11755 -> 11750;
11755 -> 11751;
11756 -> 11746;
11756 -> 11751;
11757 -> 11746;
11757 -> 11751;
11758 -> 11746;
11758 -> 11751;
11759 -> 11744;
11759 -> 11746;
11759 -> 11740;
11760 -> 11332;
11760 -> 11739;
11760 -> 11722;
11760 -> 11752;
11760 -> 11753;
11760 -> 11754;
11760 -> 11755;
11760 -> 11759;
11760 -> 11724;
11760 -> 11628;
11760 -> 11329;
11761 -> 11326;
11762 -> 11324;
11762 -> 11292;
11763 -> 11312;
11763 -> 11292;
11764 -> 11285;
11764 -> 11760;
11764 -> 11284;
11765 -> 11284;
11766 -> 11764;
11766 -> 11765;
11767 -> 11764;
11767 -> 11765;
11768 -> 11765;
11769 -> 11765;
11770 -> 11768;
11770 -> 11769;
11771 -> 11769;
11772 -> 11771;
11772 -> 11769;
11773 -> 11768;
11773 -> 11284;
11774 -> 11285;
11774 -> 11284;
11775 -> 11760;
11775 -> 11284;
11776 -> 0;
11776 -> 11284;
11777 -> 11284;
11778 -> 11766;
11778 -> 11777;
11779 -> 11766;
11779 -> 11777;
11780 -> 11766;
11780 -> 11777;
11781 -> 11766;
11781 -> 11777;
11782 -> 11766;
11782 -> 11777;
11783 -> 11766;
11783 -> 11777;
11784 -> 11766;
11784 -> 11777;
11785 -> 11231;
11785 -> 11777;
11786 -> 11780;
11786 -> 11777;
11787 -> 11780;
11787 -> 11777;
11788 -> 11787;
11788 -> 11766;
11788 -> 11777;
11789 -> 11777;
11790 -> 11788;
11790 -> 11789;
11791 -> 11790;
11791 -> 11788;
11791 -> 11789;
11792 -> 11789;
11793 -> 11791;
11793 -> 11792;
11794 -> 11792;
11795 -> 11794;
11796 -> 11793;
11796 -> 11795;
11796 -> 11794;
11797 -> 11788;
11797 -> 11789;
11798 -> 11797;
11798 -> 11793;
11798 -> 11789;
11799 -> 11789;
11800 -> 11798;
11800 -> 11799;
11801 -> 11799;
11802 -> 11799;
11803 -> 11800;
11803 -> 11798;
11804 -> 11798;
11804 -> 11799;
11805 -> 11799;
11806 -> 11804;
11806 -> 11805;
11807 -> 11805;
11807 -> 11799;
11808 -> 11799;
11809 -> 11807;
11809 -> 11808;
11809 -> 11799;
11810 -> 11809;
11810 -> 11799;
11811 -> 11810;
11811 -> 11789;
11812 -> 11781;
11812 -> 11777;
11813 -> 0;
11813 -> 11777;
11814 -> 11777;
11815 -> 11785;
11815 -> 11814;
11816 -> 11786;
11816 -> 11814;
11817 -> 11803;
11817 -> 11814;
11818 -> 11812;
11818 -> 11814;
11819 -> 11813;
11819 -> 11814;
11820 -> 11815;
11820 -> 11814;
11821 -> 11819;
11821 -> 11814;
11822 -> 11814;
11823 -> 11820;
11823 -> 11822;
11824 -> 11821;
11824 -> 11822;
11825 -> 11823;
11825 -> 11822;
11826 -> 11822;
11827 -> 11825;
11827 -> 11826;
11828 -> 11784;
11828 -> 11826;
11829 -> 11827;
11829 -> 11784;
11829 -> 11826;
11830 -> 11784;
11830 -> 11822;
11831 -> 11784;
11831 -> 11822;
11832 -> 11824;
11832 -> 11784;
11832 -> 11822;
11833 -> 11784;
11833 -> 11777;
11834 -> 11784;
11834 -> 11777;
11835 -> 11784;
11835 -> 11777;
11836 -> 11782;
11836 -> 11766;
11836 -> 11777;
11837 -> 11782;
11837 -> 11784;
11837 -> 11777;
11838 -> 11783;
11838 -> 11784;
11838 -> 11777;
11839 -> 11778;
11839 -> 11784;
11839 -> 11777;
11840 -> 11779;
11840 -> 11784;
11840 -> 11777;
11841 -> 11766;
11841 -> 11803;
11841 -> 11829;
11841 -> 11816;
11841 -> 11817;
11841 -> 11832;
11841 -> 11818;
11841 -> 11838;
11841 -> 11839;
11841 -> 11840;
11841 -> 11837;
11841 -> 0;
11841 -> 11284;
11842 -> 11247;
11843 -> 11221;
11843 -> 11841;
11843 -> 11842;
11844 -> 11843;
11844 -> 11841;
11844 -> 11842;
11845 -> 11208;
11845 -> 11209;
11846 -> 11845;
11846 -> 11844;
11846 -> 11209;
11847 -> 11208;
11847 -> 11209;
11848 -> 10513;
11848 -> 11209;
11849 -> 11208;
11849 -> 11848;
11849 -> 11846;
11849 -> 11183;
11850 -> 11208;
11850 -> 11209;
11851 -> 11208;
11851 -> 11209;
11852 -> 11208;
11852 -> 11209;
11853 -> 11208;
11853 -> 11209;
11854 -> 11208;
11854 -> 11209;
11855 -> 11208;
11855 -> 11209;
11856 -> 11208;
11856 -> 11209;
11857 -> 11850;
11857 -> 11209;
11858 -> 11851;
11858 -> 11209;
11859 -> 11855;
11859 -> 11209;
11860 -> 11852;
11860 -> 11209;
11861 -> 11853;
11861 -> 11209;
11862 -> 11854;
11862 -> 11209;
11863 -> 11209;
11864 -> 11209;
11865 -> 11857;
11865 -> 11864;
11866 -> 11858;
11866 -> 11864;
11867 -> 11859;
11867 -> 11864;
11868 -> 11860;
11868 -> 11864;
11869 -> 11861;
11869 -> 11864;
11870 -> 11862;
11870 -> 11864;
11871 -> 11863;
11871 -> 11864;
11872 -> 11865;
11872 -> 11849;
11872 -> 11864;
11873 -> 11865;
11873 -> 11849;
11873 -> 11864;
11874 -> 11867;
11874 -> 11864;
11875 -> 11864;
11876 -> 11872;
11876 -> 11875;
11877 -> 11873;
11877 -> 11875;
11878 -> 11874;
11878 -> 11875;
11879 -> 11871;
11879 -> 11875;
11880 -> 11875;
11881 -> 11880;
11881 -> 11875;
11882 -> 11880;
11882 -> 11875;
11883 -> 11880;
11883 -> 11875;
11884 -> 11875;
11885 -> 11876;
11885 -> 11884;
11885 -> 11875;
11886 -> 11877;
11886 -> 11849;
11886 -> 11875;
11887 -> 11878;
11887 -> 11880;
11887 -> 11875;
11888 -> 11876;
11888 -> 11880;
11888 -> 11875;
11889 -> 11877;
11889 -> 11880;
11889 -> 11875;
11890 -> 11871;
11890 -> 11864;
11891 -> 11871;
11891 -> 11864;
11892 -> 11871;
11892 -> 11864;
11893 -> 11871;
11893 -> 11864;
11894 -> 11871;
11894 -> 11864;
11895 -> 11871;
11895 -> 11864;
11896 -> 11871;
11896 -> 11864;
11897 -> 11864;
11898 -> 11868;
11898 -> 11897;
11898 -> 11864;
11899 -> 11864;
11900 -> 11866;
11900 -> 11899;
11900 -> 11864;
11901 -> 11866;
11901 -> 11871;
11901 -> 11864;
11902 -> 11865;
11902 -> 11871;
11902 -> 11864;
11903 -> 11868;
11903 -> 11871;
11903 -> 11864;
11904 -> 11870;
11904 -> 11871;
11904 -> 11864;
11905 -> 11869;
11905 -> 11871;
11905 -> 11864;
11906 -> 11208;
11906 -> 11863;
11906 -> 11849;
11906 -> 11880;
11906 -> 11881;
11906 -> 11882;
11906 -> 11888;
11906 -> 11883;
11906 -> 11887;
11906 -> 11889;
11906 -> 11890;
11906 -> 11902;
11906 -> 11891;
11906 -> 11901;
11906 -> 11892;
11906 -> 11903;
11906 -> 11893;
11906 -> 11904;
11906 -> 11894;
11906 -> 11905;
11906 -> 11895;
11906 -> 11896;
11906 -> 11183;
11907 -> 11906;
11907 -> 11884;
11907 -> 11875;
11908 -> 11906;
11908 -> 11875;
11909 -> 11185;
11909 -> 11906;
11909 -> 11183;
11910 -> 11183;
11911 -> 11906;
11911 -> 11183;
11912 -> 11909;
11912 -> 11910;
11913 -> 11912;
11913 -> 11909;
11913 -> 11910;
11914 -> 11183;
11915 -> 11913;
11915 -> 11183;
11916 -> 11183;
11917 -> 11183;
11918 -> 11183;
11919 -> 11918;
11919 -> 11183;
11920 -> 11183;
11921 -> 11920;
11921 -> 11183;
11922 -> 11183;
11923 -> 11922;
11923 -> 11183;
11924 -> 11184;
11924 -> 11915;
11924 -> 11183;
11925 -> 11183;
11926 -> 11924;
11926 -> 11925;
11926 -> 11183;
11927 -> 11926;
11927 -> 11183;
11928 -> 11183;
11929 -> 11927;
11929 -> 11928;
11929 -> 11183;
11930 -> 11929;
11930 -> 11183;
11931 -> 11183;
11932 -> 11930;
11932 -> 11931;
11932 -> 11183;
11933 -> 11932;
11933 -> 11183;
11934 -> 0;
11934 -> 11183;
11935 -> 11934;
11935 -> 11933;
11935 -> 11183;
11936 -> 11184;
11936 -> 11183;
11937 -> 11915;
11937 -> 11183;
11938 -> 11906;
11938 -> 11183;
11939 -> 11183;
11940 -> 11184;
11940 -> 11939;
11941 -> 11940;
11941 -> 11915;
11941 -> 11939;
11942 -> 11941;
11942 -> 11183;
11943 -> 11183;
11944 -> 11184;
11944 -> 11943;
11945 -> 11944;
11945 -> 11915;
11945 -> 11943;
11946 -> 11945;
11946 -> 11183;
11947 -> 11190;
11947 -> 11183;
11948 -> 11187;
11948 -> 11183;
11949 -> 11922;
11949 -> 11183;
11950 -> 11918;
11950 -> 11183;
11951 -> 11920;
11951 -> 11183;
11952 -> 11935;
11952 -> 11183;
11953 -> 11186;
11953 -> 11183;
11954 -> 11916;
11954 -> 11183;
11955 -> 11917;
11955 -> 11183;
11956 -> 11936;
11956 -> 11937;
11956 -> 11938;
11956 -> 11942;
11956 -> 11946;
11956 -> 11947;
11956 -> 11948;
11956 -> 11949;
11956 -> 11950;
11956 -> 11951;
11956 -> 11952;
11956 -> 11953;
11956 -> 11954;
11956 -> 11955;
11956 -> 11185;
11956 -> 11915;
11956 -> 11906;
11956 -> 11923;
11956 -> 11919;
11956 -> 11921;
11956 -> 0;
11956 -> 11183;
11957 -> 11183;
11958 -> 11956;
11958 -> 11957;
11959 -> 11956;
11959 -> 11957;
11960 -> 11956;
11960 -> 11957;
11961 -> 11960;
11961 -> 11956;
11961 -> 11957;
11962 -> 11958;
11962 -> 11957;
11963 -> 11957;
11964 -> 11959;
11964 -> 11957;
11965 -> 11961;
11965 -> 11962;
11965 -> 11963;
11965 -> 11964;
11965 -> 11956;
11965 -> 11957;
11966 -> 11956;
11966 -> 11957;
11967 -> 11966;
11967 -> 11965;
11967 -> 11957;
11968 -> 11956;
11968 -> 11957;
11969 -> 11968;
11969 -> 11967;
11969 -> 11957;
11970 -> 11956;
11970 -> 11957;
11971 -> 11970;
11971 -> 11969;
11971 -> 11957;
11972 -> 11956;
11972 -> 11957;
11973 -> 11972;
11973 -> 11971;
11973 -> 11957;
11974 -> 11956;
11974 -> 11957;
11975 -> 11957;
11976 -> 11974;
11976 -> 11973;
11976 -> 11975;
11976 -> 11957;
11977 -> 11976;
11978 -> 11977;
11978 -> 11974;
11978 -> 11976;
11979 -> 11974;
11979 -> 11973;
11979 -> 11978;
11979 -> 11976;
11980 -> 11976;
11981 -> 11979;
11981 -> 11980;
11982 -> 11974;
11982 -> 11980;
11983 -> 11982;
11983 -> 11973;
11983 -> 11980;
11984 -> 11983;
11984 -> 11973;
11984 -> 11978;
11984 -> 11980;
11985 -> 11976;
11986 -> 11974;
11986 -> 11973;
11986 -> 11978;
11986 -> 11957;
11987 -> 11974;
11987 -> 11986;
11988 -> 11986;
11989 -> 11987;
11989 -> 11988;
11990 -> 11974;
11990 -> 11988;
11991 -> 11990;
11991 -> 11986;
11991 -> 11988;
11992 -> 11986;
11993 -> 11986;
11993 -> 11183;
11994 -> 11986;
11994 -> 11183;
11995 -> 11986;
11995 -> 11183;
11996 -> 11906;
11996 -> 11995;
11996 -> 11986;
11996 -> 11994;
11996 -> 11183;
11997 -> 11183;
11998 -> 11183;
11999 -> 11998;
11999 -> 11183;
12000 -> 11986;
12000 -> 11183;
12001 -> 11994;
12001 -> 11183;
12002 -> 11996;
12002 -> 11183;
12003 -> 11906;
12003 -> 11183;
12004 -> 11906;
12004 -> 11996;
12004 -> 11183;
12005 -> 11187;
12005 -> 11183;
12006 -> 11190;
12006 -> 11183;
12007 -> 11997;
12007 -> 11183;
12008 -> 11998;
12008 -> 11183;
12009 -> 12000;
12009 -> 12001;
12009 -> 12002;
12009 -> 12003;
12009 -> 12004;
12009 -> 12005;
12009 -> 12006;
12009 -> 12007;
12009 -> 12008;
12009 -> 11996;
12009 -> 11994;
12009 -> 11999;
12009 -> 11183;
12010 -> 11183;
12011 -> 11183;
12012 -> 12011;
12012 -> 11986;
12012 -> 12009;
12012 -> 11183;
12013 -> 11986;
12013 -> 12009;
12013 -> 12011;
12013 -> 12012;
12014 -> 12013;
12014 -> 12009;
12014 -> 12012;
12015 -> 11986;
12015 -> 12011;
12015 -> 12009;
12015 -> 12014;
12016 -> 12014;
12017 -> 12015;
12017 -> 12016;
12018 -> 12017;
12018 -> 12015;
12018 -> 12016;
12019 -> 12016;
12020 -> 12017;
12020 -> 12019;
12021 -> 12020;
12021 -> 12016;
12022 -> 12016;
12023 -> 12017;
12023 -> 12022;
12024 -> 12022;
12025 -> 12023;
12025 -> 12024;
12026 -> 12025;
12026 -> 12015;
12026 -> 12024;
12027 -> 12025;
12027 -> 12015;
12027 -> 12026;
12028 -> 12027;
12028 -> 12025;
12028 -> 12026;
12029 -> 12026;
12030 -> 12029;
12030 -> 12025;
12030 -> 12026;
12031 -> 12025;
12031 -> 12027;
12031 -> 12028;
12031 -> 12024;
12032 -> 12031;
12032 -> 12022;
12033 -> 12023;
12033 -> 12027;
12033 -> 12022;
12034 -> 12033;
12034 -> 12016;
12035 -> 12016;
12036 -> 12016;
12037 -> 12018;
12037 -> 12036;
12038 -> 12018;
12038 -> 12036;
12039 -> 12021;
12039 -> 12036;
12040 -> 12034;
12040 -> 12036;
12041 -> 12035;
12041 -> 12036;
12042 -> 12036;
12043 -> 12041;
12043 -> 12042;
12044 -> 12042;
12045 -> 12043;
12045 -> 12044;
12048 -> 12047;
12048 -> 12046;
12049 -> 12046;
12050 -> 12044;
12051 -> 12045;
12051 -> 12050;
12052 -> 12050;
12053 -> 12051;
12053 -> 12052;
12054 -> 12053;
12054 -> 12052;
12055 -> 12051;
12055 -> 12050;
12056 -> 12044;
12057 -> 12056;
12057 -> 12045;
12057 -> 12044;
12058 -> 12045;
12058 -> 12044;
12059 -> 12043;
12059 -> 12042;
12060 -> 12043;
12060 -> 12042;
12061 -> 12043;
12061 -> 12042;
12062 -> 12043;
12062 -> 12042;
12063 -> 12043;
12063 -> 12042;
12064 -> 12043;
12064 -> 12042;
12065 -> 12043;
12065 -> 12042;
12066 -> 12041;
12066 -> 12036;
12067 -> 12041;
12067 -> 12036;
12068 -> 12041;
12068 -> 12036;
12069 -> 12036;
12070 -> 12037;
12070 -> 12069;
12070 -> 12036;
12071 -> 12036;
12072 -> 12038;
12072 -> 12071;
12072 -> 12036;
12073 -> 12037;
12073 -> 12041;
12073 -> 12036;
12074 -> 12038;
12074 -> 12041;
12074 -> 12036;
12075 -> 12037;
12075 -> 12027;
12075 -> 12028;
12075 -> 12030;
12075 -> 12036;
12076 -> 12036;
12077 -> 12076;
12077 -> 12037;
12077 -> 12027;
12077 -> 12028;
12077 -> 12030;
12077 -> 12036;
12078 -> 12041;
12078 -> 12077;
12080 -> 12079;
12081 -> 12037;
12081 -> 12027;
12081 -> 12076;
12081 -> 12028;
12081 -> 12030;
12081 -> 12077;
12082 -> 12040;
12082 -> 12077;
12083 -> 12076;
12083 -> 12077;
12084 -> 12077;
12085 -> 12077;
12086 -> 12078;
12086 -> 12085;
12087 -> 12081;
12087 -> 12085;
12088 -> 12082;
12088 -> 12085;
12089 -> 12083;
12089 -> 12085;
12090 -> 12084;
12090 -> 12085;
12091 -> 12086;
12091 -> 12085;
12092 -> 12087;
12092 -> 12085;
12093 -> 12088;
12093 -> 12085;
12094 -> 12089;
12094 -> 12085;
12095 -> 12085;
12096 -> 12091;
12096 -> 12095;
12097 -> 12092;
12097 -> 12095;
12098 -> 12093;
12098 -> 12095;
12099 -> 12094;
12099 -> 12095;
12100 -> 12090;
12100 -> 12095;
12101 -> 12095;
12102 -> 12100;
12102 -> 12101;
12103 -> 12101;
12104 -> 12102;
12104 -> 12103;
12105 -> 12103;
12106 -> 12104;
12106 -> 12105;
12107 -> 12106;
12107 -> 12105;
12108 -> 12102;
12108 -> 12101;
12109 -> 12100;
12109 -> 12095;
12110 -> 12100;
12110 -> 12095;
12111 -> 12100;
12111 -> 12095;
12112 -> 12100;
12112 -> 12095;
12113 -> 12100;
12113 -> 12095;
12114 -> 12100;
12114 -> 12095;
12115 -> 12100;
12115 -> 12095;
12116 -> 12095;
12117 -> 12116;
12117 -> 12095;
12118 -> 12080;
12118 -> 12095;
12119 -> 12117;
12119 -> 12118;
12119 -> 12095;
12120 -> 12119;
12120 -> 12100;
12120 -> 12095;
12121 -> 12095;
12122 -> 12121;
12122 -> 12095;
12123 -> 12080;
12123 -> 12095;
12124 -> 12122;
12124 -> 12123;
12124 -> 12095;
12125 -> 12124;
12125 -> 12100;
12125 -> 12095;
12126 -> 12100;
12126 -> 12095;
12127 -> 12100;
12127 -> 12095;
12128 -> 12100;
12128 -> 12095;
12129 -> 12100;
12129 -> 12095;
12130 -> 12095;
12131 -> 12096;
12131 -> 12130;
12131 -> 12095;
12132 -> 12095;
12133 -> 12097;
12133 -> 12132;
12133 -> 12095;
12134 -> 12096;
12134 -> 12100;
12134 -> 12095;
12135 -> 12099;
12135 -> 12100;
12135 -> 12095;
12136 -> 12097;
12136 -> 12100;
12136 -> 12095;
12137 -> 12098;
12137 -> 12100;
12137 -> 12095;
12138 -> 12100;
12138 -> 12095;
12139 -> 12095;
12140 -> 12095;
12141 -> 12138;
12141 -> 12140;
12142 -> 12139;
12142 -> 12140;
12143 -> 12140;
12144 -> 12142;
12144 -> 12143;
12145 -> 12143;
12146 -> 12144;
12146 -> 12145;
12147 -> 12145;
12148 -> 12146;
12148 -> 12147;
12149 -> 12147;
12150 -> 12148;
12150 -> 12149;
12151 -> 12150;
12151 -> 12149;
12152 -> 12146;
12152 -> 12145;
12153 -> 12146;
12153 -> 12145;
12154 -> 12144;
12154 -> 12143;
12155 -> 12144;
12155 -> 12143;
12156 -> 12144;
12156 -> 12143;
12157 -> 12142;
12157 -> 12140;
12158 -> 12140;
12159 -> 12141;
12159 -> 12158;
12159 -> 12140;
12160 -> 12141;
12160 -> 12142;
12160 -> 12140;
12161 -> 12139;
12161 -> 12100;
12161 -> 12095;
12162 -> 12100;
12162 -> 12095;
12163 -> 12162;
12163 -> 12107;
12163 -> 12108;
12163 -> 12134;
12163 -> 12135;
12163 -> 12136;
12163 -> 12161;
12163 -> 12113;
12163 -> 12114;
12163 -> 12115;
12163 -> 12120;
12163 -> 12125;
12163 -> 12137;
12163 -> 12127;
12163 -> 12128;
12163 -> 12129;
12163 -> 12119;
12163 -> 12124;
12163 -> 12054;
12163 -> 12055;
12163 -> 12057;
12163 -> 12058;
12163 -> 12059;
12163 -> 12060;
12163 -> 12061;
12163 -> 12062;
12163 -> 12063;
12163 -> 12064;
12163 -> 12065;
12163 -> 12073;
12163 -> 12074;
12163 -> 12068;
12163 -> 12056;
12163 -> 12081;
12163 -> 12151;
12163 -> 12152;
12163 -> 12153;
12163 -> 12154;
12163 -> 12155;
12163 -> 12156;
12163 -> 12160;
12163 -> 12095;
12164 -> 12163;
12164 -> 12100;
12164 -> 12095;
12165 -> 12085;
12166 -> 12089;
12166 -> 12165;
12166 -> 12085;
12167 -> 12084;
12167 -> 12076;
12167 -> 12075;
12167 -> 12077;
12168 -> 12075;
12168 -> 12036;
12169 -> 12168;
12169 -> 12075;
12169 -> 12167;
12169 -> 12163;
12169 -> 12164;
12169 -> 12036;
12170 -> 12169;
12170 -> 12041;
12170 -> 12036;
12171 -> 12039;
12171 -> 12041;
12171 -> 12036;
12172 -> 12035;
12172 -> 12014;
12173 -> 12172;
12173 -> 12013;
12173 -> 12014;
12174 -> 12011;
12174 -> 12014;
12175 -> 12010;
12175 -> 12174;
12175 -> 12014;
12176 -> 11986;
12176 -> 12011;
12176 -> 12169;
12176 -> 12170;
12176 -> 12171;
12176 -> 12012;
12177 -> 12012;
12178 -> 12176;
12178 -> 12177;
12179 -> 12012;
12180 -> 12013;
12180 -> 12009;
12180 -> 12173;
12180 -> 12179;
12181 -> 12180;
12181 -> 12176;
12181 -> 12179;
12182 -> 12178;
12182 -> 12181;
12182 -> 12012;
12183 -> 12176;
12184 -> 12183;
12184 -> 12176;
12185 -> 12176;
12186 -> 12176;
12187 -> 12176;
12188 -> 12176;
12189 -> 12176;
12190 -> 12176;
12191 -> 12176;
12192 -> 12176;
12193 -> 12176;
12194 -> 12176;
12195 -> 12176;
12196 -> 12176;
12197 -> 12176;
12198 -> 12176;
12199 -> 12176;
12200 -> 12012;
12200 -> 12176;
12201 -> 12010;
12201 -> 12175;
12201 -> 12200;
12201 -> 12176;
12202 -> 12176;
12203 -> 12176;
12204 -> 12176;
12204 -> 12199;
12204 -> 12203;
12205 -> 12204;
12205 -> 12176;
12205 -> 12203;
12206 -> 12202;
12206 -> 12205;
12206 -> 12176;
12207 -> 12202;
12207 -> 12176;
12208 -> 12202;
12208 -> 12176;
12209 -> 12202;
12210 -> 12202;
12211 -> 12202;
12212 -> 12202;
12213 -> 12202;
12214 -> 12202;
12215 -> 12202;
12216 -> 12202;
12217 -> 12202;
12218 -> 12202;
12218 -> 12198;
12218 -> 12176;
12219 -> 12202;
12219 -> 12176;
12220 -> 12176;
12221 -> 12176;
12221 -> 12219;
12221 -> 12203;
12222 -> 12221;
12222 -> 12202;
12222 -> 12203;
12223 -> 12202;
12224 -> 12223;
12224 -> 12202;
12225 -> 12202;
12226 -> 12202;
12227 -> 12202;
12228 -> 12202;
12229 -> 12202;
12230 -> 12202;
12231 -> 12176;
12231 -> 12202;
12232 -> 12010;
12232 -> 12175;
12232 -> 12201;
12232 -> 12231;
12232 -> 12202;
12233 -> 12202;
12234 -> 12202;
12234 -> 12230;
12234 -> 12233;
12235 -> 12234;
12235 -> 12202;
12235 -> 12233;
12236 -> 12202;
12237 -> 11184;
12237 -> 11183;
12238 -> 11185;
12238 -> 12202;
12238 -> 11183;
12239 -> 11184;
12239 -> 12202;
12239 -> 11183;
12240 -> 11183;
12242 -> 11906;
12242 -> 11183;
12243 -> 11183;
12244 -> 12237;
12244 -> 12243;
12245 -> 12238;
12245 -> 12243;
12246 -> 12239;
12246 -> 12243;
12247 -> 12242;
12247 -> 12243;
12248 -> 12240;
12248 -> 12243;
12249 -> 12243;
12250 -> 12248;
12250 -> 12249;
12251 -> 12249;
12252 -> 12250;
12252 -> 12251;
12253 -> 12251;
12254 -> 12252;
12254 -> 12253;
12255 -> 12253;
12256 -> 12254;
12256 -> 12255;
12257 -> 12256;
12257 -> 12255;
12258 -> 12254;
12258 -> 12253;
12259 -> 12251;
12260 -> 12259;
12260 -> 12252;
12260 -> 12251;
12261 -> 12252;
12261 -> 12251;
12262 -> 12250;
12262 -> 12249;
12263 -> 12250;
12263 -> 12249;
12264 -> 12250;
12264 -> 12249;
12265 -> 12250;
12265 -> 12249;
12266 -> 12250;
12266 -> 12249;
12267 -> 12250;
12267 -> 12249;
12268 -> 12250;
12268 -> 12249;
12269 -> 12248;
12269 -> 12243;
12270 -> 12248;
12270 -> 12243;
12271 -> 12248;
12271 -> 12243;
12272 -> 12248;
12272 -> 12243;
12273 -> 12248;
12273 -> 12243;
12274 -> 12248;
12274 -> 12243;
12275 -> 12248;
12275 -> 12243;
12276 -> 12248;
12276 -> 12243;
12277 -> 12248;
12277 -> 12243;
12278 -> 12243;
12279 -> 12278;
12279 -> 12248;
12279 -> 12243;
12280 -> 12243;
12281 -> 12280;
12281 -> 12248;
12281 -> 12243;
12282 -> 12243;
12283 -> 12282;
12283 -> 12248;
12283 -> 12243;
12284 -> 12248;
12284 -> 12243;
12285 -> 12248;
12285 -> 12243;
12286 -> 12243;
12287 -> 12244;
12287 -> 12286;
12287 -> 12243;
12288 -> 12243;
12289 -> 12245;
12289 -> 12288;
12289 -> 12243;
12290 -> 12246;
12290 -> 12243;
12291 -> 12247;
12291 -> 11906;
12291 -> 12243;
12292 -> 12244;
12292 -> 12248;
12292 -> 12243;
12293 -> 12245;
12293 -> 12248;
12293 -> 12243;
12294 -> 12243;
12295 -> 12294;
12295 -> 12247;
12295 -> 11906;
12295 -> 12243;
12296 -> 12248;
12296 -> 12243;
12297 -> 12243;
12298 -> 12244;
12298 -> 12297;
12299 -> 12297;
12300 -> 12298;
12300 -> 12239;
12300 -> 12299;
12301 -> 12300;
12301 -> 12243;
12302 -> 12246;
12302 -> 12243;
12303 -> 12243;
12304 -> 12243;
12305 -> 12296;
12305 -> 12304;
12306 -> 12301;
12306 -> 12304;
12307 -> 12302;
12307 -> 12304;
12308 -> 12303;
12308 -> 12304;
12309 -> 12304;
12310 -> 12308;
12310 -> 12309;
12311 -> 12309;
12312 -> 12310;
12312 -> 12311;
12313 -> 12311;
12314 -> 12312;
12314 -> 12313;
12315 -> 12314;
12315 -> 12313;
12316 -> 12310;
12316 -> 12309;
12317 -> 12308;
12317 -> 12304;
12318 -> 0;
12318 -> 12308;
12318 -> 12304;
12319 -> 12308;
12319 -> 12304;
12320 -> 12308;
12320 -> 12304;
12321 -> 12308;
12321 -> 12304;
12322 -> 12308;
12322 -> 12304;
12323 -> 12308;
12323 -> 12304;
12324 -> 12304;
12325 -> 12305;
12325 -> 12324;
12325 -> 12304;
12326 -> 12305;
12326 -> 12308;
12326 -> 12304;
12327 -> 12306;
12327 -> 12308;
12327 -> 12304;
12328 -> 12307;
12328 -> 12308;
12328 -> 12304;
12329 -> 12295;
12329 -> 12303;
12329 -> 12315;
12329 -> 12316;
12329 -> 12326;
12329 -> 12318;
12329 -> 12327;
12329 -> 12320;
12329 -> 12321;
12329 -> 12322;
12329 -> 12328;
12329 -> 12257;
12329 -> 12258;
12329 -> 12260;
12329 -> 12261;
12329 -> 12262;
12329 -> 12263;
12329 -> 12264;
12329 -> 12265;
12329 -> 12266;
12329 -> 12267;
12329 -> 12268;
12329 -> 12292;
12329 -> 12270;
12329 -> 12293;
12329 -> 12272;
12329 -> 12273;
12329 -> 12274;
12329 -> 12275;
12329 -> 12276;
12329 -> 12277;
12329 -> 12279;
12329 -> 12281;
12329 -> 12283;
12329 -> 12284;
12329 -> 12285;
12329 -> 12259;
12329 -> 12239;
12329 -> 12278;
12329 -> 12280;
12329 -> 12282;
12329 -> 12243;
12330 -> 12243;
12331 -> 12244;
12331 -> 12330;
12332 -> 12331;
12332 -> 12329;
12332 -> 12330;
12333 -> 12332;
12333 -> 12243;
12334 -> 12333;
12334 -> 12243;
12335 -> 12247;
12335 -> 12243;
12336 -> 12295;
12336 -> 12329;
12336 -> 12243;
12337 -> 12336;
12337 -> 12248;
12337 -> 12243;
12338 -> 12243;
12339 -> 12244;
12339 -> 12338;
12340 -> 12339;
12340 -> 12329;
12340 -> 12338;
12341 -> 12340;
12341 -> 12243;
12342 -> 12341;
12342 -> 12329;
12342 -> 12337;
12342 -> 12243;
12343 -> 11183;
12344 -> 11183;
12345 -> 11986;
12345 -> 12344;
12345 -> 11183;
12346 -> 12345;
12347 -> 11986;
12347 -> 12329;
12347 -> 12337;
12347 -> 12346;
12348 -> 12347;
12348 -> 11183;
12349 -> 11183;
12350 -> 12348;
12350 -> 12349;
12351 -> 12240;
12351 -> 12349;
12352 -> 12349;
12353 -> 12351;
12353 -> 12329;
12353 -> 12352;
12353 -> 12349;
12354 -> 12350;
12354 -> 12351;
12354 -> 12349;
12355 -> 11183;
12356 -> 11183;
12357 -> 11183;
12358 -> 11986;
12358 -> 12329;
12358 -> 12357;
12358 -> 11183;
12359 -> 11183;
12360 -> 12359;
12360 -> 11183;
12361 -> 12240;
12361 -> 11183;
12362 -> 11906;
12362 -> 11183;
12363 -> 12358;
12363 -> 11183;
12364 -> 11986;
12364 -> 11183;
12365 -> 12356;
12365 -> 11183;
12366 -> 12359;
12366 -> 11183;
12367 -> 11183;
12368 -> 12361;
12368 -> 12367;
12369 -> 12362;
12369 -> 12367;
12370 -> 12363;
12370 -> 12367;
12371 -> 12364;
12371 -> 12367;
12372 -> 12365;
12372 -> 12367;
12373 -> 12366;
12373 -> 12367;
12374 -> 12367;
12375 -> 12368;
12375 -> 12374;
12376 -> 12375;
12376 -> 12329;
12376 -> 12337;
12376 -> 12374;
12377 -> 12376;
12377 -> 12367;
12378 -> 12367;
12379 -> 12378;
12379 -> 12369;
12379 -> 11906;
12379 -> 12367;
12380 -> 12377;
12380 -> 12329;
12380 -> 12336;
12380 -> 12379;
12380 -> 12367;
12381 -> 12367;
12382 -> 12377;
12382 -> 12329;
12382 -> 12336;
12382 -> 12381;
12382 -> 12367;
12383 -> 12382;
12383 -> 12367;
12384 -> 12367;
12385 -> 12367;
12386 -> 12385;
12386 -> 12377;
12386 -> 12329;
12386 -> 12336;
12386 -> 12367;
12387 -> 12386;
12388 -> 12387;
12388 -> 12386;
12389 -> 12370;
12389 -> 12388;
12390 -> 12389;
12390 -> 12386;
12391 -> 12389;
12391 -> 12386;
12392 -> 12386;
12393 -> 12386;
12394 -> 12393;
12394 -> 12389;
12394 -> 12386;
12395 -> 12394;
12396 -> 12371;
12396 -> 12329;
12396 -> 12337;
12396 -> 12354;
12396 -> 12395;
12396 -> 12394;
12397 -> 12394;
12398 -> 12371;
12398 -> 12329;
12398 -> 12337;
12398 -> 12354;
12398 -> 12397;
12398 -> 12394;
12399 -> 12384;
12399 -> 12393;
12399 -> 12394;
12400 -> 12398;
12400 -> 12329;
12400 -> 12337;
12400 -> 12354;
12400 -> 12336;
12400 -> 12399;
12400 -> 12394;
12401 -> 12400;
12401 -> 12329;
12401 -> 12336;
12401 -> 12394;
12402 -> 12400;
12402 -> 12329;
12402 -> 12336;
12402 -> 12394;
12403 -> 12371;
12403 -> 12402;
12404 -> 12400;
12404 -> 12402;
12405 -> 12392;
12405 -> 12402;
12406 -> 12402;
12407 -> 12403;
12407 -> 12406;
12408 -> 12404;
12408 -> 12406;
12409 -> 12405;
12409 -> 12406;
12410 -> 12408;
12410 -> 12329;
12410 -> 12336;
12410 -> 12406;
12411 -> 12408;
12411 -> 12329;
12411 -> 12336;
12411 -> 12406;
12412 -> 12407;
12412 -> 12329;
12412 -> 12337;
12412 -> 12354;
12412 -> 12408;
12412 -> 12336;
12412 -> 12406;
12413 -> 12412;
12413 -> 12406;
12414 -> 12406;
12415 -> 12408;
12415 -> 12329;
12415 -> 12336;
12415 -> 12414;
12415 -> 12406;
12416 -> 12412;
12416 -> 12406;
12417 -> 12416;
12417 -> 12393;
12417 -> 12391;
12417 -> 12402;
12418 -> 12400;
12418 -> 12329;
12418 -> 12336;
12418 -> 12393;
12418 -> 12390;
12418 -> 12394;
12419 -> 12384;
12419 -> 12394;
12420 -> 12398;
12420 -> 12329;
12420 -> 12337;
12420 -> 12354;
12420 -> 12336;
12420 -> 12419;
12420 -> 12394;
12421 -> 12420;
12421 -> 12329;
12421 -> 12336;
12421 -> 12394;
12422 -> 12420;
12422 -> 12329;
12422 -> 12336;
12422 -> 12394;
12423 -> 12371;
12423 -> 12422;
12424 -> 12420;
12424 -> 12422;
12425 -> 12422;
12426 -> 12423;
12426 -> 12425;
12427 -> 12424;
12427 -> 12425;
12428 -> 12427;
12428 -> 12329;
12428 -> 12336;
12428 -> 12425;
12429 -> 12427;
12429 -> 12329;
12429 -> 12336;
12429 -> 12425;
12430 -> 12426;
12430 -> 12329;
12430 -> 12337;
12430 -> 12354;
12430 -> 12427;
12430 -> 12336;
12430 -> 12425;
12431 -> 12430;
12431 -> 12425;
12432 -> 12425;
12433 -> 12427;
12433 -> 12329;
12433 -> 12336;
12433 -> 12432;
12433 -> 12425;
12434 -> 12430;
12434 -> 12425;
12435 -> 12434;
12435 -> 12394;
12435 -> 12391;
12435 -> 12422;
12436 -> 12420;
12436 -> 12329;
12436 -> 12336;
12436 -> 12394;
12436 -> 12390;
12437 -> 12390;
12437 -> 12386;
12438 -> 12437;
12438 -> 12390;
12438 -> 12418;
12438 -> 12436;
12438 -> 12329;
12438 -> 12337;
12438 -> 12354;
12438 -> 12336;
12438 -> 12386;
12439 -> 12391;
12439 -> 12386;
12440 -> 12439;
12440 -> 12391;
12440 -> 12417;
12440 -> 12435;
12440 -> 12438;
12440 -> 12386;
12441 -> 12409;
12441 -> 12386;
12442 -> 12438;
12442 -> 12440;
12442 -> 12441;
12442 -> 12386;
12443 -> 12386;
12444 -> 12377;
12444 -> 12385;
12444 -> 12329;
12444 -> 12337;
12444 -> 12354;
12444 -> 12336;
12444 -> 12442;
12444 -> 12386;
12445 -> 12442;
12445 -> 12386;
12446 -> 12368;
12446 -> 12386;
12447 -> 12386;
12448 -> 12445;
12448 -> 12447;
12449 -> 12446;
12449 -> 12447;
12450 -> 12444;
12450 -> 12447;
12451 -> 12447;
12452 -> 12448;
12452 -> 12451;
12452 -> 12447;
12453 -> 12447;
12454 -> 12450;
12454 -> 12453;
12455 -> 12453;
12456 -> 12454;
12456 -> 12444;
12456 -> 12455;
12456 -> 12453;
12457 -> 12447;
12458 -> 12448;
12458 -> 12450;
12458 -> 12447;
12459 -> 12386;
12460 -> 12384;
12460 -> 12389;
12460 -> 12386;
12461 -> 12383;
12461 -> 12367;
12462 -> 11183;
12463 -> 11183;
12464 -> 12010;
12464 -> 12175;
12464 -> 12201;
12464 -> 12232;
12464 -> 12463;
12464 -> 11183;
12465 -> 11986;
12465 -> 12464;
12466 -> 12010;
12466 -> 12464;
12467 -> 12240;
12467 -> 12464;
12468 -> 11986;
12468 -> 12464;
12469 -> 12372;
12469 -> 12464;
12470 -> 12464;
12471 -> 12466;
12471 -> 12470;
12472 -> 12467;
12472 -> 12470;
12473 -> 12468;
12473 -> 12470;
12474 -> 12468;
12474 -> 12470;
12475 -> 12469;
12475 -> 12470;
12476 -> 12470;
12477 -> 12471;
12477 -> 12010;
12477 -> 12175;
12477 -> 12201;
12477 -> 12232;
12477 -> 12476;
12477 -> 12470;
12478 -> 12470;
12479 -> 12472;
12479 -> 12478;
12480 -> 12479;
12480 -> 12444;
12480 -> 12478;
12481 -> 12480;
12481 -> 12470;
12482 -> 12470;
12483 -> 12481;
12483 -> 12482;
12483 -> 12470;
12484 -> 12471;
12484 -> 12470;
12485 -> 12473;
12485 -> 12484;
12485 -> 12444;
12485 -> 12458;
12486 -> 12484;
12487 -> 12485;
12487 -> 12486;
12487 -> 12484;
12488 -> 12473;
12488 -> 12484;
12488 -> 12485;
12488 -> 12487;
12489 -> 12488;
12489 -> 12487;
12490 -> 12474;
12490 -> 12487;
12491 -> 12474;
12491 -> 12488;
12491 -> 12484;
12491 -> 12487;
12492 -> 12475;
12492 -> 12487;
12493 -> 12472;
12493 -> 12487;
12494 -> 12487;
12495 -> 12489;
12495 -> 12494;
12496 -> 12490;
12496 -> 12494;
12497 -> 12491;
12497 -> 12494;
12498 -> 12492;
12498 -> 12494;
12499 -> 12493;
12499 -> 12494;
12500 -> 12497;
12500 -> 12488;
12500 -> 12494;
12501 -> 12497;
12501 -> 12488;
12501 -> 12494;
12502 -> 12497;
12502 -> 12488;
12502 -> 12494;
12503 -> 12494;
12504 -> 12502;
12504 -> 12503;
12505 -> 12504;
12505 -> 12488;
12505 -> 12503;
12506 -> 12505;
12506 -> 12494;
12507 -> 12506;
12507 -> 12488;
12507 -> 12494;
12508 -> 12494;
12509 -> 12494;
12510 -> 12509;
12510 -> 12507;
12510 -> 12494;
12511 -> 12495;
12511 -> 12488;
12511 -> 12509;
12511 -> 12510;
12512 -> 12511;
12512 -> 12510;
12513 -> 12511;
12513 -> 12510;
12514 -> 12510;
12515 -> 12495;
12515 -> 12514;
12516 -> 12515;
12516 -> 12511;
12516 -> 12514;
12517 -> 12516;
12517 -> 12510;
12518 -> 12508;
12518 -> 12510;
12519 -> 12512;
12519 -> 12510;
12520 -> 12510;
12521 -> 12511;
12521 -> 12510;
12522 -> 12517;
12522 -> 12518;
12522 -> 12519;
12522 -> 12520;
12522 -> 12521;
12522 -> 12511;
12522 -> 12512;
12522 -> 12510;
12523 -> 12510;
12524 -> 12510;
12525 -> 12524;
12525 -> 12511;
12525 -> 12510;
12526 -> 12512;
12526 -> 12510;
12527 -> 12526;
12527 -> 12522;
12527 -> 12510;
12528 -> 12513;
12528 -> 12510;
12529 -> 12523;
12529 -> 12510;
12530 -> 12527;
12530 -> 12528;
12530 -> 12529;
12530 -> 12510;
12531 -> 12506;
12531 -> 12509;
12531 -> 12488;
12531 -> 12530;
12531 -> 12510;
12532 -> 12530;
12532 -> 12510;
12533 -> 12499;
12533 -> 12510;
12534 -> 12510;
12535 -> 12532;
12535 -> 12534;
12536 -> 12533;
12536 -> 12534;
12537 -> 12531;
12537 -> 12534;
12538 -> 12534;
12539 -> 12535;
12539 -> 12538;
12539 -> 12534;
12540 -> 12534;
12541 -> 12537;
12541 -> 12540;
12542 -> 12540;
12543 -> 12541;
12543 -> 12531;
12543 -> 12542;
12543 -> 12540;
12544 -> 12534;
12545 -> 12510;
12546 -> 12508;
12546 -> 12511;
12546 -> 12510;
12547 -> 12487;
12548 -> 12498;
12548 -> 12535;
12549 -> 12472;
12549 -> 12535;
12550 -> 12535;
12551 -> 12549;
12551 -> 12535;
12552 -> 12535;
12553 -> 12535;
12554 -> 12535;
12555 -> 12535;
12555 -> 12554;
12556 -> 12555;
12556 -> 12535;
12556 -> 12554;
12557 -> 12550;
12557 -> 12556;
12558 -> 12555;
12558 -> 12556;
12559 -> 12535;
12559 -> 12556;
12560 -> 12556;
12561 -> 12557;
12561 -> 12560;
12562 -> 12558;
12562 -> 12560;
12563 -> 12559;
12563 -> 12560;
12564 -> 12562;
12564 -> 12535;
12564 -> 12560;
12565 -> 12562;
12565 -> 12535;
12565 -> 12560;
12566 -> 12561;
12566 -> 12560;
12567 -> 12560;
12568 -> 12562;
12568 -> 12535;
12568 -> 12567;
12568 -> 12560;
12569 -> 12561;
12569 -> 12554;
12569 -> 12535;
12569 -> 12556;
12570 -> 12535;
12570 -> 12554;
12570 -> 12556;
12571 -> 12548;
12571 -> 12556;
12572 -> 12556;
12573 -> 12570;
12573 -> 12572;
12574 -> 12571;
12574 -> 12572;
12575 -> 12572;
12576 -> 12572;
12577 -> 12574;
12577 -> 12576;
12577 -> 12572;
12578 -> 12577;
12579 -> 12573;
12579 -> 12572;
12580 -> 12572;
12581 -> 12572;
12582 -> 12579;
12582 -> 12581;
12583 -> 12580;
12583 -> 12581;
12584 -> 12581;
12585 -> 12583;
12585 -> 12581;
12586 -> 12583;
12586 -> 12581;
12587 -> 12581;
12588 -> 12582;
12588 -> 12587;
12588 -> 12581;
12589 -> 12582;
12589 -> 12583;
12589 -> 12581;
12590 -> 12583;
12590 -> 12581;
12591 -> 12581;
12592 -> 12581;
12593 -> 12590;
12593 -> 12592;
12594 -> 12591;
12594 -> 12592;
12595 -> 12591;
12595 -> 12592;
12596 -> 12592;
12597 -> 12595;
12597 -> 12592;
12598 -> 12595;
12598 -> 12592;
12599 -> 12595;
12599 -> 12592;
12600 -> 12592;
12601 -> 12593;
12601 -> 12600;
12601 -> 12592;
12602 -> 12592;
12603 -> 12594;
12603 -> 12602;
12603 -> 12592;
12604 -> 12593;
12604 -> 12595;
12604 -> 12592;
12605 -> 12594;
12605 -> 12595;
12605 -> 12592;
12606 -> 12595;
12606 -> 12592;
12607 -> 12592;
12608 -> 12592;
12609 -> 12606;
12609 -> 12608;
12610 -> 12607;
12610 -> 12608;
12611 -> 12608;
12612 -> 12610;
12612 -> 12608;
12613 -> 12610;
12613 -> 12608;
12614 -> 12608;
12615 -> 12609;
12615 -> 12614;
12615 -> 12608;
12616 -> 12609;
12616 -> 12610;
12616 -> 12608;
12617 -> 11231;
12617 -> 12610;
12617 -> 12608;
12618 -> 12607;
12618 -> 12595;
12618 -> 12592;
12619 -> 12591;
12619 -> 12583;
12619 -> 12581;
12620 -> 12573;
12620 -> 12572;
12621 -> 12580;
12621 -> 12572;
12622 -> 12578;
12622 -> 12620;
12622 -> 12621;
12622 -> 12572;
12623 -> 12580;
12623 -> 12572;
12624 -> 12623;
12624 -> 12556;
12625 -> 12624;
12625 -> 12554;
12625 -> 12535;
12625 -> 12556;
12626 -> 12573;
12626 -> 12578;
12627 -> 12575;
12627 -> 12578;
12628 -> 12578;
12628 -> 12626;
12628 -> 12627;
12628 -> 12535;
12628 -> 12622;
12628 -> 12583;
12628 -> 12589;
12628 -> 12619;
12628 -> 12595;
12628 -> 12604;
12628 -> 12605;
12628 -> 12618;
12628 -> 12610;
12628 -> 12617;
12628 -> 12616;
12629 -> 12535;
12629 -> 12569;
12629 -> 12625;
12629 -> 12628;
12630 -> 12551;
12630 -> 12535;
12631 -> 12535;
12632 -> 12629;
12632 -> 12631;
12632 -> 12535;
12633 -> 12535;
12634 -> 12629;
12634 -> 12633;
12635 -> 12633;
12636 -> 12634;
12636 -> 12629;
12636 -> 12635;
12636 -> 12633;
12637 -> 12535;
12638 -> 12535;
12639 -> 12472;
12639 -> 12629;
12640 -> 12639;
12640 -> 12629;
12641 -> 12629;
12642 -> 12629;
12643 -> 12629;
12644 -> 12629;
12645 -> 12629;
12646 -> 12629;
12647 -> 12629;
12648 -> 12647;
12648 -> 12629;
12649 -> 12647;
12649 -> 12629;
12650 -> 12629;
12651 -> 12647;
12651 -> 12650;
12651 -> 12629;
12652 -> 12647;
12652 -> 12629;
12653 -> 12647;
12653 -> 12629;
12654 -> 12647;
12654 -> 12629;
12655 -> 12629;
12656 -> 12647;
12656 -> 12655;
12656 -> 12629;
12657 -> 12629;
12658 -> 12647;
12658 -> 12657;
12658 -> 12629;
12659 -> 12647;
12659 -> 12629;
12660 -> 12647;
12660 -> 12629;
12661 -> 12629;
12662 -> 12647;
12662 -> 12661;
12662 -> 12629;
12663 -> 12647;
12664 -> 12647;
12665 -> 12647;
12666 -> 12647;
12667 -> 12647;
12668 -> 12647;
12669 -> 12647;
12670 -> 12647;
12671 -> 12647;
12672 -> 12647;
12673 -> 12647;
12674 -> 12640;
12674 -> 12629;
12675 -> 12629;
12676 -> 12647;
12676 -> 12675;
12676 -> 12629;
12677 -> 12629;
12678 -> 12647;
12678 -> 12677;
12679 -> 12677;
12680 -> 12678;
12680 -> 12647;
12680 -> 12679;
12680 -> 12677;
12681 -> 12629;
12682 -> 12629;
12683 -> 12472;
12683 -> 12647;
12684 -> 12683;
12684 -> 12647;
12685 -> 12647;
12686 -> 12647;
12687 -> 12647;
12688 -> 12647;
12689 -> 12647;
12690 -> 12647;
12691 -> 12690;
12692 -> 12691;
12693 -> 12647;
12693 -> 12690;
12694 -> 12692;
12694 -> 12693;
12694 -> 12690;
12695 -> 12694;
12696 -> 12694;
12697 -> 12694;
12698 -> 12694;
12699 -> 12694;
12700 -> 12694;
12701 -> 12694;
12702 -> 12694;
12703 -> 12694;
12704 -> 12694;
12705 -> 12694;
12706 -> 12684;
12706 -> 12647;
12707 -> 12647;
12708 -> 12694;
12708 -> 12707;
12708 -> 12647;
12709 -> 12647;
12710 -> 12694;
12710 -> 12709;
12711 -> 12709;
12712 -> 12710;
12712 -> 12694;
12712 -> 12711;
12712 -> 12709;
12713 -> 12647;
12714 -> 12647;
12715 -> 12472;
12715 -> 12694;
12716 -> 12715;
12716 -> 12694;
12717 -> 12694;
12718 -> 12694;
12719 -> 12694;
12720 -> 12694;
12721 -> 12694;
12722 -> 12716;
12722 -> 12694;
12723 -> 12694;
12724 -> 12694;
12725 -> 12694;
12725 -> 12724;
12726 -> 12724;
12727 -> 12725;
12727 -> 12694;
12727 -> 12726;
12727 -> 12724;
12728 -> 12694;
12729 -> 12694;
12730 -> 12470;
12731 -> 12470;
12732 -> 12472;
12732 -> 12731;
12733 -> 12732;
12733 -> 12694;
12733 -> 12731;
12734 -> 12733;
12734 -> 12470;
12735 -> 12470;
12736 -> 12470;
12737 -> 12734;
12737 -> 12736;
12738 -> 12736;
12739 -> 12737;
12739 -> 12738;
12740 -> 12738;
12741 -> 12739;
12741 -> 12734;
12741 -> 12740;
12741 -> 12738;
12742 -> 12736;
12743 -> 12737;
12743 -> 12734;
12743 -> 12736;
12744 -> 12471;
12744 -> 12470;
12745 -> 12474;
12745 -> 12734;
12745 -> 12744;
12746 -> 12745;
12746 -> 12734;
12746 -> 12744;
12747 -> 12745;
12747 -> 12734;
12747 -> 12744;
12748 -> 12473;
12748 -> 12744;
12748 -> 12734;
12749 -> 12744;
12750 -> 12748;
12750 -> 12749;
12751 -> 12730;
12751 -> 12744;
12752 -> 12473;
12752 -> 12744;
12752 -> 12750;
12753 -> 12744;
12754 -> 12752;
12754 -> 12753;
12755 -> 12745;
12755 -> 12734;
12755 -> 12744;
12756 -> 12755;
12756 -> 12752;
12756 -> 12744;
12757 -> 12744;
12758 -> 12730;
12758 -> 12751;
12758 -> 12757;
12758 -> 12744;
12759 -> 12481;
12759 -> 12744;
12760 -> 12744;
12761 -> 12759;
12761 -> 12760;
12762 -> 12745;
12762 -> 12734;
12762 -> 12760;
12763 -> 12760;
12764 -> 12762;
12764 -> 12752;
12764 -> 12763;
12764 -> 12760;
12765 -> 12761;
12765 -> 12762;
12765 -> 12760;
12766 -> 12744;
12767 -> 12474;
12767 -> 12752;
12767 -> 12765;
12767 -> 12744;
12768 -> 12767;
12768 -> 12752;
12768 -> 12744;
12769 -> 12767;
12769 -> 12752;
12769 -> 12744;
12770 -> 12473;
12770 -> 12744;
12770 -> 12752;
12770 -> 12765;
12771 -> 12770;
12771 -> 12753;
12772 -> 12767;
12772 -> 12752;
12772 -> 12744;
12773 -> 12473;
12773 -> 12772;
12773 -> 12770;
12774 -> 12772;
12775 -> 12773;
12775 -> 12774;
12776 -> 12767;
12776 -> 12773;
12776 -> 12763;
12776 -> 12760;
12777 -> 12773;
12777 -> 12744;
12778 -> 12773;
12778 -> 12744;
12779 -> 12773;
12779 -> 12753;
12780 -> 12773;
12781 -> 12773;
12781 -> 12763;
12781 -> 12760;
12782 -> 12730;
12782 -> 12751;
12782 -> 12470;
12783 -> 12470;
12784 -> 12694;
12784 -> 12783;
12784 -> 12470;
12785 -> 12694;
12785 -> 12773;
12785 -> 12784;
12786 -> 12481;
12786 -> 12785;
12787 -> 12785;
12788 -> 12786;
12788 -> 12787;
12789 -> 12787;
12790 -> 12785;
12791 -> 12788;
12792 -> 12464;
12793 -> 11184;
12793 -> 12773;
12793 -> 11183;
12794 -> 11184;
12794 -> 12773;
12794 -> 12793;
12795 -> 11185;
12795 -> 12773;
12795 -> 12794;
12796 -> 12010;
12796 -> 12794;
12797 -> 11986;
12797 -> 12794;
12798 -> 12794;
12799 -> 12796;
12799 -> 12798;
12800 -> 12797;
12800 -> 12798;
12801 -> 12797;
12801 -> 12798;
12802 -> 12799;
12802 -> 12798;
12803 -> 12801;
12803 -> 12773;
12803 -> 12788;
12803 -> 12802;
12804 -> 12803;
12804 -> 12773;
12804 -> 12802;
12805 -> 12800;
12805 -> 12802;
12805 -> 12773;
12805 -> 12788;
12806 -> 12802;
12807 -> 12805;
12807 -> 12806;
12807 -> 12802;
12808 -> 12800;
12808 -> 12802;
12808 -> 12805;
12808 -> 12807;
12809 -> 12803;
12809 -> 12773;
12809 -> 12807;
12810 -> 12808;
12810 -> 12809;
12810 -> 12807;
12811 -> 12810;
12811 -> 12802;
12812 -> 12794;
12813 -> 12009;
12813 -> 12794;
12814 -> 11906;
12814 -> 12794;
12815 -> 11986;
12815 -> 12794;
12816 -> 11186;
12816 -> 12810;
12816 -> 12794;
12817 -> 12347;
12817 -> 12794;
12818 -> 12240;
12818 -> 12794;
12819 -> 12817;
12819 -> 12794;
12820 -> 12461;
12820 -> 12794;
12821 -> 12794;
12822 -> 12240;
12822 -> 12821;
12823 -> 12821;
12824 -> 12822;
12824 -> 12823;
12825 -> 12824;
12825 -> 12816;
12825 -> 12823;
12826 -> 12825;
12826 -> 12821;
12827 -> 12821;
12828 -> 12794;
12829 -> 12826;
12829 -> 12828;
12830 -> 12828;
12831 -> 12829;
12831 -> 12830;
12832 -> 12830;
12833 -> 12831;
12833 -> 12826;
12833 -> 12832;
12833 -> 12830;
12834 -> 12828;
12835 -> 12829;
12835 -> 12826;
12835 -> 12828;
12836 -> 12794;
12837 -> 12240;
12837 -> 12836;
12838 -> 12836;
12839 -> 12837;
12839 -> 12838;
12840 -> 12839;
12840 -> 12826;
12840 -> 12838;
12841 -> 12836;
12842 -> 12794;
12843 -> 12840;
12843 -> 12842;
12844 -> 12842;
12845 -> 12843;
12845 -> 12844;
12846 -> 12844;
12847 -> 12845;
12847 -> 12840;
12847 -> 12846;
12847 -> 12844;
12848 -> 12842;
12849 -> 12843;
12849 -> 12840;
12849 -> 12842;
12850 -> 11185;
12850 -> 12813;
12850 -> 12814;
12850 -> 12815;
12850 -> 12816;
12850 -> 12819;
12850 -> 12820;
12850 -> 12835;
12850 -> 12849;
12850 -> 12840;
12850 -> 12826;
12850 -> 11906;
12850 -> 12810;
12850 -> 12461;
12850 -> 12009;
12850 -> 12794;
12851 -> 11184;
12851 -> 12850;
12851 -> 12794;
12852 -> 11185;
12852 -> 12794;
12853 -> 11185;
12853 -> 11184;
12853 -> 12794;
12854 -> 12240;
12854 -> 11184;
12854 -> 12794;
12855 -> 11183;
12856 -> 11186;
12856 -> 12850;
12856 -> 12853;
12856 -> 12854;
12856 -> 11183;
12857 -> 11187;
12857 -> 12856;
12857 -> 11183;
12858 -> 12855;
12858 -> 11179;
12859 -> 11181;
12859 -> 12857;
12859 -> 12858;
12859 -> 11179;
12860 -> 11181;
12860 -> 12857;
12860 -> 11179;
12861 -> 11180;
12861 -> 12860;
12861 -> 11179;
12862 -> 11177;
12863 -> 11176;
12863 -> 12860;
12863 -> 11177;
12864 -> 11176;
12864 -> 12860;
12864 -> 11175;
12865 -> 12864;
12865 -> 11173;
12866 -> 11174;
12866 -> 12860;
12866 -> 11173;
12867 -> 11174;
12867 -> 12866;
12867 -> 11173;
12868 -> 12867;
12868 -> 11171;
12869 -> 12868;
12869 -> 11168;
12870 -> 11168;
12871 -> 12869;
12871 -> 12870;
12872 -> 11169;
12872 -> 12871;
12872 -> 11166;
12872 -> 12866;
12872 -> 11168;
12873 -> 11168;
12874 -> 11170;
12874 -> 12873;
12875 -> 12874;
12875 -> 12872;
12875 -> 12873;
12876 -> 12874;
12876 -> 12872;
12876 -> 12873;
12877 -> 12876;
12877 -> 11168;
12878 -> 11168;
12879 -> 12878;
12879 -> 12877;
12879 -> 12872;
12879 -> 11168;
12880 -> 12878;
12880 -> 12879;
12881 -> 12877;
12881 -> 12880;
12881 -> 12878;
12882 -> 12880;
12883 -> 12881;
12883 -> 12882;
12884 -> 11165;
12885 -> 11164;
12885 -> 11165;
12886 -> 11165;
12887 -> 11165;
12888 -> 12885;
12888 -> 12887;
12889 -> 12886;
12889 -> 12887;
12890 -> 0;
12890 -> 12889;
12890 -> 12887;
12891 -> 12888;
12891 -> 12889;
12891 -> 12887;
12892 -> 12886;
12892 -> 11166;
12892 -> 12883;
12892 -> 11165;
12893 -> 12892;
12893 -> 12886;
12894 -> 12886;
12895 -> 12893;
12895 -> 12892;
12895 -> 12894;
12895 -> 12886;
12896 -> 12895;
12897 -> 12893;
12897 -> 12895;
12898 -> 12895;
12899 -> 12893;
12899 -> 12898;
12900 -> 12898;
12901 -> 12899;
12901 -> 12892;
12901 -> 12900;
12902 -> 12901;
12902 -> 12892;
12902 -> 12900;
12903 -> 12902;
12903 -> 12898;
12904 -> 12903;
12904 -> 12895;
12905 -> 12895;
12906 -> 12904;
12906 -> 12905;
12907 -> 12905;
12908 -> 12906;
12908 -> 12907;
12909 -> 12908;
12909 -> 12905;
12910 -> 12906;
12910 -> 12905;
12911 -> 12905;
12912 -> 12910;
12912 -> 12911;
12913 -> 12909;
12913 -> 12911;
12914 -> 12911;
12915 -> 12912;
12915 -> 12914;
12916 -> 12915;
12916 -> 12911;
12917 -> 12916;
12917 -> 12913;
12917 -> 12911;
12918 -> 12911;
12919 -> 12913;
12919 -> 12892;
12919 -> 12918;
12919 -> 12911;
12920 -> 12913;
12920 -> 12892;
12920 -> 12919;
12921 -> 12912;
12921 -> 12919;
12922 -> 12919;
12923 -> 12921;
12923 -> 12922;
12924 -> 12913;
12924 -> 12922;
12925 -> 12924;
12925 -> 12892;
12925 -> 12922;
12926 -> 12922;
12927 -> 12924;
12927 -> 12892;
12927 -> 12926;
12927 -> 12922;
12928 -> 12927;
12929 -> 12925;
12929 -> 12928;
12929 -> 12927;
12930 -> 12929;
12931 -> 12930;
12931 -> 12929;
12932 -> 12929;
12933 -> 12931;
12933 -> 12892;
12933 -> 12932;
12933 -> 12929;
12934 -> 12931;
12934 -> 12929;
12935 -> 12933;
12935 -> 12934;
12935 -> 12892;
12935 -> 12929;
12936 -> 12924;
12936 -> 12935;
12936 -> 12929;
12937 -> 12929;
12938 -> 12923;
12938 -> 12937;
12938 -> 12929;
12939 -> 12923;
12939 -> 12938;
12940 -> 12938;
12941 -> 12938;
12942 -> 12939;
12942 -> 12941;
12943 -> 12940;
12943 -> 12941;
12944 -> 12943;
12944 -> 12941;
12945 -> 12942;
12945 -> 12943;
12945 -> 12941;
12946 -> 12933;
12946 -> 12940;
12946 -> 12936;
12946 -> 12945;
12946 -> 12938;
12947 -> 12933;
12947 -> 12946;
12947 -> 12929;
12948 -> 12929;
12949 -> 12947;
12949 -> 12948;
12950 -> 12949;
12951 -> 12949;
12951 -> 12950;
12951 -> 12947;
12951 -> 12946;
12952 -> 12949;
12953 -> 12951;
12953 -> 12952;
12954 -> 12953;
12954 -> 12951;
12954 -> 12952;
12955 -> 12948;
12956 -> 12948;
12956 -> 12929;
12957 -> 12956;
12957 -> 12919;
12958 -> 12919;
12959 -> 12913;
12959 -> 12954;
12959 -> 12911;
12961 -> 12960;
12963 -> 12962;
12964 -> 12896;
12964 -> 12895;
12965 -> 12895;
12966 -> 12895;
12967 -> 12897;
12967 -> 12966;
12968 -> 12897;
12968 -> 12966;
12969 -> 12959;
12969 -> 12966;
12970 -> 12964;
12970 -> 12966;
12971 -> 12965;
12971 -> 12966;
12972 -> 12966;
12973 -> 12971;
12973 -> 12966;
12974 -> 12971;
12974 -> 12966;
12975 -> 12971;
12975 -> 12966;
12976 -> 12971;
12976 -> 12966;
12977 -> 12971;
12977 -> 12966;
12978 -> 12971;
12978 -> 12966;
12981 -> 12980;
12981 -> 12979;
12983 -> 12982;
12983 -> 12979;
12984 -> 12979;
12987 -> 12986;
12987 -> 12985;
12989 -> 12988;
12989 -> 12985;
12990 -> 12985;
12992 -> 0;
12992 -> 12991;
12994 -> 0;
12994 -> 12993;
12995 -> 12994;
12995 -> 12991;
12996 -> 12991;
12998 -> 0;
12998 -> 12997;
12999 -> 0;
12999 -> 12997;
13000 -> 12997;
13001 -> 12990;
13001 -> 12971;
13001 -> 12966;
13002 -> 12966;
13003 -> 12969;
13003 -> 13002;
13003 -> 12966;
13004 -> 12967;
13004 -> 12971;
13004 -> 12966;
13005 -> 12968;
13005 -> 12971;
13005 -> 12966;
13006 -> 12969;
13006 -> 12971;
13006 -> 12966;
13007 -> 12966;
13008 -> 12969;
13008 -> 13007;
13009 -> 13008;
13009 -> 12966;
13010 -> 13009;
13010 -> 12954;
13011 -> 12970;
13011 -> 13010;
13011 -> 12896;
13011 -> 12954;
13011 -> 13009;
13012 -> 12896;
13012 -> 13011;
13012 -> 12895;
13013 -> 12896;
13013 -> 13011;
13013 -> 12895;
13014 -> 12893;
13014 -> 13013;
13014 -> 12895;
13015 -> 12965;
13015 -> 12895;
13016 -> 12895;
13017 -> 13014;
13017 -> 13015;
13017 -> 13016;
13017 -> 12971;
13017 -> 13004;
13017 -> 13005;
13017 -> 13006;
13017 -> 12976;
13017 -> 12977;
13017 -> 12978;
13017 -> 13001;
13017 -> 13013;
13017 -> 12987;
13017 -> 12989;
13017 -> 12985;
13017 -> 12895;
13018 -> 12893;
13018 -> 13017;
13018 -> 12886;
13019 -> 12892;
13019 -> 12886;
13020 -> 13019;
13020 -> 12886;
13021 -> 13020;
13021 -> 13018;
13021 -> 12886;
13022 -> 12892;
13022 -> 12886;
13023 -> 13022;
13023 -> 13021;
13023 -> 12886;
13024 -> 11165;
13025 -> 12886;
13025 -> 13024;
13026 -> 12886;
13026 -> 13024;
13027 -> 13023;
13027 -> 13024;
13028 -> 12886;
13028 -> 13024;
13029 -> 13024;
13030 -> 13027;
13030 -> 13023;
13030 -> 13029;
13030 -> 13024;
13031 -> 13024;
13032 -> 13027;
13032 -> 13023;
13032 -> 13031;
13032 -> 13024;
13033 -> 13032;
13033 -> 13024;
13034 -> 13025;
13034 -> 13033;
13035 -> 13026;
13035 -> 13033;
13036 -> 13028;
13036 -> 13033;
13037 -> 13033;
13038 -> 13034;
13038 -> 13037;
13039 -> 13035;
13039 -> 13037;
13040 -> 13033;
13040 -> 13037;
13041 -> 13036;
13041 -> 13037;
13042 -> 13033;
13042 -> 13037;
13043 -> 13037;
13044 -> 13042;
13044 -> 13037;
13045 -> 13042;
13045 -> 13037;
13046 -> 13042;
13046 -> 13037;
13047 -> 13038;
13047 -> 13042;
13047 -> 13037;
13048 -> 13040;
13048 -> 13042;
13048 -> 13037;
13049 -> 13039;
13049 -> 13042;
13049 -> 13037;
13050 -> 13042;
13050 -> 13037;
13051 -> 0;
13051 -> 13037;
13052 -> 13050;
13052 -> 13042;
13052 -> 13037;
13053 -> 13041;
13053 -> 13042;
13053 -> 13037;
13054 -> 13040;
13054 -> 13037;
13055 -> 13054;
13056 -> 13054;
13056 -> 13055;
13057 -> 13056;
13057 -> 13055;
13058 -> 13057;
13058 -> 13054;
13059 -> 13054;
13060 -> 11166;
13060 -> 13023;
13060 -> 11165;
13061 -> 11164;
13061 -> 13060;
13061 -> 11165;
13062 -> 13033;
13062 -> 11165;
13063 -> 11165;
13064 -> 13061;
13064 -> 13062;
13064 -> 13063;
13064 -> 13042;
13064 -> 13049;
13064 -> 13053;
13064 -> 13052;
13064 -> 13047;
13064 -> 13048;
13064 -> 13060;
13064 -> 12890;
13064 -> 12891;
13064 -> 13023;
13064 -> 13050;
13064 -> 11165;
13065 -> 11164;
13065 -> 13064;
13065 -> 11163;
13066 -> 13065;
13066 -> 1;
13067 -> 1;
13068 -> 1;
13069 -> 13067;
13069 -> 13068;
13070 -> 13066;
13070 -> 13068;
13071 -> 13070;
13071 -> 13064;
13071 -> 13069;
13071 -> 13068;
13072 -> 13068;
13073 -> 13071;
13073 -> 13072;
13074 -> 13071;
13074 -> 13072;
13075 -> 13072;
13076 -> 13072;
13077 -> 13074;
13077 -> 13071;
13077 -> 13072;
13078 -> 13073;
13078 -> 13077;
13079 -> 13077;
13080 -> 13078;
13080 -> 13079;
13081 -> 13077;
13081 -> 13079;
13082 -> 13079;
13083 -> 13082;
13083 -> 13079;
13084 -> 13079;
13085 -> 13081;
13085 -> 13084;
13086 -> 13084;
13087 -> 13085;
13087 -> 13071;
13087 -> 13086;
13087 -> 13084;
13088 -> 13087;
13089 -> 13085;
13089 -> 13071;
13089 -> 13087;
13090 -> 13088;
13090 -> 13087;
13091 -> 13087;
13092 -> 13090;
13092 -> 13091;
13093 -> 13085;
13093 -> 13091;
13094 -> 13091;
13095 -> 13093;
13095 -> 13071;
13095 -> 13094;
13096 -> 13095;
13096 -> 13071;
13096 -> 13094;
13097 -> 13095;
13097 -> 13071;
13097 -> 13096;
13098 -> 13096;
13099 -> 13095;
13099 -> 13098;
13100 -> 13098;
13101 -> 13098;
13102 -> 13098;
13103 -> 13098;
13104 -> 13099;
13104 -> 13071;
13104 -> 13098;
13105 -> 13104;
13106 -> 13104;
13106 -> 13105;
13107 -> 13105;
13108 -> 13106;
13108 -> 13107;
13109 -> 13108;
13109 -> 13071;
13109 -> 13107;
13110 -> 13109;
13110 -> 13105;
13111 -> 13110;
13111 -> 13104;
13112 -> 13111;
13113 -> 13111;
13114 -> 13112;
13114 -> 13113;
13114 -> 13111;
13115 -> 13111;
13116 -> 13111;
13117 -> 13115;
13117 -> 13116;
13117 -> 13111;
13118 -> 13117;
13119 -> 13100;
13119 -> 13118;
13119 -> 13117;
13120 -> 13119;
13121 -> 13115;
13121 -> 13117;
13122 -> 13120;
13122 -> 13121;
13122 -> 13071;
13122 -> 13117;
13123 -> 13122;
13124 -> 13122;
13125 -> 13102;
13125 -> 13124;
13126 -> 13120;
13126 -> 13122;
13126 -> 13125;
13127 -> 13125;
13128 -> 13126;
13128 -> 13127;
13129 -> 13127;
13130 -> 13127;
13130 -> 13125;
13131 -> 13123;
13131 -> 13130;
13131 -> 13128;
13131 -> 13125;
13132 -> 13122;
13133 -> 13101;
13133 -> 13132;
13133 -> 13122;
13134 -> 13123;
13134 -> 13131;
13134 -> 13122;
13135 -> 13134;
13135 -> 13096;
13136 -> 13095;
13136 -> 13135;
13136 -> 13094;
13137 -> 13136;
13137 -> 13091;
13138 -> 13091;
13139 -> 13091;
13140 -> 13137;
13140 -> 13139;
13141 -> 13138;
13141 -> 13139;
13142 -> 13140;
13142 -> 13139;
13143 -> 0;
13143 -> 13139;
13144 -> 13142;
13144 -> 13141;
13144 -> 13139;
13145 -> 13091;
13146 -> 13093;
13146 -> 13135;
13146 -> 13145;
13147 -> 13146;
13147 -> 13135;
13147 -> 13145;
13148 -> 13147;
13148 -> 13091;
13149 -> 13148;
13150 -> 13092;
13150 -> 13148;
13151 -> 13148;
13152 -> 13149;
13152 -> 13151;
13153 -> 13150;
13153 -> 13151;
13154 -> 13093;
13154 -> 13151;
13155 -> 13151;
13156 -> 13152;
13156 -> 13155;
13157 -> 0;
13157 -> 13155;
13158 -> 13157;
13158 -> 13151;
13159 -> 13154;
13159 -> 13135;
13159 -> 13158;
13160 -> 13154;
13160 -> 13158;
13161 -> 13152;
13161 -> 13158;
13162 -> 13153;
13162 -> 13158;
13163 -> 13158;
13164 -> 13158;
13165 -> 13159;
13165 -> 13164;
13166 -> 13160;
13166 -> 13164;
13167 -> 13161;
13167 -> 13164;
13168 -> 13162;
13168 -> 13164;
13169 -> 13163;
13169 -> 13164;
13170 -> 13169;
13170 -> 13164;
13171 -> 13169;
13171 -> 13164;
13172 -> 13169;
13172 -> 13164;
13173 -> 13164;
13174 -> 13167;
13174 -> 13173;
13174 -> 13164;
13175 -> 13168;
13175 -> 13167;
13175 -> 13088;
13175 -> 13135;
13176 -> 13163;
13176 -> 13148;
13177 -> 13148;
13178 -> 13176;
13178 -> 13177;
13179 -> 13138;
13179 -> 13177;
13180 -> 13177;
13181 -> 13178;
13181 -> 13180;
13182 -> 13180;
13183 -> 13181;
13183 -> 13167;
13183 -> 13182;
13184 -> 13183;
13184 -> 13135;
13184 -> 13175;
13184 -> 13182;
13185 -> 13184;
13185 -> 13177;
13186 -> 13177;
13187 -> 13185;
13187 -> 13177;
13188 -> 13186;
13188 -> 13177;
13189 -> 13179;
13189 -> 13144;
13189 -> 13187;
13189 -> 13188;
13189 -> 13142;
13189 -> 0;
13189 -> 13177;
13190 -> 13178;
13190 -> 13185;
13190 -> 13179;
13190 -> 13189;
13191 -> 13091;
13192 -> 13138;
13192 -> 13191;
13193 -> 13192;
13193 -> 13191;
13194 -> 0;
13194 -> 13191;
13195 -> 13192;
13195 -> 13190;
13195 -> 13191;
13196 -> 13195;
13197 -> 13195;
13198 -> 13197;
13198 -> 13195;
13199 -> 13196;
13199 -> 13195;
13200 -> 13195;
13201 -> 13199;
13201 -> 13200;
13201 -> 13195;
13202 -> 13196;
13202 -> 13201;
13203 -> 13201;
13204 -> 13202;
13204 -> 13203;
13205 -> 0;
13205 -> 13203;
13206 -> 13205;
13206 -> 13201;
13207 -> 13206;
13207 -> 13201;
13208 -> 13202;
13208 -> 13207;
13209 -> 13195;
13210 -> 13208;
13210 -> 13195;
13211 -> 13193;
13211 -> 13209;
13211 -> 13210;
13211 -> 13195;
13212 -> 13193;
13212 -> 13191;
13213 -> 13212;
13213 -> 13091;
13214 -> 13093;
13214 -> 13091;
13215 -> 13213;
13215 -> 13091;
13216 -> 13092;
13216 -> 13091;
13217 -> 13091;
13218 -> 13214;
13218 -> 13217;
13219 -> 13215;
13219 -> 13217;
13220 -> 13216;
13220 -> 13217;
13221 -> 13217;
13222 -> 13217;
13223 -> 13217;
13224 -> 13218;
13224 -> 13223;
13225 -> 13223;
13226 -> 13224;
13226 -> 13175;
13226 -> 13225;
13227 -> 13226;
13227 -> 13175;
13227 -> 13225;
13228 -> 13227;
13228 -> 13217;
13229 -> 13217;
13230 -> 13228;
13230 -> 13229;
13231 -> 13217;
13232 -> 13219;
13232 -> 13193;
13232 -> 13217;
13233 -> 13232;
13233 -> 13193;
13233 -> 13211;
13233 -> 13217;
13234 -> 13221;
13234 -> 13233;
13235 -> 13233;
13236 -> 13219;
13236 -> 13233;
13236 -> 13193;
13236 -> 13211;
13236 -> 13189;
13236 -> 13208;
13237 -> 13236;
13238 -> 13236;
13239 -> 13237;
13239 -> 13238;
13239 -> 13236;
13240 -> 13239;
13240 -> 13236;
13241 -> 13240;
13241 -> 13221;
13241 -> 13234;
13241 -> 13236;
13242 -> 13221;
13242 -> 13234;
13242 -> 13240;
13242 -> 13236;
13243 -> 13236;
13244 -> 13242;
13244 -> 13243;
13244 -> 13236;
13245 -> 13222;
13245 -> 13243;
13245 -> 13236;
13246 -> 13244;
13246 -> 13245;
13246 -> 13236;
13247 -> 13236;
13248 -> 13242;
13248 -> 13247;
13248 -> 13236;
13249 -> 13236;
13249 -> 13240;
13249 -> 13221;
13250 -> 13236;
13251 -> 13237;
13251 -> 13250;
13251 -> 13236;
13252 -> 13091;
13253 -> 13213;
13253 -> 13091;
13254 -> 13253;
13254 -> 13087;
13255 -> 13087;
13256 -> 13089;
13256 -> 13254;
13256 -> 13255;
13256 -> 13236;
13256 -> 13175;
13256 -> 13087;
13257 -> 13256;
13258 -> 13085;
13258 -> 13257;
13259 -> 13257;
13260 -> 13258;
13260 -> 13259;
13261 -> 13259;
13261 -> 13257;
13262 -> 13257;
13263 -> 13258;
13263 -> 13262;
13264 -> 13263;
13264 -> 13256;
13264 -> 13262;
13265 -> 13264;
13265 -> 13257;
13266 -> 13257;
13267 -> 13265;
13267 -> 13266;
13267 -> 13257;
13268 -> 13267;
13268 -> 13257;
13269 -> 13268;
13270 -> 13269;
13270 -> 13256;
13271 -> 13256;
13272 -> 13270;
13272 -> 13271;
13273 -> 13272;
13273 -> 13256;
13273 -> 13271;
13274 -> 13271;
13275 -> 13272;
13275 -> 13256;
13275 -> 13274;
13275 -> 13271;
13276 -> 13275;
13277 -> 13272;
13277 -> 13256;
13277 -> 13275;
13278 -> 13276;
13278 -> 13275;
13279 -> 13275;
13280 -> 13272;
13280 -> 13278;
13280 -> 13271;
13281 -> 13088;
13281 -> 13256;
13282 -> 13256;
13283 -> 13085;
13283 -> 13282;
13284 -> 13282;
13285 -> 13283;
13285 -> 13284;
13286 -> 13284;
13287 -> 13285;
13287 -> 13280;
13287 -> 13286;
13288 -> 13287;
13288 -> 13280;
13288 -> 13286;
13289 -> 13288;
13289 -> 13282;
13290 -> 13282;
13291 -> 13289;
13291 -> 13290;
13292 -> 13290;
13293 -> 13291;
13293 -> 13292;
13294 -> 13293;
13294 -> 13290;
13295 -> 13291;
13295 -> 13290;
13296 -> 13294;
13296 -> 13282;
13297 -> 13256;
13298 -> 13256;
13299 -> 13085;
13299 -> 13298;
13300 -> 13298;
13301 -> 13299;
13301 -> 13300;
13302 -> 13300;
13302 -> 13298;
13303 -> 13298;
13304 -> 13299;
13304 -> 13303;
13305 -> 13304;
13305 -> 13280;
13305 -> 13303;
13306 -> 13298;
13307 -> 13305;
13307 -> 13256;
13308 -> 13085;
13308 -> 13256;
13309 -> 13256;
13310 -> 13308;
13310 -> 13309;
13311 -> 13307;
13311 -> 13309;
13312 -> 13311;
13312 -> 13280;
13312 -> 13309;
13313 -> 13256;
13314 -> 0;
13314 -> 13256;
13315 -> 13256;
13316 -> 13314;
13316 -> 13315;
13317 -> 13085;
13317 -> 13280;
13317 -> 13315;
13318 -> 13317;
13318 -> 13280;
13318 -> 13315;
13319 -> 13316;
13319 -> 13315;
13320 -> 13318;
13320 -> 13319;
13320 -> 13315;
13321 -> 13320;
13321 -> 13256;
13322 -> 13088;
13322 -> 13280;
13322 -> 13320;
13322 -> 13087;
13323 -> 13085;
13323 -> 13322;
13323 -> 13084;
13324 -> 13323;
13324 -> 13079;
13325 -> 13080;
13325 -> 13079;
13326 -> 13082;
13326 -> 13079;
13327 -> 13324;
13327 -> 13325;
13327 -> 13326;
13327 -> 13322;
13327 -> 13083;
13327 -> 13079;
13328 -> 13327;
13328 -> 13079;
13329 -> 13328;
13330 -> 13328;
13330 -> 13329;
13331 -> 13329;
13331 -> 13328;
13332 -> 13331;
13333 -> 13332;
13333 -> 13075;
13333 -> 13331;
13334 -> 13328;
13334 -> 13331;
13335 -> 13333;
13335 -> 13334;
13335 -> 13332;
13335 -> 13328;
13335 -> 13331;
13336 -> 13335;
13337 -> 13335;
13338 -> 13335;
13339 -> 13337;
13339 -> 13338;
13340 -> 13338;
13341 -> 13339;
13341 -> 13335;
13341 -> 13340;
13341 -> 13338;
13342 -> 13341;
13343 -> 13341;
13344 -> 13339;
13344 -> 13335;
13344 -> 13343;
13345 -> 13344;
13345 -> 13335;
13345 -> 13343;
13346 -> 13345;
13346 -> 13341;
13347 -> 0;
13347 -> 13341;
13348 -> 13346;
13348 -> 13341;
13349 -> 13341;
13350 -> 13348;
13350 -> 13349;
13351 -> 13339;
13351 -> 13349;
13352 -> 13349;
13353 -> 13350;
13353 -> 13352;
13353 -> 13349;
13354 -> 13349;
13355 -> 13349;
13356 -> 13349;
13357 -> 13351;
13357 -> 13356;
13358 -> 13356;
13359 -> 13358;
13359 -> 13349;
13360 -> 13359;
13360 -> 13349;
13361 -> 13359;
13361 -> 13349;
13362 -> 13361;
13363 -> 13350;
13363 -> 13349;
13364 -> 0;
13364 -> 13349;
13365 -> 13354;
13365 -> 13349;
13366 -> 13355;
13366 -> 13349;
13367 -> 13360;
13367 -> 13362;
13367 -> 13363;
13367 -> 13364;
13367 -> 13365;
13367 -> 13366;
13367 -> 13346;
13367 -> 13349;
13368 -> 13367;
13368 -> 13349;
13369 -> 13349;
13370 -> 13368;
13370 -> 13369;
13371 -> 13351;
13371 -> 13369;
13372 -> 13369;
13373 -> 13371;
13373 -> 13367;
13373 -> 13372;
13373 -> 13369;
13374 -> 0;
13374 -> 13373;
13375 -> 13370;
13375 -> 13373;
13376 -> 13375;
13376 -> 13367;
13377 -> 13371;
13377 -> 13375;
13378 -> 13375;
13379 -> 13375;
13380 -> 13376;
13380 -> 13379;
13381 -> 13377;
13381 -> 13379;
13382 -> 13376;
13382 -> 13379;
13383 -> 13378;
13383 -> 13379;
13384 -> 13379;
13385 -> 13383;
13385 -> 13379;
13386 -> 13383;
13386 -> 13379;
13387 -> 13383;
13387 -> 13379;
13388 -> 13379;
13389 -> 13380;
13389 -> 13388;
13389 -> 13379;
13390 -> 13379;
13391 -> 13381;
13391 -> 13390;
13391 -> 13379;
13392 -> 13379;
13393 -> 13382;
13393 -> 13392;
13393 -> 13379;
13394 -> 13381;
13394 -> 13383;
13394 -> 13379;
13395 -> 13380;
13395 -> 13383;
13395 -> 13379;
13396 -> 13382;
13396 -> 13383;
13396 -> 13379;
13397 -> 13375;
13398 -> 13378;
13398 -> 13397;
13399 -> 13398;
13399 -> 13395;
13399 -> 13397;
13400 -> 13399;
13400 -> 13375;
13401 -> 13378;
13401 -> 13375;
13402 -> 13374;
13402 -> 13400;
13402 -> 13401;
13402 -> 13375;
13403 -> 13371;
13403 -> 13367;
13403 -> 13373;
13404 -> 13374;
13404 -> 13373;
13405 -> 13373;
13406 -> 13403;
13406 -> 13404;
13406 -> 13405;
13406 -> 13374;
13406 -> 13367;
13406 -> 13402;
13406 -> 13383;
13406 -> 13394;
13406 -> 13395;
13406 -> 13396;
13406 -> 13373;
13407 -> 13349;
13408 -> 13367;
13408 -> 13349;
13409 -> 13349;
13410 -> 13408;
13410 -> 13409;
13411 -> 13351;
13411 -> 13409;
13412 -> 13409;
13413 -> 13411;
13413 -> 13406;
13413 -> 13412;
13413 -> 13409;
13414 -> 13413;
13415 -> 13411;
13415 -> 13414;
13416 -> 13415;
13416 -> 13406;
13416 -> 13414;
13417 -> 13416;
13417 -> 13413;
13418 -> 13413;
13419 -> 13413;
13420 -> 13417;
13420 -> 13419;
13421 -> 13420;
13421 -> 13413;
13422 -> 13413;
13423 -> 13410;
13423 -> 13413;
13424 -> 13423;
13424 -> 13421;
13424 -> 13413;
13425 -> 13424;
13426 -> 13421;
13426 -> 13425;
13427 -> 13417;
13427 -> 13426;
13428 -> 13411;
13428 -> 13426;
13429 -> 13425;
13429 -> 13426;
13430 -> 0;
13431 -> 13430;
13432 -> 13431;
13434 -> 13433;
13435 -> 13434;
13435 -> 13433;
13436 -> 0;
13436 -> 13434;
13436 -> 13433;
13437 -> 0;
13437 -> 13434;
13437 -> 13433;
13438 -> 13434;
13438 -> 13433;
13439 -> 13434;
13439 -> 13433;
13440 -> 13434;
13440 -> 13433;
13441 -> 13434;
13441 -> 13433;
13443 -> 13442;
13444 -> 13442;
13445 -> 13444;
13446 -> 13444;
13448 -> 13447;
13450 -> 13449;
13452 -> 13451;
13454 -> 13453;
13456 -> 13454;
13456 -> 13455;
13457 -> 13456;
13459 -> 13458;
13461 -> 13460;
13463 -> 13462;
13465 -> 13464;
13475 -> 13467;
13475 -> 13466;
13476 -> 13468;
13476 -> 13466;
13477 -> 13469;
13477 -> 13466;
13478 -> 13470;
13478 -> 13466;
13479 -> 13471;
13479 -> 13466;
13480 -> 13472;
13480 -> 13466;
13481 -> 13473;
13481 -> 13466;
13482 -> 13474;
13482 -> 13466;
13483 -> 13466;
13484 -> 13446;
13484 -> 13444;
13485 -> 13484;
13485 -> 13445;
13486 -> 13445;
13488 -> 13487;
13490 -> 0;
13492 -> 13490;
13492 -> 13491;
13493 -> 13491;
13494 -> 13493;
13494 -> 13491;
13495 -> 13492;
13495 -> 13493;
13495 -> 13491;
13496 -> 13491;
13497 -> 0;
13499 -> 13497;
13499 -> 13498;
13500 -> 13498;
13501 -> 13500;
13501 -> 13498;
13502 -> 13499;
13502 -> 13500;
13502 -> 13498;
13503 -> 13498;
13504 -> 0;
13506 -> 13504;
13506 -> 13505;
13507 -> 13505;
13508 -> 13507;
13508 -> 13505;
13509 -> 13506;
13509 -> 13507;
13509 -> 13505;
13510 -> 13505;
13511 -> 0;
13513 -> 13511;
13513 -> 13512;
13514 -> 13512;
13515 -> 13514;
13515 -> 13512;
13516 -> 13513;
13516 -> 13514;
13516 -> 13512;
13517 -> 13512;
13518 -> 0;
13520 -> 13518;
13520 -> 13519;
13521 -> 13519;
13522 -> 13521;
13522 -> 13519;
13523 -> 13520;
13523 -> 13521;
13523 -> 13519;
13524 -> 13519;
13525 -> 0;
13527 -> 13525;
13527 -> 13526;
13528 -> 13526;
13529 -> 13528;
13529 -> 13526;
13530 -> 13527;
13530 -> 13528;
13530 -> 13526;
13531 -> 13526;
13532 -> 0;
13534 -> 13532;
13534 -> 13533;
13535 -> 13533;
13536 -> 13535;
13536 -> 13533;
13537 -> 13534;
13537 -> 13535;
13537 -> 13533;
13538 -> 13533;
13539 -> 0;
13541 -> 13539;
13541 -> 13540;
13542 -> 13540;
13543 -> 13542;
13543 -> 13540;
13544 -> 13541;
13544 -> 13542;
13544 -> 13540;
13545 -> 13540;
13546 -> 13545;
13548 -> 13489;
13548 -> 13546;
13548 -> 13547;
13548 -> 13542;
13548 -> 13543;
13548 -> 13544;
13549 -> 13548;
13551 -> 13550;
13552 -> 13551;
13552 -> 13550;
13553 -> 13551;
13553 -> 13550;
13554 -> 13551;
13554 -> 13550;
13555 -> 13550;
13557 -> 13556;
13558 -> 13486;
13559 -> 13558;
13560 -> 13559;
13561 -> 13560;
13561 -> 13559;
13562 -> 13558;
13562 -> 13486;
13563 -> 13558;
13563 -> 13486;
13564 -> 13486;
13564 -> 13445;
13565 -> 13486;
13565 -> 13445;
13566 -> 13486;
13566 -> 13445;
13567 -> 13485;
13567 -> 13486;
13567 -> 13445;
13568 -> 13444;
13568 -> 13442;
13569 -> 13443;
13569 -> 13444;
13569 -> 13442;
13570 -> 13442;
13571 -> 13570;
13571 -> 13434;
13571 -> 13433;
13572 -> 0;
13572 -> 13434;
13572 -> 13433;
13573 -> 13433;
13574 -> 13424;
13574 -> 13421;
13574 -> 13426;
13575 -> 13426;
13576 -> 13427;
13576 -> 13575;
13577 -> 13428;
13577 -> 13575;
13578 -> 13429;
13578 -> 13575;
13579 -> 13574;
13579 -> 13575;
13580 -> 13575;
13581 -> 13580;
13581 -> 13575;
13582 -> 13575;
13583 -> 13575;
13584 -> 13576;
13584 -> 13575;
13585 -> 13578;
13585 -> 13575;
13586 -> 13580;
13586 -> 13575;
13587 -> 13582;
13587 -> 13575;
13588 -> 13583;
13588 -> 13575;
13589 -> 13575;
13590 -> 13584;
13590 -> 13589;
13591 -> 13585;
13591 -> 13589;
13592 -> 13586;
13592 -> 13589;
13593 -> 13587;
13593 -> 13589;
13594 -> 13588;
13594 -> 13589;
13595 -> 13589;
13596 -> 13590;
13596 -> 13595;
13597 -> 13596;
13597 -> 13589;
13598 -> 13591;
13598 -> 13589;
13599 -> 13597;
13599 -> 13598;
13599 -> 13421;
13599 -> 13589;
13600 -> 13599;
13600 -> 13589;
13601 -> 13589;
13602 -> 13575;
13603 -> 13575;
13604 -> 13575;
13605 -> 13575;
13606 -> 13600;
13606 -> 13605;
13606 -> 13575;
13607 -> 13576;
13607 -> 13606;
13608 -> 13577;
13608 -> 13606;
13609 -> 13578;
13609 -> 13606;
13610 -> 13579;
13610 -> 13606;
13611 -> 13603;
13611 -> 13606;
13612 -> 13606;
13613 -> 13606;
13614 -> 13607;
13614 -> 13613;
13615 -> 13608;
13615 -> 13613;
13616 -> 13609;
13616 -> 13613;
13617 -> 13610;
13617 -> 13613;
13618 -> 13611;
13618 -> 13613;
13619 -> 13612;
13619 -> 13613;
13620 -> 13614;
13620 -> 13613;
13621 -> 13615;
13621 -> 13613;
13622 -> 13616;
13622 -> 13613;
13623 -> 13617;
13623 -> 13613;
13624 -> 13613;
13625 -> 13618;
13625 -> 13613;
13626 -> 13613;
13627 -> 13620;
13627 -> 13626;
13628 -> 13621;
13628 -> 13626;
13629 -> 13622;
13629 -> 13626;
13630 -> 13623;
13630 -> 13626;
13631 -> 13624;
13631 -> 13626;
13632 -> 13625;
13632 -> 13626;
13633 -> 13619;
13633 -> 13626;
13634 -> 13626;
13635 -> 13633;
13635 -> 13634;
13636 -> 13634;
13637 -> 13634;
13638 -> 13635;
13638 -> 13637;
13639 -> 13637;
13640 -> 13638;
13640 -> 13637;
13641 -> 13638;
13641 -> 13637;
13642 -> 13635;
13642 -> 13634;
13643 -> 13635;
13643 -> 13634;
13644 -> 13635;
13644 -> 13634;
13645 -> 13636;
13645 -> 13635;
13645 -> 13634;
13646 -> 13633;
13646 -> 13626;
13647 -> 13633;
13647 -> 13626;
13648 -> 13633;
13648 -> 13626;
13649 -> 13633;
13649 -> 13626;
13650 -> 13633;
13650 -> 13626;
13651 -> 13633;
13651 -> 13626;
13652 -> 13633;
13652 -> 13626;
13653 -> 13633;
13653 -> 13626;
13654 -> 13633;
13654 -> 13626;
13655 -> 13570;
13655 -> 13633;
13655 -> 13626;
13656 -> 13626;
13657 -> 13656;
13657 -> 13633;
13657 -> 13626;
13658 -> 13570;
13658 -> 13633;
13658 -> 13626;
13659 -> 13626;
13660 -> 13659;
13660 -> 13633;
13660 -> 13626;
13661 -> 13633;
13661 -> 13626;
13664 -> 13662;
13664 -> 13663;
13665 -> 13663;
13666 -> 13664;
13666 -> 13663;
13667 -> 13663;
13668 -> 0;
13668 -> 13663;
13669 -> 0;
13669 -> 13663;
13670 -> 13666;
13670 -> 13665;
13671 -> 13667;
13671 -> 13665;
13672 -> 13668;
13672 -> 13665;
13673 -> 13669;
13673 -> 13665;
13674 -> 13665;
13675 -> 13670;
13675 -> 13665;
13676 -> 13671;
13676 -> 13665;
13677 -> 13672;
13677 -> 13665;
13678 -> 13675;
13678 -> 13674;
13679 -> 13676;
13679 -> 13674;
13680 -> 13677;
13680 -> 13674;
13681 -> 13674;
13682 -> 10513;
13682 -> 13674;
13683 -> 13678;
13683 -> 13674;
13684 -> 13679;
13684 -> 13674;
13685 -> 13681;
13685 -> 13682;
13685 -> 13683;
13685 -> 13684;
13685 -> 13599;
13685 -> 13667;
13685 -> 13674;
13686 -> 13685;
13686 -> 13681;
13687 -> 13685;
13687 -> 13681;
13689 -> 13688;
13691 -> 13690;
13692 -> 0;
13693 -> 13692;
13694 -> 13693;
13698 -> 0;
13700 -> 13698;
13700 -> 13699;
13701 -> 13700;
13701 -> 13699;
13702 -> 13701;
13702 -> 10513;
13702 -> 13685;
13702 -> 13699;
13703 -> 13699;
13704 -> 13702;
13704 -> 13703;
13705 -> 13703;
13706 -> 13702;
13706 -> 13705;
13706 -> 13699;
13707 -> 13697;
13707 -> 13706;
13708 -> 0;
13710 -> 13708;
13710 -> 13709;
13711 -> 13710;
13711 -> 13709;
13712 -> 13711;
13712 -> 10513;
13712 -> 13706;
13712 -> 13709;
13713 -> 13709;
13714 -> 13712;
13714 -> 13713;
13715 -> 13713;
13716 -> 13697;
13716 -> 13712;
13716 -> 13707;
13717 -> 0;
13719 -> 13717;
13719 -> 13718;
13720 -> 13719;
13720 -> 13718;
13721 -> 13720;
13721 -> 10513;
13721 -> 13712;
13721 -> 13718;
13722 -> 13718;
13723 -> 13721;
13723 -> 13722;
13724 -> 13722;
13725 -> 13697;
13725 -> 13721;
13725 -> 13716;
13726 -> 0;
13728 -> 13726;
13728 -> 13727;
13729 -> 13728;
13729 -> 13727;
13730 -> 13729;
13730 -> 10513;
13730 -> 13721;
13730 -> 13727;
13731 -> 13727;
13732 -> 13730;
13732 -> 13731;
13733 -> 13731;
13734 -> 13697;
13734 -> 13730;
13734 -> 13725;
13735 -> 0;
13737 -> 13735;
13737 -> 13736;
13738 -> 13737;
13738 -> 13736;
13739 -> 13738;
13739 -> 10513;
13739 -> 13730;
13739 -> 13736;
13740 -> 13736;
13741 -> 13739;
13741 -> 13740;
13742 -> 13740;
13743 -> 13697;
13743 -> 13739;
13743 -> 13734;
13744 -> 0;
13746 -> 13744;
13746 -> 13745;
13747 -> 13746;
13747 -> 13745;
13748 -> 13747;
13748 -> 10513;
13748 -> 13739;
13748 -> 13745;
13749 -> 13745;
13750 -> 13748;
13750 -> 13749;
13751 -> 13749;
13752 -> 13697;
13752 -> 13748;
13752 -> 13743;
13753 -> 0;
13755 -> 13753;
13755 -> 13754;
13756 -> 13755;
13756 -> 13754;
13757 -> 13756;
13757 -> 10513;
13757 -> 13748;
13757 -> 13754;
13758 -> 13754;
13759 -> 13757;
13759 -> 13758;
13760 -> 13758;
13761 -> 13697;
13761 -> 13757;
13761 -> 13752;
13762 -> 0;
13764 -> 13762;
13764 -> 13763;
13765 -> 13764;
13765 -> 13763;
13766 -> 13765;
13766 -> 10513;
13766 -> 13757;
13766 -> 13763;
13767 -> 13763;
13768 -> 13766;
13768 -> 13767;
13769 -> 13767;
13770 -> 13697;
13770 -> 13766;
13770 -> 13761;
13771 -> 0;
13773 -> 13771;
13773 -> 13772;
13774 -> 13773;
13774 -> 13772;
13775 -> 13774;
13775 -> 10513;
13775 -> 13766;
13775 -> 13772;
13776 -> 13772;
13777 -> 13775;
13777 -> 13776;
13778 -> 13776;
13779 -> 13697;
13779 -> 13775;
13779 -> 13770;
13780 -> 0;
13782 -> 13780;
13782 -> 13781;
13783 -> 13782;
13783 -> 13781;
13784 -> 13783;
13784 -> 10513;
13784 -> 13775;
13784 -> 13781;
13785 -> 13781;
13786 -> 13784;
13786 -> 13785;
13787 -> 13785;
13788 -> 13697;
13788 -> 13784;
13788 -> 13779;
13789 -> 0;
13791 -> 13789;
13791 -> 13790;
13792 -> 13791;
13792 -> 13790;
13793 -> 13792;
13793 -> 10513;
13793 -> 13784;
13793 -> 13790;
13794 -> 13790;
13795 -> 13793;
13795 -> 13794;
13796 -> 13794;
13797 -> 13697;
13797 -> 13793;
13797 -> 13788;
13798 -> 0;
13800 -> 13798;
13800 -> 13799;
13801 -> 13800;
13801 -> 13799;
13802 -> 13801;
13802 -> 10513;
13802 -> 13793;
13802 -> 13799;
13803 -> 13799;
13804 -> 13802;
13804 -> 13803;
13805 -> 13803;
13806 -> 13697;
13806 -> 13802;
13806 -> 13797;
13807 -> 0;
13809 -> 13807;
13809 -> 13808;
13810 -> 13809;
13810 -> 13808;
13811 -> 13810;
13811 -> 10513;
13811 -> 13802;
13811 -> 13808;
13812 -> 13808;
13813 -> 13811;
13813 -> 13812;
13814 -> 13812;
13815 -> 13697;
13815 -> 13811;
13815 -> 13806;
13816 -> 0;
13818 -> 13816;
13818 -> 13817;
13819 -> 13818;
13819 -> 13817;
13820 -> 13819;
13820 -> 10513;
13820 -> 13811;
13820 -> 13817;
13821 -> 13817;
13822 -> 13820;
13822 -> 13821;
13823 -> 13821;
13824 -> 13697;
13824 -> 13820;
13824 -> 13815;
13825 -> 0;
13827 -> 13825;
13827 -> 13826;
13828 -> 13827;
13828 -> 13826;
13829 -> 13828;
13829 -> 10513;
13829 -> 13820;
13829 -> 13826;
13830 -> 13826;
13831 -> 13829;
13831 -> 13830;
13832 -> 13830;
13833 -> 13697;
13833 -> 13829;
13833 -> 13824;
13834 -> 0;
13836 -> 13834;
13836 -> 13835;
13837 -> 13836;
13837 -> 13835;
13838 -> 13837;
13838 -> 10513;
13838 -> 13829;
13838 -> 13835;
13839 -> 13835;
13840 -> 13838;
13840 -> 13839;
13841 -> 13839;
13842 -> 13697;
13842 -> 13838;
13842 -> 13833;
13843 -> 0;
13845 -> 13843;
13845 -> 13844;
13846 -> 13845;
13846 -> 13844;
13847 -> 13846;
13847 -> 10513;
13847 -> 13838;
13847 -> 13844;
13848 -> 13844;
13849 -> 13847;
13849 -> 13848;
13850 -> 13848;
13851 -> 13697;
13851 -> 13847;
13851 -> 13842;
13852 -> 0;
13854 -> 13852;
13854 -> 13853;
13855 -> 13854;
13855 -> 13853;
13856 -> 13855;
13856 -> 10513;
13856 -> 13847;
13856 -> 13853;
13857 -> 13853;
13858 -> 13856;
13858 -> 13857;
13859 -> 13857;
13860 -> 13697;
13860 -> 13856;
13860 -> 13851;
13861 -> 0;
13863 -> 13861;
13863 -> 13862;
13864 -> 13863;
13864 -> 13862;
13865 -> 13864;
13865 -> 10513;
13865 -> 13856;
13865 -> 13862;
13866 -> 13862;
13867 -> 13865;
13867 -> 13866;
13868 -> 13866;
13869 -> 13697;
13869 -> 13865;
13869 -> 13860;
13870 -> 0;
13872 -> 13870;
13872 -> 13871;
13873 -> 13872;
13873 -> 13871;
13874 -> 13873;
13874 -> 10513;
13874 -> 13865;
13874 -> 13871;
13875 -> 13871;
13876 -> 13874;
13876 -> 13875;
13877 -> 13875;
13878 -> 13697;
13878 -> 13874;
13878 -> 13869;
13879 -> 0;
13881 -> 13879;
13881 -> 13880;
13882 -> 13881;
13882 -> 13880;
13883 -> 13882;
13883 -> 10513;
13883 -> 13874;
13883 -> 13880;
13884 -> 13880;
13885 -> 13883;
13885 -> 13884;
13886 -> 13884;
13887 -> 13697;
13887 -> 13883;
13887 -> 13878;
13888 -> 0;
13890 -> 13888;
13890 -> 13889;
13891 -> 13890;
13891 -> 13889;
13892 -> 13891;
13892 -> 10513;
13892 -> 13883;
13892 -> 13889;
13893 -> 13889;
13894 -> 13892;
13894 -> 13893;
13895 -> 13893;
13896 -> 13697;
13896 -> 13892;
13896 -> 13887;
13897 -> 0;
13899 -> 13897;
13899 -> 13898;
13900 -> 13899;
13900 -> 13898;
13901 -> 13900;
13901 -> 10513;
13901 -> 13892;
13901 -> 13898;
13902 -> 13898;
13903 -> 13901;
13903 -> 13902;
13904 -> 13902;
13905 -> 13697;
13905 -> 13901;
13905 -> 13896;
13906 -> 0;
13908 -> 13906;
13908 -> 13907;
13909 -> 13908;
13909 -> 13907;
13910 -> 13909;
13910 -> 10513;
13910 -> 13901;
13910 -> 13907;
13911 -> 13907;
13912 -> 13910;
13912 -> 13911;
13913 -> 13911;
13914 -> 13697;
13914 -> 13910;
13914 -> 13905;
13915 -> 0;
13917 -> 13915;
13917 -> 13916;
13918 -> 13917;
13918 -> 13916;
13919 -> 13918;
13919 -> 10513;
13919 -> 13910;
13919 -> 13916;
13920 -> 13916;
13921 -> 13919;
13921 -> 13920;
13922 -> 13920;
13923 -> 13697;
13923 -> 13919;
13923 -> 13914;
13924 -> 0;
13926 -> 13924;
13926 -> 13925;
13927 -> 13926;
13927 -> 13925;
13928 -> 13927;
13928 -> 10513;
13928 -> 13919;
13928 -> 13925;
13929 -> 13925;
13930 -> 13928;
13930 -> 13929;
13931 -> 13929;
13932 -> 13697;
13932 -> 13928;
13932 -> 13923;
13933 -> 0;
13935 -> 13933;
13935 -> 13934;
13936 -> 13935;
13936 -> 13934;
13937 -> 13936;
13937 -> 10513;
13937 -> 13928;
13937 -> 13934;
13938 -> 13934;
13939 -> 13937;
13939 -> 13938;
13940 -> 13938;
13941 -> 13697;
13941 -> 13937;
13941 -> 13932;
13942 -> 0;
13944 -> 13942;
13944 -> 13943;
13945 -> 13944;
13945 -> 13943;
13946 -> 13945;
13946 -> 10513;
13946 -> 13937;
13946 -> 13943;
13947 -> 13943;
13948 -> 13946;
13948 -> 13947;
13949 -> 13947;
13950 -> 13697;
13950 -> 13946;
13950 -> 13941;
13951 -> 0;
13953 -> 13951;
13953 -> 13952;
13954 -> 13953;
13954 -> 13952;
13955 -> 13954;
13955 -> 10513;
13955 -> 13946;
13955 -> 13952;
13956 -> 13952;
13957 -> 13955;
13957 -> 13956;
13958 -> 13956;
13959 -> 13697;
13959 -> 13955;
13959 -> 13950;
13960 -> 0;
13962 -> 13960;
13962 -> 13961;
13963 -> 13962;
13963 -> 13961;
13964 -> 13963;
13964 -> 10513;
13964 -> 13955;
13964 -> 13961;
13965 -> 13961;
13966 -> 13964;
13966 -> 13965;
13967 -> 13965;
13968 -> 13697;
13968 -> 13964;
13968 -> 13959;
13969 -> 0;
13971 -> 13969;
13971 -> 13970;
13972 -> 13971;
13972 -> 13970;
13973 -> 13972;
13973 -> 10513;
13973 -> 13964;
13973 -> 13970;
13974 -> 13970;
13975 -> 13973;
13975 -> 13974;
13976 -> 13974;
13977 -> 13697;
13977 -> 13973;
13977 -> 13968;
13978 -> 0;
13980 -> 13978;
13980 -> 13979;
13981 -> 13980;
13981 -> 13979;
13982 -> 13981;
13982 -> 10513;
13982 -> 13973;
13982 -> 13979;
13983 -> 13979;
13984 -> 13982;
13984 -> 13983;
13985 -> 13983;
13986 -> 13697;
13986 -> 13982;
13986 -> 13977;
13987 -> 0;
13989 -> 13987;
13989 -> 13988;
13990 -> 13989;
13990 -> 13988;
13991 -> 13990;
13991 -> 10513;
13991 -> 13982;
13991 -> 13988;
13992 -> 13988;
13993 -> 13991;
13993 -> 13992;
13994 -> 13992;
13995 -> 13697;
13995 -> 13991;
13995 -> 13986;
13996 -> 0;
13998 -> 13996;
13998 -> 13997;
13999 -> 13998;
13999 -> 13997;
14000 -> 13999;
14000 -> 10513;
14000 -> 13991;
14000 -> 13997;
14001 -> 13997;
14002 -> 14000;
14002 -> 14001;
14003 -> 14001;
14004 -> 13697;
14004 -> 14000;
14004 -> 13995;
14005 -> 0;
14007 -> 14005;
14007 -> 14006;
14008 -> 14007;
14008 -> 14006;
14009 -> 14008;
14009 -> 10513;
14009 -> 14000;
14009 -> 14006;
14010 -> 14006;
14011 -> 14009;
14011 -> 14010;
14012 -> 14010;
14013 -> 13697;
14013 -> 14009;
14013 -> 14004;
14014 -> 0;
14016 -> 14014;
14016 -> 14015;
14017 -> 14016;
14017 -> 14015;
14018 -> 14017;
14018 -> 10513;
14018 -> 14009;
14018 -> 14015;
14019 -> 14015;
14020 -> 14018;
14020 -> 14019;
14021 -> 14019;
14022 -> 13697;
14022 -> 14018;
14022 -> 14013;
14023 -> 0;
14025 -> 14023;
14025 -> 14024;
14026 -> 14025;
14026 -> 14024;
14027 -> 14026;
14027 -> 10513;
14027 -> 14018;
14027 -> 14024;
14028 -> 14024;
14029 -> 14027;
14029 -> 14028;
14030 -> 14028;
14031 -> 13697;
14031 -> 14027;
14031 -> 14022;
14032 -> 0;
14034 -> 14032;
14034 -> 14033;
14035 -> 14034;
14035 -> 14033;
14036 -> 14035;
14036 -> 10513;
14036 -> 14027;
14036 -> 14033;
14037 -> 14033;
14038 -> 14036;
14038 -> 14037;
14039 -> 14037;
14040 -> 13697;
14040 -> 14036;
14040 -> 14031;
14041 -> 0;
14043 -> 14041;
14043 -> 14042;
14044 -> 14043;
14044 -> 14042;
14045 -> 14044;
14045 -> 10513;
14045 -> 14036;
14045 -> 14042;
14046 -> 14042;
14047 -> 14045;
14047 -> 14046;
14048 -> 14046;
14049 -> 13697;
14049 -> 14045;
14049 -> 14040;
14050 -> 0;
14052 -> 14050;
14052 -> 14051;
14053 -> 14052;
14053 -> 14051;
14054 -> 14053;
14054 -> 10513;
14054 -> 14045;
14054 -> 14051;
14055 -> 14051;
14056 -> 14054;
14056 -> 14055;
14057 -> 14055;
14058 -> 13697;
14058 -> 14054;
14058 -> 14049;
14059 -> 0;
14061 -> 14059;
14061 -> 14060;
14062 -> 14061;
14062 -> 14060;
14063 -> 14062;
14063 -> 10513;
14063 -> 14054;
14063 -> 14060;
14064 -> 14060;
14065 -> 14063;
14065 -> 14064;
14066 -> 14064;
14067 -> 13697;
14067 -> 14063;
14067 -> 14058;
14068 -> 0;
14070 -> 14068;
14070 -> 14069;
14071 -> 14070;
14071 -> 14069;
14072 -> 14071;
14072 -> 10513;
14072 -> 14063;
14072 -> 14069;
14073 -> 14069;
14074 -> 14072;
14074 -> 14073;
14075 -> 14073;
14076 -> 13697;
14076 -> 14072;
14076 -> 14067;
14077 -> 0;
14079 -> 14077;
14079 -> 14078;
14080 -> 14079;
14080 -> 14078;
14081 -> 14080;
14081 -> 10513;
14081 -> 14072;
14081 -> 14078;
14082 -> 14078;
14083 -> 14081;
14083 -> 14082;
14084 -> 14082;
14085 -> 13697;
14085 -> 14081;
14085 -> 14076;
14086 -> 0;
14088 -> 14086;
14088 -> 14087;
14089 -> 14088;
14089 -> 14087;
14090 -> 14089;
14090 -> 10513;
14090 -> 14081;
14090 -> 14087;
14091 -> 14087;
14092 -> 14090;
14092 -> 14091;
14093 -> 14091;
14094 -> 13697;
14094 -> 14090;
14094 -> 14085;
14095 -> 0;
14097 -> 14095;
14097 -> 14096;
14098 -> 14097;
14098 -> 14096;
14099 -> 14098;
14099 -> 10513;
14099 -> 14090;
14099 -> 14096;
14100 -> 14096;
14101 -> 14099;
14101 -> 14100;
14102 -> 14100;
14103 -> 13697;
14103 -> 14099;
14103 -> 14094;
14104 -> 0;
14106 -> 14104;
14106 -> 14105;
14107 -> 14106;
14107 -> 14105;
14108 -> 14107;
14108 -> 10513;
14108 -> 14099;
14108 -> 14105;
14109 -> 14105;
14110 -> 14108;
14110 -> 14109;
14111 -> 14109;
14112 -> 13697;
14112 -> 14108;
14112 -> 14103;
14113 -> 0;
14115 -> 14113;
14115 -> 14114;
14116 -> 14115;
14116 -> 14114;
14117 -> 14116;
14117 -> 10513;
14117 -> 14108;
14117 -> 14114;
14118 -> 14114;
14119 -> 14117;
14119 -> 14118;
14120 -> 14118;
14121 -> 13697;
14121 -> 14117;
14121 -> 14112;
14122 -> 0;
14124 -> 14122;
14124 -> 14123;
14125 -> 14124;
14125 -> 14123;
14126 -> 14125;
14126 -> 10513;
14126 -> 14117;
14126 -> 14123;
14127 -> 14123;
14128 -> 14126;
14128 -> 14127;
14129 -> 14127;
14130 -> 13697;
14130 -> 14126;
14130 -> 14121;
14131 -> 0;
14133 -> 14131;
14133 -> 14132;
14134 -> 14133;
14134 -> 14132;
14135 -> 14134;
14135 -> 10513;
14135 -> 14126;
14135 -> 14132;
14136 -> 14132;
14137 -> 14135;
14137 -> 14136;
14138 -> 14136;
14139 -> 13697;
14139 -> 14135;
14139 -> 14130;
14140 -> 0;
14142 -> 14140;
14142 -> 14141;
14143 -> 14142;
14143 -> 14141;
14144 -> 14143;
14144 -> 10513;
14144 -> 14135;
14144 -> 14141;
14145 -> 14141;
14146 -> 14144;
14146 -> 14145;
14147 -> 14145;
14148 -> 13697;
14148 -> 14144;
14148 -> 14139;
14149 -> 0;
14151 -> 14149;
14151 -> 14150;
14152 -> 14151;
14152 -> 14150;
14153 -> 14152;
14153 -> 10513;
14153 -> 14144;
14153 -> 14150;
14154 -> 14150;
14155 -> 14153;
14155 -> 14154;
14156 -> 14154;
14157 -> 13697;
14157 -> 14153;
14157 -> 14148;
14158 -> 0;
14160 -> 14158;
14160 -> 14159;
14161 -> 14160;
14161 -> 14159;
14162 -> 14161;
14162 -> 10513;
14162 -> 14153;
14162 -> 14159;
14163 -> 14159;
14164 -> 14162;
14164 -> 14163;
14165 -> 14163;
14166 -> 13697;
14166 -> 14162;
14166 -> 14157;
14167 -> 0;
14169 -> 14167;
14169 -> 14168;
14170 -> 14169;
14170 -> 14168;
14171 -> 14170;
14171 -> 10513;
14171 -> 14162;
14171 -> 14168;
14172 -> 14168;
14173 -> 14171;
14173 -> 14172;
14174 -> 14172;
14175 -> 13697;
14175 -> 14171;
14175 -> 14166;
14176 -> 0;
14178 -> 14176;
14178 -> 14177;
14179 -> 14178;
14179 -> 14177;
14180 -> 14179;
14180 -> 10513;
14180 -> 14171;
14180 -> 14177;
14181 -> 14177;
14182 -> 14180;
14182 -> 14181;
14183 -> 14181;
14184 -> 13697;
14184 -> 14180;
14184 -> 14175;
14185 -> 13697;
14185 -> 14184;
14186 -> 13686;
14186 -> 13681;
14187 -> 13681;
14188 -> 14186;
14188 -> 14187;
14189 -> 14188;
14189 -> 0;
14189 -> 14187;
14190 -> 14188;
14190 -> 0;
14190 -> 14189;
14191 -> 14188;
14191 -> 14190;
14192 -> 14190;
14193 -> 14191;
14193 -> 14192;
14194 -> 14193;
14194 -> 14192;
14195 -> 14194;
14196 -> 14188;
14196 -> 14195;
14197 -> 14195;
14198 -> 14196;
14198 -> 14197;
14199 -> 14198;
14199 -> 14197;
14200 -> 14199;
14201 -> 14188;
14201 -> 14200;
14202 -> 14200;
14203 -> 14201;
14203 -> 14202;
14204 -> 14203;
14204 -> 14202;
14205 -> 14204;
14206 -> 0;
14206 -> 14205;
14207 -> 13685;
14207 -> 14206;
14207 -> 14180;
14207 -> 13674;
14208 -> 13680;
14208 -> 13681;
14208 -> 13674;
14209 -> 13674;
14209 -> 13665;
14210 -> 13670;
14210 -> 0;
14210 -> 13665;
14211 -> 13673;
14211 -> 0;
14211 -> 13665;
14212 -> 14211;
14213 -> 14212;
14213 -> 13674;
14213 -> 13665;
14214 -> 13663;
14215 -> 0;
14217 -> 14215;
14217 -> 14216;
14218 -> 14216;
14219 -> 14217;
14219 -> 14216;
14220 -> 14216;
14221 -> 0;
14221 -> 14216;
14222 -> 0;
14222 -> 14216;
14223 -> 14219;
14223 -> 14218;
14224 -> 14220;
14224 -> 14218;
14225 -> 14221;
14225 -> 14218;
14226 -> 14222;
14226 -> 14218;
14227 -> 14218;
14228 -> 14223;
14228 -> 14218;
14229 -> 14224;
14229 -> 14218;
14230 -> 14225;
14230 -> 14218;
14231 -> 14228;
14231 -> 14227;
14232 -> 14229;
14232 -> 14227;
14233 -> 14230;
14233 -> 14227;
14234 -> 14227;
14235 -> 10513;
14235 -> 14227;
14236 -> 14231;
14236 -> 14227;
14237 -> 14232;
14237 -> 14227;
14238 -> 14234;
14238 -> 14235;
14238 -> 14236;
14238 -> 14237;
14238 -> 14207;
14238 -> 14208;
14238 -> 14209;
14238 -> 14213;
14238 -> 14220;
14238 -> 0;
14238 -> 14212;
14238 -> 14227;
14239 -> 14238;
14239 -> 14234;
14240 -> 14234;
14241 -> 0;
14241 -> 14238;
14242 -> 14233;
14242 -> 14234;
14242 -> 14227;
14243 -> 14227;
14243 -> 14218;
14244 -> 14223;
14244 -> 0;
14244 -> 14218;
14245 -> 14226;
14245 -> 0;
14245 -> 14218;
14246 -> 14245;
14247 -> 14246;
14247 -> 14227;
14247 -> 14218;
14248 -> 14216;
14249 -> 14214;
14249 -> 13633;
14249 -> 13626;
14250 -> 13633;
14250 -> 13626;
14251 -> 13633;
14251 -> 13626;
14252 -> 13629;
14252 -> 13421;
14252 -> 13626;
14253 -> 13626;
14254 -> 13628;
14254 -> 14253;
14254 -> 13626;
14255 -> 13626;
14256 -> 13631;
14256 -> 14255;
14256 -> 13626;
14257 -> 13626;
14258 -> 13626;
14259 -> 13626;
14260 -> 13627;
14260 -> 14259;
14261 -> 14260;
14261 -> 14241;
14261 -> 14259;
14262 -> 14261;
14262 -> 13626;
14263 -> 13629;
14263 -> 13626;
14264 -> 14262;
14264 -> 14263;
14264 -> 14241;
14264 -> 14242;
14264 -> 14243;
14264 -> 14247;
14264 -> 13421;
14264 -> 0;
14264 -> 14246;
14264 -> 13626;
14265 -> 13629;
14265 -> 13633;
14265 -> 13626;
14266 -> 13628;
14266 -> 13633;
14266 -> 13626;
14267 -> 13626;
14268 -> 13627;
14268 -> 14267;
14269 -> 14268;
14269 -> 14264;
14269 -> 14267;
14270 -> 14269;
14270 -> 13626;
14271 -> 13629;
14271 -> 13626;
14272 -> 14270;
14272 -> 13633;
14272 -> 13626;
14273 -> 13626;
14274 -> 13631;
14274 -> 14273;
14274 -> 13626;
14275 -> 14264;
14275 -> 13633;
14275 -> 14274;
14276 -> 14274;
14277 -> 13626;
14278 -> 13630;
14278 -> 14277;
14278 -> 13626;
14279 -> 13626;
14280 -> 13627;
14280 -> 14279;
14281 -> 14280;
14281 -> 14270;
14281 -> 14279;
14282 -> 14281;
14282 -> 13626;
14283 -> 13626;
14284 -> 14282;
14284 -> 14283;
14285 -> 14283;
14286 -> 14284;
14286 -> 14285;
14287 -> 14286;
14287 -> 14283;
14288 -> 14284;
14288 -> 14283;
14289 -> 14284;
14289 -> 14270;
14289 -> 0;
14289 -> 14283;
14290 -> 14278;
14290 -> 14287;
14290 -> 13626;
14291 -> 13626;
14292 -> 13633;
14292 -> 14291;
14293 -> 0;
14293 -> 14291;
14294 -> 14292;
14294 -> 14272;
14294 -> 0;
14294 -> 14291;
14295 -> 0;
14295 -> 14294;
14296 -> 14295;
14296 -> 14291;
14297 -> 14296;
14297 -> 13626;
14298 -> 14290;
14298 -> 14297;
14298 -> 13626;
14299 -> 0;
14299 -> 13633;
14299 -> 14298;
14300 -> 14258;
14300 -> 13626;
14301 -> 13575;
14302 -> 13601;
14302 -> 14301;
14302 -> 13575;
14303 -> 13612;
14303 -> 13575;
14304 -> 13418;
14304 -> 14303;
14304 -> 13638;
14304 -> 13640;
14304 -> 13641;
14304 -> 13642;
14304 -> 13643;
14304 -> 13645;
14304 -> 14266;
14304 -> 14275;
14304 -> 14272;
14304 -> 14299;
14304 -> 13650;
14304 -> 13651;
14304 -> 13652;
14304 -> 13653;
14304 -> 13654;
14304 -> 13655;
14304 -> 13657;
14304 -> 13658;
14304 -> 13660;
14304 -> 13661;
14304 -> 14249;
14304 -> 14250;
14304 -> 14251;
14304 -> 14265;
14304 -> 13561;
14304 -> 13562;
14304 -> 13563;
14304 -> 13564;
14304 -> 13565;
14304 -> 13567;
14304 -> 13569;
14304 -> 13656;
14304 -> 13659;
14304 -> 14270;
14304 -> 13421;
14304 -> 13426;
14305 -> 14304;
14306 -> 14305;
14306 -> 14304;
14307 -> 14304;
14308 -> 14304;
14309 -> 14305;
14309 -> 14304;
14310 -> 14307;
14310 -> 14304;
14311 -> 14308;
14311 -> 14304;
14312 -> 14304;
14313 -> 14304;
14314 -> 14304;
14315 -> 14304;
14316 -> 14313;
14316 -> 14304;
14317 -> 14304;
14318 -> 14315;
14318 -> 14317;
14319 -> 14315;
14319 -> 14317;
14320 -> 14315;
14320 -> 14317;
14321 -> 14315;
14321 -> 14317;
14322 -> 14315;
14322 -> 14317;
14323 -> 14315;
14323 -> 14317;
14324 -> 14316;
14324 -> 14317;
14325 -> 14315;
14325 -> 14317;
14326 -> 14318;
14326 -> 14317;
14327 -> 14319;
14327 -> 14317;
14328 -> 14320;
14328 -> 14317;
14329 -> 14321;
14329 -> 14317;
14330 -> 14323;
14330 -> 14317;
14331 -> 14324;
14331 -> 14317;
14332 -> 14317;
14333 -> 14326;
14333 -> 14332;
14334 -> 14327;
14334 -> 14332;
14335 -> 14328;
14335 -> 14332;
14336 -> 14329;
14336 -> 14332;
14337 -> 14330;
14337 -> 14332;
14338 -> 14331;
14338 -> 14332;
14339 -> 14325;
14339 -> 14332;
14340 -> 14325;
14340 -> 14332;
14341 -> 14325;
14341 -> 14332;
14342 -> 14325;
14342 -> 14332;
14343 -> 14325;
14343 -> 14332;
14344 -> 14335;
14344 -> 14304;
14344 -> 14332;
14345 -> 14332;
14346 -> 14334;
14346 -> 14345;
14346 -> 14332;
14347 -> 14332;
14348 -> 14337;
14348 -> 14347;
14348 -> 14332;
14349 -> 14332;
14350 -> 14332;
14351 -> 14333;
14351 -> 14335;
14351 -> 14304;
14351 -> 14332;
14352 -> 14351;
14352 -> 14337;
14353 -> 14337;
14354 -> 14352;
14354 -> 14325;
14354 -> 14337;
14355 -> 14325;
14355 -> 14354;
14355 -> 14337;
14356 -> 14351;
14356 -> 14337;
14357 -> 14325;
14357 -> 14354;
14357 -> 14351;
14357 -> 14337;
14358 -> 14325;
14358 -> 14354;
14358 -> 14337;
14359 -> 14351;
14359 -> 14337;
14360 -> 14336;
14360 -> 14351;
14360 -> 14332;
14361 -> 0;
14361 -> 14332;
14362 -> 14350;
14362 -> 14332;
14363 -> 14325;
14363 -> 14317;
14364 -> 14325;
14364 -> 14317;
14365 -> 14317;
14366 -> 14322;
14366 -> 14304;
14366 -> 14365;
14366 -> 14317;
14367 -> 14323;
14367 -> 14325;
14367 -> 14317;
14368 -> 14322;
14368 -> 14325;
14368 -> 14317;
14369 -> 14358;
14369 -> 14325;
14369 -> 14317;
14370 -> 14304;
14371 -> 14312;
14371 -> 14370;
14371 -> 14304;
14372 -> 13418;
14372 -> 14315;
14372 -> 14351;
14372 -> 14325;
14372 -> 14334;
14372 -> 14354;
14372 -> 14360;
14372 -> 14335;
14372 -> 14367;
14372 -> 14369;
14372 -> 14368;
14372 -> 14332;
14372 -> 14304;
14373 -> 14372;
14374 -> 14373;
14374 -> 14372;
14375 -> 14372;
14376 -> 14372;
14377 -> 14373;
14377 -> 14372;
14378 -> 14375;
14378 -> 14372;
14379 -> 14376;
14379 -> 14372;
14380 -> 14372;
14381 -> 14372;
14382 -> 14372;
14383 -> 14381;
14383 -> 14372;
14384 -> 14383;
14384 -> 14372;
14385 -> 14384;
14385 -> 14381;
14386 -> 14381;
14387 -> 14381;
14388 -> 14381;
14389 -> 14381;
14390 -> 14381;
14391 -> 14381;
14391 -> 14372;
14392 -> 14381;
14393 -> 14381;
14394 -> 14381;
14395 -> 14381;
14396 -> 14381;
14397 -> 0;
14397 -> 14381;
14398 -> 14395;
14398 -> 14381;
14399 -> 14381;
14399 -> 14372;
14400 -> 14381;
14400 -> 14372;
14401 -> 14372;
14402 -> 14372;
14403 -> 14380;
14403 -> 14402;
14403 -> 14372;
14404 -> 14381;
14405 -> 14404;
14405 -> 14381;
14406 -> 14381;
14407 -> 14381;
14408 -> 14404;
14408 -> 14381;
14409 -> 14406;
14409 -> 14381;
14410 -> 14407;
14410 -> 14381;
14411 -> 14381;
14412 -> 14381;
14413 -> 14381;
14414 -> 14413;
14414 -> 14381;
14415 -> 14414;
14415 -> 14381;
14416 -> 14381;
14417 -> 14381;
14418 -> 14381;
14419 -> 14411;
14419 -> 14418;
14419 -> 14381;
14420 -> 14404;
14421 -> 14420;
14421 -> 14404;
14422 -> 14421;
14422 -> 14404;
14423 -> 14404;
14424 -> 14404;
14425 -> 14404;
14426 -> 14404;
14427 -> 14404;
14428 -> 14404;
14428 -> 14381;
14429 -> 14404;
14430 -> 14404;
14431 -> 14404;
14432 -> 14404;
14433 -> 14404;
14434 -> 0;
14434 -> 14404;
14435 -> 14432;
14435 -> 14404;
14436 -> 14404;
14437 -> 14404;
14438 -> 14404;
14439 -> 14404;
14440 -> 14437;
14440 -> 14404;
14441 -> 14438;
14441 -> 14404;
14442 -> 14404;
14443 -> 14404;
14444 -> 14404;
14445 -> 14404;
14446 -> 14442;
14446 -> 14445;
14446 -> 14404;
14447 -> 14437;
14447 -> 14404;
14448 -> 14437;
14449 -> 14448;
14449 -> 14437;
14450 -> 14449;
14450 -> 14437;
14451 -> 14437;
14452 -> 14437;
14453 -> 14437;
14454 -> 14437;
14455 -> 14437;
14456 -> 14437;
14456 -> 14404;
14457 -> 14437;
14458 -> 14437;
14459 -> 14437;
14460 -> 14437;
14461 -> 14437;
14462 -> 0;
14462 -> 14437;
14463 -> 14460;
14463 -> 14437;
14464 -> 13413;
14465 -> 0;
14465 -> 13413;
14466 -> 14464;
14466 -> 14465;
14466 -> 13418;
14466 -> 14437;
14466 -> 13413;
14467 -> 14466;
14467 -> 14464;
14468 -> 14467;
14468 -> 14466;
14468 -> 14464;
14469 -> 13418;
14469 -> 14468;
14469 -> 13413;
14470 -> 13413;
14471 -> 13422;
14471 -> 14470;
14471 -> 13413;
14472 -> 13411;
14472 -> 14469;
14472 -> 13413;
14473 -> 14468;
14473 -> 13413;
14474 -> 13413;
14475 -> 13413;
14476 -> 14472;
14476 -> 14475;
14476 -> 13413;
14477 -> 14468;
14477 -> 14476;
14478 -> 14476;
14479 -> 14477;
14479 -> 14478;
14480 -> 13417;
14480 -> 14478;
14481 -> 14478;
14482 -> 14480;
14482 -> 14472;
14482 -> 14481;
14482 -> 14478;
14483 -> 14478;
14484 -> 14480;
14484 -> 14472;
14484 -> 14483;
14485 -> 14484;
14485 -> 14478;
14486 -> 14479;
14486 -> 14472;
14486 -> 14478;
14487 -> 14486;
14488 -> 14487;
14489 -> 14487;
14490 -> 14487;
14490 -> 14489;
14491 -> 14490;
14491 -> 14472;
14491 -> 14489;
14492 -> 14491;
14492 -> 14487;
14493 -> 14487;
14494 -> 14480;
14494 -> 14472;
14494 -> 14492;
14494 -> 14493;
14494 -> 14487;
14495 -> 14494;
14495 -> 14487;
14496 -> 14487;
14497 -> 14487;
14497 -> 14496;
14498 -> 14497;
14498 -> 14494;
14498 -> 14496;
14499 -> 14498;
14499 -> 14487;
14500 -> 14485;
14500 -> 14499;
14500 -> 14487;
14501 -> 14494;
14502 -> 14494;
14503 -> 14494;
14504 -> 14494;
14504 -> 14503;
14505 -> 14504;
14505 -> 14494;
14505 -> 14503;
14506 -> 14505;
14506 -> 14494;
14507 -> 14485;
14507 -> 14506;
14507 -> 14494;
14508 -> 14476;
14509 -> 13349;
14510 -> 13341;
14511 -> 13335;
14512 -> 13335;
14513 -> 13335;
14514 -> 14513;
14514 -> 13335;
14515 -> 13336;
14515 -> 13335;
14516 -> 14512;
14516 -> 13335;
14517 -> 13337;
14517 -> 14494;
14517 -> 14515;
14517 -> 14516;
14517 -> 13335;
14518 -> 13336;
14518 -> 14517;
14519 -> 14513;
14519 -> 14517;
14520 -> 13337;
14520 -> 14517;
14520 -> 14518;
14520 -> 14519;
14520 -> 14514;
14521 -> 0;
14521 -> 13335;
14522 -> 14520;
14523 -> 14520;
14524 -> 14520;
14525 -> 14520;
14526 -> 14520;
14527 -> 14520;
14528 -> 14520;
14529 -> 14520;
14530 -> 14520;
14531 -> 14520;
14532 -> 14520;
14533 -> 14520;
14534 -> 14520;
14535 -> 14520;
14536 -> 14533;
14536 -> 14520;
14537 -> 14520;
14538 -> 14520;
14539 -> 14520;
14540 -> 14539;
14540 -> 14520;
14541 -> 14540;
14541 -> 14520;
14542 -> 14520;
14543 -> 14520;
14544 -> 14520;
14545 -> 14520;
14546 -> 14520;
14547 -> 14520;
14548 -> 14520;
14549 -> 14520;
14550 -> 14520;
14551 -> 14520;
14552 -> 14520;
14553 -> 14551;
14553 -> 14520;
14554 -> 14520;
14555 -> 14537;
14555 -> 14554;
14555 -> 14520;
14556 -> 14533;
14556 -> 14520;
14557 -> 14533;
14557 -> 14520;
14558 -> 14533;
14559 -> 14558;
14559 -> 14533;
14560 -> 14559;
14560 -> 14533;
14561 -> 14533;
14562 -> 14533;
14563 -> 14533;
14564 -> 14533;
14565 -> 14533;
14566 -> 14533;
14566 -> 14520;
14567 -> 14533;
14568 -> 14533;
14569 -> 14533;
14570 -> 14533;
14571 -> 14533;
14572 -> 14570;
14572 -> 14533;
14573 -> 14533;
14574 -> 14533;
14575 -> 14533;
14576 -> 14533;
14577 -> 14533;
14578 -> 14533;
14579 -> 14533;
14580 -> 14533;
14581 -> 14577;
14581 -> 14580;
14581 -> 14533;
14582 -> 14520;
14583 -> 14531;
14583 -> 14582;
14583 -> 14520;
14584 -> 14533;
14585 -> 14533;
14586 -> 14585;
14586 -> 14533;
14587 -> 14533;
14588 -> 14533;
14589 -> 14586;
14589 -> 14533;
14590 -> 14520;
14591 -> 0;
14591 -> 14520;
14592 -> 14533;
14593 -> 14533;
14594 -> 14533;
14595 -> 14533;
14596 -> 14533;
14597 -> 14533;
14598 -> 14533;
14599 -> 14533;
14600 -> 14533;
14601 -> 14533;
14602 -> 14533;
14603 -> 14601;
14603 -> 14602;
14603 -> 14533;
14604 -> 14585;
14605 -> 14585;
14606 -> 14585;
14607 -> 14604;
14607 -> 14585;
14608 -> 14533;
14609 -> 0;
14609 -> 14533;
14610 -> 14585;
14611 -> 14585;
14612 -> 14585;
14613 -> 14585;
14614 -> 14585;
14615 -> 14585;
14616 -> 14585;
14617 -> 14585;
14618 -> 14585;
14619 -> 14585;
14620 -> 14585;
14621 -> 14585;
14622 -> 14585;
14623 -> 14585;
14624 -> 14585;
14625 -> 14585;
14626 -> 14585;
14627 -> 14626;
14627 -> 14585;
14628 -> 14627;
14628 -> 14585;
14629 -> 14585;
14630 -> 14585;
14631 -> 14585;
14632 -> 14585;
14633 -> 14585;
14634 -> 14585;
14635 -> 14585;
14636 -> 14585;
14637 -> 14585;
14638 -> 14585;
14639 -> 14585;
14640 -> 14638;
14640 -> 14585;
14641 -> 14585;
14642 -> 14624;
14642 -> 14641;
14642 -> 14585;
14643 -> 14585;
14644 -> 14619;
14644 -> 14643;
14644 -> 14585;
14645 -> 14585;
14646 -> 0;
14646 -> 14585;
14647 -> 13072;
14648 -> 13333;
14648 -> 14647;
14648 -> 13072;
14649 -> 13074;
14649 -> 14585;
14649 -> 14648;
14650 -> 13074;
14650 -> 14648;
14651 -> 13333;
14651 -> 14585;
14651 -> 14648;
14652 -> 14648;
14653 -> 14648;
14654 -> 14649;
14654 -> 14653;
14655 -> 14650;
14655 -> 14653;
14656 -> 14651;
14656 -> 14653;
14657 -> 14652;
14657 -> 14653;
14658 -> 14653;
14659 -> 14656;
14659 -> 14651;
14659 -> 14658;
14659 -> 14653;
14660 -> 13076;
14660 -> 14656;
14660 -> 14648;
14661 -> 13076;
14661 -> 14660;
14661 -> 13072;
14662 -> 1;
14663 -> 1;
14664 -> 14662;
14664 -> 14663;
14665 -> 14661;
14665 -> 14663;
14666 -> 14663;
14667 -> 14666;
14667 -> 14663;
14668 -> 14663;
14669 -> 14668;
14670 -> 14665;
14671 -> 14665;
14672 -> 14665;
14673 -> 14665;
14674 -> 14672;
14674 -> 14673;
14674 -> 14665;
14675 -> 14674;
14676 -> 14670;
14676 -> 14675;
14676 -> 14674;
14677 -> 14676;
14678 -> 14672;
14678 -> 14674;
14679 -> 14677;
14679 -> 14678;
14679 -> 14661;
14679 -> 14674;
14680 -> 14679;
14681 -> 14679;
14681 -> 14680;
14682 -> 14681;
14682 -> 14680;
14683 -> 14680;
14684 -> 14680;
14685 -> 14682;
14685 -> 14684;
14686 -> 14683;
14686 -> 14684;
14687 -> 14685;
14687 -> 14686;
14687 -> 14684;
14688 -> 14683;
14688 -> 14679;
14689 -> 14679;
14690 -> 14689;
14691 -> 14690;
14691 -> 14689;
14692 -> 14689;
14693 -> 14689;
14694 -> 14691;
14694 -> 14693;
14695 -> 14692;
14695 -> 14693;
14696 -> 14694;
14696 -> 14695;
14696 -> 14693;
14697 -> 14679;
14698 -> 14696;
14698 -> 14697;
14699 -> 14696;
14699 -> 14697;
14700 -> 14699;
14700 -> 14696;
14700 -> 14697;
14701 -> 14698;
14701 -> 14696;
14701 -> 14697;
14702 -> 14700;
14702 -> 14701;
14702 -> 14697;
14703 -> 14700;
14703 -> 14696;
14703 -> 14701;
14703 -> 14697;
14704 -> 14703;
14705 -> 14688;
14705 -> 14704;
14705 -> 14687;
14705 -> 14679;
14706 -> 14671;
14706 -> 14705;
14706 -> 14679;
14707 -> 14706;
14708 -> 14705;
14709 -> 14707;
14709 -> 14708;
14710 -> 14709;
14711 -> 14710;
14712 -> 14711;
14712 -> 14710;
14713 -> 14710;
14714 -> 14712;
14714 -> 14713;
14715 -> 14714;
14715 -> 14710;
14716 -> 14710;
14717 -> 14712;
14717 -> 14716;
14718 -> 14717;
14718 -> 14710;
14718 -> 14716;
14719 -> 14718;
14719 -> 14710;
14720 -> 14710;
14721 -> 14712;
14721 -> 14720;
14722 -> 14721;
14722 -> 14710;
14722 -> 14720;
14723 -> 14722;
14723 -> 14710;
14724 -> 14719;
14724 -> 14723;
14724 -> 14710;
14725 -> 14715;
14725 -> 14724;
14725 -> 14710;
14726 -> 14677;
14726 -> 14725;
14726 -> 14709;
14727 -> 14725;
14727 -> 14726;
14727 -> 14709;
14728 -> 14727;
14729 -> 14727;
14730 -> 14728;
14730 -> 14729;
14731 -> 14728;
14731 -> 14729;
14732 -> 14729;
14733 -> 14730;
14733 -> 14732;
14733 -> 14726;
14733 -> 14729;
14734 -> 14729;
14735 -> 14733;
14735 -> 14734;
14736 -> 14729;
14737 -> 14735;
14737 -> 14736;
14738 -> 14731;
14738 -> 14736;
14739 -> 14731;
14739 -> 14729;
14740 -> 14730;
14740 -> 14731;
14740 -> 14729;
14741 -> 14705;
14741 -> 14728;
14741 -> 14737;
14741 -> 14739;
14741 -> 14740;
14741 -> 14733;
14741 -> 14727;
14742 -> 14741;
14743 -> 14665;
14743 -> 14741;
14744 -> 14741;
14745 -> 14741;
14746 -> 14744;
14746 -> 14745;
14747 -> 14746;
14747 -> 14741;
14747 -> 14745;
14748 -> 14747;
14748 -> 14741;
14749 -> 14741;
14750 -> 14741;
14751 -> 14748;
14751 -> 14750;
14752 -> 14743;
14752 -> 14751;
14753 -> 14741;
14753 -> 14751;
14754 -> 14751;
14755 -> 14751;
14756 -> 14752;
14756 -> 14755;
14757 -> 14753;
14757 -> 14755;
14758 -> 14753;
14758 -> 14755;
14759 -> 14754;
14759 -> 14755;
14760 -> 14754;
14760 -> 14755;
14762 -> 14761;
14764 -> 14763;
14766 -> 14765;
14768 -> 14767;
14770 -> 14769;
14772 -> 14771;
14773 -> 0;
14775 -> 14762;
14775 -> 14774;
14776 -> 14764;
14776 -> 14774;
14777 -> 14766;
14777 -> 14774;
14778 -> 14768;
14778 -> 14774;
14779 -> 14770;
14779 -> 14774;
14780 -> 14772;
14780 -> 14774;
14781 -> 14773;
14781 -> 14774;
14782 -> 14774;
14783 -> 14782;
14783 -> 14774;
14784 -> 14782;
14784 -> 14774;
14785 -> 14782;
14785 -> 14774;
14786 -> 14782;
14786 -> 14774;
14787 -> 14782;
14787 -> 14774;
14788 -> 14782;
14788 -> 14774;
14789 -> 14782;
14789 -> 14774;
14790 -> 14776;
14790 -> 14774;
14791 -> 14774;
14792 -> 14775;
14792 -> 14782;
14792 -> 14774;
14793 -> 14776;
14793 -> 14782;
14793 -> 14774;
14794 -> 14777;
14794 -> 14782;
14794 -> 14774;
14795 -> 14778;
14795 -> 14782;
14795 -> 14774;
14796 -> 14779;
14796 -> 14782;
14796 -> 14774;
14797 -> 14780;
14797 -> 14782;
14797 -> 14774;
14798 -> 14781;
14798 -> 14782;
14798 -> 14774;
14799 -> 14782;
14799 -> 14798;
14799 -> 0;
14799 -> 14774;
14800 -> 14774;
14801 -> 14780;
14801 -> 14774;
14802 -> 14774;
14804 -> 14803;
14806 -> 14805;
14808 -> 14807;
14810 -> 14809;
14812 -> 14811;
14814 -> 14813;
14815 -> 0;
14817 -> 14804;
14817 -> 14816;
14818 -> 14806;
14818 -> 14816;
14819 -> 14808;
14819 -> 14816;
14820 -> 14810;
14820 -> 14816;
14821 -> 14812;
14821 -> 14816;
14822 -> 14814;
14822 -> 14816;
14823 -> 14815;
14823 -> 14816;
14824 -> 14816;
14825 -> 14824;
14825 -> 14816;
14826 -> 14824;
14826 -> 14816;
14827 -> 14824;
14827 -> 14816;
14828 -> 14824;
14828 -> 14816;
14829 -> 14824;
14829 -> 14816;
14830 -> 14824;
14830 -> 14816;
14831 -> 14824;
14831 -> 14816;
14832 -> 14818;
14832 -> 14817;
14832 -> 14816;
14833 -> 14816;
14834 -> 14817;
14834 -> 14824;
14834 -> 14816;
14835 -> 14818;
14835 -> 14824;
14835 -> 14816;
14836 -> 14819;
14836 -> 14824;
14836 -> 14816;
14837 -> 14820;
14837 -> 14824;
14837 -> 14816;
14838 -> 14821;
14838 -> 14824;
14838 -> 14816;
14839 -> 14822;
14839 -> 14824;
14839 -> 14816;
14840 -> 14823;
14840 -> 14824;
14840 -> 14816;
14841 -> 14824;
14841 -> 14840;
14841 -> 0;
14841 -> 14816;
14842 -> 14816;
14843 -> 14822;
14843 -> 14816;
14844 -> 14816;
14846 -> 14845;
14848 -> 14847;
14850 -> 14849;
14852 -> 14851;
14854 -> 14853;
14856 -> 14855;
14857 -> 0;
14859 -> 14846;
14859 -> 14858;
14860 -> 14848;
14860 -> 14858;
14861 -> 14850;
14861 -> 14858;
14862 -> 14852;
14862 -> 14858;
14863 -> 14854;
14863 -> 14858;
14864 -> 14856;
14864 -> 14858;
14865 -> 14857;
14865 -> 14858;
14866 -> 14858;
14867 -> 14866;
14867 -> 14858;
14868 -> 14866;
14868 -> 14858;
14869 -> 14866;
14869 -> 14858;
14870 -> 14866;
14870 -> 14858;
14871 -> 14866;
14871 -> 14858;
14872 -> 14866;
14872 -> 14858;
14873 -> 14866;
14873 -> 14858;
14874 -> 14860;
14874 -> 14859;
14874 -> 14858;
14875 -> 14858;
14876 -> 14859;
14876 -> 14866;
14876 -> 14858;
14877 -> 14860;
14877 -> 14866;
14877 -> 14858;
14878 -> 14861;
14878 -> 14866;
14878 -> 14858;
14879 -> 14862;
14879 -> 14866;
14879 -> 14858;
14880 -> 14863;
14880 -> 14866;
14880 -> 14858;
14881 -> 14864;
14881 -> 14866;
14881 -> 14858;
14882 -> 14865;
14882 -> 14866;
14882 -> 14858;
14883 -> 14866;
14883 -> 14882;
14883 -> 0;
14883 -> 14858;
14884 -> 14858;
14885 -> 14864;
14885 -> 14858;
14886 -> 14858;
14888 -> 14887;
14890 -> 14889;
14892 -> 14891;
14894 -> 14893;
14896 -> 14895;
14898 -> 14897;
14899 -> 0;
14901 -> 14888;
14901 -> 14900;
14902 -> 14890;
14902 -> 14900;
14903 -> 14892;
14903 -> 14900;
14904 -> 14894;
14904 -> 14900;
14905 -> 14896;
14905 -> 14900;
14906 -> 14898;
14906 -> 14900;
14907 -> 14899;
14907 -> 14900;
14908 -> 14900;
14909 -> 14908;
14909 -> 14900;
14910 -> 14908;
14910 -> 14900;
14911 -> 14908;
14911 -> 14900;
14912 -> 14908;
14912 -> 14900;
14913 -> 14908;
14913 -> 14900;
14914 -> 14908;
14914 -> 14900;
14915 -> 14908;
14915 -> 14900;
14916 -> 14902;
14916 -> 14901;
14916 -> 14900;
14917 -> 14900;
14918 -> 14901;
14918 -> 14908;
14918 -> 14900;
14919 -> 14902;
14919 -> 14908;
14919 -> 14900;
14920 -> 14903;
14920 -> 14908;
14920 -> 14900;
14921 -> 14904;
14921 -> 14908;
14921 -> 14900;
14922 -> 14905;
14922 -> 14908;
14922 -> 14900;
14923 -> 14906;
14923 -> 14908;
14923 -> 14900;
14924 -> 14907;
14924 -> 14908;
14924 -> 14900;
14925 -> 14908;
14925 -> 14924;
14925 -> 0;
14925 -> 14900;
14926 -> 14900;
14927 -> 14906;
14927 -> 14900;
14928 -> 14908;
14928 -> 14924;
14928 -> 0;
14928 -> 14927;
14929 -> 14928;
14929 -> 14908;
14929 -> 14927;
14930 -> 14900;
14932 -> 14931;
14934 -> 14933;
14936 -> 14935;
14938 -> 14937;
14940 -> 14939;
14942 -> 14941;
14943 -> 0;
14945 -> 14932;
14945 -> 14944;
14946 -> 14934;
14946 -> 14944;
14947 -> 14936;
14947 -> 14944;
14948 -> 14938;
14948 -> 14944;
14949 -> 14940;
14949 -> 14944;
14950 -> 14942;
14950 -> 14944;
14951 -> 14943;
14951 -> 14944;
14952 -> 14944;
14953 -> 14952;
14953 -> 14944;
14954 -> 14952;
14954 -> 14944;
14955 -> 14952;
14955 -> 14944;
14956 -> 14952;
14956 -> 14944;
14957 -> 14952;
14957 -> 14944;
14958 -> 14952;
14958 -> 14944;
14959 -> 14952;
14959 -> 14944;
14960 -> 14946;
14960 -> 14945;
14960 -> 14944;
14961 -> 14944;
14962 -> 14945;
14962 -> 14952;
14962 -> 14944;
14963 -> 14946;
14963 -> 14952;
14963 -> 14944;
14964 -> 14947;
14964 -> 14952;
14964 -> 14944;
14965 -> 14948;
14965 -> 14952;
14965 -> 14944;
14966 -> 14949;
14966 -> 14952;
14966 -> 14944;
14967 -> 14950;
14967 -> 14952;
14967 -> 14944;
14968 -> 14951;
14968 -> 14952;
14968 -> 14944;
14969 -> 14952;
14969 -> 14968;
14969 -> 0;
14969 -> 14944;
14970 -> 14944;
14971 -> 14950;
14971 -> 14944;
14972 -> 14944;
14974 -> 14973;
14976 -> 14975;
14978 -> 14977;
14980 -> 14979;
14982 -> 14981;
14984 -> 14983;
14985 -> 0;
14987 -> 14974;
14987 -> 14986;
14988 -> 14976;
14988 -> 14986;
14989 -> 14978;
14989 -> 14986;
14990 -> 14980;
14990 -> 14986;
14991 -> 14982;
14991 -> 14986;
14992 -> 14984;
14992 -> 14986;
14993 -> 14985;
14993 -> 14986;
14994 -> 14986;
14995 -> 14994;
14995 -> 14986;
14996 -> 14994;
14996 -> 14986;
14997 -> 14994;
14997 -> 14986;
14998 -> 14994;
14998 -> 14986;
14999 -> 14994;
14999 -> 14986;
15000 -> 14994;
15000 -> 14986;
15001 -> 14994;
15001 -> 14986;
15002 -> 14988;
15002 -> 14987;
15002 -> 14986;
15003 -> 14986;
15004 -> 14987;
15004 -> 14994;
15004 -> 14986;
15005 -> 14988;
15005 -> 14994;
15005 -> 14986;
15006 -> 14989;
15006 -> 14994;
15006 -> 14986;
15007 -> 14990;
15007 -> 14994;
15007 -> 14986;
15008 -> 14991;
15008 -> 14994;
15008 -> 14986;
15009 -> 14992;
15009 -> 14994;
15009 -> 14986;
15010 -> 14993;
15010 -> 14994;
15010 -> 14986;
15011 -> 14994;
15011 -> 15010;
15011 -> 0;
15011 -> 14986;
15012 -> 14986;
15013 -> 14992;
15013 -> 14986;
15014 -> 14986;
15016 -> 15015;
15018 -> 15017;
15020 -> 15019;
15022 -> 15021;
15024 -> 15023;
15026 -> 15025;
15027 -> 0;
15029 -> 15016;
15029 -> 15028;
15030 -> 15018;
15030 -> 15028;
15031 -> 15020;
15031 -> 15028;
15032 -> 15022;
15032 -> 15028;
15033 -> 15024;
15033 -> 15028;
15034 -> 15026;
15034 -> 15028;
15035 -> 15027;
15035 -> 15028;
15036 -> 15028;
15037 -> 15036;
15037 -> 15028;
15038 -> 15036;
15038 -> 15028;
15039 -> 15036;
15039 -> 15028;
15040 -> 15036;
15040 -> 15028;
15041 -> 15036;
15041 -> 15028;
15042 -> 15036;
15042 -> 15028;
15043 -> 15036;
15043 -> 15028;
15044 -> 15030;
15044 -> 15028;
15045 -> 15028;
15046 -> 15029;
15046 -> 15036;
15046 -> 15028;
15047 -> 15030;
15047 -> 15036;
15047 -> 15028;
15048 -> 15031;
15048 -> 15036;
15048 -> 15028;
15049 -> 15032;
15049 -> 15036;
15049 -> 15028;
15050 -> 15033;
15050 -> 15036;
15050 -> 15028;
15051 -> 15034;
15051 -> 15036;
15051 -> 15028;
15052 -> 15035;
15052 -> 15036;
15052 -> 15028;
15053 -> 15036;
15053 -> 15052;
15053 -> 0;
15053 -> 15028;
15054 -> 15028;
15055 -> 15034;
15055 -> 15028;
15056 -> 15028;
15058 -> 15057;
15060 -> 15059;
15062 -> 15061;
15064 -> 15063;
15066 -> 15065;
15068 -> 15067;
15069 -> 0;
15070 -> 15069;
15072 -> 15058;
15072 -> 15071;
15073 -> 15060;
15073 -> 15071;
15074 -> 15062;
15074 -> 15071;
15075 -> 15064;
15075 -> 15071;
15076 -> 15066;
15076 -> 15071;
15077 -> 15068;
15077 -> 15071;
15078 -> 15070;
15078 -> 15071;
15079 -> 15071;
15080 -> 15079;
15080 -> 15071;
15081 -> 15079;
15081 -> 15071;
15082 -> 15079;
15082 -> 15071;
15083 -> 15079;
15083 -> 15071;
15084 -> 15079;
15084 -> 15071;
15085 -> 15079;
15085 -> 15071;
15086 -> 15079;
15086 -> 15071;
15087 -> 15073;
15087 -> 15071;
15088 -> 15071;
15089 -> 15072;
15089 -> 15079;
15089 -> 15071;
15090 -> 15073;
15090 -> 15079;
15090 -> 15071;
15091 -> 15074;
15091 -> 15079;
15091 -> 15071;
15092 -> 15075;
15092 -> 15079;
15092 -> 15071;
15093 -> 15076;
15093 -> 15079;
15093 -> 15071;
15094 -> 15077;
15094 -> 15079;
15094 -> 15071;
15095 -> 15078;
15095 -> 15079;
15095 -> 15071;
15096 -> 15079;
15096 -> 15095;
15096 -> 0;
15096 -> 15071;
15097 -> 15071;
15098 -> 15077;
15098 -> 15071;
15099 -> 15079;
15099 -> 15095;
15099 -> 0;
15099 -> 15098;
15100 -> 15099;
15100 -> 15079;
15100 -> 15098;
15101 -> 15071;
15103 -> 15102;
15105 -> 15104;
15107 -> 15106;
15109 -> 15108;
15111 -> 15110;
15113 -> 15112;
15114 -> 0;
15116 -> 15103;
15116 -> 15115;
15117 -> 15105;
15117 -> 15115;
15118 -> 15107;
15118 -> 15115;
15119 -> 15109;
15119 -> 15115;
15120 -> 15111;
15120 -> 15115;
15121 -> 15113;
15121 -> 15115;
15122 -> 15114;
15122 -> 15115;
15123 -> 15115;
15124 -> 15123;
15124 -> 15115;
15125 -> 15123;
15125 -> 15115;
15126 -> 15123;
15126 -> 15115;
15127 -> 15123;
15127 -> 15115;
15128 -> 15123;
15128 -> 15115;
15129 -> 15123;
15129 -> 15115;
15130 -> 15123;
15130 -> 15115;
15131 -> 15117;
15131 -> 15115;
15132 -> 15115;
15133 -> 15116;
15133 -> 15123;
15133 -> 15115;
15134 -> 15117;
15134 -> 15123;
15134 -> 15115;
15135 -> 15118;
15135 -> 15123;
15135 -> 15115;
15136 -> 15119;
15136 -> 15123;
15136 -> 15115;
15137 -> 15120;
15137 -> 15123;
15137 -> 15115;
15138 -> 15121;
15138 -> 15123;
15138 -> 15115;
15139 -> 15122;
15139 -> 15123;
15139 -> 15115;
15140 -> 15123;
15140 -> 15139;
15140 -> 0;
15140 -> 15115;
15141 -> 15115;
15142 -> 15121;
15142 -> 15115;
15143 -> 15123;
15143 -> 15139;
15143 -> 0;
15143 -> 15142;
15144 -> 15143;
15144 -> 15123;
15144 -> 15142;
15145 -> 15115;
15147 -> 15146;
15149 -> 15148;
15151 -> 15150;
15153 -> 15152;
15155 -> 15154;
15157 -> 15156;
15158 -> 0;
15160 -> 15147;
15160 -> 15159;
15161 -> 15149;
15161 -> 15159;
15162 -> 15151;
15162 -> 15159;
15163 -> 15153;
15163 -> 15159;
15164 -> 15155;
15164 -> 15159;
15165 -> 15157;
15165 -> 15159;
15166 -> 15158;
15166 -> 15159;
15167 -> 15159;
15168 -> 15167;
15168 -> 15159;
15169 -> 15167;
15169 -> 15159;
15170 -> 15167;
15170 -> 15159;
15171 -> 15167;
15171 -> 15159;
15172 -> 15167;
15172 -> 15159;
15173 -> 15167;
15173 -> 15159;
15174 -> 15167;
15174 -> 15159;
15175 -> 15161;
15175 -> 15159;
15176 -> 15159;
15177 -> 15160;
15177 -> 15167;
15177 -> 15159;
15178 -> 15161;
15178 -> 15167;
15178 -> 15159;
15179 -> 15162;
15179 -> 15167;
15179 -> 15159;
15180 -> 15163;
15180 -> 15167;
15180 -> 15159;
15181 -> 15164;
15181 -> 15167;
15181 -> 15159;
15182 -> 15165;
15182 -> 15167;
15182 -> 15159;
15183 -> 15166;
15183 -> 15167;
15183 -> 15159;
15184 -> 15167;
15184 -> 15183;
15184 -> 0;
15184 -> 15159;
15185 -> 15159;
15186 -> 15165;
15186 -> 15159;
15187 -> 15159;
15189 -> 15188;
15191 -> 15190;
15193 -> 15192;
15195 -> 15194;
15197 -> 15196;
15199 -> 15198;
15200 -> 0;
15201 -> 15200;
15201 -> 0;
15202 -> 15201;
15204 -> 15189;
15204 -> 15203;
15205 -> 15191;
15205 -> 15203;
15206 -> 15193;
15206 -> 15203;
15207 -> 15195;
15207 -> 15203;
15208 -> 15197;
15208 -> 15203;
15209 -> 15199;
15209 -> 15203;
15210 -> 15202;
15210 -> 15203;
15211 -> 15203;
15212 -> 15211;
15212 -> 15203;
15213 -> 15211;
15213 -> 15203;
15214 -> 15211;
15214 -> 15203;
15215 -> 15211;
15215 -> 15203;
15216 -> 15211;
15216 -> 15203;
15217 -> 15211;
15217 -> 15203;
15218 -> 15211;
15218 -> 15203;
15219 -> 15205;
15219 -> 15203;
15220 -> 15203;
15221 -> 15204;
15221 -> 15211;
15221 -> 15203;
15222 -> 15205;
15222 -> 15211;
15222 -> 15203;
15223 -> 15206;
15223 -> 15211;
15223 -> 15203;
15224 -> 15207;
15224 -> 15211;
15224 -> 15203;
15225 -> 15208;
15225 -> 15211;
15225 -> 15203;
15226 -> 15209;
15226 -> 15211;
15226 -> 15203;
15227 -> 15210;
15227 -> 15211;
15227 -> 15203;
15228 -> 15211;
15228 -> 15227;
15228 -> 0;
15228 -> 15203;
15229 -> 15203;
15230 -> 15209;
15230 -> 15203;
15231 -> 15203;
15233 -> 15232;
15235 -> 15234;
15237 -> 15236;
15239 -> 15238;
15241 -> 15240;
15243 -> 15242;
15244 -> 0;
15245 -> 15244;
15245 -> 0;
15246 -> 15245;
15248 -> 15233;
15248 -> 15247;
15249 -> 15235;
15249 -> 15247;
15250 -> 15237;
15250 -> 15247;
15251 -> 15239;
15251 -> 15247;
15252 -> 15241;
15252 -> 15247;
15253 -> 15243;
15253 -> 15247;
15254 -> 15246;
15254 -> 15247;
15255 -> 15247;
15256 -> 15255;
15256 -> 15247;
15257 -> 15255;
15257 -> 15247;
15258 -> 15255;
15258 -> 15247;
15259 -> 15255;
15259 -> 15247;
15260 -> 15255;
15260 -> 15247;
15261 -> 15255;
15261 -> 15247;
15262 -> 15255;
15262 -> 15247;
15263 -> 15249;
15263 -> 15247;
15264 -> 15247;
15265 -> 15248;
15265 -> 15255;
15265 -> 15247;
15266 -> 15249;
15266 -> 15255;
15266 -> 15247;
15267 -> 15250;
15267 -> 15255;
15267 -> 15247;
15268 -> 15251;
15268 -> 15255;
15268 -> 15247;
15269 -> 15252;
15269 -> 15255;
15269 -> 15247;
15270 -> 15253;
15270 -> 15255;
15270 -> 15247;
15271 -> 15254;
15271 -> 15255;
15271 -> 15247;
15272 -> 15255;
15272 -> 15271;
15272 -> 0;
15272 -> 15247;
15273 -> 15247;
15274 -> 15253;
15274 -> 15247;
15275 -> 15255;
15275 -> 15271;
15275 -> 0;
15275 -> 15274;
15276 -> 15275;
15276 -> 15255;
15276 -> 15274;
15277 -> 15247;
15279 -> 15278;
15281 -> 15280;
15283 -> 15282;
15285 -> 15284;
15287 -> 15286;
15289 -> 15288;
15290 -> 0;
15291 -> 15290;
15291 -> 0;
15292 -> 15291;
15294 -> 15279;
15294 -> 15293;
15295 -> 15281;
15295 -> 15293;
15296 -> 15283;
15296 -> 15293;
15297 -> 15285;
15297 -> 15293;
15298 -> 15287;
15298 -> 15293;
15299 -> 15289;
15299 -> 15293;
15300 -> 15292;
15300 -> 15293;
15301 -> 15293;
15302 -> 15301;
15302 -> 15293;
15303 -> 15301;
15303 -> 15293;
15304 -> 15301;
15304 -> 15293;
15305 -> 15301;
15305 -> 15293;
15306 -> 15301;
15306 -> 15293;
15307 -> 15301;
15307 -> 15293;
15308 -> 15301;
15308 -> 15293;
15309 -> 15295;
15309 -> 15293;
15310 -> 15293;
15311 -> 15294;
15311 -> 15301;
15311 -> 15293;
15312 -> 15295;
15312 -> 15301;
15312 -> 15293;
15313 -> 15296;
15313 -> 15301;
15313 -> 15293;
15314 -> 15297;
15314 -> 15301;
15314 -> 15293;
15315 -> 15298;
15315 -> 15301;
15315 -> 15293;
15316 -> 15299;
15316 -> 15301;
15316 -> 15293;
15317 -> 15300;
15317 -> 15301;
15317 -> 15293;
15318 -> 15301;
15318 -> 15317;
15318 -> 0;
15318 -> 15293;
15319 -> 15293;
15320 -> 15299;
15320 -> 15293;
15321 -> 15301;
15321 -> 15317;
15321 -> 0;
15321 -> 15320;
15322 -> 15321;
15322 -> 15301;
15322 -> 15320;
15323 -> 15293;
15325 -> 15324;
15327 -> 15326;
15329 -> 15328;
15331 -> 15330;
15333 -> 15332;
15335 -> 15334;
15336 -> 0;
15337 -> 15336;
15337 -> 0;
15338 -> 15337;
15340 -> 15325;
15340 -> 15339;
15341 -> 15327;
15341 -> 15339;
15342 -> 15329;
15342 -> 15339;
15343 -> 15331;
15343 -> 15339;
15344 -> 15333;
15344 -> 15339;
15345 -> 15335;
15345 -> 15339;
15346 -> 15338;
15346 -> 15339;
15347 -> 15339;
15348 -> 15347;
15348 -> 15339;
15349 -> 15347;
15349 -> 15339;
15350 -> 15347;
15350 -> 15339;
15351 -> 15347;
15351 -> 15339;
15352 -> 15347;
15352 -> 15339;
15353 -> 15347;
15353 -> 15339;
15354 -> 15347;
15354 -> 15339;
15355 -> 15341;
15355 -> 15339;
15356 -> 15339;
15357 -> 15340;
15357 -> 15347;
15357 -> 15339;
15358 -> 15341;
15358 -> 15347;
15358 -> 15339;
15359 -> 15342;
15359 -> 15347;
15359 -> 15339;
15360 -> 15343;
15360 -> 15347;
15360 -> 15339;
15361 -> 15344;
15361 -> 15347;
15361 -> 15339;
15362 -> 15345;
15362 -> 15347;
15362 -> 15339;
15363 -> 15346;
15363 -> 15347;
15363 -> 15339;
15364 -> 15347;
15364 -> 15363;
15364 -> 0;
15364 -> 15339;
15365 -> 15339;
15366 -> 15345;
15366 -> 15339;
15367 -> 15339;
15369 -> 15368;
15371 -> 15370;
15373 -> 15372;
15375 -> 15374;
15377 -> 15376;
15379 -> 15378;
15380 -> 0;
15381 -> 15380;
15381 -> 0;
15382 -> 15381;
15384 -> 15369;
15384 -> 15383;
15385 -> 15371;
15385 -> 15383;
15386 -> 15373;
15386 -> 15383;
15387 -> 15375;
15387 -> 15383;
15388 -> 15377;
15388 -> 15383;
15389 -> 15379;
15389 -> 15383;
15390 -> 15382;
15390 -> 15383;
15391 -> 15383;
15392 -> 15391;
15392 -> 15383;
15393 -> 15391;
15393 -> 15383;
15394 -> 15391;
15394 -> 15383;
15395 -> 15391;
15395 -> 15383;
15396 -> 15391;
15396 -> 15383;
15397 -> 15391;
15397 -> 15383;
15398 -> 15391;
15398 -> 15383;
15399 -> 15385;
15399 -> 15384;
15399 -> 15383;
15400 -> 15383;
15401 -> 15384;
15401 -> 15391;
15401 -> 15383;
15402 -> 15385;
15402 -> 15391;
15402 -> 15383;
15403 -> 15386;
15403 -> 15391;
15403 -> 15383;
15404 -> 15387;
15404 -> 15391;
15404 -> 15383;
15405 -> 15388;
15405 -> 15391;
15405 -> 15383;
15406 -> 15389;
15406 -> 15391;
15406 -> 15383;
15407 -> 15390;
15407 -> 15391;
15407 -> 15383;
15408 -> 15391;
15408 -> 15407;
15408 -> 0;
15408 -> 15383;
15409 -> 15383;
15410 -> 15389;
15410 -> 15383;
15411 -> 15391;
15411 -> 15407;
15411 -> 0;
15411 -> 15410;
15412 -> 15411;
15412 -> 15391;
15412 -> 15410;
15413 -> 15383;
15415 -> 15414;
15417 -> 15416;
15419 -> 15418;
15421 -> 15420;
15423 -> 15422;
15425 -> 15424;
15426 -> 0;
15427 -> 15426;
15427 -> 0;
15428 -> 15427;
15430 -> 15415;
15430 -> 15429;
15431 -> 15417;
15431 -> 15429;
15432 -> 15419;
15432 -> 15429;
15433 -> 15421;
15433 -> 15429;
15434 -> 15423;
15434 -> 15429;
15435 -> 15425;
15435 -> 15429;
15436 -> 15428;
15436 -> 15429;
15437 -> 15429;
15438 -> 15437;
15438 -> 15429;
15439 -> 15437;
15439 -> 15429;
15440 -> 15437;
15440 -> 15429;
15441 -> 15437;
15441 -> 15429;
15442 -> 15437;
15442 -> 15429;
15443 -> 15437;
15443 -> 15429;
15444 -> 15437;
15444 -> 15429;
15445 -> 15431;
15445 -> 15430;
15445 -> 15429;
15446 -> 15429;
15447 -> 15430;
15447 -> 15437;
15447 -> 15429;
15448 -> 15431;
15448 -> 15437;
15448 -> 15429;
15449 -> 15432;
15449 -> 15437;
15449 -> 15429;
15450 -> 15433;
15450 -> 15437;
15450 -> 15429;
15451 -> 15434;
15451 -> 15437;
15451 -> 15429;
15452 -> 15435;
15452 -> 15437;
15452 -> 15429;
15453 -> 15436;
15453 -> 15437;
15453 -> 15429;
15454 -> 15437;
15454 -> 15453;
15454 -> 0;
15454 -> 15429;
15455 -> 15429;
15456 -> 15435;
15456 -> 15429;
15457 -> 15429;
15459 -> 15458;
15461 -> 15460;
15463 -> 15462;
15465 -> 15464;
15467 -> 15466;
15469 -> 15468;
15470 -> 0;
15471 -> 15470;
15471 -> 0;
15472 -> 15471;
15474 -> 15459;
15474 -> 15473;
15475 -> 15461;
15475 -> 15473;
15476 -> 15463;
15476 -> 15473;
15477 -> 15465;
15477 -> 15473;
15478 -> 15467;
15478 -> 15473;
15479 -> 15469;
15479 -> 15473;
15480 -> 15472;
15480 -> 15473;
15481 -> 15473;
15482 -> 15481;
15482 -> 15473;
15483 -> 15481;
15483 -> 15473;
15484 -> 15481;
15484 -> 15473;
15485 -> 15481;
15485 -> 15473;
15486 -> 15481;
15486 -> 15473;
15487 -> 15481;
15487 -> 15473;
15488 -> 15481;
15488 -> 15473;
15489 -> 15475;
15489 -> 15473;
15490 -> 15473;
15491 -> 15474;
15491 -> 15481;
15491 -> 15473;
15492 -> 15475;
15492 -> 15481;
15492 -> 15473;
15493 -> 15476;
15493 -> 15481;
15493 -> 15473;
15494 -> 15477;
15494 -> 15481;
15494 -> 15473;
15495 -> 15478;
15495 -> 15481;
15495 -> 15473;
15496 -> 15479;
15496 -> 15481;
15496 -> 15473;
15497 -> 15480;
15497 -> 15481;
15497 -> 15473;
15498 -> 15481;
15498 -> 15497;
15498 -> 0;
15498 -> 15473;
15499 -> 15473;
15500 -> 15479;
15500 -> 15473;
15501 -> 15473;
15503 -> 15502;
15505 -> 15504;
15507 -> 15506;
15509 -> 15508;
15511 -> 15510;
15513 -> 15512;
15514 -> 0;
15515 -> 15514;
15515 -> 0;
15516 -> 15515;
15518 -> 15503;
15518 -> 15517;
15519 -> 15505;
15519 -> 15517;
15520 -> 15507;
15520 -> 15517;
15521 -> 15509;
15521 -> 15517;
15522 -> 15511;
15522 -> 15517;
15523 -> 15513;
15523 -> 15517;
15524 -> 15516;
15524 -> 15517;
15525 -> 15517;
15526 -> 15525;
15526 -> 15517;
15527 -> 15525;
15527 -> 15517;
15528 -> 15525;
15528 -> 15517;
15529 -> 15525;
15529 -> 15517;
15530 -> 15525;
15530 -> 15517;
15531 -> 15525;
15531 -> 15517;
15532 -> 15525;
15532 -> 15517;
15533 -> 15519;
15533 -> 15517;
15534 -> 15517;
15535 -> 15518;
15535 -> 15525;
15535 -> 15517;
15536 -> 15519;
15536 -> 15525;
15536 -> 15517;
15537 -> 15520;
15537 -> 15525;
15537 -> 15517;
15538 -> 15521;
15538 -> 15525;
15538 -> 15517;
15539 -> 15522;
15539 -> 15525;
15539 -> 15517;
15540 -> 15523;
15540 -> 15525;
15540 -> 15517;
15541 -> 15524;
15541 -> 15525;
15541 -> 15517;
15542 -> 15525;
15542 -> 15541;
15542 -> 0;
15542 -> 15517;
15543 -> 15517;
15544 -> 15523;
15544 -> 15517;
15545 -> 15517;
15546 -> 14972;
15547 -> 15546;
15547 -> 14962;
15547 -> 14963;
15547 -> 14964;
15547 -> 14965;
15547 -> 14966;
15547 -> 14967;
15547 -> 14968;
15548 -> 15547;
15549 -> 0;
15550 -> 15549;
15551 -> 15550;
15552 -> 0;
15553 -> 15552;
15554 -> 0;
15555 -> 15554;
15556 -> 14756;
15556 -> 14755;
15557 -> 14757;
15557 -> 14755;
15558 -> 14758;
15558 -> 14755;
15559 -> 14759;
15559 -> 14755;
15560 -> 14755;
15561 -> 15556;
15561 -> 15560;
15562 -> 15557;
15562 -> 15560;
15563 -> 15558;
15563 -> 15560;
15564 -> 15559;
15564 -> 15560;
15565 -> 14760;
15565 -> 15560;
15566 -> 15564;
15566 -> 15560;
15567 -> 15560;
15568 -> 15566;
15568 -> 15567;
15569 -> 15565;
15569 -> 15567;
15570 -> 15565;
15570 -> 15560;
15571 -> 15565;
15571 -> 15560;
15572 -> 15565;
15572 -> 15560;
15574 -> 15573;
15575 -> 15574;
15575 -> 15573;
15576 -> 15574;
15576 -> 15573;
15577 -> 15574;
15577 -> 15573;
15578 -> 15574;
15578 -> 15573;
15579 -> 15574;
15579 -> 15573;
15580 -> 15574;
15580 -> 15573;
15581 -> 15573;
15582 -> 15581;
15582 -> 15565;
15582 -> 15560;
15583 -> 15565;
15583 -> 15560;
15584 -> 15565;
15584 -> 15560;
15585 -> 15565;
15585 -> 15560;
15586 -> 15565;
15586 -> 15560;
15587 -> 15565;
15587 -> 15560;
15588 -> 12990;
15588 -> 15565;
15588 -> 15560;
15589 -> 15565;
15589 -> 15560;
15590 -> 15565;
15590 -> 15560;
15591 -> 15561;
15591 -> 15565;
15591 -> 15560;
15592 -> 15562;
15592 -> 15565;
15592 -> 15560;
15593 -> 15560;
15594 -> 15562;
15594 -> 15593;
15595 -> 15594;
15595 -> 15560;
15596 -> 15560;
15597 -> 15595;
15597 -> 15596;
15598 -> 15597;
15598 -> 15596;
15599 -> 0;
15599 -> 15598;
15600 -> 15599;
15600 -> 15560;
15601 -> 15563;
15601 -> 15560;
15602 -> 15560;
15603 -> 15600;
15603 -> 15602;
15604 -> 15601;
15604 -> 15602;
15605 -> 15565;
15605 -> 15602;
15606 -> 15602;
15607 -> 15605;
15607 -> 15606;
15608 -> 15607;
15608 -> 15591;
15608 -> 15606;
15609 -> 15608;
15609 -> 15602;
15610 -> 15602;
15611 -> 0;
15611 -> 15602;
15612 -> 15602;
15613 -> 15609;
15613 -> 15612;
15614 -> 15612;
15614 -> 15602;
15615 -> 0;
15615 -> 15614;
15616 -> 15603;
15616 -> 15602;
15617 -> 0;
15617 -> 15616;
15618 -> 15611;
15618 -> 15617;
15618 -> 15616;
15619 -> 15616;
15620 -> 15605;
15620 -> 15619;
15621 -> 15619;
15622 -> 15620;
15622 -> 15592;
15622 -> 15621;
15623 -> 15622;
15623 -> 15619;
15624 -> 15619;
15625 -> 15619;
15626 -> 15623;
15626 -> 15625;
15627 -> 15626;
15627 -> 15616;
15628 -> 15618;
15628 -> 0;
15628 -> 15627;
15629 -> 15602;
15630 -> 15615;
15630 -> 15602;
15631 -> 15628;
15631 -> 15602;
15632 -> 15604;
15632 -> 15602;
15633 -> 15629;
15633 -> 15602;
15634 -> 15602;
15635 -> 15630;
15635 -> 15634;
15636 -> 15631;
15636 -> 15634;
15637 -> 15632;
15637 -> 15634;
15638 -> 15633;
15638 -> 15634;
15639 -> 15605;
15639 -> 15634;
15640 -> 15634;
15641 -> 0;
15641 -> 15634;
15642 -> 15634;
15643 -> 15639;
15643 -> 15592;
15643 -> 15642;
15644 -> 15643;
15644 -> 14741;
15644 -> 15623;
15644 -> 15642;
15645 -> 15644;
15645 -> 15634;
15646 -> 15634;
15647 -> 15634;
15648 -> 15647;
15648 -> 15645;
15648 -> 15634;
15649 -> 15648;
15650 -> 15649;
15650 -> 15648;
15651 -> 15648;
15652 -> 15650;
15652 -> 15651;
15653 -> 15652;
15653 -> 15650;
15653 -> 15651;
15654 -> 15653;
15654 -> 15648;
15655 -> 15648;
15656 -> 15640;
15656 -> 15648;
15657 -> 15654;
15657 -> 15656;
15658 -> 15636;
15658 -> 15656;
15659 -> 15656;
15660 -> 15659;
15660 -> 14741;
15660 -> 15650;
15661 -> 15660;
15661 -> 15656;
15662 -> 15656;
15663 -> 15661;
15663 -> 15662;
15664 -> 15663;
15664 -> 15661;
15664 -> 15662;
15665 -> 15637;
15665 -> 15656;
15666 -> 15656;
15667 -> 15640;
15667 -> 15656;
15668 -> 15656;
15669 -> 15657;
15669 -> 15668;
15670 -> 15658;
15670 -> 15668;
15671 -> 15664;
15671 -> 15668;
15672 -> 15665;
15672 -> 15668;
15673 -> 15666;
15673 -> 15668;
15674 -> 15667;
15674 -> 15668;
15675 -> 15668;
15676 -> 15669;
15676 -> 15670;
15676 -> 15668;
15677 -> 15669;
15677 -> 15670;
15677 -> 15668;
15678 -> 15676;
15678 -> 0;
15678 -> 15668;
15679 -> 15677;
15679 -> 0;
15679 -> 15668;
15680 -> 15668;
15681 -> 15677;
15681 -> 15668;
15682 -> 15675;
15682 -> 15656;
15683 -> 15681;
15683 -> 15682;
15684 -> 15639;
15684 -> 15682;
15685 -> 15682;
15686 -> 15682;
15687 -> 15683;
15687 -> 15686;
15688 -> 15684;
15688 -> 15686;
15689 -> 15685;
15689 -> 15686;
15690 -> 15687;
15690 -> 15686;
15691 -> 15686;
15692 -> 15690;
15692 -> 15691;
15693 -> 15692;
15693 -> 0;
15693 -> 15691;
15694 -> 15693;
15695 -> 15686;
15696 -> 15688;
15696 -> 15695;
15697 -> 0;
15697 -> 15695;
15698 -> 15697;
15698 -> 15686;
15699 -> 15689;
15699 -> 15698;
15699 -> 15686;
15700 -> 15687;
15700 -> 0;
15700 -> 15686;
15701 -> 15686;
15702 -> 15699;
15702 -> 15700;
15702 -> 15686;
15703 -> 15687;
15703 -> 0;
15703 -> 15702;
15704 -> 15686;
15705 -> 15704;
15705 -> 15682;
15706 -> 15682;
15707 -> 15705;
15707 -> 15706;
15707 -> 15682;
15708 -> 15641;
15708 -> 0;
15708 -> 15648;
15709 -> 15681;
15709 -> 15708;
15710 -> 15709;
15710 -> 0;
15710 -> 15634;
15711 -> 15634;
15712 -> 15709;
15712 -> 15635;
15712 -> 15710;
15713 -> 15646;
15713 -> 15634;
15714 -> 15634;
15715 -> 15639;
15715 -> 15714;
15716 -> 15714;
15717 -> 15715;
15717 -> 15592;
15717 -> 15716;
15718 -> 15717;
15718 -> 14741;
15718 -> 15661;
15718 -> 15716;
15719 -> 15718;
15719 -> 15714;
15720 -> 15719;
15720 -> 15634;
15721 -> 0;
15721 -> 15634;
15722 -> 15634;
15723 -> 15721;
15723 -> 15722;
15724 -> 15720;
15724 -> 15723;
15724 -> 15634;
15725 -> 15712;
15725 -> 15634;
15727 -> 15726;
15728 -> 15605;
15728 -> 15602;
15729 -> 15725;
15729 -> 15602;
15730 -> 15604;
15730 -> 15602;
15731 -> 15602;
15732 -> 15728;
15732 -> 15731;
15733 -> 15729;
15733 -> 15731;
15734 -> 15730;
15734 -> 15731;
15735 -> 15732;
15735 -> 15731;
15736 -> 15733;
15736 -> 15731;
15737 -> 15731;
15738 -> 15732;
15738 -> 15737;
15739 -> 15737;
15740 -> 15738;
15740 -> 15592;
15740 -> 15739;
15741 -> 15739;
15742 -> 15740;
15742 -> 15741;
15743 -> 15742;
15743 -> 14741;
15743 -> 15661;
15743 -> 15741;
15744 -> 15743;
15744 -> 15739;
15745 -> 15739;
15746 -> 15744;
15747 -> 15746;
15747 -> 15744;
15748 -> 15744;
15749 -> 15744;
15750 -> 15747;
15750 -> 15749;
15751 -> 15750;
15751 -> 15747;
15751 -> 15749;
15752 -> 15751;
15752 -> 15737;
15753 -> 15752;
15753 -> 15731;
15754 -> 15731;
15755 -> 15734;
15755 -> 15731;
15756 -> 15731;
15757 -> 15735;
15757 -> 15756;
15758 -> 15736;
15758 -> 15756;
15759 -> 15753;
15759 -> 15756;
15760 -> 15755;
15760 -> 15756;
15761 -> 15758;
15761 -> 0;
15761 -> 15756;
15762 -> 15602;
15763 -> 15725;
15763 -> 0;
15763 -> 15602;
15764 -> 15602;
15765 -> 15675;
15765 -> 15763;
15765 -> 15602;
15766 -> 0;
15766 -> 15602;
15767 -> 15725;
15767 -> 15766;
15767 -> 15602;
15768 -> 15675;
15768 -> 15767;
15768 -> 15602;
15769 -> 15603;
15769 -> 15602;
15770 -> 15725;
15770 -> 15602;
15771 -> 15560;
15772 -> 15562;
15772 -> 15771;
15773 -> 15772;
15773 -> 14741;
15773 -> 15753;
15773 -> 15771;
15774 -> 15773;
15774 -> 15560;
15775 -> 15774;
15775 -> 15753;
15775 -> 14741;
15776 -> 15563;
15776 -> 15775;
15776 -> 14665;
15776 -> 15753;
15776 -> 14741;
15776 -> 15774;
15777 -> 15770;
15777 -> 0;
15777 -> 15560;
15778 -> 15560;
15779 -> 15777;
15779 -> 15778;
15779 -> 15560;
15780 -> 15770;
15780 -> 15565;
15780 -> 15560;
15781 -> 15777;
15781 -> 0;
15781 -> 15560;
15782 -> 15781;
15782 -> 15560;
15784 -> 15783;
15786 -> 15785;
15787 -> 15784;
15787 -> 15786;
15788 -> 15787;
15790 -> 15789;
15791 -> 15788;
15791 -> 15790;
15792 -> 15791;
15794 -> 15793;
15795 -> 15792;
15795 -> 15794;
15796 -> 15795;
15798 -> 15797;
15799 -> 15796;
15799 -> 15798;
15800 -> 15799;
15802 -> 15801;
15803 -> 15800;
15803 -> 15802;
15804 -> 15803;
15806 -> 15805;
15808 -> 15807;
15808 -> 15786;
15810 -> 15808;
15810 -> 15809;
15811 -> 15810;
15813 -> 15812;
15813 -> 15790;
15815 -> 15813;
15815 -> 15814;
15816 -> 15815;
15818 -> 15817;
15818 -> 15802;
15820 -> 15818;
15820 -> 15819;
15821 -> 15820;
15823 -> 15822;
15823 -> 15806;
15825 -> 15823;
15825 -> 15824;
15826 -> 15825;
15828 -> 15827;
15828 -> 15792;
15829 -> 15828;
15831 -> 15830;
15831 -> 15796;
15832 -> 15831;
15833 -> 15811;
15834 -> 15826;
15835 -> 15782;
15835 -> 15560;
15836 -> 15599;
15836 -> 15560;
15837 -> 15560;
15838 -> 15560;
15839 -> 15835;
15839 -> 15838;
15840 -> 15836;
15840 -> 15838;
15841 -> 15837;
15841 -> 15838;
15842 -> 15839;
15842 -> 15811;
15842 -> 15838;
15843 -> 15842;
15843 -> 15784;
15843 -> 15838;
15844 -> 15840;
15844 -> 15821;
15844 -> 15838;
15845 -> 15844;
15845 -> 15800;
15845 -> 15838;
15846 -> 15843;
15846 -> 15845;
15846 -> 15838;
15847 -> 15846;
15847 -> 15841;
15847 -> 15838;
15848 -> 15837;
15848 -> 15565;
15848 -> 15560;
15849 -> 15560;
15850 -> 15565;
15850 -> 15849;
15851 -> 15850;
15851 -> 15591;
15851 -> 15849;
15852 -> 15851;
15852 -> 15560;
15853 -> 15852;
15853 -> 15560;
15854 -> 15560;
15855 -> 0;
15855 -> 15560;
15856 -> 15560;
15857 -> 15855;
15857 -> 15856;
15858 -> 15565;
15858 -> 15856;
15859 -> 15858;
15859 -> 15857;
15859 -> 15856;
15860 -> 14760;
15860 -> 14755;
15861 -> 14760;
15861 -> 14755;
15862 -> 14760;
15862 -> 14755;
15863 -> 0;
15863 -> 14760;
15863 -> 14755;
15864 -> 14760;
15864 -> 14755;
15865 -> 13570;
15865 -> 14760;
15865 -> 14755;
15866 -> 14760;
15866 -> 14755;
15867 -> 13570;
15867 -> 14760;
15867 -> 14755;
15868 -> 14755;
15869 -> 14757;
15869 -> 15868;
15870 -> 15869;
15870 -> 14741;
15870 -> 15776;
15870 -> 15868;
15871 -> 15870;
15871 -> 14755;
15872 -> 14755;
15873 -> 14756;
15873 -> 15872;
15874 -> 15872;
15874 -> 14755;
15875 -> 14754;
15875 -> 14741;
15876 -> 14741;
15877 -> 15875;
15877 -> 15592;
15877 -> 15876;
15878 -> 15877;
15878 -> 14741;
15878 -> 15870;
15878 -> 15876;
15879 -> 15878;
15879 -> 14741;
15880 -> 14665;
15880 -> 15879;
15881 -> 15880;
15881 -> 15879;
15882 -> 15879;
15883 -> 15881;
15883 -> 15879;
15884 -> 15882;
15884 -> 15879;
15885 -> 15883;
15885 -> 15879;
15886 -> 15884;
15886 -> 15879;
15887 -> 15886;
15887 -> 15879;
15888 -> 15879;
15889 -> 15879;
15890 -> 15879;
15891 -> 15879;
15892 -> 15581;
15892 -> 15879;
15893 -> 15879;
15894 -> 15879;
15895 -> 15879;
15896 -> 15879;
15897 -> 15879;
15898 -> 12990;
15898 -> 15879;
15899 -> 15879;
15900 -> 15879;
15901 -> 15885;
15901 -> 15879;
15902 -> 15879;
15903 -> 15879;
15904 -> 15879;
15904 -> 15903;
15905 -> 15904;
15905 -> 15901;
15905 -> 15903;
15906 -> 15905;
15906 -> 15879;
15907 -> 15879;
15908 -> 0;
15908 -> 15879;
15909 -> 15879;
15910 -> 15906;
15910 -> 15909;
15911 -> 15909;
15911 -> 15879;
15912 -> 0;
15912 -> 15911;
15913 -> 0;
15913 -> 15879;
15914 -> 15908;
15914 -> 15913;
15914 -> 15879;
15915 -> 15879;
15916 -> 15915;
15916 -> 15879;
15917 -> 15914;
15917 -> 0;
15917 -> 15916;
15918 -> 15879;
15919 -> 15912;
15919 -> 15879;
15920 -> 15917;
15920 -> 15879;
15921 -> 15902;
15921 -> 15879;
15922 -> 15918;
15922 -> 15879;
15923 -> 15919;
15923 -> 15879;
15924 -> 15920;
15924 -> 15879;
15925 -> 15921;
15925 -> 15879;
15926 -> 15922;
15926 -> 15879;
15927 -> 0;
15927 -> 15879;
15928 -> 15879;
15929 -> 15879;
15930 -> 15879;
15930 -> 15929;
15931 -> 15930;
15931 -> 15879;
15931 -> 15929;
15932 -> 15931;
15932 -> 15879;
15933 -> 15879;
15934 -> 15879;
15935 -> 15879;
15936 -> 15932;
15936 -> 15935;
15937 -> 15924;
15937 -> 15935;
15938 -> 15934;
15938 -> 15935;
15939 -> 15925;
15939 -> 15935;
15940 -> 15934;
15940 -> 15935;
15941 -> 15934;
15941 -> 15935;
15942 -> 15935;
15943 -> 15936;
15943 -> 15937;
15943 -> 15935;
15944 -> 15936;
15944 -> 15937;
15944 -> 15935;
15945 -> 15943;
15945 -> 0;
15945 -> 15935;
15946 -> 15944;
15946 -> 0;
15946 -> 15935;
15947 -> 15935;
15948 -> 15944;
15948 -> 15935;
15949 -> 15942;
15949 -> 15879;
15950 -> 15948;
15950 -> 15949;
15951 -> 15879;
15951 -> 15949;
15952 -> 15949;
15953 -> 15949;
15954 -> 15950;
15954 -> 15953;
15955 -> 15951;
15955 -> 15953;
15956 -> 15952;
15956 -> 15953;
15957 -> 15954;
15957 -> 15953;
15958 -> 15953;
15959 -> 15957;
15959 -> 15958;
15960 -> 15959;
15960 -> 0;
15960 -> 15958;
15961 -> 15960;
15962 -> 15953;
15963 -> 15955;
15963 -> 15962;
15964 -> 0;
15964 -> 15962;
15965 -> 15964;
15965 -> 15953;
15966 -> 15956;
15966 -> 15965;
15966 -> 15953;
15967 -> 15954;
15967 -> 0;
15967 -> 15953;
15968 -> 15953;
15969 -> 15966;
15969 -> 15967;
15969 -> 15953;
15970 -> 15954;
15970 -> 0;
15970 -> 15969;
15971 -> 15953;
15972 -> 15971;
15972 -> 15949;
15973 -> 15949;
15974 -> 15972;
15974 -> 15973;
15974 -> 15949;
15975 -> 15927;
15975 -> 0;
15975 -> 15879;
15976 -> 15948;
15976 -> 15975;
15977 -> 15976;
15977 -> 0;
15977 -> 15879;
15978 -> 15879;
15979 -> 15976;
15979 -> 15923;
15979 -> 15977;
15980 -> 15928;
15980 -> 15879;
15981 -> 15879;
15982 -> 15981;
15982 -> 15879;
15983 -> 0;
15983 -> 15879;
15984 -> 15879;
15985 -> 15983;
15985 -> 15984;
15986 -> 15982;
15986 -> 15985;
15986 -> 15879;
15987 -> 15979;
15987 -> 15879;
15988 -> 15987;
15988 -> 15879;
15989 -> 15902;
15989 -> 15879;
15990 -> 15879;
15991 -> 15879;
15991 -> 15990;
15992 -> 15988;
15992 -> 15990;
15993 -> 15934;
15993 -> 15990;
15994 -> 15989;
15994 -> 15990;
15995 -> 15992;
15995 -> 0;
15995 -> 15990;
15996 -> 15987;
15996 -> 0;
15996 -> 15879;
15997 -> 15879;
15998 -> 15942;
15998 -> 15996;
15998 -> 15879;
15999 -> 0;
15999 -> 15879;
16000 -> 15987;
16000 -> 15999;
16000 -> 15879;
16001 -> 15942;
16001 -> 16000;
16001 -> 15879;
16002 -> 15879;
16003 -> 15987;
16003 -> 15879;
16004 -> 16003;
16004 -> 0;
16004 -> 15879;
16005 -> 15879;
16006 -> 16004;
16006 -> 16005;
16006 -> 15879;
16007 -> 16003;
16007 -> 15879;
16008 -> 16004;
16008 -> 0;
16008 -> 15879;
16009 -> 16008;
16009 -> 15879;
16010 -> 16009;
16010 -> 15879;
16011 -> 15879;
16012 -> 15879;
16013 -> 16010;
16013 -> 16012;
16014 -> 16011;
16014 -> 16012;
16015 -> 16011;
16015 -> 16012;
16016 -> 16013;
16016 -> 15811;
16016 -> 16012;
16017 -> 16016;
16017 -> 15784;
16017 -> 16012;
16018 -> 16014;
16018 -> 15821;
16018 -> 16012;
16019 -> 16018;
16019 -> 15800;
16019 -> 16012;
16020 -> 16017;
16020 -> 16019;
16020 -> 16012;
16021 -> 16020;
16021 -> 16015;
16021 -> 16012;
16022 -> 16011;
16022 -> 15879;
16023 -> 15879;
16024 -> 15879;
16024 -> 16023;
16025 -> 16024;
16025 -> 15901;
16025 -> 16023;
16026 -> 16025;
16026 -> 15879;
16027 -> 16026;
16027 -> 15879;
16028 -> 15879;
16029 -> 0;
16029 -> 15879;
16030 -> 15879;
16031 -> 16029;
16031 -> 16030;
16032 -> 15879;
16033 -> 15879;
16034 -> 15879;
16035 -> 0;
16035 -> 15879;
16036 -> 15879;
16037 -> 13570;
16037 -> 15879;
16038 -> 15879;
16039 -> 13570;
16039 -> 15879;
16040 -> 15934;
16040 -> 15879;
16041 -> 15879;
16042 -> 15881;
16042 -> 16041;
16043 -> 16041;
16043 -> 15879;
16044 -> 15981;
16044 -> 14741;
16044 -> 15934;
16045 -> 16044;
16046 -> 16045;
16046 -> 16044;
16047 -> 16044;
16048 -> 0;
16048 -> 16044;
16049 -> 14665;
16050 -> 14665;
16051 -> 14665;
16052 -> 14665;
16053 -> 14665;
16054 -> 16049;
16054 -> 16053;
16055 -> 16053;
16056 -> 16054;
16056 -> 15934;
16056 -> 16055;
16057 -> 16056;
16057 -> 15934;
16057 -> 16055;
16058 -> 16057;
16058 -> 14665;
16059 -> 14665;
16060 -> 16058;
16060 -> 16059;
16061 -> 14665;
16062 -> 16051;
16062 -> 16048;
16063 -> 16048;
16064 -> 16048;
16065 -> 16048;
16066 -> 16064;
16066 -> 16065;
16066 -> 16048;
16067 -> 16066;
16067 -> 16048;
16068 -> 16067;
16069 -> 16064;
16069 -> 16068;
16070 -> 16068;
16071 -> 16069;
16071 -> 16048;
16071 -> 16070;
16072 -> 16070;
16073 -> 16071;
16073 -> 16072;
16074 -> 16073;
16074 -> 16070;
16075 -> 16070;
16076 -> 16070;
16077 -> 16074;
16077 -> 16076;
16078 -> 16077;
16078 -> 16068;
16079 -> 16078;
16079 -> 16051;
16079 -> 16062;
16079 -> 16048;
16080 -> 16051;
16080 -> 16062;
16080 -> 16078;
16080 -> 16048;
16081 -> 16048;
16082 -> 16080;
16082 -> 16081;
16082 -> 16048;
16083 -> 16052;
16083 -> 16081;
16083 -> 16048;
16084 -> 16082;
16084 -> 16083;
16084 -> 16048;
16085 -> 16048;
16086 -> 16080;
16086 -> 16085;
16086 -> 16048;
16087 -> 16048;
16087 -> 16078;
16087 -> 16051;
16088 -> 16048;
16089 -> 16064;
16089 -> 16088;
16089 -> 16048;
16090 -> 16089;
16091 -> 16064;
16091 -> 16090;
16092 -> 16091;
16092 -> 16074;
16092 -> 16090;
16093 -> 16090;
16094 -> 16092;
16094 -> 16093;
16095 -> 16094;
16095 -> 0;
16095 -> 16093;
16096 -> 0;
16096 -> 16095;
16097 -> 16096;
16097 -> 16089;
16098 -> 16097;
16098 -> 0;
16098 -> 16089;
16099 -> 16051;
16099 -> 16074;
16100 -> 16074;
16101 -> 16051;
16101 -> 16062;
16101 -> 16087;
16101 -> 16074;
16102 -> 16101;
16102 -> 16051;
16103 -> 16051;
16103 -> 16101;
16104 -> 16101;
16105 -> 16103;
16105 -> 16104;
16105 -> 16101;
16106 -> 16052;
16106 -> 16104;
16106 -> 16101;
16107 -> 16105;
16107 -> 16106;
16107 -> 16101;
16108 -> 16101;
16109 -> 16103;
16109 -> 16108;
16109 -> 16101;
16110 -> 16101;
16111 -> 16110;
16112 -> 16101;
16112 -> 16111;
16113 -> 16112;
16113 -> 16101;
16113 -> 16111;
16114 -> 16111;
16115 -> 16113;
16115 -> 16114;
16116 -> 16115;
16116 -> 0;
16116 -> 16114;
16117 -> 0;
16117 -> 16116;
16118 -> 16117;
16118 -> 16110;
16119 -> 16118;
16119 -> 0;
16119 -> 16110;
16120 -> 16101;
16121 -> 16101;
16121 -> 16120;
16122 -> 16120;
16122 -> 16101;
16123 -> 16101;
16124 -> 16101;
16125 -> 14665;
16125 -> 16124;
16126 -> 16124;
16127 -> 16125;
16127 -> 16126;
16128 -> 16126;
16129 -> 16127;
16129 -> 16101;
16129 -> 16128;
16130 -> 16129;
16130 -> 16101;
16130 -> 16128;
16131 -> 16130;
16131 -> 16124;
16132 -> 16124;
16133 -> 16131;
16133 -> 16132;
16134 -> 16133;
16134 -> 16124;
16135 -> 16101;
16136 -> 16101;
16137 -> 16136;
16138 -> 16136;
16138 -> 16137;
16139 -> 16137;
16139 -> 16136;
16140 -> 16136;
16140 -> 16101;
16141 -> 14665;
16141 -> 16101;
16142 -> 16101;
16143 -> 16141;
16143 -> 16142;
16144 -> 16140;
16144 -> 16142;
16145 -> 16144;
16145 -> 16101;
16145 -> 16142;
16146 -> 16101;
16147 -> 16101;
16148 -> 14664;
16148 -> 14663;
16149 -> 14666;
16149 -> 14663;
16150 -> 16101;
16150 -> 16148;
16150 -> 16149;
16150 -> 14667;
16150 -> 14663;
16151 -> 1;
16152 -> 1;
16153 -> 16151;
16153 -> 16152;
16154 -> 14661;
16154 -> 16152;
16155 -> 16152;
16156 -> 16155;
16156 -> 16152;
16157 -> 16152;
16158 -> 16157;
16159 -> 16154;
16159 -> 16150;
16159 -> 16158;
16159 -> 16157;
16160 -> 16154;
16160 -> 16150;
16160 -> 16157;
16161 -> 16153;
16161 -> 16152;
16162 -> 16155;
16162 -> 16152;
16163 -> 16160;
16163 -> 16161;
16163 -> 16162;
16163 -> 16150;
16163 -> 16156;
16163 -> 16152;
16164 -> 1;
16165 -> 16163;
16165 -> 16164;
16166 -> 16164;
16167 -> 16165;
16167 -> 16166;
16168 -> 16167;
16168 -> 16163;
16168 -> 16166;
16169 -> 13570;
16169 -> 16166;
16170 -> 16168;
16171 -> 16167;
16171 -> 16170;
16172 -> 16171;
16172 -> 16163;
16172 -> 16170;
16173 -> 16172;
16173 -> 16168;
16174 -> 16168;
16175 -> 16168;
16176 -> 16175;
16176 -> 16168;
16177 -> 16168;
16178 -> 16176;
16178 -> 16177;
16179 -> 16167;
16179 -> 16177;
16180 -> 16177;
16181 -> 16179;
16181 -> 16180;
16182 -> 16180;
16183 -> 16181;
16183 -> 16163;
16183 -> 16182;
16184 -> 16183;
16184 -> 16163;
16184 -> 15800;
16184 -> 16182;
16185 -> 16184;
16185 -> 15821;
16185 -> 16182;
16186 -> 16185;
16186 -> 16180;
16187 -> 16186;
16187 -> 16177;
16188 -> 16177;
16189 -> 16179;
16189 -> 16188;
16190 -> 16188;
16191 -> 16189;
16191 -> 16190;
16192 -> 16190;
16192 -> 16188;
16193 -> 16189;
16193 -> 16188;
16194 -> 16188;
16195 -> 16193;
16195 -> 16194;
16196 -> 16195;
16196 -> 16163;
16196 -> 16194;
16197 -> 16196;
16197 -> 16188;
16198 -> 16188;
16199 -> 16197;
16199 -> 16198;
16199 -> 16188;
16200 -> 16199;
16200 -> 16188;
16201 -> 16200;
16202 -> 16201;
16202 -> 16177;
16203 -> 16177;
16204 -> 16187;
16204 -> 0;
16204 -> 16177;
16205 -> 16204;
16206 -> 16204;
16207 -> 16205;
16207 -> 16206;
16208 -> 16179;
16208 -> 16206;
16209 -> 16207;
16209 -> 16206;
16210 -> 16206;
16211 -> 16209;
16211 -> 16210;
16212 -> 16208;
16212 -> 16210;
16213 -> 16212;
16213 -> 16163;
16213 -> 16210;
16214 -> 16210;
16215 -> 16213;
16216 -> 16212;
16216 -> 16163;
16216 -> 16213;
16217 -> 16211;
16217 -> 16213;
16218 -> 16215;
16218 -> 16213;
16219 -> 16213;
16220 -> 16217;
16220 -> 16219;
16221 -> 16218;
16221 -> 16219;
16222 -> 16212;
16222 -> 16219;
16223 -> 16219;
16224 -> 16222;
16224 -> 16223;
16225 -> 16224;
16225 -> 16219;
16226 -> 16219;
16227 -> 16219;
16228 -> 16220;
16228 -> 16227;
16228 -> 16219;
16229 -> 16220;
16229 -> 16219;
16230 -> 16219;
16231 -> 16222;
16231 -> 16230;
16232 -> 16231;
16232 -> 16230;
16233 -> 16232;
16233 -> 16219;
16234 -> 16229;
16234 -> 16233;
16234 -> 16163;
16234 -> 16219;
16235 -> 16219;
16236 -> 16219;
16237 -> 16219;
16238 -> 16219;
16239 -> 13496;
16240 -> 16239;
16240 -> 13493;
16240 -> 13494;
16240 -> 13495;
16241 -> 16240;
16242 -> 0;
16242 -> 16238;
16243 -> 16238;
16244 -> 16242;
16244 -> 16243;
16244 -> 16238;
16245 -> 16242;
16245 -> 16238;
16246 -> 16245;
16246 -> 16219;
16247 -> 16219;
16248 -> 16222;
16248 -> 16234;
16248 -> 16247;
16249 -> 16248;
16249 -> 16219;
16250 -> 16234;
16250 -> 16249;
16251 -> 16249;
16252 -> 16221;
16252 -> 16249;
16253 -> 16249;
16254 -> 16250;
16254 -> 16253;
16255 -> 16251;
16255 -> 16253;
16256 -> 16252;
16256 -> 16253;
16257 -> 16222;
16257 -> 16253;
16258 -> 16255;
16258 -> 16253;
16259 -> 16253;
16260 -> 16258;
16260 -> 16259;
16261 -> 16259;
16262 -> 16260;
16262 -> 16261;
16263 -> 16262;
16263 -> 16234;
16263 -> 0;
16263 -> 16261;
16264 -> 16261;
16265 -> 16263;
16265 -> 16259;
16266 -> 16265;
16267 -> 16260;
16267 -> 16266;
16268 -> 16267;
16268 -> 16234;
16268 -> 16266;
16269 -> 16268;
16269 -> 16265;
16270 -> 16265;
16271 -> 16265;
16272 -> 16270;
16272 -> 16271;
16273 -> 16269;
16273 -> 16271;
16274 -> 16273;
16274 -> 16234;
16274 -> 16271;
16275 -> 16274;
16275 -> 16234;
16275 -> 16265;
16276 -> 16253;
16277 -> 16275;
16277 -> 16276;
16277 -> 16253;
16278 -> 16253;
16279 -> 16253;
16280 -> 16253;
16281 -> 16257;
16281 -> 16280;
16282 -> 16280;
16283 -> 16281;
16283 -> 16282;
16284 -> 16282;
16284 -> 16280;
16285 -> 16281;
16285 -> 16280;
16286 -> 16280;
16287 -> 16285;
16287 -> 16286;
16288 -> 16287;
16288 -> 16234;
16288 -> 16286;
16289 -> 16288;
16289 -> 16280;
16290 -> 16280;
16291 -> 16289;
16291 -> 16290;
16291 -> 16280;
16292 -> 16291;
16292 -> 16280;
16293 -> 16292;
16294 -> 16293;
16294 -> 16253;
16295 -> 16275;
16295 -> 16253;
16296 -> 16253;
16297 -> 16295;
16297 -> 16296;
16298 -> 16294;
16298 -> 16296;
16299 -> 16296;
16300 -> 16297;
16300 -> 16299;
16301 -> 16299;
16302 -> 16299;
16303 -> 16300;
16303 -> 16234;
16303 -> 16299;
16304 -> 16299;
16305 -> 16303;
16305 -> 16304;
16305 -> 16299;
16306 -> 16299;
16307 -> 16300;
16307 -> 16306;
16307 -> 16299;
16308 -> 16299;
16309 -> 16300;
16309 -> 16308;
16309 -> 16299;
16310 -> 16300;
16310 -> 16296;
16311 -> 16296;
16312 -> 16296;
16313 -> 16310;
16313 -> 16312;
16314 -> 16311;
16314 -> 16312;
16315 -> 16298;
16315 -> 16312;
16316 -> 16314;
16316 -> 16312;
16317 -> 16313;
16317 -> 16312;
16318 -> 16312;
16319 -> 16315;
16319 -> 16234;
16319 -> 16312;
16320 -> 16312;
16321 -> 16317;
16321 -> 16320;
16322 -> 16318;
16322 -> 16320;
16323 -> 16319;
16323 -> 16320;
16324 -> 16315;
16324 -> 16320;
16325 -> 16323;
16325 -> 16320;
16326 -> 16322;
16326 -> 16320;
16327 -> 16324;
16327 -> 16234;
16327 -> 16326;
16328 -> 16324;
16328 -> 16234;
16328 -> 16327;
16328 -> 16320;
16329 -> 16325;
16329 -> 16328;
16329 -> 16234;
16329 -> 16300;
16329 -> 16327;
16329 -> 16320;
16330 -> 16321;
16330 -> 16320;
16331 -> 16320;
16332 -> 16330;
16332 -> 16331;
16333 -> 16324;
16333 -> 16331;
16334 -> 16332;
16334 -> 16331;
16335 -> 16331;
16336 -> 16334;
16336 -> 16335;
16337 -> 16333;
16337 -> 16335;
16338 -> 16335;
16339 -> 16336;
16339 -> 16338;
16339 -> 16335;
16340 -> 16335;
16341 -> 16337;
16341 -> 16329;
16341 -> 16340;
16342 -> 16341;
16342 -> 16335;
16343 -> 16336;
16343 -> 16335;
16344 -> 16342;
16344 -> 16329;
16344 -> 16343;
16344 -> 16335;
16345 -> 16331;
16346 -> 16333;
16346 -> 16344;
16346 -> 16345;
16347 -> 16346;
16347 -> 16331;
16348 -> 16329;
16348 -> 16320;
16349 -> 16320;
16350 -> 16348;
16350 -> 16349;
16350 -> 16320;
16351 -> 16350;
16352 -> 16351;
16352 -> 16347;
16353 -> 16352;
16353 -> 16350;
16354 -> 16329;
16354 -> 16350;
16355 -> 16353;
16355 -> 16350;
16356 -> 16350;
16357 -> 16320;
16358 -> 16355;
16358 -> 16347;
16358 -> 16320;
16359 -> 16320;
16360 -> 16358;
16360 -> 16359;
16360 -> 16320;
16361 -> 16321;
16361 -> 16320;
16362 -> 16322;
16362 -> 16320;
16363 -> 16355;
16363 -> 16347;
16363 -> 16320;
16364 -> 16320;
16365 -> 16361;
16365 -> 16364;
16366 -> 16362;
16366 -> 16364;
16367 -> 16363;
16367 -> 16364;
16368 -> 16324;
16368 -> 16364;
16369 -> 16368;
16369 -> 16364;
16370 -> 16365;
16370 -> 16364;
16371 -> 16366;
16371 -> 16364;
16372 -> 16364;
16373 -> 16364;
16374 -> 16369;
16374 -> 16373;
16375 -> 16370;
16375 -> 16373;
16376 -> 16371;
16376 -> 16373;
16377 -> 16372;
16377 -> 16373;
16378 -> 16377;
16378 -> 16373;
16379 -> 16377;
16379 -> 16373;
16380 -> 16377;
16380 -> 16373;
16381 -> 16377;
16381 -> 16373;
16382 -> 16377;
16382 -> 16373;
16383 -> 16377;
16383 -> 16373;
16384 -> 16374;
16384 -> 16377;
16384 -> 16373;
16385 -> 16375;
16385 -> 16377;
16385 -> 16373;
16386 -> 16376;
16386 -> 16377;
16386 -> 16373;
16387 -> 16377;
16387 -> 16373;
16388 -> 16373;
16389 -> 16387;
16389 -> 16388;
16389 -> 16378;
16389 -> 16384;
16389 -> 16385;
16389 -> 16381;
16389 -> 16386;
16389 -> 16383;
16389 -> 16355;
16389 -> 16373;
16390 -> 16389;
16390 -> 16377;
16390 -> 16373;
16391 -> 16373;
16392 -> 16391;
16392 -> 16377;
16392 -> 16373;
16393 -> 16374;
16393 -> 16373;
16394 -> 16373;
16395 -> 16373;
16396 -> 16393;
16396 -> 16395;
16397 -> 16394;
16397 -> 16395;
16399 -> 16398;
16401 -> 16400;
16403 -> 16402;
16406 -> 16405;
16407 -> 0;
16408 -> 0;
16409 -> 0;
16410 -> 16409;
16412 -> 16407;
16412 -> 16408;
16412 -> 16410;
16412 -> 16411;
16413 -> 16412;
16415 -> 16414;
16417 -> 16416;
16419 -> 16418;
16421 -> 16420;
16422 -> 16396;
16422 -> 16395;
16423 -> 16395;
16424 -> 16422;
16424 -> 16423;
16425 -> 16397;
16425 -> 16423;
16426 -> 16425;
16426 -> 16423;
16427 -> 16425;
16427 -> 16423;
16428 -> 16425;
16428 -> 16423;
16429 -> 16425;
16429 -> 16423;
16430 -> 16425;
16430 -> 16423;
16431 -> 16423;
16432 -> 16424;
16432 -> 16431;
16432 -> 16423;
16433 -> 16425;
16433 -> 16423;
16434 -> 16433;
16434 -> 16426;
16434 -> 16427;
16434 -> 16428;
16434 -> 16429;
16434 -> 16430;
16434 -> 16423;
16435 -> 16423;
16436 -> 16424;
16436 -> 16435;
16437 -> 16436;
16437 -> 16389;
16437 -> 16435;
16438 -> 16437;
16438 -> 16423;
16439 -> 16438;
16439 -> 16389;
16439 -> 16425;
16439 -> 16423;
16440 -> 16424;
16440 -> 16425;
16440 -> 16423;
16441 -> 16394;
16441 -> 16377;
16441 -> 16373;
16442 -> 16372;
16442 -> 16364;
16443 -> 16442;
16443 -> 16389;
16443 -> 16390;
16443 -> 16392;
16443 -> 16441;
16443 -> 16391;
16443 -> 16434;
16443 -> 16439;
16443 -> 16440;
16443 -> 16364;
16444 -> 16364;
16445 -> 16444;
16446 -> 16367;
16446 -> 16444;
16447 -> 16444;
16448 -> 16446;
16448 -> 16447;
16448 -> 16444;
16449 -> 16367;
16449 -> 16444;
16450 -> 16443;
16450 -> 16444;
16451 -> 16446;
16451 -> 16444;
16452 -> 16449;
16452 -> 16450;
16452 -> 16451;
16452 -> 16443;
16452 -> 16444;
16453 -> 16372;
16453 -> 16452;
16454 -> 16297;
16454 -> 16296;
16455 -> 16296;
16456 -> 16454;
16456 -> 16455;
16457 -> 16311;
16457 -> 16455;
16458 -> 16311;
16458 -> 16455;
16459 -> 16453;
16459 -> 16455;
16460 -> 16456;
16460 -> 16452;
16460 -> 16355;
16460 -> 16455;
16461 -> 16455;
16462 -> 16460;
16462 -> 16461;
16463 -> 16455;
16464 -> 16459;
16464 -> 16463;
16465 -> 16464;
16465 -> 16462;
16465 -> 16463;
16466 -> 16463;
16467 -> 16465;
16467 -> 16466;
16468 -> 16467;
16468 -> 16455;
16469 -> 16455;
16470 -> 16456;
16470 -> 16467;
16470 -> 16469;
16470 -> 16455;
16471 -> 16456;
16471 -> 16467;
16471 -> 16468;
16472 -> 16471;
16472 -> 16455;
16473 -> 16462;
16473 -> 16455;
16474 -> 16457;
16474 -> 16455;
16475 -> 16458;
16475 -> 16455;
16476 -> 16455;
16477 -> 16472;
16477 -> 16476;
16478 -> 16473;
16478 -> 16476;
16479 -> 16474;
16479 -> 16476;
16480 -> 16475;
16480 -> 16476;
16481 -> 16459;
16481 -> 16476;
16482 -> 16476;
16483 -> 16477;
16483 -> 16482;
16483 -> 16476;
16484 -> 16480;
16484 -> 16476;
16485 -> 16481;
16485 -> 16467;
16485 -> 16476;
16486 -> 16476;
16487 -> 16485;
16487 -> 16486;
16488 -> 16485;
16488 -> 16486;
16489 -> 16486;
16490 -> 16488;
16490 -> 16489;
16491 -> 16488;
16491 -> 16486;
16492 -> 16488;
16492 -> 16486;
16493 -> 16488;
16493 -> 16486;
16494 -> 16488;
16494 -> 16486;
16495 -> 16487;
16495 -> 16488;
16495 -> 16486;
16496 -> 16485;
16496 -> 16491;
16496 -> 16492;
16496 -> 16493;
16496 -> 16495;
16496 -> 16476;
16497 -> 16478;
16497 -> 16476;
16498 -> 16479;
16498 -> 16476;
16499 -> 16480;
16499 -> 16476;
16500 -> 16476;
16501 -> 16497;
16501 -> 16500;
16502 -> 16498;
16502 -> 16500;
16503 -> 16499;
16503 -> 16500;
16504 -> 16496;
16504 -> 16500;
16505 -> 16500;
16506 -> 16500;
16507 -> 16502;
16507 -> 16506;
16508 -> 16505;
16508 -> 16506;
16509 -> 16508;
16509 -> 16506;
16510 -> 16507;
16510 -> 16509;
16511 -> 16502;
16511 -> 16505;
16511 -> 16500;
16512 -> 16503;
16512 -> 16505;
16512 -> 16500;
16513 -> 16511;
16513 -> 16512;
16513 -> 16500;
16514 -> 16501;
16514 -> 16504;
16514 -> 16500;
16515 -> 16502;
16515 -> 16504;
16515 -> 16500;
16516 -> 16503;
16516 -> 16504;
16516 -> 16500;
16517 -> 16476;
16518 -> 16477;
16518 -> 16476;
16519 -> 16476;
16520 -> 16518;
16520 -> 16519;
16521 -> 16496;
16521 -> 16519;
16522 -> 16520;
16522 -> 16519;
16523 -> 16519;
16524 -> 16522;
16524 -> 16523;
16525 -> 16521;
16525 -> 16523;
16526 -> 16525;
16526 -> 16523;
16527 -> 16526;
16527 -> 16524;
16527 -> 16496;
16527 -> 16514;
16527 -> 16515;
16527 -> 16516;
16527 -> 16523;
16528 -> 16523;
16529 -> 16527;
16529 -> 16528;
16530 -> 16527;
16530 -> 16528;
16531 -> 16529;
16531 -> 16528;
16532 -> 16528;
16533 -> 16531;
16533 -> 16532;
16534 -> 16530;
16534 -> 16532;
16535 -> 16534;
16535 -> 16527;
16535 -> 16532;
16536 -> 16533;
16536 -> 16532;
16537 -> 16532;
16538 -> 16535;
16538 -> 16537;
16539 -> 16536;
16539 -> 16537;
16540 -> 16537;
16541 -> 16539;
16541 -> 16540;
16541 -> 16537;
16542 -> 16538;
16542 -> 16537;
16543 -> 16539;
16543 -> 16537;
16544 -> 16539;
16544 -> 16527;
16544 -> 16537;
16545 -> 16537;
16546 -> 16544;
16546 -> 16545;
16547 -> 16545;
16547 -> 16537;
16548 -> 16544;
16548 -> 16547;
16548 -> 16537;
16549 -> 16537;
16550 -> 16542;
16550 -> 16549;
16551 -> 16543;
16551 -> 16549;
16552 -> 16548;
16552 -> 16549;
16553 -> 16550;
16553 -> 16549;
16554 -> 16552;
16554 -> 16549;
16555 -> 16549;
16556 -> 16553;
16556 -> 16555;
16557 -> 16554;
16557 -> 16555;
16558 -> 16557;
16558 -> 16555;
16559 -> 16555;
16560 -> 16558;
16560 -> 16559;
16561 -> 16560;
16561 -> 16548;
16561 -> 16559;
16562 -> 16561;
16562 -> 16559;
16563 -> 16559;
16564 -> 16562;
16564 -> 16563;
16565 -> 16563;
16566 -> 0;
16566 -> 16563;
16567 -> 16564;
16567 -> 16565;
16567 -> 16563;
16568 -> 16563;
16569 -> 16566;
16569 -> 16568;
16569 -> 16563;
16570 -> 16569;
16570 -> 16565;
16570 -> 16563;
16571 -> 16567;
16571 -> 16570;
16571 -> 16563;
16572 -> 16557;
16572 -> 16548;
16572 -> 16555;
16573 -> 16555;
16574 -> 16572;
16574 -> 16573;
16575 -> 16556;
16575 -> 16557;
16575 -> 16574;
16575 -> 16555;
16576 -> 16571;
16576 -> 16575;
16576 -> 16555;
16577 -> 16551;
16577 -> 16574;
16577 -> 16549;
16578 -> 16549;
16579 -> 16577;
16579 -> 16578;
16580 -> 16550;
16580 -> 16551;
16580 -> 16579;
16580 -> 16549;
16581 -> 16576;
16581 -> 16580;
16581 -> 16549;
16582 -> 0;
16582 -> 16532;
16583 -> 16533;
16583 -> 16579;
16583 -> 16532;
16584 -> 16532;
16585 -> 16583;
16585 -> 16584;
16586 -> 16584;
16586 -> 16532;
16587 -> 16583;
16587 -> 16586;
16587 -> 16532;
16588 -> 16532;
16589 -> 16532;
16590 -> 16587;
16590 -> 16589;
16591 -> 16589;
16591 -> 16532;
16592 -> 16587;
16592 -> 16591;
16592 -> 16532;
16593 -> 16534;
16593 -> 16592;
16593 -> 16532;
16594 -> 16532;
16595 -> 16592;
16595 -> 16594;
16596 -> 16594;
16596 -> 16532;
16597 -> 16592;
16597 -> 16596;
16597 -> 16532;
16598 -> 16532;
16599 -> 16597;
16599 -> 16598;
16600 -> 16598;
16600 -> 16532;
16601 -> 16597;
16601 -> 16600;
16601 -> 16532;
16602 -> 16532;
16603 -> 16593;
16603 -> 16602;
16604 -> 16597;
16604 -> 16602;
16605 -> 16601;
16605 -> 16602;
16606 -> 16604;
16606 -> 16597;
16606 -> 16601;
16606 -> 16602;
16607 -> 16602;
16608 -> 16606;
16608 -> 16607;
16609 -> 16608;
16609 -> 16607;
16610 -> 16607;
16610 -> 16602;
16611 -> 16606;
16611 -> 16610;
16611 -> 16602;
16612 -> 16603;
16612 -> 16604;
16612 -> 16611;
16612 -> 16602;
16613 -> 16534;
16613 -> 16611;
16613 -> 16532;
16614 -> 16532;
16615 -> 16613;
16615 -> 16614;
16616 -> 16611;
16616 -> 16614;
16617 -> 16616;
16617 -> 16611;
16617 -> 16614;
16618 -> 16614;
16619 -> 16617;
16619 -> 16618;
16619 -> 16614;
16620 -> 16619;
16621 -> 16612;
16621 -> 16620;
16621 -> 16532;
16622 -> 16534;
16622 -> 16611;
16622 -> 16621;
16623 -> 16533;
16623 -> 16621;
16624 -> 16621;
16625 -> 16622;
16625 -> 16624;
16626 -> 16623;
16626 -> 16624;
16627 -> 16626;
16627 -> 16611;
16627 -> 16624;
16628 -> 16624;
16629 -> 16627;
16629 -> 16628;
16629 -> 16624;
16630 -> 16534;
16630 -> 16611;
16630 -> 16629;
16631 -> 16533;
16631 -> 16611;
16631 -> 16629;
16632 -> 16629;
16633 -> 16631;
16633 -> 16632;
16634 -> 16632;
16634 -> 16629;
16635 -> 16629;
16636 -> 16634;
16636 -> 16635;
16637 -> 16635;
16637 -> 16629;
16638 -> 16634;
16638 -> 16637;
16638 -> 16629;
16639 -> 16629;
16640 -> 16630;
16640 -> 16639;
16641 -> 16634;
16641 -> 16639;
16642 -> 16638;
16642 -> 16639;
16643 -> 16641;
16643 -> 16634;
16643 -> 16638;
16643 -> 16639;
16644 -> 16639;
16645 -> 16640;
16645 -> 16644;
16646 -> 16642;
16646 -> 16644;
16647 -> 16644;
16648 -> 16646;
16648 -> 16647;
16649 -> 16648;
16649 -> 16638;
16649 -> 16647;
16650 -> 16649;
16650 -> 16647;
16651 -> 16647;
16652 -> 16650;
16652 -> 16651;
16653 -> 16651;
16654 -> 0;
16654 -> 16651;
16655 -> 16652;
16655 -> 16653;
16655 -> 16651;
16656 -> 16651;
16657 -> 16654;
16657 -> 16656;
16657 -> 16651;
16658 -> 16657;
16658 -> 16653;
16658 -> 16651;
16659 -> 16655;
16659 -> 16658;
16659 -> 16651;
16660 -> 16646;
16660 -> 16644;
16661 -> 16645;
16661 -> 16646;
16661 -> 16644;
16662 -> 16659;
16662 -> 16661;
16662 -> 16644;
16663 -> 0;
16663 -> 16662;
16664 -> 16533;
16664 -> 16532;
16665 -> 16663;
16665 -> 16532;
16666 -> 16532;
16667 -> 16664;
16667 -> 16666;
16668 -> 16665;
16668 -> 16666;
16669 -> 16534;
16669 -> 16666;
16670 -> 16667;
16670 -> 16666;
16671 -> 16668;
16671 -> 16666;
16672 -> 16666;
16673 -> 16670;
16673 -> 16672;
16674 -> 16671;
16674 -> 16672;
16675 -> 16674;
16675 -> 16672;
16676 -> 16672;
16677 -> 16673;
16677 -> 16672;
16678 -> 16674;
16678 -> 16672;
16679 -> 16672;
16680 -> 16672;
16681 -> 16677;
16681 -> 16680;
16682 -> 16678;
16682 -> 16680;
16683 -> 16679;
16683 -> 16680;
16684 -> 16681;
16684 -> 16683;
16684 -> 16680;
16685 -> 16682;
16685 -> 16683;
16685 -> 16680;
16686 -> 16679;
16686 -> 16666;
16687 -> 16666;
16688 -> 16666;
16689 -> 16669;
16689 -> 16688;
16690 -> 16689;
16690 -> 16646;
16690 -> 16688;
16691 -> 16690;
16691 -> 16666;
16692 -> 16686;
16692 -> 16666;
16693 -> 16687;
16693 -> 16666;
16694 -> 16692;
16694 -> 16693;
16694 -> 16691;
16694 -> 16684;
16694 -> 16685;
16694 -> 16646;
16694 -> 16666;
16695 -> 16666;
16696 -> 16694;
16696 -> 16695;
16697 -> 16696;
16697 -> 16694;
16697 -> 16695;
16698 -> 16697;
16699 -> 16698;
16699 -> 16697;
16700 -> 16697;
16701 -> 16699;
16701 -> 16700;
16702 -> 16701;
16702 -> 16700;
16703 -> 16701;
16703 -> 16700;
16704 -> 16703;
16704 -> 16701;
16704 -> 16700;
16705 -> 16702;
16705 -> 16700;
16706 -> 16700;
16707 -> 16704;
16707 -> 16706;
16708 -> 16705;
16708 -> 16706;
16709 -> 16706;
16710 -> 16708;
16710 -> 16709;
16710 -> 16706;
16711 -> 16707;
16711 -> 16706;
16712 -> 16708;
16712 -> 16701;
16712 -> 16706;
16713 -> 16706;
16714 -> 16712;
16714 -> 16713;
16715 -> 16712;
16715 -> 16713;
16716 -> 16713;
16716 -> 16706;
16717 -> 16706;
16718 -> 16714;
16718 -> 16717;
16719 -> 16714;
16719 -> 16717;
16720 -> 16717;
16720 -> 16706;
16721 -> 16706;
16722 -> 16711;
16722 -> 16721;
16723 -> 16714;
16723 -> 16721;
16724 -> 16718;
16724 -> 16721;
16725 -> 16723;
16725 -> 16714;
16725 -> 16718;
16725 -> 16721;
16726 -> 16722;
16726 -> 16723;
16726 -> 16725;
16726 -> 16721;
16727 -> 16722;
16727 -> 16724;
16727 -> 16721;
16728 -> 16703;
16728 -> 16724;
16728 -> 16700;
16729 -> 16702;
16729 -> 16724;
16729 -> 16700;
16730 -> 16700;
16731 -> 16729;
16731 -> 16730;
16732 -> 16729;
16732 -> 16730;
16733 -> 16730;
16733 -> 16700;
16734 -> 16700;
16735 -> 16731;
16735 -> 16734;
16736 -> 16731;
16736 -> 16734;
16737 -> 16734;
16737 -> 16700;
16738 -> 16700;
16739 -> 16728;
16739 -> 16738;
16740 -> 16731;
16740 -> 16738;
16741 -> 16735;
16741 -> 16738;
16742 -> 16740;
16742 -> 16731;
16742 -> 16735;
16742 -> 16738;
16743 -> 16739;
16743 -> 16740;
16743 -> 16742;
16743 -> 16738;
16744 -> 16739;
16744 -> 16741;
16744 -> 16738;
16745 -> 16702;
16745 -> 16700;
16746 -> 16700;
16747 -> 16745;
16747 -> 16746;
16748 -> 16703;
16748 -> 16746;
16749 -> 16747;
16749 -> 16741;
16749 -> 16746;
16750 -> 16746;
16751 -> 16749;
16751 -> 16750;
16752 -> 16749;
16752 -> 16750;
16753 -> 16746;
16754 -> 16753;
16754 -> 16746;
16755 -> 16746;
16756 -> 16747;
16756 -> 16755;
16757 -> 16756;
16757 -> 16751;
16757 -> 16755;
16758 -> 16757;
16758 -> 16746;
16759 -> 16748;
16759 -> 16751;
16759 -> 16746;
16760 -> 16758;
16760 -> 16759;
16760 -> 16746;
16761 -> 16748;
16761 -> 16751;
16761 -> 16760;
16762 -> 16748;
16762 -> 16751;
16762 -> 16761;
16763 -> 16761;
16764 -> 16761;
16765 -> 16762;
16765 -> 16764;
16766 -> 16763;
16766 -> 16764;
16767 -> 16747;
16767 -> 16764;
16768 -> 16765;
16768 -> 16764;
16769 -> 16766;
16769 -> 16764;
16770 -> 16768;
16770 -> 16769;
16770 -> 16767;
16770 -> 16751;
16770 -> 16764;
16771 -> 16764;
16772 -> 16770;
16772 -> 16771;
16773 -> 16770;
16773 -> 16746;
16774 -> 16746;
16775 -> 16773;
16775 -> 16774;
16775 -> 16746;
16776 -> 16773;
16776 -> 16747;
16776 -> 16746;
16777 -> 16773;
16777 -> 16775;
16778 -> 0;
16778 -> 16775;
16779 -> 16775;
16780 -> 16777;
16780 -> 16779;
16781 -> 16778;
16781 -> 16779;
16782 -> 16780;
16782 -> 16770;
16782 -> 16781;
16782 -> 16779;
16783 -> 16773;
16783 -> 16770;
16783 -> 16775;
16784 -> 16783;
16785 -> 0;
16785 -> 16783;
16786 -> 16783;
16787 -> 16784;
16787 -> 16786;
16788 -> 16785;
16788 -> 16786;
16789 -> 16787;
16789 -> 16770;
16789 -> 16788;
16789 -> 16786;
16790 -> 16746;
16791 -> 16790;
16791 -> 16700;
16792 -> 16702;
16792 -> 16700;
16793 -> 16703;
16793 -> 16770;
16793 -> 16700;
16794 -> 16743;
16794 -> 16700;
16795 -> 16791;
16795 -> 16700;
16796 -> 16700;
16797 -> 16792;
16797 -> 16796;
16798 -> 16793;
16798 -> 16796;
16799 -> 16794;
16799 -> 16796;
16800 -> 16795;
16800 -> 16796;
16801 -> 16703;
16801 -> 16796;
16802 -> 16800;
16802 -> 16796;
16803 -> 16796;
16804 -> 16800;
16804 -> 16796;
16805 -> 16799;
16805 -> 16804;
16806 -> 0;
16806 -> 16805;
16807 -> 16797;
16807 -> 16796;
16808 -> 16806;
16808 -> 16796;
16809 -> 16796;
16810 -> 16807;
16810 -> 16809;
16811 -> 16808;
16811 -> 16809;
16812 -> 16811;
16812 -> 16809;
16813 -> 16809;
16814 -> 16809;
16814 -> 16796;
16815 -> 16796;
16816 -> 16796;
16817 -> 16801;
16817 -> 16816;
16818 -> 16817;
16818 -> 16770;
16818 -> 16816;
16819 -> 16818;
16819 -> 16796;
16820 -> 16814;
16820 -> 16796;
16821 -> 16815;
16821 -> 16796;
16822 -> 16820;
16822 -> 16821;
16822 -> 16819;
16822 -> 16810;
16822 -> 16811;
16822 -> 16770;
16822 -> 16796;
16823 -> 16796;
16824 -> 16822;
16825 -> 16822;
16826 -> 16825;
16826 -> 16822;
16827 -> 16822;
16828 -> 16801;
16828 -> 16827;
16829 -> 16827;
16830 -> 16828;
16830 -> 16822;
16830 -> 16829;
16831 -> 16830;
16831 -> 16827;
16832 -> 16831;
16832 -> 16822;
16833 -> 16832;
16834 -> 16833;
16834 -> 16832;
16835 -> 16798;
16835 -> 16832;
16836 -> 16832;
16837 -> 16832;
16838 -> 16834;
16838 -> 16837;
16839 -> 16835;
16839 -> 16837;
16840 -> 16836;
16840 -> 16837;
16841 -> 16836;
16841 -> 16837;
16842 -> 16837;
16843 -> 16838;
16843 -> 16842;
16843 -> 16837;
16844 -> 16841;
16844 -> 16837;
16845 -> 16837;
16846 -> 16837;
16847 -> 16837;
16848 -> 16837;
16849 -> 16840;
16849 -> 16848;
16850 -> 16847;
16850 -> 16848;
16851 -> 16850;
16851 -> 16848;
16852 -> 16849;
16852 -> 16851;
16853 -> 16840;
16853 -> 16847;
16853 -> 16837;
16854 -> 16841;
16854 -> 16847;
16854 -> 16837;
16855 -> 16837;
16855 -> 16838;
16855 -> 16839;
16855 -> 16840;
16855 -> 16841;
16856 -> 16855;
16856 -> 16837;
16857 -> 16855;
16857 -> 16837;
16858 -> 16856;
16858 -> 16837;
16859 -> 16837;
16860 -> 16858;
16860 -> 16859;
16861 -> 16857;
16861 -> 16859;
16862 -> 16860;
16862 -> 16859;
16863 -> 16859;
16864 -> 16863;
16864 -> 16859;
16865 -> 16861;
16865 -> 16860;
16866 -> 16865;
16867 -> 16865;
16867 -> 16859;
16868 -> 16859;
16869 -> 16867;
16869 -> 16868;
16869 -> 16859;
16870 -> 16867;
16870 -> 16860;
16870 -> 16859;
16871 -> 16867;
16871 -> 16869;
16872 -> 0;
16872 -> 16869;
16873 -> 16869;
16874 -> 16871;
16874 -> 16873;
16875 -> 16872;
16875 -> 16873;
16876 -> 16874;
16876 -> 16865;
16876 -> 16875;
16876 -> 16873;
16877 -> 16867;
16877 -> 16865;
16877 -> 16869;
16878 -> 16877;
16879 -> 0;
16879 -> 16877;
16880 -> 16877;
16881 -> 16878;
16881 -> 16880;
16882 -> 16879;
16882 -> 16880;
16883 -> 16881;
16883 -> 16865;
16883 -> 16882;
16883 -> 16880;
16884 -> 16859;
16884 -> 16837;
16885 -> 16837;
16886 -> 16857;
16886 -> 16885;
16887 -> 16886;
16887 -> 16865;
16887 -> 16885;
16888 -> 16837;
16889 -> 16858;
16889 -> 16888;
16890 -> 16884;
16890 -> 16888;
16891 -> 16887;
16891 -> 16888;
16892 -> 16857;
16892 -> 16888;
16893 -> 16888;
16894 -> 16892;
16894 -> 16893;
16895 -> 16894;
16895 -> 16887;
16895 -> 16893;
16896 -> 16895;
16896 -> 16888;
16897 -> 16888;
16898 -> 16896;
16898 -> 16897;
16899 -> 16889;
16899 -> 16896;
16899 -> 16888;
16900 -> 16890;
16900 -> 16888;
16901 -> 16891;
16901 -> 16900;
16902 -> 0;
16902 -> 16901;
16903 -> 16889;
16903 -> 16888;
16904 -> 16902;
16904 -> 16888;
16905 -> 16888;
16906 -> 16903;
16906 -> 16905;
16907 -> 16904;
16907 -> 16905;
16908 -> 16907;
16908 -> 16905;
16909 -> 16905;
16910 -> 16905;
16910 -> 16888;
16911 -> 16888;
16912 -> 16888;
16913 -> 16892;
16913 -> 16912;
16914 -> 16913;
16914 -> 16896;
16914 -> 16912;
16915 -> 16914;
16915 -> 16888;
16916 -> 16910;
16916 -> 16888;
16917 -> 16911;
16917 -> 16888;
16918 -> 16916;
16918 -> 16917;
16918 -> 16915;
16918 -> 16906;
16918 -> 16907;
16918 -> 16896;
16918 -> 16888;
16919 -> 16888;
16920 -> 16918;
16921 -> 16892;
16921 -> 16920;
16922 -> 16921;
16922 -> 16918;
16922 -> 16920;
16923 -> 16922;
16923 -> 16918;
16924 -> 16891;
16924 -> 16918;
16925 -> 16924;
16926 -> 16892;
16926 -> 16925;
16927 -> 16926;
16927 -> 16918;
16927 -> 16925;
16928 -> 16927;
16928 -> 16924;
16929 -> 16924;
16930 -> 16928;
16930 -> 16929;
16931 -> 16923;
16931 -> 16924;
16932 -> 16889;
16932 -> 16924;
16933 -> 16890;
16933 -> 16924;
16934 -> 16924;
16935 -> 16924;
16936 -> 16930;
16936 -> 16935;
16937 -> 16931;
16937 -> 16935;
16938 -> 16932;
16938 -> 16935;
16939 -> 16933;
16939 -> 16935;
16940 -> 16934;
16940 -> 16935;
16941 -> 16937;
16941 -> 16935;
16942 -> 16935;
16943 -> 16941;
16943 -> 16942;
16944 -> 16940;
16944 -> 16942;
16945 -> 16942;
16946 -> 16942;
16947 -> 16943;
16947 -> 16946;
16947 -> 16942;
16948 -> 16943;
16948 -> 16944;
16948 -> 16942;
16949 -> 16943;
16949 -> 16918;
16949 -> 16944;
16949 -> 16942;
16950 -> 16943;
16950 -> 16918;
16950 -> 16944;
16950 -> 16942;
16951 -> 16945;
16951 -> 16944;
16951 -> 16942;
16952 -> 16940;
16952 -> 16935;
16953 -> 16940;
16953 -> 16935;
16954 -> 16940;
16954 -> 16935;
16955 -> 16940;
16955 -> 16935;
16956 -> 16940;
16956 -> 16935;
16957 -> 16935;
16958 -> 16936;
16958 -> 16957;
16958 -> 16935;
16959 -> 16935;
16960 -> 16938;
16960 -> 16959;
16960 -> 16935;
16961 -> 16936;
16961 -> 16940;
16961 -> 16935;
16962 -> 16938;
16962 -> 16940;
16962 -> 16939;
16962 -> 16935;
16963 -> 16962;
16963 -> 16940;
16963 -> 16935;
16964 -> 16939;
16964 -> 16935;
16965 -> 16964;
16966 -> 16938;
16966 -> 16965;
16967 -> 16966;
16967 -> 16964;
16968 -> 16938;
16968 -> 16967;
16969 -> 16968;
16969 -> 16918;
16969 -> 16940;
16969 -> 16967;
16970 -> 16924;
16971 -> 16892;
16971 -> 16970;
16972 -> 16971;
16972 -> 16918;
16972 -> 16970;
16973 -> 16972;
16973 -> 16924;
16974 -> 16889;
16974 -> 16924;
16975 -> 16924;
16976 -> 16924;
16977 -> 16973;
16977 -> 16976;
16978 -> 16974;
16978 -> 16976;
16979 -> 16975;
16979 -> 16976;
16980 -> 16977;
16980 -> 16976;
16981 -> 16976;
16982 -> 16980;
16982 -> 16981;
16983 -> 16981;
16984 -> 16982;
16984 -> 16983;
16985 -> 16983;
16986 -> 16984;
16986 -> 16985;
16987 -> 16986;
16987 -> 16985;
16988 -> 16986;
16988 -> 16983;
16989 -> 16983;
16990 -> 16988;
16990 -> 16989;
16991 -> 16983;
16992 -> 16990;
16992 -> 16981;
16993 -> 16981;
16994 -> 16992;
16994 -> 16993;
16995 -> 0;
16995 -> 16981;
16996 -> 16981;
16997 -> 16995;
16997 -> 16996;
16998 -> 16994;
16998 -> 16996;
16999 -> 16996;
17000 -> 16999;
17000 -> 16996;
17001 -> 16996;
17002 -> 16998;
17002 -> 17001;
17003 -> 17001;
17004 -> 17002;
17004 -> 16990;
17004 -> 17003;
17004 -> 17001;
17005 -> 17002;
17005 -> 16990;
17005 -> 17004;
17006 -> 17004;
17007 -> 17006;
17007 -> 17004;
17008 -> 17004;
17009 -> 17007;
17009 -> 17008;
17010 -> 0;
17010 -> 17008;
17011 -> 17009;
17011 -> 17008;
17012 -> 17011;
17012 -> 16990;
17013 -> 17011;
17014 -> 17011;
17015 -> 17012;
17015 -> 17011;
17016 -> 17015;
17017 -> 17015;
17017 -> 17016;
17018 -> 17016;
17018 -> 17015;
17019 -> 17018;
17020 -> 17015;
17020 -> 17019;
17021 -> 17019;
17021 -> 17018;
17022 -> 17018;
17023 -> 17013;
17023 -> 17018;
17024 -> 17013;
17024 -> 17011;
17025 -> 17010;
17025 -> 17008;
17026 -> 17025;
17026 -> 17004;
17027 -> 17004;
17028 -> 17002;
17028 -> 17026;
17028 -> 17001;
17029 -> 17028;
17029 -> 16996;
17030 -> 16997;
17030 -> 16996;
17031 -> 16999;
17031 -> 16996;
17032 -> 17029;
17032 -> 17030;
17032 -> 17031;
17032 -> 17026;
17032 -> 17000;
17032 -> 16996;
17033 -> 17032;
17033 -> 16996;
17034 -> 17033;
17034 -> 16976;
17035 -> 17034;
17036 -> 16918;
17037 -> 17036;
17037 -> 17032;
17038 -> 17037;
17038 -> 16918;
17039 -> 16910;
17039 -> 16918;
17040 -> 16934;
17040 -> 16918;
17041 -> 17039;
17041 -> 17040;
17041 -> 17038;
17041 -> 16906;
17041 -> 16907;
17041 -> 16950;
17041 -> 16949;
17041 -> 16948;
17041 -> 16951;
17041 -> 16944;
17041 -> 16961;
17041 -> 16963;
17041 -> 16954;
17041 -> 16955;
17041 -> 16956;
17041 -> 16969;
17041 -> 17032;
17041 -> 16962;
17041 -> 16918;
17042 -> 16918;
17043 -> 16934;
17043 -> 16888;
17044 -> 16855;
17044 -> 17043;
17044 -> 17041;
17044 -> 16837;
17045 -> 16837;
17046 -> 16837;
17046 -> 17044;
17046 -> 17045;
17047 -> 17044;
17047 -> 16837;
17048 -> 16799;
17048 -> 16822;
17049 -> 16797;
17049 -> 17048;
17050 -> 16797;
17050 -> 17046;
17050 -> 17048;
17051 -> 17047;
17051 -> 17048;
17052 -> 16800;
17052 -> 17048;
17053 -> 17048;
17054 -> 17049;
17054 -> 17053;
17055 -> 17050;
17055 -> 17053;
17056 -> 17051;
17056 -> 17053;
17057 -> 17052;
17057 -> 17053;
17058 -> 16801;
17058 -> 17053;
17059 -> 17053;
17060 -> 17055;
17060 -> 17053;
17061 -> 17053;
17062 -> 17055;
17062 -> 17061;
17062 -> 17053;
17063 -> 17053;
17064 -> 17056;
17064 -> 17053;
17065 -> 17064;
17066 -> 17064;
17066 -> 17065;
17067 -> 17066;
17067 -> 17046;
17067 -> 17065;
17068 -> 17067;
17068 -> 17064;
17069 -> 17055;
17069 -> 17053;
17070 -> 17053;
17071 -> 17069;
17071 -> 17070;
17072 -> 17068;
17072 -> 17070;
17073 -> 17070;
17074 -> 17071;
17074 -> 17073;
17075 -> 17074;
17075 -> 17070;
17076 -> 17071;
17076 -> 17046;
17076 -> 17075;
17077 -> 17075;
17078 -> 17076;
17078 -> 17077;
17079 -> 17077;
17079 -> 17075;
17080 -> 17076;
17080 -> 17077;
17081 -> 17076;
17081 -> 17077;
17082 -> 17076;
17082 -> 17077;
17083 -> 17081;
17083 -> 17077;
17084 -> 17077;
17085 -> 17083;
17085 -> 17084;
17086 -> 17082;
17086 -> 17084;
17087 -> 17086;
17087 -> 17080;
17087 -> 17085;
17087 -> 17084;
17088 -> 17087;
17089 -> 17087;
17089 -> 17088;
17090 -> 17088;
17090 -> 17087;
17091 -> 17087;
17091 -> 17090;
17092 -> 17072;
17092 -> 17091;
17092 -> 17075;
17093 -> 17053;
17094 -> 17092;
17094 -> 17093;
17094 -> 17053;
17095 -> 17092;
17095 -> 17053;
17096 -> 17056;
17096 -> 17053;
17097 -> 17054;
17097 -> 17053;
17098 -> 17057;
17098 -> 17053;
17099 -> 17053;
17100 -> 17053;
17101 -> 17095;
17101 -> 17100;
17102 -> 17096;
17102 -> 17100;
17103 -> 17097;
17103 -> 17100;
17104 -> 17098;
17104 -> 17100;
17105 -> 17099;
17105 -> 17100;
17106 -> 17100;
17107 -> 17105;
17107 -> 17106;
17108 -> 17106;
17109 -> 17106;
17110 -> 17102;
17110 -> 17109;
17110 -> 17106;
17111 -> 17102;
17111 -> 17092;
17111 -> 17107;
17111 -> 17106;
17112 -> 17102;
17112 -> 17092;
17112 -> 17107;
17112 -> 17106;
17113 -> 17108;
17113 -> 17107;
17113 -> 17106;
17114 -> 17105;
17114 -> 17100;
17115 -> 17105;
17115 -> 17100;
17116 -> 17105;
17116 -> 17100;
17117 -> 17105;
17117 -> 17100;
17118 -> 17105;
17118 -> 17100;
17119 -> 17100;
17120 -> 17101;
17120 -> 17119;
17120 -> 17100;
17121 -> 17100;
17122 -> 17103;
17122 -> 17121;
17122 -> 17100;
17123 -> 17103;
17123 -> 17105;
17123 -> 17104;
17123 -> 17100;
17124 -> 17123;
17124 -> 17105;
17124 -> 17100;
17125 -> 17104;
17125 -> 17100;
17126 -> 17125;
17127 -> 17103;
17127 -> 17126;
17128 -> 17127;
17128 -> 17092;
17128 -> 17126;
17129 -> 17128;
17130 -> 17129;
17130 -> 17128;
17131 -> 17103;
17131 -> 17130;
17132 -> 17131;
17132 -> 17092;
17132 -> 17105;
17132 -> 17130;
17133 -> 17099;
17133 -> 17048;
17134 -> 16822;
17135 -> 17134;
17135 -> 17092;
17136 -> 17135;
17136 -> 16822;
17137 -> 16814;
17137 -> 16822;
17138 -> 17133;
17138 -> 16822;
17139 -> 17137;
17139 -> 17138;
17139 -> 17136;
17139 -> 16810;
17139 -> 16811;
17139 -> 17112;
17139 -> 17111;
17139 -> 17102;
17139 -> 17113;
17139 -> 17107;
17139 -> 17101;
17139 -> 17124;
17139 -> 17116;
17139 -> 17117;
17139 -> 17118;
17139 -> 17132;
17139 -> 17092;
17139 -> 17123;
17139 -> 16822;
17140 -> 16822;
17141 -> 17133;
17141 -> 16796;
17142 -> 16701;
17142 -> 17141;
17142 -> 17139;
17142 -> 16700;
17143 -> 16668;
17143 -> 16902;
17143 -> 16697;
17144 -> 17143;
17145 -> 17142;
17145 -> 17144;
17146 -> 17145;
17146 -> 17142;
17146 -> 17144;
17147 -> 17144;
17148 -> 17146;
17148 -> 17147;
17148 -> 17144;
17149 -> 17148;
17149 -> 17144;
17150 -> 17145;
17150 -> 17142;
17150 -> 17149;
17151 -> 17150;
17151 -> 17143;
17152 -> 16667;
17152 -> 17143;
17153 -> 17143;
17154 -> 17152;
17154 -> 17153;
17155 -> 17151;
17155 -> 17153;
17156 -> 17154;
17156 -> 17142;
17156 -> 17150;
17156 -> 17153;
17157 -> 17153;
17158 -> 17156;
17158 -> 17157;
17159 -> 17157;
17159 -> 17153;
17160 -> 17156;
17160 -> 17159;
17160 -> 17153;
17161 -> 17156;
17161 -> 17157;
17162 -> 17156;
17162 -> 17157;
17163 -> 17153;
17164 -> 17161;
17164 -> 17163;
17165 -> 17154;
17165 -> 17153;
17166 -> 17153;
17167 -> 17161;
17167 -> 17166;
17168 -> 17164;
17168 -> 17166;
17169 -> 17164;
17169 -> 17166;
17170 -> 17165;
17170 -> 17166;
17171 -> 17155;
17171 -> 17166;
17172 -> 17169;
17172 -> 17166;
17173 -> 17166;
17174 -> 17172;
17174 -> 17173;
17175 -> 17174;
17175 -> 17173;
17176 -> 0;
17176 -> 17175;
17177 -> 17166;
17178 -> 17176;
17178 -> 17177;
17179 -> 17167;
17179 -> 17166;
17180 -> 17168;
17180 -> 17166;
17181 -> 17166;
17182 -> 17179;
17182 -> 17181;
17183 -> 17180;
17183 -> 17181;
17184 -> 17171;
17184 -> 17181;
17185 -> 17182;
17185 -> 17181;
17186 -> 17181;
17187 -> 17185;
17187 -> 17186;
17188 -> 17184;
17188 -> 17186;
17189 -> 17186;
17190 -> 17189;
17190 -> 17186;
17191 -> 17186;
17192 -> 17191;
17193 -> 17188;
17193 -> 17164;
17193 -> 17192;
17193 -> 17191;
17194 -> 17193;
17195 -> 17194;
17195 -> 17193;
17196 -> 17195;
17196 -> 17193;
17197 -> 17196;
17197 -> 17164;
17198 -> 17196;
17199 -> 17196;
17200 -> 17197;
17200 -> 17196;
17201 -> 17200;
17202 -> 17200;
17202 -> 17201;
17203 -> 17201;
17203 -> 17200;
17204 -> 17203;
17205 -> 17199;
17205 -> 17203;
17206 -> 17204;
17206 -> 17196;
17207 -> 17199;
17207 -> 17206;
17208 -> 17196;
17208 -> 17164;
17208 -> 17207;
17209 -> 17197;
17209 -> 17164;
17209 -> 17207;
17210 -> 17209;
17211 -> 17209;
17212 -> 17209;
17213 -> 17189;
17213 -> 17186;
17214 -> 17209;
17214 -> 17187;
17214 -> 17213;
17214 -> 17190;
17214 -> 17186;
17215 -> 17214;
17215 -> 17186;
17216 -> 17181;
17217 -> 17183;
17217 -> 17181;
17218 -> 17215;
17218 -> 17216;
17218 -> 17217;
17218 -> 17214;
17218 -> 17181;
17219 -> 17218;
17220 -> 17218;
17221 -> 17219;
17221 -> 17220;
17221 -> 17218;
17222 -> 17218;
17223 -> 17219;
17223 -> 17222;
17224 -> 17223;
17224 -> 17218;
17225 -> 17224;
17225 -> 17178;
17225 -> 17218;
17226 -> 17225;
17227 -> 17170;
17227 -> 17226;
17227 -> 17225;
17228 -> 17227;
17229 -> 17228;
17229 -> 17227;
17230 -> 17229;
17231 -> 17230;
17232 -> 17230;
17232 -> 17229;
17233 -> 17170;
17233 -> 17228;
17233 -> 17229;
17234 -> 17229;
17235 -> 17233;
17235 -> 17234;
17236 -> 17233;
17236 -> 17234;
17237 -> 17232;
17237 -> 17235;
17237 -> 17229;
17238 -> 17219;
17238 -> 17237;
17239 -> 16668;
17239 -> 0;
17239 -> 17143;
17240 -> 17238;
17240 -> 17239;
17241 -> 17142;
17241 -> 17239;
17242 -> 17239;
17243 -> 17239;
17244 -> 17240;
17244 -> 17243;
17245 -> 17241;
17245 -> 17243;
17246 -> 17242;
17246 -> 17243;
17247 -> 17245;
17247 -> 17243;
17248 -> 17243;
17249 -> 17247;
17249 -> 17248;
17250 -> 17246;
17250 -> 17248;
17251 -> 17249;
17251 -> 17248;
17252 -> 17248;
17253 -> 17251;
17253 -> 17252;
17254 -> 17250;
17254 -> 17252;
17255 -> 17252;
17256 -> 17252;
17257 -> 17253;
17257 -> 17256;
17257 -> 17252;
17258 -> 17253;
17258 -> 17235;
17258 -> 17254;
17258 -> 17252;
17259 -> 17253;
17259 -> 17235;
17259 -> 17254;
17259 -> 17252;
17260 -> 17255;
17260 -> 17254;
17260 -> 17252;
17261 -> 17246;
17261 -> 17243;
17262 -> 17246;
17262 -> 17243;
17263 -> 17243;
17264 -> 17244;
17264 -> 17263;
17264 -> 17243;
17265 -> 17244;
17265 -> 17246;
17265 -> 17243;
17266 -> 16667;
17266 -> 17235;
17266 -> 16697;
17267 -> 16697;
17268 -> 17266;
17268 -> 17267;
17269 -> 17242;
17269 -> 17267;
17270 -> 17269;
17270 -> 17258;
17270 -> 17267;
17271 -> 0;
17271 -> 17267;
17272 -> 17267;
17273 -> 17270;
17273 -> 17272;
17274 -> 17271;
17274 -> 17272;
17275 -> 17273;
17275 -> 17274;
17275 -> 17272;
17276 -> 17268;
17276 -> 17267;
17277 -> 17267;
17278 -> 17276;
17278 -> 17277;
17279 -> 17271;
17279 -> 17277;
17280 -> 17278;
17280 -> 17277;
17281 -> 17279;
17281 -> 17277;
17282 -> 17277;
17283 -> 17280;
17283 -> 17282;
17284 -> 17281;
17284 -> 17282;
17285 -> 17284;
17285 -> 17282;
17286 -> 17283;
17286 -> 17285;
17286 -> 17235;
17286 -> 17282;
17287 -> 17277;
17288 -> 17275;
17288 -> 17286;
17288 -> 17267;
17289 -> 17288;
17289 -> 17267;
17290 -> 16697;
17291 -> 17290;
17291 -> 17286;
17292 -> 17291;
17292 -> 16697;
17293 -> 16686;
17293 -> 16697;
17294 -> 17289;
17294 -> 16697;
17295 -> 17293;
17295 -> 17294;
17295 -> 17292;
17295 -> 16684;
17295 -> 16685;
17295 -> 17259;
17295 -> 17258;
17295 -> 17253;
17295 -> 17260;
17295 -> 17254;
17295 -> 17265;
17295 -> 17262;
17295 -> 17286;
17295 -> 17218;
17295 -> 16697;
17296 -> 16697;
17297 -> 17289;
17297 -> 16666;
17298 -> 16527;
17298 -> 17297;
17298 -> 17295;
17298 -> 16523;
17299 -> 16496;
17299 -> 16476;
17300 -> 0;
17300 -> 16253;
17301 -> 16257;
17301 -> 16253;
17302 -> 16253;
17303 -> 17300;
17303 -> 17302;
17304 -> 17301;
17304 -> 17302;
17305 -> 17298;
17305 -> 17302;
17306 -> 17302;
17307 -> 17304;
17307 -> 17306;
17307 -> 17302;
17308 -> 17305;
17308 -> 17302;
17309 -> 17305;
17309 -> 17298;
17309 -> 17303;
17309 -> 17302;
17310 -> 17304;
17310 -> 17302;
17311 -> 17302;
17312 -> 17302;
17313 -> 17308;
17313 -> 17312;
17314 -> 17309;
17314 -> 17312;
17315 -> 17310;
17315 -> 17312;
17316 -> 17311;
17316 -> 17312;
17317 -> 17313;
17317 -> 17312;
17318 -> 17314;
17318 -> 17312;
17319 -> 17312;
17320 -> 17317;
17320 -> 17319;
17321 -> 17318;
17321 -> 17319;
17322 -> 17316;
17322 -> 17319;
17323 -> 17322;
17323 -> 17319;
17324 -> 17322;
17324 -> 17319;
17325 -> 17322;
17325 -> 17319;
17326 -> 17322;
17326 -> 17319;
17327 -> 17322;
17327 -> 17319;
17328 -> 17319;
17329 -> 17320;
17329 -> 17328;
17329 -> 17319;
17330 -> 17321;
17330 -> 17319;
17331 -> 0;
17331 -> 17319;
17332 -> 17319;
17333 -> 17330;
17333 -> 17332;
17334 -> 17331;
17334 -> 17332;
17335 -> 17321;
17335 -> 17319;
17336 -> 0;
17336 -> 17319;
17337 -> 17319;
17338 -> 17335;
17338 -> 17337;
17339 -> 17336;
17339 -> 17337;
17340 -> 17320;
17340 -> 17322;
17340 -> 17319;
17341 -> 17321;
17341 -> 17322;
17341 -> 17319;
17342 -> 17320;
17342 -> 17298;
17342 -> 17322;
17342 -> 17319;
17343 -> 17316;
17343 -> 17312;
17344 -> 17312;
17345 -> 17312;
17346 -> 17315;
17346 -> 17345;
17347 -> 17344;
17347 -> 17345;
17348 -> 17347;
17348 -> 17345;
17349 -> 17346;
17349 -> 17348;
17350 -> 17315;
17350 -> 17344;
17350 -> 17312;
17351 -> 17315;
17351 -> 17316;
17351 -> 17312;
17352 -> 17311;
17352 -> 16253;
17353 -> 16253;
17354 -> 16275;
17354 -> 17298;
17354 -> 16253;
17355 -> 16253;
17356 -> 17354;
17356 -> 17355;
17357 -> 17354;
17357 -> 17355;
17358 -> 17354;
17358 -> 17355;
17359 -> 17354;
17359 -> 17355;
17360 -> 17353;
17360 -> 17356;
17361 -> 17356;
17362 -> 17356;
17363 -> 17361;
17363 -> 17362;
17364 -> 17361;
17364 -> 17362;
17365 -> 17361;
17365 -> 17362;
17366 -> 17361;
17366 -> 17362;
17367 -> 17356;
17368 -> 17363;
17368 -> 17367;
17369 -> 17368;
17369 -> 17356;
17370 -> 17356;
17371 -> 17363;
17371 -> 17370;
17372 -> 17371;
17372 -> 17356;
17373 -> 17356;
17374 -> 17372;
17374 -> 17373;
17375 -> 17374;
17375 -> 17373;
17376 -> 17375;
17377 -> 17369;
17377 -> 17376;
17377 -> 17356;
17378 -> 16256;
17378 -> 17377;
17379 -> 0;
17379 -> 17377;
17380 -> 17377;
17381 -> 17363;
17381 -> 17380;
17382 -> 17381;
17382 -> 17380;
17383 -> 17380;
17384 -> 17383;
17385 -> 17383;
17386 -> 17382;
17386 -> 17383;
17387 -> 17383;
17388 -> 17386;
17388 -> 17387;
17388 -> 17383;
17389 -> 17383;
17390 -> 17382;
17390 -> 17389;
17390 -> 17383;
17391 -> 17383;
17392 -> 17382;
17392 -> 17391;
17392 -> 17383;
17393 -> 17382;
17394 -> 17382;
17395 -> 17393;
17395 -> 17394;
17395 -> 17382;
17396 -> 17383;
17397 -> 17382;
17397 -> 17396;
17397 -> 17383;
17398 -> 17382;
17398 -> 17383;
17399 -> 17382;
17399 -> 17377;
17400 -> 17377;
17401 -> 17378;
17401 -> 17400;
17402 -> 17379;
17402 -> 17400;
17403 -> 17399;
17403 -> 17400;
17404 -> 17402;
17404 -> 17400;
17405 -> 17400;
17406 -> 17400;
17407 -> 17404;
17407 -> 17406;
17408 -> 17405;
17408 -> 17406;
17409 -> 17406;
17409 -> 17407;
17409 -> 17382;
17410 -> 17409;
17410 -> 17406;
17411 -> 17407;
17411 -> 0;
17411 -> 17406;
17412 -> 17405;
17412 -> 17400;
17413 -> 17403;
17413 -> 17400;
17414 -> 17400;
17415 -> 17400;
17416 -> 17412;
17416 -> 17415;
17417 -> 17413;
17417 -> 17415;
17418 -> 17414;
17418 -> 17415;
17419 -> 17414;
17419 -> 17415;
17420 -> 17416;
17420 -> 17415;
17421 -> 17417;
17421 -> 17415;
17422 -> 17418;
17422 -> 17415;
17423 -> 17415;
17424 -> 17423;
17424 -> 17420;
17424 -> 17421;
17424 -> 17422;
17424 -> 17409;
17424 -> 17406;
17424 -> 17408;
17424 -> 0;
17424 -> 17415;
17425 -> 17414;
17425 -> 17400;
17426 -> 17401;
17426 -> 17425;
17426 -> 16215;
17426 -> 17424;
17426 -> 17400;
17427 -> 17405;
17427 -> 17400;
17428 -> 17427;
17428 -> 17377;
17429 -> 17363;
17429 -> 17356;
17430 -> 17429;
17430 -> 17426;
17430 -> 17356;
17431 -> 17356;
17432 -> 17431;
17433 -> 17430;
17433 -> 17432;
17433 -> 17431;
17434 -> 17430;
17434 -> 17431;
17435 -> 17356;
17436 -> 17356;
17437 -> 17360;
17437 -> 17436;
17437 -> 17356;
17438 -> 17356;
17439 -> 17438;
17439 -> 17430;
17440 -> 17439;
17440 -> 17356;
17441 -> 17437;
17441 -> 17440;
17441 -> 17356;
17442 -> 17363;
17442 -> 17441;
17443 -> 16256;
17443 -> 17441;
17444 -> 16254;
17444 -> 17441;
17445 -> 17441;
17446 -> 17441;
17447 -> 17442;
17447 -> 17446;
17448 -> 17443;
17448 -> 17446;
17449 -> 17444;
17449 -> 17446;
17450 -> 17445;
17450 -> 17446;
17451 -> 17352;
17451 -> 17446;
17452 -> 17447;
17452 -> 17446;
17453 -> 17448;
17453 -> 17446;
17454 -> 17449;
17454 -> 17446;
17455 -> 17450;
17455 -> 17446;
17456 -> 17446;
17457 -> 17452;
17457 -> 17456;
17458 -> 17453;
17458 -> 17456;
17459 -> 17454;
17459 -> 17456;
17460 -> 17455;
17460 -> 17456;
17461 -> 17451;
17461 -> 17456;
17462 -> 17456;
17463 -> 17458;
17463 -> 17462;
17463 -> 17456;
17464 -> 17457;
17464 -> 17456;
17465 -> 17458;
17465 -> 17456;
17466 -> 17459;
17466 -> 17456;
17467 -> 17456;
17468 -> 17459;
17468 -> 17467;
17468 -> 17456;
17469 -> 17456;
17470 -> 17464;
17470 -> 17469;
17471 -> 17465;
17471 -> 17469;
17472 -> 17466;
17472 -> 17469;
17473 -> 17468;
17473 -> 17469;
17474 -> 17461;
17474 -> 17469;
17475 -> 17469;
17476 -> 17470;
17476 -> 17475;
17477 -> 17476;
17477 -> 17469;
17478 -> 17470;
17478 -> 17477;
17479 -> 17471;
17479 -> 17477;
17480 -> 17477;
17481 -> 17472;
17481 -> 17477;
17482 -> 17477;
17483 -> 17478;
17483 -> 17482;
17484 -> 17479;
17484 -> 17482;
17485 -> 17480;
17485 -> 17482;
17486 -> 17481;
17486 -> 17482;
17487 -> 17480;
17487 -> 17482;
17488 -> 17474;
17488 -> 17482;
17489 -> 17483;
17489 -> 17430;
17489 -> 17482;
17490 -> 17482;
17491 -> 17489;
17491 -> 17490;
17492 -> 17489;
17492 -> 17490;
17493 -> 17489;
17493 -> 17490;
17494 -> 17489;
17494 -> 17490;
17495 -> 17484;
17495 -> 17482;
17496 -> 17486;
17496 -> 17482;
17497 -> 17482;
17498 -> 17482;
17499 -> 17491;
17499 -> 17498;
17500 -> 17495;
17500 -> 17498;
17501 -> 17496;
17501 -> 17498;
17502 -> 17497;
17502 -> 17498;
17503 -> 17488;
17503 -> 17498;
17504 -> 17502;
17504 -> 17498;
17505 -> 17498;
17506 -> 17500;
17506 -> 17505;
17506 -> 17498;
17507 -> 17501;
17507 -> 17498;
17508 -> 17499;
17509 -> 17500;
17509 -> 17499;
17510 -> 17501;
17510 -> 17499;
17511 -> 17507;
17511 -> 17499;
17512 -> 17499;
17513 -> 17508;
17513 -> 17512;
17514 -> 17509;
17514 -> 17512;
17515 -> 17510;
17515 -> 17512;
17516 -> 17511;
17516 -> 17512;
17517 -> 17508;
17517 -> 17512;
17518 -> 17503;
17518 -> 17512;
17519 -> 17513;
17519 -> 17491;
17519 -> 17512;
17520 -> 17512;
17521 -> 17519;
17521 -> 17520;
17522 -> 17520;
17522 -> 17512;
17523 -> 17519;
17523 -> 17522;
17523 -> 17512;
17524 -> 17519;
17524 -> 17520;
17525 -> 17524;
17525 -> 17512;
17526 -> 17512;
17527 -> 17513;
17527 -> 17526;
17528 -> 17527;
17528 -> 17524;
17528 -> 17526;
17529 -> 17528;
17529 -> 17512;
17530 -> 17517;
17530 -> 17512;
17531 -> 17524;
17531 -> 17512;
17532 -> 17512;
17533 -> 17514;
17533 -> 17512;
17534 -> 17512;
17535 -> 17529;
17535 -> 17534;
17536 -> 17530;
17536 -> 17534;
17537 -> 17531;
17537 -> 17534;
17538 -> 17532;
17538 -> 17534;
17539 -> 17533;
17539 -> 17534;
17540 -> 17518;
17540 -> 17534;
17541 -> 17534;
17542 -> 17536;
17542 -> 17541;
17542 -> 17534;
17543 -> 17534;
17544 -> 17543;
17544 -> 17512;
17545 -> 17512;
17546 -> 17544;
17546 -> 17545;
17546 -> 17512;
17548 -> 17547;
17549 -> 17548;
17549 -> 17547;
17550 -> 17547;
17551 -> 17549;
17551 -> 17547;
17552 -> 17551;
17553 -> 17512;
17554 -> 17552;
17554 -> 17553;
17555 -> 17552;
17555 -> 17549;
17555 -> 17553;
17556 -> 17553;
17557 -> 17555;
17557 -> 17556;
17558 -> 17554;
17558 -> 17556;
17559 -> 17558;
17559 -> 17556;
17560 -> 17558;
17560 -> 17556;
17561 -> 17558;
17561 -> 17556;
17562 -> 17558;
17562 -> 17556;
17563 -> 17557;
17563 -> 17558;
17563 -> 17556;
17564 -> 0;
17564 -> 17558;
17564 -> 17556;
17565 -> 17556;
17566 -> 17565;
17566 -> 17558;
17566 -> 17556;
17567 -> 17556;
17568 -> 17567;
17568 -> 17558;
17568 -> 17556;
17569 -> 17555;
17569 -> 17554;
17569 -> 17564;
17569 -> 17566;
17569 -> 17568;
17569 -> 17563;
17569 -> 17565;
17569 -> 17553;
17570 -> 17553;
17571 -> 17569;
17571 -> 17570;
17572 -> 17571;
17572 -> 17569;
17572 -> 0;
17572 -> 17570;
17573 -> 17570;
17574 -> 17571;
17574 -> 17569;
17574 -> 17573;
17574 -> 17570;
17575 -> 17572;
17575 -> 17553;
17576 -> 17569;
17576 -> 17553;
17577 -> 17576;
17577 -> 17512;
17578 -> 17513;
17578 -> 17512;
17579 -> 17513;
17579 -> 17524;
17579 -> 17512;
17580 -> 17512;
17581 -> 17579;
17581 -> 17580;
17582 -> 17580;
17582 -> 17512;
17583 -> 17579;
17583 -> 17582;
17583 -> 17512;
17584 -> 17512;
17585 -> 17583;
17585 -> 17584;
17586 -> 17585;
17586 -> 17584;
17587 -> 0;
17587 -> 17584;
17588 -> 17584;
17589 -> 17586;
17589 -> 17588;
17590 -> 17587;
17590 -> 17588;
17591 -> 17589;
17591 -> 17583;
17591 -> 17590;
17591 -> 17588;
17592 -> 17584;
17593 -> 17585;
17593 -> 17583;
17593 -> 17592;
17594 -> 17592;
17595 -> 17593;
17595 -> 17594;
17596 -> 17595;
17596 -> 17592;
17597 -> 17596;
17597 -> 17584;
17598 -> 17584;
17599 -> 17591;
17599 -> 17597;
17599 -> 17584;
17600 -> 17584;
17601 -> 17585;
17601 -> 17597;
17601 -> 17600;
17602 -> 17600;
17603 -> 17599;
17603 -> 17601;
17603 -> 17584;
17604 -> 17512;
17605 -> 17578;
17605 -> 17604;
17606 -> 17603;
17606 -> 17604;
17607 -> 17605;
17607 -> 17604;
17608 -> 17604;
17609 -> 17607;
17609 -> 17608;
17610 -> 17609;
17610 -> 17601;
17610 -> 17608;
17611 -> 17608;
17612 -> 17610;
17612 -> 17611;
17612 -> 17608;
17613 -> 17609;
17613 -> 17608;
17614 -> 17608;
17615 -> 17613;
17615 -> 17614;
17616 -> 17615;
17616 -> 17601;
17616 -> 17614;
17617 -> 17616;
17617 -> 17614;
17618 -> 17614;
17619 -> 17617;
17619 -> 17618;
17620 -> 17608;
17621 -> 17619;
17621 -> 17620;
17622 -> 17621;
17623 -> 17612;
17623 -> 17622;
17623 -> 17608;
17624 -> 17610;
17624 -> 17608;
17625 -> 17608;
17626 -> 17624;
17626 -> 17625;
17627 -> 17626;
17627 -> 17601;
17627 -> 17625;
17628 -> 17627;
17628 -> 17625;
17629 -> 17625;
17630 -> 17628;
17630 -> 17629;
17631 -> 17609;
17631 -> 17601;
17631 -> 17608;
17632 -> 17608;
17633 -> 17631;
17633 -> 17632;
17633 -> 17608;
17634 -> 0;
17634 -> 17633;
17635 -> 17512;
17636 -> 17577;
17636 -> 17512;
17637 -> 17517;
17637 -> 17512;
17638 -> 17524;
17638 -> 17512;
17639 -> 17512;
17640 -> 17515;
17640 -> 17512;
17641 -> 17634;
17641 -> 17512;
17642 -> 17635;
17642 -> 17512;
17643 -> 17512;
17644 -> 17636;
17644 -> 17643;
17645 -> 17637;
17645 -> 17643;
17646 -> 17638;
17646 -> 17643;
17647 -> 17639;
17647 -> 17643;
17648 -> 17640;
17648 -> 17643;
17649 -> 17641;
17649 -> 17643;
17650 -> 17639;
17650 -> 17643;
17651 -> 17642;
17651 -> 17643;
17652 -> 17518;
17652 -> 17643;
17653 -> 17649;
17653 -> 17643;
17654 -> 17643;
17655 -> 17653;
17655 -> 17654;
17656 -> 17655;
17656 -> 0;
17656 -> 17654;
17657 -> 17644;
17657 -> 17656;
17658 -> 17645;
17658 -> 17656;
17659 -> 17646;
17659 -> 17656;
17660 -> 17647;
17660 -> 17656;
17661 -> 17648;
17661 -> 17656;
17662 -> 17649;
17662 -> 17656;
17663 -> 17650;
17663 -> 17656;
17664 -> 17651;
17664 -> 17656;
17665 -> 17656;
17666 -> 17657;
17666 -> 17665;
17667 -> 17658;
17667 -> 17665;
17668 -> 17659;
17668 -> 17665;
17669 -> 17660;
17669 -> 17665;
17670 -> 17661;
17670 -> 17665;
17671 -> 17662;
17671 -> 17665;
17672 -> 17663;
17672 -> 17665;
17673 -> 17664;
17673 -> 17665;
17674 -> 17652;
17674 -> 17665;
17675 -> 17665;
17676 -> 17667;
17676 -> 17675;
17676 -> 17665;
17677 -> 17666;
17677 -> 17676;
17678 -> 17668;
17678 -> 17676;
17679 -> 17669;
17679 -> 17676;
17680 -> 17670;
17680 -> 17676;
17681 -> 17671;
17681 -> 17676;
17682 -> 17672;
17682 -> 17676;
17683 -> 17673;
17683 -> 17676;
17684 -> 17676;
17685 -> 17677;
17685 -> 17684;
17686 -> 17678;
17686 -> 17684;
17687 -> 17679;
17687 -> 17684;
17688 -> 17680;
17688 -> 17684;
17689 -> 17681;
17689 -> 17684;
17690 -> 17682;
17690 -> 17684;
17691 -> 17683;
17691 -> 17684;
17692 -> 17674;
17692 -> 17684;
17693 -> 17684;
17694 -> 17685;
17694 -> 17693;
17695 -> 17694;
17695 -> 17569;
17695 -> 0;
17695 -> 17693;
17696 -> 17693;
17697 -> 17694;
17697 -> 17569;
17697 -> 17696;
17697 -> 17693;
17698 -> 17695;
17698 -> 17684;
17699 -> 17689;
17699 -> 17684;
17700 -> 17684;
17701 -> 17699;
17701 -> 17700;
17702 -> 17701;
17702 -> 0;
17702 -> 17700;
17703 -> 17701;
17703 -> 0;
17703 -> 17700;
17704 -> 17700;
17705 -> 0;
17705 -> 17700;
17706 -> 17701;
17706 -> 17705;
17706 -> 17700;
17707 -> 0;
17707 -> 17700;
17708 -> 17701;
17708 -> 17707;
17708 -> 17700;
17709 -> 17700;
17710 -> 0;
17710 -> 17700;
17711 -> 17701;
17711 -> 17710;
17711 -> 17700;
17712 -> 17711;
17712 -> 17700;
17713 -> 17700;
17714 -> 17712;
17714 -> 17713;
17715 -> 17713;
17716 -> 17714;
17716 -> 17715;
17716 -> 17713;
17717 -> 17684;
17718 -> 17692;
17718 -> 17684;
17719 -> 17684;
17720 -> 17684;
17721 -> 17685;
17721 -> 17720;
17722 -> 17720;
17723 -> 17721;
17723 -> 17722;
17724 -> 17723;
17724 -> 17569;
17724 -> 17722;
17725 -> 17724;
17725 -> 17720;
17726 -> 17725;
17726 -> 17684;
17727 -> 17718;
17727 -> 17726;
17727 -> 17684;
17728 -> 17727;
17729 -> 17717;
17729 -> 17728;
17729 -> 17727;
17730 -> 17685;
17730 -> 17729;
17731 -> 17686;
17731 -> 17729;
17732 -> 17687;
17732 -> 17729;
17733 -> 17688;
17733 -> 17729;
17734 -> 17689;
17734 -> 17729;
17735 -> 17692;
17735 -> 17729;
17736 -> 17690;
17736 -> 17729;
17737 -> 17691;
17737 -> 17729;
17738 -> 17729;
17739 -> 17730;
17739 -> 17738;
17740 -> 17731;
17740 -> 17738;
17741 -> 17732;
17741 -> 17738;
17742 -> 17733;
17742 -> 17738;
17743 -> 17734;
17743 -> 17738;
17744 -> 17735;
17744 -> 17738;
17745 -> 17736;
17745 -> 17738;
17746 -> 17737;
17746 -> 17738;
17747 -> 17718;
17747 -> 17738;
17748 -> 17729;
17749 -> 17729;
17750 -> 17685;
17750 -> 17749;
17751 -> 17750;
17751 -> 17569;
17751 -> 0;
17751 -> 17749;
17752 -> 17749;
17753 -> 17750;
17753 -> 17569;
17753 -> 17752;
17753 -> 17749;
17754 -> 17751;
17754 -> 17729;
17755 -> 17689;
17755 -> 0;
17755 -> 17727;
17756 -> 17727;
17757 -> 17718;
17757 -> 17340;
17757 -> 17727;
17758 -> 17757;
17759 -> 17717;
17759 -> 17758;
17759 -> 17757;
17760 -> 17685;
17760 -> 17759;
17761 -> 17686;
17761 -> 17759;
17762 -> 17687;
17762 -> 17759;
17763 -> 17688;
17763 -> 17759;
17764 -> 17689;
17764 -> 17759;
17765 -> 17692;
17765 -> 17759;
17766 -> 17690;
17766 -> 17759;
17767 -> 17746;
17767 -> 17759;
17768 -> 17759;
17769 -> 17760;
17769 -> 17768;
17770 -> 17761;
17770 -> 17768;
17771 -> 17762;
17771 -> 17768;
17772 -> 17763;
17772 -> 17768;
17773 -> 17764;
17773 -> 17768;
17774 -> 17765;
17774 -> 17768;
17775 -> 17766;
17775 -> 17768;
17776 -> 17767;
17776 -> 17768;
17777 -> 17757;
17777 -> 17768;
17778 -> 17768;
17779 -> 17769;
17779 -> 17778;
17780 -> 17779;
17780 -> 17569;
17780 -> 0;
17780 -> 17778;
17781 -> 17778;
17782 -> 17779;
17782 -> 17569;
17782 -> 17781;
17782 -> 17778;
17783 -> 17780;
17783 -> 17768;
17784 -> 17768;
17785 -> 17777;
17785 -> 17784;
17786 -> 0;
17786 -> 17784;
17787 -> 17786;
17787 -> 17768;
17788 -> 17773;
17788 -> 17787;
17788 -> 17768;
17789 -> 17768;
17790 -> 17768;
17791 -> 17777;
17791 -> 17790;
17792 -> 17790;
17793 -> 17791;
17793 -> 17601;
17793 -> 17792;
17793 -> 17790;
17794 -> 17793;
17795 -> 17793;
17796 -> 17791;
17796 -> 17601;
17796 -> 17795;
17797 -> 17796;
17797 -> 17601;
17797 -> 17795;
17798 -> 17797;
17799 -> 17796;
17799 -> 17601;
17799 -> 17797;
17800 -> 17798;
17800 -> 17797;
17801 -> 17797;
17802 -> 17798;
17802 -> 17800;
17803 -> 17800;
17804 -> 17802;
17804 -> 17803;
17805 -> 17796;
17805 -> 17803;
17806 -> 17803;
17807 -> 17805;
17807 -> 17806;
17808 -> 17807;
17808 -> 17803;
17809 -> 17804;
17809 -> 17800;
17809 -> 17803;
17810 -> 17800;
17811 -> 17798;
17811 -> 17800;
17811 -> 17797;
17812 -> 17796;
17812 -> 17811;
17812 -> 17795;
17813 -> 17812;
17813 -> 17793;
17814 -> 17791;
17814 -> 17811;
17814 -> 17793;
17815 -> 17794;
17815 -> 17793;
17816 -> 17793;
17817 -> 17814;
17817 -> 17815;
17817 -> 17816;
17817 -> 17794;
17817 -> 17811;
17817 -> 17793;
17818 -> 17791;
17818 -> 17817;
17818 -> 17790;
17819 -> 17818;
17819 -> 17768;
17820 -> 17819;
17820 -> 17770;
17820 -> 17817;
17820 -> 17768;
17821 -> 17759;
17822 -> 17759;
17823 -> 17685;
17823 -> 17822;
17824 -> 17823;
17824 -> 17569;
17824 -> 0;
17824 -> 17822;
17825 -> 17822;
17826 -> 17823;
17826 -> 17569;
17826 -> 17825;
17826 -> 17822;
17827 -> 17824;
17827 -> 17759;
17828 -> 17689;
17828 -> 0;
17828 -> 17757;
17829 -> 17757;
17830 -> 17687;
17830 -> 17820;
17831 -> 17688;
17831 -> 17820;
17832 -> 17689;
17832 -> 17820;
17833 -> 17690;
17833 -> 17820;
17834 -> 17776;
17834 -> 17820;
17835 -> 17820;
17836 -> 17820;
17837 -> 17830;
17837 -> 17820;
17838 -> 17831;
17838 -> 17820;
17839 -> 17832;
17839 -> 17820;
17840 -> 17820;
17841 -> 17833;
17841 -> 17820;
17842 -> 17834;
17842 -> 17820;
17843 -> 17820;
17844 -> 17820;
17845 -> 17835;
17845 -> 17844;
17846 -> 17845;
17846 -> 17569;
17846 -> 0;
17846 -> 17844;
17847 -> 17844;
17848 -> 17845;
17848 -> 17569;
17848 -> 17847;
17848 -> 17844;
17849 -> 17846;
17849 -> 17820;
17850 -> 17820;
17851 -> 17843;
17851 -> 17850;
17852 -> 17850;
17853 -> 17851;
17853 -> 17820;
17853 -> 17852;
17854 -> 17852;
17854 -> 17850;
17855 -> 17854;
17855 -> 17820;
17856 -> 17838;
17856 -> 17820;
17857 -> 17820;
17858 -> 17856;
17858 -> 17857;
17859 -> 17843;
17859 -> 17857;
17860 -> 17857;
17861 -> 17859;
17861 -> 17820;
17861 -> 17860;
17861 -> 17857;
17862 -> 17857;
17863 -> 17859;
17863 -> 17820;
17863 -> 17862;
17863 -> 17857;
17865 -> 0;
17866 -> 0;
17867 -> 0;
17870 -> 17864;
17870 -> 17869;
17871 -> 17865;
17871 -> 17869;
17872 -> 17866;
17872 -> 17869;
17873 -> 17867;
17873 -> 17869;
17874 -> 17868;
17874 -> 17869;
17875 -> 17869;
17876 -> 17875;
17876 -> 17869;
17877 -> 17875;
17877 -> 17869;
17878 -> 17875;
17878 -> 17869;
17879 -> 17869;
17880 -> 17871;
17880 -> 17879;
17880 -> 17869;
17881 -> 17872;
17881 -> 0;
17881 -> 17869;
17882 -> 17873;
17882 -> 0;
17882 -> 17869;
17883 -> 17870;
17883 -> 17875;
17883 -> 17869;
17884 -> 17871;
17884 -> 17875;
17884 -> 17869;
17885 -> 17872;
17885 -> 17875;
17885 -> 17869;
17886 -> 17874;
17886 -> 17875;
17886 -> 17869;
17887 -> 17873;
17887 -> 17875;
17887 -> 17869;
17888 -> 17869;
17889 -> 17859;
17889 -> 17820;
17889 -> 17863;
17890 -> 17858;
17890 -> 17863;
17891 -> 17863;
17892 -> 17890;
17892 -> 17891;
17893 -> 17890;
17893 -> 17891;
17894 -> 17890;
17894 -> 17891;
17895 -> 17890;
17895 -> 17891;
17896 -> 17891;
17897 -> 17896;
17897 -> 17891;
17898 -> 17891;
17899 -> 17898;
17899 -> 17891;
17900 -> 17891;
17901 -> 17892;
17901 -> 17900;
17902 -> 17901;
17902 -> 17891;
17903 -> 17902;
17904 -> 17903;
17904 -> 17902;
17905 -> 17892;
17905 -> 17904;
17906 -> 17895;
17906 -> 17904;
17907 -> 17905;
17907 -> 17890;
17907 -> 17906;
17908 -> 17905;
17908 -> 17890;
17908 -> 17907;
17908 -> 17904;
17909 -> 17905;
17909 -> 17890;
17909 -> 17904;
17910 -> 17891;
17911 -> 17908;
17911 -> 17890;
17911 -> 17910;
17911 -> 17891;
17912 -> 17909;
17912 -> 17890;
17912 -> 17910;
17912 -> 17891;
17913 -> 17911;
17913 -> 17912;
17913 -> 17891;
17914 -> 17888;
17914 -> 17913;
17915 -> 17890;
17915 -> 17914;
17915 -> 17907;
17915 -> 17883;
17915 -> 17886;
17915 -> 17884;
17915 -> 17885;
17915 -> 17887;
17915 -> 0;
17915 -> 17863;
17916 -> 17859;
17916 -> 17915;
17916 -> 17857;
17917 -> 17839;
17917 -> 0;
17917 -> 17820;
17918 -> 17820;
17919 -> 17820;
17920 -> 17843;
17920 -> 17915;
17920 -> 17919;
17921 -> 17918;
17921 -> 17919;
17922 -> 17921;
17922 -> 17919;
17923 -> 17920;
17923 -> 17922;
17924 -> 17843;
17924 -> 17915;
17924 -> 17918;
17924 -> 17820;
17925 -> 17917;
17925 -> 17924;
17925 -> 17820;
17926 -> 17835;
17926 -> 17925;
17927 -> 17843;
17927 -> 17915;
17927 -> 17925;
17928 -> 17836;
17928 -> 17925;
17929 -> 17837;
17929 -> 17925;
17930 -> 17838;
17930 -> 17925;
17931 -> 17839;
17931 -> 17925;
17932 -> 17840;
17932 -> 17925;
17933 -> 17841;
17933 -> 17925;
17934 -> 17842;
17934 -> 17925;
17935 -> 17925;
17936 -> 17926;
17936 -> 17935;
17937 -> 17927;
17937 -> 17935;
17938 -> 17928;
17938 -> 17935;
17939 -> 17929;
17939 -> 17935;
17940 -> 17930;
17940 -> 17935;
17941 -> 17931;
17941 -> 17935;
17942 -> 17932;
17942 -> 17935;
17943 -> 17933;
17943 -> 17935;
17944 -> 17934;
17944 -> 17935;
17945 -> 17843;
17945 -> 17935;
17946 -> 17941;
17946 -> 17935;
17947 -> 17935;
17948 -> 17946;
17948 -> 17947;
17949 -> 17948;
17949 -> 0;
17949 -> 17947;
17950 -> 17948;
17950 -> 0;
17950 -> 17947;
17951 -> 17947;
17952 -> 0;
17952 -> 17947;
17953 -> 17948;
17953 -> 17952;
17953 -> 17947;
17954 -> 0;
17954 -> 17947;
17955 -> 17948;
17955 -> 17954;
17955 -> 17947;
17956 -> 17947;
17957 -> 0;
17957 -> 17947;
17958 -> 17948;
17958 -> 17957;
17958 -> 17947;
17959 -> 17958;
17959 -> 17947;
17960 -> 17947;
17961 -> 17959;
17961 -> 17960;
17962 -> 17960;
17963 -> 17961;
17963 -> 17962;
17963 -> 17960;
17964 -> 17935;
17965 -> 17939;
17965 -> 17964;
17965 -> 17935;
17966 -> 17935;
17967 -> 17937;
17967 -> 17966;
17968 -> 17966;
17969 -> 17967;
17969 -> 17968;
17970 -> 17968;
17970 -> 17966;
17971 -> 17970;
17971 -> 17935;
17972 -> 17936;
17972 -> 17971;
17973 -> 17937;
17973 -> 17971;
17974 -> 17938;
17974 -> 17971;
17975 -> 17939;
17975 -> 17971;
17976 -> 17941;
17976 -> 17971;
17977 -> 17942;
17977 -> 17971;
17978 -> 17943;
17978 -> 17971;
17979 -> 17944;
17979 -> 17971;
17980 -> 17971;
17981 -> 17972;
17981 -> 17980;
17982 -> 17973;
17982 -> 17980;
17983 -> 17974;
17983 -> 17980;
17984 -> 17975;
17984 -> 17980;
17985 -> 17976;
17985 -> 17980;
17986 -> 17977;
17986 -> 17980;
17987 -> 17978;
17987 -> 17980;
17988 -> 17979;
17988 -> 17980;
17989 -> 17982;
17989 -> 17980;
17990 -> 17983;
17990 -> 17980;
17991 -> 17985;
17991 -> 17980;
17992 -> 17986;
17992 -> 17980;
17993 -> 17980;
17994 -> 17989;
17994 -> 17993;
17995 -> 17990;
17995 -> 17993;
17996 -> 17991;
17996 -> 17993;
17997 -> 17992;
17997 -> 17993;
17998 -> 17996;
17998 -> 0;
17998 -> 17993;
17999 -> 17993;
18000 -> 17998;
18000 -> 17994;
18000 -> 17993;
18001 -> 18000;
18002 -> 17994;
18002 -> 18001;
18003 -> 18001;
18003 -> 18000;
18004 -> 17996;
18004 -> 0;
18004 -> 18003;
18005 -> 18003;
18006 -> 17995;
18006 -> 18004;
18007 -> 18004;
18008 -> 18006;
18008 -> 18007;
18009 -> 18008;
18009 -> 17980;
18010 -> 18009;
18011 -> 17984;
18011 -> 18009;
18012 -> 17985;
18012 -> 18009;
18013 -> 17987;
18013 -> 18009;
18014 -> 17988;
18014 -> 18009;
18015 -> 18009;
18016 -> 18010;
18016 -> 18015;
18017 -> 18011;
18017 -> 18015;
18018 -> 18012;
18018 -> 18015;
18019 -> 18010;
18019 -> 18015;
18020 -> 18013;
18020 -> 18015;
18021 -> 18014;
18021 -> 18015;
18022 -> 18010;
18022 -> 18015;
18023 -> 17986;
18023 -> 18015;
18024 -> 18015;
18025 -> 18015;
18026 -> 18015;
18027 -> 18016;
18027 -> 18026;
18028 -> 18026;
18028 -> 18015;
18029 -> 18028;
18029 -> 18015;
18030 -> 18016;
18030 -> 18029;
18031 -> 18015;
18032 -> 18023;
18032 -> 17342;
18032 -> 18031;
18033 -> 18032;
18033 -> 18031;
18034 -> 18032;
18034 -> 18015;
18035 -> 18015;
18036 -> 18030;
18036 -> 18035;
18037 -> 18036;
18037 -> 18008;
18037 -> 18032;
18037 -> 18035;
18038 -> 18037;
18038 -> 18015;
18039 -> 18015;
18040 -> 18038;
18040 -> 18039;
18041 -> 18034;
18041 -> 18039;
18042 -> 18040;
18042 -> 18039;
18043 -> 18039;
18044 -> 18039;
18045 -> 18042;
18045 -> 18044;
18046 -> 18043;
18046 -> 18044;
18047 -> 18041;
18047 -> 18044;
18048 -> 18047;
18048 -> 18045;
18048 -> 18044;
18049 -> 18030;
18049 -> 18048;
18050 -> 18017;
18050 -> 18048;
18051 -> 18020;
18051 -> 18048;
18052 -> 18018;
18052 -> 18048;
18053 -> 18025;
18053 -> 18048;
18054 -> 18048;
18055 -> 18049;
18055 -> 18054;
18056 -> 18050;
18056 -> 18054;
18057 -> 18051;
18057 -> 18054;
18058 -> 18052;
18058 -> 18054;
18059 -> 18053;
18059 -> 18054;
18060 -> 18054;
18061 -> 18055;
18061 -> 18060;
18062 -> 18060;
18062 -> 18054;
18063 -> 18062;
18064 -> 18056;
18064 -> 18063;
18064 -> 18062;
18065 -> 18058;
18065 -> 0;
18065 -> 18062;
18066 -> 18064;
18066 -> 18065;
18066 -> 18062;
18067 -> 18055;
18067 -> 18066;
18068 -> 18066;
18069 -> 18067;
18069 -> 18068;
18070 -> 18069;
18070 -> 18068;
18071 -> 18070;
18071 -> 18066;
18072 -> 18067;
18072 -> 18066;
18073 -> 18066;
18074 -> 18067;
18074 -> 18073;
18075 -> 18074;
18075 -> 18066;
18076 -> 18058;
18076 -> 18066;
18077 -> 18066;
18078 -> 18076;
18078 -> 18077;
18079 -> 18075;
18079 -> 18078;
18079 -> 18066;
18080 -> 18054;
18081 -> 18054;
18082 -> 18081;
18082 -> 18048;
18083 -> 18082;
18084 -> 18023;
18084 -> 18083;
18085 -> 18084;
18085 -> 17341;
18085 -> 18083;
18086 -> 0;
18086 -> 18083;
18087 -> 18083;
18088 -> 18085;
18088 -> 18087;
18089 -> 18086;
18089 -> 18087;
18090 -> 18088;
18090 -> 18082;
18091 -> 18082;
18092 -> 18030;
18092 -> 18091;
18093 -> 18091;
18094 -> 18092;
18094 -> 18093;
18095 -> 18093;
18095 -> 18091;
18096 -> 18091;
18097 -> 18096;
18097 -> 18082;
18098 -> 18090;
18098 -> 18097;
18098 -> 18082;
18099 -> 18018;
18099 -> 0;
18099 -> 18098;
18100 -> 18098;
18101 -> 18018;
18101 -> 0;
18101 -> 18099;
18102 -> 18099;
18103 -> 18101;
18104 -> 18103;
18104 -> 18101;
18105 -> 18104;
18106 -> 18105;
18106 -> 18104;
18107 -> 18030;
18107 -> 18104;
18108 -> 18018;
18108 -> 18104;
18109 -> 18019;
18109 -> 18104;
18110 -> 18104;
18111 -> 18108;
18111 -> 18110;
18112 -> 18109;
18112 -> 18110;
18113 -> 18111;
18113 -> 0;
18113 -> 18110;
18114 -> 18110;
18115 -> 18113;
18115 -> 18110;
18116 -> 18112;
18116 -> 18115;
18117 -> 18024;
18117 -> 18104;
18118 -> 18021;
18118 -> 18104;
18119 -> 18022;
18119 -> 18104;
18120 -> 18104;
18121 -> 18107;
18121 -> 18120;
18122 -> 18116;
18122 -> 18120;
18123 -> 18117;
18123 -> 18120;
18124 -> 18118;
18124 -> 18120;
18125 -> 18119;
18125 -> 18120;
18126 -> 18023;
18126 -> 18120;
18127 -> 18126;
18127 -> 17341;
18127 -> 18120;
18128 -> 0;
18128 -> 18120;
18129 -> 18120;
18130 -> 18127;
18130 -> 18129;
18131 -> 18128;
18131 -> 18129;
18132 -> 18121;
18132 -> 18120;
18133 -> 18122;
18133 -> 18120;
18134 -> 18123;
18134 -> 18120;
18135 -> 18124;
18135 -> 18120;
18136 -> 18125;
18136 -> 18120;
18137 -> 18120;
18138 -> 18132;
18138 -> 18137;
18139 -> 18133;
18139 -> 18137;
18140 -> 18134;
18140 -> 18137;
18141 -> 18135;
18141 -> 18137;
18142 -> 18136;
18142 -> 18137;
18143 -> 18126;
18143 -> 18137;
18144 -> 18138;
18144 -> 18137;
18145 -> 18139;
18145 -> 18137;
18146 -> 18140;
18146 -> 18137;
18147 -> 18141;
18147 -> 18137;
18148 -> 18142;
18148 -> 18137;
18149 -> 18137;
18150 -> 18144;
18150 -> 18149;
18151 -> 18145;
18151 -> 18149;
18152 -> 18146;
18152 -> 18149;
18153 -> 18147;
18153 -> 18149;
18154 -> 18148;
18154 -> 18149;
18155 -> 18143;
18155 -> 17340;
18155 -> 18149;
18156 -> 18150;
18156 -> 18149;
18157 -> 18155;
18157 -> 18074;
18157 -> 18149;
18158 -> 18151;
18158 -> 18149;
18159 -> 18152;
18159 -> 18149;
18160 -> 18153;
18160 -> 18149;
18161 -> 18154;
18161 -> 18149;
18162 -> 18149;
18163 -> 18156;
18163 -> 18162;
18164 -> 18157;
18164 -> 18162;
18165 -> 18158;
18165 -> 18162;
18166 -> 18159;
18166 -> 18162;
18167 -> 18160;
18167 -> 18162;
18168 -> 18161;
18168 -> 18162;
18169 -> 18155;
18169 -> 18162;
18170 -> 18169;
18170 -> 18074;
18170 -> 18162;
18171 -> 0;
18171 -> 18162;
18172 -> 18162;
18173 -> 18170;
18173 -> 18172;
18174 -> 18171;
18174 -> 18172;
18175 -> 18163;
18175 -> 18162;
18176 -> 18164;
18176 -> 18162;
18177 -> 18165;
18177 -> 18162;
18178 -> 18166;
18178 -> 18162;
18179 -> 18167;
18179 -> 18162;
18180 -> 18168;
18180 -> 18162;
18181 -> 18162;
18182 -> 18175;
18182 -> 18181;
18183 -> 18176;
18183 -> 18181;
18184 -> 18177;
18184 -> 18181;
18185 -> 18178;
18185 -> 18181;
18186 -> 18179;
18186 -> 18181;
18187 -> 18180;
18187 -> 18181;
18188 -> 18182;
18188 -> 18181;
18189 -> 18183;
18189 -> 18181;
18190 -> 18184;
18190 -> 18181;
18191 -> 18185;
18191 -> 18181;
18192 -> 18181;
18193 -> 18183;
18193 -> 18192;
18194 -> 18192;
18195 -> 18193;
18195 -> 18194;
18196 -> 18194;
18196 -> 18192;
18197 -> 18193;
18197 -> 18181;
18198 -> 18186;
18198 -> 18181;
18199 -> 18187;
18199 -> 18181;
18200 -> 18181;
18201 -> 18188;
18201 -> 18200;
18202 -> 18189;
18202 -> 18200;
18203 -> 18190;
18203 -> 18200;
18204 -> 18191;
18204 -> 18200;
18205 -> 18197;
18205 -> 18200;
18206 -> 18198;
18206 -> 18200;
18207 -> 18199;
18207 -> 18200;
18208 -> 18200;
18209 -> 18201;
18209 -> 18208;
18209 -> 18200;
18210 -> 18200;
18211 -> 18202;
18211 -> 18210;
18211 -> 18200;
18212 -> 18200;
18213 -> 18202;
18213 -> 18212;
18214 -> 18212;
18215 -> 18213;
18215 -> 18214;
18216 -> 18214;
18217 -> 18215;
18217 -> 18216;
18218 -> 18216;
18219 -> 18217;
18219 -> 18218;
18220 -> 18218;
18221 -> 18219;
18221 -> 18220;
18222 -> 18221;
18222 -> 18218;
18223 -> 18222;
18223 -> 18216;
18224 -> 18223;
18224 -> 18214;
18225 -> 18224;
18225 -> 18212;
18226 -> 18225;
18226 -> 18200;
18227 -> 18202;
18227 -> 18200;
18228 -> 18200;
18229 -> 18200;
18230 -> 18201;
18230 -> 18229;
18231 -> 18229;
18231 -> 18200;
18232 -> 18201;
18232 -> 18231;
18233 -> 18202;
18233 -> 18231;
18234 -> 18206;
18234 -> 18231;
18235 -> 18207;
18235 -> 18231;
18236 -> 18231;
18237 -> 18232;
18237 -> 18236;
18238 -> 18233;
18238 -> 18236;
18239 -> 18234;
18239 -> 18236;
18240 -> 18235;
18240 -> 18236;
18241 -> 18238;
18241 -> 18236;
18242 -> 18236;
18243 -> 18237;
18243 -> 18242;
18243 -> 18236;
18244 -> 18236;
18245 -> 18238;
18245 -> 18244;
18246 -> 18244;
18247 -> 18245;
18247 -> 18246;
18248 -> 18246;
18248 -> 18244;
18249 -> 18245;
18249 -> 18236;
18250 -> 18236;
18251 -> 18236;
18252 -> 18237;
18252 -> 18251;
18253 -> 18251;
18254 -> 18252;
18254 -> 18253;
18255 -> 18253;
18256 -> 18254;
18256 -> 18255;
18257 -> 18255;
18258 -> 18256;
18258 -> 18257;
18259 -> 18257;
18260 -> 18258;
18260 -> 18259;
18261 -> 18260;
18261 -> 18257;
18262 -> 18261;
18262 -> 18255;
18263 -> 18262;
18263 -> 18253;
18264 -> 18263;
18264 -> 18251;
18265 -> 18264;
18265 -> 18236;
18266 -> 18236;
18267 -> 18237;
18267 -> 18266;
18268 -> 18267;
18268 -> 18008;
18268 -> 18074;
18268 -> 18266;
18269 -> 18268;
18269 -> 18236;
18270 -> 18236;
18271 -> 18269;
18271 -> 18270;
18271 -> 18236;
18272 -> 18271;
18272 -> 18236;
18273 -> 18272;
18274 -> 18237;
18274 -> 18273;
18275 -> 18273;
18276 -> 18274;
18276 -> 18275;
18277 -> 18276;
18277 -> 18273;
18278 -> 18273;
18279 -> 18277;
18279 -> 18278;
18279 -> 18273;
18280 -> 18279;
18280 -> 18273;
18281 -> 18280;
18282 -> 18277;
18282 -> 18281;
18283 -> 18281;
18284 -> 18282;
18284 -> 18074;
18284 -> 18283;
18285 -> 18284;
18285 -> 18074;
18285 -> 18283;
18286 -> 18272;
18287 -> 18237;
18287 -> 18286;
18288 -> 18287;
18288 -> 18008;
18288 -> 18074;
18288 -> 18286;
18289 -> 18286;
18290 -> 18288;
18290 -> 18289;
18291 -> 18290;
18291 -> 0;
18291 -> 18289;
18292 -> 0;
18292 -> 18291;
18293 -> 18238;
18293 -> 18272;
18294 -> 18272;
18295 -> 18285;
18295 -> 18294;
18296 -> 18292;
18296 -> 18294;
18297 -> 18293;
18297 -> 18294;
18298 -> 18297;
18298 -> 18294;
18299 -> 18294;
18300 -> 18295;
18300 -> 18299;
18300 -> 18294;
18301 -> 18296;
18301 -> 18294;
18302 -> 18297;
18302 -> 18301;
18303 -> 18301;
18304 -> 18302;
18304 -> 18303;
18304 -> 18301;
18305 -> 18304;
18305 -> 18301;
18306 -> 18305;
18307 -> 18302;
18307 -> 18306;
18308 -> 18306;
18309 -> 18307;
18309 -> 18308;
18310 -> 18309;
18310 -> 18306;
18311 -> 18306;
18312 -> 18310;
18312 -> 18311;
18312 -> 18306;
18313 -> 18312;
18313 -> 18306;
18314 -> 18313;
18315 -> 18310;
18315 -> 18314;
18316 -> 18314;
18317 -> 18315;
18317 -> 18074;
18317 -> 18316;
18318 -> 18317;
18318 -> 18074;
18318 -> 18316;
18319 -> 18318;
18319 -> 18295;
18319 -> 18301;
18320 -> 18106;
18320 -> 18319;
18320 -> 18104;
18321 -> 18320;
18322 -> 18321;
18322 -> 18320;
18323 -> 18030;
18323 -> 18320;
18324 -> 18320;
18325 -> 18323;
18325 -> 18324;
18326 -> 18324;
18327 -> 18325;
18327 -> 18326;
18328 -> 18326;
18328 -> 18324;
18329 -> 18328;
18330 -> 18329;
18330 -> 18320;
18331 -> 18322;
18331 -> 18330;
18331 -> 18320;
18332 -> 18018;
18332 -> 0;
18332 -> 18331;
18333 -> 18331;
18334 -> 18018;
18334 -> 0;
18334 -> 18332;
18335 -> 18332;
18336 -> 18018;
18336 -> 0;
18336 -> 18334;
18337 -> 18334;
18338 -> 18018;
18338 -> 0;
18338 -> 18336;
18339 -> 18336;
18340 -> 18030;
18340 -> 18338;
18341 -> 18338;
18342 -> 18340;
18342 -> 18341;
18343 -> 0;
18343 -> 18341;
18344 -> 18342;
18344 -> 18341;
18345 -> 18341;
18346 -> 18341;
18347 -> 18343;
18347 -> 18346;
18348 -> 18344;
18348 -> 18346;
18349 -> 18345;
18349 -> 18346;
18350 -> 18345;
18350 -> 18346;
18351 -> 18347;
18351 -> 18350;
18351 -> 18346;
18352 -> 18348;
18352 -> 18350;
18352 -> 18346;
18353 -> 18349;
18353 -> 18350;
18353 -> 18346;
18354 -> 18345;
18354 -> 18338;
18355 -> 18354;
18355 -> 18009;
18356 -> 18009;
18357 -> 18355;
18357 -> 18356;
18358 -> 17981;
18358 -> 18356;
18359 -> 18356;
18360 -> 18358;
18360 -> 18359;
18361 -> 18360;
18361 -> 18356;
18362 -> 18361;
18362 -> 18357;
18362 -> 18351;
18362 -> 18356;
18363 -> 18362;
18364 -> 18363;
18364 -> 18362;
18365 -> 18357;
18365 -> 18364;
18366 -> 18364;
18367 -> 18365;
18367 -> 18366;
18368 -> 18358;
18368 -> 18366;
18369 -> 18367;
18369 -> 18351;
18369 -> 18368;
18369 -> 18366;
18370 -> 18368;
18370 -> 17569;
18370 -> 18369;
18370 -> 18366;
18371 -> 18367;
18371 -> 18352;
18371 -> 18366;
18372 -> 18368;
18372 -> 18370;
18372 -> 18371;
18372 -> 18008;
18372 -> 18074;
18372 -> 18366;
18373 -> 18367;
18373 -> 18353;
18373 -> 18368;
18373 -> 18366;
18374 -> 18364;
18375 -> 18009;
18376 -> 18009;
18376 -> 18372;
18376 -> 18373;
18376 -> 17980;
18377 -> 17971;
18378 -> 17925;
18379 -> 17925;
18380 -> 17835;
18380 -> 18379;
18381 -> 18380;
18381 -> 18372;
18381 -> 18379;
18382 -> 18381;
18382 -> 17925;
18383 -> 18382;
18384 -> 17836;
18384 -> 18382;
18385 -> 18382;
18386 -> 17840;
18386 -> 18385;
18387 -> 18386;
18387 -> 17341;
18387 -> 18385;
18388 -> 0;
18388 -> 18385;
18389 -> 18385;
18390 -> 18387;
18390 -> 18389;
18391 -> 18388;
18391 -> 18389;
18392 -> 18390;
18392 -> 18382;
18393 -> 18382;
18394 -> 18384;
18394 -> 18393;
18395 -> 18392;
18395 -> 18393;
18396 -> 17916;
18396 -> 18393;
18397 -> 18393;
18398 -> 18397;
18398 -> 18393;
18399 -> 18394;
18399 -> 18393;
18400 -> 18397;
18400 -> 18393;
18401 -> 18396;
18401 -> 18372;
18401 -> 18399;
18401 -> 18400;
18401 -> 18373;
18401 -> 18398;
18401 -> 18393;
18402 -> 18393;
18403 -> 18402;
18403 -> 18382;
18404 -> 18382;
18405 -> 17820;
18406 -> 17685;
18406 -> 18405;
18407 -> 18406;
18407 -> 18401;
18407 -> 0;
18407 -> 18405;
18408 -> 18407;
18408 -> 17820;
18409 -> 17820;
18409 -> 18408;
18410 -> 17689;
18410 -> 0;
18410 -> 17820;
18411 -> 17820;
18412 -> 18409;
18412 -> 17684;
18413 -> 17656;
18414 -> 17514;
18414 -> 17512;
18415 -> 17513;
18415 -> 17512;
18416 -> 18239;
18416 -> 17512;
18417 -> 17512;
18418 -> 18414;
18418 -> 18417;
18419 -> 18415;
18419 -> 18417;
18420 -> 18416;
18420 -> 18417;
18421 -> 18420;
18421 -> 18417;
18422 -> 17512;
18423 -> 17512;
18424 -> 17517;
18424 -> 18423;
18424 -> 17512;
18425 -> 17577;
18425 -> 17512;
18426 -> 17512;
18427 -> 18425;
18427 -> 18426;
18428 -> 18426;
18429 -> 18427;
18429 -> 18428;
18430 -> 18428;
18431 -> 18429;
18431 -> 18430;
18432 -> 18431;
18432 -> 18401;
18432 -> 18430;
18433 -> 18432;
18433 -> 18426;
18434 -> 18426;
18435 -> 18427;
18435 -> 18434;
18436 -> 18435;
18436 -> 18401;
18436 -> 18434;
18437 -> 18436;
18437 -> 18426;
18438 -> 18437;
18439 -> 18437;
18439 -> 18438;
18440 -> 18438;
18440 -> 18437;
18441 -> 18440;
18442 -> 18422;
18442 -> 17512;
18443 -> 18442;
18444 -> 17577;
18444 -> 18442;
18445 -> 17524;
18445 -> 18442;
18446 -> 18442;
18447 -> 17513;
18447 -> 18442;
18448 -> 17514;
18448 -> 18442;
18449 -> 17516;
18449 -> 18442;
18450 -> 18443;
18450 -> 18442;
18451 -> 17517;
18451 -> 18442;
18452 -> 17634;
18452 -> 18442;
18453 -> 18442;
18454 -> 18444;
18454 -> 18453;
18455 -> 18445;
18455 -> 18453;
18456 -> 18446;
18456 -> 18453;
18457 -> 18447;
18457 -> 18453;
18458 -> 18448;
18458 -> 18453;
18459 -> 18449;
18459 -> 18453;
18460 -> 18450;
18460 -> 18453;
18461 -> 18451;
18461 -> 18453;
18462 -> 18452;
18462 -> 18453;
18463 -> 17518;
18463 -> 18453;
18464 -> 18454;
18464 -> 18453;
18465 -> 18455;
18465 -> 18453;
18466 -> 18456;
18466 -> 18453;
18467 -> 18457;
18467 -> 18453;
18468 -> 18458;
18468 -> 18453;
18469 -> 18459;
18469 -> 18453;
18470 -> 18460;
18470 -> 18453;
18471 -> 18461;
18471 -> 18453;
18472 -> 18462;
18472 -> 18453;
18473 -> 18453;
18474 -> 18464;
18474 -> 18473;
18475 -> 18465;
18475 -> 18473;
18476 -> 18466;
18476 -> 18473;
18477 -> 18467;
18477 -> 18473;
18478 -> 18468;
18478 -> 18473;
18479 -> 18469;
18479 -> 18473;
18480 -> 18470;
18480 -> 18473;
18481 -> 18471;
18481 -> 18473;
18482 -> 18472;
18482 -> 18473;
18483 -> 18463;
18483 -> 18473;
18484 -> 18473;
18485 -> 18477;
18485 -> 18484;
18485 -> 18473;
18486 -> 18473;
18487 -> 18478;
18487 -> 18486;
18487 -> 18473;
18488 -> 18473;
18489 -> 18474;
18489 -> 18488;
18490 -> 18489;
18490 -> 18401;
18490 -> 18488;
18491 -> 18490;
18491 -> 18473;
18492 -> 18473;
18493 -> 18473;
18494 -> 18474;
18494 -> 18493;
18495 -> 18493;
18496 -> 18494;
18496 -> 18495;
18497 -> 18496;
18497 -> 18401;
18497 -> 18495;
18498 -> 18497;
18498 -> 18473;
18499 -> 18498;
18500 -> 18491;
18500 -> 18401;
18500 -> 18499;
18500 -> 18498;
18501 -> 18500;
18502 -> 18501;
18502 -> 18500;
18503 -> 18500;
18504 -> 18502;
18504 -> 18503;
18504 -> 18500;
18505 -> 18500;
18506 -> 18502;
18506 -> 18505;
18507 -> 18505;
18508 -> 18506;
18508 -> 18507;
18509 -> 18508;
18509 -> 18505;
18510 -> 18509;
18511 -> 18506;
18511 -> 18510;
18512 -> 18510;
18513 -> 18511;
18513 -> 18501;
18513 -> 18512;
18514 -> 18513;
18514 -> 18501;
18514 -> 15784;
18514 -> 18512;
18515 -> 18514;
18515 -> 15811;
18515 -> 18512;
18516 -> 18515;
18516 -> 18510;
18517 -> 18516;
18517 -> 18509;
18518 -> 18517;
18518 -> 18500;
18519 -> 18518;
18520 -> 18501;
18520 -> 18519;
18521 -> 18519;
18521 -> 18518;
18522 -> 18518;
18523 -> 18483;
18523 -> 17342;
18523 -> 18522;
18524 -> 18523;
18524 -> 18522;
18525 -> 18523;
18525 -> 18518;
18526 -> 18518;
18527 -> 18525;
18527 -> 18526;
18528 -> 18526;
18529 -> 18527;
18529 -> 18528;
18530 -> 18529;
18530 -> 18523;
18530 -> 18528;
18531 -> 18530;
18532 -> 18529;
18532 -> 18531;
18533 -> 18531;
18534 -> 18532;
18534 -> 18523;
18534 -> 18533;
18534 -> 18531;
18535 -> 18530;
18536 -> 18530;
18537 -> 18530;
18538 -> 18537;
18539 -> 18537;
18539 -> 18538;
18540 -> 18538;
18541 -> 18539;
18541 -> 18523;
18541 -> 18540;
18541 -> 18538;
18542 -> 18537;
18543 -> 18537;
18543 -> 18530;
18544 -> 18543;
18545 -> 18543;
18545 -> 18544;
18546 -> 18545;
18546 -> 18523;
18546 -> 18544;
18547 -> 18546;
18547 -> 18543;
18548 -> 18529;
18548 -> 18523;
18548 -> 18530;
18549 -> 18536;
18549 -> 18530;
18550 -> 18530;
18551 -> 18529;
18551 -> 18549;
18551 -> 18528;
18552 -> 18529;
18552 -> 18549;
18552 -> 18528;
18553 -> 18552;
18553 -> 18526;
18554 -> 18526;
18555 -> 18521;
18555 -> 18553;
18555 -> 18518;
18556 -> 18479;
18556 -> 18518;
18557 -> 18556;
18558 -> 18501;
18558 -> 18557;
18559 -> 18557;
18559 -> 18556;
18560 -> 18501;
18560 -> 18500;
18561 -> 18453;
18562 -> 18560;
18562 -> 18561;
18563 -> 18561;
18563 -> 18453;
18564 -> 18457;
18564 -> 18563;
18565 -> 18563;
18566 -> 18560;
18566 -> 18563;
18567 -> 18458;
18567 -> 18563;
18568 -> 18563;
18569 -> 18564;
18569 -> 18568;
18570 -> 18565;
18570 -> 18568;
18571 -> 18566;
18571 -> 18568;
18572 -> 18567;
18572 -> 18568;
18573 -> 18463;
18573 -> 18568;
18574 -> 18568;
18575 -> 18571;
18575 -> 18574;
18576 -> 18575;
18576 -> 18549;
18576 -> 18574;
18577 -> 18576;
18577 -> 18568;
18578 -> 18568;
18579 -> 18560;
18579 -> 18453;
18580 -> 18442;
18581 -> 18579;
18581 -> 18580;
18582 -> 18580;
18582 -> 18442;
18583 -> 17512;
18584 -> 17577;
18584 -> 18583;
18585 -> 18583;
18586 -> 18584;
18586 -> 18585;
18587 -> 0;
18587 -> 18586;
18587 -> 18585;
18588 -> 18586;
18588 -> 18549;
18588 -> 18587;
18588 -> 18585;
18589 -> 18585;
18590 -> 18589;
18590 -> 18586;
18590 -> 18585;
18591 -> 18583;
18592 -> 18583;
18593 -> 18584;
18593 -> 18588;
18593 -> 18592;
18593 -> 18583;
18594 -> 18584;
18594 -> 18593;
18595 -> 18584;
18595 -> 18588;
18595 -> 18594;
18595 -> 18590;
18595 -> 18593;
18596 -> 17512;
18597 -> 17513;
18597 -> 18595;
18597 -> 17512;
18598 -> 17512;
18599 -> 18597;
18599 -> 18598;
18600 -> 18598;
18600 -> 17512;
18601 -> 18597;
18601 -> 18600;
18601 -> 17512;
18602 -> 17512;
18603 -> 18601;
18603 -> 18602;
18604 -> 17518;
18604 -> 18602;
18605 -> 18603;
18605 -> 18601;
18605 -> 18602;
18606 -> 18602;
18607 -> 18606;
18608 -> 18606;
18609 -> 18605;
18609 -> 18606;
18610 -> 18606;
18611 -> 18609;
18611 -> 18610;
18611 -> 18606;
18612 -> 18606;
18613 -> 18605;
18613 -> 18612;
18613 -> 18606;
18614 -> 18606;
18615 -> 18605;
18615 -> 18614;
18615 -> 18606;
18616 -> 18603;
18616 -> 18601;
18616 -> 18602;
18617 -> 18616;
18617 -> 18604;
18617 -> 18605;
18617 -> 17342;
18617 -> 17341;
18617 -> 17340;
18617 -> 17326;
18617 -> 17327;
18617 -> 17351;
18617 -> 18602;
18618 -> 18602;
18619 -> 18618;
18620 -> 18617;
18620 -> 18619;
18620 -> 18618;
18621 -> 18617;
18621 -> 18618;
18622 -> 18617;
18622 -> 18618;
18623 -> 18617;
18623 -> 18618;
18624 -> 18617;
18624 -> 18618;
18625 -> 18622;
18625 -> 18618;
18626 -> 18623;
18626 -> 18618;
18627 -> 18618;
18628 -> 18626;
18628 -> 18627;
18629 -> 18625;
18629 -> 18627;
18630 -> 18627;
18631 -> 18629;
18631 -> 18630;
18632 -> 18630;
18633 -> 18631;
18633 -> 18617;
18633 -> 18632;
18633 -> 18630;
18634 -> 18631;
18634 -> 18617;
18634 -> 18633;
18635 -> 18631;
18635 -> 18633;
18636 -> 18633;
18637 -> 18635;
18637 -> 18636;
18638 -> 18637;
18638 -> 18636;
18639 -> 18636;
18640 -> 18638;
18640 -> 18639;
18641 -> 18639;
18642 -> 18641;
18643 -> 18642;
18643 -> 18641;
18644 -> 0;
18644 -> 18641;
18645 -> 0;
18645 -> 18641;
18646 -> 18641;
18647 -> 18643;
18647 -> 18646;
18648 -> 18644;
18648 -> 18646;
18649 -> 18645;
18649 -> 18646;
18650 -> 18646;
18651 -> 18647;
18651 -> 18650;
18651 -> 18646;
18652 -> 18648;
18652 -> 18650;
18652 -> 18646;
18653 -> 18649;
18653 -> 18650;
18653 -> 18646;
18654 -> 18646;
18654 -> 18639;
18655 -> 18639;
18656 -> 18639;
18657 -> 18656;
18657 -> 18640;
18657 -> 18617;
18657 -> 18639;
18658 -> 18657;
18658 -> 18656;
18659 -> 18639;
18660 -> 18657;
18660 -> 18659;
18661 -> 18656;
18661 -> 18659;
18662 -> 18661;
18662 -> 18659;
18663 -> 18659;
18664 -> 18662;
18664 -> 18663;
18665 -> 18660;
18665 -> 18663;
18666 -> 18664;
18666 -> 18663;
18667 -> 18665;
18667 -> 18666;
18667 -> 18657;
18667 -> 18663;
18668 -> 18655;
18668 -> 18639;
18669 -> 18668;
18669 -> 18636;
18670 -> 18669;
18670 -> 18636;
18671 -> 18636;
18672 -> 18636;
18673 -> 18670;
18673 -> 18672;
18674 -> 18671;
18674 -> 18672;
18675 -> 18672;
18676 -> 18675;
18676 -> 18673;
18676 -> 18668;
18676 -> 18672;
18677 -> 18673;
18677 -> 18674;
18677 -> 18672;
18678 -> 18671;
18678 -> 18633;
18679 -> 18678;
18679 -> 18677;
18679 -> 18668;
18679 -> 18655;
18679 -> 18633;
18680 -> 18633;
18681 -> 18634;
18681 -> 18679;
18681 -> 18680;
18681 -> 18667;
18681 -> 18633;
18682 -> 18631;
18682 -> 18681;
18682 -> 18630;
18683 -> 18628;
18683 -> 18627;
18684 -> 18627;
18685 -> 18683;
18685 -> 18684;
18686 -> 18682;
18686 -> 18684;
18687 -> 18685;
18687 -> 18684;
18688 -> 18684;
18689 -> 18687;
18689 -> 18688;
18690 -> 18686;
18690 -> 18688;
18691 -> 18689;
18691 -> 18688;
18692 -> 0;
18692 -> 18688;
18693 -> 18688;
18694 -> 18688;
18695 -> 18691;
18695 -> 18694;
18696 -> 18692;
18696 -> 18694;
18697 -> 18692;
18697 -> 18694;
18698 -> 18693;
18698 -> 18694;
18699 -> 18695;
18699 -> 18698;
18699 -> 18694;
18700 -> 18696;
18700 -> 18698;
18700 -> 18694;
18701 -> 18697;
18701 -> 18698;
18701 -> 18694;
18703 -> 18702;
18704 -> 18702;
18705 -> 18690;
18705 -> 18681;
18705 -> 18688;
18706 -> 18693;
18706 -> 18688;
18707 -> 18704;
18707 -> 18688;
18708 -> 18705;
18708 -> 18706;
18708 -> 18707;
18708 -> 18681;
18708 -> 18699;
18708 -> 18700;
18708 -> 18701;
18708 -> 18688;
18709 -> 18688;
18710 -> 18708;
18710 -> 18709;
18710 -> 18688;
18711 -> 18710;
18712 -> 18688;
18713 -> 18711;
18713 -> 18712;
18713 -> 18688;
18714 -> 18711;
18714 -> 18690;
18714 -> 18681;
18714 -> 18708;
18714 -> 18688;
18715 -> 18688;
18716 -> 18711;
18716 -> 18715;
18716 -> 18688;
18717 -> 18711;
18717 -> 18688;
18718 -> 18684;
18719 -> 18717;
18719 -> 18718;
18719 -> 18684;
18720 -> 18719;
18720 -> 18684;
18721 -> 18720;
18722 -> 18721;
18723 -> 18722;
18723 -> 18721;
18724 -> 0;
18724 -> 18721;
18725 -> 0;
18725 -> 18721;
18726 -> 18721;
18727 -> 18723;
18727 -> 18726;
18728 -> 18724;
18728 -> 18726;
18729 -> 18725;
18729 -> 18726;
18730 -> 18726;
18730 -> 18729;
18730 -> 18618;
18731 -> 18730;
18732 -> 18624;
18732 -> 18708;
18732 -> 18731;
18733 -> 18732;
18733 -> 18730;
18734 -> 0;
18734 -> 18730;
18735 -> 18730;
18736 -> 18733;
18736 -> 18735;
18737 -> 18734;
18737 -> 18735;
18738 -> 18625;
18738 -> 18735;
18739 -> 18736;
18739 -> 18735;
18740 -> 18739;
18740 -> 18735;
18741 -> 18740;
18742 -> 18738;
18742 -> 18741;
18743 -> 18742;
18743 -> 18708;
18743 -> 0;
18743 -> 18741;
18744 -> 18742;
18744 -> 18743;
18745 -> 0;
18745 -> 18743;
18746 -> 18743;
18747 -> 18744;
18747 -> 18746;
18748 -> 18747;
18748 -> 18744;
18748 -> 18746;
18749 -> 18744;
18749 -> 18746;
18750 -> 18744;
18750 -> 18746;
18751 -> 18744;
18751 -> 18746;
18752 -> 18746;
18753 -> 18751;
18753 -> 18752;
18754 -> 18753;
18754 -> 18748;
18754 -> 18752;
18755 -> 18754;
18755 -> 18746;
18756 -> 18744;
18756 -> 18746;
18757 -> 18756;
18757 -> 18755;
18757 -> 18746;
18758 -> 18757;
18758 -> 18746;
18759 -> 18746;
18760 -> 18758;
18760 -> 18759;
18761 -> 18760;
18761 -> 18743;
18762 -> 0;
18762 -> 18761;
18763 -> 18762;
18763 -> 18742;
18763 -> 18743;
18764 -> 18742;
18764 -> 18760;
18764 -> 18763;
18764 -> 0;
18764 -> 18741;
18765 -> 18730;
18766 -> 18624;
18766 -> 18765;
18767 -> 18766;
18767 -> 18760;
18767 -> 18765;
18768 -> 18767;
18768 -> 18760;
18768 -> 18763;
18768 -> 18765;
18769 -> 18765;
18770 -> 18766;
18770 -> 18768;
18770 -> 18769;
18771 -> 18770;
18771 -> 18769;
18772 -> 18769;
18773 -> 18771;
18773 -> 18772;
18774 -> 18772;
18775 -> 18773;
18775 -> 18770;
18775 -> 18774;
18776 -> 18775;
18776 -> 18772;
18777 -> 18776;
18778 -> 18777;
18778 -> 18769;
18779 -> 18778;
18779 -> 18769;
18780 -> 18764;
18780 -> 18779;
18780 -> 18730;
18781 -> 18579;
18781 -> 17512;
18782 -> 17512;
18783 -> 18780;
18783 -> 18782;
18784 -> 18781;
18784 -> 18782;
18785 -> 18784;
18785 -> 18782;
18786 -> 18784;
18786 -> 18782;
18787 -> 18786;
18787 -> 18782;
18788 -> 18787;
18788 -> 18782;
18789 -> 0;
18790 -> 0;
18791 -> 0;
18792 -> 18791;
18794 -> 18789;
18794 -> 18790;
18794 -> 18792;
18794 -> 18793;
18795 -> 18794;
18796 -> 0;
18797 -> 0;
18798 -> 0;
18799 -> 18798;
18799 -> 0;
18800 -> 18799;
18802 -> 18796;
18802 -> 18797;
18802 -> 18800;
18802 -> 18801;
18803 -> 18802;
18804 -> 18783;
18804 -> 18788;
18805 -> 18788;
18806 -> 18804;
18806 -> 18805;
18807 -> 18788;
18807 -> 18805;
18808 -> 18788;
18808 -> 18805;
18809 -> 18807;
18809 -> 18805;
18810 -> 18807;
18810 -> 18805;
18811 -> 18808;
18811 -> 18805;
18812 -> 18806;
18812 -> 18811;
18813 -> 0;
18813 -> 18812;
18814 -> 18805;
18815 -> 18805;
18816 -> 18810;
18816 -> 18815;
18817 -> 18813;
18817 -> 18815;
18818 -> 18814;
18818 -> 18815;
18819 -> 18816;
18819 -> 18815;
18820 -> 18817;
18820 -> 0;
18820 -> 18815;
18821 -> 18817;
18821 -> 18815;
18822 -> 18816;
18822 -> 18821;
18827 -> 18823;
18827 -> 18826;
18828 -> 18824;
18828 -> 18826;
18829 -> 18825;
18829 -> 18826;
18830 -> 18826;
18831 -> 0;
18832 -> 18831;
18833 -> 0;
18834 -> 18833;
18835 -> 0;
18836 -> 18835;
18837 -> 0;
18838 -> 18837;
18839 -> 18821;
18840 -> 18822;
18840 -> 18839;
18841 -> 18839;
18842 -> 18840;
18842 -> 18841;
18843 -> 18841;
18844 -> 18842;
18844 -> 18843;
18845 -> 18843;
18846 -> 18844;
18846 -> 18845;
18847 -> 18846;
18847 -> 18843;
18848 -> 18847;
18848 -> 18841;
18849 -> 18848;
18849 -> 18839;
18850 -> 18839;
18851 -> 18849;
18851 -> 18850;
18852 -> 18816;
18852 -> 18815;
18853 -> 18817;
18853 -> 18815;
18854 -> 18818;
18854 -> 18815;
18855 -> 18815;
18856 -> 18852;
18856 -> 18855;
18857 -> 18853;
18857 -> 18855;
18858 -> 18854;
18858 -> 18855;
18859 -> 0;
18861 -> 18859;
18861 -> 18860;
18862 -> 18860;
18863 -> 18862;
18864 -> 18861;
18864 -> 0;
18864 -> 18860;
18865 -> 18861;
18865 -> 18862;
18865 -> 18860;
18866 -> 18860;
18867 -> 18856;
18867 -> 18855;
18868 -> 18857;
18868 -> 18855;
18869 -> 18858;
18869 -> 18855;
18870 -> 18855;
18871 -> 18869;
18871 -> 18870;
18872 -> 18871;
18872 -> 18854;
18872 -> 18870;
18873 -> 18866;
18873 -> 18872;
18874 -> 18855;
18875 -> 18855;
18876 -> 18867;
18876 -> 18875;
18877 -> 18868;
18877 -> 18875;
18878 -> 18873;
18878 -> 18875;
18879 -> 18874;
18879 -> 18875;
18880 -> 18876;
18880 -> 18875;
18881 -> 18880;
18881 -> 18875;
18882 -> 18876;
18882 -> 18881;
18883 -> 18881;
18884 -> 18882;
18884 -> 18883;
18885 -> 18883;
18886 -> 18884;
18886 -> 18885;
18887 -> 18885;
18888 -> 18886;
18888 -> 18887;
18889 -> 18887;
18890 -> 18888;
18890 -> 18889;
18891 -> 18890;
18891 -> 18887;
18892 -> 18891;
18892 -> 18885;
18893 -> 18892;
18893 -> 18883;
18894 -> 18883;
18895 -> 18893;
18895 -> 18894;
18896 -> 18894;
18897 -> 18895;
18897 -> 18780;
18897 -> 18896;
18898 -> 18877;
18898 -> 0;
18898 -> 18875;
18899 -> 18875;
18900 -> 18897;
18900 -> 18899;
18900 -> 18875;
18901 -> 18875;
18902 -> 18878;
18902 -> 18901;
18902 -> 18875;
18903 -> 18876;
18903 -> 18879;
18903 -> 18875;
18904 -> 18877;
18904 -> 18879;
18904 -> 18875;
18905 -> 18878;
18905 -> 18879;
18905 -> 18875;
18906 -> 18874;
18906 -> 18815;
18907 -> 18906;
18907 -> 18805;
18908 -> 18788;
18909 -> 18907;
18909 -> 18908;
18910 -> 18788;
18910 -> 18908;
18911 -> 18908;
18912 -> 18909;
18912 -> 18911;
18913 -> 18912;
18913 -> 18903;
18913 -> 18911;
18914 -> 18913;
18914 -> 18911;
18915 -> 18914;
18915 -> 18908;
18916 -> 18909;
18916 -> 18910;
18916 -> 18908;
18917 -> 18908;
18918 -> 18917;
18918 -> 18910;
18918 -> 18908;
18919 -> 18908;
18920 -> 18919;
18920 -> 18910;
18920 -> 18908;
18921 -> 17498;
18922 -> 18788;
18922 -> 18921;
18923 -> 18921;
18924 -> 18922;
18924 -> 18916;
18924 -> 18923;
18925 -> 18924;
18925 -> 18903;
18925 -> 18923;
18926 -> 18925;
18926 -> 18923;
18927 -> 18926;
18927 -> 18923;
18928 -> 18927;
18928 -> 18921;
18929 -> 18928;
18929 -> 17498;
18930 -> 18929;
18931 -> 18930;
18931 -> 18929;
18932 -> 18931;
18933 -> 18788;
18933 -> 18932;
18934 -> 18933;
18934 -> 18916;
18934 -> 18932;
18935 -> 18934;
18935 -> 18931;
18936 -> 17503;
18936 -> 18931;
18937 -> 17499;
18937 -> 18931;
18938 -> 17500;
18938 -> 18931;
18939 -> 18931;
18940 -> 18936;
18940 -> 18939;
18941 -> 18937;
18941 -> 18939;
18942 -> 18938;
18942 -> 18939;
18943 -> 18935;
18943 -> 18939;
18944 -> 18943;
18944 -> 18939;
18945 -> 18940;
18945 -> 18939;
18946 -> 18941;
18946 -> 18939;
18947 -> 18942;
18947 -> 18939;
18948 -> 18939;
18949 -> 18944;
18949 -> 18948;
18950 -> 18945;
18950 -> 18948;
18951 -> 18946;
18951 -> 18948;
18952 -> 18947;
18952 -> 18948;
18953 -> 18943;
18953 -> 18905;
18953 -> 18948;
18954 -> 18950;
18954 -> 18948;
18955 -> 18951;
18955 -> 18948;
18956 -> 18952;
18956 -> 18948;
18957 -> 18948;
18958 -> 18954;
18958 -> 18957;
18959 -> 18955;
18959 -> 18957;
18960 -> 18956;
18960 -> 18957;
18961 -> 18949;
18961 -> 18957;
18962 -> 18960;
18962 -> 18957;
18963 -> 18957;
18964 -> 18961;
18964 -> 18963;
18965 -> 18964;
18965 -> 18903;
18965 -> 18963;
18966 -> 18963;
18967 -> 18965;
18967 -> 18966;
18968 -> 18964;
18968 -> 18905;
18968 -> 18966;
18969 -> 18967;
18969 -> 18966;
18970 -> 18969;
18970 -> 18963;
18971 -> 18970;
18971 -> 18957;
18972 -> 18959;
18972 -> 18957;
18973 -> 18957;
18974 -> 18957;
18975 -> 18962;
18975 -> 18974;
18976 -> 18971;
18976 -> 18974;
18977 -> 18972;
18977 -> 18974;
18978 -> 18973;
18978 -> 18974;
18979 -> 18958;
18979 -> 18974;
18980 -> 18975;
18980 -> 18974;
18981 -> 18976;
18981 -> 18974;
18982 -> 18977;
18982 -> 18974;
18983 -> 18978;
18983 -> 18974;
18984 -> 18974;
18985 -> 18980;
18985 -> 18984;
18986 -> 18981;
18986 -> 18984;
18987 -> 18982;
18987 -> 18984;
18988 -> 18983;
18988 -> 18984;
18989 -> 18979;
18989 -> 18984;
18990 -> 18984;
18991 -> 18986;
18991 -> 18990;
18992 -> 18990;
18992 -> 18984;
18993 -> 18985;
18993 -> 18992;
18994 -> 18986;
18994 -> 18992;
18995 -> 18987;
18995 -> 18992;
18996 -> 18988;
18996 -> 18992;
18997 -> 18992;
18998 -> 18989;
18998 -> 18997;
18999 -> 18998;
18999 -> 18780;
18999 -> 18997;
19000 -> 18999;
19000 -> 18992;
19001 -> 18992;
19002 -> 18989;
19002 -> 19001;
19003 -> 19001;
19004 -> 19002;
19004 -> 19003;
19005 -> 19004;
19005 -> 18780;
19005 -> 19003;
19006 -> 19005;
19006 -> 19001;
19007 -> 19006;
19007 -> 19001;
19008 -> 19001;
19009 -> 19006;
19009 -> 19008;
19010 -> 19008;
19010 -> 19001;
19011 -> 19007;
19011 -> 19010;
19011 -> 19001;
19012 -> 19006;
19012 -> 19001;
19013 -> 19006;
19013 -> 19001;
19014 -> 19013;
19014 -> 18992;
19015 -> 18989;
19015 -> 18780;
19015 -> 18992;
19016 -> 18992;
19017 -> 18993;
19017 -> 19016;
19018 -> 18994;
19018 -> 19016;
19019 -> 18995;
19019 -> 19016;
19020 -> 18996;
19020 -> 19016;
19021 -> 19000;
19021 -> 19016;
19022 -> 19014;
19022 -> 19016;
19023 -> 19015;
19023 -> 19016;
19024 -> 19018;
19024 -> 19016;
19025 -> 19024;
19025 -> 18780;
19025 -> 19016;
19026 -> 19016;
19027 -> 19018;
19027 -> 19026;
19028 -> 19026;
19028 -> 19016;
19029 -> 19016;
19030 -> 19018;
19030 -> 19029;
19031 -> 19029;
19031 -> 19016;
19032 -> 19018;
19032 -> 19016;
19033 -> 19022;
19033 -> 19016;
19034 -> 19016;
19035 -> 19032;
19035 -> 19034;
19036 -> 19033;
19036 -> 19034;
19037 -> 19034;
19038 -> 19035;
19038 -> 19037;
19039 -> 19037;
19039 -> 19034;
19040 -> 19035;
19040 -> 19039;
19041 -> 19020;
19041 -> 19016;
19042 -> 19041;
19042 -> 19016;
19043 -> 19017;
19043 -> 19016;
19044 -> 19040;
19044 -> 19016;
19045 -> 19019;
19045 -> 19016;
19046 -> 19021;
19046 -> 19016;
19047 -> 19023;
19047 -> 19016;
19048 -> 19016;
19049 -> 19043;
19049 -> 19048;
19050 -> 19044;
19050 -> 19048;
19051 -> 19045;
19051 -> 19048;
19052 -> 19046;
19052 -> 19048;
19053 -> 19047;
19053 -> 19048;
19054 -> 19048;
19055 -> 19049;
19055 -> 19054;
19055 -> 19048;
19056 -> 19050;
19056 -> 19048;
19057 -> 19052;
19057 -> 19048;
19058 -> 19048;
19059 -> 19048;
19060 -> 19056;
19060 -> 19059;
19061 -> 19057;
19061 -> 19059;
19062 -> 19058;
19062 -> 19059;
19063 -> 19059;
19064 -> 19060;
19064 -> 19063;
19065 -> 19063;
19066 -> 19064;
19066 -> 19065;
19067 -> 19066;
19067 -> 19025;
19067 -> 19065;
19068 -> 19065;
19069 -> 19067;
19069 -> 19068;
19069 -> 19065;
19070 -> 19065;
19071 -> 19066;
19071 -> 19025;
19071 -> 19070;
19072 -> 19071;
19072 -> 19065;
19073 -> 19072;
19074 -> 19072;
19074 -> 19073;
19075 -> 19074;
19075 -> 19025;
19075 -> 0;
19075 -> 19073;
19076 -> 19073;
19077 -> 19075;
19077 -> 19072;
19078 -> 19065;
19079 -> 19078;
19079 -> 19063;
19080 -> 19063;
19081 -> 19079;
19081 -> 19080;
19081 -> 19063;
19082 -> 19081;
19082 -> 19063;
19083 -> 19082;
19083 -> 19059;
19084 -> 0;
19084 -> 19083;
19085 -> 19084;
19085 -> 19048;
19086 -> 19048;
19087 -> 19085;
19087 -> 19048;
19088 -> 19048;
19089 -> 19086;
19089 -> 19088;
19089 -> 19048;
19090 -> 19085;
19090 -> 19048;
19091 -> 19090;
19091 -> 19016;
19092 -> 19091;
19092 -> 19016;
19093 -> 19041;
19093 -> 19092;
19094 -> 18992;
19095 -> 18974;
19096 -> 18948;
19097 -> 18931;
19098 -> 18788;
19098 -> 18929;
19099 -> 19098;
19099 -> 17498;
19100 -> 17500;
19100 -> 17498;
19101 -> 17499;
19101 -> 17498;
19102 -> 17501;
19102 -> 17498;
19103 -> 17498;
19104 -> 19099;
19104 -> 19103;
19105 -> 19100;
19105 -> 19103;
19106 -> 19101;
19106 -> 19103;
19107 -> 19102;
19107 -> 19103;
19108 -> 17503;
19108 -> 19103;
19109 -> 19103;
19110 -> 19104;
19110 -> 19109;
19111 -> 19110;
19111 -> 18918;
19111 -> 19109;
19112 -> 19111;
19112 -> 0;
19112 -> 19109;
19113 -> 19112;
19113 -> 19103;
19114 -> 19104;
19114 -> 19103;
19115 -> 17498;
19116 -> 19114;
19116 -> 19115;
19117 -> 19116;
19117 -> 18916;
19117 -> 19115;
19118 -> 17482;
19119 -> 19117;
19119 -> 19118;
19120 -> 19119;
19120 -> 18903;
19120 -> 19118;
19121 -> 19118;
19122 -> 19120;
19122 -> 19121;
19123 -> 19119;
19123 -> 18905;
19123 -> 19121;
19124 -> 19121;
19125 -> 19122;
19125 -> 19124;
19126 -> 0;
19126 -> 19124;
19127 -> 19124;
19128 -> 19126;
19128 -> 19127;
19129 -> 19125;
19129 -> 19127;
19130 -> 19129;
19130 -> 19025;
19130 -> 19128;
19130 -> 19127;
19131 -> 19127;
19132 -> 19130;
19132 -> 19131;
19132 -> 19127;
19133 -> 19132;
19133 -> 17482;
19134 -> 17487;
19134 -> 17482;
19135 -> 19134;
19136 -> 17488;
19136 -> 19135;
19137 -> 19136;
19137 -> 19025;
19137 -> 19135;
19138 -> 0;
19138 -> 19135;
19139 -> 19135;
19140 -> 19137;
19140 -> 19139;
19141 -> 19138;
19141 -> 19139;
19142 -> 19140;
19142 -> 19134;
19143 -> 17484;
19143 -> 19142;
19144 -> 19117;
19144 -> 19142;
19145 -> 19142;
19146 -> 19142;
19147 -> 19144;
19147 -> 19146;
19148 -> 19145;
19148 -> 19146;
19149 -> 19146;
19150 -> 19148;
19150 -> 19149;
19151 -> 10513;
19151 -> 19149;
19152 -> 0;
19152 -> 19149;
19153 -> 19149;
19154 -> 19153;
19154 -> 19151;
19154 -> 19152;
19154 -> 19025;
19154 -> 19149;
19155 -> 19154;
19155 -> 19153;
19156 -> 0;
19156 -> 19154;
19157 -> 19153;
19157 -> 19149;
19158 -> 19147;
19158 -> 19148;
19158 -> 19146;
19159 -> 19142;
19160 -> 17483;
19160 -> 19156;
19160 -> 19159;
19161 -> 19160;
19161 -> 19156;
19161 -> 19157;
19161 -> 19158;
19161 -> 18903;
19161 -> 18904;
19161 -> 18905;
19161 -> 18865;
19161 -> 0;
19161 -> 19159;
19162 -> 19159;
19163 -> 19161;
19163 -> 19162;
19163 -> 19159;
19164 -> 19161;
19164 -> 19159;
19165 -> 19161;
19165 -> 19159;
19166 -> 19142;
19167 -> 19143;
19167 -> 19166;
19168 -> 19145;
19168 -> 19166;
19169 -> 19161;
19169 -> 19166;
19170 -> 19168;
19170 -> 19166;
19171 -> 19169;
19171 -> 19166;
19172 -> 19166;
19173 -> 19166;
19174 -> 19170;
19174 -> 19173;
19175 -> 19171;
19175 -> 19173;
19176 -> 19172;
19176 -> 19173;
19177 -> 19172;
19177 -> 19173;
19178 -> 19173;
19178 -> 19174;
19178 -> 19175;
19178 -> 19176;
19178 -> 19161;
19179 -> 19172;
19179 -> 19166;
19180 -> 19167;
19180 -> 19179;
19180 -> 19178;
19180 -> 19166;
19181 -> 17483;
19181 -> 19180;
19181 -> 17482;
19182 -> 17482;
19183 -> 19181;
19183 -> 19182;
19184 -> 19181;
19184 -> 19182;
19185 -> 19181;
19185 -> 19182;
19186 -> 19181;
19186 -> 19182;
19187 -> 17482;
19188 -> 17483;
19188 -> 19183;
19189 -> 19188;
19189 -> 19183;
19190 -> 19183;
19191 -> 19189;
19191 -> 19190;
19192 -> 19189;
19192 -> 19190;
19193 -> 19189;
19193 -> 19190;
19194 -> 19189;
19194 -> 19190;
19195 -> 19183;
19196 -> 19191;
19196 -> 19195;
19196 -> 19183;
19197 -> 17485;
19197 -> 19196;
19197 -> 19183;
19198 -> 19183;
19199 -> 19196;
19199 -> 19198;
19200 -> 19197;
19200 -> 19199;
19200 -> 19183;
19201 -> 19183;
19202 -> 17488;
19202 -> 19196;
19202 -> 19201;
19203 -> 19202;
19203 -> 19201;
19204 -> 19202;
19204 -> 19183;
19205 -> 19117;
19205 -> 19183;
19206 -> 19183;
19207 -> 19188;
19207 -> 19206;
19208 -> 19207;
19208 -> 19202;
19208 -> 19206;
19209 -> 19208;
19209 -> 19183;
19210 -> 19183;
19211 -> 19204;
19211 -> 19210;
19212 -> 19205;
19212 -> 19210;
19213 -> 19209;
19213 -> 19210;
19214 -> 19210;
19215 -> 19213;
19215 -> 19214;
19215 -> 19210;
19216 -> 19211;
19216 -> 19215;
19217 -> 19212;
19217 -> 19215;
19218 -> 19215;
19219 -> 19216;
19219 -> 19218;
19220 -> 19217;
19220 -> 19218;
19221 -> 19220;
19221 -> 19218;
19222 -> 0;
19222 -> 19218;
19223 -> 19218;
19224 -> 19222;
19224 -> 19223;
19225 -> 19219;
19225 -> 19223;
19226 -> 19223;
19227 -> 19225;
19227 -> 19226;
19228 -> 19227;
19228 -> 19223;
19229 -> 19224;
19229 -> 19223;
19230 -> 19223;
19231 -> 19229;
19231 -> 19230;
19232 -> 19228;
19232 -> 19230;
19233 -> 19230;
19234 -> 19232;
19234 -> 19233;
19235 -> 19234;
19235 -> 19230;
19236 -> 19235;
19237 -> 19235;
19237 -> 19236;
19238 -> 19236;
19239 -> 19237;
19239 -> 19238;
19240 -> 19238;
19241 -> 19239;
19241 -> 19202;
19241 -> 19240;
19241 -> 19238;
19242 -> 19236;
19243 -> 19237;
19243 -> 19202;
19243 -> 19236;
19244 -> 19243;
19244 -> 19235;
19245 -> 19235;
19246 -> 19230;
19247 -> 19232;
19247 -> 19202;
19247 -> 19246;
19247 -> 19230;
19248 -> 19231;
19248 -> 19247;
19249 -> 19247;
19250 -> 19247;
19251 -> 19250;
19251 -> 19247;
19252 -> 19247;
19253 -> 19248;
19253 -> 19247;
19254 -> 19247;
19255 -> 19253;
19255 -> 19254;
19256 -> 19251;
19256 -> 19254;
19257 -> 19254;
19258 -> 19254;
19259 -> 19256;
19259 -> 19258;
19260 -> 19259;
19260 -> 19254;
19261 -> 19255;
19261 -> 19248;
19261 -> 19254;
19262 -> 19254;
19263 -> 19261;
19263 -> 19262;
19264 -> 19260;
19264 -> 19262;
19265 -> 19264;
19265 -> 19262;
19266 -> 19263;
19266 -> 19262;
19267 -> 19266;
19268 -> 19266;
19269 -> 19266;
19270 -> 19268;
19270 -> 19269;
19271 -> 19265;
19271 -> 19269;
19272 -> 19269;
19273 -> 19271;
19273 -> 19251;
19273 -> 19270;
19273 -> 19269;
19274 -> 19270;
19274 -> 19273;
19275 -> 19269;
19275 -> 19273;
19276 -> 19273;
19276 -> 19274;
19277 -> 19276;
19278 -> 19276;
19279 -> 19277;
19279 -> 19278;
19279 -> 19276;
19280 -> 19279;
19281 -> 19267;
19281 -> 19280;
19281 -> 19279;
19282 -> 19277;
19282 -> 19279;
19283 -> 19282;
19283 -> 19266;
19284 -> 19266;
19285 -> 19283;
19285 -> 19284;
19285 -> 19266;
19286 -> 19283;
19286 -> 19262;
19287 -> 19254;
19288 -> 19286;
19288 -> 19287;
19288 -> 19254;
19289 -> 19255;
19289 -> 19288;
19290 -> 19288;
19291 -> 19289;
19291 -> 19290;
19292 -> 19286;
19292 -> 19290;
19293 -> 19291;
19293 -> 19248;
19293 -> 19290;
19294 -> 19292;
19294 -> 19290;
19295 -> 19290;
19296 -> 19294;
19296 -> 19295;
19297 -> 19295;
19297 -> 19290;
19298 -> 19290;
19299 -> 19290;
19300 -> 19299;
19300 -> 19290;
19301 -> 19290;
19302 -> 19294;
19302 -> 19301;
19303 -> 19302;
19303 -> 19301;
19304 -> 19301;
19304 -> 19290;
19305 -> 0;
19305 -> 19290;
19306 -> 19290;
19307 -> 19305;
19307 -> 19306;
19308 -> 19294;
19308 -> 19306;
19309 -> 19306;
19310 -> 19308;
19310 -> 19309;
19311 -> 19310;
19311 -> 19276;
19311 -> 19274;
19311 -> 19309;
19312 -> 19310;
19312 -> 19276;
19312 -> 19274;
19312 -> 19311;
19313 -> 19311;
19314 -> 19310;
19314 -> 19313;
19315 -> 19314;
19315 -> 19313;
19316 -> 19313;
19317 -> 19313;
19318 -> 19315;
19318 -> 19317;
19319 -> 19316;
19319 -> 19317;
19320 -> 19317;
19321 -> 19319;
19321 -> 19320;
19322 -> 19320;
19323 -> 19321;
19323 -> 19322;
19324 -> 19319;
19324 -> 19317;
19325 -> 19318;
19325 -> 19317;
19326 -> 19318;
19326 -> 19319;
19326 -> 19317;
19327 -> 19316;
19327 -> 19311;
19328 -> 19311;
19329 -> 19312;
19329 -> 19327;
19329 -> 19328;
19329 -> 19326;
19329 -> 19274;
19329 -> 19276;
19329 -> 19311;
19330 -> 19310;
19330 -> 19329;
19330 -> 19309;
19331 -> 19330;
19331 -> 19306;
19332 -> 19307;
19332 -> 19306;
19333 -> 19306;
19334 -> 19331;
19334 -> 19333;
19335 -> 19332;
19335 -> 19333;
19336 -> 19334;
19336 -> 19333;
19337 -> 19335;
19337 -> 19333;
19338 -> 19333;
19339 -> 19336;
19339 -> 19338;
19340 -> 19337;
19340 -> 19338;
19341 -> 19340;
19341 -> 19338;
19342 -> 19339;
19342 -> 19338;
19343 -> 19338;
19344 -> 19341;
19344 -> 19338;
19345 -> 19338;
19346 -> 19342;
19346 -> 19345;
19347 -> 19343;
19347 -> 19345;
19348 -> 19343;
19348 -> 19345;
19349 -> 19344;
19349 -> 19345;
19350 -> 19343;
19350 -> 19345;
19351 -> 19345;
19352 -> 19346;
19352 -> 19351;
19352 -> 19345;
19353 -> 19350;
19353 -> 19345;
19354 -> 19353;
19355 -> 19347;
19355 -> 19354;
19355 -> 19353;
19356 -> 19353;
19357 -> 19348;
19357 -> 19356;
19357 -> 19353;
19358 -> 19346;
19358 -> 19345;
19359 -> 19345;
19361 -> 19360;
19363 -> 19362;
19364 -> 19359;
19364 -> 19345;
19365 -> 19349;
19365 -> 19345;
19366 -> 19347;
19366 -> 19345;
19367 -> 19348;
19367 -> 19345;
19368 -> 19345;
19369 -> 19345;
19370 -> 19364;
19370 -> 19369;
19371 -> 19365;
19371 -> 19369;
19372 -> 19366;
19372 -> 19369;
19373 -> 19367;
19373 -> 19369;
19374 -> 19368;
19374 -> 19369;
19375 -> 19370;
19375 -> 19369;
19376 -> 19371;
19376 -> 19369;
19377 -> 19369;
19378 -> 19372;
19378 -> 19369;
19379 -> 19373;
19379 -> 19369;
19380 -> 19369;
19381 -> 19380;
19381 -> 19375;
19381 -> 19376;
19381 -> 19377;
19381 -> 19378;
19381 -> 19379;
19381 -> 19359;
19381 -> 0;
19381 -> 19369;
19382 -> 19380;
19382 -> 19369;
19383 -> 19380;
19383 -> 19369;
19384 -> 19371;
19384 -> 19381;
19384 -> 19369;
19385 -> 0;
19385 -> 19369;
19386 -> 19384;
19386 -> 19380;
19386 -> 19369;
19387 -> 19368;
19387 -> 19345;
19388 -> 19345;
19389 -> 19387;
19389 -> 19388;
19390 -> 19346;
19390 -> 19388;
19391 -> 19389;
19391 -> 19388;
19392 -> 19388;
19393 -> 19391;
19393 -> 19392;
19394 -> 19390;
19394 -> 19392;
19395 -> 19394;
19395 -> 19392;
19396 -> 19392;
19397 -> 19395;
19397 -> 19396;
19398 -> 19393;
19398 -> 19396;
19399 -> 19398;
19399 -> 19381;
19399 -> 19396;
19400 -> 19398;
19400 -> 19381;
19400 -> 19382;
19400 -> 19386;
19400 -> 19383;
19400 -> 19396;
19401 -> 0;
19401 -> 19396;
19402 -> 19398;
19402 -> 19381;
19402 -> 19382;
19402 -> 19386;
19402 -> 19383;
19402 -> 0;
19402 -> 19396;
19403 -> 19402;
19404 -> 19397;
19404 -> 19403;
19405 -> 19403;
19406 -> 19404;
19406 -> 19405;
19407 -> 19406;
19407 -> 19329;
19407 -> 19405;
19408 -> 19403;
19409 -> 19407;
19409 -> 19408;
19410 -> 19408;
19411 -> 19409;
19411 -> 19410;
19412 -> 19411;
19412 -> 19329;
19412 -> 19410;
19413 -> 19412;
19413 -> 19408;
19414 -> 19408;
19415 -> 19413;
19416 -> 19413;
19417 -> 19415;
19417 -> 19416;
19417 -> 19413;
19418 -> 19415;
19418 -> 19417;
19419 -> 19403;
19420 -> 19418;
19420 -> 19419;
19421 -> 19420;
19421 -> 19419;
19422 -> 19419;
19423 -> 19421;
19423 -> 19422;
19424 -> 19422;
19425 -> 19423;
19425 -> 19424;
19426 -> 19425;
19427 -> 19426;
19428 -> 19425;
19429 -> 19425;
19430 -> 19425;
19430 -> 19422;
19431 -> 19430;
19431 -> 19402;
19432 -> 19431;
19432 -> 19402;
19433 -> 19402;
19434 -> 19432;
19434 -> 19433;
19435 -> 19398;
19435 -> 19433;
19436 -> 19434;
19436 -> 19433;
19437 -> 19433;
19438 -> 19436;
19438 -> 19437;
19438 -> 19433;
19439 -> 19435;
19439 -> 19381;
19439 -> 19382;
19439 -> 19386;
19439 -> 19383;
19439 -> 0;
19439 -> 19433;
19440 -> 19433;
19441 -> 19436;
19441 -> 19440;
19442 -> 19440;
19443 -> 19441;
19443 -> 19425;
19443 -> 19442;
19444 -> 19442;
19444 -> 19433;
19445 -> 19435;
19445 -> 19381;
19445 -> 19382;
19445 -> 19386;
19445 -> 19383;
19445 -> 0;
19445 -> 19433;
19446 -> 19444;
19446 -> 19445;
19446 -> 19433;
19447 -> 19446;
19447 -> 19402;
19448 -> 19396;
19449 -> 19397;
19449 -> 19448;
19450 -> 19448;
19451 -> 19449;
19451 -> 19425;
19451 -> 19450;
19452 -> 19450;
19453 -> 19452;
19453 -> 19396;
19454 -> 0;
19454 -> 19453;
19455 -> 19397;
19455 -> 19453;
19456 -> 19453;
19457 -> 19397;
19457 -> 19456;
19458 -> 19456;
19459 -> 19457;
19459 -> 19458;
19460 -> 19459;
19460 -> 19425;
19460 -> 19458;
19461 -> 19456;
19462 -> 19460;
19462 -> 19461;
19463 -> 19462;
19463 -> 19453;
19464 -> 19453;
19465 -> 19454;
19465 -> 19464;
19466 -> 19455;
19466 -> 19464;
19467 -> 19463;
19467 -> 19464;
19468 -> 19398;
19468 -> 19464;
19469 -> 19464;
19470 -> 19467;
19470 -> 19469;
19470 -> 19464;
19471 -> 19470;
19471 -> 19464;
19472 -> 19468;
19472 -> 19381;
19472 -> 19382;
19472 -> 19386;
19472 -> 19471;
19473 -> 19472;
19473 -> 19471;
19474 -> 19465;
19474 -> 19464;
19475 -> 19466;
19475 -> 19464;
19476 -> 19473;
19476 -> 19464;
19477 -> 19474;
19477 -> 19475;
19477 -> 19476;
19477 -> 19425;
19477 -> 19464;
19478 -> 19392;
19479 -> 19388;
19480 -> 19345;
19481 -> 19359;
19481 -> 19477;
19481 -> 19345;
19482 -> 19481;
19482 -> 19291;
19482 -> 19248;
19482 -> 19290;
19483 -> 19304;
19483 -> 19482;
19483 -> 19290;
19484 -> 19291;
19484 -> 19248;
19484 -> 19290;
19485 -> 19291;
19485 -> 19248;
19485 -> 19484;
19486 -> 19484;
19487 -> 19291;
19487 -> 19248;
19487 -> 19290;
19488 -> 19291;
19488 -> 19248;
19488 -> 19290;
19489 -> 19488;
19490 -> 19489;
19491 -> 19487;
19491 -> 19490;
19491 -> 19489;
19492 -> 19491;
19493 -> 19291;
19493 -> 19248;
19493 -> 19290;
19494 -> 19290;
19495 -> 19493;
19495 -> 19494;
19496 -> 19294;
19496 -> 19494;
19497 -> 19494;
19498 -> 19496;
19498 -> 19497;
19499 -> 19498;
19499 -> 19481;
19499 -> 19497;
19500 -> 19497;
19501 -> 19498;
19501 -> 19481;
19501 -> 19500;
19501 -> 19497;
19502 -> 19501;
19503 -> 19499;
19503 -> 19502;
19503 -> 19501;
19504 -> 19499;
19504 -> 19501;
19505 -> 19501;
19506 -> 19504;
19506 -> 19505;
19507 -> 19505;
19508 -> 19506;
19508 -> 19507;
19508 -> 19505;
19509 -> 19505;
19510 -> 19505;
19511 -> 19505;
19511 -> 19510;
19512 -> 19510;
19513 -> 19511;
19513 -> 19512;
19514 -> 19513;
19514 -> 19510;
19515 -> 19510;
19516 -> 19511;
19516 -> 19515;
19517 -> 19516;
19517 -> 19510;
19518 -> 19510;
19519 -> 19517;
19519 -> 19518;
19520 -> 19518;
19520 -> 19510;
19521 -> 19510;
19522 -> 19514;
19522 -> 19510;
19523 -> 19505;
19523 -> 19522;
19523 -> 19506;
19523 -> 19481;
19524 -> 19523;
19525 -> 19523;
19526 -> 19523;
19527 -> 19523;
19528 -> 19523;
19529 -> 19523;
19530 -> 19505;
19530 -> 19523;
19531 -> 19523;
19532 -> 19530;
19532 -> 19523;
19532 -> 19531;
19533 -> 19532;
19533 -> 19523;
19534 -> 19523;
19535 -> 19533;
19536 -> 19533;
19537 -> 19533;
19538 -> 19533;
19539 -> 19533;
19540 -> 19533;
19541 -> 19533;
19542 -> 19541;
19542 -> 19533;
19543 -> 19542;
19543 -> 19533;
19544 -> 19533;
19545 -> 19533;
19546 -> 19533;
19547 -> 19533;
19548 -> 19533;
19549 -> 19533;
19550 -> 19533;
19551 -> 19533;
19552 -> 19533;
19553 -> 19533;
19554 -> 19533;
19555 -> 0;
19555 -> 19533;
19556 -> 0;
19556 -> 19533;
19557 -> 19533;
19557 -> 19556;
19558 -> 19557;
19558 -> 19533;
19558 -> 19556;
19559 -> 19553;
19559 -> 19533;
19560 -> 19533;
19561 -> 19539;
19561 -> 19560;
19561 -> 19533;
19562 -> 19558;
19563 -> 19558;
19564 -> 19558;
19565 -> 19558;
19566 -> 19558;
19567 -> 19558;
19568 -> 19558;
19569 -> 19568;
19569 -> 19558;
19570 -> 19569;
19570 -> 19558;
19571 -> 19558;
19572 -> 19558;
19573 -> 19558;
19574 -> 19558;
19575 -> 19558;
19576 -> 19558;
19577 -> 19558;
19578 -> 19558;
19579 -> 19558;
19580 -> 19558;
19581 -> 19558;
19582 -> 0;
19582 -> 19558;
19583 -> 19580;
19583 -> 19558;
19584 -> 19558;
19585 -> 19566;
19585 -> 19584;
19585 -> 19558;
19586 -> 16009;
19586 -> 19558;
19587 -> 19586;
19588 -> 19586;
19589 -> 19586;
19590 -> 19586;
19591 -> 19586;
19592 -> 19586;
19593 -> 19586;
19594 -> 19593;
19594 -> 19586;
19595 -> 19594;
19595 -> 19586;
19596 -> 19586;
19597 -> 19586;
19598 -> 19586;
19599 -> 19586;
19600 -> 19586;
19601 -> 19586;
19602 -> 19586;
19603 -> 19586;
19604 -> 19586;
19605 -> 19586;
19606 -> 19586;
19607 -> 0;
19607 -> 19586;
19608 -> 19605;
19608 -> 19586;
19609 -> 19586;
19610 -> 19591;
19610 -> 19609;
19610 -> 19586;
19611 -> 19586;
19612 -> 19611;
19612 -> 19586;
19613 -> 19612;
19613 -> 19586;
19614 -> 19586;
19615 -> 19586;
19616 -> 19586;
19617 -> 19586;
19618 -> 19523;
19619 -> 19534;
19619 -> 19618;
19619 -> 19523;
19620 -> 19586;
19621 -> 19586;
19622 -> 19586;
19623 -> 19586;
19624 -> 19586;
19624 -> 19623;
19625 -> 19624;
19625 -> 19586;
19625 -> 19623;
19626 -> 19625;
19626 -> 19586;
19627 -> 19620;
19627 -> 19626;
19627 -> 19586;
19628 -> 19586;
19628 -> 19627;
19629 -> 19627;
19630 -> 19628;
19630 -> 19629;
19631 -> 19586;
19631 -> 19629;
19632 -> 19629;
19633 -> 19630;
19633 -> 19632;
19634 -> 19633;
19634 -> 19629;
19635 -> 19634;
19635 -> 16009;
19635 -> 19629;
19636 -> 19629;
19637 -> 19630;
19637 -> 19636;
19638 -> 19637;
19638 -> 19636;
19639 -> 19638;
19639 -> 19586;
19639 -> 19636;
19640 -> 19639;
19641 -> 19639;
19642 -> 19640;
19642 -> 19641;
19643 -> 19642;
19643 -> 19639;
19644 -> 19639;
19645 -> 19643;
19645 -> 19644;
19646 -> 19645;
19646 -> 19629;
19647 -> 19631;
19647 -> 19629;
19648 -> 19646;
19648 -> 19647;
19648 -> 19629;
19649 -> 19629;
19650 -> 19630;
19650 -> 19649;
19651 -> 19649;
19652 -> 19650;
19652 -> 19651;
19653 -> 19652;
19653 -> 19586;
19653 -> 19651;
19654 -> 19651;
19655 -> 19653;
19655 -> 19654;
19656 -> 19654;
19656 -> 19651;
19657 -> 19651;
19658 -> 19653;
19658 -> 19657;
19659 -> 19658;
19659 -> 19651;
19660 -> 19659;
19660 -> 19649;
19661 -> 19660;
19661 -> 19629;
19662 -> 19629;
19663 -> 19661;
19663 -> 19662;
19664 -> 19663;
19664 -> 19586;
19664 -> 19662;
19665 -> 19629;
19666 -> 19629;
19667 -> 19631;
19667 -> 19666;
19668 -> 19667;
19668 -> 19629;
19669 -> 19631;
19669 -> 19629;
19670 -> 19629;
19671 -> 19631;
19671 -> 19586;
19671 -> 19670;
19671 -> 19629;
19672 -> 19631;
19672 -> 19586;
19672 -> 19671;
19673 -> 19671;
19674 -> 19631;
19674 -> 19672;
19674 -> 19634;
19674 -> 19629;
19675 -> 19630;
19675 -> 19629;
19676 -> 19629;
19677 -> 19631;
19677 -> 19674;
19678 -> 19674;
19679 -> 19631;
19679 -> 19674;
19679 -> 19677;
19679 -> 19678;
19680 -> 19631;
19680 -> 19674;
19680 -> 19677;
19680 -> 0;
19681 -> 19627;
19682 -> 19627;
19683 -> 19586;
19683 -> 19674;
19683 -> 19682;
19684 -> 19683;
19684 -> 19674;
19684 -> 19677;
19684 -> 0;
19684 -> 19682;
19685 -> 19684;
19685 -> 19627;
19686 -> 19677;
19687 -> 19677;
19688 -> 19685;
19688 -> 16009;
19689 -> 19685;
19690 -> 19689;
19691 -> 19690;
19691 -> 19677;
19691 -> 19689;
19692 -> 19691;
19693 -> 19691;
19694 -> 19692;
19694 -> 19693;
19695 -> 19694;
19695 -> 19691;
19696 -> 19691;
19697 -> 19695;
19697 -> 19696;
19698 -> 19697;
19698 -> 19685;
19699 -> 19685;
19700 -> 19685;
19701 -> 19685;
19701 -> 19700;
19702 -> 19700;
19703 -> 19701;
19703 -> 19702;
19704 -> 19703;
19704 -> 19677;
19704 -> 19702;
19705 -> 19702;
19706 -> 19704;
19706 -> 19705;
19707 -> 19705;
19707 -> 19702;
19708 -> 19702;
19709 -> 19704;
19709 -> 19708;
19710 -> 19709;
19710 -> 19702;
19711 -> 19710;
19711 -> 19700;
19712 -> 19711;
19712 -> 19685;
19713 -> 19685;
19714 -> 19712;
19714 -> 19713;
19715 -> 19714;
19715 -> 19677;
19715 -> 19713;
19716 -> 19685;
19717 -> 19685;
19718 -> 19717;
19718 -> 19685;
19719 -> 19685;
19720 -> 19685;
19721 -> 19685;
19721 -> 0;
19722 -> 19685;
19723 -> 19685;
19724 -> 19717;
19724 -> 16009;
19725 -> 19717;
19726 -> 19725;
19727 -> 19726;
19727 -> 19685;
19727 -> 19725;
19728 -> 19727;
19729 -> 19727;
19730 -> 19728;
19730 -> 19729;
19731 -> 19730;
19731 -> 19727;
19732 -> 19727;
19733 -> 19731;
19733 -> 19732;
19734 -> 19733;
19734 -> 19717;
19735 -> 19717;
19736 -> 19717;
19737 -> 19717;
19737 -> 19736;
19738 -> 19736;
19739 -> 19737;
19739 -> 19738;
19740 -> 19739;
19740 -> 19685;
19740 -> 19738;
19741 -> 19738;
19742 -> 19740;
19742 -> 19741;
19743 -> 19741;
19743 -> 19738;
19744 -> 19738;
19745 -> 19740;
19745 -> 19744;
19746 -> 19745;
19746 -> 19738;
19747 -> 19746;
19747 -> 19736;
19748 -> 19747;
19748 -> 19717;
19749 -> 19717;
19750 -> 19748;
19750 -> 19749;
19751 -> 19750;
19751 -> 19685;
19751 -> 19749;
19752 -> 19717;
19753 -> 19717;
19754 -> 19717;
19755 -> 19717;
19755 -> 0;
19756 -> 19717;
19757 -> 19717;
19758 -> 19726;
19758 -> 19717;
19758 -> 19725;
19759 -> 19758;
19760 -> 19758;
19761 -> 19759;
19761 -> 19760;
19762 -> 19761;
19762 -> 19758;
19763 -> 19758;
19764 -> 19762;
19764 -> 19763;
19765 -> 19764;
19765 -> 19717;
19766 -> 19739;
19766 -> 19717;
19766 -> 19738;
19767 -> 19766;
19767 -> 19741;
19768 -> 19766;
19768 -> 19744;
19769 -> 19768;
19769 -> 19738;
19770 -> 19769;
19770 -> 19736;
19771 -> 19770;
19771 -> 19717;
19772 -> 19771;
19772 -> 19749;
19773 -> 19772;
19773 -> 19717;
19773 -> 19749;
19774 -> 19501;
19775 -> 19498;
19775 -> 19717;
19775 -> 19501;
19776 -> 19501;
19777 -> 19494;
19778 -> 19494;
19779 -> 19778;
19779 -> 19494;
19780 -> 19495;
19780 -> 19494;
19781 -> 19778;
19781 -> 19494;
19782 -> 19496;
19782 -> 19775;
19782 -> 19780;
19782 -> 19781;
19782 -> 19779;
19782 -> 19494;
19783 -> 19782;
19783 -> 19494;
19784 -> 19783;
19784 -> 19290;
19785 -> 19784;
19786 -> 19784;
19786 -> 19785;
19787 -> 19785;
19788 -> 19787;
19788 -> 19784;
19789 -> 19784;
19790 -> 19492;
19790 -> 19789;
19790 -> 19784;
19791 -> 19784;
19792 -> 19784;
19792 -> 19791;
19793 -> 19791;
19794 -> 19793;
19794 -> 19784;
19795 -> 19492;
19795 -> 19794;
19795 -> 19784;
19796 -> 19788;
19796 -> 19795;
19796 -> 19784;
19797 -> 19796;
19798 -> 19298;
19798 -> 19797;
19798 -> 19796;
19799 -> 19784;
19799 -> 19796;
19800 -> 19290;
19801 -> 19799;
19801 -> 19800;
19801 -> 19290;
19802 -> 19799;
19802 -> 19290;
19803 -> 19254;
19804 -> 19802;
19804 -> 19803;
19804 -> 19254;
19805 -> 19802;
19805 -> 19254;
19806 -> 19247;
19807 -> 19805;
19807 -> 19806;
19808 -> 19806;
19808 -> 19247;
19809 -> 19247;
19810 -> 19805;
19810 -> 19809;
19811 -> 0;
19811 -> 19809;
19812 -> 19810;
19812 -> 19247;
19813 -> 19808;
19813 -> 19812;
19813 -> 19247;
19814 -> 19805;
19814 -> 19247;
19815 -> 19247;
19816 -> 19814;
19816 -> 19815;
19817 -> 19232;
19817 -> 19815;
19818 -> 19815;
19819 -> 19816;
19819 -> 16009;
19819 -> 19815;
19820 -> 19815;
19821 -> 19816;
19821 -> 19820;
19822 -> 19821;
19822 -> 19820;
19823 -> 19822;
19823 -> 19783;
19823 -> 19820;
19824 -> 19823;
19825 -> 19823;
19826 -> 19824;
19826 -> 19825;
19827 -> 19826;
19827 -> 19823;
19828 -> 19823;
19829 -> 19827;
19829 -> 19828;
19830 -> 19829;
19830 -> 19815;
19831 -> 19817;
19831 -> 19815;
19832 -> 19815;
19833 -> 19816;
19833 -> 19832;
19834 -> 19832;
19835 -> 19833;
19835 -> 19834;
19836 -> 19835;
19836 -> 19783;
19836 -> 19834;
19837 -> 19834;
19838 -> 19836;
19838 -> 19837;
19839 -> 19837;
19839 -> 19834;
19840 -> 19834;
19841 -> 19836;
19841 -> 19840;
19842 -> 19840;
19843 -> 19841;
19843 -> 19834;
19844 -> 19843;
19844 -> 19832;
19845 -> 19844;
19845 -> 19815;
19846 -> 19815;
19847 -> 19845;
19847 -> 19846;
19848 -> 19847;
19848 -> 19783;
19848 -> 19846;
19849 -> 19815;
19850 -> 19815;
19851 -> 19817;
19851 -> 19850;
19852 -> 19851;
19852 -> 19783;
19852 -> 19850;
19853 -> 19852;
19853 -> 19815;
19854 -> 19817;
19854 -> 19815;
19855 -> 19815;
19856 -> 19817;
19856 -> 19783;
19856 -> 19855;
19856 -> 19815;
19857 -> 19815;
19858 -> 19816;
19859 -> 19817;
19859 -> 19816;
19860 -> 19247;
19861 -> 19232;
19861 -> 19816;
19861 -> 19231;
19861 -> 19230;
19862 -> 19219;
19862 -> 19218;
19863 -> 19218;
19864 -> 19221;
19864 -> 19863;
19865 -> 19862;
19865 -> 19863;
19866 -> 19863;
19867 -> 0;
19867 -> 19863;
19868 -> 19863;
19869 -> 19867;
19869 -> 19868;
19870 -> 19865;
19870 -> 19868;
19871 -> 19868;
19872 -> 19870;
19872 -> 19871;
19873 -> 19872;
19873 -> 19816;
19873 -> 19871;
19874 -> 19869;
19874 -> 19868;
19875 -> 19868;
19876 -> 19874;
19876 -> 19875;
19877 -> 19875;
19878 -> 19873;
19878 -> 19877;
19879 -> 19878;
19879 -> 19875;
19880 -> 19879;
19881 -> 19879;
19881 -> 19880;
19882 -> 19880;
19883 -> 19881;
19883 -> 19882;
19884 -> 19882;
19885 -> 19883;
19885 -> 19816;
19885 -> 19884;
19885 -> 19882;
19886 -> 19880;
19887 -> 19881;
19887 -> 19816;
19887 -> 19880;
19888 -> 19887;
19888 -> 19879;
19889 -> 19879;
19890 -> 19875;
19891 -> 19873;
19891 -> 19816;
19891 -> 19876;
19891 -> 19875;
19892 -> 19891;
19893 -> 19891;
19894 -> 19891;
19895 -> 19891;
19896 -> 19893;
19896 -> 19895;
19896 -> 19891;
19897 -> 19891;
19898 -> 19891;
19899 -> 19891;
19900 -> 19891;
19901 -> 19891;
19902 -> 19901;
19902 -> 19891;
19903 -> 19891;
19904 -> 19902;
19904 -> 19903;
19905 -> 19903;
19905 -> 19891;
19906 -> 19891;
19907 -> 19905;
19908 -> 19902;
19908 -> 19907;
19909 -> 19908;
19909 -> 19905;
19910 -> 19905;
19911 -> 19905;
19912 -> 19902;
19912 -> 19911;
19913 -> 19912;
19913 -> 19905;
19914 -> 19913;
19914 -> 19903;
19915 -> 19909;
19916 -> 19909;
19917 -> 19909;
19918 -> 19909;
19919 -> 19909;
19920 -> 19909;
19921 -> 19909;
19922 -> 19909;
19923 -> 19909;
19924 -> 19909;
19925 -> 19909;
19926 -> 19909;
19927 -> 19909;
19928 -> 19909;
19929 -> 19928;
19929 -> 19909;
19930 -> 19929;
19930 -> 19909;
19931 -> 19909;
19932 -> 19909;
19933 -> 19909;
19934 -> 19909;
19935 -> 19909;
19936 -> 19909;
19937 -> 19909;
19938 -> 19909;
19939 -> 19909;
19940 -> 19909;
19941 -> 19909;
19942 -> 0;
19942 -> 19909;
19943 -> 19940;
19943 -> 19909;
19944 -> 19909;
19945 -> 19926;
19945 -> 19944;
19945 -> 19909;
19946 -> 19909;
19947 -> 19921;
19947 -> 19946;
19947 -> 19909;
19948 -> 19909;
19949 -> 19909;
19950 -> 19909;
19950 -> 16009;
19951 -> 19909;
19952 -> 19951;
19953 -> 19952;
19953 -> 19909;
19953 -> 19951;
19954 -> 19953;
19955 -> 19953;
19956 -> 19954;
19956 -> 19955;
19957 -> 19956;
19957 -> 19953;
19958 -> 19953;
19959 -> 19957;
19959 -> 19958;
19960 -> 19959;
19960 -> 19909;
19961 -> 19909;
19962 -> 19909;
19963 -> 19909;
19963 -> 19962;
19964 -> 19962;
19965 -> 19963;
19965 -> 19964;
19966 -> 19965;
19966 -> 19909;
19966 -> 19964;
19967 -> 19964;
19968 -> 19966;
19968 -> 19967;
19969 -> 19967;
19969 -> 19964;
19970 -> 19964;
19971 -> 19966;
19971 -> 19970;
19972 -> 19971;
19972 -> 19964;
19973 -> 19972;
19973 -> 19962;
19974 -> 19973;
19974 -> 19909;
19975 -> 19909;
19976 -> 19974;
19976 -> 19975;
19977 -> 19976;
19977 -> 19909;
19977 -> 19975;
19978 -> 19909;
19979 -> 19909;
19980 -> 19909;
19981 -> 19909;
19981 -> 0;
19982 -> 19909;
19983 -> 19893;
19983 -> 19982;
19983 -> 19909;
19984 -> 19909;
19984 -> 19897;
19984 -> 19891;
19985 -> 19909;
19985 -> 19891;
19986 -> 19909;
19987 -> 19909;
19987 -> 19986;
19988 -> 19986;
19988 -> 19909;
19989 -> 19909;
19990 -> 19909;
19991 -> 19990;
19991 -> 19909;
19992 -> 19909;
19993 -> 19909;
19993 -> 19992;
19994 -> 19993;
19994 -> 19992;
19995 -> 19992;
19995 -> 19909;
19996 -> 19909;
19997 -> 19996;
19998 -> 19909;
19999 -> 19909;
20000 -> 19909;
20001 -> 19909;
20002 -> 20000;
20002 -> 19909;
20003 -> 20002;
20004 -> 20002;
20005 -> 19909;
20006 -> 19909;
20007 -> 19909;
20008 -> 0;
20008 -> 19909;
20009 -> 19909;
20010 -> 20009;
20010 -> 19909;
20011 -> 20010;
20011 -> 19909;
20012 -> 19909;
20013 -> 20011;
20013 -> 20012;
20014 -> 19909;
20014 -> 20012;
20015 -> 20013;
20015 -> 20012;
20016 -> 20012;
20017 -> 20015;
20017 -> 20016;
20017 -> 20012;
20018 -> 20014;
20018 -> 19909;
20018 -> 0;
20018 -> 20012;
20019 -> 20012;
20020 -> 20015;
20020 -> 20019;
20021 -> 20020;
20021 -> 19909;
20021 -> 20019;
20022 -> 20019;
20022 -> 20012;
20023 -> 20022;
20023 -> 19909;
20024 -> 19909;
20024 -> 20023;
20025 -> 20023;
20026 -> 20024;
20026 -> 20025;
20027 -> 20024;
20027 -> 20025;
20028 -> 20027;
20028 -> 20024;
20028 -> 20025;
20029 -> 20025;
20030 -> 20026;
20030 -> 20025;
20031 -> 20025;
20032 -> 20028;
20032 -> 20031;
20033 -> 20028;
20033 -> 20031;
20034 -> 20028;
20034 -> 20031;
20035 -> 20028;
20035 -> 20031;
20036 -> 20028;
20036 -> 20031;
20037 -> 20028;
20037 -> 20031;
20038 -> 20029;
20038 -> 20031;
20039 -> 20030;
20039 -> 20031;
20040 -> 20029;
20040 -> 20031;
20041 -> 20032;
20041 -> 20031;
20042 -> 20033;
20042 -> 20031;
20043 -> 20038;
20043 -> 20031;
20044 -> 20034;
20044 -> 20031;
20045 -> 20035;
20045 -> 20031;
20046 -> 20039;
20046 -> 20031;
20047 -> 20031;
20048 -> 20047;
20048 -> 20041;
20048 -> 20042;
20048 -> 20043;
20048 -> 20044;
20048 -> 20045;
20048 -> 20046;
20048 -> 20024;
20048 -> 20031;
20049 -> 20036;
20049 -> 20047;
20049 -> 20031;
20050 -> 20037;
20050 -> 20047;
20050 -> 20031;
20051 -> 20029;
20051 -> 20023;
20052 -> 20024;
20052 -> 20051;
20052 -> 20048;
20052 -> 20047;
20052 -> 20049;
20052 -> 20050;
20052 -> 20023;
20053 -> 20023;
20054 -> 20052;
20054 -> 20053;
20055 -> 20010;
20055 -> 20053;
20056 -> 20054;
20056 -> 20052;
20056 -> 20053;
20057 -> 20054;
20057 -> 20052;
20057 -> 20053;
20058 -> 20055;
20058 -> 20054;
20059 -> 20058;
20059 -> 20054;
20060 -> 20054;
20061 -> 20059;
20061 -> 20054;
20062 -> 20054;
20063 -> 20061;
20063 -> 20062;
20063 -> 20054;
20064 -> 20060;
20064 -> 20052;
20064 -> 0;
20064 -> 20054;
20065 -> 20061;
20065 -> 20054;
20066 -> 20065;
20066 -> 20052;
20066 -> 20054;
20067 -> 20054;
20067 -> 20052;
20068 -> 20054;
20068 -> 20052;
20069 -> 20065;
20069 -> 20052;
20069 -> 20054;
20070 -> 20058;
20070 -> 20054;
20071 -> 20070;
20071 -> 20052;
20071 -> 20054;
20072 -> 20054;
20073 -> 20058;
20073 -> 20072;
20074 -> 20073;
20074 -> 20058;
20074 -> 20072;
20075 -> 20072;
20075 -> 20054;
20076 -> 20054;
20077 -> 20075;
20077 -> 20076;
20078 -> 20054;
20078 -> 20076;
20079 -> 0;
20079 -> 20076;
20080 -> 20076;
20081 -> 20077;
20081 -> 20076;
20082 -> 20076;
20083 -> 20081;
20083 -> 20082;
20084 -> 20076;
20085 -> 20079;
20085 -> 20084;
20086 -> 20080;
20086 -> 20084;
20087 -> 20083;
20087 -> 20084;
20088 -> 20078;
20088 -> 20084;
20089 -> 20088;
20089 -> 20058;
20089 -> 20087;
20090 -> 20054;
20091 -> 20055;
20091 -> 20053;
20092 -> 20091;
20092 -> 20089;
20092 -> 20053;
20093 -> 20023;
20094 -> 20023;
20095 -> 20010;
20095 -> 20094;
20096 -> 20095;
20096 -> 20089;
20096 -> 20094;
20097 -> 20094;
20097 -> 20023;
20098 -> 20023;
20099 -> 20075;
20099 -> 20098;
20100 -> 19909;
20100 -> 20098;
20101 -> 0;
20101 -> 20098;
20102 -> 20098;
20103 -> 20099;
20103 -> 20098;
20104 -> 20098;
20105 -> 20103;
20105 -> 20104;
20106 -> 20098;
20107 -> 20101;
20107 -> 20106;
20108 -> 20102;
20108 -> 20106;
20109 -> 20105;
20109 -> 20106;
20110 -> 20100;
20110 -> 20106;
20111 -> 20023;
20112 -> 19909;
20113 -> 20112;
20113 -> 20089;
20113 -> 19909;
20114 -> 19995;
20114 -> 20089;
20114 -> 19909;
20115 -> 19909;
20115 -> 19891;
20116 -> 19909;
20116 -> 19891;
20116 -> 20115;
20117 -> 20115;
20118 -> 20115;
20119 -> 19909;
20119 -> 19891;
20119 -> 20118;
20120 -> 20118;
20121 -> 20119;
20121 -> 20120;
20122 -> 20120;
20122 -> 20089;
20123 -> 20120;
20123 -> 20089;
20124 -> 20123;
20125 -> 20123;
20126 -> 20123;
20127 -> 20123;
20128 -> 20127;
20128 -> 20123;
20129 -> 20128;
20129 -> 20123;
20130 -> 20128;
20130 -> 20123;
20131 -> 20128;
20132 -> 20128;
20133 -> 20128;
20134 -> 20128;
20135 -> 20128;
20136 -> 20128;
20137 -> 20128;
20138 -> 20128;
20139 -> 20138;
20139 -> 20128;
20140 -> 20139;
20140 -> 20128;
20141 -> 20128;
20142 -> 20128;
20143 -> 20128;
20144 -> 20128;
20145 -> 20128;
20146 -> 20128;
20147 -> 20128;
20148 -> 20128;
20149 -> 20128;
20150 -> 20128;
20151 -> 20128;
20152 -> 0;
20152 -> 20128;
20153 -> 20150;
20153 -> 20128;
20154 -> 20128;
20155 -> 20128;
20156 -> 20128;
20157 -> 20128;
20158 -> 20136;
20158 -> 20157;
20158 -> 20128;
20159 -> 20128;
20160 -> 20159;
20160 -> 20128;
20161 -> 20160;
20161 -> 20128;
20162 -> 20128;
20163 -> 20128;
20164 -> 20131;
20164 -> 20163;
20164 -> 20128;
20165 -> 20128;
20166 -> 20128;
20167 -> 20128;
20167 -> 16009;
20168 -> 20128;
20169 -> 20168;
20170 -> 20169;
20170 -> 20128;
20170 -> 20168;
20171 -> 20170;
20172 -> 20170;
20173 -> 20171;
20173 -> 20172;
20174 -> 20173;
20174 -> 20170;
20175 -> 20170;
20176 -> 20174;
20176 -> 20175;
20177 -> 20176;
20177 -> 20128;
20178 -> 20128;
20179 -> 20128;
20180 -> 20128;
20180 -> 20179;
20181 -> 20179;
20182 -> 20180;
20182 -> 20181;
20183 -> 20182;
20183 -> 20128;
20183 -> 20181;
20184 -> 20181;
20185 -> 20183;
20185 -> 20184;
20186 -> 20184;
20186 -> 20181;
20187 -> 20181;
20188 -> 20183;
20188 -> 20187;
20189 -> 20188;
20189 -> 20181;
20190 -> 20189;
20190 -> 20179;
20191 -> 20190;
20191 -> 20128;
20192 -> 20128;
20193 -> 20191;
20193 -> 20192;
20194 -> 20193;
20194 -> 20128;
20194 -> 20192;
20195 -> 20128;
20196 -> 20128;
20197 -> 20128;
20198 -> 20128;
20198 -> 0;
20199 -> 20120;
20200 -> 20120;
20200 -> 20128;
20200 -> 20121;
20201 -> 20200;
20201 -> 20118;
20202 -> 20201;
20203 -> 20201;
20203 -> 20202;
20204 -> 20203;
20204 -> 20200;
20204 -> 20202;
20205 -> 20204;
20205 -> 20201;
20206 -> 20201;
20207 -> 20201;
20207 -> 20206;
20208 -> 20207;
20208 -> 20200;
20208 -> 20206;
20209 -> 20208;
20209 -> 20201;
20210 -> 20205;
20210 -> 20209;
20210 -> 20201;
20211 -> 20210;
20212 -> 19989;
20212 -> 20211;
20212 -> 20210;
20213 -> 20201;
20213 -> 20210;
20214 -> 19909;
20215 -> 20213;
20215 -> 20214;
20215 -> 19909;
20216 -> 19891;
20217 -> 20213;
20217 -> 20216;
20217 -> 19891;
20218 -> 19891;
20219 -> 20213;
20219 -> 20218;
20220 -> 20218;
20220 -> 19891;
20221 -> 19891;
20222 -> 20213;
20222 -> 20221;
20223 -> 0;
20223 -> 20221;
20224 -> 20222;
20224 -> 19891;
20225 -> 20220;
20225 -> 20224;
20225 -> 19891;
20226 -> 20213;
20226 -> 16009;
20226 -> 19891;
20227 -> 19891;
20228 -> 20213;
20228 -> 20227;
20229 -> 20228;
20229 -> 20227;
20230 -> 20229;
20230 -> 20200;
20230 -> 20227;
20231 -> 20230;
20232 -> 20230;
20233 -> 20231;
20233 -> 20232;
20234 -> 20233;
20234 -> 20230;
20235 -> 20230;
20236 -> 20234;
20236 -> 20235;
20237 -> 20236;
20237 -> 19891;
20238 -> 19891;
20239 -> 19891;
20240 -> 20213;
20240 -> 20239;
20241 -> 20239;
20242 -> 20240;
20242 -> 20241;
20243 -> 20242;
20243 -> 20200;
20243 -> 20241;
20244 -> 20241;
20245 -> 20243;
20245 -> 20244;
20246 -> 20244;
20246 -> 20241;
20247 -> 20241;
20248 -> 20243;
20248 -> 20247;
20249 -> 20248;
20249 -> 20241;
20250 -> 20249;
20250 -> 20239;
20251 -> 20250;
20251 -> 19891;
20252 -> 19891;
20253 -> 20251;
20253 -> 20252;
20254 -> 20253;
20254 -> 20200;
20254 -> 20252;
20255 -> 19891;
20256 -> 20200;
20256 -> 19891;
20257 -> 19891;
20258 -> 20213;
20259 -> 19891;
20259 -> 20213;
20260 -> 19873;
20260 -> 20213;
20260 -> 19876;
20260 -> 19875;
20261 -> 20260;
20261 -> 19863;
20262 -> 19863;
20263 -> 20261;
20263 -> 20262;
20264 -> 20262;
20265 -> 20263;
20265 -> 20264;
20265 -> 20262;
20266 -> 20262;
20267 -> 20263;
20267 -> 20266;
20268 -> 20266;
20268 -> 20262;
20269 -> 20268;
20269 -> 19863;
20270 -> 20260;
20270 -> 20269;
20271 -> 19864;
20271 -> 20269;
20272 -> 20271;
20272 -> 18903;
20272 -> 18904;
20272 -> 18905;
20272 -> 20213;
20272 -> 20269;
20273 -> 20269;
20274 -> 20269;
20275 -> 20270;
20275 -> 20274;
20276 -> 20272;
20276 -> 20274;
20277 -> 20273;
20277 -> 20274;
20278 -> 20273;
20278 -> 20274;
20279 -> 20273;
20279 -> 20274;
20280 -> 20274;
20281 -> 20275;
20281 -> 20280;
20282 -> 20281;
20282 -> 20213;
20282 -> 20280;
20283 -> 20274;
20284 -> 20275;
20284 -> 20283;
20285 -> 20284;
20285 -> 20213;
20285 -> 20283;
20286 -> 20274;
20287 -> 20275;
20287 -> 20286;
20288 -> 20274;
20289 -> 20287;
20289 -> 20288;
20290 -> 20288;
20291 -> 20289;
20291 -> 20290;
20292 -> 20291;
20292 -> 20213;
20292 -> 20290;
20293 -> 20292;
20294 -> 20291;
20294 -> 20293;
20295 -> 20294;
20295 -> 20213;
20295 -> 20293;
20296 -> 20293;
20297 -> 20295;
20297 -> 20296;
20298 -> 20296;
20298 -> 20293;
20299 -> 20293;
20300 -> 20295;
20300 -> 20299;
20301 -> 20300;
20301 -> 20293;
20302 -> 20301;
20302 -> 20292;
20303 -> 20291;
20303 -> 20213;
20303 -> 20292;
20304 -> 20291;
20304 -> 20213;
20304 -> 20292;
20305 -> 20292;
20306 -> 20305;
20306 -> 20304;
20306 -> 20292;
20307 -> 20302;
20307 -> 20306;
20308 -> 20291;
20308 -> 20306;
20309 -> 20305;
20309 -> 20306;
20310 -> 20303;
20310 -> 20305;
20310 -> 20306;
20311 -> 20306;
20312 -> 20306;
20313 -> 20307;
20313 -> 20312;
20314 -> 20308;
20314 -> 20312;
20315 -> 20309;
20315 -> 20312;
20316 -> 20310;
20316 -> 20312;
20317 -> 20311;
20317 -> 20312;
20318 -> 20313;
20318 -> 20312;
20319 -> 20314;
20319 -> 20312;
20320 -> 20315;
20320 -> 20312;
20321 -> 20316;
20321 -> 20312;
20322 -> 20312;
20323 -> 20318;
20323 -> 20322;
20324 -> 20319;
20324 -> 20322;
20325 -> 20320;
20325 -> 20322;
20326 -> 20321;
20326 -> 20322;
20327 -> 20317;
20327 -> 20322;
20328 -> 20322;
20329 -> 20327;
20329 -> 20328;
20330 -> 20328;
20331 -> 20329;
20331 -> 20328;
20332 -> 20327;
20332 -> 20322;
20333 -> 20327;
20333 -> 20322;
20334 -> 20327;
20334 -> 20322;
20335 -> 14214;
20335 -> 20327;
20335 -> 20322;
20336 -> 20327;
20336 -> 20322;
20337 -> 20327;
20337 -> 20322;
20339 -> 20338;
20340 -> 20339;
20340 -> 20338;
20341 -> 20339;
20341 -> 20338;
20342 -> 20338;
20343 -> 20342;
20343 -> 20339;
20343 -> 20338;
20344 -> 20338;
20345 -> 20344;
20345 -> 20339;
20345 -> 20338;
20346 -> 20338;
20347 -> 20346;
20347 -> 20327;
20347 -> 20322;
20348 -> 20322;
20349 -> 20323;
20349 -> 20348;
20349 -> 20322;
20350 -> 20322;
20351 -> 20324;
20351 -> 20350;
20351 -> 20322;
20352 -> 20322;
20353 -> 20325;
20353 -> 20352;
20353 -> 20322;
20354 -> 20326;
20354 -> 20310;
20354 -> 20322;
20355 -> 20324;
20355 -> 20327;
20355 -> 20322;
20356 -> 20322;
20357 -> 20322;
20358 -> 20323;
20358 -> 20357;
20359 -> 20358;
20359 -> 20310;
20359 -> 20357;
20360 -> 20359;
20360 -> 20322;
20361 -> 20326;
20361 -> 20322;
20362 -> 20327;
20362 -> 20333;
20362 -> 20322;
20363 -> 20356;
20363 -> 20322;
20364 -> 20360;
20364 -> 20361;
20364 -> 20362;
20364 -> 20363;
20364 -> 20310;
20364 -> 20322;
20365 -> 20364;
20365 -> 0;
20365 -> 20322;
20366 -> 20322;
20367 -> 20365;
20367 -> 20322;
20368 -> 20367;
20368 -> 20327;
20368 -> 20322;
20369 -> 20325;
20369 -> 20327;
20369 -> 20322;
20370 -> 20326;
20370 -> 20327;
20370 -> 20322;
20371 -> 20311;
20371 -> 20305;
20371 -> 20304;
20371 -> 20306;
20372 -> 20291;
20372 -> 20364;
20372 -> 20292;
20373 -> 20304;
20373 -> 20292;
20374 -> 20373;
20374 -> 20304;
20374 -> 20371;
20374 -> 20329;
20374 -> 20331;
20374 -> 20355;
20374 -> 20364;
20374 -> 20369;
20374 -> 20335;
20374 -> 20368;
20374 -> 20337;
20374 -> 20347;
20374 -> 20370;
20374 -> 20343;
20374 -> 20345;
20374 -> 20310;
20374 -> 20292;
20375 -> 20288;
20376 -> 20289;
20376 -> 20374;
20376 -> 20288;
20378 -> 20377;
20379 -> 0;
20380 -> 20379;
20380 -> 0;
20381 -> 20380;
20383 -> 20382;
20384 -> 20381;
20384 -> 20382;
20385 -> 20384;
20385 -> 20383;
20386 -> 20383;
20387 -> 20386;
20388 -> 20386;
20388 -> 20383;
20389 -> 20385;
20389 -> 20386;
20389 -> 20383;
20390 -> 20381;
20390 -> 20382;
20391 -> 20382;
20392 -> 20276;
20392 -> 20274;
20393 -> 20274;
20394 -> 20285;
20394 -> 20393;
20395 -> 20376;
20395 -> 20393;
20396 -> 20392;
20396 -> 20393;
20397 -> 20393;
20398 -> 20394;
20398 -> 20393;
20399 -> 20393;
20400 -> 20398;
20400 -> 20399;
20401 -> 20400;
20401 -> 20399;
20402 -> 20399;
20403 -> 20401;
20403 -> 20402;
20403 -> 20399;
20404 -> 20403;
20404 -> 20399;
20405 -> 20404;
20405 -> 20390;
20406 -> 20405;
20406 -> 20397;
20407 -> 20397;
20408 -> 20407;
20409 -> 20407;
20409 -> 20397;
20410 -> 20406;
20410 -> 20407;
20410 -> 20397;
20411 -> 20393;
20412 -> 20411;
20412 -> 20395;
20412 -> 20374;
20412 -> 20393;
20413 -> 20395;
20413 -> 20411;
20413 -> 20374;
20413 -> 20412;
20414 -> 20396;
20414 -> 20411;
20414 -> 20213;
20414 -> 18903;
20414 -> 18904;
20414 -> 18905;
20414 -> 20272;
20414 -> 20413;
20414 -> 20412;
20415 -> 20413;
20415 -> 20412;
20416 -> 20412;
20417 -> 20415;
20417 -> 20416;
20418 -> 20414;
20418 -> 20416;
20420 -> 20419;
20422 -> 20421;
20424 -> 20423;
20425 -> 20418;
20425 -> 20414;
20425 -> 20416;
20426 -> 20416;
20427 -> 20425;
20427 -> 20426;
20428 -> 20427;
20428 -> 18813;
20428 -> 20426;
20429 -> 20418;
20429 -> 20414;
20429 -> 20417;
20429 -> 20416;
20430 -> 20428;
20430 -> 20429;
20430 -> 20416;
20431 -> 20413;
20431 -> 20430;
20432 -> 20414;
20432 -> 20430;
20433 -> 20397;
20433 -> 20410;
20433 -> 20431;
20433 -> 20432;
20433 -> 20405;
20433 -> 20414;
20433 -> 20430;
20434 -> 20274;
20435 -> 20275;
20435 -> 20434;
20436 -> 0;
20437 -> 20275;
20437 -> 20274;
20438 -> 20277;
20438 -> 20274;
20439 -> 20278;
20439 -> 20274;
20440 -> 20274;
20441 -> 20282;
20441 -> 20440;
20442 -> 20393;
20442 -> 20440;
20443 -> 20435;
20443 -> 20440;
20444 -> 20437;
20444 -> 20440;
20445 -> 20438;
20445 -> 20440;
20446 -> 20439;
20446 -> 20440;
20447 -> 20279;
20447 -> 20440;
20448 -> 20443;
20448 -> 20440;
20449 -> 20446;
20449 -> 20440;
20450 -> 20440;
20451 -> 20448;
20451 -> 20450;
20452 -> 20449;
20452 -> 20450;
20453 -> 20447;
20453 -> 20450;
20454 -> 20452;
20454 -> 20450;
20455 -> 20450;
20456 -> 20454;
20456 -> 20455;
20457 -> 20453;
20457 -> 20455;
20458 -> 20453;
20458 -> 20450;
20459 -> 20450;
20460 -> 20451;
20460 -> 20459;
20460 -> 20450;
20461 -> 20451;
20461 -> 20453;
20461 -> 20450;
20462 -> 20447;
20462 -> 20440;
20463 -> 20447;
20463 -> 20440;
20464 -> 20447;
20464 -> 20440;
20465 -> 20447;
20465 -> 20440;
20466 -> 20447;
20466 -> 20440;
20467 -> 20447;
20467 -> 20440;
20468 -> 20440;
20469 -> 20443;
20469 -> 20468;
20470 -> 20468;
20471 -> 20469;
20471 -> 20470;
20472 -> 20470;
20473 -> 20471;
20473 -> 20472;
20474 -> 20472;
20475 -> 20473;
20475 -> 20474;
20476 -> 20474;
20477 -> 20475;
20477 -> 20476;
20478 -> 20477;
20478 -> 20474;
20479 -> 20478;
20479 -> 20472;
20480 -> 20479;
20480 -> 20470;
20481 -> 20480;
20481 -> 20468;
20482 -> 20481;
20482 -> 20440;
20483 -> 20443;
20483 -> 20440;
20484 -> 20440;
20485 -> 20483;
20485 -> 20484;
20486 -> 20484;
20487 -> 20485;
20487 -> 20486;
20487 -> 20484;
20488 -> 20485;
20488 -> 20484;
20489 -> 20484;
20489 -> 20440;
20490 -> 20441;
20490 -> 20447;
20490 -> 20440;
20491 -> 20442;
20491 -> 20447;
20491 -> 20440;
20492 -> 20445;
20492 -> 20447;
20492 -> 20440;
20493 -> 20440;
20494 -> 20444;
20494 -> 20493;
20494 -> 20440;
20495 -> 20494;
20496 -> 20444;
20496 -> 20495;
20497 -> 20496;
20497 -> 20495;
20498 -> 20497;
20498 -> 20494;
20499 -> 20444;
20499 -> 20494;
20500 -> 20494;
20501 -> 20444;
20501 -> 20500;
20502 -> 20500;
20503 -> 20501;
20503 -> 20502;
20504 -> 20503;
20504 -> 20433;
20504 -> 20502;
20505 -> 20500;
20506 -> 20501;
20506 -> 20433;
20506 -> 20500;
20507 -> 20506;
20507 -> 20494;
20508 -> 20507;
20508 -> 20447;
20508 -> 20494;
20509 -> 20442;
20509 -> 20447;
20509 -> 20494;
20510 -> 20279;
20510 -> 20274;
20511 -> 20276;
20511 -> 20279;
20511 -> 20274;
20512 -> 20275;
20512 -> 20279;
20512 -> 20274;
20513 -> 20274;
20514 -> 20275;
20514 -> 20513;
20515 -> 20514;
20515 -> 20433;
20515 -> 20513;
20516 -> 20515;
20516 -> 20274;
20517 -> 20274;
20518 -> 20275;
20518 -> 20517;
20519 -> 20518;
20519 -> 20433;
20519 -> 20517;
20520 -> 20519;
20520 -> 20274;
20521 -> 20274;
20522 -> 19866;
20522 -> 20273;
20522 -> 20453;
20522 -> 20456;
20522 -> 20461;
20522 -> 20492;
20522 -> 20491;
20522 -> 20490;
20522 -> 20509;
20522 -> 20466;
20522 -> 20467;
20522 -> 20508;
20522 -> 20512;
20522 -> 20511;
20522 -> 20433;
20522 -> 20410;
20522 -> 20213;
20522 -> 18903;
20522 -> 18904;
20522 -> 18905;
20522 -> 20272;
20522 -> 20269;
20523 -> 0;
20523 -> 19863;
20524 -> 19863;
20525 -> 20523;
20525 -> 20524;
20526 -> 19865;
20526 -> 20524;
20527 -> 20524;
20528 -> 20526;
20528 -> 20527;
20529 -> 20528;
20529 -> 20522;
20529 -> 20527;
20530 -> 20525;
20530 -> 20524;
20531 -> 20524;
20532 -> 20530;
20532 -> 20531;
20533 -> 20531;
20534 -> 20529;
20534 -> 20533;
20535 -> 20534;
20535 -> 20531;
20536 -> 20535;
20537 -> 20535;
20537 -> 20536;
20538 -> 20536;
20539 -> 20537;
20539 -> 20538;
20540 -> 20538;
20541 -> 20539;
20541 -> 20522;
20541 -> 20540;
20541 -> 20538;
20542 -> 20536;
20543 -> 20537;
20543 -> 20522;
20543 -> 20536;
20544 -> 20543;
20544 -> 20535;
20545 -> 20535;
20546 -> 20531;
20547 -> 20529;
20547 -> 20522;
20547 -> 20532;
20547 -> 20531;
20548 -> 20529;
20548 -> 20522;
20548 -> 20532;
20548 -> 20531;
20549 -> 20548;
20549 -> 19863;
20550 -> 19863;
20551 -> 20549;
20551 -> 20550;
20552 -> 20550;
20553 -> 20551;
20553 -> 20552;
20553 -> 20550;
20554 -> 20550;
20555 -> 20551;
20555 -> 20554;
20556 -> 20554;
20556 -> 20550;
20557 -> 20556;
20557 -> 19863;
20558 -> 20548;
20558 -> 20557;
20559 -> 19864;
20559 -> 20557;
20560 -> 20559;
20560 -> 18903;
20560 -> 18904;
20560 -> 18905;
20560 -> 20522;
20560 -> 20557;
20561 -> 20557;
20562 -> 20557;
20563 -> 20558;
20563 -> 20562;
20564 -> 20560;
20564 -> 20562;
20565 -> 20561;
20565 -> 20562;
20566 -> 20561;
20566 -> 20562;
20567 -> 20561;
20567 -> 20562;
20568 -> 20562;
20569 -> 20562;
20570 -> 20562;
20571 -> 20562;
20572 -> 20571;
20573 -> 20563;
20574 -> 20563;
20574 -> 20573;
20575 -> 20573;
20575 -> 20563;
20576 -> 20563;
20577 -> 20563;
20578 -> 20563;
20579 -> 20563;
20580 -> 20563;
20581 -> 20563;
20582 -> 20563;
20583 -> 20571;
20584 -> 20562;
20585 -> 20584;
20586 -> 20584;
20587 -> 20586;
20588 -> 20585;
20589 -> 20588;
20590 -> 20588;
20590 -> 20585;
20591 -> 20584;
20592 -> 20562;
20593 -> 20565;
20593 -> 20562;
20594 -> 20566;
20594 -> 20562;
20595 -> 20562;
20596 -> 20584;
20596 -> 20595;
20597 -> 20593;
20597 -> 20595;
20598 -> 20594;
20598 -> 20595;
20599 -> 20567;
20599 -> 20595;
20600 -> 20598;
20600 -> 20595;
20601 -> 20595;
20602 -> 20600;
20602 -> 20601;
20603 -> 20599;
20603 -> 20601;
20604 -> 20602;
20604 -> 20601;
20605 -> 20601;
20606 -> 20604;
20606 -> 20605;
20607 -> 20603;
20607 -> 20605;
20608 -> 20603;
20608 -> 20601;
20609 -> 20601;
20610 -> 20563;
20610 -> 20609;
20610 -> 20601;
20611 -> 20599;
20611 -> 20595;
20612 -> 20599;
20612 -> 20595;
20613 -> 20599;
20613 -> 20595;
20614 -> 20599;
20614 -> 20595;
20615 -> 20599;
20615 -> 20595;
20616 -> 20599;
20616 -> 20595;
20617 -> 20595;
20618 -> 20563;
20618 -> 20617;
20619 -> 20617;
20620 -> 20618;
20620 -> 20619;
20621 -> 20619;
20622 -> 20620;
20622 -> 20621;
20623 -> 20621;
20624 -> 20622;
20624 -> 20623;
20625 -> 20623;
20626 -> 20624;
20626 -> 20625;
20627 -> 20626;
20627 -> 20623;
20628 -> 20627;
20628 -> 20621;
20629 -> 20628;
20629 -> 20619;
20630 -> 20629;
20630 -> 20617;
20631 -> 20630;
20631 -> 20595;
20632 -> 20563;
20632 -> 20595;
20633 -> 20595;
20634 -> 20632;
20634 -> 20633;
20635 -> 20633;
20636 -> 20634;
20636 -> 20635;
20636 -> 20633;
20637 -> 20634;
20637 -> 20633;
20638 -> 20633;
20638 -> 20595;
20639 -> 20596;
20639 -> 20599;
20639 -> 20595;
20640 -> 20597;
20640 -> 20599;
20640 -> 20595;
20641 -> 20595;
20642 -> 20563;
20643 -> 20563;
20643 -> 20642;
20644 -> 20643;
20644 -> 20642;
20645 -> 20644;
20645 -> 20563;
20646 -> 20563;
20647 -> 20563;
20648 -> 20567;
20648 -> 20562;
20649 -> 20562;
20650 -> 20563;
20650 -> 20649;
20651 -> 20650;
20651 -> 20562;
20652 -> 20562;
20653 -> 20563;
20653 -> 20652;
20654 -> 20653;
20654 -> 20562;
20655 -> 20562;
20656 -> 19866;
20656 -> 20563;
20656 -> 19863;
20657 -> 19218;
20658 -> 19221;
20658 -> 20657;
20659 -> 19861;
20659 -> 20657;
20660 -> 20656;
20660 -> 20657;
20661 -> 20658;
20661 -> 20657;
20662 -> 20659;
20662 -> 20657;
20663 -> 20660;
20663 -> 20657;
20664 -> 20657;
20665 -> 20657;
20666 -> 20661;
20666 -> 20665;
20667 -> 20662;
20667 -> 20665;
20668 -> 20663;
20668 -> 20665;
20669 -> 20664;
20669 -> 20665;
20670 -> 20666;
20670 -> 20665;
20671 -> 20667;
20671 -> 20665;
20672 -> 20665;
20673 -> 20670;
20673 -> 20672;
20674 -> 20671;
20674 -> 20672;
20675 -> 20669;
20675 -> 20672;
20676 -> 20672;
20677 -> 20675;
20677 -> 20672;
20678 -> 20675;
20678 -> 20672;
20679 -> 20672;
20680 -> 20673;
20680 -> 20679;
20681 -> 20680;
20681 -> 18903;
20681 -> 20679;
20682 -> 20681;
20682 -> 20679;
20683 -> 20682;
20683 -> 20672;
20684 -> 20672;
20685 -> 20674;
20685 -> 20684;
20685 -> 20672;
20686 -> 20673;
20686 -> 20675;
20686 -> 20672;
20687 -> 20674;
20687 -> 20675;
20687 -> 20672;
20688 -> 20665;
20689 -> 20668;
20689 -> 20656;
20689 -> 20688;
20689 -> 20665;
20690 -> 20668;
20690 -> 20669;
20690 -> 20665;
20691 -> 20664;
20691 -> 19218;
20692 -> 20691;
20692 -> 19215;
20693 -> 19188;
20693 -> 20563;
20693 -> 19183;
20694 -> 19183;
20695 -> 20693;
20695 -> 20694;
20696 -> 20694;
20696 -> 19183;
20697 -> 20693;
20697 -> 20696;
20697 -> 19183;
20698 -> 19183;
20699 -> 20697;
20699 -> 20698;
20700 -> 20698;
20701 -> 20698;
20702 -> 20699;
20702 -> 20698;
20703 -> 20698;
20704 -> 20702;
20704 -> 20703;
20704 -> 20698;
20705 -> 20698;
20706 -> 20699;
20706 -> 20705;
20706 -> 20698;
20707 -> 20698;
20708 -> 20699;
20708 -> 20707;
20708 -> 20698;
20709 -> 20698;
20710 -> 20699;
20710 -> 20709;
20710 -> 20698;
20711 -> 20699;
20711 -> 20698;
20712 -> 20698;
20713 -> 20699;
20713 -> 20712;
20713 -> 20698;
20714 -> 20699;
20715 -> 20714;
20715 -> 20699;
20716 -> 0;
20716 -> 20699;
20717 -> 20699;
20718 -> 20692;
20718 -> 19183;
20719 -> 19183;
20720 -> 19183;
20721 -> 20699;
20721 -> 20720;
20722 -> 20718;
20722 -> 20720;
20723 -> 20719;
20723 -> 20720;
20724 -> 20722;
20724 -> 20720;
20725 -> 20722;
20725 -> 20720;
20726 -> 20721;
20726 -> 0;
20726 -> 20720;
20727 -> 20721;
20727 -> 20720;
20728 -> 20722;
20728 -> 20727;
20729 -> 20727;
20730 -> 20728;
20730 -> 20729;
20731 -> 20729;
20732 -> 20730;
20732 -> 20731;
20733 -> 20731;
20734 -> 20732;
20734 -> 20733;
20735 -> 20734;
20735 -> 20733;
20736 -> 20735;
20736 -> 20731;
20737 -> 20736;
20737 -> 20729;
20738 -> 20729;
20739 -> 20737;
20739 -> 20738;
20740 -> 16009;
20740 -> 20738;
20741 -> 20740;
20741 -> 20729;
20742 -> 20741;
20742 -> 20727;
20743 -> 20728;
20743 -> 20742;
20743 -> 20727;
20744 -> 20722;
20744 -> 20720;
20745 -> 20744;
20745 -> 20720;
20746 -> 20722;
20746 -> 20745;
20747 -> 20745;
20748 -> 20746;
20748 -> 20747;
20749 -> 20747;
20750 -> 20748;
20750 -> 20749;
20751 -> 20749;
20752 -> 20750;
20752 -> 20751;
20753 -> 20752;
20753 -> 20751;
20754 -> 20753;
20754 -> 20749;
20755 -> 20754;
20755 -> 20747;
20756 -> 20747;
20757 -> 20755;
20757 -> 20756;
20758 -> 16009;
20758 -> 20756;
20759 -> 20758;
20759 -> 20747;
20760 -> 20759;
20760 -> 20745;
20761 -> 20721;
20761 -> 0;
20761 -> 20720;
20762 -> 20720;
20763 -> 20760;
20763 -> 20762;
20763 -> 20720;
20764 -> 20720;
20765 -> 20720;
20765 -> 19183;
20766 -> 20765;
20766 -> 17482;
20767 -> 20766;
20767 -> 17482;
20768 -> 20767;
20768 -> 17482;
20769 -> 17482;
20770 -> 17482;
20771 -> 20768;
20771 -> 20770;
20772 -> 20769;
20772 -> 20770;
20773 -> 20770;
20774 -> 20771;
20774 -> 20773;
20775 -> 20774;
20775 -> 20722;
20775 -> 20773;
20776 -> 20775;
20776 -> 20773;
20777 -> 20776;
20777 -> 20770;
20778 -> 20770;
20779 -> 20778;
20779 -> 20772;
20779 -> 20770;
20780 -> 20770;
20781 -> 20780;
20781 -> 20772;
20781 -> 20770;
20782 -> 20769;
20782 -> 17477;
20783 -> 17456;
20784 -> 20782;
20784 -> 20783;
20785 -> 20783;
20786 -> 20771;
20786 -> 20722;
20786 -> 20785;
20787 -> 20786;
20788 -> 20786;
20789 -> 20786;
20790 -> 20787;
20790 -> 20786;
20791 -> 20788;
20791 -> 20786;
20792 -> 20789;
20792 -> 20786;
20793 -> 20790;
20793 -> 20786;
20794 -> 20791;
20794 -> 20786;
20795 -> 20792;
20795 -> 20786;
20796 -> 20786;
20796 -> 20720;
20797 -> 20793;
20797 -> 20786;
20798 -> 20794;
20798 -> 20786;
20799 -> 20795;
20799 -> 20786;
20800 -> 20797;
20800 -> 20786;
20801 -> 20798;
20801 -> 20786;
20802 -> 20799;
20802 -> 20786;
20803 -> 20786;
20803 -> 20720;
20804 -> 20802;
20804 -> 20786;
20805 -> 20801;
20805 -> 20786;
20806 -> 20786;
20807 -> 20800;
20807 -> 20786;
20808 -> 20804;
20808 -> 20786;
20809 -> 20805;
20809 -> 20786;
20810 -> 20806;
20810 -> 20786;
20811 -> 20807;
20811 -> 20786;
20812 -> 20786;
20813 -> 0;
20813 -> 20786;
20814 -> 20786;
20815 -> 17448;
20815 -> 17446;
20816 -> 17447;
20816 -> 17446;
20817 -> 17449;
20817 -> 17446;
20818 -> 17446;
20819 -> 20815;
20819 -> 20818;
20820 -> 20816;
20820 -> 20818;
20821 -> 20817;
20821 -> 20818;
20822 -> 17451;
20822 -> 20818;
20823 -> 20818;
20824 -> 20786;
20824 -> 20823;
20825 -> 20824;
20825 -> 20779;
20825 -> 20823;
20826 -> 20825;
20826 -> 0;
20826 -> 20823;
20827 -> 20826;
20827 -> 20818;
20828 -> 17446;
20829 -> 17441;
20830 -> 20786;
20830 -> 20829;
20831 -> 20829;
20832 -> 20830;
20832 -> 20720;
20832 -> 20831;
20833 -> 17441;
20834 -> 20830;
20834 -> 20833;
20835 -> 16009;
20835 -> 20833;
20836 -> 20835;
20836 -> 17441;
20837 -> 20836;
20837 -> 17441;
20838 -> 17441;
20839 -> 20837;
20839 -> 20838;
20840 -> 20839;
20840 -> 20838;
20841 -> 20838;
20842 -> 20841;
20842 -> 17441;
20843 -> 17441;
20844 -> 20830;
20844 -> 20843;
20845 -> 20843;
20846 -> 20845;
20846 -> 17441;
20847 -> 17441;
20848 -> 17441;
20849 -> 20830;
20849 -> 20848;
20850 -> 0;
20850 -> 20848;
20851 -> 20850;
20851 -> 17441;
20852 -> 17441;
20853 -> 20830;
20853 -> 20852;
20854 -> 0;
20854 -> 20852;
20855 -> 20854;
20855 -> 17441;
20856 -> 17441;
20857 -> 20830;
20857 -> 20856;
20858 -> 0;
20858 -> 20856;
20859 -> 20858;
20859 -> 17441;
20860 -> 20855;
20860 -> 20859;
20860 -> 17441;
20861 -> 17441;
20862 -> 20830;
20862 -> 20861;
20863 -> 0;
20863 -> 20861;
20864 -> 20863;
20864 -> 17441;
20865 -> 20860;
20865 -> 20864;
20865 -> 17441;
20866 -> 20865;
20866 -> 20847;
20866 -> 17441;
20867 -> 17356;
20868 -> 20830;
20868 -> 20867;
20869 -> 0;
20869 -> 20867;
20870 -> 20869;
20870 -> 17356;
20871 -> 16256;
20871 -> 20870;
20872 -> 0;
20872 -> 20870;
20873 -> 17430;
20873 -> 20870;
20874 -> 20870;
20875 -> 20830;
20875 -> 20874;
20875 -> 20870;
20876 -> 20870;
20877 -> 20871;
20877 -> 20876;
20878 -> 20872;
20878 -> 20876;
20879 -> 20873;
20879 -> 20876;
20880 -> 20874;
20880 -> 20876;
20881 -> 20878;
20881 -> 20876;
20882 -> 20880;
20882 -> 20876;
20883 -> 20876;
20884 -> 20876;
20885 -> 20881;
20885 -> 20884;
20886 -> 20882;
20886 -> 20884;
20887 -> 20883;
20887 -> 20884;
20888 -> 20885;
20888 -> 20884;
20889 -> 20886;
20889 -> 20884;
20890 -> 0;
20890 -> 20884;
20891 -> 0;
20891 -> 20884;
20892 -> 20884;
20893 -> 20888;
20893 -> 20892;
20894 -> 20889;
20894 -> 20892;
20895 -> 20890;
20895 -> 20892;
20896 -> 20891;
20896 -> 20892;
20897 -> 20892;
20897 -> 20893;
20897 -> 20894;
20897 -> 20699;
20897 -> 20874;
20897 -> 20875;
20897 -> 20675;
20897 -> 20677;
20897 -> 20687;
20897 -> 20686;
20897 -> 20690;
20897 -> 18903;
20897 -> 18904;
20897 -> 18905;
20897 -> 20656;
20898 -> 20897;
20898 -> 20892;
20899 -> 20893;
20899 -> 0;
20899 -> 20892;
20900 -> 20896;
20900 -> 20887;
20900 -> 20892;
20901 -> 20883;
20901 -> 20876;
20902 -> 20879;
20902 -> 20876;
20903 -> 20876;
20904 -> 20876;
20905 -> 20901;
20905 -> 20904;
20906 -> 20902;
20906 -> 20904;
20907 -> 20903;
20907 -> 20904;
20908 -> 20903;
20908 -> 20904;
20909 -> 20905;
20909 -> 20904;
20910 -> 20907;
20910 -> 20904;
20911 -> 20904;
20912 -> 20911;
20912 -> 20909;
20912 -> 20906;
20912 -> 20910;
20912 -> 20897;
20912 -> 20895;
20912 -> 20887;
20912 -> 20900;
20912 -> 0;
20912 -> 20896;
20912 -> 20904;
20913 -> 20903;
20913 -> 20876;
20914 -> 20877;
20914 -> 20913;
20914 -> 20912;
20914 -> 20876;
20915 -> 20883;
20915 -> 20876;
20916 -> 20915;
20916 -> 20870;
20917 -> 20870;
20918 -> 16257;
20918 -> 20917;
20919 -> 20917;
20920 -> 20918;
20920 -> 20914;
20920 -> 20919;
20921 -> 20920;
20921 -> 20870;
20922 -> 16278;
20922 -> 20870;
20923 -> 16279;
20923 -> 20870;
20924 -> 20922;
20924 -> 20923;
20924 -> 16279;
20924 -> 20870;
20925 -> 16249;
20926 -> 20924;
20926 -> 20925;
20926 -> 16249;
20927 -> 20924;
20927 -> 16249;
20928 -> 20924;
20928 -> 16249;
20929 -> 16226;
20929 -> 16249;
20930 -> 20929;
20931 -> 16236;
20931 -> 20930;
20931 -> 20929;
20932 -> 20927;
20932 -> 20931;
20933 -> 20931;
20934 -> 20933;
20934 -> 16234;
20934 -> 20914;
20935 -> 20934;
20935 -> 20931;
20936 -> 20928;
20936 -> 16249;
20937 -> 16219;
20938 -> 16219;
20939 -> 16222;
20939 -> 20914;
20939 -> 20938;
20940 -> 20939;
20940 -> 16219;
20941 -> 16219;
20942 -> 20932;
20942 -> 20941;
20942 -> 16219;
20943 -> 16235;
20943 -> 16219;
20944 -> 16219;
20945 -> 16222;
20945 -> 20944;
20946 -> 20945;
20946 -> 20939;
20946 -> 20944;
20947 -> 20944;
20948 -> 20946;
20948 -> 16219;
20949 -> 16219;
20950 -> 16222;
20950 -> 20949;
20951 -> 20949;
20952 -> 20950;
20952 -> 20951;
20953 -> 20952;
20953 -> 20939;
20953 -> 20951;
20954 -> 20953;
20954 -> 20949;
20955 -> 20954;
20955 -> 16219;
20956 -> 20948;
20956 -> 20955;
20956 -> 16219;
20957 -> 16246;
20957 -> 16242;
20957 -> 16219;
20958 -> 16221;
20958 -> 16219;
20959 -> 16219;
20960 -> 16222;
20960 -> 20959;
20961 -> 20960;
20961 -> 20939;
20961 -> 20959;
20962 -> 20961;
20962 -> 16219;
20963 -> 16219;
20964 -> 20937;
20964 -> 16219;
20965 -> 16219;
20966 -> 20958;
20966 -> 20965;
20967 -> 20962;
20967 -> 20965;
20968 -> 20964;
20968 -> 20965;
20969 -> 20968;
20969 -> 20965;
20970 -> 20969;
20971 -> 20932;
20971 -> 16219;
20972 -> 20943;
20972 -> 16219;
20973 -> 20971;
20973 -> 20972;
20973 -> 20924;
20973 -> 20943;
20973 -> 16235;
20973 -> 16219;
20974 -> 16213;
20975 -> 16216;
20975 -> 20973;
20975 -> 20974;
20975 -> 20962;
20975 -> 16213;
20976 -> 16215;
20976 -> 20975;
20977 -> 20975;
20978 -> 20976;
20978 -> 20977;
20979 -> 16212;
20979 -> 20977;
20980 -> 20977;
20981 -> 20979;
20981 -> 20980;
20982 -> 20981;
20982 -> 20977;
20983 -> 20978;
20983 -> 20975;
20983 -> 20977;
20984 -> 20983;
20985 -> 20979;
20985 -> 20984;
20986 -> 20984;
20987 -> 20985;
20987 -> 20986;
20988 -> 20986;
20988 -> 20984;
20989 -> 20985;
20989 -> 20983;
20990 -> 20983;
20991 -> 20989;
20991 -> 20990;
20991 -> 20983;
20992 -> 20983;
20993 -> 20989;
20993 -> 20992;
20994 -> 20993;
20994 -> 20975;
20994 -> 20992;
20995 -> 20993;
20995 -> 20983;
20996 -> 20978;
20996 -> 20983;
20997 -> 20975;
20998 -> 16215;
20998 -> 20995;
20998 -> 16213;
20999 -> 16212;
20999 -> 20998;
20999 -> 16210;
21000 -> 16177;
21001 -> 20999;
21001 -> 21000;
21001 -> 16177;
21002 -> 16187;
21002 -> 21001;
21003 -> 21002;
21004 -> 21003;
21004 -> 21002;
21005 -> 0;
21005 -> 21002;
21006 -> 21002;
21007 -> 21005;
21007 -> 21006;
21008 -> 16202;
21008 -> 21006;
21009 -> 21007;
21009 -> 16009;
21009 -> 21006;
21010 -> 21007;
21010 -> 0;
21010 -> 21006;
21011 -> 21006;
21012 -> 21007;
21012 -> 21006;
21013 -> 21008;
21013 -> 21012;
21013 -> 20998;
21013 -> 21006;
21014 -> 21013;
21015 -> 21014;
21016 -> 21014;
21016 -> 21013;
21017 -> 21007;
21017 -> 21013;
21018 -> 21013;
21019 -> 21017;
21019 -> 21018;
21020 -> 21016;
21020 -> 21018;
21021 -> 21018;
21022 -> 21020;
21022 -> 21021;
21023 -> 21022;
21023 -> 21018;
21024 -> 21023;
21025 -> 21023;
21025 -> 21024;
21026 -> 21024;
21027 -> 21025;
21027 -> 21026;
21028 -> 21026;
21029 -> 21027;
21029 -> 21014;
21029 -> 21028;
21029 -> 21026;
21030 -> 21024;
21031 -> 21025;
21031 -> 21014;
21031 -> 21024;
21032 -> 21031;
21032 -> 21023;
21033 -> 21023;
21034 -> 21006;
21035 -> 21020;
21035 -> 21034;
21036 -> 21035;
21036 -> 21006;
21037 -> 21020;
21037 -> 21006;
21038 -> 21037;
21038 -> 16177;
21039 -> 16179;
21039 -> 16177;
21040 -> 16177;
21041 -> 21038;
21041 -> 21040;
21042 -> 21039;
21042 -> 21040;
21043 -> 21040;
21044 -> 21041;
21044 -> 21043;
21044 -> 21040;
21045 -> 21040;
21046 -> 21042;
21046 -> 21045;
21046 -> 21040;
21047 -> 21040;
21048 -> 21042;
21048 -> 21047;
21049 -> 21047;
21050 -> 21048;
21050 -> 21049;
21051 -> 21049;
21052 -> 21050;
21052 -> 21051;
21053 -> 21051;
21054 -> 21052;
21054 -> 21053;
21055 -> 21053;
21056 -> 21054;
21056 -> 21055;
21057 -> 21056;
21057 -> 21055;
21058 -> 21057;
21058 -> 21053;
21059 -> 21058;
21059 -> 21051;
21060 -> 21059;
21060 -> 21049;
21061 -> 21060;
21061 -> 21047;
21062 -> 21061;
21062 -> 21040;
21063 -> 21040;
21064 -> 21041;
21064 -> 21040;
21065 -> 21040;
21066 -> 21041;
21066 -> 21065;
21067 -> 21065;
21068 -> 21067;
21068 -> 21040;
21069 -> 21063;
21069 -> 21040;
21070 -> 21040;
21071 -> 21064;
21071 -> 21070;
21072 -> 21068;
21072 -> 21070;
21073 -> 21069;
21073 -> 21070;
21074 -> 21070;
21075 -> 21071;
21075 -> 21074;
21075 -> 21070;
21076 -> 21070;
21077 -> 21071;
21077 -> 21076;
21078 -> 21077;
21078 -> 21070;
21079 -> 21078;
21079 -> 21070;
21080 -> 21079;
21080 -> 21073;
21080 -> 21014;
21080 -> 21063;
21080 -> 21070;
21081 -> 21070;
21082 -> 21080;
21082 -> 21081;
21083 -> 21081;
21084 -> 21082;
21084 -> 21083;
21085 -> 21084;
21085 -> 21081;
21086 -> 0;
21086 -> 21085;
21087 -> 21086;
21088 -> 21078;
21088 -> 21087;
21089 -> 21088;
21089 -> 21086;
21089 -> 21087;
21090 -> 21089;
21090 -> 21086;
21091 -> 21090;
21092 -> 21090;
21093 -> 21091;
21093 -> 21092;
21094 -> 21078;
21094 -> 21092;
21095 -> 21092;
21096 -> 21092;
21097 -> 21095;
21097 -> 21096;
21098 -> 21094;
21098 -> 21096;
21099 -> 21098;
21099 -> 21086;
21099 -> 21096;
21100 -> 13570;
21100 -> 21096;
21101 -> 21099;
21102 -> 21098;
21102 -> 21101;
21103 -> 21102;
21103 -> 21086;
21103 -> 21101;
21104 -> 21103;
21105 -> 21104;
21106 -> 21104;
21106 -> 21105;
21107 -> 21105;
21107 -> 21104;
21108 -> 21104;
21108 -> 21103;
21109 -> 21103;
21110 -> 21108;
21110 -> 21109;
21111 -> 21110;
21111 -> 21103;
21112 -> 21102;
21112 -> 21086;
21112 -> 21103;
21113 -> 21111;
21113 -> 21103;
21114 -> 21101;
21115 -> 21114;
21115 -> 21099;
21116 -> 21115;
21116 -> 21099;
21117 -> 21098;
21117 -> 21111;
21117 -> 21099;
21118 -> 21115;
21118 -> 21099;
21119 -> 13570;
21119 -> 21099;
21120 -> 21117;
21120 -> 21118;
21120 -> 21119;
21120 -> 21111;
21120 -> 21099;
21121 -> 21098;
21121 -> 21120;
21121 -> 21096;
21122 -> 21121;
21122 -> 21092;
21123 -> 21122;
21123 -> 21090;
21124 -> 21072;
21124 -> 21090;
21125 -> 21073;
21125 -> 21090;
21126 -> 21090;
21127 -> 21123;
21127 -> 21126;
21128 -> 21124;
21128 -> 21126;
21129 -> 21125;
21129 -> 21126;
21130 -> 21126;
21131 -> 21127;
21131 -> 21130;
21131 -> 21126;
21132 -> 21131;
21133 -> 21086;
21134 -> 21072;
21134 -> 21133;
21134 -> 21086;
21135 -> 21040;
21136 -> 21042;
21136 -> 21040;
21137 -> 21136;
21137 -> 21063;
21137 -> 21120;
21137 -> 21040;
21138 -> 21040;
21139 -> 21138;
21140 -> 21139;
21141 -> 21138;
21142 -> 21137;
21142 -> 21141;
21143 -> 21142;
21143 -> 21138;
21144 -> 21063;
21144 -> 21143;
21144 -> 21040;
21145 -> 21143;
21145 -> 21040;
21146 -> 16177;
21147 -> 16179;
21147 -> 21146;
21148 -> 21146;
21149 -> 21148;
21149 -> 21147;
21149 -> 21146;
21150 -> 16177;
21151 -> 16177;
21152 -> 21037;
21152 -> 16177;
21153 -> 16177;
21154 -> 21152;
21154 -> 21153;
21155 -> 21153;
21156 -> 21155;
21156 -> 16177;
21157 -> 16177;
21158 -> 16179;
21158 -> 21157;
21159 -> 21157;
21160 -> 21158;
21160 -> 21159;
21161 -> 21159;
21161 -> 21157;
21162 -> 21158;
21162 -> 21157;
21163 -> 21157;
21164 -> 21162;
21164 -> 21163;
21165 -> 21164;
21165 -> 21144;
21165 -> 21163;
21166 -> 21157;
21167 -> 21165;
21167 -> 16177;
21168 -> 21156;
21168 -> 21167;
21168 -> 16177;
21169 -> 21152;
21169 -> 16177;
21170 -> 21151;
21170 -> 16177;
21171 -> 16177;
21172 -> 21169;
21172 -> 21171;
21173 -> 21170;
21173 -> 21171;
21174 -> 21171;
21175 -> 21172;
21175 -> 21174;
21176 -> 21175;
21176 -> 21144;
21176 -> 21174;
21177 -> 14214;
21177 -> 21174;
21178 -> 21176;
21179 -> 21175;
21179 -> 21178;
21180 -> 21178;
21181 -> 21180;
21181 -> 21178;
21182 -> 21178;
21183 -> 21179;
21183 -> 21182;
21184 -> 21182;
21185 -> 21184;
21185 -> 21182;
21186 -> 21182;
21187 -> 21183;
21187 -> 21186;
21188 -> 21186;
21189 -> 21187;
21189 -> 21188;
21190 -> 21189;
21190 -> 21144;
21190 -> 21188;
21191 -> 13570;
21191 -> 21188;
21192 -> 21189;
21192 -> 21144;
21192 -> 21190;
21193 -> 21190;
21194 -> 21189;
21194 -> 21193;
21195 -> 21193;
21196 -> 21193;
21197 -> 21195;
21197 -> 21196;
21198 -> 21194;
21198 -> 21196;
21199 -> 21196;
21200 -> 21199;
21200 -> 21196;
21201 -> 21198;
21201 -> 21144;
21201 -> 21196;
21202 -> 21201;
21202 -> 21196;
21203 -> 21202;
21203 -> 21193;
21204 -> 21193;
21205 -> 21203;
21205 -> 21204;
21205 -> 21193;
21206 -> 21205;
21207 -> 21206;
21207 -> 21190;
21208 -> 13570;
21208 -> 21190;
21209 -> 21192;
21209 -> 21207;
21209 -> 21208;
21209 -> 21144;
21209 -> 21149;
21209 -> 21190;
21210 -> 21189;
21210 -> 21209;
21210 -> 21188;
21211 -> 21210;
21211 -> 21186;
21212 -> 21186;
21213 -> 21211;
21213 -> 21212;
21213 -> 21186;
21214 -> 21186;
21215 -> 21214;
21215 -> 21182;
21216 -> 21182;
21217 -> 21185;
21217 -> 21216;
21218 -> 21215;
21218 -> 21216;
21219 -> 21183;
21219 -> 21216;
21220 -> 21216;
21221 -> 21218;
21221 -> 21220;
21221 -> 21216;
21222 -> 21221;
21223 -> 21182;
21224 -> 21183;
21224 -> 21223;
21225 -> 21223;
21226 -> 21224;
21226 -> 21225;
21227 -> 21226;
21227 -> 21209;
21227 -> 21225;
21228 -> 21225;
21229 -> 21227;
21229 -> 21228;
21230 -> 21228;
21230 -> 21225;
21231 -> 21227;
21231 -> 21223;
21232 -> 21231;
21232 -> 21182;
21233 -> 21182;
21234 -> 21232;
21234 -> 21233;
21235 -> 21233;
21236 -> 21234;
21236 -> 21235;
21237 -> 21235;
21238 -> 21236;
21238 -> 21237;
21239 -> 21237;
21240 -> 21238;
21240 -> 21209;
21240 -> 21239;
21240 -> 21237;
21241 -> 21235;
21242 -> 21236;
21242 -> 21233;
21243 -> 21233;
21244 -> 21217;
21244 -> 21182;
21245 -> 21244;
21245 -> 21178;
21246 -> 21178;
21247 -> 21181;
21247 -> 21246;
21248 -> 21245;
21248 -> 21246;
21249 -> 21179;
21249 -> 21246;
21250 -> 21246;
21251 -> 21248;
21251 -> 21250;
21251 -> 21246;
21252 -> 21251;
21253 -> 21252;
21254 -> 21179;
21254 -> 21253;
21255 -> 21254;
21255 -> 21209;
21255 -> 21253;
21256 -> 21253;
21257 -> 21255;
21257 -> 21256;
21258 -> 21256;
21258 -> 21253;
21259 -> 21255;
21259 -> 21252;
21260 -> 21252;
21261 -> 21259;
21261 -> 21260;
21262 -> 21179;
21262 -> 21209;
21262 -> 21252;
21263 -> 21261;
21264 -> 21179;
21264 -> 21263;
21265 -> 21264;
21265 -> 21261;
21265 -> 21263;
21266 -> 21265;
21266 -> 0;
21266 -> 21263;
21267 -> 21264;
21267 -> 21261;
21267 -> 21266;
21268 -> 21267;
21269 -> 21267;
21270 -> 21268;
21270 -> 21269;
21271 -> 21269;
21271 -> 21267;
21272 -> 0;
21272 -> 21267;
21273 -> 21267;
21274 -> 21271;
21274 -> 21273;
21274 -> 21267;
21275 -> 21272;
21275 -> 21264;
21275 -> 21266;
21276 -> 21272;
21276 -> 21263;
21277 -> 21276;
21277 -> 21261;
21278 -> 21261;
21279 -> 21278;
21279 -> 21261;
21280 -> 21277;
21280 -> 21279;
21280 -> 21261;
21281 -> 21280;
21282 -> 21280;
21283 -> 21281;
21283 -> 21282;
21284 -> 21282;
21285 -> 21282;
21285 -> 21280;
21286 -> 21285;
21286 -> 21280;
21287 -> 21247;
21287 -> 21178;
21288 -> 21287;
21288 -> 21176;
21289 -> 21288;
21289 -> 21175;
21289 -> 21176;
21290 -> 21175;
21290 -> 21261;
21290 -> 21289;
21290 -> 21174;
21291 -> 21290;
21291 -> 21171;
21292 -> 21171;
21293 -> 21291;
21293 -> 21292;
21293 -> 21171;
21294 -> 16177;
21295 -> 16177;
21296 -> 21152;
21296 -> 21295;
21297 -> 21296;
21297 -> 21261;
21297 -> 21295;
21298 -> 13570;
21298 -> 21295;
21299 -> 21296;
21299 -> 21261;
21299 -> 21295;
21300 -> 21299;
21300 -> 16177;
21301 -> 16177;
21302 -> 21300;
21302 -> 21301;
21302 -> 16177;
21303 -> 21173;
21303 -> 16177;
21304 -> 21037;
21304 -> 16177;
21305 -> 21304;
21305 -> 16168;
21306 -> 16167;
21306 -> 21261;
21306 -> 16168;
21307 -> 21305;
21307 -> 16168;
21308 -> 13570;
21308 -> 16168;
21309 -> 21306;
21309 -> 21307;
21309 -> 21308;
21309 -> 21261;
21309 -> 21275;
21309 -> 21289;
21309 -> 16168;
21310 -> 16175;
21310 -> 21309;
21311 -> 21309;
21312 -> 21310;
21312 -> 21311;
21313 -> 21311;
21314 -> 21313;
21314 -> 21311;
21315 -> 21309;
21316 -> 16175;
21316 -> 16168;
21317 -> 16167;
21317 -> 21309;
21317 -> 16166;
21318 -> 21317;
21318 -> 16164;
21319 -> 1;
21320 -> 1;
21321 -> 21318;
21321 -> 21320;
21322 -> 21321;
21322 -> 1;
}