digraph G {
0 [label="EXTERNAL"];
1 [label="param InitializeTestModule(this) 363589"];
2 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 363590"];
3 [label="param TypeTests(this) 363591"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 363592"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 363593"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 363594"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 363595"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 363596"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 363597"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 363598"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 363599"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 363600"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 363601"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 363602"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 363603"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 363604"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 363605"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 363606"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 363607"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 363608"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 363609"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 363610"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 363611"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 363612"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 363613"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 363614"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 363615"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 363616"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 363617"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 363618"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 363619"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 363620"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 363621"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 363622"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 363623"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 363624"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 363625"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 363626"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 363627"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 363628"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 363629"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 363630"];
43 [label="LazyThreadSafetyMode.PublicationOnly 363631"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 363632"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 363633"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 363634"];
47 [label="LazyThreadSafetyMode.PublicationOnly 363635"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 363636"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 363637"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 363638"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 363639"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 363640"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 363641"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 363642"];
55 [label="LazyThreadSafetyMode.PublicationOnly 363643"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 363644"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 363645"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 363646"];
59 [label="LazyThreadSafetyMode.PublicationOnly 363647"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 363648"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 363649"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 363650"];
63 [label="LazyThreadSafetyMode.PublicationOnly 363651"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 363652"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 363653"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 363654"];
67 [label="LazyThreadSafetyMode.PublicationOnly 363655"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363656"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363657"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 363658"];
71 [label="LazyThreadSafetyMode.PublicationOnly 363659"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363660"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363661"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 363662"];
75 [label="LazyThreadSafetyMode.PublicationOnly 363663"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363664"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363665"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 363666"];
79 [label="LazyThreadSafetyMode.PublicationOnly 363667"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363668"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363669"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 363670"];
83 [label="LazyThreadSafetyMode.PublicationOnly 363671"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363672"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363673"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 363674"];
87 [label="LazyThreadSafetyMode.PublicationOnly 363675"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363676"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363677"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 363678"];
91 [label="LazyThreadSafetyMode.PublicationOnly 363679"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363680"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363681"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 363682"];
95 [label="LazyThreadSafetyMode.PublicationOnly 363683"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 363684"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 363685"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 363686"];
99 [label="LazyThreadSafetyMode.PublicationOnly 363687"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 363688"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 363689"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 363690"];
103 [label="LazyThreadSafetyMode.PublicationOnly 363691"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363692"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363693"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 363694"];
107 [label="LazyThreadSafetyMode.PublicationOnly 363695"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363696"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363697"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 363698"];
111 [label="LazyThreadSafetyMode.PublicationOnly 363699"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363700"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363701"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 363702"];
115 [label="LazyThreadSafetyMode.PublicationOnly 363703"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363704"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363705"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 363706"];
119 [label="LazyThreadSafetyMode.PublicationOnly 363707"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 363708"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 363709"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 363710"];
123 [label="LazyThreadSafetyMode.PublicationOnly 363711"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363712"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363713"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 363714"];
127 [label="LazyThreadSafetyMode.PublicationOnly 363715"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363716"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363717"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 363718"];
131 [label="LazyThreadSafetyMode.PublicationOnly 363719"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363720"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363721"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 363722"];
135 [label="LazyThreadSafetyMode.PublicationOnly 363723"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363724"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363725"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 363726"];
139 [label="LazyThreadSafetyMode.PublicationOnly 363727"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363728"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363729"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 363730"];
143 [label="LazyThreadSafetyMode.PublicationOnly 363731"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363732"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363733"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 363734"];
147 [label="LazyThreadSafetyMode.PublicationOnly 363735"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363736"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363737"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 363738"];
151 [label="LazyThreadSafetyMode.PublicationOnly 363739"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363740"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363741"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 363742"];
155 [label="LazyThreadSafetyMode.PublicationOnly 363743"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363744"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363745"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 363746"];
159 [label="LazyThreadSafetyMode.PublicationOnly 363747"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363748"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363749"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 363750"];
163 [label="LazyThreadSafetyMode.PublicationOnly 363751"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363752"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363753"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 363754"];
167 [label="LazyThreadSafetyMode.PublicationOnly 363755"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363756"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363757"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 363758"];
171 [label="LazyThreadSafetyMode.PublicationOnly 363759"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363760"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 363761"];
174 [label="@'R:\\Invalid.dll' 363762"];
175 [label="fullPath: @'R:\\Invalid.dll' 363763"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 363764"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 363765"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 363766"];
179 [label="MscorlibRef_v4_0_30316_17626 363767"];
180 [label="Net451.mscorlib 363768"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 363769"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 363770"];
183 [label="'/*<bind>*/' 363771"];
184 [label="StartString = '/*<bind>*/' 363772"];
185 [label="'/*</bind>*/' 363773"];
186 [label="EndString = '/*</bind>*/' 363774"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 363775"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 363776"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 363777"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 363778"];
191 [label="param CSharpTestBase(this) 363779"];
192 [label="param CommonTestBase(this) 363780"];
193 [label="param TestBase(this) 363781"];
194 [label="_temp 363782"];
195 [label="param ErrorTypeSymbolWithArity(this) 363783"];
196 [label="var text = @'\nnamespace N\n{\n    public interface IGoo<T, V, U> {}\n    public interface IBar<T> {}\n\n    public class A : NotExist<int, int>\n    {\n        public class BB {}\n        public class B : BB, IGoo<string, byte>\n        {\n        }\n    }\n\n    public class C : IBar<char, string>\n    {\n        // NotExist is binding error, Not error symbol\n        public class D : IGoo<char, ulong, NotExist>\n        {\n        }\n    }\n}\n'; 363784"];
197 [label="var comp = CreateCompilation(text); 363785"];
198 [label="text 363786"];
199 [label="param operator(string source) 363787"];
200 [label="source 363788"];
201 [label="new CSharpTestSource(source) 363789"];
202 [label="param CSharpTestSource(object value) 363790"];
203 [label="param CSharpTestSource(this) 363791"];
204 [label="Value 363792"];
205 [label="var comp = CreateCompilation(text); 363793"];
206 [label="var comp = CreateCompilation(text); 363794"];
207 [label="CreateCompilation(text) 363795"];
208 [label="param CreateCompilation(CSharpTestSource source) 363796"];
209 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 363797"];
210 [label="param CreateCompilation(CSharpCompilationOptions options = null) 363798"];
211 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 363799"];
212 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 363800"];
213 [label="param CreateCompilation(string assemblyName = '') 363801"];
214 [label="param CreateCompilation(string sourceFileName = '') 363802"];
215 [label="param CreateCompilation(bool skipUsesIsNullable = false) 363803"];
216 [label="source 363804"];
217 [label="targetFramework 363805"];
218 [label="references 363806"];
219 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 363807"];
220 [label="param GetReferences(TargetFramework tf) 363808"];
221 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 363809"];
222 [label="var references = GetReferences(tf); 363810"];
223 [label="GetReferences(tf) 363811"];
224 [label="param GetReferences(TargetFramework targetFramework) 363812"];
225 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 363813"];
226 [label="StandardReferences 363814"];
227 [label="RuntimeUtilities.IsCoreClrRuntime 363815"];
228 [label="NetStandard20References 363816"];
229 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 363817"];
230 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 363818"];
231 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 363819"];
232 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 363820"];
233 [label="return references; 363821"];
234 [label="options 363822"];
235 [label="parseOptions 363823"];
236 [label="assemblyName 363824"];
237 [label="sourceFileName 363825"];
238 [label="skipUsesIsNullable 363826"];
239 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 363827"];
240 [label="param CreateEmptyCompilation(CSharpTestSource source) 363828"];
241 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 363829"];
242 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 363830"];
243 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 363831"];
244 [label="param CreateEmptyCompilation(string assemblyName = '') 363832"];
245 [label="param CreateEmptyCompilation(string sourceFileName = '') 363833"];
246 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 363834"];
247 [label="source 363835"];
248 [label="references 363836"];
249 [label="options 363837"];
250 [label="parseOptions 363838"];
251 [label="assemblyName 363839"];
252 [label="sourceFileName 363840"];
253 [label="skipUsesIsNullable 363841"];
254 [label="null 363842"];
255 [label="experimentalFeature: null 363843"];
256 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 363844"];
257 [label="param CreateCompilationCore(CSharpTestSource source) 363845"];
258 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 363846"];
259 [label="param CreateCompilationCore(CSharpCompilationOptions options) 363847"];
260 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 363848"];
261 [label="param CreateCompilationCore(string assemblyName) 363849"];
262 [label="param CreateCompilationCore(string sourceFileName) 363850"];
263 [label="param CreateCompilationCore(bool skipUsesIsNullable) 363851"];
264 [label="param CreateCompilationCore(MessageID? experimentalFeature) 363852"];
265 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 363853"];
266 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 363854"];
267 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 363855"];
268 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 363856"];
269 [label="param GetSyntaxTrees(string sourceFileName = '') 363857"];
270 [label="param GetSyntaxTrees(this) 363858"];
271 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 363859"];
272 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 363860"];
273 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 363861"];
274 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 363862"];
275 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 363863"];
276 [label="param Parse(string text) 363864"];
277 [label="param Parse(string filename = '') 363865"];
278 [label="param Parse(CSharpParseOptions options = null) 363866"];
279 [label="param Parse(Encoding encoding = null) 363867"];
280 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 363868"];
281 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 363869"];
282 [label="kind: SourceCodeKind.Regular 363870"];
283 [label="documentationMode: DocumentationMode.Parse 363871"];
284 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 363872"];
285 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 363873"];
286 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 363874"];
287 [label="SourceCodeKind.Script 363875"];
288 [label="Regular.WithKind(SourceCodeKind.Script) 363876"];
289 [label="Script = Regular.WithKind(SourceCodeKind.Script) 363877"];
290 [label="LanguageVersion.CSharp6 363878"];
291 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 363879"];
292 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 363880"];
293 [label="LanguageVersion.CSharp7 363881"];
294 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 363882"];
295 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 363883"];
296 [label="LanguageVersion.CSharp7_1 363884"];
297 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 363885"];
298 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 363886"];
299 [label="LanguageVersion.CSharp7_2 363887"];
300 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 363888"];
301 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 363889"];
302 [label="LanguageVersion.CSharp7_3 363890"];
303 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 363891"];
304 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 363892"];
305 [label="LanguageVersion.Default 363893"];
306 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 363894"];
307 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 363895"];
308 [label="LanguageVersion.Preview 363896"];
309 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 363897"];
310 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 363898"];
311 [label="LanguageVersion.CSharp8 363899"];
312 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 363900"];
313 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 363901"];
314 [label="LanguageVersion.CSharp9 363902"];
315 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 363903"];
316 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 363904"];
317 [label="DocumentationMode.Diagnose 363905"];
318 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 363906"];
319 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 363907"];
320 [label="Regular 363908"];
321 [label="'UseLegacyStrongNameProvider' 363909"];
322 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 363910"];
323 [label="param WithFeature(this CSharpParseOptions options) 363911"];
324 [label="param WithFeature(string feature) 363912"];
325 [label="param WithFeature(string value = 'true') 363913"];
326 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363914"];
327 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363915"];
328 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363916"];
329 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363917"];
330 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363918"];
331 [label="new[] { new KeyValuePair<string, string>(feature, value) } 363919"];
332 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 363920"];
333 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 363921"];
334 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 363922"];
335 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 363923"];
336 [label="1 363924"];
337 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 363925"];
338 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 363926"];
339 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 363927"];
340 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 363928"];
341 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 363929"];
342 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 363930"];
343 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 363931"];
344 [label="LanguageVersion.CSharp8 363932"];
345 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 363933"];
346 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 363934"];
347 [label="RegularWithExtendedPartialMethods = RegularPreview 363935"];
348 [label="new SmallDictionary<string, string> { } 363936"];
349 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 363937"];
350 [label="kind: SourceCodeKind.Regular 363938"];
351 [label="documentationMode: DocumentationMode.None 363939"];
352 [label="languageVersion: LanguageVersion.Preview 363940"];
353 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 363941"];
354 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 363942"];
355 [label="s_experimentalFeatures 363943"];
356 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 363944"];
357 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 363945"];
358 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 363946"];
359 [label="'testV7SwitchBinder' 363947"];
360 [label="'true' 363948"];
361 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 363949"];
362 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 363950"];
363 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 363951"];
364 [label="RegularWithoutRecursivePatterns = Regular7_3 363952"];
365 [label="RegularWithRecursivePatterns = Regular8 363953"];
366 [label="RegularWithoutPatternCombinators = Regular8 363954"];
367 [label="RegularWithPatternCombinators = RegularPreview 363955"];
368 [label="OutputKind.DynamicallyLinkedLibrary 363956"];
369 [label="OptimizationLevel.Release 363957"];
370 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 363958"];
371 [label="param CreateTestOptions(OutputKind outputKind) 363959"];
372 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 363960"];
373 [label="param CreateTestOptions(bool allowUnsafe = false) 363961"];
374 [label="outputKind 363962"];
375 [label="optimizationLevel: optimizationLevel 363963"];
376 [label="warningLevel: Diagnostic.MaxWarningLevel 363964"];
377 [label="allowUnsafe: allowUnsafe 363965"];
378 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363966"];
379 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363967"];
380 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 363968"];
381 [label="OutputKind.ConsoleApplication 363969"];
382 [label="OptimizationLevel.Release 363970"];
383 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 363971"];
384 [label="param CreateTestOptions(OutputKind outputKind) 363972"];
385 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 363973"];
386 [label="param CreateTestOptions(bool allowUnsafe = false) 363974"];
387 [label="outputKind 363975"];
388 [label="optimizationLevel: optimizationLevel 363976"];
389 [label="warningLevel: Diagnostic.MaxWarningLevel 363977"];
390 [label="allowUnsafe: allowUnsafe 363978"];
391 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363979"];
392 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363980"];
393 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 363981"];
394 [label="true 363982"];
395 [label="ReleaseDll.WithDebugPlusMode(true) 363983"];
396 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 363984"];
397 [label="true 363985"];
398 [label="ReleaseExe.WithDebugPlusMode(true) 363986"];
399 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 363987"];
400 [label="OutputKind.DynamicallyLinkedLibrary 363988"];
401 [label="OptimizationLevel.Debug 363989"];
402 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 363990"];
403 [label="param CreateTestOptions(OutputKind outputKind) 363991"];
404 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 363992"];
405 [label="param CreateTestOptions(bool allowUnsafe = false) 363993"];
406 [label="outputKind 363994"];
407 [label="optimizationLevel: optimizationLevel 363995"];
408 [label="warningLevel: Diagnostic.MaxWarningLevel 363996"];
409 [label="allowUnsafe: allowUnsafe 363997"];
410 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363998"];
411 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 363999"];
412 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 364000"];
413 [label="OutputKind.ConsoleApplication 364001"];
414 [label="OptimizationLevel.Debug 364002"];
415 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 364003"];
416 [label="param CreateTestOptions(OutputKind outputKind) 364004"];
417 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 364005"];
418 [label="param CreateTestOptions(bool allowUnsafe = false) 364006"];
419 [label="outputKind 364007"];
420 [label="optimizationLevel: optimizationLevel 364008"];
421 [label="warningLevel: Diagnostic.MaxWarningLevel 364009"];
422 [label="allowUnsafe: allowUnsafe 364010"];
423 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364011"];
424 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364012"];
425 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 364013"];
426 [label="OutputKind.WindowsRuntimeMetadata 364014"];
427 [label="OptimizationLevel.Release 364015"];
428 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 364016"];
429 [label="param CreateTestOptions(OutputKind outputKind) 364017"];
430 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 364018"];
431 [label="param CreateTestOptions(bool allowUnsafe = false) 364019"];
432 [label="outputKind 364020"];
433 [label="optimizationLevel: optimizationLevel 364021"];
434 [label="warningLevel: Diagnostic.MaxWarningLevel 364022"];
435 [label="allowUnsafe: allowUnsafe 364023"];
436 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364024"];
437 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364025"];
438 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 364026"];
439 [label="OutputKind.WindowsRuntimeMetadata 364027"];
440 [label="OptimizationLevel.Debug 364028"];
441 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 364029"];
442 [label="param CreateTestOptions(OutputKind outputKind) 364030"];
443 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 364031"];
444 [label="param CreateTestOptions(bool allowUnsafe = false) 364032"];
445 [label="outputKind 364033"];
446 [label="optimizationLevel: optimizationLevel 364034"];
447 [label="warningLevel: Diagnostic.MaxWarningLevel 364035"];
448 [label="allowUnsafe: allowUnsafe 364036"];
449 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364037"];
450 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364038"];
451 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 364039"];
452 [label="OutputKind.NetModule 364040"];
453 [label="OptimizationLevel.Release 364041"];
454 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 364042"];
455 [label="param CreateTestOptions(OutputKind outputKind) 364043"];
456 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 364044"];
457 [label="param CreateTestOptions(bool allowUnsafe = false) 364045"];
458 [label="outputKind 364046"];
459 [label="optimizationLevel: optimizationLevel 364047"];
460 [label="warningLevel: Diagnostic.MaxWarningLevel 364048"];
461 [label="allowUnsafe: allowUnsafe 364049"];
462 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364050"];
463 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364051"];
464 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 364052"];
465 [label="OutputKind.NetModule 364053"];
466 [label="OptimizationLevel.Debug 364054"];
467 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 364055"];
468 [label="param CreateTestOptions(OutputKind outputKind) 364056"];
469 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 364057"];
470 [label="param CreateTestOptions(bool allowUnsafe = false) 364058"];
471 [label="outputKind 364059"];
472 [label="optimizationLevel: optimizationLevel 364060"];
473 [label="warningLevel: Diagnostic.MaxWarningLevel 364061"];
474 [label="allowUnsafe: allowUnsafe 364062"];
475 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364063"];
476 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 364064"];
477 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 364065"];
478 [label="true 364066"];
479 [label="ReleaseDll.WithAllowUnsafe(true) 364067"];
480 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 364068"];
481 [label="true 364069"];
482 [label="ReleaseExe.WithAllowUnsafe(true) 364070"];
483 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 364071"];
484 [label="true 364072"];
485 [label="DebugDll.WithAllowUnsafe(true) 364073"];
486 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 364074"];
487 [label="true 364075"];
488 [label="DebugExe.WithAllowUnsafe(true) 364076"];
489 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 364077"];
490 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 364078"];
491 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364079"];
492 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364080"];
493 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 364081"];
494 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364082"];
495 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364083"];
496 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 364084"];
497 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364085"];
498 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364086"];
499 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 364087"];
500 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364088"];
501 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 364089"];
502 [label="DebugInformationFormat.Pdb 364090"];
503 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 364091"];
504 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 364092"];
505 [label="options = TestOptions.Regular; 364093"];
506 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 364094"];
507 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 364095"];
508 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 364096"];
509 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 364097"];
510 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 364098"];
511 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 364099"];
512 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 364100"];
513 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 364101"];
514 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 364102"];
515 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 364103"];
516 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 364104"];
517 [label="param CheckSerializable(SyntaxTree tree) 364105"];
518 [label="var stream = new MemoryStream(); 364106"];
519 [label="var root = tree.GetRoot(); 364107"];
520 [label="var root = tree.GetRoot(); 364108"];
521 [label="root.SerializeTo(stream); 364109"];
522 [label="root.SerializeTo(stream); 364110"];
523 [label="root.SerializeTo(stream); 364111"];
524 [label="stream.Position = 0; 364112"];
525 [label="stream.Position 364113"];
526 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 364114"];
527 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 364115"];
528 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 364116"];
529 [label="return tree; 364117"];
530 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 364118"];
531 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 364119"];
532 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 364120"];
533 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 364121"];
534 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 364122"];
535 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 364123"];
536 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 364124"];
537 [label="hasTopLevelStatements 364125"];
538 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 364126"];
539 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 364127"];
540 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 364128"];
541 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 364129"];
542 [label="'ROSLYN_TEST_IOPERATION' 364130"];
543 [label="Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION') 364131"];
544 [label="string.IsNullOrEmpty(Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION')) 364132"];
545 [label="internal static bool EnableVerifyIOperation { get; } = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION')); 364133"];
546 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 364134"];
547 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 364135"];
548 [label="param ValidateIOperations(Func<Compilation> createCompilation) 364136"];
549 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 364137"];
550 [label="return; 364138"];
551 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 364139"];
552 [label="var compilation = createCompilationLambda(); 364140"];
553 [label="var compilation = createCompilationLambda(); 364141"];
554 [label="return Guid.NewGuid().ToString('D'); 364142"];
555 [label="var compilation = createCompilationLambda(); 364143"];
556 [label="OutputKind.ConsoleApplication 364144"];
557 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 364145"];
558 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 364146"];
559 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 364147"];
560 [label="OutputKind.DynamicallyLinkedLibrary 364148"];
561 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 364149"];
562 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 364150"];
563 [label="true 364151"];
564 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 364152"];
565 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 364153"];
566 [label="param Create(string? assemblyName) 364154"];
567 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 364155"];
568 [label="param Create(IEnumerable<MetadataReference>? references = null) 364156"];
569 [label="param Create(CSharpCompilationOptions? options = null) 364157"];
570 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 364158"];
571 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 364159"];
572 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 364160"];
573 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 364161"];
574 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 364162"];
575 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 364163"];
576 [label="param Create(string? assemblyName) 364164"];
577 [label="param Create(CSharpCompilationOptions options) 364165"];
578 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 364166"];
579 [label="param Create(IEnumerable<MetadataReference>? references) 364167"];
580 [label="param Create(CSharpCompilation? previousSubmission) 364168"];
581 [label="param Create(Type? returnType) 364169"];
582 [label="param Create(Type? hostObjectType) 364170"];
583 [label="param Create(bool isSubmission) 364171"];
584 [label="RoslynDebug.Assert(options != null); 364172"];
585 [label="RoslynDebug.Assert(options != null); 364173"];
586 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 364174"];
587 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 364175"];
588 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 364176"];
589 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364177"];
590 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364178"];
591 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364179"];
592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364180"];
593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364181"];
594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364182"];
595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364183"];
596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364184"];
597 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364185"];
598 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364186"];
599 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 364187"];
600 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 364188"];
601 [label="param CSharpCompilation(string? assemblyName) 364189"];
602 [label="param CSharpCompilation(CSharpCompilationOptions options) 364190"];
603 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 364191"];
604 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 364192"];
605 [label="param CSharpCompilation(Type? submissionReturnType) 364193"];
606 [label="param CSharpCompilation(Type? hostObjectType) 364194"];
607 [label="param CSharpCompilation(bool isSubmission) 364195"];
608 [label="param CSharpCompilation(ReferenceManager? referenceManager) 364196"];
609 [label="param CSharpCompilation(bool reuseReferenceManager) 364197"];
610 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 364198"];
611 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 364199"];
612 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 364200"];
613 [label="param CSharpCompilation(this) 364201"];
614 [label="assemblyName 364202"];
615 [label="options 364203"];
616 [label="references 364204"];
617 [label="previousSubmission 364205"];
618 [label="submissionReturnType 364206"];
619 [label="hostObjectType 364207"];
620 [label="isSubmission 364208"];
621 [label="referenceManager 364209"];
622 [label="reuseReferenceManager 364210"];
623 [label="syntaxAndDeclarations 364211"];
624 [label="syntaxAndDeclarations.ExternalSyntaxTrees 364212"];
625 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 364213"];
626 [label="semanticModelProvider 364214"];
627 [label="eventQueue 364215"];
628 [label="param CSharpCompilation(this) 364216"];
629 [label="param CSharpCompilation(string? assemblyName) 364217"];
630 [label="param CSharpCompilation(CSharpCompilationOptions options) 364218"];
631 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 364219"];
632 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 364220"];
633 [label="param CSharpCompilation(Type? submissionReturnType) 364221"];
634 [label="param CSharpCompilation(Type? hostObjectType) 364222"];
635 [label="param CSharpCompilation(bool isSubmission) 364223"];
636 [label="param CSharpCompilation(ReferenceManager? referenceManager) 364224"];
637 [label="param CSharpCompilation(bool reuseReferenceManager) 364225"];
638 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 364226"];
639 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 364227"];
640 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 364228"];
641 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 364229"];
642 [label="param CSharpCompilation(this) 364230"];
643 [label="assemblyName 364231"];
644 [label="references 364232"];
645 [label="features 364233"];
646 [label="isSubmission 364234"];
647 [label="semanticModelProvider 364235"];
648 [label="eventQueue 364236"];
649 [label="param CSharpCompilation(this) 364237"];
650 [label="param CSharpCompilation(this) 364238"];
651 [label="_options 364239"];
652 [label="_globalImports 364240"];
653 [label="_previousSubmissionImports 364241"];
654 [label="_globalNamespaceAlias 364242"];
655 [label="_scriptClass 364243"];
656 [label="_lazyHostObjectTypeSymbol 364244"];
657 [label="_lazyImportInfos 364245"];
658 [label="_conversions 364246"];
659 [label="_anonymousTypeManager 364247"];
660 [label="_lazyGlobalNamespace 364248"];
661 [label="builtInOperators 364249"];
662 [label="_lazyAssemblySymbol 364250"];
663 [label="_referenceManager 364251"];
664 [label="_syntaxAndDeclarations 364252"];
665 [label="_lazyEntryPoint 364253"];
666 [label="_lazyEmitNullablePublicOnly 364254"];
667 [label="_lazyCompilationUnitCompletedTrees 364255"];
668 [label="NullableAnalysisData 364256"];
669 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 364257"];
670 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 364258"];
671 [label="_externAliasTargets 364259"];
672 [label="_moduleInitializerMethods 364260"];
673 [label="_binderFactories 364261"];
674 [label="_ignoreAccessibilityBinderFactories 364262"];
675 [label="_lazyDeclarationDiagnostics 364263"];
676 [label="_declarationDiagnosticsFrozen 364264"];
677 [label="new DiagnosticBag() 364265"];
678 [label="_additionalCodegenWarnings = new DiagnosticBag() 364266"];
679 [label="WellKnownMemberSignatureComparer 364267"];
680 [label="_lazyWellKnownTypes 364268"];
681 [label="_lazyWellKnownTypeMembers 364269"];
682 [label="_usesNullableAttributes 364270"];
683 [label="_needsGeneratedAttributes 364271"];
684 [label="_needsGeneratedAttributes_IsFrozen 364272"];
685 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 364273"];
686 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 364274"];
687 [label="new WellKnownMembersSignatureComparer(this) 364275"];
688 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 364276"];
689 [label="param WellKnownMembersSignatureComparer(this) 364277"];
690 [label="new SpecialMembersSignatureComparer() 364278"];
691 [label="param SpecialMembersSignatureComparer(this) 364279"];
692 [label="Instance = new SpecialMembersSignatureComparer() 364280"];
693 [label="param WellKnownMembersSignatureComparer(this) 364281"];
694 [label="param SpecialMembersSignatureComparer(this) 364282"];
695 [label="param SpecialMembersSignatureComparer(this) 364283"];
696 [label="_compilation 364284"];
697 [label="_compilation 364285"];
698 [label="WellKnownMemberSignatureComparer 364286"];
699 [label="_options 364287"];
700 [label="this.builtInOperators = new BuiltInOperators(this); 364288"];
701 [label="this.builtInOperators = new BuiltInOperators(this); 364289"];
702 [label="this.builtInOperators 364290"];
703 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 364291"];
704 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 364292"];
705 [label="_scriptClass 364293"];
706 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 364294"];
707 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 364295"];
708 [label="_globalImports 364296"];
709 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 364297"];
710 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 364298"];
711 [label="_previousSubmissionImports 364299"];
712 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 364300"];
713 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 364301"];
714 [label="_globalNamespaceAlias 364302"];
715 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 364303"];
716 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 364304"];
717 [label="new AnonymousTypeManager(this) 364305"];
718 [label="param AnonymousTypeManager(CSharpCompilation compilation) 364306"];
719 [label="param AnonymousTypeManager(this) 364307"];
720 [label="param AnonymousTypeManager(this) 364308"];
721 [label="public CSharpCompilation Compilation { get; } 364309"];
722 [label="_lazyAnonymousTypeTemplates 364310"];
723 [label="_lazySynthesizedDelegates 364311"];
724 [label="new ConcurrentDictionary<Location, bool>() 364312"];
725 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 364313"];
726 [label="Debug.Assert(compilation != null); 364314"];
727 [label="Debug.Assert(compilation != null); 364315"];
728 [label="this.Compilation 364316"];
729 [label="_anonymousTypeManager 364317"];
730 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 364318"];
731 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 364319"];
732 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 364320"];
733 [label="LanguageVersion? result = null; 364321"];
734 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 364322"];
735 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 364323"];
736 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 364324"];
737 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 364325"];
738 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 364326"];
739 [label="this.LanguageVersion 364327"];
740 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 364328"];
741 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364329"];
742 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364330"];
743 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364331"];
744 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364332"];
745 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364333"];
746 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364334"];
747 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 364335"];
748 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 364336"];
749 [label="this.Options 364337"];
750 [label="get\n            {\n                return _options;\n            } 364338"];
751 [label="return _options; 364339"];
752 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 364340"];
753 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 364341"];
754 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 364342"];
755 [label="param ReferenceManager(string simpleAssemblyName) 364343"];
756 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 364344"];
757 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 364345"];
758 [label="param ReferenceManager(this) 364346"];
759 [label="simpleAssemblyName 364347"];
760 [label="identityComparer 364348"];
761 [label="observedMetadata 364349"];
762 [label="param ReferenceManager(this) 364350"];
763 [label="param ReferenceManager(this) 364351"];
764 [label="_referenceManager 364352"];
765 [label="_syntaxAndDeclarations 364353"];
766 [label="Debug.Assert(_lazyAssemblySymbol is null); 364354"];
767 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 364355"];
768 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 364356"];
769 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 364357"];
770 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 364358"];
771 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 364359"];
772 [label="compilation.AddSyntaxTrees(syntaxTrees) 364360"];
773 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 364361"];
774 [label="param AddSyntaxTrees(this) 364362"];
775 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 364363"];
776 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 364364"];
777 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 364365"];
778 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 364366"];
779 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 364367"];
780 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 364368"];
781 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 364369"];
782 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 364370"];
783 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 364371"];
784 [label="bool reuseReferenceManager = true; 364372"];
785 [label="int i = 0; 364373"];
786 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 364374"];
787 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 364375"];
788 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 364376"];
789 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 364377"];
790 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 364378"];
791 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 364379"];
792 [label="externalSyntaxTrees.Add(tree); 364380"];
793 [label="externalSyntaxTrees.Add(tree); 364381"];
794 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 364382"];
795 [label="i++; 364383"];
796 [label="externalSyntaxTrees.Free(); 364384"];
797 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 364385"];
798 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 364386"];
799 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 364387"];
800 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 364388"];
801 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 364389"];
802 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 364390"];
803 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 364391"];
804 [label="param Update(ReferenceManager referenceManager) 364392"];
805 [label="param Update(bool reuseReferenceManager) 364393"];
806 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 364394"];
807 [label="param Update(this) 364395"];
808 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364396"];
809 [label="this.PreviousSubmission 364397"];
810 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 364398"];
811 [label="ScriptCompilationInfo 364399"];
812 [label="ScriptCompilationInfo?.PreviousScriptCompilation 364400"];
813 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364401"];
814 [label="this.SubmissionReturnType 364402"];
815 [label="=> ScriptCompilationInfo 364403"];
816 [label="ScriptCompilationInfo 364404"];
817 [label="this.HostObjectType 364405"];
818 [label="=> ScriptCompilationInfo 364406"];
819 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364407"];
820 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364408"];
821 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364409"];
822 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 364410"];
823 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 364411"];
824 [label="param CSharpCompilation(string? assemblyName) 364412"];
825 [label="param CSharpCompilation(CSharpCompilationOptions options) 364413"];
826 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 364414"];
827 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 364415"];
828 [label="param CSharpCompilation(Type? submissionReturnType) 364416"];
829 [label="param CSharpCompilation(Type? hostObjectType) 364417"];
830 [label="param CSharpCompilation(bool isSubmission) 364418"];
831 [label="param CSharpCompilation(ReferenceManager? referenceManager) 364419"];
832 [label="param CSharpCompilation(bool reuseReferenceManager) 364420"];
833 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 364421"];
834 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 364422"];
835 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 364423"];
836 [label="param CSharpCompilation(this) 364424"];
837 [label="previousSubmission 364425"];
838 [label="submissionReturnType 364426"];
839 [label="hostObjectType 364427"];
840 [label="syntaxAndDeclarations.ExternalSyntaxTrees 364428"];
841 [label="eventQueue 364429"];
842 [label="param CSharpCompilation(this) 364430"];
843 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 364431"];
844 [label="param CSharpCompilation(Type? submissionReturnType) 364432"];
845 [label="param CSharpCompilation(Type? hostObjectType) 364433"];
846 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 364434"];
847 [label="param CSharpCompilation(this) 364435"];
848 [label="eventQueue 364436"];
849 [label="param CSharpCompilation(this) 364437"];
850 [label="_options 364438"];
851 [label="_globalImports 364439"];
852 [label="_previousSubmissionImports 364440"];
853 [label="_globalNamespaceAlias 364441"];
854 [label="_scriptClass 364442"];
855 [label="_lazyHostObjectTypeSymbol 364443"];
856 [label="_lazyImportInfos 364444"];
857 [label="_conversions 364445"];
858 [label="_anonymousTypeManager 364446"];
859 [label="_lazyGlobalNamespace 364447"];
860 [label="builtInOperators 364448"];
861 [label="_lazyAssemblySymbol 364449"];
862 [label="_referenceManager 364450"];
863 [label="_syntaxAndDeclarations 364451"];
864 [label="_lazyEntryPoint 364452"];
865 [label="_lazyEmitNullablePublicOnly 364453"];
866 [label="_lazyCompilationUnitCompletedTrees 364454"];
867 [label="NullableAnalysisData 364455"];
868 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 364456"];
869 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 364457"];
870 [label="_externAliasTargets 364458"];
871 [label="_moduleInitializerMethods 364459"];
872 [label="_binderFactories 364460"];
873 [label="_ignoreAccessibilityBinderFactories 364461"];
874 [label="_lazyDeclarationDiagnostics 364462"];
875 [label="_declarationDiagnosticsFrozen 364463"];
876 [label="new DiagnosticBag() 364464"];
877 [label="_additionalCodegenWarnings = new DiagnosticBag() 364465"];
878 [label="WellKnownMemberSignatureComparer 364466"];
879 [label="_lazyWellKnownTypes 364467"];
880 [label="_lazyWellKnownTypeMembers 364468"];
881 [label="_usesNullableAttributes 364469"];
882 [label="_needsGeneratedAttributes 364470"];
883 [label="_needsGeneratedAttributes_IsFrozen 364471"];
884 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 364472"];
885 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 364473"];
886 [label="new WellKnownMembersSignatureComparer(this) 364474"];
887 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 364475"];
888 [label="param WellKnownMembersSignatureComparer(this) 364476"];
889 [label="param WellKnownMembersSignatureComparer(this) 364477"];
890 [label="param SpecialMembersSignatureComparer(this) 364478"];
891 [label="param SpecialMembersSignatureComparer(this) 364479"];
892 [label="_compilation 364480"];
893 [label="_compilation 364481"];
894 [label="WellKnownMemberSignatureComparer 364482"];
895 [label="this.builtInOperators = new BuiltInOperators(this); 364483"];
896 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 364484"];
897 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 364485"];
898 [label="new AnonymousTypeManager(this) 364486"];
899 [label="param AnonymousTypeManager(CSharpCompilation compilation) 364487"];
900 [label="param AnonymousTypeManager(this) 364488"];
901 [label="param AnonymousTypeManager(this) 364489"];
902 [label="public CSharpCompilation Compilation { get; } 364490"];
903 [label="_lazyAnonymousTypeTemplates 364491"];
904 [label="_lazySynthesizedDelegates 364492"];
905 [label="new ConcurrentDictionary<Location, bool>() 364493"];
906 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 364494"];
907 [label="Debug.Assert(compilation != null); 364495"];
908 [label="Debug.Assert(compilation != null); 364496"];
909 [label="this.Compilation 364497"];
910 [label="_anonymousTypeManager 364498"];
911 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 364499"];
912 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 364500"];
913 [label="LanguageVersion? result = null; 364501"];
914 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 364502"];
915 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 364503"];
916 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 364504"];
917 [label="result = version; 364505"];
918 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 364506"];
919 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364507"];
920 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364508"];
921 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364509"];
922 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364510"];
923 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364511"];
924 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 364512"];
925 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 364513"];
926 [label="referenceManager.AssertCanReuseForCompilation(this); 364514"];
927 [label="referenceManager.AssertCanReuseForCompilation(this); 364515"];
928 [label="_referenceManager 364516"];
929 [label="Debug.Assert(_lazyAssemblySymbol is null); 364517"];
930 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 364518"];
931 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 364519"];
932 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 364520"];
933 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 364521"];
934 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 364522"];
935 [label="return compilation; 364523"];
936 [label="var compilation = createCompilationLambda(); 364524"];
937 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 364525"];
938 [label="IsNullableEnabled(compilation) 364526"];
939 [label="param IsNullableEnabled(CSharpCompilation compilation) 364527"];
940 [label="compilation.SyntaxTrees 364528"];
941 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 364529"];
942 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 364530"];
943 [label="var trees = compilation.SyntaxTrees; 364531"];
944 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 364532"];
945 [label="var options = (CSharpParseOptions)trees[0].Options; 364533"];
946 [label="var options = (CSharpParseOptions)trees[0].Options; 364534"];
947 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 364535"];
948 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 364536"];
949 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 364537"];
950 [label="return compilation; 364538"];
951 [label="CustomAssert.Equal(4, comp.GetDiagnostics().Count()); 364539"];
952 [label="comp.GetDiagnostics() 364540"];
953 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 364541"];
954 [label="param GetDiagnostics(this) 364542"];
955 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 364543"];
956 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 364544"];
957 [label="return GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken); 364545"];
958 [label="GetDiagnostics(DefaultDiagnosticsStage, true, cancellationToken) 364546"];
959 [label="param GetDiagnostics(CompilationStage stage) 364547"];
960 [label="param GetDiagnostics(bool includeEarlierStages) 364548"];
961 [label="param GetDiagnostics(CancellationToken cancellationToken) 364549"];
962 [label="param GetDiagnostics(this) 364550"];
963 [label="var diagnostics = DiagnosticBag.GetInstance(); 364551"];
964 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 364552"];
965 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 364553"];
966 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 364554"];
967 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 364555"];
968 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 364556"];
969 [label="param GetDiagnostics(CompilationStage stage) 364557"];
970 [label="param GetDiagnostics(bool includeEarlierStages) 364558"];
971 [label="param GetDiagnostics(DiagnosticBag diagnostics) 364559"];
972 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 364560"];
973 [label="param GetDiagnostics(this) 364561"];
974 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 364562"];
975 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 364563"];
976 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 364564"];
977 [label="this.SyntaxTrees 364565"];
978 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 364566"];
979 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 364567"];
980 [label="var syntaxTrees = this.SyntaxTrees; 364568"];
981 [label="this.Options 364569"];
982 [label="get\n            {\n                return _options;\n            } 364570"];
983 [label="return _options; 364571"];
984 [label="if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                } 364572"];
985 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 364573"];
986 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 364574"];
987 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 364575"];
988 [label="RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken); 364576"];
989 [label="param AppendLoadDirectiveDiagnostics(DiagnosticBag builder) 364577"];
990 [label="param AppendLoadDirectiveDiagnostics(SyntaxAndDeclarationManager syntaxAndDeclarations) 364578"];
991 [label="param AppendLoadDirectiveDiagnostics(SyntaxTree syntaxTree) 364579"];
992 [label="param AppendLoadDirectiveDiagnostics(Func<IEnumerable<Diagnostic>, IEnumerable<Diagnostic>>? locationFilterOpt = null) 364580"];
993 [label="ImmutableArray<LoadDirective> loadDirectives; 364581"];
994 [label="loadDirectives 364582"];
995 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 364583"];
996 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 364584"];
997 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 364585"];
998 [label="if (syntaxAndDeclarations.GetLazyState().LoadDirectiveMap.TryGetValue(syntaxTree, out loadDirectives))\n            {\n                Debug.Assert(!loadDirectives.IsEmpty);\n                foreach (var directive in loadDirectives)\n                {\n                    IEnumerable<Diagnostic> diagnostics = directive.Diagnostics;\n                    if (locationFilterOpt != null)\n                    {\n                        diagnostics = locationFilterOpt(diagnostics);\n                    }\n                    builder.AddRange(diagnostics);\n                }\n            } 364586"];
999 [label="var parseOptionsReported = new HashSet<ParseOptions>(); 364587"];
1000 [label="foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                } 364588"];
1001 [label="cancellationToken.ThrowIfCancellationRequested(); 364589"];
1002 [label="if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    } 364590"];
1003 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 364591"];
1004 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 364592"];
1005 [label="CheckAssemblyName(builder); 364593"];
1006 [label="CheckAssemblyName(builder); 364594"];
1007 [label="CheckAssemblyName(builder); 364595"];
1008 [label="get { return _syntaxAndDeclarations.MessageProvider; } 364596"];
1009 [label="return _syntaxAndDeclarations.MessageProvider; 364597"];
1010 [label="Options 364598"];
1011 [label="get\n            {\n                return _options;\n            } 364599"];
1012 [label="return _options; 364600"];
1013 [label="builder.AddRange(Options.Errors); 364601"];
1014 [label="Options 364602"];
1015 [label="get\n            {\n                return _options;\n            } 364603"];
1016 [label="return _options; 364604"];
1017 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 364605"];
1018 [label="cancellationToken.ThrowIfCancellationRequested(); 364606"];
1019 [label="GetBoundReferenceManager() 364607"];
1020 [label="param GetBoundReferenceManager(this) 364608"];
1021 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 364609"];
1022 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 364610"];
1023 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 364611"];
1024 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 364612"];
1025 [label="param CreateSourceAssemblyForCompilation(this) 364613"];
1026 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 364614"];
1027 [label="CreateAndSetSourceAssemblyFullBind(compilation) 364615"];
1028 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 364616"];
1029 [label="param CreateAndSetSourceAssemblyFullBind(this) 364617"];
1030 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 364618"];
1031 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 364619"];
1032 [label="compilation.Options 364620"];
1033 [label="get\n            {\n                return _options;\n            } 364621"];
1034 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 364622"];
1035 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 364623"];
1036 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 364624"];
1037 [label="boundReferenceDirectives 364625"];
1038 [label="ImmutableArray<AssemblyData> referencedAssemblies; 364626"];
1039 [label="referencedAssemblies 364627"];
1040 [label="ImmutableArray<PEModule> modules; 364628"];
1041 [label="modules 364629"];
1042 [label="ImmutableArray<MetadataReference> explicitReferences; 364630"];
1043 [label="explicitReferences 364631"];
1044 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364632"];
1045 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364633"];
1046 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364634"];
1047 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364635"];
1048 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364636"];
1049 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364637"];
1050 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364638"];
1051 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364639"];
1052 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364640"];
1053 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364641"];
1054 [label="get { return this.Declarations.ReferenceDirectives; } 364642"];
1055 [label="this.Declarations 364643"];
1056 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 364644"];
1057 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 364645"];
1058 [label="return this.Declarations.ReferenceDirectives; 364646"];
1059 [label="this.Declarations.ReferenceDirectives 364647"];
1060 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 364648"];
1061 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 364649"];
1062 [label="var result = DeclarationModifiers.None; 364650"];
1063 [label="bool seenNoDuplicates = true; 364651"];
1064 [label="bool seenNoAccessibilityDuplicates = true; 364652"];
1065 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 364653"];
1066 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 364654"];
1067 [label="ToDeclarationModifier(modifier.ContextualKind()) 364655"];
1068 [label="param ToDeclarationModifier(SyntaxKind kind) 364656"];
1069 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                    return DeclarationModifiers.Abstract;\n                case SyntaxKind.AsyncKeyword:\n                    return DeclarationModifiers.Async;\n                case SyntaxKind.SealedKeyword:\n                    return DeclarationModifiers.Sealed;\n                case SyntaxKind.StaticKeyword:\n                    return DeclarationModifiers.Static;\n                case SyntaxKind.NewKeyword:\n                    return DeclarationModifiers.New;\n                case SyntaxKind.PublicKeyword:\n                    return DeclarationModifiers.Public;\n                case SyntaxKind.ProtectedKeyword:\n                    return DeclarationModifiers.Protected;\n                case SyntaxKind.InternalKeyword:\n                    return DeclarationModifiers.Internal;\n                case SyntaxKind.PrivateKeyword:\n                    return DeclarationModifiers.Private;\n                case SyntaxKind.ExternKeyword:\n                    return DeclarationModifiers.Extern;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return DeclarationModifiers.ReadOnly;\n                case SyntaxKind.PartialKeyword:\n                    return DeclarationModifiers.Partial;\n                case SyntaxKind.UnsafeKeyword:\n                    return DeclarationModifiers.Unsafe;\n                case SyntaxKind.VirtualKeyword:\n                    return DeclarationModifiers.Virtual;\n                case SyntaxKind.OverrideKeyword:\n                    return DeclarationModifiers.Override;\n                case SyntaxKind.ConstKeyword:\n                    return DeclarationModifiers.Const;\n                case SyntaxKind.FixedKeyword:\n                    return DeclarationModifiers.Fixed;\n                case SyntaxKind.VolatileKeyword:\n                    return DeclarationModifiers.Volatile;\n                case SyntaxKind.RefKeyword:\n                    return DeclarationModifiers.Ref;\n                case SyntaxKind.DataKeyword:\n                    return DeclarationModifiers.Data;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 364657"];
1070 [label="return DeclarationModifiers.Public; 364658"];
1071 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364659"];
1072 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364660"];
1073 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364661"];
1074 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364662"];
1075 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364663"];
1076 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364664"];
1077 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 364665"];
1078 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 364666"];
1079 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 364667"];
1080 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 364668"];
1081 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 364669"];
1082 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 364670"];
1083 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 364671"];
1084 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 364672"];
1085 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 364673"];
1086 [label="result |= one; 364674"];
1087 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 364675"];
1088 [label="return result; 364676"];
1089 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364677"];
1090 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364678"];
1091 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364679"];
1092 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364680"];
1093 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 364681"];
1094 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 364682"];
1095 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 364683"];
1096 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 364684"];
1097 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 364685"];
1098 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 364686"];
1099 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 364687"];
1100 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 364688"];
1101 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 364689"];
1102 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 364690"];
1103 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 364691"];
1104 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 364692"];
1105 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 364693"];
1106 [label="SymbolDisplayCompilerInternalOptions.None 364694"];
1107 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 364695"];
1108 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 364696"];
1109 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 364697"];
1110 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 364698"];
1111 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 364699"];
1112 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 364700"];
1113 [label="get { return _options; } 364701"];
1114 [label="return _options; 364702"];
1115 [label="get { return CSharp.MessageProvider.Instance; } 364703"];
1116 [label="return CSharp.MessageProvider.Instance; 364704"];
1117 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364705"];
1118 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 364706"];
1119 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 364707"];
1120 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 364708"];
1121 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 364709"];
1122 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 364710"];
1123 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 364711"];
1124 [label="param CreateAssemblyDataForFile(this) 364712"];
1125 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364713"];
1126 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364714"];
1127 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364715"];
1128 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364716"];
1129 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364717"];
1130 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364718"];
1131 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 364719"];
1132 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 364720"];
1133 [label="param AssemblyDataForFile(PEAssembly assembly) 364721"];
1134 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 364722"];
1135 [label="param AssemblyDataForFile(bool embedInteropTypes) 364723"];
1136 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 364724"];
1137 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 364725"];
1138 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 364726"];
1139 [label="param AssemblyDataForFile(this) 364727"];
1140 [label="assembly.Identity 364728"];
1141 [label="assembly.AssemblyReferences 364729"];
1142 [label="embedInteropTypes 364730"];
1143 [label="param AssemblyDataForFile(this) 364731"];
1144 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 364732"];
1145 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 364733"];
1146 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 364734"];
1147 [label="param AssemblyDataForMetadataOrCompilation(this) 364735"];
1148 [label="param AssemblyDataForMetadataOrCompilation(this) 364736"];
1149 [label="_assemblies 364737"];
1150 [label="_identity 364738"];
1151 [label="_embedInteropTypes 364739"];
1152 [label="RoslynDebug.Assert(identity != null); 364740"];
1153 [label="RoslynDebug.Assert(identity != null); 364741"];
1154 [label="Debug.Assert(!referencedAssemblies.IsDefault); 364742"];
1155 [label="_embedInteropTypes 364743"];
1156 [label="_identity 364744"];
1157 [label="_referencedAssemblies 364745"];
1158 [label="Assembly 364746"];
1159 [label="CachedSymbols 364747"];
1160 [label="DocumentationProvider 364748"];
1161 [label="_compilationImportOptions 364749"];
1162 [label="_sourceAssemblySimpleName 364750"];
1163 [label="_internalsVisibleComputed 364751"];
1164 [label="_internalsPotentiallyVisibleToCompilation 364752"];
1165 [label="RoslynDebug.Assert(documentationProvider != null); 364753"];
1166 [label="RoslynDebug.Assert(documentationProvider != null); 364754"];
1167 [label="RoslynDebug.Assert(cachedSymbols != null); 364755"];
1168 [label="RoslynDebug.Assert(cachedSymbols != null); 364756"];
1169 [label="CachedSymbols 364757"];
1170 [label="Assembly 364758"];
1171 [label="DocumentationProvider 364759"];
1172 [label="_compilationImportOptions 364760"];
1173 [label="_sourceAssemblySimpleName 364761"];
1174 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 364762"];
1175 [label="RoslynDebug.Assert(identity != null); 364763"];
1176 [label="Debug.Assert(!referencedAssemblies.IsDefault); 364764"];
1177 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 364765"];
1178 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 364766"];
1179 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 364767"];
1180 [label="get\n                    {\n                        return _identity;\n                    } 364768"];
1181 [label="return _identity; 364769"];
1182 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 364770"];
1183 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 364771"];
1184 [label="bool hasCircularReference; 364772"];
1185 [label="int corLibraryIndex; 364773"];
1186 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 364774"];
1187 [label="implicitlyResolvedReferences 364775"];
1188 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 364776"];
1189 [label="implicitlyResolvedReferenceMap 364777"];
1190 [label="ImmutableArray<AssemblyData> allAssemblyData; 364778"];
1191 [label="allAssemblyData 364779"];
1192 [label="var temp1 = compilation.ScriptCompilationInfo; 364780"];
1193 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 364781"];
1194 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 364782"];
1195 [label="temp1 != null 364783"];
1196 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 364784"];
1197 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 364785"];
1198 [label="temp2 != null 364786"];
1199 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 364787"];
1200 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 364788"];
1201 [label="temp3 != null 364789"];
1202 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 364790"];
1203 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 364791"];
1204 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364792"];
1205 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364793"];
1206 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364794"];
1207 [label="compilation.Options 364795"];
1208 [label="get\n            {\n                return _options;\n            } 364796"];
1209 [label="return _options; 364797"];
1210 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364798"];
1211 [label="compilation.Options 364799"];
1212 [label="get\n            {\n                return _options;\n            } 364800"];
1213 [label="return _options; 364801"];
1214 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364802"];
1215 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364803"];
1216 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364804"];
1217 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364805"];
1218 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364806"];
1219 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364807"];
1220 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364808"];
1221 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364809"];
1222 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364810"];
1223 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364811"];
1224 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364812"];
1225 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 364813"];
1226 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 364814"];
1227 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 364815"];
1228 [label="param BindAssemblyReferences(this) 364816"];
1229 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 364817"];
1230 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 364818"];
1231 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 364819"];
1232 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 364820"];
1233 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 364821"];
1234 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 364822"];
1235 [label="return _embedInteropTypes; 364823"];
1236 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 364824"];
1237 [label="return _referencedAssemblies; 364825"];
1238 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 364826"];
1239 [label="return Assembly.ContainsNoPiaLocalTypes(); 364827"];
1240 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 364828"];
1241 [label="return Assembly.DeclaresTheObjectClass; 364829"];
1242 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 364830"];
1243 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 364831"];
1244 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 364832"];
1245 [label="_assemblies = new List<AssemblySymbol>(); 364833"];
1246 [label="_assemblies 364834"];
1247 [label="AddAvailableSymbols(_assemblies); 364835"];
1248 [label="AddAvailableSymbols(_assemblies) 364836"];
1249 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 364837"];
1250 [label="param AddAvailableSymbols(this) 364838"];
1251 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 364839"];
1252 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 364840"];
1253 [label="AddAvailableSymbols(_assemblies); 364841"];
1254 [label="return _assemblies; 364842"];
1255 [label="AddAvailableSymbols(_assemblies); 364843"];
1256 [label="AddAvailableSymbols(_assemblies) 364844"];
1257 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 364845"];
1258 [label="param AddAvailableSymbols(this) 364846"];
1259 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 364847"];
1260 [label="AddAvailableSymbols(_assemblies); 364848"];
1261 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 364849"];
1262 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 364850"];
1263 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 364851"];
1264 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 364852"];
1265 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 364853"];
1266 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 364854"];
1267 [label="aliasesOfReferencedAssemblies 364855"];
1268 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364856"];
1269 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364857"];
1270 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364858"];
1271 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364859"];
1272 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364860"];
1273 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364861"];
1274 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364862"];
1275 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364863"];
1276 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364864"];
1277 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 364865"];
1278 [label="var newSymbols = new List<int>(); 364866"];
1279 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 364867"];
1280 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 364868"];
1281 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 364869"];
1282 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 364870"];
1283 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 364871"];
1284 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 364872"];
1285 [label="param CreateAssemblySymbol(this) 364873"];
1286 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 364874"];
1287 [label="this.IsLinked 364875"];
1288 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 364876"];
1289 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 364877"];
1290 [label="this.EffectiveImportOptions 364878"];
1291 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 364879"];
1292 [label="InternalsMayBeVisibleToCompilation 364880"];
1293 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 364881"];
1294 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 364882"];
1295 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 364883"];
1296 [label="_internalsPotentiallyVisibleToCompilation 364884"];
1297 [label="_internalsVisibleComputed = true; 364885"];
1298 [label="_internalsVisibleComputed 364886"];
1299 [label="return _internalsPotentiallyVisibleToCompilation; 364887"];
1300 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 364888"];
1301 [label="return _compilationImportOptions; 364889"];
1302 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 364890"];
1303 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 364891"];
1304 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 364892"];
1305 [label="param PEAssemblySymbol(PEAssembly assembly) 364893"];
1306 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 364894"];
1307 [label="param PEAssemblySymbol(bool isLinked) 364895"];
1308 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 364896"];
1309 [label="param PEAssemblySymbol(this) 364897"];
1310 [label="param PEAssemblySymbol(this) 364898"];
1311 [label="param MetadataOrSourceAssemblySymbol(this) 364899"];
1312 [label="param MetadataOrSourceAssemblySymbol(this) 364900"];
1313 [label="param NonMissingAssemblySymbol(this) 364901"];
1314 [label="new char[] { '+' } 364902"];
1315 [label="'+' 364903"];
1316 [label="new char[] { '+' } 364904"];
1317 [label="s_nestedTypeNameSeparators = new char[] { '+' } 364905"];
1318 [label="param NonMissingAssemblySymbol(this) 364906"];
1319 [label="param AssemblySymbol(this) 364907"];
1320 [label="param AssemblySymbol(this) 364908"];
1321 [label="param Symbol(this) 364909"];
1322 [label="_lazyISymbol 364910"];
1323 [label="_corLibrary 364911"];
1324 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 364912"];
1325 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 364913"];
1326 [label="_globalNamespace 364914"];
1327 [label="_lazySpecialTypes 364915"];
1328 [label="_cachedSpecialTypes 364916"];
1329 [label="_lazyNativeIntegerTypes 364917"];
1330 [label="_lazyTypeNames 364918"];
1331 [label="_lazyNamespaceNames 364919"];
1332 [label="_lazySpecialTypeMembers 364920"];
1333 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 364921"];
1334 [label="_assembly 364922"];
1335 [label="_documentationProvider 364923"];
1336 [label="_isLinked 364924"];
1337 [label="Debug.Assert(assembly != null); 364925"];
1338 [label="Debug.Assert(assembly != null); 364926"];
1339 [label="Debug.Assert(documentationProvider != null); 364927"];
1340 [label="Debug.Assert(documentationProvider != null); 364928"];
1341 [label="_assembly 364929"];
1342 [label="_documentationProvider 364930"];
1343 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 364931"];
1344 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 364932"];
1345 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 364933"];
1346 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 364934"];
1347 [label="31 364935"];
1348 [label="DefaultTypeMapCapacity = 31 364936"];
1349 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 364937"];
1350 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 364938"];
1351 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 364939"];
1352 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 364940"];
1353 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 364941"];
1354 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 364942"];
1355 [label="param PEModuleSymbol(PEModule module) 364943"];
1356 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 364944"];
1357 [label="param PEModuleSymbol(int ordinal) 364945"];
1358 [label="param PEModuleSymbol(this) 364946"];
1359 [label="assemblySymbol 364947"];
1360 [label="module 364948"];
1361 [label="importOptions 364949"];
1362 [label="ordinal 364950"];
1363 [label="param PEModuleSymbol(this) 364951"];
1364 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 364952"];
1365 [label="param PEModuleSymbol(PEModule module) 364953"];
1366 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 364954"];
1367 [label="param PEModuleSymbol(int ordinal) 364955"];
1368 [label="param PEModuleSymbol(this) 364956"];
1369 [label="param PEModuleSymbol(this) 364957"];
1370 [label="param NonMissingModuleSymbol(this) 364958"];
1371 [label="param NonMissingModuleSymbol(this) 364959"];
1372 [label="param ModuleSymbol(this) 364960"];
1373 [label="param ModuleSymbol(this) 364961"];
1374 [label="param Symbol(this) 364962"];
1375 [label="_lazyISymbol 364963"];
1376 [label="_moduleReferences 364964"];
1377 [label="_assemblySymbol 364965"];
1378 [label="_ordinal 364966"];
1379 [label="_module 364967"];
1380 [label="_globalNamespace 364968"];
1381 [label="_lazySystemTypeSymbol 364969"];
1382 [label="_lazyEventRegistrationTokenSymbol 364970"];
1383 [label="_lazyEventRegistrationTokenTableSymbol 364971"];
1384 [label="2 364972"];
1385 [label="concurrencyLevel: 2 364973"];
1386 [label="capacity: DefaultTypeMapCapacity 364974"];
1387 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 364975"];
1388 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 364976"];
1389 [label="2 364977"];
1390 [label="concurrencyLevel: 2 364978"];
1391 [label="capacity: DefaultTypeMapCapacity 364979"];
1392 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 364980"];
1393 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 364981"];
1394 [label="ImportOptions 364982"];
1395 [label="_lazyTypeNames 364983"];
1396 [label="_lazyNamespaceNames 364984"];
1397 [label="_lazyNullableMemberMetadata 364985"];
1398 [label="Debug.Assert((object)assemblySymbol != null); 364986"];
1399 [label="Debug.Assert((object)assemblySymbol != null); 364987"];
1400 [label="Debug.Assert(module != null); 364988"];
1401 [label="Debug.Assert(module != null); 364989"];
1402 [label="_assemblySymbol 364990"];
1403 [label="_ordinal 364991"];
1404 [label="_module 364992"];
1405 [label="this.ImportOptions 364993"];
1406 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 364994"];
1407 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 364995"];
1408 [label="new PEGlobalNamespaceSymbol(this) 364996"];
1409 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 364997"];
1410 [label="param PEGlobalNamespaceSymbol(this) 364998"];
1411 [label="param PEGlobalNamespaceSymbol(this) 364999"];
1412 [label="param PENamespaceSymbol(this) 365000"];
1413 [label="param PENamespaceSymbol(this) 365001"];
1414 [label="param NamespaceSymbol(this) 365002"];
1415 [label="param NamespaceSymbol(this) 365003"];
1416 [label="param NamespaceOrTypeSymbol(this) 365004"];
1417 [label="param NamespaceOrTypeSymbol(this) 365005"];
1418 [label="param Symbol(this) 365006"];
1419 [label="_lazyISymbol 365007"];
1420 [label="_lazyAdapter 365008"];
1421 [label="_lazyQualifiedName 365009"];
1422 [label="lazyNamespaces 365010"];
1423 [label="lazyTypes 365011"];
1424 [label="_lazyNoPiaLocalTypes 365012"];
1425 [label="_moduleSymbol 365013"];
1426 [label="Debug.Assert((object)moduleSymbol != null); 365014"];
1427 [label="Debug.Assert((object)moduleSymbol != null); 365015"];
1428 [label="_moduleSymbol 365016"];
1429 [label="_globalNamespace 365017"];
1430 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 365018"];
1431 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 365019"];
1432 [label="this.MetadataLocation 365020"];
1433 [label="Debug.Assert(ordinal >= 0); 365021"];
1434 [label="Debug.Assert(ordinal >= 0); 365022"];
1435 [label="modules[i] 365023"];
1436 [label="_modules = modules.AsImmutableOrNull(); 365024"];
1437 [label="_modules = modules.AsImmutableOrNull(); 365025"];
1438 [label="_modules 365026"];
1439 [label="_isLinked 365027"];
1440 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 365028"];
1441 [label="bound.AssemblySymbol 365029"];
1442 [label="newSymbols.Add(i); 365030"];
1443 [label="newSymbols.Add(i); 365031"];
1444 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 365032"];
1445 [label="allAssemblyData[i].IsLinked 365033"];
1446 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 365034"];
1447 [label="bound.AssemblySymbol.IsLinked 365035"];
1448 [label="get\n            {\n                return _isLinked;\n            } 365036"];
1449 [label="return _isLinked; 365037"];
1450 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 365038"];
1451 [label="return _internalsPotentiallyVisibleToCompilation; 365039"];
1452 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 365040"];
1453 [label="_assembly 365041"];
1454 [label="_documentationProvider 365042"];
1455 [label="Debug.Assert(assembly != null); 365043"];
1456 [label="Debug.Assert(documentationProvider != null); 365044"];
1457 [label="_assemblySymbol 365045"];
1458 [label="_ordinal 365046"];
1459 [label="_module 365047"];
1460 [label="_globalNamespace 365048"];
1461 [label="ImportOptions 365049"];
1462 [label="Debug.Assert((object)assemblySymbol != null); 365050"];
1463 [label="Debug.Assert(module != null); 365051"];
1464 [label="_moduleSymbol 365052"];
1465 [label="Debug.Assert((object)moduleSymbol != null); 365053"];
1466 [label="Debug.Assert(ordinal >= 0); 365054"];
1467 [label="bound.AssemblySymbol 365055"];
1468 [label="newSymbols.Add(i); 365056"];
1469 [label="newSymbols.Add(i); 365057"];
1470 [label="allAssemblyData[i].IsLinked 365058"];
1471 [label="bound.AssemblySymbol.IsLinked 365059"];
1472 [label="get\n            {\n                return _isLinked;\n            } 365060"];
1473 [label="return _isLinked; 365061"];
1474 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 365062"];
1475 [label="_assembly 365063"];
1476 [label="_documentationProvider 365064"];
1477 [label="_assemblySymbol 365065"];
1478 [label="_ordinal 365066"];
1479 [label="_module 365067"];
1480 [label="_globalNamespace 365068"];
1481 [label="ImportOptions 365069"];
1482 [label="Debug.Assert((object)assemblySymbol != null); 365070"];
1483 [label="Debug.Assert(module != null); 365071"];
1484 [label="_moduleSymbol 365072"];
1485 [label="Debug.Assert((object)moduleSymbol != null); 365073"];
1486 [label="Debug.Assert(ordinal >= 0); 365074"];
1487 [label="bound.AssemblySymbol 365075"];
1488 [label="newSymbols.Add(i); 365076"];
1489 [label="get\n            {\n                return _isLinked;\n            } 365077"];
1490 [label="return _isLinked; 365078"];
1491 [label="return _internalsPotentiallyVisibleToCompilation; 365079"];
1492 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 365080"];
1493 [label="_assembly 365081"];
1494 [label="_documentationProvider 365082"];
1495 [label="Debug.Assert(assembly != null); 365083"];
1496 [label="Debug.Assert(documentationProvider != null); 365084"];
1497 [label="Debug.Assert(ordinal >= 0); 365085"];
1498 [label="bound.AssemblySymbol 365086"];
1499 [label="newSymbols.Add(i); 365087"];
1500 [label="newSymbols.Add(i); 365088"];
1501 [label="bound.AssemblySymbol.IsLinked 365089"];
1502 [label="get\n            {\n                return _isLinked;\n            } 365090"];
1503 [label="return _isLinked; 365091"];
1504 [label="newSymbols.Add(i); 365092"];
1505 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 365093"];
1506 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 365094"];
1507 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 365095"];
1508 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 365096"];
1509 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 365097"];
1510 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 365098"];
1511 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 365099"];
1512 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 365100"];
1513 [label="param SourceAssemblySymbol(string assemblySimpleName) 365101"];
1514 [label="param SourceAssemblySymbol(string moduleName) 365102"];
1515 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 365103"];
1516 [label="param SourceAssemblySymbol(this) 365104"];
1517 [label="param SourceAssemblySymbol(this) 365105"];
1518 [label="param MetadataOrSourceAssemblySymbol(this) 365106"];
1519 [label="param MetadataOrSourceAssemblySymbol(this) 365107"];
1520 [label="param NonMissingAssemblySymbol(this) 365108"];
1521 [label="param NonMissingAssemblySymbol(this) 365109"];
1522 [label="param AssemblySymbol(this) 365110"];
1523 [label="param AssemblySymbol(this) 365111"];
1524 [label="param Symbol(this) 365112"];
1525 [label="_lazyISymbol 365113"];
1526 [label="_corLibrary 365114"];
1527 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 365115"];
1528 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 365116"];
1529 [label="_globalNamespace 365117"];
1530 [label="_lazySpecialTypes 365118"];
1531 [label="_cachedSpecialTypes 365119"];
1532 [label="_lazyNativeIntegerTypes 365120"];
1533 [label="_lazyTypeNames 365121"];
1534 [label="_lazyNamespaceNames 365122"];
1535 [label="_lazySpecialTypeMembers 365123"];
1536 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 365124"];
1537 [label="_compilation 365125"];
1538 [label="lazyAssemblyIdentity 365126"];
1539 [label="_assemblySimpleName 365127"];
1540 [label="_lazyStrongNameKeys 365128"];
1541 [label="_lazySourceAttributesBag 365129"];
1542 [label="_lazyNetModuleAttributesBag 365130"];
1543 [label="_lazyForwardedTypesFromSource 365131"];
1544 [label="_lazyOmittedAttributeIndices 365132"];
1545 [label="_lazyContainsExtensionMethods 365133"];
1546 [label="new ConcurrentDictionary<FieldSymbol, bool>() 365134"];
1547 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 365135"];
1548 [label="new ConcurrentSet<FieldSymbol>() 365136"];
1549 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 365137"];
1550 [label="new ConcurrentSet<TypeSymbol>() 365138"];
1551 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 365139"];
1552 [label="_optimisticallyGrantedInternalsAccess 365140"];
1553 [label="_lazyInternalsVisibleToMap 365141"];
1554 [label="Debug.Assert(compilation != null); 365142"];
1555 [label="Debug.Assert(compilation != null); 365143"];
1556 [label="Debug.Assert(assemblySimpleName != null); 365144"];
1557 [label="Debug.Assert(assemblySimpleName != null); 365145"];
1558 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 365146"];
1559 [label="Debug.Assert(!netModules.IsDefault); 365147"];
1560 [label="_compilation 365148"];
1561 [label="_assemblySimpleName 365149"];
1562 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 365150"];
1563 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 365151"];
1564 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 365152"];
1565 [label="compilation.Declarations 365153"];
1566 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 365154"];
1567 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 365155"];
1568 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 365156"];
1569 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 365157"];
1570 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 365158"];
1571 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 365159"];
1572 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 365160"];
1573 [label="param SourceModuleSymbol(DeclarationTable declarations) 365161"];
1574 [label="param SourceModuleSymbol(string moduleName) 365162"];
1575 [label="param SourceModuleSymbol(this) 365163"];
1576 [label="param SourceModuleSymbol(this) 365164"];
1577 [label="param NonMissingModuleSymbol(this) 365165"];
1578 [label="param NonMissingModuleSymbol(this) 365166"];
1579 [label="param ModuleSymbol(this) 365167"];
1580 [label="param ModuleSymbol(this) 365168"];
1581 [label="param Symbol(this) 365169"];
1582 [label="_lazyISymbol 365170"];
1583 [label="_moduleReferences 365171"];
1584 [label="_assemblySymbol 365172"];
1585 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 365173"];
1586 [label="_sources 365174"];
1587 [label="_lazyCustomAttributesBag 365175"];
1588 [label="_globalNamespace 365176"];
1589 [label="_hasBadAttributes 365177"];
1590 [label="_name 365178"];
1591 [label="Debug.Assert((object)assemblySymbol != null); 365179"];
1592 [label="Debug.Assert((object)assemblySymbol != null); 365180"];
1593 [label="_assemblySymbol 365181"];
1594 [label="_sources 365182"];
1595 [label="_name 365183"];
1596 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 365184"];
1597 [label="compilation.Options 365185"];
1598 [label="get\n            {\n                return _options;\n            } 365186"];
1599 [label="return _options; 365187"];
1600 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 365188"];
1601 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 365189"];
1602 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 365190"];
1603 [label="_modules = moduleBuilder.ToImmutableAndFree(); 365191"];
1604 [label="_modules 365192"];
1605 [label="compilation.Options 365193"];
1606 [label="get\n            {\n                return _options;\n            } 365194"];
1607 [label="return _options; 365195"];
1608 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 365196"];
1609 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 365197"];
1610 [label="AssemblySymbol? corLibrary; 365198"];
1611 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 365199"];
1612 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 365200"];
1613 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 365201"];
1614 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 365202"];
1615 [label="assemblySymbol.SetCorLibrary(corLibrary); 365203"];
1616 [label="assemblySymbol.SetCorLibrary(corLibrary) 365204"];
1617 [label="param SetCorLibrary(AssemblySymbol corLibrary) 365205"];
1618 [label="param SetCorLibrary(this) 365206"];
1619 [label="Debug.Assert((object)_corLibrary == null); 365207"];
1620 [label="Debug.Assert((object)_corLibrary == null); 365208"];
1621 [label="_corLibrary 365209"];
1622 [label="assemblySymbol.SetCorLibrary(corLibrary); 365210"];
1623 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 365211"];
1624 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 365212"];
1625 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 365213"];
1626 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 365214"];
1627 [label="moduleReferences 365215"];
1628 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365216"];
1629 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365217"];
1630 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365218"];
1631 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365219"];
1632 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365220"];
1633 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365221"];
1634 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 365222"];
1635 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 365223"];
1636 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 365224"];
1637 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 365225"];
1638 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 365226"];
1639 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 365227"];
1640 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 365228"];
1641 [label="sourceAssembly.Modules 365229"];
1642 [label="get\n            {\n                return _modules;\n            } 365230"];
1643 [label="return _modules; 365231"];
1644 [label="var moduleSymbols = sourceAssembly.Modules; 365232"];
1645 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 365233"];
1646 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 365234"];
1647 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 365235"];
1648 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 365236"];
1649 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 365237"];
1650 [label="(moduleSymbols.Length > 1) 365238"];
1651 [label="int refsUsed = 0; 365239"];
1652 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 365240"];
1653 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 365241"];
1654 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 365242"];
1655 [label="(moduleIndex == 0) 365243"];
1656 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 365244"];
1657 [label="var identities = new AssemblyIdentity[refsCount]; 365245"];
1658 [label="var symbols = new AssemblySymbol[refsCount]; 365246"];
1659 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 365247"];
1660 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 365248"];
1661 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 365249"];
1662 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 365250"];
1663 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 365251"];
1664 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365252"];
1665 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365253"];
1666 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365254"];
1667 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365255"];
1668 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 365256"];
1669 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 365257"];
1670 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365258"];
1671 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365259"];
1672 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365260"];
1673 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 365261"];
1674 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 365262"];
1675 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 365263"];
1676 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 365264"];
1677 [label="Debug.Assert(referenceBinding.IsBound); 365265"];
1678 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 365266"];
1679 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 365267"];
1680 [label="Debug.Assert(assembly is object); 365268"];
1681 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365269"];
1682 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365270"];
1683 [label="return assembly; 365271"];
1684 [label="symbols[k] 365272"];
1685 [label="identities[k] 365273"];
1686 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365274"];
1687 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 365275"];
1688 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 365276"];
1689 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 365277"];
1690 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365278"];
1691 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365279"];
1692 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 365280"];
1693 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 365281"];
1694 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 365282"];
1695 [label="Debug.Assert(referenceBinding.IsBound); 365283"];
1696 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 365284"];
1697 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 365285"];
1698 [label="Debug.Assert(assembly is object); 365286"];
1699 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365287"];
1700 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365288"];
1701 [label="return assembly; 365289"];
1702 [label="symbols[k] 365290"];
1703 [label="identities[k] 365291"];
1704 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365292"];
1705 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365293"];
1706 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365294"];
1707 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365295"];
1708 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365296"];
1709 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 365297"];
1710 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 365298"];
1711 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 365299"];
1712 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 365300"];
1713 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 365301"];
1714 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 365302"];
1715 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 365303"];
1716 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 365304"];
1717 [label="param SetReferences(this) 365305"];
1718 [label="Debug.Assert(moduleReferences != null); 365306"];
1719 [label="Debug.Assert(moduleReferences != null); 365307"];
1720 [label="AssertReferencesUninitialized() 365308"];
1721 [label="param AssertReferencesUninitialized(this) 365309"];
1722 [label="Debug.Assert(_moduleReferences == null); 365310"];
1723 [label="Debug.Assert(_moduleReferences == null); 365311"];
1724 [label="AssertReferencesUninitialized(); 365312"];
1725 [label="_moduleReferences 365313"];
1726 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 365314"];
1727 [label="refsUsed += refsCount; 365315"];
1728 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 365316"];
1729 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 365317"];
1730 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 365318"];
1731 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 365319"];
1732 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 365320"];
1733 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 365321"];
1734 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 365322"];
1735 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 365323"];
1736 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 365324"];
1737 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 365325"];
1738 [label="param InitializeNewSymbols(List<int> newSymbols) 365326"];
1739 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 365327"];
1740 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 365328"];
1741 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 365329"];
1742 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 365330"];
1743 [label="Debug.Assert(newSymbols.Count > 0); 365331"];
1744 [label="Debug.Assert(newSymbols.Count > 0); 365332"];
1745 [label="sourceAssembly.CorLibrary 365333"];
1746 [label="get\n            {\n                return _corLibrary;\n            } 365334"];
1747 [label="return _corLibrary; 365335"];
1748 [label="var corLibrary = sourceAssembly.CorLibrary; 365336"];
1749 [label="RoslynDebug.Assert((object)corLibrary != null); 365337"];
1750 [label="RoslynDebug.Assert((object)corLibrary != null); 365338"];
1751 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 365339"];
1752 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 365340"];
1753 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 365341"];
1754 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 365342"];
1755 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 365343"];
1756 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365344"];
1757 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365345"];
1758 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365346"];
1759 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365347"];
1760 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365348"];
1761 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 365349"];
1762 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 365350"];
1763 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 365351"];
1764 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 365352"];
1765 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 365353"];
1766 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 365354"];
1767 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365355"];
1768 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365356"];
1769 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 365357"];
1770 [label="portableExecutableAssemblySymbol.Modules 365358"];
1771 [label="get\n            {\n                return _modules;\n            } 365359"];
1772 [label="return _modules; 365360"];
1773 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 365361"];
1774 [label="int moduleCount = modules.Length; 365362"];
1775 [label="int refsUsed = 0; 365363"];
1776 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 365364"];
1777 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 365365"];
1778 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 365366"];
1779 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 365367"];
1780 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 365368"];
1781 [label="fileData.AssemblyReferences 365369"];
1782 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 365370"];
1783 [label="return _referencedAssemblies; 365371"];
1784 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365372"];
1785 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365373"];
1786 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365374"];
1787 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365375"];
1788 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365376"];
1789 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 365377"];
1790 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 365378"];
1791 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 365379"];
1792 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 365380"];
1793 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365381"];
1794 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365382"];
1795 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365383"];
1796 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365384"];
1797 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365385"];
1798 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 365386"];
1799 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 365387"];
1800 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 365388"];
1801 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 365389"];
1802 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 365390"];
1803 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 365391"];
1804 [label="param SetReferences(this) 365392"];
1805 [label="Debug.Assert(moduleReferences != null); 365393"];
1806 [label="Debug.Assert(moduleReferences != null); 365394"];
1807 [label="AssertReferencesUninitialized() 365395"];
1808 [label="param AssertReferencesUninitialized(this) 365396"];
1809 [label="Debug.Assert(_moduleReferences == null); 365397"];
1810 [label="Debug.Assert(_moduleReferences == null); 365398"];
1811 [label="AssertReferencesUninitialized(); 365399"];
1812 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 365400"];
1813 [label="refsUsed += moduleReferenceCount; 365401"];
1814 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365402"];
1815 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365403"];
1816 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365404"];
1817 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 365405"];
1818 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 365406"];
1819 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365407"];
1820 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365408"];
1821 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 365409"];
1822 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 365410"];
1823 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 365411"];
1824 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365412"];
1825 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365413"];
1826 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 365414"];
1827 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 365415"];
1828 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 365416"];
1829 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 365417"];
1830 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 365418"];
1831 [label="Debug.Assert(referenceBinding.IsBound); 365419"];
1832 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 365420"];
1833 [label="Debug.Assert(assembly is object); 365421"];
1834 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365422"];
1835 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365423"];
1836 [label="symbols[k] 365424"];
1837 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 365425"];
1838 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 365426"];
1839 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 365427"];
1840 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 365428"];
1841 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 365429"];
1842 [label="MissingAssemblySymbol? missingAssembly; 365430"];
1843 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 365431"];
1844 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 365432"];
1845 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 365433"];
1846 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 365434"];
1847 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 365435"];
1848 [label="new MissingAssemblySymbol(assemblyIdentity) 365436"];
1849 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 365437"];
1850 [label="param MissingAssemblySymbol(this) 365438"];
1851 [label="param MissingAssemblySymbol(this) 365439"];
1852 [label="identity 365440"];
1853 [label="moduleSymbol 365441"];
1854 [label="Debug.Assert(identity != null); 365442"];
1855 [label="Debug.Assert(identity != null); 365443"];
1856 [label="this.identity 365444"];
1857 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 365445"];
1858 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 365446"];
1859 [label="new MissingModuleSymbol(this, 0) 365447"];
1860 [label="param MissingModuleSymbol(AssemblySymbol assembly) 365448"];
1861 [label="param MissingModuleSymbol(int ordinal) 365449"];
1862 [label="param MissingModuleSymbol(this) 365450"];
1863 [label="param MissingModuleSymbol(this) 365451"];
1864 [label="assembly 365452"];
1865 [label="ordinal 365453"];
1866 [label="globalNamespace 365454"];
1867 [label="Debug.Assert((object)assembly != null); 365455"];
1868 [label="Debug.Assert((object)assembly != null); 365456"];
1869 [label="Debug.Assert(ordinal >= -1); 365457"];
1870 [label="Debug.Assert(ordinal >= -1); 365458"];
1871 [label="this.assembly 365459"];
1872 [label="this.ordinal 365460"];
1873 [label="globalNamespace = new MissingNamespaceSymbol(this); 365461"];
1874 [label="globalNamespace = new MissingNamespaceSymbol(this); 365462"];
1875 [label="new MissingNamespaceSymbol(this) 365463"];
1876 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 365464"];
1877 [label="param MissingNamespaceSymbol(this) 365465"];
1878 [label="param MissingNamespaceSymbol(this) 365466"];
1879 [label="_name 365467"];
1880 [label="_containingSymbol 365468"];
1881 [label="Debug.Assert((object)containingModule != null); 365469"];
1882 [label="Debug.Assert((object)containingModule != null); 365470"];
1883 [label="_containingSymbol 365471"];
1884 [label="_name 365472"];
1885 [label="globalNamespace 365473"];
1886 [label="moduleSymbol 365474"];
1887 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 365475"];
1888 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 365476"];
1889 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 365477"];
1890 [label="return missingAssembly; 365478"];
1891 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 365479"];
1892 [label="symbols[k] 365480"];
1893 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 365481"];
1894 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 365482"];
1895 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 365483"];
1896 [label="identity 365484"];
1897 [label="moduleSymbol 365485"];
1898 [label="Debug.Assert(identity != null); 365486"];
1899 [label="assembly 365487"];
1900 [label="ordinal 365488"];
1901 [label="globalNamespace 365489"];
1902 [label="Debug.Assert((object)assembly != null); 365490"];
1903 [label="Debug.Assert(ordinal >= -1); 365491"];
1904 [label="_name 365492"];
1905 [label="_containingSymbol 365493"];
1906 [label="Debug.Assert((object)containingModule != null); 365494"];
1907 [label="return missingAssembly; 365495"];
1908 [label="symbols[k] 365496"];
1909 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 365497"];
1910 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 365498"];
1911 [label="Debug.Assert(moduleReferences != null); 365499"];
1912 [label="Debug.Assert(moduleReferences != null); 365500"];
1913 [label="AssertReferencesUninitialized() 365501"];
1914 [label="param AssertReferencesUninitialized(this) 365502"];
1915 [label="Debug.Assert(_moduleReferences == null); 365503"];
1916 [label="Debug.Assert(_moduleReferences == null); 365504"];
1917 [label="AssertReferencesUninitialized(); 365505"];
1918 [label="refsUsed += moduleReferenceCount; 365506"];
1919 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 365507"];
1920 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 365508"];
1921 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365509"];
1922 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365510"];
1923 [label="Debug.Assert(referenceBinding.IsBound); 365511"];
1924 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 365512"];
1925 [label="Debug.Assert(assembly is object); 365513"];
1926 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 365514"];
1927 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 365515"];
1928 [label="Debug.Assert(moduleReferences != null); 365516"];
1929 [label="AssertReferencesUninitialized() 365517"];
1930 [label="param AssertReferencesUninitialized(this) 365518"];
1931 [label="Debug.Assert(_moduleReferences == null); 365519"];
1932 [label="Debug.Assert(_moduleReferences == null); 365520"];
1933 [label="AssertReferencesUninitialized(); 365521"];
1934 [label="refsUsed += moduleReferenceCount; 365522"];
1935 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 365523"];
1936 [label="sourceAssembly.Modules 365524"];
1937 [label="get\n            {\n                return _modules;\n            } 365525"];
1938 [label="return _modules; 365526"];
1939 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 365527"];
1940 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 365528"];
1941 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 365529"];
1942 [label="param GetReferencedAssemblySymbols(this) 365530"];
1943 [label="AssertReferencesInitialized() 365531"];
1944 [label="param AssertReferencesInitialized(this) 365532"];
1945 [label="Debug.Assert(_moduleReferences != null); 365533"];
1946 [label="Debug.Assert(_moduleReferences != null); 365534"];
1947 [label="AssertReferencesInitialized(); 365535"];
1948 [label="return _moduleReferences.Symbols; 365536"];
1949 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 365537"];
1950 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 365538"];
1951 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365539"];
1952 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365540"];
1953 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 365541"];
1954 [label="assemblies[i].ContainsNoPiaLocalTypes 365542"];
1955 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 365543"];
1956 [label="linkedReferencedAssembliesBuilder.Clear(); 365544"];
1957 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 365545"];
1958 [label="assemblies[i].IsLinked 365546"];
1959 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 365547"];
1960 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 365548"];
1961 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 365549"];
1962 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 365550"];
1963 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 365551"];
1964 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 365552"];
1965 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 365553"];
1966 [label="param SetCorLibrary(AssemblySymbol corLibrary) 365554"];
1967 [label="param SetCorLibrary(this) 365555"];
1968 [label="Debug.Assert((object)_corLibrary == null); 365556"];
1969 [label="Debug.Assert((object)_corLibrary == null); 365557"];
1970 [label="_corLibrary 365558"];
1971 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 365559"];
1972 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 365560"];
1973 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365561"];
1974 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365562"];
1975 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 365563"];
1976 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 365564"];
1977 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 365565"];
1978 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 365566"];
1979 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 365567"];
1980 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 365568"];
1981 [label="Debug.Assert((object)_corLibrary == null); 365569"];
1982 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 365570"];
1983 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 365571"];
1984 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 365572"];
1985 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 365573"];
1986 [label="Debug.Assert((object)_corLibrary == null); 365574"];
1987 [label="linkedReferencedAssembliesBuilder.Free(); 365575"];
1988 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 365576"];
1989 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 365577"];
1990 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 365578"];
1991 [label="missingAssembly.SetCorLibrary(corLibrary); 365579"];
1992 [label="missingAssembly.SetCorLibrary(corLibrary) 365580"];
1993 [label="param SetCorLibrary(AssemblySymbol corLibrary) 365581"];
1994 [label="Debug.Assert((object)_corLibrary == null); 365582"];
1995 [label="missingAssembly.SetCorLibrary(corLibrary); 365583"];
1996 [label="Debug.Assert((object)_corLibrary == null); 365584"];
1997 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 365585"];
1998 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 365586"];
1999 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 365587"];
2000 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 365588"];
2001 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 365589"];
2002 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 365590"];
2003 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 365591"];
2004 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 365592"];
2005 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 365593"];
2006 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 365594"];
2007 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 365595"];
2008 [label="ref BoundInputAssembly current = ref bindingResult[i]; 365596"];
2009 [label="Debug.Assert(current.AssemblySymbol is object); 365597"];
2010 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 365598"];
2011 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 365599"];
2012 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 365600"];
2013 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 365601"];
2014 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 365602"];
2015 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 365603"];
2016 [label="Debug.Assert(current.AssemblySymbol is object); 365604"];
2017 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 365605"];
2018 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365606"];
2019 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365607"];
2020 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365608"];
2021 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365609"];
2022 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365610"];
2023 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365611"];
2024 [label="ReferenceEquals(corLibrary, assemblySymbol) 365612"];
2025 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365613"];
2026 [label="assemblySymbol.SourceModule 365614"];
2027 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 365615"];
2028 [label="this.Modules 365616"];
2029 [label="get\n            {\n                return _modules;\n            } 365617"];
2030 [label="return _modules; 365618"];
2031 [label="return (SourceModuleSymbol)this.Modules[0]; 365619"];
2032 [label="return (SourceModuleSymbol)this.Modules[0]; 365620"];
2033 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 365621"];
2034 [label="param GetReferencedAssemblySymbols(this) 365622"];
2035 [label="AssertReferencesInitialized() 365623"];
2036 [label="param AssertReferencesInitialized(this) 365624"];
2037 [label="Debug.Assert(_moduleReferences != null); 365625"];
2038 [label="Debug.Assert(_moduleReferences != null); 365626"];
2039 [label="AssertReferencesInitialized(); 365627"];
2040 [label="return _moduleReferences.Symbols; 365628"];
2041 [label="assemblySymbol.SourceModule 365629"];
2042 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 365630"];
2043 [label="this.Modules 365631"];
2044 [label="get\n            {\n                return _modules;\n            } 365632"];
2045 [label="return _modules; 365633"];
2046 [label="return (SourceModuleSymbol)this.Modules[0]; 365634"];
2047 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 365635"];
2048 [label="param GetUnifiedAssemblies(this) 365636"];
2049 [label="AssertReferencesInitialized() 365637"];
2050 [label="param AssertReferencesInitialized(this) 365638"];
2051 [label="Debug.Assert(_moduleReferences != null); 365639"];
2052 [label="Debug.Assert(_moduleReferences != null); 365640"];
2053 [label="AssertReferencesInitialized(); 365641"];
2054 [label="return _moduleReferences.UnifiedAssemblies; 365642"];
2055 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 365643"];
2056 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 365644"];
2057 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 365645"];
2058 [label="compilation._referenceManager 365646"];
2059 [label="compilation._lazyAssemblySymbol 365647"];
2060 [label="return true; 365648"];
2061 [label="resolutionDiagnostics.Free(); 365649"];
2062 [label="assemblyReferencesBySimpleName.Free(); 365650"];
2063 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 365651"];
2064 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 365652"];
2065 [label="AssertBound(); 365653"];
2066 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 365654"];
2067 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 365655"];
2068 [label="Debug.Assert(_lazyAssemblySymbol is object); 365656"];
2069 [label="return _referenceManager; 365657"];
2070 [label="builder.AddRange(GetBoundReferenceManager().Diagnostics); 365658"];
2071 [label="cancellationToken.ThrowIfCancellationRequested(); 365659"];
2072 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 365660"];
2073 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 365661"];
2074 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 365662"];
2075 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 365663"];
2076 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 365664"];
2077 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 365665"];
2078 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 365666"];
2079 [label="param GetSourceDeclarationDiagnostics(this) 365667"];
2080 [label="GlobalImports 365668"];
2081 [label="=> _globalImports.Value 365669"];
2082 [label="_globalImports.Value 365670"];
2083 [label="_globalImports.Value 365671"];
2084 [label="=> Imports.FromGlobalUsings(this) 365672"];
2085 [label="null 365673"];
2086 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 365674"];
2087 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 365675"];
2088 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 365676"];
2089 [label="null 365677"];
2090 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 365678"];
2091 [label="param Imports(CSharpCompilation compilation) 365679"];
2092 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 365680"];
2093 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 365681"];
2094 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 365682"];
2095 [label="param Imports(DiagnosticBag diagnostics) 365683"];
2096 [label="param Imports(this) 365684"];
2097 [label="_compilation 365685"];
2098 [label="_diagnostics 365686"];
2099 [label="UsingAliases 365687"];
2100 [label="Debug.Assert(usingAliases != null); 365688"];
2101 [label="Debug.Assert(usingAliases != null); 365689"];
2102 [label="Debug.Assert(!usings.IsDefault); 365690"];
2103 [label="Debug.Assert(!externs.IsDefault); 365691"];
2104 [label="_compilation 365692"];
2105 [label="this.UsingAliases 365693"];
2106 [label="this.Usings 365694"];
2107 [label="_diagnostics 365695"];
2108 [label="this.ExternAliases 365696"];
2109 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 365697"];
2110 [label="this 365698"];
2111 [label="Imports.FromGlobalUsings(this) 365699"];
2112 [label="param FromGlobalUsings(CSharpCompilation compilation) 365700"];
2113 [label="compilation.Options 365701"];
2114 [label="get\n            {\n                return _options;\n            } 365702"];
2115 [label="var usings = compilation.Options.Usings; 365703"];
2116 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 365704"];
2117 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 365705"];
2118 [label="compilation.PreviousSubmission 365706"];
2119 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 365707"];
2120 [label="ScriptCompilationInfo 365708"];
2121 [label="ScriptCompilationInfo?.PreviousScriptCompilation 365709"];
2122 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 365710"];
2123 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 365711"];
2124 [label="return Empty; 365712"];
2125 [label="_globalImports.Value 365713"];
2126 [label="GlobalImports.Complete(cancellationToken); 365714"];
2127 [label="GlobalImports.Complete(cancellationToken); 365715"];
2128 [label="GlobalImports.Complete(cancellationToken) 365716"];
2129 [label="param Complete(CancellationToken cancellationToken) 365717"];
2130 [label="param Complete(this) 365718"];
2131 [label="while (true)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                var incompletePart = _state.NextIncompletePart;\n                switch (incompletePart)\n                {\n                    case CompletionPart.StartValidatingImports:\n                        {\n                            if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            }\n                        }\n                        break;\n\n                    case CompletionPart.FinishValidatingImports:\n                        // some other thread has started validating imports (otherwise we would be in the case above) so\n                        // we just wait for it to both finish and report the diagnostics.\n                        Debug.Assert(_state.HasComplete(CompletionPart.StartValidatingImports));\n                        _state.SpinWaitComplete(CompletionPart.FinishValidatingImports, cancellationToken);\n                        break;\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // any other values are completion parts intended for other kinds of symbols\n                        _state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll);\n                        break;\n                }\n\n                _state.SpinWaitComplete(incompletePart, cancellationToken);\n            } 365719"];
2132 [label="cancellationToken.ThrowIfCancellationRequested(); 365720"];
2133 [label="_state.NextIncompletePart 365721"];
2134 [label="get\n            {\n                // NOTE: It's very important to store this value in a local.\n                // If we were to inline the field access, the value of the\n                // field could change between the two accesses and the formula\n                // might not produce a result with a single 1-bit.\n                int incomplete = IncompleteParts;\n                int next = incomplete & ~(incomplete - 1);\n                Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.');\n                return (CompletionPart)next;\n            } 365722"];
2135 [label="IncompleteParts 365723"];
2136 [label="get\n            {\n                return ~_completeParts & (int)CompletionPart.All;\n            } 365724"];
2137 [label="return ~_completeParts & (int)CompletionPart.All; 365725"];
2138 [label="int incomplete = IncompleteParts; 365726"];
2139 [label="int next = incomplete & ~(incomplete - 1); 365727"];
2140 [label="int next = incomplete & ~(incomplete - 1); 365728"];
2141 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365729"];
2142 [label="HasAtMostOneBitSet(next) 365730"];
2143 [label="param HasAtMostOneBitSet(int bits) 365731"];
2144 [label="return (bits & (bits - 1)) == 0; 365732"];
2145 [label="return (bits & (bits - 1)) == 0; 365733"];
2146 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365734"];
2147 [label="return (CompletionPart)next; 365735"];
2148 [label="var incompletePart = _state.NextIncompletePart; 365736"];
2149 [label="switch (incompletePart)\n                {\n                    case CompletionPart.StartValidatingImports:\n                        {\n                            if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            }\n                        }\n                        break;\n\n                    case CompletionPart.FinishValidatingImports:\n                        // some other thread has started validating imports (otherwise we would be in the case above) so\n                        // we just wait for it to both finish and report the diagnostics.\n                        Debug.Assert(_state.HasComplete(CompletionPart.StartValidatingImports));\n                        _state.SpinWaitComplete(CompletionPart.FinishValidatingImports, cancellationToken);\n                        break;\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // any other values are completion parts intended for other kinds of symbols\n                        _state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll);\n                        break;\n                } 365737"];
2150 [label="_state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll); 365738"];
2151 [label="_state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll) 365739"];
2152 [label="param NotePartComplete(CompletionPart part) 365740"];
2153 [label="param NotePartComplete(this) 365741"];
2154 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 365742"];
2155 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 365743"];
2156 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 365744"];
2157 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 365745"];
2158 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 365746"];
2159 [label="_state.SpinWaitComplete(incompletePart, cancellationToken) 365747"];
2160 [label="param SpinWaitComplete(CompletionPart part) 365748"];
2161 [label="param SpinWaitComplete(CancellationToken cancellationToken) 365749"];
2162 [label="param SpinWaitComplete(this) 365750"];
2163 [label="if (HasComplete(part))\n            {\n                return;\n            } 365751"];
2164 [label="HasComplete(part) 365752"];
2165 [label="param HasComplete(CompletionPart part) 365753"];
2166 [label="param HasComplete(this) 365754"];
2167 [label="return (_completeParts & (int)part) == (int)part; 365755"];
2168 [label="return; 365756"];
2169 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 365757"];
2170 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365758"];
2171 [label="param HasAtMostOneBitSet(int bits) 365759"];
2172 [label="return (bits & (bits - 1)) == 0; 365760"];
2173 [label="if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            } 365761"];
2174 [label="_state.NotePartComplete(CompletionPart.StartValidatingImports) 365762"];
2175 [label="param NotePartComplete(CompletionPart part) 365763"];
2176 [label="Validate() 365764"];
2177 [label="param Validate(this) 365765"];
2178 [label="if (this == Empty)\n            {\n                return;\n            } 365766"];
2179 [label="return; 365767"];
2180 [label="Validate(); 365768"];
2181 [label="_state.NotePartComplete(CompletionPart.FinishValidatingImports); 365769"];
2182 [label="_state.NotePartComplete(CompletionPart.FinishValidatingImports) 365770"];
2183 [label="param NotePartComplete(CompletionPart part) 365771"];
2184 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 365772"];
2185 [label="param SpinWaitComplete(CompletionPart part) 365773"];
2186 [label="if (HasComplete(part))\n            {\n                return;\n            } 365774"];
2187 [label="param HasComplete(CompletionPart part) 365775"];
2188 [label="return (_completeParts & (int)part) == (int)part; 365776"];
2189 [label="return; 365777"];
2190 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365778"];
2191 [label="param HasAtMostOneBitSet(int bits) 365779"];
2192 [label="return (bits & (bits - 1)) == 0; 365780"];
2193 [label="return; 365781"];
2194 [label="GlobalImports.Complete(cancellationToken); 365782"];
2195 [label="SourceLocation? location = null; 365783"];
2196 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 365784"];
2197 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 365785"];
2198 [label="Assembly 365786"];
2199 [label="get\n            {\n                return SourceAssembly;\n            } 365787"];
2200 [label="SourceAssembly 365788"];
2201 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 365789"];
2202 [label="GetBoundReferenceManager() 365790"];
2203 [label="param GetBoundReferenceManager(this) 365791"];
2204 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 365792"];
2205 [label="return _referenceManager; 365793"];
2206 [label="GetBoundReferenceManager(); 365794"];
2207 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 365795"];
2208 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 365796"];
2209 [label="return _lazyAssemblySymbol; 365797"];
2210 [label="return SourceAssembly; 365798"];
2211 [label="Assembly.ForceComplete(location, cancellationToken); 365799"];
2212 [label="Assembly.ForceComplete(location, cancellationToken); 365800"];
2213 [label="Assembly.ForceComplete(location, cancellationToken); 365801"];
2214 [label="Assembly.ForceComplete(location, cancellationToken); 365802"];
2215 [label="Assembly.ForceComplete(location, cancellationToken); 365803"];
2216 [label="IncompleteParts 365804"];
2217 [label="int next = incomplete & ~(incomplete - 1); 365805"];
2218 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365806"];
2219 [label="HasAtMostOneBitSet(next) 365807"];
2220 [label="param HasAtMostOneBitSet(int bits) 365808"];
2221 [label="return (bits & (bits - 1)) == 0; 365809"];
2222 [label="return (bits & (bits - 1)) == 0; 365810"];
2223 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365811"];
2224 [label="param EnsureAttributesAreBound(this) 365812"];
2225 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 365813"];
2226 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 365814"];
2227 [label="GetAttributeDeclarations() 365815"];
2228 [label="param GetAttributeDeclarations(this) 365816"];
2229 [label="var builder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance(); 365817"];
2230 [label="DeclaringCompilation 365818"];
2231 [label="get\n            {\n                return _compilation;\n            } 365819"];
2232 [label="return _compilation; 365820"];
2233 [label="var declarations = DeclaringCompilation.MergedRootDeclaration.Declarations; 365821"];
2234 [label="DeclaringCompilation.MergedRootDeclaration 365822"];
2235 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 365823"];
2236 [label="Declarations 365824"];
2237 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 365825"];
2238 [label="return Declarations.GetMergedRoot(this); 365826"];
2239 [label="return Declarations.GetMergedRoot(this); 365827"];
2240 [label="return Declarations.GetMergedRoot(this); 365828"];
2241 [label="foreach (RootSingleNamespaceDeclaration rootNs in declarations)\n            {\n                if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                }\n            } 365829"];
2242 [label="if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                } 365830"];
2243 [label="return builder.ToImmutableAndFree(); 365831"];
2244 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 365832"];
2245 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 365833"];
2246 [label="LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag) 365834"];
2247 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 365835"];
2248 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 365836"];
2249 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 365837"];
2250 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 365838"];
2251 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 365839"];
2252 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 365840"];
2253 [label="param LoadAndValidateAttributes(this) 365841"];
2254 [label="var diagnostics = DiagnosticBag.GetInstance(); 365842"];
2255 [label="this.DeclaringCompilation 365843"];
2256 [label="get\n            {\n                return _compilation;\n            } 365844"];
2257 [label="return _compilation; 365845"];
2258 [label="var compilation = this.DeclaringCompilation; 365846"];
2259 [label="ImmutableArray<Binder> binders; 365847"];
2260 [label="binders 365848"];
2261 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365849"];
2262 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365850"];
2263 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365851"];
2264 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365852"];
2265 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365853"];
2266 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365854"];
2267 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365855"];
2268 [label="this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders) 365856"];
2269 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 365857"];
2270 [label="param GetAttributesToBind(AttributeLocation symbolPart) 365858"];
2271 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 365859"];
2272 [label="param GetAttributesToBind(CSharpCompilation compilation) 365860"];
2273 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 365861"];
2274 [label="param GetAttributesToBind(Binder rootBinderOpt) 365862"];
2275 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 365863"];
2276 [label="param GetAttributesToBind(this) 365864"];
2277 [label="var attributeTarget = (IAttributeTargetSymbol)this; 365865"];
2278 [label="ArrayBuilder<AttributeSyntax> syntaxBuilder = null; 365866"];
2279 [label="ArrayBuilder<Binder> bindersBuilder = null; 365867"];
2280 [label="int attributesToBindCount = 0; 365868"];
2281 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 365869"];
2282 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 365870"];
2283 [label="if (syntaxBuilder != null)\n            {\n                binders = bindersBuilder.ToImmutableAndFree();\n                return syntaxBuilder.ToImmutableAndFree();\n            }\n            else\n            {\n                binders = ImmutableArray<Binder>.Empty;\n                return ImmutableArray<AttributeSyntax>.Empty;\n            } 365871"];
2284 [label="if (syntaxBuilder != null)\n            {\n                binders = bindersBuilder.ToImmutableAndFree();\n                return syntaxBuilder.ToImmutableAndFree();\n            }\n            else\n            {\n                binders = ImmutableArray<Binder>.Empty;\n                return ImmutableArray<AttributeSyntax>.Empty;\n            } 365872"];
2285 [label="binders = ImmutableArray<Binder>.Empty; 365873"];
2286 [label="return ImmutableArray<AttributeSyntax>.Empty; 365874"];
2287 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 365875"];
2288 [label="Debug.Assert(!attributesToBind.IsDefault); 365876"];
2289 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 365877"];
2290 [label="boundAttributes 365878"];
2291 [label="WellKnownAttributeData wellKnownAttributeData; 365879"];
2292 [label="if (attributesToBind.Any())\n            {\n                Debug.Assert(!binders.IsDefault);\n                Debug.Assert(binders.Length == attributesToBind.Length);\n\n                // Initialize the bag so that data decoded from early attributes can be stored onto it.\n                if (lazyCustomAttributesBag == null)\n                {\n                    Interlocked.CompareExchange(ref lazyCustomAttributesBag, new CustomAttributesBag<CSharpAttributeData>(), null);\n                }\n\n                // Bind the attribute types and then early decode them.\n                int totalAttributesCount = attributesToBind.Length;\n                var attributeTypesBuilder = new NamedTypeSymbol[totalAttributesCount];\n\n                Binder.BindAttributeTypes(binders, attributesToBind, this, attributeTypesBuilder, diagnostics);\n                ImmutableArray<NamedTypeSymbol> boundAttributeTypes = attributeTypesBuilder.AsImmutableOrNull();\n\n                this.EarlyDecodeWellKnownAttributeTypes(boundAttributeTypes, attributesToBind);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n\n                // Bind the attribute in two stages - early and normal.\n                var attributesBuilder = new CSharpAttributeData[totalAttributesCount];\n\n                // Early bind and decode some well-known attributes.\n                EarlyWellKnownAttributeData earlyData = this.EarlyDecodeWellKnownAttributes(binders, boundAttributeTypes, attributesToBind, symbolPart, attributesBuilder);\n                Debug.Assert(!attributesBuilder.Contains((attr) => attr != null && attr.HasErrors));\n\n                // Store data decoded from early bound well-known attributes.\n                // TODO: what if this succeeds on another thread, not ours?\n                lazyCustomAttributesBag.SetEarlyDecodedWellKnownAttributeData(earlyData);\n\n                if (earlyDecodingOnly)\n                {\n                    diagnostics.Free(); //NOTE: dropped.\n                    return false;\n                }\n\n                // Bind attributes.\n                Binder.GetAttributes(binders, attributesToBind, boundAttributeTypes, attributesBuilder, diagnostics);\n                boundAttributes = attributesBuilder.AsImmutableOrNull();\n\n                // All attributes must be bound by now.\n                Debug.Assert(!boundAttributes.Any((attr) => attr == null));\n\n                // Validate attribute usage and Decode remaining well-known attributes.\n                wellKnownAttributeData = this.ValidateAttributeUsageAndDecodeWellKnownAttributes(binders, attributesToBind, boundAttributes, diagnostics, symbolPart);\n\n                // Store data decoded from remaining well-known attributes.\n                // TODO: what if this succeeds on another thread but not this thread?\n                lazyCustomAttributesBag.SetDecodedWellKnownAttributeData(wellKnownAttributeData);\n            }\n            else if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 365880"];
2293 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 365881"];
2294 [label="boundAttributes = ImmutableArray<CSharpAttributeData>.Empty; 365882"];
2295 [label="wellKnownAttributeData = null; 365883"];
2296 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 365884"];
2297 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 365885"];
2298 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 365886"];
2299 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 365887"];
2300 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 365888"];
2301 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365889"];
2302 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365890"];
2303 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365891"];
2304 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365892"];
2305 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365893"];
2306 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 365894"];
2307 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 365895"];
2308 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 365896"];
2309 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 365897"];
2310 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 365898"];
2311 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 365899"];
2312 [label="param PostDecodeWellKnownAttributes(this) 365900"];
2313 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 365901"];
2314 [label="bool lazyAttributesStoredOnThisThread = false; 365902"];
2315 [label="if (lazyCustomAttributesBag.SetAttributes(boundAttributes))\n            {\n                if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                lazyAttributesStoredOnThisThread = true;\n                if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n            } 365903"];
2316 [label="if (lazyCustomAttributesBag.SetAttributes(boundAttributes))\n            {\n                if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                lazyAttributesStoredOnThisThread = true;\n                if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n            } 365904"];
2317 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 365905"];
2318 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 365906"];
2319 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 365907"];
2320 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 365908"];
2321 [label="param RecordPresenceOfBadAttributes(this) 365909"];
2322 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 365910"];
2323 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 365911"];
2324 [label="AddDeclarationDiagnostics(diagnostics); 365912"];
2325 [label="AddDeclarationDiagnostics(diagnostics) 365913"];
2326 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 365914"];
2327 [label="param AddDeclarationDiagnostics(this) 365915"];
2328 [label="ContainingSymbol 365916"];
2329 [label="get\n            {\n                return null;\n            } 365917"];
2330 [label="return null; 365918"];
2331 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 365919"];
2332 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 365920"];
2333 [label="AddDeclarationDiagnostics(diagnostics); 365921"];
2334 [label="lazyAttributesStoredOnThisThread = true; 365922"];
2335 [label="if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 365923"];
2336 [label="lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 365924"];
2337 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 365925"];
2338 [label="diagnostics.Free(); 365926"];
2339 [label="return lazyAttributesStoredOnThisThread; 365927"];
2340 [label="_state.NotePartComplete(CompletionPart.Attributes); 365928"];
2341 [label="_state.NotePartComplete(CompletionPart.Attributes) 365929"];
2342 [label="param NotePartComplete(CompletionPart part) 365930"];
2343 [label="param SpinWaitComplete(CompletionPart part) 365931"];
2344 [label="param SpinWaitComplete(CancellationToken cancellationToken) 365932"];
2345 [label="param SpinWaitComplete(this) 365933"];
2346 [label="if (HasComplete(part))\n            {\n                return;\n            } 365934"];
2347 [label="HasComplete(part) 365935"];
2348 [label="param HasComplete(CompletionPart part) 365936"];
2349 [label="param HasComplete(this) 365937"];
2350 [label="return (_completeParts & (int)part) == (int)part; 365938"];
2351 [label="return; 365939"];
2352 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365940"];
2353 [label="param HasAtMostOneBitSet(int bits) 365941"];
2354 [label="return (bits & (bits - 1)) == 0; 365942"];
2355 [label="Assembly.ForceComplete(location, cancellationToken); 365943"];
2356 [label="return (_completeParts & (int)part) == (int)part; 365944"];
2357 [label="return; 365945"];
2358 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 365946"];
2359 [label="param HasAtMostOneBitSet(int bits) 365947"];
2360 [label="return (bits & (bits - 1)) == 0; 365948"];
2361 [label="param ValidateAttributeSemantics(DiagnosticBag diagnostics) 365949"];
2362 [label="param ValidateAttributeSemantics(this) 365950"];
2363 [label="StrongNameKeys 365951"];
2364 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 365952"];
2365 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 365953"];
2366 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 365954"];
2367 [label="t_assemblyForWhichCurrentThreadIsComputingKeys = this; 365955"];
2368 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 365956"];
2369 [label="ComputeStrongNameKeys() 365957"];
2370 [label="param ComputeStrongNameKeys(this) 365958"];
2371 [label="EnsureAttributesAreBound() 365959"];
2372 [label="param EnsureAttributesAreBound(this) 365960"];
2373 [label="EnsureAttributesAreBound(); 365961"];
2374 [label="_compilation.Options 365962"];
2375 [label="get\n            {\n                return _options;\n            } 365963"];
2376 [label="string keyFile = _compilation.Options.CryptoKeyFile; 365964"];
2377 [label="DeclaringCompilation 365965"];
2378 [label="get\n            {\n                return _compilation;\n            } 365966"];
2379 [label="if (DeclaringCompilation.Options.PublicSign)\n            {\n                // TODO(https://github.com/dotnet/roslyn/issues/9150):\n                // Provide better error message if keys are provided by\n                // the attributes. Right now we'll just fall through to the\n                // 'no key available' error.\n\n                if (!string.IsNullOrEmpty(keyFile) && !PathUtilities.IsAbsolute(keyFile))\n                {\n                    // If keyFile has a relative path then there should be a diagnostic\n                    // about it\n                    Debug.Assert(!DeclaringCompilation.Options.Errors.IsEmpty);\n                    return StrongNameKeys.None;\n                }\n\n                // If we're public signing, we don't need a strong name provider\n                return StrongNameKeys.Create(keyFile, MessageProvider.Instance);\n            } 365967"];
2380 [label="DeclaringCompilation.Options 365968"];
2381 [label="get\n            {\n                return _options;\n            } 365969"];
2382 [label="if (string.IsNullOrEmpty(keyFile))\n            {\n                keyFile = this.AssemblyKeyFileAttributeSetting;\n\n                if ((object)keyFile == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyFile = null;\n                }\n            } 365970"];
2383 [label="this.AssemblyKeyFileAttributeSetting 365971"];
2384 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue);\n            } 365972"];
2385 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue); 365973"];
2386 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue); 365974"];
2387 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue) 365975"];
2388 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 365976"];
2389 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 365977"];
2390 [label="param GetWellKnownAttributeDataStringField(this) 365978"];
2391 [label="string fieldValue = missingValue; 365979"];
2392 [label="GetSourceDecodedWellKnownAttributeData() 365980"];
2393 [label="param GetSourceDecodedWellKnownAttributeData(this) 365981"];
2394 [label="var attributesBag = _lazySourceAttributesBag; 365982"];
2395 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 365983"];
2396 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 365984"];
2397 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 365985"];
2398 [label="var data = GetSourceDecodedWellKnownAttributeData(); 365986"];
2399 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 365987"];
2400 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 365988"];
2401 [label="if ((object)fieldValue == (object)missingValue)\n            {\n                data = GetNetModuleDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                }\n            } 365989"];
2402 [label="GetNetModuleDecodedWellKnownAttributeData() 365990"];
2403 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 365991"];
2404 [label="this.GetNetModuleAttributesBag() 365992"];
2405 [label="param GetNetModuleAttributesBag(this) 365993"];
2406 [label="EnsureNetModuleAttributesAreBound() 365994"];
2407 [label="param EnsureNetModuleAttributesAreBound(this) 365995"];
2408 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 365996"];
2409 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 365997"];
2410 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag); 365998"];
2411 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag) 365999"];
2412 [label="param LoadAndValidateNetModuleAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyNetModuleAttributesBag) 366000"];
2413 [label="param LoadAndValidateNetModuleAttributes(this) 366001"];
2414 [label="_compilation.Options 366002"];
2415 [label="get\n            {\n                return _options;\n            } 366003"];
2416 [label="if (_compilation.Options.OutputKind.IsNetModule())\n            {\n                Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, CustomAttributesBag<CSharpAttributeData>.Empty, null);\n            }\n            else\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n\n                ImmutableArray<string> netModuleNames;\n                ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames);\n\n                WellKnownAttributeData wellKnownData = null;\n\n                if (attributesFromNetModules.Any())\n                {\n                    wellKnownData = ValidateAttributeUsageAndDecodeWellKnownAttributes(attributesFromNetModules, netModuleNames, diagnostics);\n                }\n                else\n                {\n                    // Compute duplicate source assembly attributes, i.e. attributes with same constructor and arguments, that must not be emitted.\n                    var unused = GetUniqueSourceAssemblyAttributes();\n                }\n\n                // Load type forwarders from modules\n                HashSet<NamedTypeSymbol> forwardedTypes = null;\n\n                // Similar to attributes, type forwarders from the second added module should override type forwarders from the first added module, etc. \n                // This affects only diagnostics.\n                for (int i = _modules.Length - 1; i > 0; i--)\n                {\n                    var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n\n                    foreach (NamedTypeSymbol forwarded in peModuleSymbol.GetForwardedTypes())\n                    {\n                        if (forwardedTypes == null)\n                        {\n                            if (wellKnownData == null)\n                            {\n                                wellKnownData = new CommonAssemblyWellKnownAttributeData();\n                            }\n\n                            forwardedTypes = ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes;\n                            if (forwardedTypes == null)\n                            {\n                                forwardedTypes = new HashSet<NamedTypeSymbol>();\n                                ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes = forwardedTypes;\n                            }\n                        }\n\n                        if (forwardedTypes.Add(forwarded))\n                        {\n                            if (forwarded.IsErrorType())\n                            {\n                                DiagnosticInfo info = forwarded.GetUseSiteDiagnostic() ?? ((ErrorTypeSymbol)forwarded).ErrorInfo;\n\n                                if ((object)info != null)\n                                {\n                                    diagnostics.Add(info, NoLocation.Singleton);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                CustomAttributesBag<CSharpAttributeData> netModuleAttributesBag;\n\n                if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n\n                if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                }\n\n                diagnostics.Free();\n            } 366004"];
2417 [label="var diagnostics = DiagnosticBag.GetInstance(); 366005"];
2418 [label="ImmutableArray<string> netModuleNames; 366006"];
2419 [label="netModuleNames 366007"];
2420 [label="ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames); 366008"];
2421 [label="GetNetModuleAttributes(out netModuleNames) 366009"];
2422 [label="param GetNetModuleAttributes(out ImmutableArray<string> netModuleNames) 366010"];
2423 [label="param GetNetModuleAttributes(this) 366011"];
2424 [label="ArrayBuilder<CSharpAttributeData> moduleAssemblyAttributesBuilder = null; 366012"];
2425 [label="ArrayBuilder<string> netModuleNameBuilder = null; 366013"];
2426 [label="for (int i = 1; i < _modules.Length; i++)\n            {\n                var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n                string netModuleName = peModuleSymbol.Name;\n                foreach (var attributeData in peModuleSymbol.GetAssemblyAttributes())\n                {\n                    if (netModuleNameBuilder == null)\n                    {\n                        netModuleNameBuilder = ArrayBuilder<string>.GetInstance();\n                        moduleAssemblyAttributesBuilder = ArrayBuilder<CSharpAttributeData>.GetInstance();\n                    }\n\n                    netModuleNameBuilder.Add(netModuleName);\n                    moduleAssemblyAttributesBuilder.Add(attributeData);\n                }\n            } 366014"];
2427 [label="for (int i = 1; i < _modules.Length; i++)\n            {\n                var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n                string netModuleName = peModuleSymbol.Name;\n                foreach (var attributeData in peModuleSymbol.GetAssemblyAttributes())\n                {\n                    if (netModuleNameBuilder == null)\n                    {\n                        netModuleNameBuilder = ArrayBuilder<string>.GetInstance();\n                        moduleAssemblyAttributesBuilder = ArrayBuilder<CSharpAttributeData>.GetInstance();\n                    }\n\n                    netModuleNameBuilder.Add(netModuleName);\n                    moduleAssemblyAttributesBuilder.Add(attributeData);\n                }\n            } 366015"];
2428 [label="if (netModuleNameBuilder == null)\n            {\n                netModuleNames = ImmutableArray<string>.Empty;\n                return ImmutableArray<CSharpAttributeData>.Empty;\n            } 366016"];
2429 [label="if (netModuleNameBuilder == null)\n            {\n                netModuleNames = ImmutableArray<string>.Empty;\n                return ImmutableArray<CSharpAttributeData>.Empty;\n            } 366017"];
2430 [label="netModuleNames = ImmutableArray<string>.Empty; 366018"];
2431 [label="return ImmutableArray<CSharpAttributeData>.Empty; 366019"];
2432 [label="ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames); 366020"];
2433 [label="WellKnownAttributeData wellKnownData = null; 366021"];
2434 [label="if (attributesFromNetModules.Any())\n                {\n                    wellKnownData = ValidateAttributeUsageAndDecodeWellKnownAttributes(attributesFromNetModules, netModuleNames, diagnostics);\n                }\n                else\n                {\n                    // Compute duplicate source assembly attributes, i.e. attributes with same constructor and arguments, that must not be emitted.\n                    var unused = GetUniqueSourceAssemblyAttributes();\n                } 366022"];
2435 [label="GetUniqueSourceAssemblyAttributes() 366023"];
2436 [label="param GetUniqueSourceAssemblyAttributes(this) 366024"];
2437 [label="this.GetSourceAttributesBag() 366025"];
2438 [label="param GetSourceAttributesBag(this) 366026"];
2439 [label="EnsureAttributesAreBound() 366027"];
2440 [label="param EnsureAttributesAreBound(this) 366028"];
2441 [label="EnsureAttributesAreBound(); 366029"];
2442 [label="return _lazySourceAttributesBag; 366030"];
2443 [label="ImmutableArray<CSharpAttributeData> appliedSourceAttributes = this.GetSourceAttributesBag().Attributes; 366031"];
2444 [label="HashSet<CSharpAttributeData> uniqueAttributes = null; 366032"];
2445 [label="for (int i = 0; i < appliedSourceAttributes.Length; i++)\n            {\n                CSharpAttributeData attribute = appliedSourceAttributes[i];\n                if (!attribute.HasErrors)\n                {\n                    if (!AddUniqueAssemblyAttribute(attribute, ref uniqueAttributes))\n                    {\n                        AddOmittedAttributeIndex(i);\n                    }\n                }\n            } 366033"];
2446 [label="for (int i = 0; i < appliedSourceAttributes.Length; i++)\n            {\n                CSharpAttributeData attribute = appliedSourceAttributes[i];\n                if (!attribute.HasErrors)\n                {\n                    if (!AddUniqueAssemblyAttribute(attribute, ref uniqueAttributes))\n                    {\n                        AddOmittedAttributeIndex(i);\n                    }\n                }\n            } 366034"];
2447 [label="return uniqueAttributes; 366035"];
2448 [label="var unused = GetUniqueSourceAssemblyAttributes(); 366036"];
2449 [label="HashSet<NamedTypeSymbol> forwardedTypes = null; 366037"];
2450 [label="for (int i = _modules.Length - 1; i > 0; i--)\n                {\n                    var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n\n                    foreach (NamedTypeSymbol forwarded in peModuleSymbol.GetForwardedTypes())\n                    {\n                        if (forwardedTypes == null)\n                        {\n                            if (wellKnownData == null)\n                            {\n                                wellKnownData = new CommonAssemblyWellKnownAttributeData();\n                            }\n\n                            forwardedTypes = ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes;\n                            if (forwardedTypes == null)\n                            {\n                                forwardedTypes = new HashSet<NamedTypeSymbol>();\n                                ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes = forwardedTypes;\n                            }\n                        }\n\n                        if (forwardedTypes.Add(forwarded))\n                        {\n                            if (forwarded.IsErrorType())\n                            {\n                                DiagnosticInfo info = forwarded.GetUseSiteDiagnostic() ?? ((ErrorTypeSymbol)forwarded).ErrorInfo;\n\n                                if ((object)info != null)\n                                {\n                                    diagnostics.Add(info, NoLocation.Singleton);\n                                }\n                            }\n                        }\n                    }\n                } 366038"];
2451 [label="CustomAttributesBag<CSharpAttributeData> netModuleAttributesBag; 366039"];
2452 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 366040"];
2453 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 366041"];
2454 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 366042"];
2455 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 366043"];
2456 [label="netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 366044"];
2457 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 366045"];
2458 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 366046"];
2459 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 366047"];
2460 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 366048"];
2461 [label="this.AddDeclarationDiagnostics(diagnostics); 366049"];
2462 [label="this.AddDeclarationDiagnostics(diagnostics) 366050"];
2463 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 366051"];
2464 [label="param AddDeclarationDiagnostics(this) 366052"];
2465 [label="ContainingSymbol 366053"];
2466 [label="get\n            {\n                return null;\n            } 366054"];
2467 [label="return null; 366055"];
2468 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 366056"];
2469 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 366057"];
2470 [label="this.AddDeclarationDiagnostics(diagnostics); 366058"];
2471 [label="diagnostics.Free(); 366059"];
2472 [label="Debug.Assert(lazyNetModuleAttributesBag.IsSealed); 366060"];
2473 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag); 366061"];
2474 [label="EnsureNetModuleAttributesAreBound(); 366062"];
2475 [label="return _lazyNetModuleAttributesBag; 366063"];
2476 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366064"];
2477 [label="Debug.Assert(attributesBag.IsSealed); 366065"];
2478 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366066"];
2479 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366067"];
2480 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366068"];
2481 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366069"];
2482 [label="return fieldValue; 366070"];
2483 [label="keyFile = this.AssemblyKeyFileAttributeSetting; 366071"];
2484 [label="if ((object)keyFile == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyFile = null;\n                } 366072"];
2485 [label="keyFile = null; 366073"];
2486 [label="_compilation.Options 366074"];
2487 [label="get\n            {\n                return _options;\n            } 366075"];
2488 [label="string keyContainer = _compilation.Options.CryptoKeyContainer; 366076"];
2489 [label="if (string.IsNullOrEmpty(keyContainer))\n            {\n                keyContainer = this.AssemblyKeyContainerAttributeSetting;\n\n                if ((object)keyContainer == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyContainer = null;\n                }\n            } 366077"];
2490 [label="this.AssemblyKeyContainerAttributeSetting 366078"];
2491 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue);\n            } 366079"];
2492 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue); 366080"];
2493 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue); 366081"];
2494 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue) 366082"];
2495 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 366083"];
2496 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 366084"];
2497 [label="param GetWellKnownAttributeDataStringField(this) 366085"];
2498 [label="GetSourceDecodedWellKnownAttributeData() 366086"];
2499 [label="param GetSourceDecodedWellKnownAttributeData(this) 366087"];
2500 [label="var attributesBag = _lazySourceAttributesBag; 366088"];
2501 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366089"];
2502 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366090"];
2503 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366091"];
2504 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366092"];
2505 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366093"];
2506 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366094"];
2507 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366095"];
2508 [label="EnsureNetModuleAttributesAreBound(); 366096"];
2509 [label="return _lazyNetModuleAttributesBag; 366097"];
2510 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366098"];
2511 [label="Debug.Assert(attributesBag.IsSealed); 366099"];
2512 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366100"];
2513 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366101"];
2514 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366102"];
2515 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366103"];
2516 [label="return fieldValue; 366104"];
2517 [label="keyContainer = this.AssemblyKeyContainerAttributeSetting; 366105"];
2518 [label="if ((object)keyContainer == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyContainer = null;\n                } 366106"];
2519 [label="keyContainer = null; 366107"];
2520 [label="this.SignatureKey 366108"];
2521 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting);\n            } 366109"];
2522 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting); 366110"];
2523 [label="GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting) 366111"];
2524 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 366112"];
2525 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 366113"];
2526 [label="param GetWellKnownAttributeDataStringField(this) 366114"];
2527 [label="string fieldValue = missingValue; 366115"];
2528 [label="GetSourceDecodedWellKnownAttributeData() 366116"];
2529 [label="param GetSourceDecodedWellKnownAttributeData(this) 366117"];
2530 [label="var attributesBag = _lazySourceAttributesBag; 366118"];
2531 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366119"];
2532 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366120"];
2533 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366121"];
2534 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366122"];
2535 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366123"];
2536 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366124"];
2537 [label="if ((object)fieldValue == (object)missingValue)\n            {\n                data = GetNetModuleDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                }\n            } 366125"];
2538 [label="GetNetModuleDecodedWellKnownAttributeData() 366126"];
2539 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366127"];
2540 [label="this.GetNetModuleAttributesBag() 366128"];
2541 [label="param GetNetModuleAttributesBag(this) 366129"];
2542 [label="EnsureNetModuleAttributesAreBound() 366130"];
2543 [label="param EnsureNetModuleAttributesAreBound(this) 366131"];
2544 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366132"];
2545 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366133"];
2546 [label="EnsureNetModuleAttributesAreBound(); 366134"];
2547 [label="return _lazyNetModuleAttributesBag; 366135"];
2548 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366136"];
2549 [label="Debug.Assert(attributesBag.IsSealed); 366137"];
2550 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366138"];
2551 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366139"];
2552 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366140"];
2553 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366141"];
2554 [label="return fieldValue; 366142"];
2555 [label="var hasCounterSignature = !string.IsNullOrEmpty(this.SignatureKey); 366143"];
2556 [label="DeclaringCompilation 366144"];
2557 [label="get\n            {\n                return _compilation;\n            } 366145"];
2558 [label="return _compilation; 366146"];
2559 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366147"];
2560 [label="DeclaringCompilation.Options 366148"];
2561 [label="get\n            {\n                return _options;\n            } 366149"];
2562 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366150"];
2563 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366151"];
2564 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366152"];
2565 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366153"];
2566 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 366154"];
2567 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 366155"];
2568 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 366156"];
2569 [label="t_assemblyForWhichCurrentThreadIsComputingKeys = null; 366157"];
2570 [label="return _lazyStrongNameKeys; 366158"];
2571 [label="if (StrongNameKeys.DiagnosticOpt != null && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                diagnostics.Add(StrongNameKeys.DiagnosticOpt);\n            } 366159"];
2572 [label="if (StrongNameKeys.DiagnosticOpt != null && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                diagnostics.Add(StrongNameKeys.DiagnosticOpt);\n            } 366160"];
2573 [label="ValidateIVTPublicKeys(diagnostics); 366161"];
2574 [label="ValidateIVTPublicKeys(diagnostics) 366162"];
2575 [label="param ValidateIVTPublicKeys(DiagnosticBag diagnostics) 366163"];
2576 [label="param ValidateIVTPublicKeys(this) 366164"];
2577 [label="EnsureAttributesAreBound() 366165"];
2578 [label="param EnsureAttributesAreBound(this) 366166"];
2579 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 366167"];
2580 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 366168"];
2581 [label="EnsureAttributesAreBound(); 366169"];
2582 [label="this.Identity 366170"];
2583 [label="get\n            {\n                if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null);\n\n                return lazyAssemblyIdentity;\n            } 366171"];
2584 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366172"];
2585 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366173"];
2586 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366174"];
2587 [label="ComputeIdentity() 366175"];
2588 [label="param ComputeIdentity(this) 366176"];
2589 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366177"];
2590 [label="_compilation.Options 366178"];
2591 [label="get\n            {\n                return _options;\n            } 366179"];
2592 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366180"];
2593 [label="AssemblyVersionAttributeSetting 366181"];
2594 [label="get\n            {\n                var defaultValue = (Version)null;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 366182"];
2595 [label="var defaultValue = (Version)null; 366183"];
2596 [label="var fieldValue = defaultValue; 366184"];
2597 [label="GetSourceDecodedWellKnownAttributeData() 366185"];
2598 [label="param GetSourceDecodedWellKnownAttributeData(this) 366186"];
2599 [label="var attributesBag = _lazySourceAttributesBag; 366187"];
2600 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366188"];
2601 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366189"];
2602 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366190"];
2603 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366191"];
2604 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                } 366192"];
2605 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                } 366193"];
2606 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    }\n                } 366194"];
2607 [label="GetNetModuleDecodedWellKnownAttributeData() 366195"];
2608 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366196"];
2609 [label="EnsureNetModuleAttributesAreBound(); 366197"];
2610 [label="return _lazyNetModuleAttributesBag; 366198"];
2611 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366199"];
2612 [label="Debug.Assert(attributesBag.IsSealed); 366200"];
2613 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366201"];
2614 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366202"];
2615 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    } 366203"];
2616 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    } 366204"];
2617 [label="return fieldValue; 366205"];
2618 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366206"];
2619 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366207"];
2620 [label="this.AssemblyCultureAttributeSetting 366208"];
2621 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting);\n            } 366209"];
2622 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting); 366210"];
2623 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting) 366211"];
2624 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 366212"];
2625 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 366213"];
2626 [label="param GetWellKnownAttributeDataStringField(this) 366214"];
2627 [label="GetSourceDecodedWellKnownAttributeData() 366215"];
2628 [label="param GetSourceDecodedWellKnownAttributeData(this) 366216"];
2629 [label="var attributesBag = _lazySourceAttributesBag; 366217"];
2630 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366218"];
2631 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366219"];
2632 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366220"];
2633 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366221"];
2634 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366222"];
2635 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 366223"];
2636 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366224"];
2637 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366225"];
2638 [label="EnsureNetModuleAttributesAreBound(); 366226"];
2639 [label="return _lazyNetModuleAttributesBag; 366227"];
2640 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366228"];
2641 [label="Debug.Assert(attributesBag.IsSealed); 366229"];
2642 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366230"];
2643 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366231"];
2644 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366232"];
2645 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 366233"];
2646 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366234"];
2647 [label="StrongNameKeys 366235"];
2648 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 366236"];
2649 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 366237"];
2650 [label="return _lazyStrongNameKeys; 366238"];
2651 [label="StrongNameKeys 366239"];
2652 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 366240"];
2653 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 366241"];
2654 [label="return _lazyStrongNameKeys; 366242"];
2655 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 366243"];
2656 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366244"];
2657 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366245"];
2658 [label="return lazyAssemblyIdentity; 366246"];
2659 [label="if (!this.Identity.IsStrongName)\n                return; 366247"];
2660 [label="return; 366248"];
2661 [label="ValidateIVTPublicKeys(diagnostics); 366249"];
2662 [label="CheckOptimisticIVTAccessGrants(diagnostics); 366250"];
2663 [label="CheckOptimisticIVTAccessGrants(diagnostics) 366251"];
2664 [label="param CheckOptimisticIVTAccessGrants(DiagnosticBag bag) 366252"];
2665 [label="param CheckOptimisticIVTAccessGrants(this) 366253"];
2666 [label="ConcurrentDictionary<AssemblySymbol, bool> haveGrantedAssemblies = _optimisticallyGrantedInternalsAccess; 366254"];
2667 [label="if (haveGrantedAssemblies != null)\n            {\n                foreach (var otherAssembly in haveGrantedAssemblies.Keys)\n                {\n                    IVTConclusion conclusion = MakeFinalIVTDetermination(otherAssembly);\n\n                    Debug.Assert(conclusion != IVTConclusion.NoRelationshipClaimed);\n\n                    if (conclusion == IVTConclusion.PublicKeyDoesntMatch)\n                        bag.Add(ErrorCode.ERR_FriendRefNotEqualToThis, NoLocation.Singleton,\n                                                                      otherAssembly.Identity, this.Identity);\n                    else if (conclusion == IVTConclusion.OneSignedOneNot)\n                        bag.Add(ErrorCode.ERR_FriendRefSigningMismatch, NoLocation.Singleton,\n                                                                      otherAssembly.Identity);\n                }\n            } 366255"];
2668 [label="if (haveGrantedAssemblies != null)\n            {\n                foreach (var otherAssembly in haveGrantedAssemblies.Keys)\n                {\n                    IVTConclusion conclusion = MakeFinalIVTDetermination(otherAssembly);\n\n                    Debug.Assert(conclusion != IVTConclusion.NoRelationshipClaimed);\n\n                    if (conclusion == IVTConclusion.PublicKeyDoesntMatch)\n                        bag.Add(ErrorCode.ERR_FriendRefNotEqualToThis, NoLocation.Singleton,\n                                                                      otherAssembly.Identity, this.Identity);\n                    else if (conclusion == IVTConclusion.OneSignedOneNot)\n                        bag.Add(ErrorCode.ERR_FriendRefSigningMismatch, NoLocation.Singleton,\n                                                                      otherAssembly.Identity);\n                }\n            } 366256"];
2669 [label="CheckOptimisticIVTAccessGrants(diagnostics); 366257"];
2670 [label="DetectAttributeAndOptionConflicts(diagnostics); 366258"];
2671 [label="DetectAttributeAndOptionConflicts(diagnostics) 366259"];
2672 [label="param DetectAttributeAndOptionConflicts(DiagnosticBag diagnostics) 366260"];
2673 [label="param DetectAttributeAndOptionConflicts(this) 366261"];
2674 [label="EnsureAttributesAreBound() 366262"];
2675 [label="param EnsureAttributesAreBound(this) 366263"];
2676 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 366264"];
2677 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 366265"];
2678 [label="EnsureAttributesAreBound(); 366266"];
2679 [label="this.AssemblyDelaySignAttributeSetting 366267"];
2680 [label="get\n            {\n                var defaultValue = ThreeState.Unknown;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 366268"];
2681 [label="var defaultValue = ThreeState.Unknown; 366269"];
2682 [label="var fieldValue = defaultValue; 366270"];
2683 [label="GetSourceDecodedWellKnownAttributeData() 366271"];
2684 [label="param GetSourceDecodedWellKnownAttributeData(this) 366272"];
2685 [label="var attributesBag = _lazySourceAttributesBag; 366273"];
2686 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366274"];
2687 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366275"];
2688 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366276"];
2689 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366277"];
2690 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 366278"];
2691 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 366279"];
2692 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                } 366280"];
2693 [label="GetNetModuleDecodedWellKnownAttributeData() 366281"];
2694 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366282"];
2695 [label="this.GetNetModuleAttributesBag() 366283"];
2696 [label="param GetNetModuleAttributesBag(this) 366284"];
2697 [label="EnsureNetModuleAttributesAreBound() 366285"];
2698 [label="param EnsureNetModuleAttributesAreBound(this) 366286"];
2699 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366287"];
2700 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366288"];
2701 [label="EnsureNetModuleAttributesAreBound(); 366289"];
2702 [label="return _lazyNetModuleAttributesBag; 366290"];
2703 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366291"];
2704 [label="Debug.Assert(attributesBag.IsSealed); 366292"];
2705 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366293"];
2706 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366294"];
2707 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 366295"];
2708 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 366296"];
2709 [label="return fieldValue; 366297"];
2710 [label="ThreeState assemblyDelaySignAttributeSetting = this.AssemblyDelaySignAttributeSetting; 366298"];
2711 [label="_compilation.Options 366299"];
2712 [label="get\n            {\n                return _options;\n            } 366300"];
2713 [label="if (_compilation.Options.DelaySign.HasValue && (assemblyDelaySignAttributeSetting != ThreeState.Unknown) &&\n                (DeclaringCompilation.Options.DelaySign.Value != (assemblyDelaySignAttributeSetting == ThreeState.True)))\n            {\n                diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'DelaySign', AttributeDescription.AssemblyDelaySignAttribute.FullName);\n            } 366301"];
2714 [label="_compilation.Options 366302"];
2715 [label="get\n            {\n                return _options;\n            } 366303"];
2716 [label="if (_compilation.Options.PublicSign && assemblyDelaySignAttributeSetting == ThreeState.True)\n            {\n                diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton,\n                    nameof(_compilation.Options.PublicSign),\n                    AttributeDescription.AssemblyDelaySignAttribute.FullName);\n            } 366304"];
2717 [label="_compilation.Options 366305"];
2718 [label="get\n            {\n                return _options;\n            } 366306"];
2719 [label="if (!String.IsNullOrEmpty(_compilation.Options.CryptoKeyContainer))\n            {\n                string assemblyKeyContainerAttributeSetting = this.AssemblyKeyContainerAttributeSetting;\n\n                if ((object)assemblyKeyContainerAttributeSetting == (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n                {\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        // We need to synthesize this attribute for .NET module,\n                        // touch the constructor in order to generate proper use-site diagnostics\n                        Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(_compilation,\n                            WellKnownMember.System_Reflection_AssemblyKeyNameAttribute__ctor,\n                            diagnostics,\n                            NoLocation.Singleton);\n                    }\n                }\n                else if (String.Compare(_compilation.Options.CryptoKeyContainer, assemblyKeyContainerAttributeSetting, StringComparison.OrdinalIgnoreCase) != 0)\n                {\n                    // Native compiler reports a warning in this case, notifying the user that attribute value from source is ignored,\n                    // but it doesn't drop the attribute during emit. That might be fine if we produce an assembly because we actually sign it with correct\n                    // key (the one from compilation options) without relying on the emitted attribute.\n                    // If we are building a .NET module, things get more complicated. In particular, we don't sign the module, we emit an attribute with the key \n                    // information, which will be used to sign an assembly once the module is linked into it. If there is already an attribute like that in source,\n                    // native compiler emits both of them, synthetic attribute is emitted after the one from source. Incidentally, ALink picks the last attribute\n                    // for signing and things seem to work out. However, relying on the order of attributes feels fragile, especially given that Roslyn emits\n                    // synthetic attributes before attributes from source. The behavior we settled on for .NET modules is that, if the attribute in source has the\n                    // same value as the one in compilation options, we won't emit the synthetic attribute. If the value doesn't match, we report an error, which \n                    // is a breaking change. Bottom line, we will never produce a module or an assembly with two attributes, regardless whether values are the same\n                    // or not.\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource, NoLocation.Singleton, AttributeDescription.AssemblyKeyNameAttribute.FullName, 'CryptoKeyContainer');\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'CryptoKeyContainer', AttributeDescription.AssemblyKeyNameAttribute.FullName);\n                    }\n                }\n            } 366307"];
2720 [label="_compilation.Options 366308"];
2721 [label="get\n            {\n                return _options;\n            } 366309"];
2722 [label="if (_compilation.Options.PublicSign &&\n                !_compilation.Options.OutputKind.IsNetModule() &&\n                (object)this.AssemblyKeyContainerAttributeSetting != (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n            {\n                diagnostics.Add(ErrorCode.WRN_AttributeIgnoredWhenPublicSigning, NoLocation.Singleton, AttributeDescription.AssemblyKeyNameAttribute.FullName);\n            } 366310"];
2723 [label="_compilation.Options 366311"];
2724 [label="get\n            {\n                return _options;\n            } 366312"];
2725 [label="if (!String.IsNullOrEmpty(_compilation.Options.CryptoKeyFile))\n            {\n                string assemblyKeyFileAttributeSetting = this.AssemblyKeyFileAttributeSetting;\n\n                if ((object)assemblyKeyFileAttributeSetting == (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n                {\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        // We need to synthesize this attribute for .NET module,\n                        // touch the constructor in order to generate proper use-site diagnostics\n                        Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(_compilation,\n                            WellKnownMember.System_Reflection_AssemblyKeyFileAttribute__ctor,\n                            diagnostics,\n                            NoLocation.Singleton);\n                    }\n                }\n                else if (String.Compare(_compilation.Options.CryptoKeyFile, assemblyKeyFileAttributeSetting, StringComparison.OrdinalIgnoreCase) != 0)\n                {\n                    // Comment in similar section for CryptoKeyContainer is applicable here as well.\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource, NoLocation.Singleton, AttributeDescription.AssemblyKeyFileAttribute.FullName, 'CryptoKeyFile');\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'CryptoKeyFile', AttributeDescription.AssemblyKeyFileAttribute.FullName);\n                    }\n                }\n            } 366313"];
2726 [label="_compilation.Options 366314"];
2727 [label="get\n            {\n                return _options;\n            } 366315"];
2728 [label="if (_compilation.Options.PublicSign &&\n                !_compilation.Options.OutputKind.IsNetModule() &&\n                (object)this.AssemblyKeyFileAttributeSetting != (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n            {\n                diagnostics.Add(ErrorCode.WRN_AttributeIgnoredWhenPublicSigning, NoLocation.Singleton, AttributeDescription.AssemblyKeyFileAttribute.FullName);\n            } 366316"];
2729 [label="DetectAttributeAndOptionConflicts(diagnostics); 366317"];
2730 [label="IsDelaySigned 366318"];
2731 [label="get\n            {\n                //commandline setting trumps attribute value. Warning assumed to be given elsewhere\n                if (_compilation.Options.DelaySign.HasValue)\n                {\n                    return _compilation.Options.DelaySign.Value;\n                }\n\n                // The public sign argument should also override the attribute\n                if (_compilation.Options.PublicSign)\n                {\n                    return false;\n                }\n\n                return (this.AssemblyDelaySignAttributeSetting == ThreeState.True);\n            } 366319"];
2732 [label="_compilation.Options 366320"];
2733 [label="get\n            {\n                return _options;\n            } 366321"];
2734 [label="if (_compilation.Options.DelaySign.HasValue)\n                {\n                    return _compilation.Options.DelaySign.Value;\n                } 366322"];
2735 [label="_compilation.Options 366323"];
2736 [label="get\n            {\n                return _options;\n            } 366324"];
2737 [label="if (_compilation.Options.PublicSign)\n                {\n                    return false;\n                } 366325"];
2738 [label="this.AssemblyDelaySignAttributeSetting 366326"];
2739 [label="get\n            {\n                var defaultValue = ThreeState.Unknown;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 366327"];
2740 [label="var defaultValue = ThreeState.Unknown; 366328"];
2741 [label="var fieldValue = defaultValue; 366329"];
2742 [label="GetSourceDecodedWellKnownAttributeData() 366330"];
2743 [label="param GetSourceDecodedWellKnownAttributeData(this) 366331"];
2744 [label="var attributesBag = _lazySourceAttributesBag; 366332"];
2745 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366333"];
2746 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 366334"];
2747 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366335"];
2748 [label="var data = GetSourceDecodedWellKnownAttributeData(); 366336"];
2749 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 366337"];
2750 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 366338"];
2751 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                } 366339"];
2752 [label="GetNetModuleDecodedWellKnownAttributeData() 366340"];
2753 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 366341"];
2754 [label="this.GetNetModuleAttributesBag() 366342"];
2755 [label="param GetNetModuleAttributesBag(this) 366343"];
2756 [label="EnsureNetModuleAttributesAreBound() 366344"];
2757 [label="param EnsureNetModuleAttributesAreBound(this) 366345"];
2758 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366346"];
2759 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 366347"];
2760 [label="EnsureNetModuleAttributesAreBound(); 366348"];
2761 [label="return _lazyNetModuleAttributesBag; 366349"];
2762 [label="var attributesBag = this.GetNetModuleAttributesBag(); 366350"];
2763 [label="Debug.Assert(attributesBag.IsSealed); 366351"];
2764 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 366352"];
2765 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 366353"];
2766 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 366354"];
2767 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 366355"];
2768 [label="return fieldValue; 366356"];
2769 [label="return (this.AssemblyDelaySignAttributeSetting == ThreeState.True); 366357"];
2770 [label="if (IsDelaySigned && !Identity.HasPublicKey)\n            {\n                diagnostics.Add(ErrorCode.WRN_DelaySignButNoKey, NoLocation.Singleton);\n            } 366358"];
2771 [label="DeclaringCompilation 366359"];
2772 [label="get\n            {\n                return _compilation;\n            } 366360"];
2773 [label="return _compilation; 366361"];
2774 [label="if (DeclaringCompilation.Options.PublicSign)\n            {\n                if (_compilation.Options.OutputKind.IsNetModule())\n                {\n                    diagnostics.Add(ErrorCode.ERR_PublicSignNetModule, NoLocation.Singleton);\n                }\n                else if (!Identity.HasPublicKey)\n                {\n                    diagnostics.Add(ErrorCode.ERR_PublicSignButNoKey, NoLocation.Singleton);\n                }\n            } 366362"];
2775 [label="DeclaringCompilation.Options 366363"];
2776 [label="get\n            {\n                return _options;\n            } 366364"];
2777 [label="DeclaringCompilation 366365"];
2778 [label="get\n            {\n                return _compilation;\n            } 366366"];
2779 [label="return _compilation; 366367"];
2780 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 366368"];
2781 [label="DeclaringCompilation.Options 366369"];
2782 [label="get\n            {\n                return _options;\n            } 366370"];
2783 [label="DeclaringCompilation 366371"];
2784 [label="get\n            {\n                return _compilation;\n            } 366372"];
2785 [label="return _compilation; 366373"];
2786 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 366374"];
2787 [label="DeclaringCompilation.Options 366375"];
2788 [label="get\n            {\n                return _options;\n            } 366376"];
2789 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 366377"];
2790 [label="Identity 366378"];
2791 [label="get\n            {\n                if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null);\n\n                return lazyAssemblyIdentity;\n            } 366379"];
2792 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366380"];
2793 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 366381"];
2794 [label="return lazyAssemblyIdentity; 366382"];
2795 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 366383"];
2796 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 366384"];
2797 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 366385"];
2798 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 366386"];
2799 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics) 366387"];
2800 [label="param ReportDiagnosticsForSynthesizedAttributes(CSharpCompilation compilation) 366388"];
2801 [label="param ReportDiagnosticsForSynthesizedAttributes(DiagnosticBag diagnostics) 366389"];
2802 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 366390"];
2803 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 366391"];
2804 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics) 366392"];
2805 [label="param ReportDiagnosticsForUnsafeSynthesizedAttributes(CSharpCompilation compilation) 366393"];
2806 [label="param ReportDiagnosticsForUnsafeSynthesizedAttributes(DiagnosticBag diagnostics) 366394"];
2807 [label="compilation.Options 366395"];
2808 [label="get\n            {\n                return _options;\n            } 366396"];
2809 [label="CSharpCompilationOptions compilationOptions = compilation.Options; 366397"];
2810 [label="if (!compilationOptions.AllowUnsafe)\n            {\n                return;\n            } 366398"];
2811 [label="return; 366399"];
2812 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 366400"];
2813 [label="compilation.Options 366401"];
2814 [label="get\n            {\n                return _options;\n            } 366402"];
2815 [label="CSharpCompilationOptions compilationOptions = compilation.Options; 366403"];
2816 [label="if (!compilationOptions.OutputKind.IsNetModule())\n            {\n                TypeSymbol compilationRelaxationsAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute);\n                Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null');\n                if (!(compilationRelaxationsAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if CompilationRelaxationsAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton);\n                }\n\n                TypeSymbol runtimeCompatibilityAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute);\n                Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null');\n                if (!(runtimeCompatibilityAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if RuntimeCompatibilityAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton);\n\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton);\n                }\n            } 366404"];
2817 [label="TypeSymbol compilationRelaxationsAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute); 366405"];
2818 [label="compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute) 366406"];
2819 [label="param GetWellKnownType(WellKnownType type) 366407"];
2820 [label="param GetWellKnownType(this) 366408"];
2821 [label="Debug.Assert(type.IsValid()); 366409"];
2822 [label="this.Options 366410"];
2823 [label="get\n            {\n                return _options;\n            } 366411"];
2824 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 366412"];
2825 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 366413"];
2826 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 366414"];
2827 [label="param Includes(this BinderFlags self) 366415"];
2828 [label="param Includes(BinderFlags other) 366416"];
2829 [label="return (self & other) == other; 366417"];
2830 [label="int index = (int)type - (int)WellKnownType.First; 366418"];
2831 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 366419"];
2832 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 366420"];
2833 [label="if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                } 366421"];
2834 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 366422"];
2835 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 366423"];
2836 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 366424"];
2837 [label="string mdName = type.GetMetadataName(); 366425"];
2838 [label="var warnings = DiagnosticBag.GetInstance(); 366426"];
2839 [label="NamedTypeSymbol? result; 366427"];
2840 [label="(AssemblySymbol, AssemblySymbol) conflicts = default; 366428"];
2841 [label="if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                } 366429"];
2842 [label="if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                } 366430"];
2843 [label="DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null; 366431"];
2844 [label="(type <= WellKnownType.CSharp7Sentinel) 366432"];
2845 [label="DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null; 366433"];
2846 [label="this.Assembly 366434"];
2847 [label="GetBoundReferenceManager() 366435"];
2848 [label="GetBoundReferenceManager(); 366436"];
2849 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366437"];
2850 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366438"];
2851 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366439"];
2852 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366440"];
2853 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366441"];
2854 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366442"];
2855 [label="this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes) 366443"];
2856 [label="param GetTypeByMetadataName(string metadataName) 366444"];
2857 [label="param GetTypeByMetadataName(bool includeReferences) 366445"];
2858 [label="param GetTypeByMetadataName(bool isWellKnownType) 366446"];
2859 [label="param GetTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 366447"];
2860 [label="param GetTypeByMetadataName(bool useCLSCompliantNameArityEncoding = false) 366448"];
2861 [label="param GetTypeByMetadataName(DiagnosticBag warnings = null) 366449"];
2862 [label="param GetTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 366450"];
2863 [label="param GetTypeByMetadataName(this) 366451"];
2864 [label="NamedTypeSymbol type; 366452"];
2865 [label="MetadataTypeName mdName; 366453"];
2866 [label="mdName 366454"];
2867 [label="if (metadataName.IndexOf('+') >= 0)\n            {\n                var parts = metadataName.Split(s_nestedTypeNameSeparators);\n                Debug.Assert(parts.Length > 0);\n                mdName = MetadataTypeName.FromFullName(parts[0], useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n\n                for (int i = 1; (object)type != null && !type.IsErrorType() && i < parts.Length; i++)\n                {\n                    mdName = MetadataTypeName.FromTypeName(parts[i]);\n                    NamedTypeSymbol temp = type.LookupMetadataType(ref mdName);\n                    type = (!isWellKnownType || IsValidWellKnownType(temp)) ? temp : null;\n                }\n            }\n            else\n            {\n                mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n            } 366455"];
2868 [label="if (metadataName.IndexOf('+') >= 0)\n            {\n                var parts = metadataName.Split(s_nestedTypeNameSeparators);\n                Debug.Assert(parts.Length > 0);\n                mdName = MetadataTypeName.FromFullName(parts[0], useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n\n                for (int i = 1; (object)type != null && !type.IsErrorType() && i < parts.Length; i++)\n                {\n                    mdName = MetadataTypeName.FromTypeName(parts[i]);\n                    NamedTypeSymbol temp = type.LookupMetadataType(ref mdName);\n                    type = (!isWellKnownType || IsValidWellKnownType(temp)) ? temp : null;\n                }\n            }\n            else\n            {\n                mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n            } 366456"];
2869 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 366457"];
2870 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 366458"];
2871 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 366459"];
2872 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366460"];
2873 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366461"];
2874 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366462"];
2875 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366463"];
2876 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366464"];
2877 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366465"];
2878 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 366466"];
2879 [label="GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes) 366467"];
2880 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 366468"];
2881 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 366469"];
2882 [label="param GetTopLevelTypeByMetadataName(bool includeReferences) 366470"];
2883 [label="param GetTopLevelTypeByMetadataName(bool isWellKnownType) 366471"];
2884 [label="param GetTopLevelTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 366472"];
2885 [label="param GetTopLevelTypeByMetadataName(DiagnosticBag warnings = null) 366473"];
2886 [label="param GetTopLevelTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 366474"];
2887 [label="param GetTopLevelTypeByMetadataName(this) 366475"];
2888 [label="conflicts = default; 366476"];
2889 [label="NamedTypeSymbol result; 366477"];
2890 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 366478"];
2891 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 366479"];
2892 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 366480"];
2893 [label="GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt) 366481"];
2894 [label="param GetTopLevelTypeByMetadataName(AssemblySymbol assembly) 366482"];
2895 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 366483"];
2896 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 366484"];
2897 [label="var result = assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false); 366485"];
2898 [label="var result = assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false); 366486"];
2899 [label="assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false) 366487"];
2900 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 366488"];
2901 [label="param LookupTopLevelMetadataType(bool digThroughForwardedTypes) 366489"];
2902 [label="param LookupTopLevelMetadataType(this) 366490"];
2903 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 366491"];
2904 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 366492"];
2905 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 366493"];
2906 [label="LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes) 366494"];
2907 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ref MetadataTypeName emittedName) 366495"];
2908 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 366496"];
2909 [label="param LookupTopLevelMetadataTypeWithCycleDetection(bool digThroughForwardedTypes) 366497"];
2910 [label="param LookupTopLevelMetadataTypeWithCycleDetection(this) 366498"];
2911 [label="NamedTypeSymbol result = null; 366499"];
2912 [label="result = LookupTopLevelMetadataTypeInCache(ref emittedName); 366500"];
2913 [label="LookupTopLevelMetadataTypeInCache(ref emittedName) 366501"];
2914 [label="param LookupTopLevelMetadataTypeInCache(ref MetadataTypeName emittedName) 366502"];
2915 [label="param LookupTopLevelMetadataTypeInCache(this) 366503"];
2916 [label="NamedTypeSymbol result = null; 366504"];
2917 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 366505"];
2918 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 366506"];
2919 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 366507"];
2920 [label="return null; 366508"];
2921 [label="result = LookupTopLevelMetadataTypeInCache(ref emittedName); 366509"];
2922 [label="if ((object)result != null)\n            {\n                // We only cache result equivalent to digging through type forwarders, which\n                // might produce a forwarder specific ErrorTypeSymbol. We don't want to \n                // return that error symbol, unless digThroughForwardedTypes is true.\n                if (digThroughForwardedTypes || (!result.IsErrorType() && (object)result.ContainingAssembly == (object)this))\n                {\n                    return result;\n                }\n\n                // According to the cache, the type wasn't found, or isn't declared in this assembly (forwarded).\n                return new MissingMetadataTypeSymbol.TopLevel(this.Modules[0], ref emittedName);\n            }\n            else\n            {\n                // Now we will look for the type in each module of the assembly and pick the first type\n                // we find, this is what native VB compiler does.\n\n                var modules = this.Modules;\n                var count = modules.Length;\n                var i = 0;\n\n                result = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                }\n\n                bool foundMatchInThisAssembly = (i < count);\n\n                Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this);\n\n                if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                }\n\n                System.Diagnostics.Debug.Assert((object)result != null);\n\n                // Add result of the lookup into the cache\n                if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                }\n\n                return result;\n            } 366510"];
2923 [label="if ((object)result != null)\n            {\n                // We only cache result equivalent to digging through type forwarders, which\n                // might produce a forwarder specific ErrorTypeSymbol. We don't want to \n                // return that error symbol, unless digThroughForwardedTypes is true.\n                if (digThroughForwardedTypes || (!result.IsErrorType() && (object)result.ContainingAssembly == (object)this))\n                {\n                    return result;\n                }\n\n                // According to the cache, the type wasn't found, or isn't declared in this assembly (forwarded).\n                return new MissingMetadataTypeSymbol.TopLevel(this.Modules[0], ref emittedName);\n            }\n            else\n            {\n                // Now we will look for the type in each module of the assembly and pick the first type\n                // we find, this is what native VB compiler does.\n\n                var modules = this.Modules;\n                var count = modules.Length;\n                var i = 0;\n\n                result = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                }\n\n                bool foundMatchInThisAssembly = (i < count);\n\n                Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this);\n\n                if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                }\n\n                System.Diagnostics.Debug.Assert((object)result != null);\n\n                // Add result of the lookup into the cache\n                if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                }\n\n                return result;\n            } 366511"];
2924 [label="this.Modules 366512"];
2925 [label="get\n            {\n                return _modules;\n            } 366513"];
2926 [label="return _modules; 366514"];
2927 [label="var modules = this.Modules; 366515"];
2928 [label="var count = modules.Length; 366516"];
2929 [label="var i = 0; 366517"];
2930 [label="result = modules[i].LookupTopLevelMetadataType(ref emittedName); 366518"];
2931 [label="result = modules[i].LookupTopLevelMetadataType(ref emittedName); 366519"];
2932 [label="modules[i].LookupTopLevelMetadataType(ref emittedName) 366520"];
2933 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 366521"];
2934 [label="param LookupTopLevelMetadataType(this) 366522"];
2935 [label="NamedTypeSymbol result; 366523"];
2936 [label="this.GlobalNamespace 366524"];
2937 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 366525"];
2938 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 366526"];
2939 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 366527"];
2940 [label="var diagnostics = DiagnosticBag.GetInstance(); 366528"];
2941 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 366529"];
2942 [label="DeclaringCompilation 366530"];
2943 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 366531"];
2944 [label="_assemblySymbol.DeclaringCompilation 366532"];
2945 [label="get\n            {\n                return _compilation;\n            } 366533"];
2946 [label="return _assemblySymbol.DeclaringCompilation; 366534"];
2947 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 366535"];
2948 [label="DeclaringCompilation.MergedRootDeclaration 366536"];
2949 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 366537"];
2950 [label="0x1 366538"];
2951 [label="LazyAllMembersIsSorted = 0x1 366539"];
2952 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 366540"];
2953 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 366541"];
2954 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 366542"];
2955 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 366543"];
2956 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 366544"];
2957 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 366545"];
2958 [label="param SourceNamespaceSymbol(Symbol container) 366546"];
2959 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 366547"];
2960 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 366548"];
2961 [label="param SourceNamespaceSymbol(this) 366549"];
2962 [label="param SourceNamespaceSymbol(this) 366550"];
2963 [label="_module 366551"];
2964 [label="_container 366552"];
2965 [label="_mergedDeclaration 366553"];
2966 [label="_nameToMembersMap 366554"];
2967 [label="_nameToTypeMembersMap 366555"];
2968 [label="_flags 366556"];
2969 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 366557"];
2970 [label="1 366558"];
2971 [label="_treeOrdinal 366559"];
2972 [label="0 366560"];
2973 [label="_position 366561"];
2974 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 366562"];
2975 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 366563"];
2976 [label="1 366564"];
2977 [label="_treeOrdinal 366565"];
2978 [label="1 366566"];
2979 [label="_position 366567"];
2980 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 366568"];
2981 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 366569"];
2982 [label="_treeOrdinal 366570"];
2983 [label="1 366571"];
2984 [label="int.MaxValue - 1 366572"];
2985 [label="_position 366573"];
2986 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 366574"];
2987 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 366575"];
2988 [label="_treeOrdinal 366576"];
2989 [label="_position 366577"];
2990 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 366578"];
2991 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 366579"];
2992 [label="Debug.Assert(mergedDeclaration != null); 366580"];
2993 [label="Debug.Assert(mergedDeclaration != null); 366581"];
2994 [label="_module 366582"];
2995 [label="_container 366583"];
2996 [label="_mergedDeclaration 366584"];
2997 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 366585"];
2998 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 366586"];
2999 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 366587"];
3000 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 366588"];
3001 [label="diagnostics.Free(); 366589"];
3002 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 366590"];
3003 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 366591"];
3004 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 366592"];
3005 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 366593"];
3006 [label="return _globalNamespace; 366594"];
3007 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 366595"];
3008 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 366596"];
3009 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 366597"];
3010 [label="param LookupNestedNamespace(ImmutableArray<string> names) 366598"];
3011 [label="param LookupNestedNamespace(this) 366599"];
3012 [label="NamespaceSymbol scope = this; 366600"];
3013 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 366601"];
3014 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 366602"];
3015 [label="NamespaceSymbol nextScope = null; 366603"];
3016 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 366604"];
3017 [label="scope.GetMembers(name) 366605"];
3018 [label="param GetMembers(string name) 366606"];
3019 [label="param GetMembers(this) 366607"];
3020 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 366608"];
3021 [label="members 366609"];
3022 [label="this.GetNameToMembersMap() 366610"];
3023 [label="param GetNameToMembersMap(this) 366611"];
3024 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 366612"];
3025 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 366613"];
3026 [label="var diagnostics = DiagnosticBag.GetInstance(); 366614"];
3027 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 366615"];
3028 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 366616"];
3029 [label="MakeNameToMembersMap(diagnostics) 366617"];
3030 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 366618"];
3031 [label="param MakeNameToMembersMap(this) 366619"];
3032 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 366620"];
3033 [label="_mergedDeclaration.Children 366621"];
3034 [label="param NameToSymbolMapBuilder(int capacity) 366622"];
3035 [label="param NameToSymbolMapBuilder(this) 366623"];
3036 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 366624"];
3037 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 366625"];
3038 [label="_dictionary 366626"];
3039 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 366627"];
3040 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 366628"];
3041 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 366629"];
3042 [label="BuildSymbol(declaration, diagnostics) 366630"];
3043 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 366631"];
3044 [label="param BuildSymbol(DiagnosticBag diagnostics) 366632"];
3045 [label="param BuildSymbol(this) 366633"];
3046 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 366634"];
3047 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 366635"];
3048 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 366636"];
3049 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 366637"];
3050 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 366638"];
3051 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 366639"];
3052 [label="new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics) 366640"];
3053 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 366641"];
3054 [label="param SourceNamespaceSymbol(Symbol container) 366642"];
3055 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 366643"];
3056 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 366644"];
3057 [label="param SourceNamespaceSymbol(this) 366645"];
3058 [label="_module 366646"];
3059 [label="_container 366647"];
3060 [label="_mergedDeclaration 366648"];
3061 [label="Debug.Assert(mergedDeclaration != null); 366649"];
3062 [label="Debug.Assert(mergedDeclaration != null); 366650"];
3063 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 366651"];
3064 [label="param Add(NamespaceOrTypeSymbol symbol) 366652"];
3065 [label="param Add(this) 366653"];
3066 [label="symbol.Name 366654"];
3067 [label="=> _mergedDeclaration.Name 366655"];
3068 [label="_mergedDeclaration.Name 366656"];
3069 [label="string name = symbol.Name; 366657"];
3070 [label="object item; 366658"];
3071 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 366659"];
3072 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 366660"];
3073 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 366661"];
3074 [label="_dictionary 366662"];
3075 [label="builder.CreateMap() 366663"];
3076 [label="param CreateMap(this) 366664"];
3077 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 366665"];
3078 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 366666"];
3079 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 366667"];
3080 [label="object value = kvp.Value; 366668"];
3081 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 366669"];
3082 [label="members 366670"];
3083 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 366671"];
3084 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 366672"];
3085 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 366673"];
3086 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 366674"];
3087 [label="symbol.Kind 366675"];
3088 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 366676"];
3089 [label="return SymbolKind.Namespace; 366677"];
3090 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 366678"];
3091 [label="symbol.Kind == SymbolKind.Namespace 366679"];
3092 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 366680"];
3093 [label="result.Add(kvp.Key, members); 366681"];
3094 [label="result.Add(kvp.Key, members); 366682"];
3095 [label="result.Add(kvp.Key, members); 366683"];
3096 [label="return result; 366684"];
3097 [label="var result = builder.CreateMap(); 366685"];
3098 [label="CheckMembers(this, result, diagnostics); 366686"];
3099 [label="CheckMembers(this, result, diagnostics); 366687"];
3100 [label="CheckMembers(this, result, diagnostics); 366688"];
3101 [label="CheckMembers(this, result, diagnostics) 366689"];
3102 [label="param CheckMembers(NamespaceSymbol @namespace) 366690"];
3103 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 366691"];
3104 [label="param CheckMembers(DiagnosticBag diagnostics) 366692"];
3105 [label="var memberOfArity = new Symbol[10]; 366693"];
3106 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 366694"];
3107 [label="@namespace.ContainingAssembly 366695"];
3108 [label="=> _module.ContainingAssembly 366696"];
3109 [label="_module.ContainingAssembly 366697"];
3110 [label="get\n            {\n                return _assemblySymbol;\n            } 366698"];
3111 [label="return _assemblySymbol; 366699"];
3112 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 366700"];
3113 [label="@namespace.ContainingAssembly.Modules 366701"];
3114 [label="get\n            {\n                return _modules;\n            } 366702"];
3115 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 366703"];
3116 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 366704"];
3117 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 366705"];
3118 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 366706"];
3119 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 366707"];
3120 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 366708"];
3121 [label="var nts = symbol as NamedTypeSymbol; 366709"];
3122 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 366710"];
3123 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 366711"];
3124 [label="((object)nts != null) 366712"];
3125 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 366713"];
3126 [label="var other = memberOfArity[arity]; 366714"];
3127 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 366715"];
3128 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 366716"];
3129 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 366717"];
3130 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 366718"];
3131 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 366719"];
3132 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 366720"];
3133 [label="memberOfArity[arity] 366721"];
3134 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 366722"];
3135 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 366723"];
3136 [label="CheckMembers(this, result, diagnostics); 366724"];
3137 [label="return result; 366725"];
3138 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 366726"];
3139 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 366727"];
3140 [label="this.DeclaringCompilation 366728"];
3141 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 366729"];
3142 [label="this.Kind 366730"];
3143 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 366731"];
3144 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 366732"];
3145 [label="this.ContainingModule 366733"];
3146 [label="get\n            {\n                return _module;\n            } 366734"];
3147 [label="return _module; 366735"];
3148 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 366736"];
3149 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 366737"];
3150 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 366738"];
3151 [label="(object)sourceModuleSymbol == null 366739"];
3152 [label="sourceModuleSymbol.DeclaringCompilation 366740"];
3153 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 366741"];
3154 [label="this.DeclaringCompilation.DeclarationDiagnostics 366742"];
3155 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 366743"];
3156 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 366744"];
3157 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 366745"];
3158 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 366746"];
3159 [label="var diagnostics = new DiagnosticBag(); 366747"];
3160 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 366748"];
3161 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 366749"];
3162 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 366750"];
3163 [label="return _lazyDeclarationDiagnostics; 366751"];
3164 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 366752"];
3165 [label="RegisterDeclaredCorTypes() 366753"];
3166 [label="param RegisterDeclaredCorTypes(this) 366754"];
3167 [label="ContainingAssembly 366755"];
3168 [label="=> _module.ContainingAssembly 366756"];
3169 [label="_module.ContainingAssembly 366757"];
3170 [label="get\n            {\n                return _assemblySymbol;\n            } 366758"];
3171 [label="return _assemblySymbol; 366759"];
3172 [label="AssemblySymbol containingAssembly = ContainingAssembly; 366760"];
3173 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 366761"];
3174 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 366762"];
3175 [label="this.CorLibrary 366763"];
3176 [label="get\n            {\n                return _corLibrary;\n            } 366764"];
3177 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 366765"];
3178 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 366766"];
3179 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 366767"];
3180 [label="RegisterDeclaredCorTypes(); 366768"];
3181 [label="DeclaringCompilation 366769"];
3182 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 366770"];
3183 [label="this.Kind 366771"];
3184 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 366772"];
3185 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 366773"];
3186 [label="this.ContainingModule 366774"];
3187 [label="get\n            {\n                return _module;\n            } 366775"];
3188 [label="return _module; 366776"];
3189 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 366777"];
3190 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 366778"];
3191 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 366779"];
3192 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 366780"];
3193 [label="param SymbolDeclaredEvent(Symbol symbol) 366781"];
3194 [label="param SymbolDeclaredEvent(this) 366782"];
3195 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 366783"];
3196 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 366784"];
3197 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 366785"];
3198 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 366786"];
3199 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 366787"];
3200 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 366788"];
3201 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 366789"];
3202 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 366790"];
3203 [label="param NotePartComplete(CompletionPart part) 366791"];
3204 [label="param NotePartComplete(this) 366792"];
3205 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 366793"];
3206 [label="Debug.Assert(wasSetThisThread); 366794"];
3207 [label="diagnostics.Free(); 366795"];
3208 [label="return _nameToMembersMap; 366796"];
3209 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 366797"];
3210 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 366798"];
3211 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 366799"];
3212 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 366800"];
3213 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 366801"];
3214 [label="scope = nextScope; 366802"];
3215 [label="if ((object)scope == null)\n                {\n                    break;\n                } 366803"];
3216 [label="if ((object)scope == null)\n                {\n                    break;\n                } 366804"];
3217 [label="return scope; 366805"];
3218 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 366806"];
3219 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 366807"];
3220 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 366808"];
3221 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 366809"];
3222 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 366810"];
3223 [label="new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName) 366811"];
3224 [label="param TopLevel(ModuleSymbol module) 366812"];
3225 [label="param TopLevel(ref MetadataTypeName fullName) 366813"];
3226 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 366814"];
3227 [label="param TopLevel(this) 366815"];
3228 [label="module 366816"];
3229 [label="fullName 366817"];
3230 [label="1 366818"];
3231 [label="errorInfo 366819"];
3232 [label="param TopLevel(this) 366820"];
3233 [label="param TopLevel(ModuleSymbol module) 366821"];
3234 [label="param TopLevel(ref MetadataTypeName fullName) 366822"];
3235 [label="param TopLevel(int typeId) 366823"];
3236 [label="param TopLevel(DiagnosticInfo? errorInfo) 366824"];
3237 [label="param TopLevel(this) 366825"];
3238 [label="module 366826"];
3239 [label="fullName 366827"];
3240 [label="1 366828"];
3241 [label="fullName.ForcedArity == -1 366829"];
3242 [label="fullName.ForcedArity == -1 || fullName.ForcedArity == fullName.InferredArity 366830"];
3243 [label="errorInfo 366831"];
3244 [label="typeId 366832"];
3245 [label="param TopLevel(this) 366833"];
3246 [label="param TopLevel(ModuleSymbol module) 366834"];
3247 [label="param TopLevel(ref MetadataTypeName fullName) 366835"];
3248 [label="param TopLevel(bool mangleName) 366836"];
3249 [label="param TopLevel(DiagnosticInfo? errorInfo) 366837"];
3250 [label="param TopLevel(int typeId) 366838"];
3251 [label="param TopLevel(this) 366839"];
3252 [label="module 366840"];
3253 [label="fullName.NamespaceName 366841"];
3254 [label="mangleName 366842"];
3255 [label="fullName.UnmangledTypeName 366843"];
3256 [label="mangleName 366844"];
3257 [label="fullName.InferredArity 366845"];
3258 [label="mangleName 366846"];
3259 [label="false 366847"];
3260 [label="errorInfo 366848"];
3261 [label="null 366849"];
3262 [label="typeId 366850"];
3263 [label="null 366851"];
3264 [label="param TopLevel(this) 366852"];
3265 [label="param TopLevel(ModuleSymbol module) 366853"];
3266 [label="param TopLevel(string @namespace) 366854"];
3267 [label="param TopLevel(string name) 366855"];
3268 [label="param TopLevel(int arity) 366856"];
3269 [label="param TopLevel(bool mangleName) 366857"];
3270 [label="param TopLevel(bool isNativeInt) 366858"];
3271 [label="param TopLevel(DiagnosticInfo? errorInfo) 366859"];
3272 [label="param TopLevel(NamespaceSymbol? containingNamespace) 366860"];
3273 [label="param TopLevel(int typeId) 366861"];
3274 [label="param TopLevel(TupleExtraData? tupleData) 366862"];
3275 [label="param TopLevel(this) 366863"];
3276 [label="name 366864"];
3277 [label="arity 366865"];
3278 [label="mangleName 366866"];
3279 [label="tupleData 366867"];
3280 [label="param TopLevel(this) 366868"];
3281 [label="param MissingMetadataTypeSymbol(string name) 366869"];
3282 [label="param MissingMetadataTypeSymbol(int arity) 366870"];
3283 [label="param MissingMetadataTypeSymbol(bool mangleName) 366871"];
3284 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 366872"];
3285 [label="param MissingMetadataTypeSymbol(this) 366873"];
3286 [label="new UnsupportedMetadataTypeSymbol() 366874"];
3287 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 366875"];
3288 [label="param UnsupportedMetadataTypeSymbol(this) 366876"];
3289 [label="param ErrorTypeSymbol(this) 366877"];
3290 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 366878"];
3291 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 366879"];
3292 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 366880"];
3293 [label="type => !type.HasType 366881"];
3294 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 366882"];
3295 [label="type => type.HasType && type.Type.IsErrorType() 366883"];
3296 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 366884"];
3297 [label="8 366885"];
3298 [label="ValueTupleRestPosition = 8 366886"];
3299 [label="1 366887"];
3300 [label="ValueTupleRestPosition - 1 366888"];
3301 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 366889"];
3302 [label="'ValueTuple' 366890"];
3303 [label="ValueTupleTypeName = 'ValueTuple' 366891"];
3304 [label="'Rest' 366892"];
3305 [label="ValueTupleRestFieldName = 'Rest' 366893"];
3306 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 366894"];
3307 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 366895"];
3308 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 366896"];
3309 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 366897"];
3310 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366898"];
3311 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 366899"];
3312 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 366900"];
3313 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 366901"];
3314 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 366902"];
3315 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 366903"];
3316 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 366904"];
3317 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 366905"];
3318 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 366906"];
3319 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366907"];
3320 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366908"];
3321 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366909"];
3322 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366910"];
3323 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366911"];
3324 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366912"];
3325 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366913"];
3326 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366914"];
3327 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 366915"];
3328 [label="tupleData 366916"];
3329 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 366917"];
3330 [label="param NamedTypeSymbol(this) 366918"];
3331 [label="'<invalid-global-code>' 366919"];
3332 [label="ImplicitTypeName = '<invalid-global-code>' 366920"];
3333 [label="0 366921"];
3334 [label="TypeCompareKind.ConsiderEverything 366922"];
3335 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 366923"];
3336 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366924"];
3337 [label="param SymbolEqualityComparer(this) 366925"];
3338 [label="_comparison 366926"];
3339 [label="_comparison 366927"];
3340 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 366928"];
3341 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 366929"];
3342 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366930"];
3343 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366931"];
3344 [label="param SymbolEqualityComparer(this) 366932"];
3345 [label="_comparison 366933"];
3346 [label="_comparison 366934"];
3347 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366935"];
3348 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 366936"];
3349 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366937"];
3350 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366938"];
3351 [label="param SymbolEqualityComparer(this) 366939"];
3352 [label="_comparison 366940"];
3353 [label="_comparison 366941"];
3354 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366942"];
3355 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 366943"];
3356 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366944"];
3357 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366945"];
3358 [label="param SymbolEqualityComparer(this) 366946"];
3359 [label="_comparison 366947"];
3360 [label="_comparison 366948"];
3361 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366949"];
3362 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 366950"];
3363 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 366951"];
3364 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366952"];
3365 [label="param SymbolEqualityComparer(this) 366953"];
3366 [label="_comparison 366954"];
3367 [label="_comparison 366955"];
3368 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 366956"];
3369 [label="TypeCompareKind.AllIgnoreOptions 366957"];
3370 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 366958"];
3371 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366959"];
3372 [label="param SymbolEqualityComparer(this) 366960"];
3373 [label="_comparison 366961"];
3374 [label="_comparison 366962"];
3375 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 366963"];
3376 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 366964"];
3377 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 366965"];
3378 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366966"];
3379 [label="param SymbolEqualityComparer(this) 366967"];
3380 [label="_comparison 366968"];
3381 [label="_comparison 366969"];
3382 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 366970"];
3383 [label="TypeCompareKind.CLRSignatureCompareOptions 366971"];
3384 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 366972"];
3385 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 366973"];
3386 [label="param SymbolEqualityComparer(this) 366974"];
3387 [label="_comparison 366975"];
3388 [label="_comparison 366976"];
3389 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 366977"];
3390 [label="SymbolEqualityComparer.CLRSignature 366978"];
3391 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 366979"];
3392 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 366980"];
3393 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 366981"];
3394 [label="new InterfaceInfo() 366982"];
3395 [label="param InterfaceInfo(this) 366983"];
3396 [label="interfacesAndTheirBaseInterfaces 366984"];
3397 [label="_implementationForInterfaceMemberMap 366985"];
3398 [label="explicitInterfaceImplementationMap 366986"];
3399 [label="s_noInterfaces = new InterfaceInfo() 366987"];
3400 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 366988"];
3401 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 366989"];
3402 [label="param TypeSymbol(this) 366990"];
3403 [label="param NamespaceOrTypeSymbol(this) 366991"];
3404 [label="param Symbol(this) 366992"];
3405 [label="_lazyISymbol 366993"];
3406 [label="_lazyAbstractMembers 366994"];
3407 [label="_lazyInterfaceInfo 366995"];
3408 [label="_lazyAdapter 366996"];
3409 [label="_hasNoBaseCycles 366997"];
3410 [label="_lazyTupleData 366998"];
3411 [label="_lazyTupleData 366999"];
3412 [label="_mrEx 367000"];
3413 [label="_mrEx 367001"];
3414 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 367002"];
3415 [label="tupleData 367003"];
3416 [label="param MissingMetadataTypeSymbol(this) 367004"];
3417 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 367005"];
3418 [label="param ErrorTypeSymbol(this) 367006"];
3419 [label="tupleData 367007"];
3420 [label="param ErrorTypeSymbol(this) 367008"];
3421 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 367009"];
3422 [label="param NamedTypeSymbol(this) 367010"];
3423 [label="param NamedTypeSymbol(this) 367011"];
3424 [label="param TypeSymbol(this) 367012"];
3425 [label="param TypeSymbol(this) 367013"];
3426 [label="_lazyAbstractMembers 367014"];
3427 [label="_lazyInterfaceInfo 367015"];
3428 [label="_lazyAdapter 367016"];
3429 [label="_hasNoBaseCycles 367017"];
3430 [label="_lazyTupleData 367018"];
3431 [label="_lazyTupleData 367019"];
3432 [label="name 367020"];
3433 [label="arity 367021"];
3434 [label="mangleName 367022"];
3435 [label="RoslynDebug.Assert(name != null); 367023"];
3436 [label="RoslynDebug.Assert(name != null); 367024"];
3437 [label="this.name 367025"];
3438 [label="this.arity 367026"];
3439 [label="this.mangleName = (mangleName && arity > 0); 367027"];
3440 [label="this.mangleName = (mangleName && arity > 0); 367028"];
3441 [label="this.mangleName = (mangleName && arity > 0); 367029"];
3442 [label="this.mangleName 367030"];
3443 [label="_namespaceName 367031"];
3444 [label="_containingModule 367032"];
3445 [label="_isNativeInt 367033"];
3446 [label="_lazyErrorInfo 367034"];
3447 [label="_lazyContainingNamespace 367035"];
3448 [label="_lazyTypeId 367036"];
3449 [label="RoslynDebug.Assert((object)module != null); 367037"];
3450 [label="RoslynDebug.Assert((object)module != null); 367038"];
3451 [label="RoslynDebug.Assert(@namespace != null); 367039"];
3452 [label="RoslynDebug.Assert(@namespace != null); 367040"];
3453 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 367041"];
3454 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 367042"];
3455 [label="_namespaceName 367043"];
3456 [label="_containingModule 367044"];
3457 [label="_isNativeInt 367045"];
3458 [label="_lazyErrorInfo 367046"];
3459 [label="_lazyContainingNamespace 367047"];
3460 [label="_lazyTypeId 367048"];
3461 [label="Debug.Assert((object)result != null); 367049"];
3462 [label="Debug.Assert((object)result != null); 367050"];
3463 [label="return result; 367051"];
3464 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 367052"];
3465 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 367053"];
3466 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 367054"];
3467 [label="bool foundMatchInThisAssembly = (i < count); 367055"];
3468 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 367056"];
3469 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 367057"];
3470 [label="System.Diagnostics.Debug.Assert((object)result != null); 367058"];
3471 [label="System.Diagnostics.Debug.Assert((object)result != null); 367059"];
3472 [label="if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                } 367060"];
3473 [label="return result; 367061"];
3474 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 367062"];
3475 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 367063"];
3476 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 367064"];
3477 [label="candidate.Kind 367065"];
3478 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 367066"];
3479 [label="return SymbolKind.ErrorType; 367067"];
3480 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 367068"];
3481 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 367069"];
3482 [label="return null; 367070"];
3483 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 367071"];
3484 [label="IsValidWellKnownType(result) 367072"];
3485 [label="param IsValidWellKnownType(NamedTypeSymbol result) 367073"];
3486 [label="param IsValidWellKnownType(this) 367074"];
3487 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 367075"];
3488 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 367076"];
3489 [label="return false; 367077"];
3490 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 367078"];
3491 [label="result = null; 367079"];
3492 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 367080"];
3493 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 367081"];
3494 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 367082"];
3495 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 367083"];
3496 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 367084"];
3497 [label="var assemblies = ArrayBuilder<AssemblySymbol>.GetInstance(); 367085"];
3498 [label="if (assemblyOpt != null)\n            {\n                assemblies.AddRange(DeclaringCompilation.GetBoundReferenceManager().ReferencedAssemblies);\n            }\n            else\n            {\n                DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies);\n            } 367086"];
3499 [label="if (assemblyOpt != null)\n            {\n                assemblies.AddRange(DeclaringCompilation.GetBoundReferenceManager().ReferencedAssemblies);\n            }\n            else\n            {\n                DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies);\n            } 367087"];
3500 [label="DeclaringCompilation 367088"];
3501 [label="get\n            {\n                return _compilation;\n            } 367089"];
3502 [label="return _compilation; 367090"];
3503 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 367091"];
3504 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 367092"];
3505 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies) 367093"];
3506 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 367094"];
3507 [label="param GetUnaliasedReferencedAssemblies(this) 367095"];
3508 [label="GetBoundReferenceManager() 367096"];
3509 [label="param GetBoundReferenceManager(this) 367097"];
3510 [label="var referenceManager = GetBoundReferenceManager(); 367098"];
3511 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 367099"];
3512 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 367100"];
3513 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                } 367101"];
3514 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 367102"];
3515 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 367103"];
3516 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 367104"];
3517 [label="foreach (var assembly in assemblies)\n            {\n                Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); // Non-source assemblies can have missing references\n\n                NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt);\n\n                if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                }\n\n                if ((object)candidate == null)\n                {\n                    continue;\n                }\n\n                if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                }\n\n                Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2));\n\n                if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                }\n\n                result = candidate;\n            } 367105"];
3518 [label="foreach (var assembly in assemblies)\n            {\n                Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); // Non-source assemblies can have missing references\n\n                NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt);\n\n                if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                }\n\n                if ((object)candidate == null)\n                {\n                    continue;\n                }\n\n                if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                }\n\n                Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2));\n\n                if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                }\n\n                result = candidate;\n            } 367106"];
3519 [label="assembly.IsMissing 367107"];
3520 [label="get\n            {\n                return false;\n            } 367108"];
3521 [label="return false; 367109"];
3522 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 367110"];
3523 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 367111"];
3524 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 367112"];
3525 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 367113"];
3526 [label="GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt) 367114"];
3527 [label="param GetTopLevelTypeByMetadataName(AssemblySymbol assembly) 367115"];
3528 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 367116"];
3529 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 367117"];
3530 [label="param LookupTopLevelMetadataType(bool digThroughForwardedTypes) 367118"];
3531 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 367119"];
3532 [label="param LookupTopLevelMetadataTypeWithCycleDetection(bool digThroughForwardedTypes) 367120"];
3533 [label="NamedTypeSymbol result = null; 367121"];
3534 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 367122"];
3535 [label="var count = modules.Length; 367123"];
3536 [label="NamedTypeSymbol result; 367124"];
3537 [label="get { return _globalNamespace; } 367125"];
3538 [label="return _globalNamespace; 367126"];
3539 [label="param GetMembers(string name) 367127"];
3540 [label="param GetMembers(this) 367128"];
3541 [label="EnsureAllMembersLoaded() 367129"];
3542 [label="param EnsureAllMembersLoaded(this) 367130"];
3543 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 367131"];
3544 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 367132"];
3545 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 367133"];
3546 [label="_moduleSymbol.Module 367134"];
3547 [label="get\n            {\n                return _module;\n            } 367135"];
3548 [label="return _module; 367136"];
3549 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 367137"];
3550 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 367138"];
3551 [label="LoadAllMembers(groups); 367139"];
3552 [label="LoadAllMembers(groups) 367140"];
3553 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 367141"];
3554 [label="param LoadAllMembers(this) 367142"];
3555 [label="Debug.Assert(typesByNS != null); 367143"];
3556 [label="Debug.Assert(typesByNS != null); 367144"];
3557 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 367145"];
3558 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 367146"];
3559 [label="this.IsGlobalNamespace 367147"];
3560 [label="get\n            {\n                return true;\n            } 367148"];
3561 [label="return true; 367149"];
3562 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 367150"];
3563 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367151"];
3564 [label="isGlobalNamespace 367152"];
3565 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367153"];
3566 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367154"];
3567 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367155"];
3568 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367156"];
3569 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367157"];
3570 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367158"];
3571 [label="LazyInitializeNamespaces(nestedNamespaces); 367159"];
3572 [label="LazyInitializeNamespaces(nestedNamespaces) 367160"];
3573 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 367161"];
3574 [label="param LazyInitializeNamespaces(this) 367162"];
3575 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 367163"];
3576 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 367164"];
3577 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 367165"];
3578 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 367166"];
3579 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 367167"];
3580 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 367168"];
3581 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 367169"];
3582 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 367170"];
3583 [label="param PENestedNamespaceSymbol(string name) 367171"];
3584 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 367172"];
3585 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 367173"];
3586 [label="param PENestedNamespaceSymbol(this) 367174"];
3587 [label="param PENestedNamespaceSymbol(this) 367175"];
3588 [label="_containingNamespaceSymbol 367176"];
3589 [label="_name 367177"];
3590 [label="_typesByNS 367178"];
3591 [label="Debug.Assert(name != null); 367179"];
3592 [label="Debug.Assert(name != null); 367180"];
3593 [label="Debug.Assert((object)containingNamespace != null); 367181"];
3594 [label="Debug.Assert((object)containingNamespace != null); 367182"];
3595 [label="Debug.Assert(typesByNS != null); 367183"];
3596 [label="Debug.Assert(typesByNS != null); 367184"];
3597 [label="_containingNamespaceSymbol 367185"];
3598 [label="_name 367186"];
3599 [label="_typesByNS 367187"];
3600 [label="c.Name 367188"];
3601 [label="get\n            {\n                return _name;\n            } 367189"];
3602 [label="return _name; 367190"];
3603 [label="namespaces.Add(c.Name, c); 367191"];
3604 [label="namespaces.Add(c.Name, c); 367192"];
3605 [label="namespaces.Add(c.Name, c); 367193"];
3606 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 367194"];
3607 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 367195"];
3608 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 367196"];
3609 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 367197"];
3610 [label="LazyInitializeNamespaces(nestedNamespaces); 367198"];
3611 [label="LazyInitializeTypes(nestedTypes); 367199"];
3612 [label="LazyInitializeTypes(nestedTypes) 367200"];
3613 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 367201"];
3614 [label="param LazyInitializeTypes(this) 367202"];
3615 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 367203"];
3616 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 367204"];
3617 [label="ContainingPEModule 367205"];
3618 [label="get\n            {\n                return _moduleSymbol;\n            } 367206"];
3619 [label="return _moduleSymbol; 367207"];
3620 [label="var moduleSymbol = ContainingPEModule; 367208"];
3621 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 367209"];
3622 [label="moduleSymbol.Module 367210"];
3623 [label="get\n            {\n                return _module;\n            } 367211"];
3624 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 367212"];
3625 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 367213"];
3626 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 367214"];
3627 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 367215"];
3628 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 367216"];
3629 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 367217"];
3630 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367218"];
3631 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367219"];
3632 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367220"];
3633 [label="EmptyComparer.Instance 367221"];
3634 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 367222"];
3635 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 367223"];
3636 [label="new UncommonProperties() 367224"];
3637 [label="param UncommonProperties(this) 367225"];
3638 [label="lazyEnumUnderlyingType 367226"];
3639 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 367227"];
3640 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 367228"];
3641 [label="lazyContainsExtensionMethods 367229"];
3642 [label="lazyIsByRefLike 367230"];
3643 [label="lazyIsReadOnly 367231"];
3644 [label="lazyDefaultMemberName 367232"];
3645 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 367233"];
3646 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 367234"];
3647 [label="s_noUncommonProperties = new UncommonProperties() 367235"];
3648 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367236"];
3649 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 367237"];
3650 [label="param Create(PEModuleSymbol moduleSymbol) 367238"];
3651 [label="param Create(PENamespaceSymbol containingNamespace) 367239"];
3652 [label="param Create(TypeDefinitionHandle handle) 367240"];
3653 [label="param Create(string emittedNamespaceName) 367241"];
3654 [label="GenericParameterHandleCollection genericParameterHandles; 367242"];
3655 [label="genericParameterHandles 367243"];
3656 [label="ushort arity; 367244"];
3657 [label="BadImageFormatException mrEx = null; 367245"];
3658 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367246"];
3659 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367247"];
3660 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367248"];
3661 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367249"];
3662 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367250"];
3663 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 367251"];
3664 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 367252"];
3665 [label="param GetGenericInfo(TypeDefinitionHandle handle) 367253"];
3666 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367254"];
3667 [label="param GetGenericInfo(out ushort arity) 367255"];
3668 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367256"];
3669 [label="moduleSymbol.Module 367257"];
3670 [label="get\n            {\n                return _module;\n            } 367258"];
3671 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 367259"];
3672 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 367260"];
3673 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 367261"];
3674 [label="arity = (ushort)genericParameterHandles.Count; 367262"];
3675 [label="mrEx = null; 367263"];
3676 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 367264"];
3677 [label="bool mangleName; 367265"];
3678 [label="PENamedTypeSymbol result; 367266"];
3679 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 367267"];
3680 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 367268"];
3681 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367269"];
3682 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367270"];
3683 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367271"];
3684 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367272"];
3685 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367273"];
3686 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 367274"];
3687 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 367275"];
3688 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 367276"];
3689 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 367277"];
3690 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 367278"];
3691 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 367279"];
3692 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 367280"];
3693 [label="param PENamedTypeSymbolNonGeneric(this) 367281"];
3694 [label="moduleSymbol 367282"];
3695 [label="container 367283"];
3696 [label="handle 367284"];
3697 [label="emittedNamespaceName 367285"];
3698 [label="0 367286"];
3699 [label="mangleName 367287"];
3700 [label="param PENamedTypeSymbolNonGeneric(this) 367288"];
3701 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 367289"];
3702 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 367290"];
3703 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 367291"];
3704 [label="param PENamedTypeSymbol(string emittedNamespaceName) 367292"];
3705 [label="param PENamedTypeSymbol(ushort arity) 367293"];
3706 [label="param PENamedTypeSymbol(out bool mangleName) 367294"];
3707 [label="param PENamedTypeSymbol(this) 367295"];
3708 [label="param PENamedTypeSymbol(this) 367296"];
3709 [label="param NamedTypeSymbol(this) 367297"];
3710 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 367298"];
3711 [label="param NamedTypeSymbol(this) 367299"];
3712 [label="param TypeSymbol(this) 367300"];
3713 [label="param TypeSymbol(this) 367301"];
3714 [label="_lazyAbstractMembers 367302"];
3715 [label="_lazyInterfaceInfo 367303"];
3716 [label="_lazyAdapter 367304"];
3717 [label="_hasNoBaseCycles 367305"];
3718 [label="_lazyTupleData 367306"];
3719 [label="_lazyTupleData 367307"];
3720 [label="_container 367308"];
3721 [label="_name 367309"];
3722 [label="_flags 367310"];
3723 [label="_corTypeId 367311"];
3724 [label="_lazyMemberNames 367312"];
3725 [label="_lazyMembersByName 367313"];
3726 [label="_lazyNestedTypes 367314"];
3727 [label="_lazyKind 367315"];
3728 [label="_lazyNullableContextValue 367316"];
3729 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 367317"];
3730 [label="default(ImmutableArray<NamedTypeSymbol>) 367318"];
3731 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 367319"];
3732 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 367320"];
3733 [label="default(ImmutableArray<NamedTypeSymbol>) 367321"];
3734 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 367322"];
3735 [label="_lazyDocComment 367323"];
3736 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 367324"];
3737 [label="_lazyUncommonProperties 367325"];
3738 [label="public IEnumerable<object> fieldDefs { get; set; } 367326"];
3739 [label="Debug.Assert(!handle.IsNil); 367327"];
3740 [label="Debug.Assert((object)container != null); 367328"];
3741 [label="Debug.Assert((object)container != null); 367329"];
3742 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367330"];
3743 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367331"];
3744 [label="string metadataName; 367332"];
3745 [label="bool makeBad = false; 367333"];
3746 [label="moduleSymbol.Module 367334"];
3747 [label="get\n            {\n                return _module;\n            } 367335"];
3748 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 367336"];
3749 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 367337"];
3750 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 367338"];
3751 [label="_handle 367339"];
3752 [label="_container 367340"];
3753 [label="moduleSymbol.Module 367341"];
3754 [label="get\n            {\n                return _module;\n            } 367342"];
3755 [label="return _module; 367343"];
3756 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 367344"];
3757 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 367345"];
3758 [label="_flags 367346"];
3759 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 367347"];
3760 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 367348"];
3761 [label="_name 367349"];
3762 [label="mangleName = false; 367350"];
3763 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367351"];
3764 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367352"];
3765 [label="moduleSymbol.ContainingAssembly 367353"];
3766 [label="get\n            {\n                return _assemblySymbol;\n            } 367354"];
3767 [label="return _assemblySymbol; 367355"];
3768 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367356"];
3769 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 367357"];
3770 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 367358"];
3771 [label="this.CorLibrary 367359"];
3772 [label="get\n            {\n                return _corLibrary;\n            } 367360"];
3773 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 367361"];
3774 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 367362"];
3775 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 367363"];
3776 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367364"];
3777 [label="this.DeclaredAccessibility 367365"];
3778 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 367366"];
3779 [label="Accessibility access = Accessibility.Private; 367367"];
3780 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 367368"];
3781 [label="access = Accessibility.Internal; 367369"];
3782 [label="return access; 367370"];
3783 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367371"];
3784 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367372"];
3785 [label="_corTypeId 367373"];
3786 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367374"];
3787 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367375"];
3788 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367376"];
3789 [label="return result; 367377"];
3790 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367378"];
3791 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 367379"];
3792 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 367380"];
3793 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 367381"];
3794 [label="get\n            {\n                return _name;\n            } 367382"];
3795 [label="return _name; 367383"];
3796 [label="children.Free(); 367384"];
3797 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367385"];
3798 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367386"];
3799 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 367387"];
3800 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 367388"];
3801 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 367389"];
3802 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 367390"];
3803 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 367391"];
3804 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 367392"];
3805 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 367393"];
3806 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 367394"];
3807 [label="param OnNewTypeDeclarationsLoaded(this) 367395"];
3808 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 367396"];
3809 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 367397"];
3810 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 367398"];
3811 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 367399"];
3812 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 367400"];
3813 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 367401"];
3814 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 367402"];
3815 [label="bool added; 367403"];
3816 [label="type.Handle 367404"];
3817 [label="get\n            {\n                return _handle;\n            } 367405"];
3818 [label="return _handle; 367406"];
3819 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 367407"];
3820 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 367408"];
3821 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 367409"];
3822 [label="Debug.Assert(added); 367410"];
3823 [label="type.SpecialType 367411"];
3824 [label="get\n            {\n                return _corTypeId;\n            } 367412"];
3825 [label="return _corTypeId; 367413"];
3826 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 367414"];
3827 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 367415"];
3828 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 367416"];
3829 [label="LazyInitializeTypes(nestedTypes); 367417"];
3830 [label="LoadAllMembers(groups); 367418"];
3831 [label="EnsureAllMembersLoaded(); 367419"];
3832 [label="PENestedNamespaceSymbol ns = null; 367420"];
3833 [label="ImmutableArray<PENamedTypeSymbol> t; 367421"];
3834 [label="t 367422"];
3835 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 367423"];
3836 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 367424"];
3837 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 367425"];
3838 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 367426"];
3839 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 367427"];
3840 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 367428"];
3841 [label="return ImmutableArray.Create<Symbol>(ns); 367429"];
3842 [label="var ns = symbol as NamespaceSymbol; 367430"];
3843 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 367431"];
3844 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 367432"];
3845 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 367433"];
3846 [label="nextScope = ns; 367434"];
3847 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367435"];
3848 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367436"];
3849 [label="param EnsureAllMembersLoaded(this) 367437"];
3850 [label="var typesByNS = _typesByNS; 367438"];
3851 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 367439"];
3852 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 367440"];
3853 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 367441"];
3854 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 367442"];
3855 [label="LoadAllMembers(typesByNS); 367443"];
3856 [label="LoadAllMembers(typesByNS) 367444"];
3857 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 367445"];
3858 [label="Debug.Assert(typesByNS != null); 367446"];
3859 [label="Debug.Assert(typesByNS != null); 367447"];
3860 [label="get\n            {\n                return false;\n            } 367448"];
3861 [label="return false; 367449"];
3862 [label="GetQualifiedNameLength() 367450"];
3863 [label="param GetQualifiedNameLength(this) 367451"];
3864 [label="this.Name 367452"];
3865 [label="get\n            {\n                return _name;\n            } 367453"];
3866 [label="int length = this.Name.Length; 367454"];
3867 [label="ContainingNamespace 367455"];
3868 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 367456"];
3869 [label="this.ContainingSymbol 367457"];
3870 [label="get { return _containingNamespaceSymbol; } 367458"];
3871 [label="return _containingNamespaceSymbol; 367459"];
3872 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 367460"];
3873 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 367461"];
3874 [label="var ns = container as NamespaceSymbol; 367462"];
3875 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 367463"];
3876 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 367464"];
3877 [label="return ns; 367465"];
3878 [label="var parent = ContainingNamespace; 367466"];
3879 [label=".IsGlobalNamespace 367467"];
3880 [label="get\n            {\n                return true;\n            } 367468"];
3881 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 367469"];
3882 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 367470"];
3883 [label="return length; 367471"];
3884 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 367472"];
3885 [label="_containingNamespaceSymbol 367473"];
3886 [label="_name 367474"];
3887 [label="_typesByNS 367475"];
3888 [label="Debug.Assert(name != null); 367476"];
3889 [label="Debug.Assert((object)containingNamespace != null); 367477"];
3890 [label="Debug.Assert(typesByNS != null); 367478"];
3891 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367479"];
3892 [label="_containingNamespaceSymbol.ContainingPEModule 367480"];
3893 [label="get\n            {\n                return _moduleSymbol;\n            } 367481"];
3894 [label="return _containingNamespaceSymbol.ContainingPEModule; 367482"];
3895 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 367483"];
3896 [label="GenericParameterHandleCollection genericParameterHandles; 367484"];
3897 [label="genericParameterHandles 367485"];
3898 [label="ushort arity; 367486"];
3899 [label="BadImageFormatException mrEx = null; 367487"];
3900 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367488"];
3901 [label="param GetGenericInfo(out ushort arity) 367489"];
3902 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367490"];
3903 [label="mrEx = null; 367491"];
3904 [label="bool mangleName; 367492"];
3905 [label="PENamedTypeSymbol result; 367493"];
3906 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 367494"];
3907 [label="mangleName 367495"];
3908 [label="param PENamedTypeSymbol(out bool mangleName) 367496"];
3909 [label="_lazyTupleData 367497"];
3910 [label="_container 367498"];
3911 [label="_name 367499"];
3912 [label="_flags 367500"];
3913 [label="_corTypeId 367501"];
3914 [label="Debug.Assert(!handle.IsNil); 367502"];
3915 [label="Debug.Assert((object)container != null); 367503"];
3916 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367504"];
3917 [label="string metadataName; 367505"];
3918 [label="bool makeBad = false; 367506"];
3919 [label="mangleName = false; 367507"];
3920 [label="Accessibility access = Accessibility.Private; 367508"];
3921 [label="access = Accessibility.Public; 367509"];
3922 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 367510"];
3923 [label="_corTypeId 367511"];
3924 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367512"];
3925 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367513"];
3926 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367514"];
3927 [label="GenericParameterHandleCollection genericParameterHandles; 367515"];
3928 [label="genericParameterHandles 367516"];
3929 [label="ushort arity; 367517"];
3930 [label="BadImageFormatException mrEx = null; 367518"];
3931 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367519"];
3932 [label="param GetGenericInfo(out ushort arity) 367520"];
3933 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367521"];
3934 [label="mrEx = null; 367522"];
3935 [label="PENamedTypeSymbol result; 367523"];
3936 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 367524"];
3937 [label="mangleName 367525"];
3938 [label="param PENamedTypeSymbol(out bool mangleName) 367526"];
3939 [label="_lazyTupleData 367527"];
3940 [label="_container 367528"];
3941 [label="_name 367529"];
3942 [label="_flags 367530"];
3943 [label="_corTypeId 367531"];
3944 [label="Debug.Assert(!handle.IsNil); 367532"];
3945 [label="Debug.Assert((object)container != null); 367533"];
3946 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367534"];
3947 [label="string metadataName; 367535"];
3948 [label="bool makeBad = false; 367536"];
3949 [label="mangleName = false; 367537"];
3950 [label="Accessibility access = Accessibility.Private; 367538"];
3951 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367539"];
3952 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367540"];
3953 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367541"];
3954 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 367542"];
3955 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 367543"];
3956 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 367544"];
3957 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 367545"];
3958 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 367546"];
3959 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 367547"];
3960 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 367548"];
3961 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 367549"];
3962 [label="param PENamedTypeSymbolGeneric(ushort arity) 367550"];
3963 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 367551"];
3964 [label="param PENamedTypeSymbolGeneric(this) 367552"];
3965 [label="moduleSymbol 367553"];
3966 [label="container 367554"];
3967 [label="handle 367555"];
3968 [label="emittedNamespaceName 367556"];
3969 [label="arity 367557"];
3970 [label="mangleName 367558"];
3971 [label="param PENamedTypeSymbolGeneric(this) 367559"];
3972 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 367560"];
3973 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 367561"];
3974 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 367562"];
3975 [label="param PENamedTypeSymbol(string emittedNamespaceName) 367563"];
3976 [label="param PENamedTypeSymbol(ushort arity) 367564"];
3977 [label="param PENamedTypeSymbol(out bool mangleName) 367565"];
3978 [label="_lazyTupleData 367566"];
3979 [label="_container 367567"];
3980 [label="_name 367568"];
3981 [label="_flags 367569"];
3982 [label="_corTypeId 367570"];
3983 [label="Debug.Assert(!handle.IsNil); 367571"];
3984 [label="Debug.Assert((object)container != null); 367572"];
3985 [label="Debug.Assert((object)container != null); 367573"];
3986 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367574"];
3987 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367575"];
3988 [label="string metadataName; 367576"];
3989 [label="bool makeBad = false; 367577"];
3990 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 367578"];
3991 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 367579"];
3992 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 367580"];
3993 [label="_name 367581"];
3994 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367582"];
3995 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367583"];
3996 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367584"];
3997 [label="mangleName = !ReferenceEquals(_name, metadataName); 367585"];
3998 [label="mangleName = !ReferenceEquals(_name, metadataName); 367586"];
3999 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 367587"];
4000 [label="Accessibility access = Accessibility.Private; 367588"];
4001 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367589"];
4002 [label="_arity 367590"];
4003 [label="_mangleName 367591"];
4004 [label="Debug.Assert(genericParameterHandles.Count > 0); 367592"];
4005 [label="Debug.Assert(genericParameterHandles.Count > 0); 367593"];
4006 [label="_arity 367594"];
4007 [label="_genericParameterHandles 367595"];
4008 [label="_mangleName 367596"];
4009 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 367597"];
4010 [label="genericParameterHandles 367598"];
4011 [label="ushort arity; 367599"];
4012 [label="BadImageFormatException mrEx = null; 367600"];
4013 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367601"];
4014 [label="param GetGenericInfo(out ushort arity) 367602"];
4015 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367603"];
4016 [label="mrEx = null; 367604"];
4017 [label="PENamedTypeSymbol result; 367605"];
4018 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 367606"];
4019 [label="mangleName 367607"];
4020 [label="param PENamedTypeSymbol(out bool mangleName) 367608"];
4021 [label="_lazyTupleData 367609"];
4022 [label="_container 367610"];
4023 [label="_name 367611"];
4024 [label="_flags 367612"];
4025 [label="_corTypeId 367613"];
4026 [label="Debug.Assert(!handle.IsNil); 367614"];
4027 [label="Debug.Assert((object)container != null); 367615"];
4028 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367616"];
4029 [label="string metadataName; 367617"];
4030 [label="bool makeBad = false; 367618"];
4031 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367619"];
4032 [label="Accessibility access = Accessibility.Private; 367620"];
4033 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367621"];
4034 [label="_arity 367622"];
4035 [label="_mangleName 367623"];
4036 [label="Debug.Assert(genericParameterHandles.Count > 0); 367624"];
4037 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367625"];
4038 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367626"];
4039 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367627"];
4040 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 367628"];
4041 [label="mangleName 367629"];
4042 [label="param PENamedTypeSymbol(out bool mangleName) 367630"];
4043 [label="_lazyTupleData 367631"];
4044 [label="_container 367632"];
4045 [label="_name 367633"];
4046 [label="_flags 367634"];
4047 [label="_corTypeId 367635"];
4048 [label="Debug.Assert(!handle.IsNil); 367636"];
4049 [label="Debug.Assert((object)container != null); 367637"];
4050 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367638"];
4051 [label="string metadataName; 367639"];
4052 [label="bool makeBad = false; 367640"];
4053 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367641"];
4054 [label="Accessibility access = Accessibility.Private; 367642"];
4055 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367643"];
4056 [label="_arity 367644"];
4057 [label="_mangleName 367645"];
4058 [label="Debug.Assert(genericParameterHandles.Count > 0); 367646"];
4059 [label="genericParameterHandles 367647"];
4060 [label="BadImageFormatException mrEx = null; 367648"];
4061 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367649"];
4062 [label="param GetGenericInfo(out ushort arity) 367650"];
4063 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367651"];
4064 [label="mrEx = null; 367652"];
4065 [label="PENamedTypeSymbol result; 367653"];
4066 [label="Debug.Assert(!handle.IsNil); 367654"];
4067 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367655"];
4068 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367656"];
4069 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367657"];
4070 [label="param GetGenericInfo(out ushort arity) 367658"];
4071 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 367659"];
4072 [label="mangleName 367660"];
4073 [label="param PENamedTypeSymbol(out bool mangleName) 367661"];
4074 [label="_lazyTupleData 367662"];
4075 [label="_container 367663"];
4076 [label="_name 367664"];
4077 [label="_flags 367665"];
4078 [label="_corTypeId 367666"];
4079 [label="Debug.Assert(!handle.IsNil); 367667"];
4080 [label="Debug.Assert((object)container != null); 367668"];
4081 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367669"];
4082 [label="string metadataName; 367670"];
4083 [label="bool makeBad = false; 367671"];
4084 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 367672"];
4085 [label="Accessibility access = Accessibility.Private; 367673"];
4086 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367674"];
4087 [label="_arity 367675"];
4088 [label="_mangleName 367676"];
4089 [label="Debug.Assert(genericParameterHandles.Count > 0); 367677"];
4090 [label="genericParameterHandles 367678"];
4091 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367679"];
4092 [label="param GetGenericInfo(out ushort arity) 367680"];
4093 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367681"];
4094 [label="mrEx = null; 367682"];
4095 [label="PENamedTypeSymbol result; 367683"];
4096 [label="Debug.Assert(!handle.IsNil); 367684"];
4097 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367685"];
4098 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367686"];
4099 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 367687"];
4100 [label="mangleName 367688"];
4101 [label="param PENamedTypeSymbol(out bool mangleName) 367689"];
4102 [label="mangleName = false; 367690"];
4103 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367691"];
4104 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367692"];
4105 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 367693"];
4106 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 367694"];
4107 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 367695"];
4108 [label="bool added; 367696"];
4109 [label="Debug.Assert(added); 367697"];
4110 [label="type.SpecialType 367698"];
4111 [label="get\n            {\n                return _corTypeId;\n            } 367699"];
4112 [label="return _corTypeId; 367700"];
4113 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 367701"];
4114 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 367702"];
4115 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 367703"];
4116 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 367704"];
4117 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 367705"];
4118 [label="param RegisterDeclaredSpecialType(this) 367706"];
4119 [label="corType.SpecialType 367707"];
4120 [label="get\n            {\n                return _corTypeId;\n            } 367708"];
4121 [label="SpecialType typeId = corType.SpecialType; 367709"];
4122 [label="Debug.Assert(typeId != SpecialType.None); 367710"];
4123 [label="corType.ContainingAssembly 367711"];
4124 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 367712"];
4125 [label="this.ContainingSymbol 367713"];
4126 [label="get\n            {\n                return _container;\n            } 367714"];
4127 [label="return _container; 367715"];
4128 [label="var container = this.ContainingSymbol; 367716"];
4129 [label="return (object)container != null ? container.ContainingAssembly : null; 367717"];
4130 [label="return (object)container != null ? container.ContainingAssembly : null; 367718"];
4131 [label="(object)container != null 367719"];
4132 [label="container.ContainingAssembly 367720"];
4133 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 367721"];
4134 [label="ContainingPEModule 367722"];
4135 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367723"];
4136 [label="return ContainingPEModule.ContainingAssembly; 367724"];
4137 [label="ContainingPEModule.ContainingAssembly 367725"];
4138 [label="get\n            {\n                return _assemblySymbol;\n            } 367726"];
4139 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367727"];
4140 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367728"];
4141 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367729"];
4142 [label="corType.ContainingModule 367730"];
4143 [label="get\n            {\n                return ContainingPEModule;\n            } 367731"];
4144 [label="ContainingPEModule 367732"];
4145 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 367733"];
4146 [label="Symbol s = _container; 367734"];
4147 [label="s.Kind 367735"];
4148 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367736"];
4149 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 367737"];
4150 [label="((PENamespaceSymbol)s).ContainingPEModule 367738"];
4151 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367739"];
4152 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 367740"];
4153 [label="return ContainingPEModule; 367741"];
4154 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367742"];
4155 [label="corType.ContainingModule.Ordinal 367743"];
4156 [label="get\n            {\n                return _ordinal;\n            } 367744"];
4157 [label="return _ordinal; 367745"];
4158 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367746"];
4159 [label="this.CorLibrary 367747"];
4160 [label="get\n            {\n                return _corLibrary;\n            } 367748"];
4161 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 367749"];
4162 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 367750"];
4163 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 367751"];
4164 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 367752"];
4165 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 367753"];
4166 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 367754"];
4167 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 367755"];
4168 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 367756"];
4169 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 367757"];
4170 [label="Interlocked.Increment(ref _cachedSpecialTypes); 367758"];
4171 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367759"];
4172 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367760"];
4173 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367761"];
4174 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 367762"];
4175 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 367763"];
4176 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 367764"];
4177 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 367765"];
4178 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 367766"];
4179 [label="bool added; 367767"];
4180 [label="Debug.Assert(added); 367768"];
4181 [label="Debug.Assert(typeId != SpecialType.None); 367769"];
4182 [label="corType.ContainingAssembly 367770"];
4183 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 367771"];
4184 [label="this.ContainingSymbol 367772"];
4185 [label="get\n            {\n                return _container;\n            } 367773"];
4186 [label="return _container; 367774"];
4187 [label="var container = this.ContainingSymbol; 367775"];
4188 [label="return (object)container != null ? container.ContainingAssembly : null; 367776"];
4189 [label="return (object)container != null ? container.ContainingAssembly : null; 367777"];
4190 [label="(object)container != null 367778"];
4191 [label="container.ContainingAssembly 367779"];
4192 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 367780"];
4193 [label="ContainingPEModule 367781"];
4194 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367782"];
4195 [label="return ContainingPEModule.ContainingAssembly; 367783"];
4196 [label="ContainingPEModule.ContainingAssembly 367784"];
4197 [label="get\n            {\n                return _assemblySymbol;\n            } 367785"];
4198 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367786"];
4199 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367787"];
4200 [label="corType.ContainingModule 367788"];
4201 [label="get\n            {\n                return ContainingPEModule;\n            } 367789"];
4202 [label="ContainingPEModule 367790"];
4203 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 367791"];
4204 [label="Symbol s = _container; 367792"];
4205 [label="s.Kind 367793"];
4206 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367794"];
4207 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 367795"];
4208 [label="((PENamespaceSymbol)s).ContainingPEModule 367796"];
4209 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367797"];
4210 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 367798"];
4211 [label="return ContainingPEModule; 367799"];
4212 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367800"];
4213 [label="corType.ContainingModule.Ordinal 367801"];
4214 [label="get\n            {\n                return _ordinal;\n            } 367802"];
4215 [label="return _ordinal; 367803"];
4216 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367804"];
4217 [label="this.CorLibrary 367805"];
4218 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 367806"];
4219 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 367807"];
4220 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367808"];
4221 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367809"];
4222 [label="bool added; 367810"];
4223 [label="Debug.Assert(added); 367811"];
4224 [label="Debug.Assert(typeId != SpecialType.None); 367812"];
4225 [label="corType.ContainingAssembly 367813"];
4226 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 367814"];
4227 [label="this.ContainingSymbol 367815"];
4228 [label="get\n            {\n                return _container;\n            } 367816"];
4229 [label="return _container; 367817"];
4230 [label="var container = this.ContainingSymbol; 367818"];
4231 [label="return (object)container != null ? container.ContainingAssembly : null; 367819"];
4232 [label="return (object)container != null ? container.ContainingAssembly : null; 367820"];
4233 [label="(object)container != null 367821"];
4234 [label="container.ContainingAssembly 367822"];
4235 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 367823"];
4236 [label="ContainingPEModule 367824"];
4237 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367825"];
4238 [label="return ContainingPEModule.ContainingAssembly; 367826"];
4239 [label="ContainingPEModule.ContainingAssembly 367827"];
4240 [label="get\n            {\n                return _assemblySymbol;\n            } 367828"];
4241 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367829"];
4242 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367830"];
4243 [label="corType.ContainingModule 367831"];
4244 [label="get\n            {\n                return ContainingPEModule;\n            } 367832"];
4245 [label="ContainingPEModule 367833"];
4246 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 367834"];
4247 [label="Symbol s = _container; 367835"];
4248 [label="s.Kind 367836"];
4249 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367837"];
4250 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 367838"];
4251 [label="((PENamespaceSymbol)s).ContainingPEModule 367839"];
4252 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367840"];
4253 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 367841"];
4254 [label="return ContainingPEModule; 367842"];
4255 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367843"];
4256 [label="corType.ContainingModule.Ordinal 367844"];
4257 [label="get\n            {\n                return _ordinal;\n            } 367845"];
4258 [label="return _ordinal; 367846"];
4259 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367847"];
4260 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 367848"];
4261 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367849"];
4262 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 367850"];
4263 [label="bool added; 367851"];
4264 [label="Debug.Assert(added); 367852"];
4265 [label="return _container; 367853"];
4266 [label="var container = this.ContainingSymbol; 367854"];
4267 [label="return (object)container != null ? container.ContainingAssembly : null; 367855"];
4268 [label="(object)container != null 367856"];
4269 [label="container.ContainingAssembly 367857"];
4270 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 367858"];
4271 [label="ContainingPEModule 367859"];
4272 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367860"];
4273 [label="return ContainingPEModule.ContainingAssembly; 367861"];
4274 [label="ContainingPEModule.ContainingAssembly 367862"];
4275 [label="get\n            {\n                return _assemblySymbol;\n            } 367863"];
4276 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 367864"];
4277 [label="Symbol s = _container; 367865"];
4278 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367866"];
4279 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 367867"];
4280 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 367868"];
4281 [label="return ContainingPEModule; 367869"];
4282 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 367870"];
4283 [label="get\n            {\n                return _ordinal;\n            } 367871"];
4284 [label="return _ordinal; 367872"];
4285 [label="LoadAllMembers(typesByNS); 367873"];
4286 [label="Interlocked.Exchange(ref _typesByNS, null); 367874"];
4287 [label="Interlocked.Exchange(ref _typesByNS, null); 367875"];
4288 [label="EnsureAllMembersLoaded(); 367876"];
4289 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 367877"];
4290 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367878"];
4291 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367879"];
4292 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 367880"];
4293 [label="Debug.Assert(typesByNS != null); 367881"];
4294 [label="get\n            {\n                return false;\n            } 367882"];
4295 [label="ContainingNamespace 367883"];
4296 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 367884"];
4297 [label="this.ContainingSymbol 367885"];
4298 [label="get { return _containingNamespaceSymbol; } 367886"];
4299 [label="return _containingNamespaceSymbol; 367887"];
4300 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 367888"];
4301 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 367889"];
4302 [label="var ns = container as NamespaceSymbol; 367890"];
4303 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 367891"];
4304 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 367892"];
4305 [label="return ns; 367893"];
4306 [label="var parent = ContainingNamespace; 367894"];
4307 [label=".IsGlobalNamespace 367895"];
4308 [label="get\n            {\n                return false;\n            } 367896"];
4309 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 367897"];
4310 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 367898"];
4311 [label="parent.Name 367899"];
4312 [label="get\n            {\n                return _name;\n            } 367900"];
4313 [label="length += parent.Name.Length + 1; 367901"];
4314 [label="length += parent.Name.Length + 1; 367902"];
4315 [label="parent.ContainingNamespace 367903"];
4316 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 367904"];
4317 [label="this.ContainingSymbol 367905"];
4318 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 367906"];
4319 [label="parent = parent.ContainingNamespace; 367907"];
4320 [label="get\n            {\n                return true;\n            } 367908"];
4321 [label="_containingNamespaceSymbol 367909"];
4322 [label="_name 367910"];
4323 [label="_typesByNS 367911"];
4324 [label="Debug.Assert(name != null); 367912"];
4325 [label="Debug.Assert((object)containingNamespace != null); 367913"];
4326 [label="Debug.Assert(typesByNS != null); 367914"];
4327 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 367915"];
4328 [label="genericParameterHandles 367916"];
4329 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 367917"];
4330 [label="param GetGenericInfo(out ushort arity) 367918"];
4331 [label="param GetGenericInfo(out BadImageFormatException mrEx) 367919"];
4332 [label="mrEx = null; 367920"];
4333 [label="PENamedTypeSymbol result; 367921"];
4334 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 367922"];
4335 [label="mangleName 367923"];
4336 [label="param PENamedTypeSymbol(out bool mangleName) 367924"];
4337 [label="_lazyTupleData 367925"];
4338 [label="_container 367926"];
4339 [label="_name 367927"];
4340 [label="_flags 367928"];
4341 [label="_corTypeId 367929"];
4342 [label="Debug.Assert(!handle.IsNil); 367930"];
4343 [label="Debug.Assert((object)container != null); 367931"];
4344 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 367932"];
4345 [label="string metadataName; 367933"];
4346 [label="bool makeBad = false; 367934"];
4347 [label="mangleName = false; 367935"];
4348 [label="Accessibility access = Accessibility.Private; 367936"];
4349 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 367937"];
4350 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367938"];
4351 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 367939"];
4352 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367940"];
4353 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 367941"];
4354 [label="bool added; 367942"];
4355 [label="Debug.Assert(added); 367943"];
4356 [label="EnsureAllMembersLoaded(); 367944"];
4357 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 367945"];
4358 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367946"];
4359 [label="if ((object)scope == null)\n                {\n                    break;\n                } 367947"];
4360 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 367948"];
4361 [label="result = scope.LookupMetadataType(ref emittedName); 367949"];
4362 [label="scope.LookupMetadataType(ref emittedName) 367950"];
4363 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 367951"];
4364 [label="param LookupMetadataType(this) 367952"];
4365 [label="Debug.Assert(!emittedTypeName.IsNull); 367953"];
4366 [label="NamespaceOrTypeSymbol scope = this; 367954"];
4367 [label="scope.Kind 367955"];
4368 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367956"];
4369 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 367957"];
4370 [label="NamedTypeSymbol? namedType = null; 367958"];
4371 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 367959"];
4372 [label="namespaceOrTypeMembers 367960"];
4373 [label="scope.IsNamespace 367961"];
4374 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 367962"];
4375 [label="Kind 367963"];
4376 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 367964"];
4377 [label="return Kind == SymbolKind.Namespace; 367965"];
4378 [label="bool isTopLevel = scope.IsNamespace; 367966"];
4379 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 367967"];
4380 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 367968"];
4381 [label="param ToDisplayString(SymbolDisplayFormat format = null) 367969"];
4382 [label="param ToDisplayString(this) 367970"];
4383 [label="ISymbol 367971"];
4384 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 367972"];
4385 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 367973"];
4386 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 367974"];
4387 [label="CreateISymbol() 367975"];
4388 [label="param CreateISymbol(this) 367976"];
4389 [label="return new PublicModel.NamespaceSymbol(this); 367977"];
4390 [label="return new PublicModel.NamespaceSymbol(this); 367978"];
4391 [label="new PublicModel.NamespaceSymbol(this) 367979"];
4392 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 367980"];
4393 [label="param NamespaceSymbol(this) 367981"];
4394 [label="param NamespaceSymbol(this) 367982"];
4395 [label="param NamespaceOrTypeSymbol(this) 367983"];
4396 [label="param NamespaceOrTypeSymbol(this) 367984"];
4397 [label="param Symbol(this) 367985"];
4398 [label="_underlying 367986"];
4399 [label="Debug.Assert(underlying is object); 367987"];
4400 [label="_underlying 367988"];
4401 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 367989"];
4402 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 367990"];
4403 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 367991"];
4404 [label="return _lazyISymbol; 367992"];
4405 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 367993"];
4406 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 367994"];
4407 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 367995"];
4408 [label="param ToDisplayString(ISymbol symbol) 367996"];
4409 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 367997"];
4410 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 367998"];
4411 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 367999"];
4412 [label="ToDisplayParts(symbol, format) 368000"];
4413 [label="param ToDisplayParts(ISymbol symbol) 368001"];
4414 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 368002"];
4415 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 368003"];
4416 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 368004"];
4417 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 368005"];
4418 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 368006"];
4419 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 368007"];
4420 [label="param ToDisplayParts(ISymbol symbol) 368008"];
4421 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 368009"];
4422 [label="param ToDisplayParts(int positionOpt) 368010"];
4423 [label="param ToDisplayParts(SymbolDisplayFormat format) 368011"];
4424 [label="param ToDisplayParts(bool minimal) 368012"];
4425 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 368013"];
4426 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 368014"];
4427 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 368015"];
4428 [label="Debug.Assert(semanticModelOpt == null); 368016"];
4429 [label="Debug.Assert(semanticModelOpt == null); 368017"];
4430 [label="Debug.Assert(positionOpt < 0); 368018"];
4431 [label="Debug.Assert(positionOpt < 0); 368019"];
4432 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 368020"];
4433 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 368021"];
4434 [label="'modopt' 368022"];
4435 [label="IL_KEYWORD_MODOPT = 'modopt' 368023"];
4436 [label="'modreq' 368024"];
4437 [label="IL_KEYWORD_MODREQ = 'modreq' 368025"];
4438 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 368026"];
4439 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 368027"];
4440 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 368028"];
4441 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 368029"];
4442 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 368030"];
4443 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 368031"];
4444 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 368032"];
4445 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 368033"];
4446 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 368034"];
4447 [label="param SymbolDisplayVisitor(int positionOpt) 368035"];
4448 [label="param SymbolDisplayVisitor(this) 368036"];
4449 [label="builder 368037"];
4450 [label="format 368038"];
4451 [label="true 368039"];
4452 [label="semanticModelOpt 368040"];
4453 [label="positionOpt 368041"];
4454 [label="param SymbolDisplayVisitor(this) 368042"];
4455 [label="param SymbolDisplayVisitor(this) 368043"];
4456 [label="_escapeKeywordIdentifiers 368044"];
4457 [label="_lazyAliasMap 368045"];
4458 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 368046"];
4459 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 368047"];
4460 [label="_escapeKeywordIdentifiers 368048"];
4461 [label="symbol.Accept(visitor); 368049"];
4462 [label="symbol.Accept(visitor) 368050"];
4463 [label="param Accept(SymbolVisitor visitor) 368051"];
4464 [label="param Accept(this) 368052"];
4465 [label="Accept(visitor); 368053"];
4466 [label="Accept(visitor) 368054"];
4467 [label="param Accept(SymbolVisitor visitor) 368055"];
4468 [label="param Accept(this) 368056"];
4469 [label="visitor.VisitNamespace(this); 368057"];
4470 [label="visitor.VisitNamespace(this) 368058"];
4471 [label="param VisitNamespace(INamespaceSymbol symbol) 368059"];
4472 [label="param VisitNamespace(this) 368060"];
4473 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 368061"];
4474 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368062"];
4475 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368063"];
4476 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 368064"];
4477 [label="symbol.ContainingNamespace 368065"];
4478 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 368066"];
4479 [label="UnderlyingSymbol 368067"];
4480 [label="=> _underlying 368068"];
4481 [label="_underlying 368069"];
4482 [label="UnderlyingSymbol.ContainingNamespace 368070"];
4483 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 368071"];
4484 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 368072"];
4485 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 368073"];
4486 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 368074"];
4487 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 368075"];
4488 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 368076"];
4489 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 368077"];
4490 [label="param GetPublicSymbol(this Symbol? symbol) 368078"];
4491 [label=".ISymbol 368079"];
4492 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 368080"];
4493 [label="param NamespaceOrTypeSymbol(this) 368081"];
4494 [label="param Symbol(this) 368082"];
4495 [label="_underlying 368083"];
4496 [label="Debug.Assert(underlying is object); 368084"];
4497 [label="return (TISymbol?)symbol?.ISymbol; 368085"];
4498 [label="var containingNamespace = symbol.ContainingNamespace; 368086"];
4499 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 368087"];
4500 [label="ShouldVisitNamespace(containingNamespace) 368088"];
4501 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 368089"];
4502 [label="param ShouldVisitNamespace(this) 368090"];
4503 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 368091"];
4504 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368092"];
4505 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368093"];
4506 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 368094"];
4507 [label="namespaceSymbol.IsGlobalNamespace 368095"];
4508 [label="=> _underlying.IsGlobalNamespace 368096"];
4509 [label="_underlying.IsGlobalNamespace 368097"];
4510 [label="get\n            {\n                return false;\n            } 368098"];
4511 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 368099"];
4512 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 368100"];
4513 [label="containingNamespace.Accept(this.NotFirstVisitor); 368101"];
4514 [label="this.NotFirstVisitor 368102"];
4515 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 368103"];
4516 [label="param MakeNotFirstVisitor(this) 368104"];
4517 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 368105"];
4518 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 368106"];
4519 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 368107"];
4520 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 368108"];
4521 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 368109"];
4522 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 368110"];
4523 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 368111"];
4524 [label="param SymbolDisplayVisitor(int positionOpt) 368112"];
4525 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 368113"];
4526 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 368114"];
4527 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 368115"];
4528 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 368116"];
4529 [label="param SymbolDisplayVisitor(this) 368117"];
4530 [label="builder 368118"];
4531 [label="format 368119"];
4532 [label="isFirstSymbolVisited 368120"];
4533 [label="semanticModelOpt 368121"];
4534 [label="positionOpt 368122"];
4535 [label="inNamespaceOrType 368123"];
4536 [label="param SymbolDisplayVisitor(this) 368124"];
4537 [label="param SymbolDisplayVisitor(this) 368125"];
4538 [label="_escapeKeywordIdentifiers 368126"];
4539 [label="_lazyAliasMap 368127"];
4540 [label="containingNamespace.Accept(this.NotFirstVisitor); 368128"];
4541 [label="containingNamespace.Accept(this.NotFirstVisitor); 368129"];
4542 [label="containingNamespace.Accept(this.NotFirstVisitor) 368130"];
4543 [label="param Accept(SymbolVisitor visitor) 368131"];
4544 [label="param Accept(this) 368132"];
4545 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 368133"];
4546 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368134"];
4547 [label="symbol.ContainingNamespace 368135"];
4548 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 368136"];
4549 [label="UnderlyingSymbol 368137"];
4550 [label="UnderlyingSymbol.ContainingNamespace 368138"];
4551 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 368139"];
4552 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 368140"];
4553 [label=".ISymbol 368141"];
4554 [label="param NamespaceOrTypeSymbol(this) 368142"];
4555 [label="param Symbol(this) 368143"];
4556 [label="_underlying 368144"];
4557 [label="Debug.Assert(underlying is object); 368145"];
4558 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 368146"];
4559 [label="param ShouldVisitNamespace(this) 368147"];
4560 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 368148"];
4561 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368149"];
4562 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368150"];
4563 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 368151"];
4564 [label="=> _underlying.IsGlobalNamespace 368152"];
4565 [label="get\n            {\n                return false;\n            } 368153"];
4566 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 368154"];
4567 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368155"];
4568 [label="get\n            {\n                return true;\n            } 368156"];
4569 [label="symbol.IsGlobalNamespace 368157"];
4570 [label="=> _underlying.IsGlobalNamespace 368158"];
4571 [label="get\n            {\n                return false;\n            } 368159"];
4572 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 368160"];
4573 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368161"];
4574 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368162"];
4575 [label="symbol.Name 368163"];
4576 [label="=> UnderlyingSymbol.Name 368164"];
4577 [label="UnderlyingSymbol 368165"];
4578 [label="=> _underlying 368166"];
4579 [label="UnderlyingSymbol.Name 368167"];
4580 [label="get\n            {\n                return _name;\n            } 368168"];
4581 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368169"];
4582 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 368170"];
4583 [label="param CreatePart(SymbolDisplayPartKind kind) 368171"];
4584 [label="param CreatePart(ISymbol symbol) 368172"];
4585 [label="param CreatePart(string text) 368173"];
4586 [label="param CreatePart(this) 368174"];
4587 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368175"];
4588 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368176"];
4589 [label="(text == null) 368177"];
4590 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368178"];
4591 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 368179"];
4592 [label="return new SymbolDisplayPart(kind, symbol, text); 368180"];
4593 [label="return new SymbolDisplayPart(kind, symbol, text); 368181"];
4594 [label="return new SymbolDisplayPart(kind, symbol, text); 368182"];
4595 [label="return new SymbolDisplayPart(kind, symbol, text); 368183"];
4596 [label="visitor.VisitNamespace(this); 368184"];
4597 [label="containingNamespace.IsGlobalNamespace 368185"];
4598 [label="=> _underlying.IsGlobalNamespace 368186"];
4599 [label="get\n            {\n                return false;\n            } 368187"];
4600 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 368188"];
4601 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 368189"];
4602 [label="param AddPunctuation(SyntaxKind punctuationKind) 368190"];
4603 [label="param AddPunctuation(this) 368191"];
4604 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368192"];
4605 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368193"];
4606 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368194"];
4607 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 368195"];
4608 [label="param CreatePart(SymbolDisplayPartKind kind) 368196"];
4609 [label="param CreatePart(ISymbol symbol) 368197"];
4610 [label="param CreatePart(string text) 368198"];
4611 [label="param CreatePart(this) 368199"];
4612 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368200"];
4613 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368201"];
4614 [label="(text == null) 368202"];
4615 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368203"];
4616 [label="return new SymbolDisplayPart(kind, symbol, text); 368204"];
4617 [label="return new SymbolDisplayPart(kind, symbol, text); 368205"];
4618 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 368206"];
4619 [label="symbol.IsGlobalNamespace 368207"];
4620 [label="=> _underlying.IsGlobalNamespace 368208"];
4621 [label="get\n            {\n                return false;\n            } 368209"];
4622 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 368210"];
4623 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368211"];
4624 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368212"];
4625 [label="symbol.Name 368213"];
4626 [label="=> UnderlyingSymbol.Name 368214"];
4627 [label="UnderlyingSymbol 368215"];
4628 [label="=> _underlying 368216"];
4629 [label="UnderlyingSymbol.Name 368217"];
4630 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 368218"];
4631 [label="param CreatePart(SymbolDisplayPartKind kind) 368219"];
4632 [label="param CreatePart(ISymbol symbol) 368220"];
4633 [label="param CreatePart(this) 368221"];
4634 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368222"];
4635 [label="return new SymbolDisplayPart(kind, symbol, text); 368223"];
4636 [label="return new SymbolDisplayPart(kind, symbol, text); 368224"];
4637 [label="visitor.VisitNamespace(this); 368225"];
4638 [label="containingNamespace.Accept(this.NotFirstVisitor); 368226"];
4639 [label="containingNamespace.IsGlobalNamespace 368227"];
4640 [label="=> _underlying.IsGlobalNamespace 368228"];
4641 [label="get\n            {\n                return false;\n            } 368229"];
4642 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 368230"];
4643 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 368231"];
4644 [label="param AddPunctuation(SyntaxKind punctuationKind) 368232"];
4645 [label="param AddPunctuation(this) 368233"];
4646 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368234"];
4647 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368235"];
4648 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 368236"];
4649 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 368237"];
4650 [label="param CreatePart(SymbolDisplayPartKind kind) 368238"];
4651 [label="param CreatePart(ISymbol symbol) 368239"];
4652 [label="param CreatePart(string text) 368240"];
4653 [label="param CreatePart(this) 368241"];
4654 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368242"];
4655 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368243"];
4656 [label="(text == null) 368244"];
4657 [label="return new SymbolDisplayPart(kind, symbol, text); 368245"];
4658 [label="return new SymbolDisplayPart(kind, symbol, text); 368246"];
4659 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 368247"];
4660 [label="symbol.IsGlobalNamespace 368248"];
4661 [label="=> _underlying.IsGlobalNamespace 368249"];
4662 [label="_underlying.IsGlobalNamespace 368250"];
4663 [label="get\n            {\n                return false;\n            } 368251"];
4664 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 368252"];
4665 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368253"];
4666 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 368254"];
4667 [label="symbol.Name 368255"];
4668 [label="=> UnderlyingSymbol.Name 368256"];
4669 [label="UnderlyingSymbol 368257"];
4670 [label="=> _underlying 368258"];
4671 [label="UnderlyingSymbol.Name 368259"];
4672 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 368260"];
4673 [label="param CreatePart(SymbolDisplayPartKind kind) 368261"];
4674 [label="param CreatePart(ISymbol symbol) 368262"];
4675 [label="param CreatePart(this) 368263"];
4676 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 368264"];
4677 [label="return new SymbolDisplayPart(kind, symbol, text); 368265"];
4678 [label="return new SymbolDisplayPart(kind, symbol, text); 368266"];
4679 [label="visitor.VisitNamespace(this); 368267"];
4680 [label="Accept(visitor); 368268"];
4681 [label="symbol.Accept(visitor); 368269"];
4682 [label="return builder.ToImmutableAndFree(); 368270"];
4683 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 368271"];
4684 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 368272"];
4685 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 368273"];
4686 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368274"];
4687 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368275"];
4688 [label="int forcedArity = emittedTypeName.ForcedArity; 368276"];
4689 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 368277"];
4690 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 368278"];
4691 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 368279"];
4692 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 368280"];
4693 [label="forcedArity = 0; 368281"];
4694 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 368282"];
4695 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 368283"];
4696 [label="param GetTypeMembers(string name) 368284"];
4697 [label="param GetTypeMembers(this) 368285"];
4698 [label="EnsureAllMembersLoaded() 368286"];
4699 [label="param EnsureAllMembersLoaded(this) 368287"];
4700 [label="var typesByNS = _typesByNS; 368288"];
4701 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 368289"];
4702 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 368290"];
4703 [label="Debug.Assert(typesByNS != null); 368291"];
4704 [label="get\n            {\n                return false;\n            } 368292"];
4705 [label="parent.ContainingNamespace 368293"];
4706 [label="parent = parent.ContainingNamespace; 368294"];
4707 [label="get\n            {\n                return false;\n            } 368295"];
4708 [label="get\n            {\n                return true;\n            } 368296"];
4709 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 368297"];
4710 [label="genericParameterHandles 368298"];
4711 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 368299"];
4712 [label="param GetGenericInfo(out ushort arity) 368300"];
4713 [label="param GetGenericInfo(out BadImageFormatException mrEx) 368301"];
4714 [label="mrEx = null; 368302"];
4715 [label="PENamedTypeSymbol result; 368303"];
4716 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 368304"];
4717 [label="mangleName 368305"];
4718 [label="param PENamedTypeSymbol(out bool mangleName) 368306"];
4719 [label="_lazyTupleData 368307"];
4720 [label="_container 368308"];
4721 [label="_name 368309"];
4722 [label="_flags 368310"];
4723 [label="_corTypeId 368311"];
4724 [label="Debug.Assert(!handle.IsNil); 368312"];
4725 [label="Debug.Assert((object)container != null); 368313"];
4726 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 368314"];
4727 [label="string metadataName; 368315"];
4728 [label="bool makeBad = false; 368316"];
4729 [label="mangleName = false; 368317"];
4730 [label="Accessibility access = Accessibility.Private; 368318"];
4731 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 368319"];
4732 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368320"];
4733 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368321"];
4734 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 368322"];
4735 [label="mangleName 368323"];
4736 [label="param PENamedTypeSymbol(out bool mangleName) 368324"];
4737 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 368325"];
4738 [label="_arity 368326"];
4739 [label="_mangleName 368327"];
4740 [label="Debug.Assert(genericParameterHandles.Count > 0); 368328"];
4741 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368329"];
4742 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368330"];
4743 [label="bool added; 368331"];
4744 [label="Debug.Assert(added); 368332"];
4745 [label="Debug.Assert(typeId != SpecialType.None); 368333"];
4746 [label="corType.ContainingAssembly 368334"];
4747 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 368335"];
4748 [label="this.ContainingSymbol 368336"];
4749 [label="get\n            {\n                return _container;\n            } 368337"];
4750 [label="return _container; 368338"];
4751 [label="var container = this.ContainingSymbol; 368339"];
4752 [label="return (object)container != null ? container.ContainingAssembly : null; 368340"];
4753 [label="return (object)container != null ? container.ContainingAssembly : null; 368341"];
4754 [label="(object)container != null 368342"];
4755 [label="container.ContainingAssembly 368343"];
4756 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 368344"];
4757 [label="ContainingPEModule 368345"];
4758 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368346"];
4759 [label="return ContainingPEModule.ContainingAssembly; 368347"];
4760 [label="ContainingPEModule.ContainingAssembly 368348"];
4761 [label="get\n            {\n                return _assemblySymbol;\n            } 368349"];
4762 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 368350"];
4763 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 368351"];
4764 [label="corType.ContainingModule 368352"];
4765 [label="get\n            {\n                return ContainingPEModule;\n            } 368353"];
4766 [label="ContainingPEModule 368354"];
4767 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 368355"];
4768 [label="Symbol s = _container; 368356"];
4769 [label="s.Kind 368357"];
4770 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368358"];
4771 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 368359"];
4772 [label="((PENamespaceSymbol)s).ContainingPEModule 368360"];
4773 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368361"];
4774 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 368362"];
4775 [label="return ContainingPEModule; 368363"];
4776 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 368364"];
4777 [label="corType.ContainingModule.Ordinal 368365"];
4778 [label="get\n            {\n                return _ordinal;\n            } 368366"];
4779 [label="return _ordinal; 368367"];
4780 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 368368"];
4781 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 368369"];
4782 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 368370"];
4783 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 368371"];
4784 [label="EnsureAllMembersLoaded(); 368372"];
4785 [label="ImmutableArray<PENamedTypeSymbol> t; 368373"];
4786 [label="t 368374"];
4787 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 368375"];
4788 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 368376"];
4789 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 368377"];
4790 [label="lazyTypes.TryGetValue(name, out t) 368378"];
4791 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 368379"];
4792 [label="named.MangleName 368380"];
4793 [label="get\n                {\n                    return false;\n                } 368381"];
4794 [label="return false; 368382"];
4795 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368383"];
4796 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368384"];
4797 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368385"];
4798 [label="named.Arity 368386"];
4799 [label="get\n                {\n                    return 0;\n                } 368387"];
4800 [label="return 0; 368388"];
4801 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368389"];
4802 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368390"];
4803 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 368391"];
4804 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 368392"];
4805 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 368393"];
4806 [label="namedType = named; 368394"];
4807 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 368395"];
4808 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 368396"];
4809 [label="return namedType; 368397"];
4810 [label="Debug.Assert((object)result != null); 368398"];
4811 [label="Debug.Assert((object)result != null); 368399"];
4812 [label="return result; 368400"];
4813 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 368401"];
4814 [label="bool foundMatchInThisAssembly = (i < count); 368402"];
4815 [label="result.ContainingAssembly 368403"];
4816 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 368404"];
4817 [label="this.ContainingSymbol 368405"];
4818 [label="get\n            {\n                return _container;\n            } 368406"];
4819 [label="return _container; 368407"];
4820 [label="var container = this.ContainingSymbol; 368408"];
4821 [label="return (object)container != null ? container.ContainingAssembly : null; 368409"];
4822 [label="return (object)container != null ? container.ContainingAssembly : null; 368410"];
4823 [label="(object)container != null 368411"];
4824 [label="container.ContainingAssembly 368412"];
4825 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 368413"];
4826 [label="ContainingPEModule 368414"];
4827 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368415"];
4828 [label="return ContainingPEModule.ContainingAssembly; 368416"];
4829 [label="ContainingPEModule.ContainingAssembly 368417"];
4830 [label="get\n            {\n                return _assemblySymbol;\n            } 368418"];
4831 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 368419"];
4832 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 368420"];
4833 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 368421"];
4834 [label="System.Diagnostics.Debug.Assert((object)result != null); 368422"];
4835 [label="System.Diagnostics.Debug.Assert((object)result != null); 368423"];
4836 [label="if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                } 368424"];
4837 [label="CacheTopLevelMetadataType(ref emittedName, result); 368425"];
4838 [label="CacheTopLevelMetadataType(ref emittedName, result); 368426"];
4839 [label="CacheTopLevelMetadataType(ref emittedName, result) 368427"];
4840 [label="param CacheTopLevelMetadataType(ref MetadataTypeName emittedName) 368428"];
4841 [label="param CacheTopLevelMetadataType(NamedTypeSymbol result) 368429"];
4842 [label="param CacheTopLevelMetadataType(this) 368430"];
4843 [label="NamedTypeSymbol result1 = null; 368431"];
4844 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 368432"];
4845 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 368433"];
4846 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 368434"];
4847 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 368435"];
4848 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 368436"];
4849 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 368437"];
4850 [label="TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2) 368438"];
4851 [label="param Equals(TypeSymbol left) 368439"];
4852 [label="param Equals(TypeSymbol right) 368440"];
4853 [label="param Equals(TypeCompareKind comparison) 368441"];
4854 [label="if (left is null)\n            {\n                return right is null;\n            } 368442"];
4855 [label="return left.Equals(right, comparison); 368443"];
4856 [label="return left.Equals(right, comparison); 368444"];
4857 [label="left.Equals(right, comparison) 368445"];
4858 [label="param Equals(TypeSymbol t2) 368446"];
4859 [label="param Equals(TypeCompareKind comparison) 368447"];
4860 [label="param Equals(this) 368448"];
4861 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 368449"];
4862 [label="t2 is NativeIntegerTypeSymbol nativeInteger 368450"];
4863 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 368451"];
4864 [label="base.Equals(t2, comparison) 368452"];
4865 [label="param Equals(TypeSymbol t2) 368453"];
4866 [label="param Equals(TypeCompareKind comparison) 368454"];
4867 [label="param Equals(this) 368455"];
4868 [label="if ((object)t2 == this) return true; 368456"];
4869 [label="return true; 368457"];
4870 [label="CacheTopLevelMetadataType(ref emittedName, result); 368458"];
4871 [label="return result; 368459"];
4872 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 368460"];
4873 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 368461"];
4874 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 368462"];
4875 [label="candidate.Kind 368463"];
4876 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 368464"];
4877 [label="return SymbolKind.NamedType; 368465"];
4878 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 368466"];
4879 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 368467"];
4880 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 368468"];
4881 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 368469"];
4882 [label="return result; 368470"];
4883 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 368471"];
4884 [label="IsValidWellKnownType(candidate) 368472"];
4885 [label="param IsValidWellKnownType(NamedTypeSymbol result) 368473"];
4886 [label="param IsValidWellKnownType(this) 368474"];
4887 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 368475"];
4888 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 368476"];
4889 [label="result.TypeKind 368477"];
4890 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 368478"];
4891 [label="TypeKind result = _lazyKind; 368479"];
4892 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 368480"];
4893 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 368481"];
4894 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 368482"];
4895 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 368483"];
4896 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 368484"];
4897 [label="param GetDeclaredBaseType(this) 368485"];
4898 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 368486"];
4899 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 368487"];
4900 [label="MakeDeclaredBaseType() 368488"];
4901 [label="param MakeDeclaredBaseType(this) 368489"];
4902 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 368490"];
4903 [label="ContainingPEModule 368491"];
4904 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 368492"];
4905 [label="Symbol s = _container; 368493"];
4906 [label="s.Kind 368494"];
4907 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368495"];
4908 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 368496"];
4909 [label="((PENamespaceSymbol)s).ContainingPEModule 368497"];
4910 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368498"];
4911 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 368499"];
4912 [label="var moduleSymbol = ContainingPEModule; 368500"];
4913 [label="moduleSymbol.Module 368501"];
4914 [label="get\n            {\n                return _module;\n            } 368502"];
4915 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 368503"];
4916 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 368504"];
4917 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 368505"];
4918 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 368506"];
4919 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 368507"];
4920 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 368508"];
4921 [label="new MetadataDecoder(moduleSymbol, this) 368509"];
4922 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 368510"];
4923 [label="param MetadataDecoder(PENamedTypeSymbol context) 368511"];
4924 [label="param MetadataDecoder(this) 368512"];
4925 [label="moduleSymbol 368513"];
4926 [label="context 368514"];
4927 [label="null 368515"];
4928 [label="param MetadataDecoder(this) 368516"];
4929 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 368517"];
4930 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 368518"];
4931 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 368519"];
4932 [label="param MetadataDecoder(this) 368520"];
4933 [label="moduleSymbol.Module 368521"];
4934 [label="get\n            {\n                return _module;\n            } 368522"];
4935 [label="moduleSymbol.ContainingAssembly 368523"];
4936 [label="get\n            {\n                return _assemblySymbol;\n            } 368524"];
4937 [label="(moduleSymbol.ContainingAssembly is PEAssemblySymbol) 368525"];
4938 [label="moduleSymbol.ContainingAssembly 368526"];
4939 [label="moduleSymbol.ContainingAssembly.Identity 368527"];
4940 [label="get\n            {\n                return _assembly.Identity;\n            } 368528"];
4941 [label="return _assembly.Identity; 368529"];
4942 [label="new SymbolFactory() 368530"];
4943 [label="param SymbolFactory(this) 368531"];
4944 [label="Instance = new SymbolFactory() 368532"];
4945 [label="SymbolFactory.Instance 368533"];
4946 [label="moduleSymbol 368534"];
4947 [label="param MetadataDecoder(this) 368535"];
4948 [label="param MetadataDecoder(this) 368536"];
4949 [label="_typeContextOpt 368537"];
4950 [label="_methodContextOpt 368538"];
4951 [label="Debug.Assert((object)moduleSymbol != null); 368539"];
4952 [label="Debug.Assert((object)moduleSymbol != null); 368540"];
4953 [label="_typeContextOpt 368541"];
4954 [label="_methodContextOpt 368542"];
4955 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 368543"];
4956 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 368544"];
4957 [label="param GetTypeHandleToTypeMap(this) 368545"];
4958 [label="return moduleSymbol.TypeHandleToTypeMap; 368546"];
4959 [label="var baseType = MakeDeclaredBaseType(); 368547"];
4960 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 368548"];
4961 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 368549"];
4962 [label="return baseType; 368550"];
4963 [label="result = TypeKind.Class; 368551"];
4964 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 368552"];
4965 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 368553"];
4966 [label="@base.SpecialType 368554"];
4967 [label="SpecialType baseCorTypeId = @base.SpecialType; 368555"];
4968 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 368556"];
4969 [label="_lazyKind 368557"];
4970 [label="return result; 368558"];
4971 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 368559"];
4972 [label="result.ContainingType 368560"];
4973 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 368561"];
4974 [label="return _container as NamedTypeSymbol; 368562"];
4975 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 368563"];
4976 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 368564"];
4977 [label="result.DeclaredAccessibility 368565"];
4978 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 368566"];
4979 [label="Accessibility access = Accessibility.Private; 368567"];
4980 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 368568"];
4981 [label="return result.DeclaredAccessibility == Accessibility.Public || IsSymbolAccessible(result, this); 368569"];
4982 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 368570"];
4983 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 368571"];
4984 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 368572"];
4985 [label="if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                } 368573"];
4986 [label="candidate.IsHiddenByCodeAnalysisEmbeddedAttribute() 368574"];
4987 [label="param IsHiddenByCodeAnalysisEmbeddedAttribute(this Symbol symbol) 368575"];
4988 [label="symbol.Kind 368576"];
4989 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 368577"];
4990 [label="return SymbolKind.NamedType; 368578"];
4991 [label="var upperLevelType = symbol.Kind == SymbolKind.NamedType ? (NamedTypeSymbol)symbol : symbol.ContainingType; 368579"];
4992 [label="symbol.Kind == SymbolKind.NamedType 368580"];
4993 [label="var upperLevelType = symbol.Kind == SymbolKind.NamedType ? (NamedTypeSymbol)symbol : symbol.ContainingType; 368581"];
4994 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 368582"];
4995 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 368583"];
4996 [label="upperLevelType.ContainingType 368584"];
4997 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 368585"];
4998 [label="return _container as NamedTypeSymbol; 368586"];
4999 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 368587"];
5000 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 368588"];
5001 [label="upperLevelType.HasCodeAnalysisEmbeddedAttribute 368589"];
5002 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyHasEmbeddedAttribute.HasValue())\n                {\n                    uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState();\n                }\n\n                return uncommon.lazyHasEmbeddedAttribute.Value();\n            } 368590"];
5003 [label="GetUncommonProperties() 368591"];
5004 [label="param GetUncommonProperties(this) 368592"];
5005 [label="var result = _lazyUncommonProperties; 368593"];
5006 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 368594"];
5007 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 368595"];
5008 [label="this.IsUncommon() 368596"];
5009 [label="param IsUncommon(this) 368597"];
5010 [label="this.ContainingPEModule 368598"];
5011 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 368599"];
5012 [label="Symbol s = _container; 368600"];
5013 [label="s.Kind 368601"];
5014 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368602"];
5015 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 368603"];
5016 [label="((PENamespaceSymbol)s).ContainingPEModule 368604"];
5017 [label="_containingNamespaceSymbol.ContainingPEModule 368605"];
5018 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 368606"];
5019 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 368607"];
5020 [label="this.ContainingPEModule.HasAnyCustomAttributes(_handle) 368608"];
5021 [label="param HasAnyCustomAttributes(EntityHandle token) 368609"];
5022 [label="param HasAnyCustomAttributes(this) 368610"];
5023 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 368611"];
5024 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 368612"];
5025 [label="return true; 368613"];
5026 [label="return true; 368614"];
5027 [label="if (this.IsUncommon())\n            {\n                result = new UncommonProperties();\n                return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result;\n            } 368615"];
5028 [label="result = new UncommonProperties(); 368616"];
5029 [label="new UncommonProperties() 368617"];
5030 [label="param UncommonProperties(this) 368618"];
5031 [label="lazyEnumUnderlyingType 368619"];
5032 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 368620"];
5033 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 368621"];
5034 [label="lazyContainsExtensionMethods 368622"];
5035 [label="lazyIsByRefLike 368623"];
5036 [label="lazyIsReadOnly 368624"];
5037 [label="lazyDefaultMemberName 368625"];
5038 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 368626"];
5039 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 368627"];
5040 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 368628"];
5041 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 368629"];
5042 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 368630"];
5043 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 368631"];
5044 [label="var uncommon = GetUncommonProperties(); 368632"];
5045 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 368633"];
5046 [label="if (!uncommon.lazyHasEmbeddedAttribute.HasValue())\n                {\n                    uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState();\n                } 368634"];
5047 [label="ContainingPEModule 368635"];
5048 [label="s.Kind 368636"];
5049 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368637"];
5050 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 368638"];
5051 [label="uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState(); 368639"];
5052 [label="ContainingPEModule.Module 368640"];
5053 [label="get\n            {\n                return _module;\n            } 368641"];
5054 [label="uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState(); 368642"];
5055 [label="uncommon.lazyHasEmbeddedAttribute 368643"];
5056 [label="return uncommon.lazyHasEmbeddedAttribute.Value(); 368644"];
5057 [label="return upperLevelType.HasCodeAnalysisEmbeddedAttribute; 368645"];
5058 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 368646"];
5059 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 368647"];
5060 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 368648"];
5061 [label="TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2) 368649"];
5062 [label="param Equals(TypeSymbol left) 368650"];
5063 [label="param Equals(TypeSymbol right) 368651"];
5064 [label="param Equals(TypeCompareKind comparison) 368652"];
5065 [label="if (left is null)\n            {\n                return right is null;\n            } 368653"];
5066 [label="return left.Equals(right, comparison); 368654"];
5067 [label="return left.Equals(right, comparison); 368655"];
5068 [label="left.Equals(right, comparison) 368656"];
5069 [label="param Equals(TypeSymbol t2) 368657"];
5070 [label="param Equals(TypeCompareKind comparison) 368658"];
5071 [label="param Equals(this) 368659"];
5072 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 368660"];
5073 [label="t2 is NativeIntegerTypeSymbol nativeInteger 368661"];
5074 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 368662"];
5075 [label="base.Equals(t2, comparison) 368663"];
5076 [label="param Equals(TypeSymbol t2) 368664"];
5077 [label="param Equals(TypeCompareKind comparison) 368665"];
5078 [label="param Equals(this) 368666"];
5079 [label="if ((object)t2 == this) return true; 368667"];
5080 [label="if ((object)t2 == null) return false; 368668"];
5081 [label="if ((object)t2 == null) return false; 368669"];
5082 [label="return false; 368670"];
5083 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 368671"];
5084 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 368672"];
5085 [label="result = candidate; 368673"];
5086 [label="assembly.IsMissing 368674"];
5087 [label="get\n            {\n                return false;\n            } 368675"];
5088 [label="return false; 368676"];
5089 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 368677"];
5090 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 368678"];
5091 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 368679"];
5092 [label="NamedTypeSymbol result = null; 368680"];
5093 [label="NamedTypeSymbol result; 368681"];
5094 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 368682"];
5095 [label="Debug.Assert(typesByNS != null); 368683"];
5096 [label="get\n            {\n                return true;\n            } 368684"];
5097 [label="_containingNamespaceSymbol 368685"];
5098 [label="_name 368686"];
5099 [label="_typesByNS 368687"];
5100 [label="Debug.Assert(name != null); 368688"];
5101 [label="Debug.Assert((object)containingNamespace != null); 368689"];
5102 [label="Debug.Assert(typesByNS != null); 368690"];
5103 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 368691"];
5104 [label="genericParameterHandles 368692"];
5105 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 368693"];
5106 [label="param GetGenericInfo(out ushort arity) 368694"];
5107 [label="param GetGenericInfo(out BadImageFormatException mrEx) 368695"];
5108 [label="mrEx = null; 368696"];
5109 [label="PENamedTypeSymbol result; 368697"];
5110 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 368698"];
5111 [label="mangleName 368699"];
5112 [label="param PENamedTypeSymbol(out bool mangleName) 368700"];
5113 [label="_lazyTupleData 368701"];
5114 [label="_container 368702"];
5115 [label="_name 368703"];
5116 [label="_flags 368704"];
5117 [label="_corTypeId 368705"];
5118 [label="Debug.Assert(!handle.IsNil); 368706"];
5119 [label="Debug.Assert((object)container != null); 368707"];
5120 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 368708"];
5121 [label="string metadataName; 368709"];
5122 [label="bool makeBad = false; 368710"];
5123 [label="mangleName = false; 368711"];
5124 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 368712"];
5125 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368713"];
5126 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368714"];
5127 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368715"];
5128 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368716"];
5129 [label="bool added; 368717"];
5130 [label="Debug.Assert(added); 368718"];
5131 [label="EnsureAllMembersLoaded(); 368719"];
5132 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 368720"];
5133 [label="if ((object)scope == null)\n                {\n                    break;\n                } 368721"];
5134 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 368722"];
5135 [label="get\n            {\n                return false;\n            } 368723"];
5136 [label="Debug.Assert(!emittedTypeName.IsNull); 368724"];
5137 [label="scope.Kind 368725"];
5138 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368726"];
5139 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 368727"];
5140 [label="NamedTypeSymbol? namedType = null; 368728"];
5141 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 368729"];
5142 [label="namespaceOrTypeMembers 368730"];
5143 [label="scope.IsNamespace 368731"];
5144 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 368732"];
5145 [label="Kind 368733"];
5146 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368734"];
5147 [label="return Kind == SymbolKind.Namespace; 368735"];
5148 [label="bool isTopLevel = scope.IsNamespace; 368736"];
5149 [label="param NamespaceOrTypeSymbol(this) 368737"];
5150 [label="param Symbol(this) 368738"];
5151 [label="_underlying 368739"];
5152 [label="Debug.Assert(underlying is object); 368740"];
5153 [label="param ToDisplayParts(bool minimal) 368741"];
5154 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 368742"];
5155 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 368743"];
5156 [label="Debug.Assert(semanticModelOpt == null); 368744"];
5157 [label="Debug.Assert(positionOpt < 0); 368745"];
5158 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 368746"];
5159 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 368747"];
5160 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368748"];
5161 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368749"];
5162 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 368750"];
5163 [label="param ShouldVisitNamespace(this) 368751"];
5164 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 368752"];
5165 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368753"];
5166 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368754"];
5167 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 368755"];
5168 [label="=> _underlying.IsGlobalNamespace 368756"];
5169 [label="get\n            {\n                return false;\n            } 368757"];
5170 [label="get\n            {\n                return true;\n            } 368758"];
5171 [label="=> _underlying.IsGlobalNamespace 368759"];
5172 [label="get\n            {\n                return false;\n            } 368760"];
5173 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 368761"];
5174 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368762"];
5175 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368763"];
5176 [label="EnsureAllMembersLoaded(); 368764"];
5177 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 368765"];
5178 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 368766"];
5179 [label="if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                } 368767"];
5180 [label="scope.ContainingModule 368768"];
5181 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 368769"];
5182 [label="_containingNamespaceSymbol.ContainingPEModule 368770"];
5183 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368771"];
5184 [label="return _containingNamespaceSymbol.ContainingPEModule; 368772"];
5185 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 368773"];
5186 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 368774"];
5187 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 368775"];
5188 [label="new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName) 368776"];
5189 [label="param TopLevel(ModuleSymbol module) 368777"];
5190 [label="param TopLevel(ref MetadataTypeName fullName) 368778"];
5191 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 368779"];
5192 [label="param TopLevel(this) 368780"];
5193 [label="module 368781"];
5194 [label="1 368782"];
5195 [label="errorInfo 368783"];
5196 [label="param TopLevel(ModuleSymbol module) 368784"];
5197 [label="param TopLevel(int typeId) 368785"];
5198 [label="param TopLevel(DiagnosticInfo? errorInfo) 368786"];
5199 [label="module 368787"];
5200 [label="errorInfo 368788"];
5201 [label="typeId 368789"];
5202 [label="param TopLevel(ModuleSymbol module) 368790"];
5203 [label="param TopLevel(DiagnosticInfo? errorInfo) 368791"];
5204 [label="param TopLevel(int typeId) 368792"];
5205 [label="param TopLevel(this) 368793"];
5206 [label="module 368794"];
5207 [label="fullName.NamespaceName 368795"];
5208 [label="mangleName 368796"];
5209 [label="false 368797"];
5210 [label="errorInfo 368798"];
5211 [label="null 368799"];
5212 [label="typeId 368800"];
5213 [label="null 368801"];
5214 [label="param TopLevel(this) 368802"];
5215 [label="param TopLevel(ModuleSymbol module) 368803"];
5216 [label="param TopLevel(string @namespace) 368804"];
5217 [label="param TopLevel(string name) 368805"];
5218 [label="param TopLevel(int arity) 368806"];
5219 [label="param TopLevel(bool mangleName) 368807"];
5220 [label="param TopLevel(bool isNativeInt) 368808"];
5221 [label="param TopLevel(DiagnosticInfo? errorInfo) 368809"];
5222 [label="param TopLevel(NamespaceSymbol? containingNamespace) 368810"];
5223 [label="param TopLevel(int typeId) 368811"];
5224 [label="param TopLevel(TupleExtraData? tupleData) 368812"];
5225 [label="param TopLevel(this) 368813"];
5226 [label="name 368814"];
5227 [label="arity 368815"];
5228 [label="mangleName 368816"];
5229 [label="tupleData 368817"];
5230 [label="param TopLevel(this) 368818"];
5231 [label="param MissingMetadataTypeSymbol(string name) 368819"];
5232 [label="param MissingMetadataTypeSymbol(int arity) 368820"];
5233 [label="param MissingMetadataTypeSymbol(bool mangleName) 368821"];
5234 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 368822"];
5235 [label="param MissingMetadataTypeSymbol(this) 368823"];
5236 [label="tupleData 368824"];
5237 [label="param MissingMetadataTypeSymbol(this) 368825"];
5238 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 368826"];
5239 [label="_lazyTupleData 368827"];
5240 [label="_lazyTupleData 368828"];
5241 [label="name 368829"];
5242 [label="arity 368830"];
5243 [label="mangleName 368831"];
5244 [label="RoslynDebug.Assert(name != null); 368832"];
5245 [label="RoslynDebug.Assert(name != null); 368833"];
5246 [label="this.name 368834"];
5247 [label="this.arity 368835"];
5248 [label="this.mangleName = (mangleName && arity > 0); 368836"];
5249 [label="this.mangleName = (mangleName && arity > 0); 368837"];
5250 [label="this.mangleName = (mangleName && arity > 0); 368838"];
5251 [label="this.mangleName 368839"];
5252 [label="_namespaceName 368840"];
5253 [label="_containingModule 368841"];
5254 [label="_isNativeInt 368842"];
5255 [label="_lazyErrorInfo 368843"];
5256 [label="_lazyContainingNamespace 368844"];
5257 [label="_lazyTypeId 368845"];
5258 [label="RoslynDebug.Assert((object)module != null); 368846"];
5259 [label="RoslynDebug.Assert((object)module != null); 368847"];
5260 [label="RoslynDebug.Assert(@namespace != null); 368848"];
5261 [label="RoslynDebug.Assert(@namespace != null); 368849"];
5262 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 368850"];
5263 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 368851"];
5264 [label="_namespaceName 368852"];
5265 [label="_containingModule 368853"];
5266 [label="_isNativeInt 368854"];
5267 [label="_lazyErrorInfo 368855"];
5268 [label="_lazyContainingNamespace 368856"];
5269 [label="_lazyTypeId 368857"];
5270 [label="Debug.Assert((object)result != null); 368858"];
5271 [label="Debug.Assert((object)result != null); 368859"];
5272 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 368860"];
5273 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 368861"];
5274 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 368862"];
5275 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 368863"];
5276 [label="System.Diagnostics.Debug.Assert((object)result != null); 368864"];
5277 [label="System.Diagnostics.Debug.Assert((object)result != null); 368865"];
5278 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 368866"];
5279 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 368867"];
5280 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 368868"];
5281 [label="candidate.Kind 368869"];
5282 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 368870"];
5283 [label="return SymbolKind.ErrorType; 368871"];
5284 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 368872"];
5285 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 368873"];
5286 [label="return null; 368874"];
5287 [label="param IsValidWellKnownType(this) 368875"];
5288 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 368876"];
5289 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 368877"];
5290 [label="return false; 368878"];
5291 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 368879"];
5292 [label="candidate = null; 368880"];
5293 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 368881"];
5294 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 368882"];
5295 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 368883"];
5296 [label="Debug.Assert(typesByNS != null); 368884"];
5297 [label="get\n            {\n                return true;\n            } 368885"];
5298 [label="_containingNamespaceSymbol 368886"];
5299 [label="_name 368887"];
5300 [label="_typesByNS 368888"];
5301 [label="Debug.Assert(name != null); 368889"];
5302 [label="Debug.Assert((object)containingNamespace != null); 368890"];
5303 [label="Debug.Assert(typesByNS != null); 368891"];
5304 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 368892"];
5305 [label="genericParameterHandles 368893"];
5306 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 368894"];
5307 [label="param GetGenericInfo(out ushort arity) 368895"];
5308 [label="param GetGenericInfo(out BadImageFormatException mrEx) 368896"];
5309 [label="mrEx = null; 368897"];
5310 [label="PENamedTypeSymbol result; 368898"];
5311 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 368899"];
5312 [label="mangleName 368900"];
5313 [label="param PENamedTypeSymbol(out bool mangleName) 368901"];
5314 [label="_lazyTupleData 368902"];
5315 [label="_container 368903"];
5316 [label="_name 368904"];
5317 [label="_flags 368905"];
5318 [label="_corTypeId 368906"];
5319 [label="Debug.Assert(!handle.IsNil); 368907"];
5320 [label="Debug.Assert((object)container != null); 368908"];
5321 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 368909"];
5322 [label="string metadataName; 368910"];
5323 [label="bool makeBad = false; 368911"];
5324 [label="mangleName = false; 368912"];
5325 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 368913"];
5326 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368914"];
5327 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 368915"];
5328 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368916"];
5329 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 368917"];
5330 [label="bool added; 368918"];
5331 [label="Debug.Assert(added); 368919"];
5332 [label="EnsureAllMembersLoaded(); 368920"];
5333 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 368921"];
5334 [label="if ((object)scope == null)\n                {\n                    break;\n                } 368922"];
5335 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 368923"];
5336 [label="get\n            {\n                return false;\n            } 368924"];
5337 [label="Debug.Assert(!emittedTypeName.IsNull); 368925"];
5338 [label="scope.Kind 368926"];
5339 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368927"];
5340 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 368928"];
5341 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 368929"];
5342 [label="namespaceOrTypeMembers 368930"];
5343 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 368931"];
5344 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 368932"];
5345 [label="param NamespaceOrTypeSymbol(this) 368933"];
5346 [label="param Symbol(this) 368934"];
5347 [label="_underlying 368935"];
5348 [label="Debug.Assert(underlying is object); 368936"];
5349 [label="param ToDisplayParts(bool minimal) 368937"];
5350 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 368938"];
5351 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 368939"];
5352 [label="Debug.Assert(semanticModelOpt == null); 368940"];
5353 [label="Debug.Assert(positionOpt < 0); 368941"];
5354 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 368942"];
5355 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 368943"];
5356 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368944"];
5357 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 368945"];
5358 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 368946"];
5359 [label="param ShouldVisitNamespace(this) 368947"];
5360 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 368948"];
5361 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368949"];
5362 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 368950"];
5363 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 368951"];
5364 [label="=> _underlying.IsGlobalNamespace 368952"];
5365 [label="get\n            {\n                return false;\n            } 368953"];
5366 [label="get\n            {\n                return true;\n            } 368954"];
5367 [label="=> _underlying.IsGlobalNamespace 368955"];
5368 [label="get\n            {\n                return false;\n            } 368956"];
5369 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 368957"];
5370 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368958"];
5371 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 368959"];
5372 [label="EnsureAllMembersLoaded(); 368960"];
5373 [label="scope.ContainingModule 368961"];
5374 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 368962"];
5375 [label="_containingNamespaceSymbol.ContainingPEModule 368963"];
5376 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 368964"];
5377 [label="return _containingNamespaceSymbol.ContainingPEModule; 368965"];
5378 [label="param TopLevel(ModuleSymbol module) 368966"];
5379 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 368967"];
5380 [label="module 368968"];
5381 [label="1 368969"];
5382 [label="errorInfo 368970"];
5383 [label="param TopLevel(ModuleSymbol module) 368971"];
5384 [label="param TopLevel(int typeId) 368972"];
5385 [label="param TopLevel(DiagnosticInfo? errorInfo) 368973"];
5386 [label="module 368974"];
5387 [label="errorInfo 368975"];
5388 [label="typeId 368976"];
5389 [label="param TopLevel(ModuleSymbol module) 368977"];
5390 [label="param TopLevel(DiagnosticInfo? errorInfo) 368978"];
5391 [label="param TopLevel(int typeId) 368979"];
5392 [label="param TopLevel(this) 368980"];
5393 [label="module 368981"];
5394 [label="fullName.NamespaceName 368982"];
5395 [label="mangleName 368983"];
5396 [label="false 368984"];
5397 [label="errorInfo 368985"];
5398 [label="null 368986"];
5399 [label="typeId 368987"];
5400 [label="null 368988"];
5401 [label="param TopLevel(ModuleSymbol module) 368989"];
5402 [label="param TopLevel(string @namespace) 368990"];
5403 [label="param TopLevel(string name) 368991"];
5404 [label="param TopLevel(int arity) 368992"];
5405 [label="param TopLevel(bool mangleName) 368993"];
5406 [label="param TopLevel(bool isNativeInt) 368994"];
5407 [label="param TopLevel(DiagnosticInfo? errorInfo) 368995"];
5408 [label="param TopLevel(NamespaceSymbol? containingNamespace) 368996"];
5409 [label="param TopLevel(int typeId) 368997"];
5410 [label="param TopLevel(TupleExtraData? tupleData) 368998"];
5411 [label="param TopLevel(this) 368999"];
5412 [label="name 369000"];
5413 [label="arity 369001"];
5414 [label="mangleName 369002"];
5415 [label="tupleData 369003"];
5416 [label="param MissingMetadataTypeSymbol(string name) 369004"];
5417 [label="param MissingMetadataTypeSymbol(int arity) 369005"];
5418 [label="param MissingMetadataTypeSymbol(bool mangleName) 369006"];
5419 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 369007"];
5420 [label="param MissingMetadataTypeSymbol(this) 369008"];
5421 [label="tupleData 369009"];
5422 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 369010"];
5423 [label="_lazyTupleData 369011"];
5424 [label="name 369012"];
5425 [label="arity 369013"];
5426 [label="mangleName 369014"];
5427 [label="RoslynDebug.Assert(name != null); 369015"];
5428 [label="RoslynDebug.Assert(name != null); 369016"];
5429 [label="this.name 369017"];
5430 [label="this.arity 369018"];
5431 [label="this.mangleName = (mangleName && arity > 0); 369019"];
5432 [label="this.mangleName = (mangleName && arity > 0); 369020"];
5433 [label="this.mangleName = (mangleName && arity > 0); 369021"];
5434 [label="this.mangleName 369022"];
5435 [label="_namespaceName 369023"];
5436 [label="_containingModule 369024"];
5437 [label="_isNativeInt 369025"];
5438 [label="_lazyErrorInfo 369026"];
5439 [label="_lazyContainingNamespace 369027"];
5440 [label="_lazyTypeId 369028"];
5441 [label="RoslynDebug.Assert((object)module != null); 369029"];
5442 [label="RoslynDebug.Assert((object)module != null); 369030"];
5443 [label="RoslynDebug.Assert(@namespace != null); 369031"];
5444 [label="RoslynDebug.Assert(@namespace != null); 369032"];
5445 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369033"];
5446 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369034"];
5447 [label="_namespaceName 369035"];
5448 [label="_containingModule 369036"];
5449 [label="_isNativeInt 369037"];
5450 [label="_lazyErrorInfo 369038"];
5451 [label="_lazyContainingNamespace 369039"];
5452 [label="_lazyTypeId 369040"];
5453 [label="Debug.Assert((object)result != null); 369041"];
5454 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 369042"];
5455 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 369043"];
5456 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 369044"];
5457 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 369045"];
5458 [label="System.Diagnostics.Debug.Assert((object)result != null); 369046"];
5459 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 369047"];
5460 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 369048"];
5461 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 369049"];
5462 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369050"];
5463 [label="return null; 369051"];
5464 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369052"];
5465 [label="return false; 369053"];
5466 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 369054"];
5467 [label="candidate = null; 369055"];
5468 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369056"];
5469 [label="assembly.IsMissing 369057"];
5470 [label="get\n            {\n                return false;\n            } 369058"];
5471 [label="return false; 369059"];
5472 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 369060"];
5473 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 369061"];
5474 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 369062"];
5475 [label="NamedTypeSymbol result = null; 369063"];
5476 [label="NamedTypeSymbol result; 369064"];
5477 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 369065"];
5478 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 369066"];
5479 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 369067"];
5480 [label="=> _underlying.IsGlobalNamespace 369068"];
5481 [label="get\n            {\n                return false;\n            } 369069"];
5482 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 369070"];
5483 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 369071"];
5484 [label="param NamespaceOrTypeSymbol(this) 369072"];
5485 [label="param Symbol(this) 369073"];
5486 [label="_underlying 369074"];
5487 [label="Debug.Assert(underlying is object); 369075"];
5488 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 369076"];
5489 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 369077"];
5490 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 369078"];
5491 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 369079"];
5492 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 369080"];
5493 [label="=> _underlying.IsGlobalNamespace 369081"];
5494 [label="get\n            {\n                return false;\n            } 369082"];
5495 [label="get\n            {\n                return true;\n            } 369083"];
5496 [label="=> _underlying.IsGlobalNamespace 369084"];
5497 [label="get\n            {\n                return false;\n            } 369085"];
5498 [label="=> _underlying.IsGlobalNamespace 369086"];
5499 [label="get\n            {\n                return false;\n            } 369087"];
5500 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 369088"];
5501 [label="Debug.Assert(typesByNS != null); 369089"];
5502 [label="get\n            {\n                return false;\n            } 369090"];
5503 [label="get\n            {\n                return true;\n            } 369091"];
5504 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 369092"];
5505 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 369093"];
5506 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 369094"];
5507 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 369095"];
5508 [label="return _containingNamespaceSymbol.ContainingPEModule; 369096"];
5509 [label="param TopLevel(ModuleSymbol module) 369097"];
5510 [label="module 369098"];
5511 [label="param TopLevel(ModuleSymbol module) 369099"];
5512 [label="module 369100"];
5513 [label="param TopLevel(ModuleSymbol module) 369101"];
5514 [label="module 369102"];
5515 [label="param TopLevel(ModuleSymbol module) 369103"];
5516 [label="RoslynDebug.Assert((object)module != null); 369104"];
5517 [label="_containingModule 369105"];
5518 [label="Debug.Assert((object)result != null); 369106"];
5519 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 369107"];
5520 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 369108"];
5521 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 369109"];
5522 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 369110"];
5523 [label="System.Diagnostics.Debug.Assert((object)result != null); 369111"];
5524 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 369112"];
5525 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 369113"];
5526 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 369114"];
5527 [label="candidate.Kind 369115"];
5528 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 369116"];
5529 [label="return SymbolKind.ErrorType; 369117"];
5530 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369118"];
5531 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369119"];
5532 [label="return null; 369120"];
5533 [label="param IsValidWellKnownType(this) 369121"];
5534 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369122"];
5535 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369123"];
5536 [label="return false; 369124"];
5537 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 369125"];
5538 [label="candidate = null; 369126"];
5539 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369127"];
5540 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369128"];
5541 [label="assembly.IsMissing 369129"];
5542 [label="get\n            {\n                return false;\n            } 369130"];
5543 [label="return false; 369131"];
5544 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 369132"];
5545 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 369133"];
5546 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 369134"];
5547 [label="NamedTypeSymbol result = null; 369135"];
5548 [label="NamedTypeSymbol result; 369136"];
5549 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 369137"];
5550 [label="_containingNamespaceSymbol 369138"];
5551 [label="_name 369139"];
5552 [label="_typesByNS 369140"];
5553 [label="Debug.Assert(name != null); 369141"];
5554 [label="Debug.Assert((object)containingNamespace != null); 369142"];
5555 [label="Debug.Assert(typesByNS != null); 369143"];
5556 [label="genericParameterHandles 369144"];
5557 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 369145"];
5558 [label="param GetGenericInfo(out ushort arity) 369146"];
5559 [label="param GetGenericInfo(out BadImageFormatException mrEx) 369147"];
5560 [label="mrEx = null; 369148"];
5561 [label="PENamedTypeSymbol result; 369149"];
5562 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 369150"];
5563 [label="mangleName 369151"];
5564 [label="param PENamedTypeSymbol(out bool mangleName) 369152"];
5565 [label="_lazyTupleData 369153"];
5566 [label="_container 369154"];
5567 [label="_name 369155"];
5568 [label="_flags 369156"];
5569 [label="_corTypeId 369157"];
5570 [label="Debug.Assert(!handle.IsNil); 369158"];
5571 [label="Debug.Assert((object)container != null); 369159"];
5572 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 369160"];
5573 [label="string metadataName; 369161"];
5574 [label="bool makeBad = false; 369162"];
5575 [label="mangleName = false; 369163"];
5576 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 369164"];
5577 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 369165"];
5578 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 369166"];
5579 [label="bool added; 369167"];
5580 [label="Debug.Assert(added); 369168"];
5581 [label="EnsureAllMembersLoaded(); 369169"];
5582 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 369170"];
5583 [label="if ((object)scope == null)\n                {\n                    break;\n                } 369171"];
5584 [label="Debug.Assert(!emittedTypeName.IsNull); 369172"];
5585 [label="scope.Kind 369173"];
5586 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369174"];
5587 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 369175"];
5588 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 369176"];
5589 [label="namespaceOrTypeMembers 369177"];
5590 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 369178"];
5591 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369179"];
5592 [label="param ToDisplayParts(bool minimal) 369180"];
5593 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 369181"];
5594 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 369182"];
5595 [label="Debug.Assert(semanticModelOpt == null); 369183"];
5596 [label="Debug.Assert(positionOpt < 0); 369184"];
5597 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 369185"];
5598 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 369186"];
5599 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 369187"];
5600 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 369188"];
5601 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 369189"];
5602 [label="EnsureAllMembersLoaded(); 369190"];
5603 [label="scope.ContainingModule 369191"];
5604 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 369192"];
5605 [label="_containingNamespaceSymbol.ContainingPEModule 369193"];
5606 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 369194"];
5607 [label="return _containingNamespaceSymbol.ContainingPEModule; 369195"];
5608 [label="param TopLevel(ModuleSymbol module) 369196"];
5609 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 369197"];
5610 [label="module 369198"];
5611 [label="1 369199"];
5612 [label="errorInfo 369200"];
5613 [label="param TopLevel(ModuleSymbol module) 369201"];
5614 [label="param TopLevel(int typeId) 369202"];
5615 [label="param TopLevel(DiagnosticInfo? errorInfo) 369203"];
5616 [label="module 369204"];
5617 [label="errorInfo 369205"];
5618 [label="typeId 369206"];
5619 [label="param TopLevel(ModuleSymbol module) 369207"];
5620 [label="param TopLevel(DiagnosticInfo? errorInfo) 369208"];
5621 [label="param TopLevel(int typeId) 369209"];
5622 [label="param TopLevel(this) 369210"];
5623 [label="module 369211"];
5624 [label="fullName.NamespaceName 369212"];
5625 [label="mangleName 369213"];
5626 [label="false 369214"];
5627 [label="errorInfo 369215"];
5628 [label="null 369216"];
5629 [label="typeId 369217"];
5630 [label="null 369218"];
5631 [label="param TopLevel(ModuleSymbol module) 369219"];
5632 [label="param TopLevel(string @namespace) 369220"];
5633 [label="param TopLevel(string name) 369221"];
5634 [label="param TopLevel(int arity) 369222"];
5635 [label="param TopLevel(bool mangleName) 369223"];
5636 [label="param TopLevel(bool isNativeInt) 369224"];
5637 [label="param TopLevel(DiagnosticInfo? errorInfo) 369225"];
5638 [label="param TopLevel(NamespaceSymbol? containingNamespace) 369226"];
5639 [label="param TopLevel(int typeId) 369227"];
5640 [label="param TopLevel(TupleExtraData? tupleData) 369228"];
5641 [label="param TopLevel(this) 369229"];
5642 [label="name 369230"];
5643 [label="arity 369231"];
5644 [label="mangleName 369232"];
5645 [label="tupleData 369233"];
5646 [label="param MissingMetadataTypeSymbol(string name) 369234"];
5647 [label="param MissingMetadataTypeSymbol(int arity) 369235"];
5648 [label="param MissingMetadataTypeSymbol(bool mangleName) 369236"];
5649 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 369237"];
5650 [label="param MissingMetadataTypeSymbol(this) 369238"];
5651 [label="tupleData 369239"];
5652 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 369240"];
5653 [label="_lazyTupleData 369241"];
5654 [label="name 369242"];
5655 [label="arity 369243"];
5656 [label="mangleName 369244"];
5657 [label="RoslynDebug.Assert(name != null); 369245"];
5658 [label="RoslynDebug.Assert(name != null); 369246"];
5659 [label="this.name 369247"];
5660 [label="this.arity 369248"];
5661 [label="this.mangleName = (mangleName && arity > 0); 369249"];
5662 [label="this.mangleName = (mangleName && arity > 0); 369250"];
5663 [label="this.mangleName = (mangleName && arity > 0); 369251"];
5664 [label="this.mangleName 369252"];
5665 [label="_namespaceName 369253"];
5666 [label="_containingModule 369254"];
5667 [label="_isNativeInt 369255"];
5668 [label="_lazyErrorInfo 369256"];
5669 [label="_lazyContainingNamespace 369257"];
5670 [label="_lazyTypeId 369258"];
5671 [label="RoslynDebug.Assert((object)module != null); 369259"];
5672 [label="RoslynDebug.Assert((object)module != null); 369260"];
5673 [label="RoslynDebug.Assert(@namespace != null); 369261"];
5674 [label="RoslynDebug.Assert(@namespace != null); 369262"];
5675 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369263"];
5676 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369264"];
5677 [label="_namespaceName 369265"];
5678 [label="_containingModule 369266"];
5679 [label="_isNativeInt 369267"];
5680 [label="_lazyErrorInfo 369268"];
5681 [label="_lazyContainingNamespace 369269"];
5682 [label="_lazyTypeId 369270"];
5683 [label="Debug.Assert((object)result != null); 369271"];
5684 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 369272"];
5685 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 369273"];
5686 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 369274"];
5687 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 369275"];
5688 [label="System.Diagnostics.Debug.Assert((object)result != null); 369276"];
5689 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 369277"];
5690 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 369278"];
5691 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 369279"];
5692 [label="candidate.Kind 369280"];
5693 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 369281"];
5694 [label="return SymbolKind.ErrorType; 369282"];
5695 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369283"];
5696 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369284"];
5697 [label="return null; 369285"];
5698 [label="param IsValidWellKnownType(this) 369286"];
5699 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369287"];
5700 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369288"];
5701 [label="return false; 369289"];
5702 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 369290"];
5703 [label="candidate = null; 369291"];
5704 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369292"];
5705 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369293"];
5706 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 369294"];
5707 [label="return ImmutableArray<Symbol>.Empty; 369295"];
5708 [label="param TopLevel(ModuleSymbol module) 369296"];
5709 [label="module 369297"];
5710 [label="param TopLevel(ModuleSymbol module) 369298"];
5711 [label="module 369299"];
5712 [label="param TopLevel(ModuleSymbol module) 369300"];
5713 [label="module 369301"];
5714 [label="param TopLevel(ModuleSymbol module) 369302"];
5715 [label="RoslynDebug.Assert((object)module != null); 369303"];
5716 [label="_containingModule 369304"];
5717 [label="assembly.IsMissing 369305"];
5718 [label="get\n            {\n                return false;\n            } 369306"];
5719 [label="return false; 369307"];
5720 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 369308"];
5721 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 369309"];
5722 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 369310"];
5723 [label="NamedTypeSymbol result = null; 369311"];
5724 [label="NamedTypeSymbol result; 369312"];
5725 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 369313"];
5726 [label="Debug.Assert(typesByNS != null); 369314"];
5727 [label="get\n            {\n                return true;\n            } 369315"];
5728 [label="_containingNamespaceSymbol 369316"];
5729 [label="_name 369317"];
5730 [label="_typesByNS 369318"];
5731 [label="Debug.Assert(name != null); 369319"];
5732 [label="Debug.Assert((object)containingNamespace != null); 369320"];
5733 [label="Debug.Assert(typesByNS != null); 369321"];
5734 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 369322"];
5735 [label="genericParameterHandles 369323"];
5736 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 369324"];
5737 [label="param GetGenericInfo(out ushort arity) 369325"];
5738 [label="param GetGenericInfo(out BadImageFormatException mrEx) 369326"];
5739 [label="mrEx = null; 369327"];
5740 [label="PENamedTypeSymbol result; 369328"];
5741 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 369329"];
5742 [label="mangleName 369330"];
5743 [label="param PENamedTypeSymbol(out bool mangleName) 369331"];
5744 [label="_lazyTupleData 369332"];
5745 [label="_container 369333"];
5746 [label="_name 369334"];
5747 [label="_flags 369335"];
5748 [label="_corTypeId 369336"];
5749 [label="Debug.Assert(!handle.IsNil); 369337"];
5750 [label="Debug.Assert((object)container != null); 369338"];
5751 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 369339"];
5752 [label="string metadataName; 369340"];
5753 [label="bool makeBad = false; 369341"];
5754 [label="mangleName = false; 369342"];
5755 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 369343"];
5756 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 369344"];
5757 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 369345"];
5758 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 369346"];
5759 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 369347"];
5760 [label="bool added; 369348"];
5761 [label="Debug.Assert(added); 369349"];
5762 [label="EnsureAllMembersLoaded(); 369350"];
5763 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 369351"];
5764 [label="if ((object)scope == null)\n                {\n                    break;\n                } 369352"];
5765 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 369353"];
5766 [label="get\n            {\n                return false;\n            } 369354"];
5767 [label="return ImmutableArray<Symbol>.Empty; 369355"];
5768 [label="param TopLevel(ModuleSymbol module) 369356"];
5769 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 369357"];
5770 [label="module 369358"];
5771 [label="1 369359"];
5772 [label="errorInfo 369360"];
5773 [label="param TopLevel(ModuleSymbol module) 369361"];
5774 [label="param TopLevel(int typeId) 369362"];
5775 [label="param TopLevel(DiagnosticInfo? errorInfo) 369363"];
5776 [label="module 369364"];
5777 [label="errorInfo 369365"];
5778 [label="typeId 369366"];
5779 [label="param TopLevel(ModuleSymbol module) 369367"];
5780 [label="param TopLevel(DiagnosticInfo? errorInfo) 369368"];
5781 [label="param TopLevel(int typeId) 369369"];
5782 [label="param TopLevel(this) 369370"];
5783 [label="module 369371"];
5784 [label="fullName.NamespaceName 369372"];
5785 [label="mangleName 369373"];
5786 [label="false 369374"];
5787 [label="errorInfo 369375"];
5788 [label="null 369376"];
5789 [label="typeId 369377"];
5790 [label="null 369378"];
5791 [label="param TopLevel(ModuleSymbol module) 369379"];
5792 [label="param TopLevel(string @namespace) 369380"];
5793 [label="param TopLevel(string name) 369381"];
5794 [label="param TopLevel(int arity) 369382"];
5795 [label="param TopLevel(bool mangleName) 369383"];
5796 [label="param TopLevel(bool isNativeInt) 369384"];
5797 [label="param TopLevel(DiagnosticInfo? errorInfo) 369385"];
5798 [label="param TopLevel(NamespaceSymbol? containingNamespace) 369386"];
5799 [label="param TopLevel(int typeId) 369387"];
5800 [label="param TopLevel(TupleExtraData? tupleData) 369388"];
5801 [label="param TopLevel(this) 369389"];
5802 [label="name 369390"];
5803 [label="arity 369391"];
5804 [label="mangleName 369392"];
5805 [label="tupleData 369393"];
5806 [label="param MissingMetadataTypeSymbol(string name) 369394"];
5807 [label="param MissingMetadataTypeSymbol(int arity) 369395"];
5808 [label="param MissingMetadataTypeSymbol(bool mangleName) 369396"];
5809 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 369397"];
5810 [label="param MissingMetadataTypeSymbol(this) 369398"];
5811 [label="tupleData 369399"];
5812 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 369400"];
5813 [label="_lazyTupleData 369401"];
5814 [label="name 369402"];
5815 [label="arity 369403"];
5816 [label="mangleName 369404"];
5817 [label="RoslynDebug.Assert(name != null); 369405"];
5818 [label="RoslynDebug.Assert(name != null); 369406"];
5819 [label="this.name 369407"];
5820 [label="this.arity 369408"];
5821 [label="this.mangleName = (mangleName && arity > 0); 369409"];
5822 [label="this.mangleName = (mangleName && arity > 0); 369410"];
5823 [label="this.mangleName = (mangleName && arity > 0); 369411"];
5824 [label="this.mangleName 369412"];
5825 [label="_namespaceName 369413"];
5826 [label="_containingModule 369414"];
5827 [label="_isNativeInt 369415"];
5828 [label="_lazyErrorInfo 369416"];
5829 [label="_lazyContainingNamespace 369417"];
5830 [label="_lazyTypeId 369418"];
5831 [label="RoslynDebug.Assert((object)module != null); 369419"];
5832 [label="RoslynDebug.Assert((object)module != null); 369420"];
5833 [label="RoslynDebug.Assert(@namespace != null); 369421"];
5834 [label="RoslynDebug.Assert(@namespace != null); 369422"];
5835 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369423"];
5836 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 369424"];
5837 [label="_namespaceName 369425"];
5838 [label="_containingModule 369426"];
5839 [label="_isNativeInt 369427"];
5840 [label="_lazyErrorInfo 369428"];
5841 [label="_lazyContainingNamespace 369429"];
5842 [label="_lazyTypeId 369430"];
5843 [label="Debug.Assert((object)result != null); 369431"];
5844 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 369432"];
5845 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 369433"];
5846 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 369434"];
5847 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 369435"];
5848 [label="System.Diagnostics.Debug.Assert((object)result != null); 369436"];
5849 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 369437"];
5850 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 369438"];
5851 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 369439"];
5852 [label="candidate.Kind 369440"];
5853 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 369441"];
5854 [label="return SymbolKind.ErrorType; 369442"];
5855 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369443"];
5856 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 369444"];
5857 [label="return null; 369445"];
5858 [label="param IsValidWellKnownType(this) 369446"];
5859 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369447"];
5860 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 369448"];
5861 [label="return false; 369449"];
5862 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 369450"];
5863 [label="candidate = null; 369451"];
5864 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369452"];
5865 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 369453"];
5866 [label="assemblies.Free(); 369454"];
5867 [label="return result; 369455"];
5868 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 369456"];
5869 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 369457"];
5870 [label="'Expressions' 369458"];
5871 [label="'Linq' 369459"];
5872 [label="'' 369460"];
5873 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 369461"];
5874 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 369462"];
5875 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 369463"];
5876 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 369464"];
5877 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 369465"];
5878 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 369466"];
5879 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 369467"];
5880 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 369468"];
5881 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 369469"];
5882 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 369470"];
5883 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 369471"];
5884 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 369472"];
5885 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 369473"];
5886 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 369474"];
5887 [label="type.IsErrorType() 369475"];
5888 [label="param IsErrorType(this TypeSymbol type) 369476"];
5889 [label="RoslynDebug.Assert((object)type != null); 369477"];
5890 [label="RoslynDebug.Assert((object)type != null); 369478"];
5891 [label="type.Kind 369479"];
5892 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 369480"];
5893 [label="return SymbolKind.NamedType; 369481"];
5894 [label="return type.Kind == SymbolKind.ErrorType; 369482"];
5895 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 369483"];
5896 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 369484"];
5897 [label="((object)type == null || type.IsErrorType()) 369485"];
5898 [label="if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                } 369486"];
5899 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 369487"];
5900 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 369488"];
5901 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 369489"];
5902 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 369490"];
5903 [label="AdditionalCodegenWarnings 369491"];
5904 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 369492"];
5905 [label="return _additionalCodegenWarnings; 369493"];
5906 [label="AdditionalCodegenWarnings.AddRange(warnings); 369494"];
5907 [label="AdditionalCodegenWarnings.AddRange(warnings); 369495"];
5908 [label="AdditionalCodegenWarnings.AddRange(warnings); 369496"];
5909 [label="warnings.Free(); 369497"];
5910 [label="return _lazyWellKnownTypes[index]!; 369498"];
5911 [label="Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null'); 369499"];
5912 [label="Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null'); 369500"];
5913 [label="if (!(compilationRelaxationsAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if CompilationRelaxationsAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton);\n                } 369501"];
5914 [label="0 369502"];
5915 [label="ExternalScope = 0 369503"];
5916 [label="1 369504"];
5917 [label="TopLevelScope = 1 369505"];
5918 [label="2 369506"];
5919 [label="ValueKindInsignificantBits = 2 369507"];
5920 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 369508"];
5921 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 369509"];
5922 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 369510"];
5923 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 369511"];
5924 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 369512"];
5925 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 369513"];
5926 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 369514"];
5927 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 369515"];
5928 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 369516"];
5929 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 369517"];
5930 [label="10 369518"];
5931 [label="MaxParameterListsForErrorRecovery = 10 369519"];
5932 [label="'<>h__TransparentIdentifier' 369520"];
5933 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 369521"];
5934 [label="s => (MethodSymbol)s 369522"];
5935 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 369523"];
5936 [label="s => (PropertySymbol)s 369524"];
5937 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 369525"];
5938 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 369526"];
5939 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 369527"];
5940 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 369528"];
5941 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 369529"];
5942 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton) 369530"];
5943 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 369531"];
5944 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 369532"];
5945 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 369533"];
5946 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 369534"];
5947 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 369535"];
5948 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 369536"];
5949 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 369537"];
5950 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 369538"];
5951 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 369539"];
5952 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 369540"];
5953 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369541"];
5954 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369542"];
5955 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369543"];
5956 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369544"];
5957 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369545"];
5958 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 369546"];
5959 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional) 369547"];
5960 [label="param GetWellKnownTypeMember(CSharpCompilation compilation) 369548"];
5961 [label="param GetWellKnownTypeMember(WellKnownMember member) 369549"];
5962 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 369550"];
5963 [label="param GetWellKnownTypeMember(Location location = null) 369551"];
5964 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 369552"];
5965 [label="param GetWellKnownTypeMember(bool isOptional = false) 369553"];
5966 [label="Debug.Assert((syntax != null) ^ (location != null)); 369554"];
5967 [label="Debug.Assert((syntax != null) ^ (location != null)); 369555"];
5968 [label="Debug.Assert((syntax != null) ^ (location != null)); 369556"];
5969 [label="Debug.Assert((syntax != null) ^ (location != null)); 369557"];
5970 [label="DiagnosticInfo useSiteDiagnostic; 369558"];
5971 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 369559"];
5972 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 369560"];
5973 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 369561"];
5974 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 369562"];
5975 [label="GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional) 369563"];
5976 [label="param GetWellKnownTypeMember(CSharpCompilation compilation) 369564"];
5977 [label="param GetWellKnownTypeMember(WellKnownMember member) 369565"];
5978 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 369566"];
5979 [label="param GetWellKnownTypeMember(bool isOptional = false) 369567"];
5980 [label="Symbol memberSymbol = compilation.GetWellKnownTypeMember(member); 369568"];
5981 [label="compilation.GetWellKnownTypeMember(member) 369569"];
5982 [label="param GetWellKnownTypeMember(WellKnownMember member) 369570"];
5983 [label="param GetWellKnownTypeMember(this) 369571"];
5984 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 369572"];
5985 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 369573"];
5986 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 369574"];
5987 [label="if (IsMemberMissing(member)) return null; 369575"];
5988 [label="if (IsMemberMissing(member)) return null; 369576"];
5989 [label="if (_lazyWellKnownTypeMembers == null || ReferenceEquals(_lazyWellKnownTypeMembers[(int)member], ErrorTypeSymbol.UnknownResultType))\n            {\n                if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                }\n\n                MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);\n                NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId);\n                Symbol? result = null;\n\n                if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                }\n\n                Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType);\n            } 369577"];
5990 [label="if (_lazyWellKnownTypeMembers == null || ReferenceEquals(_lazyWellKnownTypeMembers[(int)member], ErrorTypeSymbol.UnknownResultType))\n            {\n                if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                }\n\n                MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);\n                NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId);\n                Symbol? result = null;\n\n                if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                }\n\n                Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType);\n            } 369578"];
5991 [label="if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                } 369579"];
5992 [label="var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count]; 369580"];
5993 [label="for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    } 369581"];
5994 [label="for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    } 369582"];
5995 [label="wellKnownTypeMembers[i] 369583"];
5996 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 369584"];
5997 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 369585"];
5998 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 369586"];
5999 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 369587"];
6000 [label="MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member); 369588"];
6001 [label="NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId); 369589"];
6002 [label="descriptor.DeclaringTypeId <= (int)SpecialType.Count 369590"];
6003 [label="this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId) 369591"];
6004 [label="Debug.Assert(type.IsValid()); 369592"];
6005 [label="this.Options 369593"];
6006 [label="return _options; 369594"];
6007 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 369595"];
6008 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 369596"];
6009 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 369597"];
6010 [label="param Includes(this BinderFlags self) 369598"];
6011 [label="param Includes(BinderFlags other) 369599"];
6012 [label="return (self & other) == other; 369600"];
6013 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 369601"];
6014 [label="return _lazyWellKnownTypes[index]!; 369602"];
6015 [label="Symbol? result = null; 369603"];
6016 [label="if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                } 369604"];
6017 [label="type.IsErrorType() 369605"];
6018 [label="param IsErrorType(this TypeSymbol type) 369606"];
6019 [label="RoslynDebug.Assert((object)type != null); 369607"];
6020 [label="RoslynDebug.Assert((object)type != null); 369608"];
6021 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 369609"];
6022 [label="if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                } 369610"];
6023 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 369611"];
6024 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 369612"];
6025 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 369613"];
6026 [label="this.Assembly 369614"];
6027 [label="GetBoundReferenceManager() 369615"];
6028 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 369616"];
6029 [label="return _referenceManager; 369617"];
6030 [label="GetBoundReferenceManager(); 369618"];
6031 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 369619"];
6032 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 369620"];
6033 [label="GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly) 369621"];
6034 [label="param GetRuntimeMember(NamedTypeSymbol declaringType) 369622"];
6035 [label="param GetRuntimeMember(in MemberDescriptor descriptor) 369623"];
6036 [label="param GetRuntimeMember(SignatureComparer<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer) 369624"];
6037 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 369625"];
6038 [label="var members = declaringType.GetMembers(descriptor.Name); 369626"];
6039 [label="declaringType.GetMembers(descriptor.Name) 369627"];
6040 [label="param GetMembers(string name) 369628"];
6041 [label="param GetMembers(this) 369629"];
6042 [label="EnsureAllMembersAreLoaded() 369630"];
6043 [label="param EnsureAllMembersAreLoaded(this) 369631"];
6044 [label="if (_lazyMembersByName == null)\n            {\n                LoadMembers();\n            } 369632"];
6045 [label="if (_lazyMembersByName == null)\n            {\n                LoadMembers();\n            } 369633"];
6046 [label="LoadMembers() 369634"];
6047 [label="param LoadMembers(this) 369635"];
6048 [label="ArrayBuilder<Symbol> members = null; 369636"];
6049 [label="if (_lazyMembersInDeclarationOrder.IsDefault)\n            {\n                EnsureNestedTypesAreLoaded();\n\n                members = ArrayBuilder<Symbol>.GetInstance();\n\n                Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder());\n                Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder());\n                Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder());\n                Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder());\n\n                if (this.TypeKind == TypeKind.Enum)\n                {\n                    EnsureEnumUnderlyingTypeIsLoaded(this.GetUncommonProperties());\n\n                    var moduleSymbol = this.ContainingPEModule;\n                    var module = moduleSymbol.Module;\n\n                    try\n                    {\n                        foreach (var fieldDef in module.GetFieldsOfTypeOrThrow(_handle))\n                        {\n                            FieldAttributes fieldFlags;\n\n                            try\n                            {\n                                fieldFlags = module.GetFieldDefFlagsOrThrow(fieldDef);\n                                if ((fieldFlags & FieldAttributes.Static) == 0)\n                                {\n                                    continue;\n                                }\n                            }\n                            catch (BadImageFormatException)\n                            {\n                                fieldFlags = 0;\n                            }\n\n                            if (ModuleExtensions.ShouldImportField(fieldFlags, moduleSymbol.ImportOptions))\n                            {\n                                var field = new PEFieldSymbol(moduleSymbol, this, fieldDef);\n                                members.Add(field);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var syntheticCtor = new SynthesizedInstanceConstructor(this);\n                    members.Add(syntheticCtor);\n                }\n                else\n                {\n                    ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance();\n                    ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance();\n\n                    MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers);\n\n                    // A method may be referenced as an accessor by one or more properties. And,\n                    // any of those properties may be 'bogus' if one of the property accessors\n                    // does not match the property signature. If the method is referenced by at\n                    // least one non-bogus property, then the method is created as an accessor,\n                    // and (for purposes of error reporting if the method is referenced directly) the\n                    // associated property is set (arbitrarily) to the first non-bogus property found\n                    // in metadata. If the method is not referenced by any non-bogus properties,\n                    // then the method is created as a normal method rather than an accessor.\n\n                    // Create a dictionary of method symbols indexed by metadata handle\n                    // (to allow efficient lookup when matching property accessors).\n                    PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers);\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    }\n\n                    this.CreateProperties(methodHandleToSymbol, nonFieldMembers);\n                    this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers);\n\n                    foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    }\n\n                    members.AddRange(nonFieldMembers);\n\n                    nonFieldMembers.Free();\n                    fieldMembers.Free();\n\n                    methodHandleToSymbol.Free();\n                }\n\n                // Now add types to the end.\n                int membersCount = members.Count;\n\n                foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                }\n\n                // Sort the types based on row id.\n                members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance);\n\n#if DEBUG\n                Symbol previous = null;\n\n                foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                }\n#endif\n\n                if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                }\n\n                var membersInDeclarationOrder = members.ToImmutable();\n\n                if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                }\n            } 369637"];
6050 [label="EnsureNestedTypesAreLoaded() 369638"];
6051 [label="param EnsureNestedTypesAreLoaded(this) 369639"];
6052 [label="if (_lazyNestedTypes == null)\n            {\n                var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                types.AddRange(this.CreateNestedTypes());\n                var typesDict = GroupByName(types);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null);\n                if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n                types.Free();\n            } 369640"];
6053 [label="if (_lazyNestedTypes == null)\n            {\n                var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                types.AddRange(this.CreateNestedTypes());\n                var typesDict = GroupByName(types);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null);\n                if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n                types.Free();\n            } 369641"];
6054 [label="var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 369642"];
6055 [label="this.CreateNestedTypes() 369643"];
6056 [label="param CreateNestedTypes(this) 369644"];
6057 [label="this.ContainingPEModule 369645"];
6058 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 369646"];
6059 [label="s.Kind 369647"];
6060 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369648"];
6061 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 369649"];
6062 [label="var moduleSymbol = this.ContainingPEModule; 369650"];
6063 [label="moduleSymbol.Module 369651"];
6064 [label="get\n            {\n                return _module;\n            } 369652"];
6065 [label="var module = moduleSymbol.Module; 369653"];
6066 [label="ImmutableArray<TypeDefinitionHandle> nestedTypeDefs; 369654"];
6067 [label="nestedTypeDefs 369655"];
6068 [label="nestedTypeDefs = module.GetNestedTypeDefsOrThrow(_handle); 369656"];
6069 [label="nestedTypeDefs = module.GetNestedTypeDefsOrThrow(_handle); 369657"];
6070 [label="foreach (var typeRid in nestedTypeDefs)\n            {\n                if (module.ShouldImportNestedType(typeRid))\n                {\n                    yield return PENamedTypeSymbol.Create(moduleSymbol, this, typeRid);\n                }\n            } 369658"];
6071 [label="param CreateNestedTypes(this) 369659"];
6072 [label="types.AddRange(this.CreateNestedTypes()); 369660"];
6073 [label="types.AddRange(this.CreateNestedTypes()); 369661"];
6074 [label="var typesDict = GroupByName(types); 369662"];
6075 [label="GroupByName(types) 369663"];
6076 [label="param GroupByName(ArrayBuilder<PENamedTypeSymbol> symbols) 369664"];
6077 [label="if (symbols.Count == 0)\n            {\n                return s_emptyNestedTypes;\n            } 369665"];
6078 [label="if (symbols.Count == 0)\n            {\n                return s_emptyNestedTypes;\n            } 369666"];
6079 [label="return s_emptyNestedTypes; 369667"];
6080 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 369668"];
6081 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 369669"];
6082 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 369670"];
6083 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 369671"];
6084 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 369672"];
6085 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 369673"];
6086 [label="this.ContainingPEModule 369674"];
6087 [label="s.Kind 369675"];
6088 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369676"];
6089 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 369677"];
6090 [label="var moduleSymbol = this.ContainingPEModule; 369678"];
6091 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 369679"];
6092 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 369680"];
6093 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 369681"];
6094 [label="param OnNewTypeDeclarationsLoaded(this) 369682"];
6095 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 369683"];
6096 [label="types.Free(); 369684"];
6097 [label="EnsureNestedTypesAreLoaded(); 369685"];
6098 [label="members = ArrayBuilder<Symbol>.GetInstance(); 369686"];
6099 [label="Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder()); 369687"];
6100 [label="Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder()); 369688"];
6101 [label="Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder()); 369689"];
6102 [label="Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder()); 369690"];
6103 [label="this.TypeKind 369691"];
6104 [label="TypeKind result = _lazyKind; 369692"];
6105 [label="return result; 369693"];
6106 [label="if (this.TypeKind == TypeKind.Enum)\n                {\n                    EnsureEnumUnderlyingTypeIsLoaded(this.GetUncommonProperties());\n\n                    var moduleSymbol = this.ContainingPEModule;\n                    var module = moduleSymbol.Module;\n\n                    try\n                    {\n                        foreach (var fieldDef in module.GetFieldsOfTypeOrThrow(_handle))\n                        {\n                            FieldAttributes fieldFlags;\n\n                            try\n                            {\n                                fieldFlags = module.GetFieldDefFlagsOrThrow(fieldDef);\n                                if ((fieldFlags & FieldAttributes.Static) == 0)\n                                {\n                                    continue;\n                                }\n                            }\n                            catch (BadImageFormatException)\n                            {\n                                fieldFlags = 0;\n                            }\n\n                            if (ModuleExtensions.ShouldImportField(fieldFlags, moduleSymbol.ImportOptions))\n                            {\n                                var field = new PEFieldSymbol(moduleSymbol, this, fieldDef);\n                                members.Add(field);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var syntheticCtor = new SynthesizedInstanceConstructor(this);\n                    members.Add(syntheticCtor);\n                }\n                else\n                {\n                    ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance();\n                    ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance();\n\n                    MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers);\n\n                    // A method may be referenced as an accessor by one or more properties. And,\n                    // any of those properties may be 'bogus' if one of the property accessors\n                    // does not match the property signature. If the method is referenced by at\n                    // least one non-bogus property, then the method is created as an accessor,\n                    // and (for purposes of error reporting if the method is referenced directly) the\n                    // associated property is set (arbitrarily) to the first non-bogus property found\n                    // in metadata. If the method is not referenced by any non-bogus properties,\n                    // then the method is created as a normal method rather than an accessor.\n\n                    // Create a dictionary of method symbols indexed by metadata handle\n                    // (to allow efficient lookup when matching property accessors).\n                    PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers);\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    }\n\n                    this.CreateProperties(methodHandleToSymbol, nonFieldMembers);\n                    this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers);\n\n                    foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    }\n\n                    members.AddRange(nonFieldMembers);\n\n                    nonFieldMembers.Free();\n                    fieldMembers.Free();\n\n                    methodHandleToSymbol.Free();\n                } 369694"];
6107 [label="ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance(); 369695"];
6108 [label="ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance(); 369696"];
6109 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 369697"];
6110 [label="this.CreateFields(fieldMembers) 369698"];
6111 [label="param CreateFields(ArrayBuilder<PEFieldSymbol> fieldMembers) 369699"];
6112 [label="param CreateFields(this) 369700"];
6113 [label="var privateFieldNameToSymbols = new MultiDictionary<string, PEFieldSymbol>(); 369701"];
6114 [label="this.ContainingPEModule 369702"];
6115 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 369703"];
6116 [label="s.Kind 369704"];
6117 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369705"];
6118 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 369706"];
6119 [label="var moduleSymbol = this.ContainingPEModule; 369707"];
6120 [label="moduleSymbol.Module 369708"];
6121 [label="get\n            {\n                return _module;\n            } 369709"];
6122 [label="var module = moduleSymbol.Module; 369710"];
6123 [label="var isOrdinaryStruct = false; 369711"];
6124 [label="var isOrdinaryEmbeddableStruct = false; 369712"];
6125 [label="this.TypeKind 369713"];
6126 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 369714"];
6127 [label="if (this.TypeKind == TypeKind.Struct)\n            {\n                if (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None)\n                {\n                    isOrdinaryStruct = true;\n                    isOrdinaryEmbeddableStruct = this.ContainingAssembly.IsLinked;\n                }\n                else\n                {\n                    isOrdinaryStruct = (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Nullable_T);\n                }\n            } 369715"];
6128 [label="foreach (var fieldRid in module.GetFieldsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        if (!(isOrdinaryEmbeddableStruct ||\n                            (isOrdinaryStruct && (module.GetFieldDefFlagsOrThrow(fieldRid) & FieldAttributes.Static) == 0) ||\n                            module.ShouldImportField(fieldRid, moduleSymbol.ImportOptions)))\n                        {\n                            continue;\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var symbol = new PEFieldSymbol(moduleSymbol, this, fieldRid);\n                    fieldMembers.Add(symbol);\n\n                    // Only private fields are potentially backing fields for field-like events.\n                    if (symbol.DeclaredAccessibility == Accessibility.Private)\n                    {\n                        var name = symbol.Name;\n                        if (name.Length > 0)\n                        {\n                            privateFieldNameToSymbols.Add(name, symbol);\n                        }\n                    }\n                } 369716"];
6129 [label="foreach (var fieldRid in module.GetFieldsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        if (!(isOrdinaryEmbeddableStruct ||\n                            (isOrdinaryStruct && (module.GetFieldDefFlagsOrThrow(fieldRid) & FieldAttributes.Static) == 0) ||\n                            module.ShouldImportField(fieldRid, moduleSymbol.ImportOptions)))\n                        {\n                            continue;\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var symbol = new PEFieldSymbol(moduleSymbol, this, fieldRid);\n                    fieldMembers.Add(symbol);\n\n                    // Only private fields are potentially backing fields for field-like events.\n                    if (symbol.DeclaredAccessibility == Accessibility.Private)\n                    {\n                        var name = symbol.Name;\n                        if (name.Length > 0)\n                        {\n                            privateFieldNameToSymbols.Add(name, symbol);\n                        }\n                    }\n                } 369717"];
6130 [label="return privateFieldNameToSymbols; 369718"];
6131 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 369719"];
6132 [label="PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers); 369720"];
6133 [label="this.CreateMethods(nonFieldMembers) 369721"];
6134 [label="param CreateMethods(ArrayBuilder<Symbol> members) 369722"];
6135 [label="param CreateMethods(this) 369723"];
6136 [label="this.ContainingPEModule 369724"];
6137 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 369725"];
6138 [label="Symbol s = _container; 369726"];
6139 [label="s.Kind 369727"];
6140 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369728"];
6141 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 369729"];
6142 [label="var moduleSymbol = this.ContainingPEModule; 369730"];
6143 [label="moduleSymbol.Module 369731"];
6144 [label="get\n            {\n                return _module;\n            } 369732"];
6145 [label="var module = moduleSymbol.Module; 369733"];
6146 [label="var map = PooledDictionary<MethodDefinitionHandle, PEMethodSymbol>.GetInstance(); 369734"];
6147 [label="this.TypeKind 369735"];
6148 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 369736"];
6149 [label="TypeKind result = _lazyKind; 369737"];
6150 [label="var isOrdinaryEmbeddableStruct = (this.TypeKind == TypeKind.Struct) && (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None) && this.ContainingAssembly.IsLinked; 369738"];
6151 [label="foreach (var methodHandle in module.GetMethodsOfTypeOrThrow(_handle))\n                {\n                    if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    }\n                } 369739"];
6152 [label="foreach (var methodHandle in module.GetMethodsOfTypeOrThrow(_handle))\n                {\n                    if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    }\n                } 369740"];
6153 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 369741"];
6154 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 369742"];
6155 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 369743"];
6156 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 369744"];
6157 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 369745"];
6158 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 369746"];
6159 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 369747"];
6160 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 369748"];
6161 [label="new PEMethodSymbol(moduleSymbol, this, methodHandle) 369749"];
6162 [label="param PEMethodSymbol(PEModuleSymbol moduleSymbol) 369750"];
6163 [label="param PEMethodSymbol(PENamedTypeSymbol containingType) 369751"];
6164 [label="param PEMethodSymbol(MethodDefinitionHandle methodDef) 369752"];
6165 [label="param PEMethodSymbol(this) 369753"];
6166 [label="null 369754"];
6167 [label="None = null 369755"];
6168 [label="param PEMethodSymbol(this) 369756"];
6169 [label="param MethodSymbol(this) 369757"];
6170 [label="param MethodSymbol(this) 369758"];
6171 [label="_lazyAdapter 369759"];
6172 [label="_lazyParameterSignature 369760"];
6173 [label="_name 369761"];
6174 [label="_containingType 369762"];
6175 [label="_associatedPropertyOrEventOpt 369763"];
6176 [label="_flags 369764"];
6177 [label="_implFlags 369765"];
6178 [label="_lazySignature 369766"];
6179 [label="_uncommonFields 369767"];
6180 [label="Debug.Assert((object)moduleSymbol != null); 369768"];
6181 [label="Debug.Assert((object)moduleSymbol != null); 369769"];
6182 [label="Debug.Assert((object)containingType != null); 369770"];
6183 [label="Debug.Assert((object)containingType != null); 369771"];
6184 [label="Debug.Assert(!methodDef.IsNil); 369772"];
6185 [label="_handle 369773"];
6186 [label="_containingType 369774"];
6187 [label="MethodAttributes localflags = 0; 369775"];
6188 [label="int rva; 369776"];
6189 [label="MethodImplAttributes implFlags; 369777"];
6190 [label="moduleSymbol.Module 369778"];
6191 [label="get\n            {\n                return _module;\n            } 369779"];
6192 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369780"];
6193 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369781"];
6194 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369782"];
6195 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369783"];
6196 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369784"];
6197 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369785"];
6198 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 369786"];
6199 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 369787"];
6200 [label="_implFlags 369788"];
6201 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 369789"];
6202 [label="_flags 369790"];
6203 [label="members.Add(method); 369791"];
6204 [label="members.Add(method); 369792"];
6205 [label="map.Add(methodHandle, method); 369793"];
6206 [label="map.Add(methodHandle, method); 369794"];
6207 [label="map.Add(methodHandle, method); 369795"];
6208 [label="_containingType 369796"];
6209 [label="_flags 369797"];
6210 [label="_implFlags 369798"];
6211 [label="Debug.Assert((object)moduleSymbol != null); 369799"];
6212 [label="Debug.Assert((object)containingType != null); 369800"];
6213 [label="Debug.Assert(!methodDef.IsNil); 369801"];
6214 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 369802"];
6215 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 369803"];
6216 [label="map.Add(methodHandle, method); 369804"];
6217 [label="map.Add(methodHandle, method); 369805"];
6218 [label="return map; 369806"];
6219 [label="PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers); 369807"];
6220 [label="this.TypeKind 369808"];
6221 [label="TypeKind result = _lazyKind; 369809"];
6222 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    } 369810"];
6223 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 369811"];
6224 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 369812"];
6225 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers) 369813"];
6226 [label="param CreateProperties(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 369814"];
6227 [label="param CreateProperties(ArrayBuilder<Symbol> members) 369815"];
6228 [label="param CreateProperties(this) 369816"];
6229 [label="this.ContainingPEModule 369817"];
6230 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 369818"];
6231 [label="Symbol s = _container; 369819"];
6232 [label="s.Kind 369820"];
6233 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 369821"];
6234 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 369822"];
6235 [label="var moduleSymbol = this.ContainingPEModule; 369823"];
6236 [label="moduleSymbol.Module 369824"];
6237 [label="get\n            {\n                return _module;\n            } 369825"];
6238 [label="var module = moduleSymbol.Module; 369826"];
6239 [label="foreach (var propertyDef in module.GetPropertiesOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetPropertyMethodsOrThrow(propertyDef);\n\n                        PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter);\n                        PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter);\n\n                        if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 369827"];
6240 [label="foreach (var propertyDef in module.GetPropertiesOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetPropertyMethodsOrThrow(propertyDef);\n\n                        PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter);\n                        PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter);\n\n                        if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 369828"];
6241 [label="var methods = module.GetPropertyMethodsOrThrow(propertyDef); 369829"];
6242 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 369830"];
6243 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 369831"];
6244 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 369832"];
6245 [label="GetAccessorMethod(module, methodHandleToSymbol, methods.Getter) 369833"];
6246 [label="param GetAccessorMethod(PEModule module) 369834"];
6247 [label="param GetAccessorMethod(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 369835"];
6248 [label="param GetAccessorMethod(MethodDefinitionHandle methodDef) 369836"];
6249 [label="param GetAccessorMethod(this) 369837"];
6250 [label="if (methodDef.IsNil)\n            {\n                return null;\n            } 369838"];
6251 [label="PEMethodSymbol method; 369839"];
6252 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 369840"];
6253 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 369841"];
6254 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 369842"];
6255 [label="Debug.Assert(found || !module.ShouldImportMethod(methodDef, this.ContainingPEModule.ImportOptions)); 369843"];
6256 [label="return method; 369844"];
6257 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 369845"];
6258 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 369846"];
6259 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 369847"];
6260 [label="GetAccessorMethod(module, methodHandleToSymbol, methods.Setter) 369848"];
6261 [label="param GetAccessorMethod(PEModule module) 369849"];
6262 [label="param GetAccessorMethod(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 369850"];
6263 [label="param GetAccessorMethod(MethodDefinitionHandle methodDef) 369851"];
6264 [label="param GetAccessorMethod(this) 369852"];
6265 [label="if (methodDef.IsNil)\n            {\n                return null;\n            } 369853"];
6266 [label="return null; 369854"];
6267 [label="if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        } 369855"];
6268 [label="if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        } 369856"];
6269 [label="1 369857"];
6270 [label="UnsetAccessibility = -1 369858"];
6271 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 369859"];
6272 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 369860"];
6273 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 369861"];
6274 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 369862"];
6275 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 369863"];
6276 [label="PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod) 369864"];
6277 [label="param Create(PEModuleSymbol moduleSymbol) 369865"];
6278 [label="param Create(PENamedTypeSymbol containingType) 369866"];
6279 [label="param Create(PropertyDefinitionHandle handle) 369867"];
6280 [label="param Create(PEMethodSymbol getMethod) 369868"];
6281 [label="param Create(PEMethodSymbol setMethod) 369869"];
6282 [label="Debug.Assert((object)moduleSymbol != null); 369870"];
6283 [label="Debug.Assert((object)moduleSymbol != null); 369871"];
6284 [label="Debug.Assert((object)containingType != null); 369872"];
6285 [label="Debug.Assert((object)containingType != null); 369873"];
6286 [label="Debug.Assert(!handle.IsNil); 369874"];
6287 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 369875"];
6288 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 369876"];
6289 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 369877"];
6290 [label="new MetadataDecoder(moduleSymbol, containingType) 369878"];
6291 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 369879"];
6292 [label="param MetadataDecoder(PENamedTypeSymbol context) 369880"];
6293 [label="param MetadataDecoder(this) 369881"];
6294 [label="Debug.Assert((object)moduleSymbol != null); 369882"];
6295 [label="Debug.Assert((object)moduleSymbol != null); 369883"];
6296 [label="SignatureHeader callingConvention; 369884"];
6297 [label="callingConvention 369885"];
6298 [label="BadImageFormatException propEx; 369886"];
6299 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 369887"];
6300 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 369888"];
6301 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 369889"];
6302 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 369890"];
6303 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 369891"];
6304 [label="param GetSpecialType(PEModuleSymbol moduleSymbol) 369892"];
6305 [label="param GetSpecialType(SpecialType specialType) 369893"];
6306 [label="param GetSpecialType(this) 369894"];
6307 [label="moduleSymbol.ContainingAssembly 369895"];
6308 [label="get\n            {\n                return _assemblySymbol;\n            } 369896"];
6309 [label="return moduleSymbol.ContainingAssembly.GetSpecialType(specialType); 369897"];
6310 [label="return moduleSymbol.ContainingAssembly.GetSpecialType(specialType); 369898"];
6311 [label="moduleSymbol.ContainingAssembly.GetSpecialType(specialType) 369899"];
6312 [label="param GetSpecialType(SpecialType type) 369900"];
6313 [label="param GetSpecialType(this) 369901"];
6314 [label="CorLibrary 369902"];
6315 [label="get\n            {\n                return _corLibrary;\n            } 369903"];
6316 [label="return CorLibrary.GetDeclaredSpecialType(type); 369904"];
6317 [label="return CorLibrary.GetDeclaredSpecialType(type); 369905"];
6318 [label="CorLibrary.GetDeclaredSpecialType(type) 369906"];
6319 [label="param GetDeclaredSpecialType(SpecialType type) 369907"];
6320 [label="param GetDeclaredSpecialType(this) 369908"];
6321 [label="this.Modules 369909"];
6322 [label="get\n            {\n                return _modules;\n            } 369910"];
6323 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 369911"];
6324 [label="module.GetReferencedAssemblies() 369912"];
6325 [label="param GetReferencedAssemblies(this) 369913"];
6326 [label="AssertReferencesInitialized() 369914"];
6327 [label="param AssertReferencesInitialized(this) 369915"];
6328 [label="Debug.Assert(_moduleReferences != null); 369916"];
6329 [label="Debug.Assert(_moduleReferences != null); 369917"];
6330 [label="AssertReferencesInitialized(); 369918"];
6331 [label="return _moduleReferences.Identities; 369919"];
6332 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 369920"];
6333 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 369921"];
6334 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369922"];
6335 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369923"];
6336 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369924"];
6337 [label="return _lazySpecialTypes[(int)type]; 369925"];
6338 [label="Debug.Assert(propertyParams.Length > 0); 369926"];
6339 [label="Debug.Assert(propertyParams.Length > 0); 369927"];
6340 [label="var returnInfo = propertyParams[0]; 369928"];
6341 [label="var returnInfo = propertyParams[0]; 369929"];
6342 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 369930"];
6343 [label="returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty 369931"];
6344 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 369932"];
6345 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 369933"];
6346 [label="new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder) 369934"];
6347 [label="param PEPropertySymbol(PEModuleSymbol moduleSymbol) 369935"];
6348 [label="param PEPropertySymbol(PENamedTypeSymbol containingType) 369936"];
6349 [label="param PEPropertySymbol(PropertyDefinitionHandle handle) 369937"];
6350 [label="param PEPropertySymbol(PEMethodSymbol getMethod) 369938"];
6351 [label="param PEPropertySymbol(PEMethodSymbol setMethod) 369939"];
6352 [label="param PEPropertySymbol(ParamInfo<TypeSymbol>[] propertyParams) 369940"];
6353 [label="param PEPropertySymbol(MetadataDecoder metadataDecoder) 369941"];
6354 [label="param PEPropertySymbol(this) 369942"];
6355 [label="param PEPropertySymbol(this) 369943"];
6356 [label="param PropertySymbol(this) 369944"];
6357 [label="param PropertySymbol(this) 369945"];
6358 [label="_lazyAdapter 369946"];
6359 [label="_lazyParameterSignature 369947"];
6360 [label="_name 369948"];
6361 [label="_containingType 369949"];
6362 [label="_refKind 369950"];
6363 [label="_getMethod 369951"];
6364 [label="_setMethod 369952"];
6365 [label="_lazyDocComment 369953"];
6366 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 369954"];
6367 [label="_lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 369955"];
6368 [label="_declaredAccessibility = UnsetAccessibility 369956"];
6369 [label="_flags 369957"];
6370 [label="_containingType 369958"];
6371 [label="moduleSymbol.Module 369959"];
6372 [label="get\n            {\n                return _module;\n            } 369960"];
6373 [label="var module = moduleSymbol.Module; 369961"];
6374 [label="PropertyAttributes mdFlags = 0; 369962"];
6375 [label="BadImageFormatException mrEx = null; 369963"];
6376 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 369964"];
6377 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 369965"];
6378 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 369966"];
6379 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 369967"];
6380 [label="_getMethod 369968"];
6381 [label="_setMethod 369969"];
6382 [label="_handle 369970"];
6383 [label="SignatureHeader unusedCallingConvention; 369971"];
6384 [label="unusedCallingConvention 369972"];
6385 [label="BadImageFormatException getEx = null; 369973"];
6386 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 369974"];
6387 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 369975"];
6388 [label="(object)getMethod == null 369976"];
6389 [label="getMethod.Handle 369977"];
6390 [label="=> _handle 369978"];
6391 [label="_handle 369979"];
6392 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 369980"];
6393 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 369981"];
6394 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 369982"];
6395 [label="param GetSpecialType(this) 369983"];
6396 [label="this.Modules 369984"];
6397 [label="get\n            {\n                return _modules;\n            } 369985"];
6398 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 369986"];
6399 [label="module.GetReferencedAssemblies() 369987"];
6400 [label="param GetReferencedAssemblies(this) 369988"];
6401 [label="AssertReferencesInitialized() 369989"];
6402 [label="param AssertReferencesInitialized(this) 369990"];
6403 [label="Debug.Assert(_moduleReferences != null); 369991"];
6404 [label="Debug.Assert(_moduleReferences != null); 369992"];
6405 [label="AssertReferencesInitialized(); 369993"];
6406 [label="return _moduleReferences.Identities; 369994"];
6407 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 369995"];
6408 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 369996"];
6409 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369997"];
6410 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369998"];
6411 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 369999"];
6412 [label="BadImageFormatException setEx = null; 370000"];
6413 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 370001"];
6414 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 370002"];
6415 [label="(object)setMethod == null 370003"];
6416 [label="bool isBad; 370004"];
6417 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370005"];
6418 [label="setMethodParams is null 370006"];
6419 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370007"];
6420 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370008"];
6421 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370009"];
6422 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370010"];
6423 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370011"];
6424 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 370012"];
6425 [label="GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad) 370013"];
6426 [label="param GetParameters(PEModuleSymbol moduleSymbol) 370014"];
6427 [label="param GetParameters(PEPropertySymbol property) 370015"];
6428 [label="param GetParameters(PEMethodSymbol accessor) 370016"];
6429 [label="param GetParameters(ParamInfo<TypeSymbol>[] propertyParams) 370017"];
6430 [label="param GetParameters(ParamInfo<TypeSymbol>[] accessorParams) 370018"];
6431 [label="param GetParameters(out bool anyParameterIsBad) 370019"];
6432 [label="anyParameterIsBad = false; 370020"];
6433 [label="if (propertyParams.Length < 2)\n            {\n                return ImmutableArray<ParameterSymbol>.Empty;\n            } 370021"];
6434 [label="if (propertyParams.Length < 2)\n            {\n                return ImmutableArray<ParameterSymbol>.Empty;\n            } 370022"];
6435 [label="return ImmutableArray<ParameterSymbol>.Empty; 370023"];
6436 [label="_parameters 370024"];
6437 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370025"];
6438 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370026"];
6439 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370027"];
6440 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370028"];
6441 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370029"];
6442 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370030"];
6443 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 370031"];
6444 [label="var returnInfo = propertyParams[0]; 370032"];
6445 [label="var returnInfo = propertyParams[0]; 370033"];
6446 [label="var typeCustomModifiers = CSharpCustomModifier.Convert(returnInfo.CustomModifiers); 370034"];
6447 [label="CSharpCustomModifier.Convert(returnInfo.CustomModifiers) 370035"];
6448 [label="param Convert(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 370036"];
6449 [label="if (customModifiers.IsDefault)\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 370037"];
6450 [label="return ImmutableArray<CustomModifier>.Empty; 370038"];
6451 [label="if (returnInfo.IsByRef)\n            {\n                if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                {\n                    _refKind = RefKind.RefReadOnly;\n                }\n                else\n                {\n                    _refKind = RefKind.Ref;\n                }\n            }\n            else\n            {\n                _refKind = RefKind.None;\n            } 370039"];
6452 [label="_refKind 370040"];
6453 [label="TypeSymbol originalPropertyType = returnInfo.Type; 370041"];
6454 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 370042"];
6455 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 370043"];
6456 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 370044"];
6457 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 370045"];
6458 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 370046"];
6459 [label="DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind) 370047"];
6460 [label="param TransformType(TypeSymbol metadataType) 370048"];
6461 [label="param TransformType(int targetSymbolCustomModifierCount) 370049"];
6462 [label="param TransformType(EntityHandle targetSymbolToken) 370050"];
6463 [label="param TransformType(PEModuleSymbol containingModule) 370051"];
6464 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 370052"];
6465 [label="Debug.Assert((object)metadataType != null); 370053"];
6466 [label="Debug.Assert((object)metadataType != null); 370054"];
6467 [label="ImmutableArray<bool> dynamicTransformFlags; 370055"];
6468 [label="dynamicTransformFlags 370056"];
6469 [label="containingModule.Module 370057"];
6470 [label="get\n            {\n                return _module;\n            } 370058"];
6471 [label="return _module; 370059"];
6472 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 370060"];
6473 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 370061"];
6474 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 370062"];
6475 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 370063"];
6476 [label="return metadataType; 370064"];
6477 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 370065"];
6478 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 370066"];
6479 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 370067"];
6480 [label="NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol) 370068"];
6481 [label="param TransformType(TypeSymbol type) 370069"];
6482 [label="param TransformType(EntityHandle handle) 370070"];
6483 [label="param TransformType(PEModuleSymbol containingModule) 370071"];
6484 [label="containingModule.Module 370072"];
6485 [label="get\n            {\n                return _module;\n            } 370073"];
6486 [label="return _module; 370074"];
6487 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 370075"];
6488 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 370076"];
6489 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 370077"];
6490 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 370078"];
6491 [label="containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) 370079"];
6492 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 370080"];
6493 [label="originalPropertyType = originalPropertyType.AsDynamicIfNoPia(_containingType); 370081"];
6494 [label="originalPropertyType = originalPropertyType.AsDynamicIfNoPia(_containingType); 370082"];
6495 [label="originalPropertyType.AsDynamicIfNoPia(_containingType) 370083"];
6496 [label="param AsDynamicIfNoPia(this TypeSymbol type) 370084"];
6497 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 370085"];
6498 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 370086"];
6499 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 370087"];
6500 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 370088"];
6501 [label="type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) 370089"];
6502 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 370090"];
6503 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 370091"];
6504 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 370092"];
6505 [label="type.SpecialType 370093"];
6506 [label="get\n            {\n                return _corTypeId;\n            } 370094"];
6507 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 370095"];
6508 [label="result = null; 370096"];
6509 [label="return false; 370097"];
6510 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 370098"];
6511 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 370099"];
6512 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 370100"];
6513 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 370101"];
6514 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 370102"];
6515 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 370103"];
6516 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 370104"];
6517 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 370105"];
6518 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 370106"];
6519 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 370107"];
6520 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 370108"];
6521 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 370109"];
6522 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 370110"];
6523 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 370111"];
6524 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 370112"];
6525 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 370113"];
6526 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 370114"];
6527 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 370115"];
6528 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 370116"];
6529 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 370117"];
6530 [label="TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers) 370118"];
6531 [label="param Create(TypeSymbol typeSymbol) 370119"];
6532 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 370120"];
6533 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 370121"];
6534 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 370122"];
6535 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 370123"];
6536 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 370124"];
6537 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 370125"];
6538 [label="typeSymbol.IsNullableType() 370126"];
6539 [label="param IsNullableType(this TypeSymbol type) 370127"];
6540 [label="type.OriginalDefinition 370128"];
6541 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 370129"];
6542 [label="OriginalTypeSymbolDefinition 370130"];
6543 [label="get\n            {\n                return this.OriginalDefinition;\n            } 370131"];
6544 [label="this.OriginalDefinition 370132"];
6545 [label="get\n            {\n                return this;\n            } 370133"];
6546 [label="return this; 370134"];
6547 [label="return this.OriginalDefinition; 370135"];
6548 [label="return OriginalTypeSymbolDefinition; 370136"];
6549 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 370137"];
6550 [label="type.OriginalDefinition.SpecialType 370138"];
6551 [label="get\n            {\n                return _corTypeId;\n            } 370139"];
6552 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 370140"];
6553 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 370141"];
6554 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 370142"];
6555 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 370143"];
6556 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 370144"];
6557 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 370145"];
6558 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 370146"];
6559 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 370147"];
6560 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 370148"];
6561 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 370149"];
6562 [label="param NonLazyType(this) 370150"];
6563 [label="param Extensions(this) 370151"];
6564 [label="Debug.Assert(!customModifiers.IsDefault); 370152"];
6565 [label="_customModifiers 370153"];
6566 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 370154"];
6567 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 370155"];
6568 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 370156"];
6569 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 370157"];
6570 [label="Extensions.Create(customModifiers) 370158"];
6571 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 370159"];
6572 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 370160"];
6573 [label="return Default; 370161"];
6574 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 370162"];
6575 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 370163"];
6576 [label="param TypeWithAnnotations(TypeSymbol defaultType) 370164"];
6577 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 370165"];
6578 [label="param TypeWithAnnotations(Extensions extensions) 370166"];
6579 [label="param TypeWithAnnotations(this) 370167"];
6580 [label="var a1 = defaultType is null; 370168"];
6581 [label="!a1 370169"];
6582 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 370170"];
6583 [label="defaultType.IsNullableType() 370171"];
6584 [label="param IsNullableType(this TypeSymbol type) 370172"];
6585 [label="type.OriginalDefinition 370173"];
6586 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 370174"];
6587 [label="OriginalTypeSymbolDefinition 370175"];
6588 [label="get\n            {\n                return this.OriginalDefinition;\n            } 370176"];
6589 [label="this.OriginalDefinition 370177"];
6590 [label="get\n            {\n                return this;\n            } 370178"];
6591 [label="return this; 370179"];
6592 [label="return this.OriginalDefinition; 370180"];
6593 [label="return OriginalTypeSymbolDefinition; 370181"];
6594 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 370182"];
6595 [label="type.OriginalDefinition.SpecialType 370183"];
6596 [label="get\n            {\n                return _corTypeId;\n            } 370184"];
6597 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 370185"];
6598 [label="Debug.Assert(a1 || a2 != true || a3); 370186"];
6599 [label="Debug.Assert(a1 || a2 != true || a3); 370187"];
6600 [label="Debug.Assert(extensions != null); 370188"];
6601 [label="Debug.Assert(extensions != null); 370189"];
6602 [label="DefaultType 370190"];
6603 [label="NullableAnnotation 370191"];
6604 [label="_extensions 370192"];
6605 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 370193"];
6606 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 370194"];
6607 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 370195"];
6608 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 370196"];
6609 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 370197"];
6610 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 370198"];
6611 [label="NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType) 370199"];
6612 [label="param TransformType(TypeWithAnnotations metadataType) 370200"];
6613 [label="param TransformType(EntityHandle targetSymbolToken) 370201"];
6614 [label="param TransformType(PEModuleSymbol containingModule) 370202"];
6615 [label="param TransformType(Symbol accessSymbol) 370203"];
6616 [label="param TransformType(Symbol nullableContext) 370204"];
6617 [label="metadataType.HasType 370205"];
6618 [label="=> !(DefaultType is null) 370206"];
6619 [label="DefaultType is null 370207"];
6620 [label="!(DefaultType is null) 370208"];
6621 [label="Debug.Assert(metadataType.HasType); 370209"];
6622 [label="accessSymbol.IsDefinition 370210"];
6623 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 370211"];
6624 [label="OriginalDefinition 370212"];
6625 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 370213"];
6626 [label="OriginalSymbolDefinition 370214"];
6627 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 370215"];
6628 [label="this.OriginalTypeSymbolDefinition 370216"];
6629 [label="get\n            {\n                return this.OriginalDefinition;\n            } 370217"];
6630 [label="this.OriginalDefinition 370218"];
6631 [label="get\n            {\n                return this;\n            } 370219"];
6632 [label="return this; 370220"];
6633 [label="return this.OriginalDefinition; 370221"];
6634 [label="return this.OriginalTypeSymbolDefinition; 370222"];
6635 [label="return OriginalSymbolDefinition; 370223"];
6636 [label="return (object)this == (object)OriginalDefinition; 370224"];
6637 [label="Debug.Assert(accessSymbol.IsDefinition); 370225"];
6638 [label="accessSymbol.ContainingModule 370226"];
6639 [label="get\n            {\n                return ContainingPEModule;\n            } 370227"];
6640 [label="ContainingPEModule 370228"];
6641 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 370229"];
6642 [label="Symbol s = _container; 370230"];
6643 [label="s.Kind 370231"];
6644 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370232"];
6645 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 370233"];
6646 [label="return ContainingPEModule; 370234"];
6647 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 370235"];
6648 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 370236"];
6649 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 370237"];
6650 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 370238"];
6651 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 370239"];
6652 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 370240"];
6653 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 370241"];
6654 [label="Debug.Assert(symbol is object); 370242"];
6655 [label="symbol.Kind 370243"];
6656 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 370244"];
6657 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 370245"];
6658 [label="isInternal = false; 370246"];
6659 [label="symbol.DeclaredAccessibility 370247"];
6660 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 370248"];
6661 [label="Accessibility access = Accessibility.Private; 370249"];
6662 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 370250"];
6663 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 370251"];
6664 [label="symbol.ContainingType 370252"];
6665 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 370253"];
6666 [label="return _container as NamedTypeSymbol; 370254"];
6667 [label="symbol = symbol.ContainingType; 370255"];
6668 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 370256"];
6669 [label="return true; 370257"];
6670 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 370258"];
6671 [label="byte defaultTransformFlag; 370259"];
6672 [label="ImmutableArray<byte> nullableTransformFlags; 370260"];
6673 [label="nullableTransformFlags 370261"];
6674 [label="containingModule.Module 370262"];
6675 [label="get\n            {\n                return _module;\n            } 370263"];
6676 [label="return _module; 370264"];
6677 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 370265"];
6678 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 370266"];
6679 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 370267"];
6680 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 370268"];
6681 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 370269"];
6682 [label="nullableContext.GetNullableContextValue() 370270"];
6683 [label="param GetNullableContextValue(this) 370271"];
6684 [label="byte? value; 370272"];
6685 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 370273"];
6686 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 370274"];
6687 [label="_lazyNullableContextValue.TryGetByte(out value) 370275"];
6688 [label="param TryGetByte(this NullableContextKind kind) 370276"];
6689 [label="param TryGetByte(out byte? value) 370277"];
6690 [label="switch (kind)\n            {\n                case NullableContextKind.Unknown:\n                    value = null;\n                    return false;\n                case NullableContextKind.None:\n                    value = null;\n                    return true;\n                case NullableContextKind.Oblivious:\n                    value = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    return true;\n                case NullableContextKind.NotAnnotated:\n                    value = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    return true;\n                case NullableContextKind.Annotated:\n                    value = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 370278"];
6691 [label="value = null; 370279"];
6692 [label="return false; 370280"];
6693 [label="ContainingPEModule 370281"];
6694 [label="s.Kind 370282"];
6695 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370283"];
6696 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 370284"];
6697 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 370285"];
6698 [label="ContainingPEModule.Module 370286"];
6699 [label="get\n            {\n                return _module;\n            } 370287"];
6700 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 370288"];
6701 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 370289"];
6702 [label="ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 370290"];
6703 [label="_container.GetNullableContextValue() 370291"];
6704 [label="param GetNullableContextValue(this) 370292"];
6705 [label="GetLocalNullableContextValue() 370293"];
6706 [label="param GetLocalNullableContextValue(this) 370294"];
6707 [label="return null; 370295"];
6708 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 370296"];
6709 [label="ContainingSymbol 370297"];
6710 [label="get { return _containingNamespaceSymbol; } 370298"];
6711 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 370299"];
6712 [label=".GetNullableContextValue() 370300"];
6713 [label="param GetNullableContextValue(this) 370301"];
6714 [label="GetLocalNullableContextValue() 370302"];
6715 [label="param GetLocalNullableContextValue(this) 370303"];
6716 [label="return null; 370304"];
6717 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 370305"];
6718 [label="ContainingSymbol 370306"];
6719 [label="get\n            {\n                return _moduleSymbol;\n            } 370307"];
6720 [label="return _moduleSymbol; 370308"];
6721 [label="param GetLocalNullableContextValue(this) 370309"];
6722 [label="get\n            {\n                return _assemblySymbol;\n            } 370310"];
6723 [label="return _assemblySymbol; 370311"];
6724 [label="param GetLocalNullableContextValue(this) 370312"];
6725 [label="get\n            {\n                return null;\n            } 370313"];
6726 [label="return null; 370314"];
6727 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 370315"];
6728 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 370316"];
6729 [label="_lazyNullableContextValue = value.ToNullableContextFlags(); 370317"];
6730 [label="value.ToNullableContextFlags() 370318"];
6731 [label="param ToNullableContextFlags(this byte? value) 370319"];
6732 [label="switch (value)\n            {\n                case null:\n                    return NullableContextKind.None;\n                case NullableAnnotationExtensions.ObliviousAttributeValue:\n                    return NullableContextKind.Oblivious;\n                case NullableAnnotationExtensions.NotAnnotatedAttributeValue:\n                    return NullableContextKind.NotAnnotated;\n                case NullableAnnotationExtensions.AnnotatedAttributeValue:\n                    return NullableContextKind.Annotated;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(value);\n            } 370320"];
6733 [label="return NullableContextKind.None; 370321"];
6734 [label="_lazyNullableContextValue 370322"];
6735 [label="return value; 370323"];
6736 [label="byte? value = nullableContext.GetNullableContextValue(); 370324"];
6737 [label="if (value == null)\n                {\n                    return metadataType;\n                } 370325"];
6738 [label="if (value == null)\n                {\n                    return metadataType;\n                } 370326"];
6739 [label="return metadataType; 370327"];
6740 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 370328"];
6741 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 370329"];
6742 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 370330"];
6743 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol) 370331"];
6744 [label="param DecodeTupleTypesIfApplicable(TypeWithAnnotations metadataType) 370332"];
6745 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 370333"];
6746 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 370334"];
6747 [label="ImmutableArray<string?> elementNames; 370335"];
6748 [label="elementNames 370336"];
6749 [label="containingModule\n                .Module 370337"];
6750 [label="get\n            {\n                return _module;\n            } 370338"];
6751 [label="return _module; 370339"];
6752 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 370340"];
6753 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 370341"];
6754 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 370342"];
6755 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 370343"];
6756 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 370344"];
6757 [label="metadataType.Type 370345"];
6758 [label="=> _extensions?.GetResolvedType(DefaultType) 370346"];
6759 [label="DefaultType 370347"];
6760 [label=".GetResolvedType(DefaultType) 370348"];
6761 [label="param GetResolvedType(TypeSymbol defaultType) 370349"];
6762 [label="=> defaultType 370350"];
6763 [label="defaultType 370351"];
6764 [label="_extensions?.GetResolvedType(DefaultType) 370352"];
6765 [label="TypeSymbol type = metadataType.Type; 370353"];
6766 [label="TypeSymbol decoded = DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute); 370354"];
6767 [label="TypeSymbol decoded = DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute); 370355"];
6768 [label="DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute) 370356"];
6769 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 370357"];
6770 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 370358"];
6771 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 370359"];
6772 [label="RoslynDebug.AssertNotNull(metadataType); 370360"];
6773 [label="RoslynDebug.AssertNotNull(metadataType); 370361"];
6774 [label="var decoder = new TupleTypeDecoder(elementNames); 370362"];
6775 [label="var decoder = new TupleTypeDecoder(elementNames); 370363"];
6776 [label="new TupleTypeDecoder(elementNames) 370364"];
6777 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 370365"];
6778 [label="param TupleTypeDecoder(this) 370366"];
6779 [label="_elementNames 370367"];
6780 [label="elementNames.IsDefault 370368"];
6781 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 370369"];
6782 [label="_namesIndex 370370"];
6783 [label="_decodingFailed = false; 370371"];
6784 [label="_decodingFailed 370372"];
6785 [label="_foundUsableErrorType = false; 370373"];
6786 [label="_foundUsableErrorType 370374"];
6787 [label="var decoded = decoder.DecodeType(metadataType); 370375"];
6788 [label="decoder.DecodeType(metadataType) 370376"];
6789 [label="param DecodeType(TypeSymbol type) 370377"];
6790 [label="param DecodeType(this) 370378"];
6791 [label="type.Kind 370379"];
6792 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 370380"];
6793 [label="switch (type.Kind)\n            {\n                case SymbolKind.ErrorType:\n                    _foundUsableErrorType = true;\n                    return type;\n\n                case SymbolKind.DynamicType:\n                case SymbolKind.TypeParameter:\n                    return type;\n\n                case SymbolKind.FunctionPointerType:\n                    return DecodeFunctionPointerType((FunctionPointerTypeSymbol)type);\n\n                case SymbolKind.PointerType:\n                    return DecodePointerType((PointerTypeSymbol)type);\n\n                case SymbolKind.NamedType:\n                    // We may have a tuple type from a substituted type symbol,\n                    // but it will be missing names from metadata, so we'll\n                    // need to re-create the type.\n                    //\n                    // Consider the declaration\n                    //\n                    //      class C : BaseType<(int x, int y)>\n                    //\n                    // The process for decoding tuples in C looks at the BaseType, calls\n                    // DecodeOrThrow, then passes the decoded type to the TupleTypeDecoder.\n                    // However, DecodeOrThrow uses the AbstractTypeMap to construct a\n                    // SubstitutedTypeSymbol, which eagerly converts tuple-compatible\n                    // types to TupleTypeSymbols. Thus, by the time we get to the Decoder\n                    // all metadata instances of System.ValueTuple will have been\n                    //  replaced with TupleTypeSymbols without names.\n                    // \n                    // Rather than fixing up after-the-fact it's possible that we could\n                    // flow up a SubstituteWith/Without tuple unification to the top level\n                    // of the type map and change DecodeOrThrow to call into the substitution\n                    // without unification instead.\n                    return DecodeNamedType((NamedTypeSymbol)type);\n\n                case SymbolKind.ArrayType:\n                    return DecodeArrayType((ArrayTypeSymbol)type);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);\n            } 370381"];
6794 [label="return DecodeNamedType((NamedTypeSymbol)type); 370382"];
6795 [label="DecodeNamedType((NamedTypeSymbol)type) 370383"];
6796 [label="param DecodeNamedType(NamedTypeSymbol type) 370384"];
6797 [label="param DecodeNamedType(this) 370385"];
6798 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 370386"];
6799 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 370387"];
6800 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 370388"];
6801 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 370389"];
6802 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 370390"];
6803 [label="DecodeTypeArguments(typeArgs) 370391"];
6804 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 370392"];
6805 [label="param DecodeTypeArguments(this) 370393"];
6806 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 370394"];
6807 [label="return typeArgs; 370395"];
6808 [label="NamedTypeSymbol decodedType = type; 370396"];
6809 [label="type.ContainingType 370397"];
6810 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 370398"];
6811 [label="return _container as NamedTypeSymbol; 370399"];
6812 [label="NamedTypeSymbol containingType = type.ContainingType; 370400"];
6813 [label="NamedTypeSymbol? decodedContainingType; 370401"];
6814 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 370402"];
6815 [label="decodedContainingType = containingType; 370403"];
6816 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 370404"];
6817 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 370405"];
6818 [label="var typeArgsChanged = typeArgs != decodedArgs; 370406"];
6819 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 370407"];
6820 [label="decodedType.IsTupleType 370408"];
6821 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 370409"];
6822 [label="_ 370410"];
6823 [label="tupleCardinality: out _ 370411"];
6824 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 370412"];
6825 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 370413"];
6826 [label="param IsTupleTypeOfCardinality(this) 370414"];
6827 [label="IsUnboundGenericType 370415"];
6828 [label="get\n            {\n                return false;\n            } 370416"];
6829 [label="return false; 370417"];
6830 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370418"];
6831 [label="ContainingSymbol 370419"];
6832 [label="get\n            {\n                return _container;\n            } 370420"];
6833 [label="return _container; 370421"];
6834 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370422"];
6835 [label=".Kind 370423"];
6836 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370424"];
6837 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370425"];
6838 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370426"];
6839 [label="ContainingNamespace 370427"];
6840 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 370428"];
6841 [label="get\n            {\n                return _container;\n            } 370429"];
6842 [label="return _container; 370430"];
6843 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370431"];
6844 [label="ContainingNamespace.ContainingNamespace 370432"];
6845 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 370433"];
6846 [label=".IsGlobalNamespace 370434"];
6847 [label="get\n            {\n                return true;\n            } 370435"];
6848 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370436"];
6849 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370437"];
6850 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370438"];
6851 [label="Name 370439"];
6852 [label="get\n            {\n                return _name;\n            } 370440"];
6853 [label="return _name; 370441"];
6854 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370442"];
6855 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370443"];
6856 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370444"];
6857 [label="tupleCardinality = 0; 370445"];
6858 [label="return false; 370446"];
6859 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 370447"];
6860 [label="return decodedType; 370448"];
6861 [label="if (!decoder._decodingFailed)\n            {\n                if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                }\n            } 370449"];
6862 [label="if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                } 370450"];
6863 [label="return decoded; 370451"];
6864 [label="return (object)decoded == (object)type ?\n                metadataType :\n                TypeWithAnnotations.Create(decoded, metadataType.NullableAnnotation, metadataType.CustomModifiers); 370452"];
6865 [label="(object)decoded == (object)type 370453"];
6866 [label="_propertyTypeWithAnnotations 370454"];
6867 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370455"];
6868 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370456"];
6869 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370457"];
6870 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370458"];
6871 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370459"];
6872 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370460"];
6873 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370461"];
6874 [label="DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) 370462"];
6875 [label="param DoSignaturesMatch(PEModule module) 370463"];
6876 [label="param DoSignaturesMatch(MetadataDecoder metadataDecoder) 370464"];
6877 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] propertyParams) 370465"];
6878 [label="param DoSignaturesMatch(PEMethodSymbol getMethod) 370466"];
6879 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] getMethodParams) 370467"];
6880 [label="param DoSignaturesMatch(PEMethodSymbol setMethod) 370468"];
6881 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] setMethodParams) 370469"];
6882 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 370470"];
6883 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 370471"];
6884 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 370472"];
6885 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 370473"];
6886 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 370474"];
6887 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 370475"];
6888 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 370476"];
6889 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 370477"];
6890 [label="bool hasGetMethod = getMethodParams != null; 370478"];
6891 [label="bool hasGetMethod = getMethodParams != null; 370479"];
6892 [label="bool hasSetMethod = setMethodParams != null; 370480"];
6893 [label="bool hasSetMethod = setMethodParams != null; 370481"];
6894 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370482"];
6895 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370483"];
6896 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370484"];
6897 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370485"];
6898 [label="param Equals(ISymbolInternal other) 370486"];
6899 [label="param Equals(TypeCompareKind compareKind) 370487"];
6900 [label="param Equals(this) 370488"];
6901 [label="return this.Equals(other as Symbol, compareKind); 370489"];
6902 [label="return this.Equals(other as Symbol, compareKind); 370490"];
6903 [label="this.Equals(other as Symbol, compareKind) 370491"];
6904 [label="param Equals(Symbol other) 370492"];
6905 [label="param Equals(TypeCompareKind compareKind) 370493"];
6906 [label="param Equals(this) 370494"];
6907 [label="var t2 = other as TypeSymbol; 370495"];
6908 [label="if (t2 is null)\n            {\n                return false;\n            } 370496"];
6909 [label="return this.Equals(t2, compareKind); 370497"];
6910 [label="return this.Equals(t2, compareKind); 370498"];
6911 [label="this.Equals(t2, compareKind) 370499"];
6912 [label="param Equals(TypeSymbol t2) 370500"];
6913 [label="param Equals(TypeCompareKind comparison) 370501"];
6914 [label="param Equals(this) 370502"];
6915 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 370503"];
6916 [label="t2 is NativeIntegerTypeSymbol nativeInteger 370504"];
6917 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 370505"];
6918 [label="base.Equals(t2, comparison) 370506"];
6919 [label="param Equals(TypeSymbol t2) 370507"];
6920 [label="param Equals(TypeCompareKind comparison) 370508"];
6921 [label="param Equals(this) 370509"];
6922 [label="if ((object)t2 == this) return true; 370510"];
6923 [label="return true; 370511"];
6924 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370512"];
6925 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 370513"];
6926 [label="if (hasGetMethod && hasSetMethod)\n            {\n                var lastPropertyParamIndex = propertyParams.Length - 1;\n                var getHandle = getMethodParams[lastPropertyParamIndex].Handle;\n                var setHandle = setMethodParams[lastPropertyParamIndex].Handle;\n                var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle);\n                var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle);\n                if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                }\n\n                if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                }\n            } 370514"];
6927 [label="return true; 370515"];
6928 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370516"];
6929 [label="MustCallMethodsDirectlyCore() 370517"];
6930 [label="param MustCallMethodsDirectlyCore(this) 370518"];
6931 [label="this.RefKind 370519"];
6932 [label="get { return _refKind; } 370520"];
6933 [label="return _refKind; 370521"];
6934 [label="if (this.RefKind != RefKind.None && _setMethod != null)\n            {\n                return true;\n            }\n            else if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 370522"];
6935 [label="this.ParameterCount 370523"];
6936 [label="get\n            {\n                return this.Parameters.Length;\n            } 370524"];
6937 [label="this.Parameters 370525"];
6938 [label="get { return _parameters; } 370526"];
6939 [label="return _parameters; 370527"];
6940 [label="return this.Parameters.Length; 370528"];
6941 [label="if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 370529"];
6942 [label="if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 370530"];
6943 [label="return false; 370531"];
6944 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370532"];
6945 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370533"];
6946 [label="anyUnexpectedRequiredModifiers(propertyParams) 370534"];
6947 [label="static bool anyUnexpectedRequiredModifiers(ParamInfo<TypeSymbol>[] propertyParams)\n            {\n                return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired());\n            } 370535"];
6948 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 370536"];
6949 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 370537"];
6950 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 370538"];
6951 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 370539"];
6952 [label="if (!callMethodsDirectly)\n            {\n                if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                }\n\n                if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                }\n            } 370540"];
6953 [label="if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                } 370541"];
6954 [label="if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                } 370542"];
6955 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 370543"];
6956 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 370544"];
6957 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet) 370545"];
6958 [label="param SetAssociatedProperty(PEPropertySymbol propertySymbol) 370546"];
6959 [label="param SetAssociatedProperty(MethodKind methodKind) 370547"];
6960 [label="param SetAssociatedProperty(this) 370548"];
6961 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 370549"];
6962 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 370550"];
6963 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 370551"];
6964 [label="this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind) 370552"];
6965 [label="param SetAssociatedPropertyOrEvent(Symbol propertyOrEventSymbol) 370553"];
6966 [label="param SetAssociatedPropertyOrEvent(MethodKind methodKind) 370554"];
6967 [label="param SetAssociatedPropertyOrEvent(this) 370555"];
6968 [label="if ((object)_associatedPropertyOrEventOpt == null)\n            {\n                Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2));\n\n                // No locking required since SetAssociatedProperty/SetAssociatedEvent will only be called\n                // by the thread that created the method symbol (and will be called before the method\n                // symbol is added to the containing type members and available to other threads).\n                _associatedPropertyOrEventOpt = propertyOrEventSymbol;\n\n                // NOTE: may be overwriting an existing value.\n                Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation);\n\n                _packedFlags.MethodKind = methodKind;\n                return true;\n            } 370556"];
6969 [label="if ((object)_associatedPropertyOrEventOpt == null)\n            {\n                Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2));\n\n                // No locking required since SetAssociatedProperty/SetAssociatedEvent will only be called\n                // by the thread that created the method symbol (and will be called before the method\n                // symbol is added to the containing type members and available to other threads).\n                _associatedPropertyOrEventOpt = propertyOrEventSymbol;\n\n                // NOTE: may be overwriting an existing value.\n                Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation);\n\n                _packedFlags.MethodKind = methodKind;\n                return true;\n            } 370557"];
6970 [label="propertyOrEventSymbol.ContainingType 370558"];
6971 [label="get\n            {\n                return _containingType;\n            } 370559"];
6972 [label="return _containingType; 370560"];
6973 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 370561"];
6974 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 370562"];
6975 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 370563"];
6976 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 370564"];
6977 [label="param Equals(TypeSymbol left) 370565"];
6978 [label="param Equals(TypeSymbol right) 370566"];
6979 [label="param Equals(TypeCompareKind comparison) 370567"];
6980 [label="if (left is null)\n            {\n                return right is null;\n            } 370568"];
6981 [label="return left.Equals(right, comparison); 370569"];
6982 [label="return left.Equals(right, comparison); 370570"];
6983 [label="left.Equals(right, comparison) 370571"];
6984 [label="param Equals(TypeSymbol t2) 370572"];
6985 [label="param Equals(TypeCompareKind comparison) 370573"];
6986 [label="param Equals(this) 370574"];
6987 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 370575"];
6988 [label="param Equals(TypeCompareKind comparison) 370576"];
6989 [label="param Equals(this) 370577"];
6990 [label="_associatedPropertyOrEventOpt 370578"];
6991 [label="0 370579"];
6992 [label="MethodKindOffset = 0 370580"];
6993 [label="0x1F 370581"];
6994 [label="MethodKindMask = 0x1F 370582"];
6995 [label="0x1 370583"];
6996 [label="5 370584"];
6997 [label="0x1 << 5 370585"];
6998 [label="MethodKindIsPopulatedBit = 0x1 << 5 370586"];
6999 [label="0x1 370587"];
7000 [label="6 370588"];
7001 [label="0x1 << 6 370589"];
7002 [label="IsExtensionMethodBit = 0x1 << 6 370590"];
7003 [label="0x1 370591"];
7004 [label="7 370592"];
7005 [label="0x1 << 7 370593"];
7006 [label="IsExtensionMethodIsPopulatedBit = 0x1 << 7 370594"];
7007 [label="0x1 370595"];
7008 [label="8 370596"];
7009 [label="0x1 << 8 370597"];
7010 [label="IsExplicitFinalizerOverrideBit = 0x1 << 8 370598"];
7011 [label="0x1 370599"];
7012 [label="9 370600"];
7013 [label="0x1 << 9 370601"];
7014 [label="IsExplicitClassOverrideBit = 0x1 << 9 370602"];
7015 [label="0x1 370603"];
7016 [label="10 370604"];
7017 [label="0x1 << 10 370605"];
7018 [label="IsExplicitOverrideIsPopulatedBit = 0x1 << 10 370606"];
7019 [label="0x1 370607"];
7020 [label="11 370608"];
7021 [label="0x1 << 11 370609"];
7022 [label="IsObsoleteAttributePopulatedBit = 0x1 << 11 370610"];
7023 [label="0x1 370611"];
7024 [label="12 370612"];
7025 [label="0x1 << 12 370613"];
7026 [label="IsCustomAttributesPopulatedBit = 0x1 << 12 370614"];
7027 [label="0x1 370615"];
7028 [label="13 370616"];
7029 [label="0x1 << 13 370617"];
7030 [label="IsUseSiteDiagnosticPopulatedBit = 0x1 << 13 370618"];
7031 [label="0x1 370619"];
7032 [label="14 370620"];
7033 [label="0x1 << 14 370621"];
7034 [label="IsConditionalPopulatedBit = 0x1 << 14 370622"];
7035 [label="0x1 370623"];
7036 [label="15 370624"];
7037 [label="0x1 << 15 370625"];
7038 [label="IsOverriddenOrHiddenMembersPopulatedBit = 0x1 << 15 370626"];
7039 [label="0x1 370627"];
7040 [label="16 370628"];
7041 [label="0x1 << 16 370629"];
7042 [label="IsReadOnlyBit = 0x1 << 16 370630"];
7043 [label="0x1 370631"];
7044 [label="17 370632"];
7045 [label="0x1 << 17 370633"];
7046 [label="IsReadOnlyPopulatedBit = 0x1 << 17 370634"];
7047 [label="18 370635"];
7048 [label="NullableContextOffset = 18 370636"];
7049 [label="0x7 370637"];
7050 [label="NullableContextMask = 0x7 370638"];
7051 [label="0x1 370639"];
7052 [label="21 370640"];
7053 [label="0x1 << 21 370641"];
7054 [label="DoesNotReturnBit = 0x1 << 21 370642"];
7055 [label="0x1 370643"];
7056 [label="22 370644"];
7057 [label="0x1 << 22 370645"];
7058 [label="IsDoesNotReturnPopulatedBit = 0x1 << 22 370646"];
7059 [label="0x1 370647"];
7060 [label="23 370648"];
7061 [label="0x1 << 23 370649"];
7062 [label="IsMemberNotNullPopulatedBit = 0x1 << 23 370650"];
7063 [label="0x1 370651"];
7064 [label="24 370652"];
7065 [label="0x1 << 24 370653"];
7066 [label="IsInitOnlyBit = 0x1 << 24 370654"];
7067 [label="0x1 370655"];
7068 [label="25 370656"];
7069 [label="0x1 << 25 370657"];
7070 [label="IsInitOnlyPopulatedBit = 0x1 << 25 370658"];
7071 [label="0x1 370659"];
7072 [label="26 370660"];
7073 [label="0x1 << 26 370661"];
7074 [label="IsUnmanagedCallersOnlyAttributePopulatedBit = 0x1 << 26 370662"];
7075 [label="Debug.Assert(EnumUtilities.ContainsAllValues<MethodKind>(MethodKindMask)); 370663"];
7076 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 370664"];
7077 [label="_packedFlags.MethodKind 370665"];
7078 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 370666"];
7079 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 370667"];
7080 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 370668"];
7081 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 370669"];
7082 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 370670"];
7083 [label="_packedFlags.MethodKind = methodKind 370671"];
7084 [label="_packedFlags.MethodKind = methodKind; 370672"];
7085 [label="set\n                {\n                    Debug.Assert((int)value == ((int)value & MethodKindMask));\n                    _bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit;\n                } 370673"];
7086 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 370674"];
7087 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370675"];
7088 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370676"];
7089 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370677"];
7090 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370678"];
7091 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370679"];
7092 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 370680"];
7093 [label="_bits 370681"];
7094 [label="return true; 370682"];
7095 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 370683"];
7096 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 370684"];
7097 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 370685"];
7098 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 370686"];
7099 [label="if (callMethodsDirectly)\n            {\n                _flags |= Flags.CallMethodsDirectly;\n            } 370687"];
7100 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 370688"];
7101 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 370689"];
7102 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 370690"];
7103 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 370691"];
7104 [label="result.RefKind 370692"];
7105 [label="get { return _refKind; } 370693"];
7106 [label="return _refKind; 370694"];
7107 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 370695"];
7108 [label="result.RefCustomModifiers 370696"];
7109 [label="get { return ImmutableArray<CustomModifier>.Empty; } 370697"];
7110 [label="return ImmutableArray<CustomModifier>.Empty; 370698"];
7111 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 370699"];
7112 [label="result.RefCustomModifiers.HasInAttributeModifier() 370700"];
7113 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 370701"];
7114 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 370702"];
7115 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 370703"];
7116 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 370704"];
7117 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 370705"];
7118 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 370706"];
7119 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 370707"];
7120 [label="return result; 370708"];
7121 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 370709"];
7122 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 370710"];
7123 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 370711"];
7124 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 370712"];
7125 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 370713"];
7126 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers) 370714"];
7127 [label="param CreateEvents(MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols) 370715"];
7128 [label="param CreateEvents(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 370716"];
7129 [label="param CreateEvents(ArrayBuilder<Symbol> members) 370717"];
7130 [label="param CreateEvents(this) 370718"];
7131 [label="this.ContainingPEModule 370719"];
7132 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 370720"];
7133 [label="Symbol s = _container; 370721"];
7134 [label="s.Kind 370722"];
7135 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370723"];
7136 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 370724"];
7137 [label="var moduleSymbol = this.ContainingPEModule; 370725"];
7138 [label="moduleSymbol.Module 370726"];
7139 [label="get\n            {\n                return _module;\n            } 370727"];
7140 [label="var module = moduleSymbol.Module; 370728"];
7141 [label="foreach (var eventRid in module.GetEventsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetEventMethodsOrThrow(eventRid);\n\n                        // NOTE: C# ignores all other accessors (most notably, raise/fire).\n                        PEMethodSymbol addMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Adder);\n                        PEMethodSymbol removeMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Remover);\n\n                        // NOTE: both accessors are required, but that will be reported separately.\n                        // Create the symbol unless both accessors are missing.\n                        if (((object)addMethod != null) || ((object)removeMethod != null))\n                        {\n                            members.Add(new PEEventSymbol(moduleSymbol, this, eventRid, addMethod, removeMethod, privateFieldNameToSymbols));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 370729"];
7142 [label="foreach (var eventRid in module.GetEventsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetEventMethodsOrThrow(eventRid);\n\n                        // NOTE: C# ignores all other accessors (most notably, raise/fire).\n                        PEMethodSymbol addMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Adder);\n                        PEMethodSymbol removeMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Remover);\n\n                        // NOTE: both accessors are required, but that will be reported separately.\n                        // Create the symbol unless both accessors are missing.\n                        if (((object)addMethod != null) || ((object)removeMethod != null))\n                        {\n                            members.Add(new PEEventSymbol(moduleSymbol, this, eventRid, addMethod, removeMethod, privateFieldNameToSymbols));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 370730"];
7143 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 370731"];
7144 [label="foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    } 370732"];
7145 [label="members.AddRange(nonFieldMembers); 370733"];
7146 [label="members.AddRange(nonFieldMembers); 370734"];
7147 [label="nonFieldMembers.Free(); 370735"];
7148 [label="fieldMembers.Free(); 370736"];
7149 [label="methodHandleToSymbol.Free(); 370737"];
7150 [label="int membersCount = members.Count; 370738"];
7151 [label="foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                } 370739"];
7152 [label="new DeclarationOrderTypeSymbolComparer() 370740"];
7153 [label="param DeclarationOrderTypeSymbolComparer(this) 370741"];
7154 [label="Instance = new DeclarationOrderTypeSymbolComparer() 370742"];
7155 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 370743"];
7156 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 370744"];
7157 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 370745"];
7158 [label="Symbol previous = null; 370746"];
7159 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 370747"];
7160 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 370748"];
7161 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 370749"];
7162 [label="previous == null 370750"];
7163 [label="param ==(Symbol left) 370751"];
7164 [label="param ==(Symbol right) 370752"];
7165 [label="if (right is null)\n            {\n                return left is null;\n            } 370753"];
7166 [label="return left is null; 370754"];
7167 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 370755"];
7168 [label="previous = s; 370756"];
7169 [label="param ==(Symbol left) 370757"];
7170 [label="return left is null; 370758"];
7171 [label="Symbol current = s; 370759"];
7172 [label="previous.Kind 370760"];
7173 [label="get\n            {\n                return SymbolKind.Method;\n            } 370761"];
7174 [label="return SymbolKind.Method; 370762"];
7175 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370763"];
7176 [label="current.Kind 370764"];
7177 [label="get\n            {\n                return SymbolKind.Method;\n            } 370765"];
7178 [label="return SymbolKind.Method; 370766"];
7179 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370767"];
7180 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370768"];
7181 [label="previous = current; 370769"];
7182 [label="param ==(Symbol left) 370770"];
7183 [label="return left is null; 370771"];
7184 [label="previous.Kind 370772"];
7185 [label="get\n            {\n                return SymbolKind.Method;\n            } 370773"];
7186 [label="return SymbolKind.Method; 370774"];
7187 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370775"];
7188 [label="current.Kind 370776"];
7189 [label="get\n            {\n                return SymbolKind.Method;\n            } 370777"];
7190 [label="return SymbolKind.Method; 370778"];
7191 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370779"];
7192 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370780"];
7193 [label="get\n            {\n                return SymbolKind.Property;\n            } 370781"];
7194 [label="return SymbolKind.Property; 370782"];
7195 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370783"];
7196 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 370784"];
7197 [label="IsTupleType 370785"];
7198 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 370786"];
7199 [label="_ 370787"];
7200 [label="tupleCardinality: out _ 370788"];
7201 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 370789"];
7202 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 370790"];
7203 [label="param IsTupleTypeOfCardinality(this) 370791"];
7204 [label="IsUnboundGenericType 370792"];
7205 [label="get\n            {\n                return false;\n            } 370793"];
7206 [label="return false; 370794"];
7207 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370795"];
7208 [label="ContainingSymbol 370796"];
7209 [label="get\n            {\n                return _container;\n            } 370797"];
7210 [label="return _container; 370798"];
7211 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370799"];
7212 [label=".Kind 370800"];
7213 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370801"];
7214 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370802"];
7215 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370803"];
7216 [label="ContainingNamespace 370804"];
7217 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 370805"];
7218 [label="get\n            {\n                return _container;\n            } 370806"];
7219 [label="return _container; 370807"];
7220 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370808"];
7221 [label="ContainingNamespace.ContainingNamespace 370809"];
7222 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 370810"];
7223 [label=".IsGlobalNamespace 370811"];
7224 [label="get\n            {\n                return false;\n            } 370812"];
7225 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370813"];
7226 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370814"];
7227 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 370815"];
7228 [label="tupleCardinality = 0; 370816"];
7229 [label="return false; 370817"];
7230 [label="if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                } 370818"];
7231 [label="var membersInDeclarationOrder = members.ToImmutable(); 370819"];
7232 [label="if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                } 370820"];
7233 [label="if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                } 370821"];
7234 [label="members.Clip(membersCount); 370822"];
7235 [label="if (_lazyMembersByName == null)\n            {\n                if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                }\n\n                Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null);\n                if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                }\n            } 370823"];
7236 [label="if (_lazyMembersByName == null)\n            {\n                if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                }\n\n                Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null);\n                if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                }\n            } 370824"];
7237 [label="if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                } 370825"];
7238 [label="Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members); 370826"];
7239 [label="GroupByName(members) 370827"];
7240 [label="param GroupByName(ArrayBuilder<Symbol> symbols) 370828"];
7241 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 370829"];
7242 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 370830"];
7243 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 370831"];
7244 [label="=> _name 370832"];
7245 [label="_name 370833"];
7246 [label="get { return this.IsIndexer ? WellKnownMemberNames.Indexer : _name; } 370834"];
7247 [label="this.IsIndexer 370835"];
7248 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 370836"];
7249 [label="this.ParameterCount 370837"];
7250 [label="get\n            {\n                return this.Parameters.Length;\n            } 370838"];
7251 [label="return _parameters; 370839"];
7252 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 370840"];
7253 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 370841"];
7254 [label="return false; 370842"];
7255 [label="return this.IsIndexer ? WellKnownMemberNames.Indexer : _name; 370843"];
7256 [label="_name 370844"];
7257 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 370845"];
7258 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 370846"];
7259 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 370847"];
7260 [label="if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                } 370848"];
7261 [label="if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                } 370849"];
7262 [label="var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys); 370850"];
7263 [label="Interlocked.Exchange(ref _lazyMemberNames, memberNames); 370851"];
7264 [label="Interlocked.Exchange(ref _lazyMemberNames, memberNames); 370852"];
7265 [label="if (members != null)\n            {\n                members.Free();\n            } 370853"];
7266 [label="if (members != null)\n            {\n                members.Free();\n            } 370854"];
7267 [label="members.Free(); 370855"];
7268 [label="LoadMembers(); 370856"];
7269 [label="EnsureAllMembersAreLoaded(); 370857"];
7270 [label="ImmutableArray<Symbol> m; 370858"];
7271 [label="m 370859"];
7272 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 370860"];
7273 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 370861"];
7274 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 370862"];
7275 [label="ImmutableArray<PENamedTypeSymbol> t; 370863"];
7276 [label="t 370864"];
7277 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 370865"];
7278 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 370866"];
7279 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 370867"];
7280 [label="return m; 370868"];
7281 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 370869"];
7282 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 370870"];
7283 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 370871"];
7284 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 370872"];
7285 [label="GetRuntimeMember(members, descriptor, comparer, accessWithinOpt) 370873"];
7286 [label="param GetRuntimeMember(ImmutableArray<Symbol> members) 370874"];
7287 [label="param GetRuntimeMember(in MemberDescriptor descriptor) 370875"];
7288 [label="param GetRuntimeMember(SignatureComparer<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer) 370876"];
7289 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 370877"];
7290 [label="SymbolKind targetSymbolKind; 370878"];
7291 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 370879"];
7292 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 370880"];
7293 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 370881"];
7294 [label="Symbol? result = null; 370882"];
7295 [label="switch (descriptor.Flags & MemberFlags.KindMask)\n            {\n                case MemberFlags.Constructor:\n                    targetSymbolKind = SymbolKind.Method;\n                    targetMethodKind = MethodKind.Constructor;\n                    //  static constructors are never called explicitly\n                    Debug.Assert(!isStatic);\n                    break;\n\n                case MemberFlags.Method:\n                    targetSymbolKind = SymbolKind.Method;\n                    break;\n\n                case MemberFlags.PropertyGet:\n                    targetSymbolKind = SymbolKind.Method;\n                    targetMethodKind = MethodKind.PropertyGet;\n                    break;\n\n                case MemberFlags.Field:\n                    targetSymbolKind = SymbolKind.Field;\n                    break;\n\n                case MemberFlags.Property:\n                    targetSymbolKind = SymbolKind.Property;\n                    break;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(descriptor.Flags);\n            } 370883"];
7296 [label="targetSymbolKind = SymbolKind.Method; 370884"];
7297 [label="targetMethodKind = MethodKind.Constructor; 370885"];
7298 [label="Debug.Assert(!isStatic); 370886"];
7299 [label="foreach (var member in members)\n            {\n                if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                }\n\n                if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                }\n\n                switch (targetSymbolKind)\n                {\n                    case SymbolKind.Method:\n                        {\n                            MethodSymbol method = (MethodSymbol)member;\n                            MethodKind methodKind = method.MethodKind;\n                            // Treat user-defined conversions and operators as ordinary methods for the purpose\n                            // of matching them here.\n                            if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            }\n\n                            if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Property:\n                        {\n                            PropertySymbol property = (PropertySymbol)member;\n                            if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Field:\n                        if (!comparer.MatchFieldSignature((FieldSymbol)member, descriptor.Signature))\n                        {\n                            continue;\n                        }\n\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(targetSymbolKind);\n                }\n\n                // ambiguity\n                if (result is object)\n                {\n                    result = null;\n                    break;\n                }\n\n                result = member;\n            } 370887"];
7300 [label="member.Name 370888"];
7301 [label="_name 370889"];
7302 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 370890"];
7303 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 370891"];
7304 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 370892"];
7305 [label="member.Kind 370893"];
7306 [label="get\n            {\n                return SymbolKind.Method;\n            } 370894"];
7307 [label="return SymbolKind.Method; 370895"];
7308 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370896"];
7309 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370897"];
7310 [label="member.IsStatic 370898"];
7311 [label="=> HasFlag(MethodAttributes.Static) 370899"];
7312 [label="MethodAttributes.Static 370900"];
7313 [label="HasFlag(MethodAttributes.Static) 370901"];
7314 [label="param HasFlag(MethodAttributes flag) 370902"];
7315 [label="param HasFlag(this) 370903"];
7316 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370904"];
7317 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370905"];
7318 [label="return ((ushort)flag & _flags) != 0; 370906"];
7319 [label="return ((ushort)flag & _flags) != 0; 370907"];
7320 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370908"];
7321 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370909"];
7322 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370910"];
7323 [label="member.DeclaredAccessibility 370911"];
7324 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 370912"];
7325 [label="Flags 370913"];
7326 [label="=> (MethodAttributes)_flags 370914"];
7327 [label="(MethodAttributes)_flags 370915"];
7328 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 370916"];
7329 [label="return Accessibility.Public; 370917"];
7330 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370918"];
7331 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 370919"];
7332 [label="switch (targetSymbolKind)\n                {\n                    case SymbolKind.Method:\n                        {\n                            MethodSymbol method = (MethodSymbol)member;\n                            MethodKind methodKind = method.MethodKind;\n                            // Treat user-defined conversions and operators as ordinary methods for the purpose\n                            // of matching them here.\n                            if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            }\n\n                            if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Property:\n                        {\n                            PropertySymbol property = (PropertySymbol)member;\n                            if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Field:\n                        if (!comparer.MatchFieldSignature((FieldSymbol)member, descriptor.Signature))\n                        {\n                            continue;\n                        }\n\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(targetSymbolKind);\n                } 370920"];
7333 [label="MethodSymbol method = (MethodSymbol)member; 370921"];
7334 [label="method.MethodKind 370922"];
7335 [label="get\n            {\n                if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                }\n                return _packedFlags.MethodKind;\n            } 370923"];
7336 [label="_packedFlags.MethodKindIsPopulated 370924"];
7337 [label="=> (_bits & MethodKindIsPopulatedBit) != 0 370925"];
7338 [label="_bits & MethodKindIsPopulatedBit 370926"];
7339 [label="0 370927"];
7340 [label="(_bits & MethodKindIsPopulatedBit) != 0 370928"];
7341 [label="if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                } 370929"];
7342 [label="this.ComputeMethodKind() 370930"];
7343 [label="param ComputeMethodKind(this) 370931"];
7344 [label="this.HasSpecialName 370932"];
7345 [label="=> HasFlag(MethodAttributes.SpecialName) 370933"];
7346 [label="MethodAttributes.SpecialName 370934"];
7347 [label="HasFlag(MethodAttributes.SpecialName) 370935"];
7348 [label="param HasFlag(MethodAttributes flag) 370936"];
7349 [label="param HasFlag(this) 370937"];
7350 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370938"];
7351 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370939"];
7352 [label="return ((ushort)flag & _flags) != 0; 370940"];
7353 [label="return ((ushort)flag & _flags) != 0; 370941"];
7354 [label="if (this.HasSpecialName)\n            {\n                if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                }\n\n                if (!this.HasRuntimeSpecialName && this.IsStatic && this.DeclaredAccessibility == Accessibility.Public)\n                {\n                    switch (_name)\n                    {\n                        case WellKnownMemberNames.AdditionOperatorName:\n                        case WellKnownMemberNames.BitwiseAndOperatorName:\n                        case WellKnownMemberNames.BitwiseOrOperatorName:\n                        case WellKnownMemberNames.DivisionOperatorName:\n                        case WellKnownMemberNames.EqualityOperatorName:\n                        case WellKnownMemberNames.ExclusiveOrOperatorName:\n                        case WellKnownMemberNames.GreaterThanOperatorName:\n                        case WellKnownMemberNames.GreaterThanOrEqualOperatorName:\n                        case WellKnownMemberNames.InequalityOperatorName:\n                        case WellKnownMemberNames.LeftShiftOperatorName:\n                        case WellKnownMemberNames.LessThanOperatorName:\n                        case WellKnownMemberNames.LessThanOrEqualOperatorName:\n                        case WellKnownMemberNames.ModulusOperatorName:\n                        case WellKnownMemberNames.MultiplyOperatorName:\n                        case WellKnownMemberNames.RightShiftOperatorName:\n                        case WellKnownMemberNames.SubtractionOperatorName:\n                            return IsValidUserDefinedOperatorSignature(2) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;\n                        case WellKnownMemberNames.DecrementOperatorName:\n                        case WellKnownMemberNames.FalseOperatorName:\n                        case WellKnownMemberNames.IncrementOperatorName:\n                        case WellKnownMemberNames.LogicalNotOperatorName:\n                        case WellKnownMemberNames.OnesComplementOperatorName:\n                        case WellKnownMemberNames.TrueOperatorName:\n                        case WellKnownMemberNames.UnaryNegationOperatorName:\n                        case WellKnownMemberNames.UnaryPlusOperatorName:\n                            return IsValidUserDefinedOperatorSignature(1) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;\n                        case WellKnownMemberNames.ImplicitConversionName:\n                        case WellKnownMemberNames.ExplicitConversionName:\n                            return IsValidUserDefinedOperatorSignature(1) ? MethodKind.Conversion : MethodKind.Ordinary;\n\n                            //case WellKnownMemberNames.ConcatenateOperatorName:\n                            //case WellKnownMemberNames.ExponentOperatorName:\n                            //case WellKnownMemberNames.IntegerDivisionOperatorName:\n                            //case WellKnownMemberNames.LikeOperatorName:\n                            //// Non-C#-supported overloaded operator\n                            //return MethodKind.Ordinary;\n                    }\n\n                    return MethodKind.Ordinary;\n                }\n            } 370942"];
7355 [label="if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                } 370943"];
7356 [label="if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                } 370944"];
7357 [label="Flags 370945"];
7358 [label="=> (MethodAttributes)_flags 370946"];
7359 [label="(MethodAttributes)_flags 370947"];
7360 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 370948"];
7361 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 370949"];
7362 [label="this.IsStatic 370950"];
7363 [label="=> HasFlag(MethodAttributes.Static) 370951"];
7364 [label="MethodAttributes.Static 370952"];
7365 [label="HasFlag(MethodAttributes.Static) 370953"];
7366 [label="param HasFlag(MethodAttributes flag) 370954"];
7367 [label="param HasFlag(this) 370955"];
7368 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370956"];
7369 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 370957"];
7370 [label="return ((ushort)flag & _flags) != 0; 370958"];
7371 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 370959"];
7372 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 370960"];
7373 [label="this.ReturnsVoid 370961"];
7374 [label="=> this.ReturnType.IsVoidType() 370962"];
7375 [label="this.ReturnType 370963"];
7376 [label="=> ReturnTypeWithAnnotations.Type 370964"];
7377 [label="ReturnTypeWithAnnotations 370965"];
7378 [label="=> Signature.ReturnParam.TypeWithAnnotations 370966"];
7379 [label="Signature 370967"];
7380 [label="=> _lazySignature ?? LoadSignature() 370968"];
7381 [label="LoadSignature() 370969"];
7382 [label="param LoadSignature(this) 370970"];
7383 [label="_containingType.ContainingPEModule 370971"];
7384 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 370972"];
7385 [label="s.Kind 370973"];
7386 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 370974"];
7387 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 370975"];
7388 [label="var moduleSymbol = _containingType.ContainingPEModule; 370976"];
7389 [label="SignatureHeader signatureHeader; 370977"];
7390 [label="signatureHeader 370978"];
7391 [label="BadImageFormatException mrEx; 370979"];
7392 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 370980"];
7393 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 370981"];
7394 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 370982"];
7395 [label="new MetadataDecoder(moduleSymbol, this) 370983"];
7396 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 370984"];
7397 [label="param MetadataDecoder(PEMethodSymbol context) 370985"];
7398 [label="param MetadataDecoder(this) 370986"];
7399 [label="moduleSymbol 370987"];
7400 [label="context.ContainingType 370988"];
7401 [label="=> _containingType 370989"];
7402 [label="_containingType 370990"];
7403 [label="context 370991"];
7404 [label="param MetadataDecoder(this) 370992"];
7405 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 370993"];
7406 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 370994"];
7407 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 370995"];
7408 [label="Debug.Assert((object)moduleSymbol != null); 370996"];
7409 [label="Debug.Assert((object)moduleSymbol != null); 370997"];
7410 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 370998"];
7411 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 370999"];
7412 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 371000"];
7413 [label="param GetSpecialType(this) 371001"];
7414 [label="this.Modules 371002"];
7415 [label="get\n            {\n                return _modules;\n            } 371003"];
7416 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 371004"];
7417 [label="module.GetReferencedAssemblies() 371005"];
7418 [label="param GetReferencedAssemblies(this) 371006"];
7419 [label="AssertReferencesInitialized() 371007"];
7420 [label="param AssertReferencesInitialized(this) 371008"];
7421 [label="Debug.Assert(_moduleReferences != null); 371009"];
7422 [label="Debug.Assert(_moduleReferences != null); 371010"];
7423 [label="AssertReferencesInitialized(); 371011"];
7424 [label="return _moduleReferences.Identities; 371012"];
7425 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 371013"];
7426 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 371014"];
7427 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 371015"];
7428 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 371016"];
7429 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 371017"];
7430 [label="bool makeBad = (mrEx != null); 371018"];
7431 [label="bool makeBad = (mrEx != null); 371019"];
7432 [label="if (!signatureHeader.IsGeneric &&\n                _lazyTypeParameters.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty);\n            } 371020"];
7433 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty); 371021"];
7434 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty); 371022"];
7435 [label="int count = paramInfo.Length - 1; 371023"];
7436 [label="int count = paramInfo.Length - 1; 371024"];
7437 [label="ImmutableArray<ParameterSymbol> @params; 371025"];
7438 [label="@params 371026"];
7439 [label="bool isBadParameter; 371027"];
7440 [label="if (count > 0)\n            {\n                var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count);\n                for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                }\n\n                @params = builder.ToImmutable();\n            }\n            else\n            {\n                @params = ImmutableArray<ParameterSymbol>.Empty;\n            } 371028"];
7441 [label="if (count > 0)\n            {\n                var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count);\n                for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                }\n\n                @params = builder.ToImmutable();\n            }\n            else\n            {\n                @params = ImmutableArray<ParameterSymbol>.Empty;\n            } 371029"];
7442 [label="var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count); 371030"];
7443 [label="for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                } 371031"];
7444 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371032"];
7445 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371033"];
7446 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371034"];
7447 [label="this.IsMetadataVirtual() 371035"];
7448 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 371036"];
7449 [label="=> HasFlag(MethodAttributes.Virtual) 371037"];
7450 [label="MethodAttributes.Virtual 371038"];
7451 [label="HasFlag(MethodAttributes.Virtual) 371039"];
7452 [label="param HasFlag(MethodAttributes flag) 371040"];
7453 [label="param HasFlag(this) 371041"];
7454 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371042"];
7455 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371043"];
7456 [label="return ((ushort)flag & _flags) != 0; 371044"];
7457 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371045"];
7458 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371046"];
7459 [label="PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter) 371047"];
7460 [label="param Create(PEModuleSymbol moduleSymbol) 371048"];
7461 [label="param Create(PEMethodSymbol containingSymbol) 371049"];
7462 [label="param Create(bool isContainingSymbolVirtual) 371050"];
7463 [label="param Create(int ordinal) 371051"];
7464 [label="param Create(ParamInfo<TypeSymbol> parameterInfo) 371052"];
7465 [label="param Create(Symbol nullableContext) 371053"];
7466 [label="param Create(bool isReturn) 371054"];
7467 [label="param Create(out bool isBad) 371055"];
7468 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371056"];
7469 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371057"];
7470 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371058"];
7471 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371059"];
7472 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371060"];
7473 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371061"];
7474 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371062"];
7475 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371063"];
7476 [label="Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad) 371064"];
7477 [label="param Create(PEModuleSymbol moduleSymbol) 371065"];
7478 [label="param Create(Symbol containingSymbol) 371066"];
7479 [label="param Create(bool isContainingSymbolVirtual) 371067"];
7480 [label="param Create(int ordinal) 371068"];
7481 [label="param Create(bool isByRef) 371069"];
7482 [label="param Create(ImmutableArray<ModifierInfo<TypeSymbol>> refCustomModifiers) 371070"];
7483 [label="param Create(TypeSymbol type) 371071"];
7484 [label="param Create(ParameterHandle handle) 371072"];
7485 [label="param Create(Symbol nullableContext) 371073"];
7486 [label="param Create(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 371074"];
7487 [label="param Create(bool isReturn) 371075"];
7488 [label="param Create(out bool isBad) 371076"];
7489 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371077"];
7490 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371078"];
7491 [label="CSharpCustomModifier.Convert(customModifiers) 371079"];
7492 [label="param Convert(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 371080"];
7493 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371081"];
7494 [label="TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)) 371082"];
7495 [label="param Create(TypeSymbol typeSymbol) 371083"];
7496 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 371084"];
7497 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 371085"];
7498 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 371086"];
7499 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 371087"];
7500 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 371088"];
7501 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 371089"];
7502 [label="typeSymbol.IsNullableType() 371090"];
7503 [label="param IsNullableType(this TypeSymbol type) 371091"];
7504 [label="type.OriginalDefinition 371092"];
7505 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371093"];
7506 [label="OriginalTypeSymbolDefinition 371094"];
7507 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371095"];
7508 [label="this.OriginalDefinition 371096"];
7509 [label="get\n            {\n                return this;\n            } 371097"];
7510 [label="return this; 371098"];
7511 [label="return this.OriginalDefinition; 371099"];
7512 [label="return OriginalTypeSymbolDefinition; 371100"];
7513 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 371101"];
7514 [label="type.OriginalDefinition.SpecialType 371102"];
7515 [label="get\n            {\n                return _corTypeId;\n            } 371103"];
7516 [label="var a1 = defaultType is null; 371104"];
7517 [label="!a1 371105"];
7518 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 371106"];
7519 [label="defaultType.IsNullableType() 371107"];
7520 [label="param IsNullableType(this TypeSymbol type) 371108"];
7521 [label="type.OriginalDefinition 371109"];
7522 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371110"];
7523 [label="OriginalTypeSymbolDefinition 371111"];
7524 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371112"];
7525 [label="this.OriginalDefinition 371113"];
7526 [label="get\n            {\n                return this;\n            } 371114"];
7527 [label="return this; 371115"];
7528 [label="return this.OriginalDefinition; 371116"];
7529 [label="return OriginalTypeSymbolDefinition; 371117"];
7530 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 371118"];
7531 [label="type.OriginalDefinition.SpecialType 371119"];
7532 [label="get\n            {\n                return _corTypeId;\n            } 371120"];
7533 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 371121"];
7534 [label="Debug.Assert(a1 || a2 != true || a3); 371122"];
7535 [label="Debug.Assert(a1 || a2 != true || a3); 371123"];
7536 [label="Debug.Assert(extensions != null); 371124"];
7537 [label="Debug.Assert(extensions != null); 371125"];
7538 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371126"];
7539 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371127"];
7540 [label="customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty 371128"];
7541 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371129"];
7542 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371130"];
7543 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371131"];
7544 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371132"];
7545 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371133"];
7546 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371134"];
7547 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371135"];
7548 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371136"];
7549 [label="new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad) 371137"];
7550 [label="param PEParameterSymbol(PEModuleSymbol moduleSymbol) 371138"];
7551 [label="param PEParameterSymbol(Symbol containingSymbol) 371139"];
7552 [label="param PEParameterSymbol(int ordinal) 371140"];
7553 [label="param PEParameterSymbol(bool isByRef) 371141"];
7554 [label="param PEParameterSymbol(TypeWithAnnotations typeWithAnnotations) 371142"];
7555 [label="param PEParameterSymbol(ParameterHandle handle) 371143"];
7556 [label="param PEParameterSymbol(Symbol nullableContext) 371144"];
7557 [label="param PEParameterSymbol(int countOfCustomModifiers) 371145"];
7558 [label="param PEParameterSymbol(out bool isBad) 371146"];
7559 [label="param PEParameterSymbol(this) 371147"];
7560 [label="'value' 371148"];
7561 [label="ValueParameterName = 'value' 371149"];
7562 [label="param PEParameterSymbol(this) 371150"];
7563 [label="param ParameterSymbol(this) 371151"];
7564 [label="param ParameterSymbol(this) 371152"];
7565 [label="_lazyAdapter 371153"];
7566 [label="_containingSymbol 371154"];
7567 [label="_name 371155"];
7568 [label="_flags 371156"];
7569 [label="_moduleSymbol 371157"];
7570 [label="_lazyDefaultValue = ConstantValue.Unset 371158"];
7571 [label="_lazyIsParams 371159"];
7572 [label="_ordinal 371160"];
7573 [label="Debug.Assert((object)moduleSymbol != null); 371161"];
7574 [label="Debug.Assert((object)moduleSymbol != null); 371162"];
7575 [label="Debug.Assert((object)containingSymbol != null); 371163"];
7576 [label="Debug.Assert((object)containingSymbol != null); 371164"];
7577 [label="Debug.Assert(ordinal >= 0); 371165"];
7578 [label="Debug.Assert(ordinal >= 0); 371166"];
7579 [label="typeWithAnnotations.HasType 371167"];
7580 [label="=> !(DefaultType is null) 371168"];
7581 [label="DefaultType is null 371169"];
7582 [label="!(DefaultType is null) 371170"];
7583 [label="Debug.Assert(typeWithAnnotations.HasType); 371171"];
7584 [label="isBad = false; 371172"];
7585 [label="_moduleSymbol 371173"];
7586 [label="_containingSymbol 371174"];
7587 [label="_ordinal 371175"];
7588 [label="_handle 371176"];
7589 [label="RefKind refKind = RefKind.None; 371177"];
7590 [label="if (handle.IsNil)\n            {\n                refKind = isByRef ? RefKind.Ref : RefKind.None;\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                }\n                _lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                _lazyHiddenAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                _lazyDefaultValue = ConstantValue.NotAvailable;\n                _lazyIsParams = ThreeState.False;\n            }\n            else\n            {\n                try\n                {\n                    moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags);\n                }\n                catch (BadImageFormatException)\n                {\n                    isBad = true;\n                }\n\n                if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                }\n\n                var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind);\n                typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol);\n                typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers);\n                // Decode nullable before tuple types to avoid converting between\n                // NamedTypeSymbol and TupleTypeSymbol unnecessarily.\n\n                // The containing type is passed to NullableTypeDecoder.TransformType to determine access\n                // for property parameters because the property does not have explicit accessibility in metadata.\n                var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol;\n                typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext);\n                typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol);\n            } 371178"];
7591 [label="moduleSymbol.Module 371179"];
7592 [label="get\n            {\n                return _module;\n            } 371180"];
7593 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 371181"];
7594 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 371182"];
7595 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 371183"];
7596 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 371184"];
7597 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 371185"];
7598 [label="if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                } 371186"];
7599 [label="typeWithAnnotations.Type 371187"];
7600 [label="=> _extensions?.GetResolvedType(DefaultType) 371188"];
7601 [label="DefaultType 371189"];
7602 [label="=> defaultType 371190"];
7603 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 371191"];
7604 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 371192"];
7605 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 371193"];
7606 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 371194"];
7607 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 371195"];
7608 [label="DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind) 371196"];
7609 [label="param TransformType(TypeSymbol metadataType) 371197"];
7610 [label="param TransformType(int targetSymbolCustomModifierCount) 371198"];
7611 [label="param TransformType(EntityHandle targetSymbolToken) 371199"];
7612 [label="param TransformType(PEModuleSymbol containingModule) 371200"];
7613 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 371201"];
7614 [label="Debug.Assert((object)metadataType != null); 371202"];
7615 [label="Debug.Assert((object)metadataType != null); 371203"];
7616 [label="return _module; 371204"];
7617 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 371205"];
7618 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 371206"];
7619 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 371207"];
7620 [label="NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol) 371208"];
7621 [label="param TransformType(TypeSymbol type) 371209"];
7622 [label="param TransformType(EntityHandle handle) 371210"];
7623 [label="param TransformType(PEModuleSymbol containingModule) 371211"];
7624 [label="return _module; 371212"];
7625 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 371213"];
7626 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 371214"];
7627 [label="typeWithAnnotations.CustomModifiers 371215"];
7628 [label="=> _extensions.CustomModifiers 371216"];
7629 [label="_extensions.CustomModifiers 371217"];
7630 [label="=> _customModifiers 371218"];
7631 [label="_customModifiers 371219"];
7632 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 371220"];
7633 [label="typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers) 371221"];
7634 [label="param WithTypeAndModifiers(TypeSymbol typeSymbol) 371222"];
7635 [label="param WithTypeAndModifiers(ImmutableArray<CustomModifier> customModifiers) 371223"];
7636 [label="=>\n            _extensions.WithTypeAndModifiers(this, typeSymbol, customModifiers) 371224"];
7637 [label="this 371225"];
7638 [label="typeSymbol 371226"];
7639 [label="customModifiers 371227"];
7640 [label="_extensions.WithTypeAndModifiers(this, typeSymbol, customModifiers) 371228"];
7641 [label="param WithTypeAndModifiers(TypeWithAnnotations type) 371229"];
7642 [label="param WithTypeAndModifiers(TypeSymbol typeSymbol) 371230"];
7643 [label="param WithTypeAndModifiers(ImmutableArray<CustomModifier> customModifiers) 371231"];
7644 [label="param WithTypeAndModifiers(this) 371232"];
7645 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 371233"];
7646 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 371234"];
7647 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 371235"];
7648 [label="CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers) 371236"];
7649 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 371237"];
7650 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 371238"];
7651 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 371239"];
7652 [label="var a1 = defaultType is null; 371240"];
7653 [label="!a1 371241"];
7654 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 371242"];
7655 [label="defaultType.IsNullableType() 371243"];
7656 [label="param IsNullableType(this TypeSymbol type) 371244"];
7657 [label="type.OriginalDefinition 371245"];
7658 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371246"];
7659 [label="OriginalTypeSymbolDefinition 371247"];
7660 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371248"];
7661 [label="this.OriginalDefinition 371249"];
7662 [label="get\n            {\n                return this;\n            } 371250"];
7663 [label="return this; 371251"];
7664 [label="return this.OriginalDefinition; 371252"];
7665 [label="return OriginalTypeSymbolDefinition; 371253"];
7666 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 371254"];
7667 [label="type.OriginalDefinition.SpecialType 371255"];
7668 [label="get\n            {\n                return _corTypeId;\n            } 371256"];
7669 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 371257"];
7670 [label="Debug.Assert(a1 || a2 != true || a3); 371258"];
7671 [label="Debug.Assert(a1 || a2 != true || a3); 371259"];
7672 [label="Debug.Assert(extensions != null); 371260"];
7673 [label="Debug.Assert(extensions != null); 371261"];
7674 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 371262"];
7675 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 371263"];
7676 [label="containingSymbol.Kind 371264"];
7677 [label="get\n            {\n                return SymbolKind.Method;\n            } 371265"];
7678 [label="return SymbolKind.Method; 371266"];
7679 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 371267"];
7680 [label="containingSymbol.Kind == SymbolKind.Property 371268"];
7681 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 371269"];
7682 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 371270"];
7683 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 371271"];
7684 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 371272"];
7685 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 371273"];
7686 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 371274"];
7687 [label="NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext) 371275"];
7688 [label="param TransformType(TypeWithAnnotations metadataType) 371276"];
7689 [label="param TransformType(EntityHandle targetSymbolToken) 371277"];
7690 [label="param TransformType(PEModuleSymbol containingModule) 371278"];
7691 [label="param TransformType(Symbol accessSymbol) 371279"];
7692 [label="param TransformType(Symbol nullableContext) 371280"];
7693 [label="metadataType.HasType 371281"];
7694 [label="=> !(DefaultType is null) 371282"];
7695 [label="DefaultType is null 371283"];
7696 [label="!(DefaultType is null) 371284"];
7697 [label="Debug.Assert(metadataType.HasType); 371285"];
7698 [label="accessSymbol.IsDefinition 371286"];
7699 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 371287"];
7700 [label="OriginalDefinition 371288"];
7701 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 371289"];
7702 [label="OriginalSymbolDefinition 371290"];
7703 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371291"];
7704 [label="this.OriginalDefinition 371292"];
7705 [label="get\n            {\n                return this;\n            } 371293"];
7706 [label="return this; 371294"];
7707 [label="return this.OriginalDefinition; 371295"];
7708 [label="return OriginalSymbolDefinition; 371296"];
7709 [label="return (object)this == (object)OriginalDefinition; 371297"];
7710 [label="Debug.Assert(accessSymbol.IsDefinition); 371298"];
7711 [label="accessSymbol.ContainingModule 371299"];
7712 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 371300"];
7713 [label="this.ContainingSymbol 371301"];
7714 [label="=> _containingType 371302"];
7715 [label="_containingType 371303"];
7716 [label="var container = this.ContainingSymbol; 371304"];
7717 [label="return (object)container != null ? container.ContainingModule : null; 371305"];
7718 [label="return (object)container != null ? container.ContainingModule : null; 371306"];
7719 [label="(object)container != null 371307"];
7720 [label="container.ContainingModule 371308"];
7721 [label="get\n            {\n                return ContainingPEModule;\n            } 371309"];
7722 [label="ContainingPEModule 371310"];
7723 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 371311"];
7724 [label="s.Kind 371312"];
7725 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 371313"];
7726 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 371314"];
7727 [label="return ContainingPEModule; 371315"];
7728 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 371316"];
7729 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 371317"];
7730 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 371318"];
7731 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 371319"];
7732 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 371320"];
7733 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 371321"];
7734 [label="Debug.Assert(symbol is object); 371322"];
7735 [label="symbol.Kind 371323"];
7736 [label="get\n            {\n                return SymbolKind.Method;\n            } 371324"];
7737 [label="return SymbolKind.Method; 371325"];
7738 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 371326"];
7739 [label="isInternal = false; 371327"];
7740 [label="symbol.DeclaredAccessibility 371328"];
7741 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 371329"];
7742 [label="Flags 371330"];
7743 [label="=> (MethodAttributes)_flags 371331"];
7744 [label="(MethodAttributes)_flags 371332"];
7745 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 371333"];
7746 [label="return Accessibility.Public; 371334"];
7747 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 371335"];
7748 [label="symbol.ContainingType 371336"];
7749 [label="=> _containingType 371337"];
7750 [label="_containingType 371338"];
7751 [label="symbol = symbol.ContainingType; 371339"];
7752 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 371340"];
7753 [label="symbol.DeclaredAccessibility 371341"];
7754 [label="Accessibility access = Accessibility.Private; 371342"];
7755 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 371343"];
7756 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 371344"];
7757 [label="return _container as NamedTypeSymbol; 371345"];
7758 [label="return true; 371346"];
7759 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 371347"];
7760 [label="return _module; 371348"];
7761 [label="param GetNullableContextValue(this) 371349"];
7762 [label="byte? value; 371350"];
7763 [label="if (!_packedFlags.TryGetNullableContext(out value))\n            {\n                value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue();\n                _packedFlags.SetNullableContext(value);\n            } 371351"];
7764 [label="_packedFlags.TryGetNullableContext(out value) 371352"];
7765 [label="param TryGetNullableContext(out byte? value) 371353"];
7766 [label="param TryGetNullableContext(this) 371354"];
7767 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 371355"];
7768 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 371356"];
7769 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 371357"];
7770 [label="((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value) 371358"];
7771 [label="param TryGetByte(this NullableContextKind kind) 371359"];
7772 [label="param TryGetByte(out byte? value) 371360"];
7773 [label="value = null; 371361"];
7774 [label="if (!_packedFlags.TryGetNullableContext(out value))\n            {\n                value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue();\n                _packedFlags.SetNullableContext(value);\n            } 371362"];
7775 [label="_containingType.ContainingPEModule 371363"];
7776 [label="s.Kind 371364"];
7777 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 371365"];
7778 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 371366"];
7779 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 371367"];
7780 [label="_containingType.ContainingPEModule.Module 371368"];
7781 [label="get\n            {\n                return _module;\n            } 371369"];
7782 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 371370"];
7783 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 371371"];
7784 [label="_containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 371372"];
7785 [label="_containingType.GetNullableContextValue() 371373"];
7786 [label="byte? value; 371374"];
7787 [label="param TryGetByte(out byte? value) 371375"];
7788 [label="value = null; 371376"];
7789 [label="return true; 371377"];
7790 [label="_packedFlags.SetNullableContext(value); 371378"];
7791 [label="_packedFlags.SetNullableContext(value) 371379"];
7792 [label="param SetNullableContext(byte? value) 371380"];
7793 [label="param SetNullableContext(this) 371381"];
7794 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 371382"];
7795 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 371383"];
7796 [label="value.ToNullableContextFlags() 371384"];
7797 [label="param ToNullableContextFlags(this byte? value) 371385"];
7798 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 371386"];
7799 [label="return value; 371387"];
7800 [label="return metadataType; 371388"];
7801 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 371389"];
7802 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 371390"];
7803 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 371391"];
7804 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol) 371392"];
7805 [label="param DecodeTupleTypesIfApplicable(TypeWithAnnotations metadataType) 371393"];
7806 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 371394"];
7807 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 371395"];
7808 [label="return _module; 371396"];
7809 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 371397"];
7810 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 371398"];
7811 [label="DefaultType 371399"];
7812 [label="=> defaultType 371400"];
7813 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 371401"];
7814 [label="RoslynDebug.AssertNotNull(metadataType); 371402"];
7815 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 371403"];
7816 [label="_elementNames 371404"];
7817 [label="elementNames.IsDefault 371405"];
7818 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 371406"];
7819 [label="_namesIndex 371407"];
7820 [label="_foundUsableErrorType = false; 371408"];
7821 [label="_foundUsableErrorType 371409"];
7822 [label="param DecodeType(this) 371410"];
7823 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 371411"];
7824 [label="param DecodeNamedType(this) 371412"];
7825 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 371413"];
7826 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 371414"];
7827 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 371415"];
7828 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 371416"];
7829 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 371417"];
7830 [label="DecodeTypeArguments(typeArgs) 371418"];
7831 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 371419"];
7832 [label="param DecodeTypeArguments(this) 371420"];
7833 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 371421"];
7834 [label="return typeArgs; 371422"];
7835 [label="type.ContainingType 371423"];
7836 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 371424"];
7837 [label="return _container as NamedTypeSymbol; 371425"];
7838 [label="NamedTypeSymbol containingType = type.ContainingType; 371426"];
7839 [label="NamedTypeSymbol? decodedContainingType; 371427"];
7840 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 371428"];
7841 [label="decodedContainingType = containingType; 371429"];
7842 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 371430"];
7843 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 371431"];
7844 [label="var typeArgsChanged = typeArgs != decodedArgs; 371432"];
7845 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 371433"];
7846 [label="decodedType.IsTupleType 371434"];
7847 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 371435"];
7848 [label="_ 371436"];
7849 [label="tupleCardinality: out _ 371437"];
7850 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 371438"];
7851 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 371439"];
7852 [label="param IsTupleTypeOfCardinality(this) 371440"];
7853 [label="IsUnboundGenericType 371441"];
7854 [label="get\n            {\n                return false;\n            } 371442"];
7855 [label="return false; 371443"];
7856 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371444"];
7857 [label="ContainingSymbol 371445"];
7858 [label="get\n            {\n                return _container;\n            } 371446"];
7859 [label="return _container; 371447"];
7860 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371448"];
7861 [label=".Kind 371449"];
7862 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 371450"];
7863 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371451"];
7864 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371452"];
7865 [label="ContainingNamespace 371453"];
7866 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 371454"];
7867 [label="get\n            {\n                return _container;\n            } 371455"];
7868 [label="return _container; 371456"];
7869 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371457"];
7870 [label="ContainingNamespace.ContainingNamespace 371458"];
7871 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 371459"];
7872 [label=".IsGlobalNamespace 371460"];
7873 [label="get\n            {\n                return true;\n            } 371461"];
7874 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371462"];
7875 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371463"];
7876 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371464"];
7877 [label="Name 371465"];
7878 [label="get\n            {\n                return _name;\n            } 371466"];
7879 [label="return _name; 371467"];
7880 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371468"];
7881 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371469"];
7882 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 371470"];
7883 [label="tupleCardinality = 0; 371471"];
7884 [label="return false; 371472"];
7885 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 371473"];
7886 [label="return decoded; 371474"];
7887 [label="_typeWithAnnotations 371475"];
7888 [label="bool hasNameInMetadata = !string.IsNullOrEmpty(_name); 371476"];
7889 [label="if (!hasNameInMetadata)\n            {\n                // As was done historically, if the parameter doesn't have a name, we give it the name 'value'.\n                _name = 'value';\n            } 371477"];
7890 [label="0 371478"];
7891 [label="WellKnownAttributeDataOffset = 0 371479"];
7892 [label="8 371480"];
7893 [label="WellKnownAttributeCompletionFlagOffset = 8 371481"];
7894 [label="16 371482"];
7895 [label="RefKindOffset = 16 371483"];
7896 [label="20 371484"];
7897 [label="FlowAnalysisAnnotationsOffset = 20 371485"];
7898 [label="0x3 371486"];
7899 [label="RefKindMask = 0x3 371487"];
7900 [label="0xFF 371488"];
7901 [label="WellKnownAttributeDataMask = 0xFF 371489"];
7902 [label="WellKnownAttributeCompletionFlagMask = WellKnownAttributeDataMask 371490"];
7903 [label="0xFF 371491"];
7904 [label="FlowAnalysisAnnotationsMask = 0xFF 371492"];
7905 [label="0x1 371493"];
7906 [label="18 371494"];
7907 [label="0x1 << 18 371495"];
7908 [label="HasNameInMetadataBit = 0x1 << 18 371496"];
7909 [label="0x1 371497"];
7910 [label="19 371498"];
7911 [label="0x1 << 19 371499"];
7912 [label="FlowAnalysisAnnotationsCompletionBit = 0x1 << 19 371500"];
7913 [label="WellKnownAttributeCompletionFlagMask << WellKnownAttributeCompletionFlagOffset 371501"];
7914 [label="AllWellKnownAttributesCompleteNoData = WellKnownAttributeCompletionFlagMask << WellKnownAttributeCompletionFlagOffset 371502"];
7915 [label="Debug.Assert(EnumUtilities.ContainsAllValues<WellKnownAttributeFlags>(WellKnownAttributeDataMask)); 371503"];
7916 [label="Debug.Assert(EnumUtilities.ContainsAllValues<RefKind>(RefKindMask)); 371504"];
7917 [label="Debug.Assert(EnumUtilities.ContainsAllValues<FlowAnalysisAnnotations>(FlowAnalysisAnnotationsMask)); 371505"];
7918 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 371506"];
7919 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 371507"];
7920 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 371508"];
7921 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 371509"];
7922 [label="new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata) 371510"];
7923 [label="param PackedFlags(RefKind refKind) 371511"];
7924 [label="param PackedFlags(bool attributesAreComplete) 371512"];
7925 [label="param PackedFlags(bool hasNameInMetadata) 371513"];
7926 [label="param PackedFlags(this) 371514"];
7927 [label="int refKindBits = ((int)refKind & RefKindMask) << RefKindOffset; 371515"];
7928 [label="int refKindBits = ((int)refKind & RefKindMask) << RefKindOffset; 371516"];
7929 [label="attributesAreComplete 371517"];
7930 [label="int attributeBits = attributesAreComplete ? AllWellKnownAttributesCompleteNoData : 0; 371518"];
7931 [label="hasNameInMetadata 371519"];
7932 [label="int hasNameInMetadataBits = hasNameInMetadata ? HasNameInMetadataBit : 0; 371520"];
7933 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 371521"];
7934 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 371522"];
7935 [label="_bits 371523"];
7936 [label="_packedFlags 371524"];
7937 [label="this.RefKind 371525"];
7938 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371526"];
7939 [label="_packedFlags.RefKind 371527"];
7940 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371528"];
7941 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 371529"];
7942 [label="return _packedFlags.RefKind; 371530"];
7943 [label="Debug.Assert(refKind == this.RefKind); 371531"];
7944 [label="this.HasNameInMetadata 371532"];
7945 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 371533"];
7946 [label="_packedFlags.HasNameInMetadata 371534"];
7947 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 371535"];
7948 [label="return (_bits & HasNameInMetadataBit) != 0; 371536"];
7949 [label="return (_bits & HasNameInMetadataBit) != 0; 371537"];
7950 [label="return _packedFlags.HasNameInMetadata; 371538"];
7951 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 371539"];
7952 [label="parameter.RefCustomModifiers 371540"];
7953 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 371541"];
7954 [label="return ImmutableArray<CustomModifier>.Empty; 371542"];
7955 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 371543"];
7956 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 371544"];
7957 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 371545"];
7958 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 371546"];
7959 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 371547"];
7960 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 371548"];
7961 [label="parameter.RefKind 371549"];
7962 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371550"];
7963 [label="_packedFlags.RefKind 371551"];
7964 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371552"];
7965 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 371553"];
7966 [label="return _packedFlags.RefKind; 371554"];
7967 [label="if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 371555"];
7968 [label="if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 371556"];
7969 [label="return parameter; 371557"];
7970 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 371558"];
7971 [label="if (isBadParameter)\n                    {\n                        makeBad = true;\n                    } 371559"];
7972 [label="@params = builder.ToImmutable(); 371560"];
7973 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 371561"];
7974 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 371562"];
7975 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 371563"];
7976 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 371564"];
7977 [label="param AsDynamicIfNoPia(this TypeSymbol type) 371565"];
7978 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 371566"];
7979 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 371567"];
7980 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 371568"];
7981 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 371569"];
7982 [label="type.SpecialType 371570"];
7983 [label="get\n            {\n                return _corTypeId;\n            } 371571"];
7984 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 371572"];
7985 [label="result = null; 371573"];
7986 [label="paramInfo[0].Type = returnType; 371574"];
7987 [label="paramInfo[0].Type = returnType; 371575"];
7988 [label="paramInfo[0].Type 371576"];
7989 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371577"];
7990 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371578"];
7991 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371579"];
7992 [label="this.IsMetadataVirtual() 371580"];
7993 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 371581"];
7994 [label="=> HasFlag(MethodAttributes.Virtual) 371582"];
7995 [label="MethodAttributes.Virtual 371583"];
7996 [label="HasFlag(MethodAttributes.Virtual) 371584"];
7997 [label="param HasFlag(MethodAttributes flag) 371585"];
7998 [label="param HasFlag(this) 371586"];
7999 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371587"];
8000 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371588"];
8001 [label="return ((ushort)flag & _flags) != 0; 371589"];
8002 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371590"];
8003 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371591"];
8004 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 371592"];
8005 [label="PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter) 371593"];
8006 [label="param Create(PEModuleSymbol moduleSymbol) 371594"];
8007 [label="param Create(PEMethodSymbol containingSymbol) 371595"];
8008 [label="param Create(bool isContainingSymbolVirtual) 371596"];
8009 [label="param Create(int ordinal) 371597"];
8010 [label="param Create(ParamInfo<TypeSymbol> parameterInfo) 371598"];
8011 [label="param Create(Symbol nullableContext) 371599"];
8012 [label="param Create(bool isReturn) 371600"];
8013 [label="param Create(out bool isBad) 371601"];
8014 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371602"];
8015 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371603"];
8016 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371604"];
8017 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371605"];
8018 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 371606"];
8019 [label="Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad) 371607"];
8020 [label="param Create(PEModuleSymbol moduleSymbol) 371608"];
8021 [label="param Create(Symbol containingSymbol) 371609"];
8022 [label="param Create(bool isContainingSymbolVirtual) 371610"];
8023 [label="param Create(int ordinal) 371611"];
8024 [label="param Create(bool isByRef) 371612"];
8025 [label="param Create(Symbol nullableContext) 371613"];
8026 [label="param Create(bool isReturn) 371614"];
8027 [label="param Create(out bool isBad) 371615"];
8028 [label="CSharpCustomModifier.Convert(customModifiers) 371616"];
8029 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371617"];
8030 [label="TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)) 371618"];
8031 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 371619"];
8032 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 371620"];
8033 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 371621"];
8034 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 371622"];
8035 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 371623"];
8036 [label="typeSymbol.IsNullableType() 371624"];
8037 [label="param IsNullableType(this TypeSymbol type) 371625"];
8038 [label="type.OriginalDefinition 371626"];
8039 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371627"];
8040 [label="OriginalTypeSymbolDefinition 371628"];
8041 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371629"];
8042 [label="this.OriginalDefinition 371630"];
8043 [label="get\n            {\n                return this;\n            } 371631"];
8044 [label="return this; 371632"];
8045 [label="return this.OriginalDefinition; 371633"];
8046 [label="return OriginalTypeSymbolDefinition; 371634"];
8047 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 371635"];
8048 [label="type.OriginalDefinition.SpecialType 371636"];
8049 [label="get\n            {\n                return _corTypeId;\n            } 371637"];
8050 [label="var a1 = defaultType is null; 371638"];
8051 [label="!a1 371639"];
8052 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 371640"];
8053 [label="defaultType.IsNullableType() 371641"];
8054 [label="param IsNullableType(this TypeSymbol type) 371642"];
8055 [label="type.OriginalDefinition 371643"];
8056 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371644"];
8057 [label="OriginalTypeSymbolDefinition 371645"];
8058 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371646"];
8059 [label="this.OriginalDefinition 371647"];
8060 [label="get\n            {\n                return this;\n            } 371648"];
8061 [label="return this; 371649"];
8062 [label="return this.OriginalDefinition; 371650"];
8063 [label="return OriginalTypeSymbolDefinition; 371651"];
8064 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 371652"];
8065 [label="type.OriginalDefinition.SpecialType 371653"];
8066 [label="get\n            {\n                return _corTypeId;\n            } 371654"];
8067 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 371655"];
8068 [label="Debug.Assert(a1 || a2 != true || a3); 371656"];
8069 [label="Debug.Assert(a1 || a2 != true || a3); 371657"];
8070 [label="Debug.Assert(extensions != null); 371658"];
8071 [label="Debug.Assert(extensions != null); 371659"];
8072 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 371660"];
8073 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 371661"];
8074 [label="param PEParameterSymbol(bool isByRef) 371662"];
8075 [label="param PEParameterSymbol(int countOfCustomModifiers) 371663"];
8076 [label="param PEParameterSymbol(out bool isBad) 371664"];
8077 [label="_containingSymbol 371665"];
8078 [label="_moduleSymbol 371666"];
8079 [label="_ordinal 371667"];
8080 [label="Debug.Assert((object)moduleSymbol != null); 371668"];
8081 [label="Debug.Assert((object)containingSymbol != null); 371669"];
8082 [label="Debug.Assert(ordinal >= 0); 371670"];
8083 [label="typeWithAnnotations.HasType 371671"];
8084 [label="=> !(DefaultType is null) 371672"];
8085 [label="DefaultType is null 371673"];
8086 [label="!(DefaultType is null) 371674"];
8087 [label="Debug.Assert(typeWithAnnotations.HasType); 371675"];
8088 [label="isBad = false; 371676"];
8089 [label="isByRef 371677"];
8090 [label="refKind = isByRef ? RefKind.Ref : RefKind.None; 371678"];
8091 [label="nullableContext.GetNullableContextValue() 371679"];
8092 [label="byte? value; 371680"];
8093 [label="param TryGetNullableContext(out byte? value) 371681"];
8094 [label="param TryGetByte(out byte? value) 371682"];
8095 [label="return true; 371683"];
8096 [label="byte? value = nullableContext.GetNullableContextValue(); 371684"];
8097 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 371685"];
8098 [label="_lazyCustomAttributes 371686"];
8099 [label="_lazyHiddenAttributes 371687"];
8100 [label="_lazyDefaultValue 371688"];
8101 [label="_lazyIsParams 371689"];
8102 [label="if (!hasNameInMetadata)\n            {\n                // As was done historically, if the parameter doesn't have a name, we give it the name 'value'.\n                _name = 'value';\n            } 371690"];
8103 [label="_name = 'value'; 371691"];
8104 [label="_name 371692"];
8105 [label="int attributeBits = attributesAreComplete ? AllWellKnownAttributesCompleteNoData : 0; 371693"];
8106 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 371694"];
8107 [label="this.RefKind 371695"];
8108 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371696"];
8109 [label="_packedFlags.RefKind 371697"];
8110 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371698"];
8111 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 371699"];
8112 [label="return _packedFlags.RefKind; 371700"];
8113 [label="Debug.Assert(refKind == this.RefKind); 371701"];
8114 [label="this.HasNameInMetadata 371702"];
8115 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 371703"];
8116 [label="_packedFlags.HasNameInMetadata 371704"];
8117 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 371705"];
8118 [label="return (_bits & HasNameInMetadataBit) != 0; 371706"];
8119 [label="return (_bits & HasNameInMetadataBit) != 0; 371707"];
8120 [label="return _packedFlags.HasNameInMetadata; 371708"];
8121 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 371709"];
8122 [label="parameter.RefCustomModifiers 371710"];
8123 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 371711"];
8124 [label="return ImmutableArray<CustomModifier>.Empty; 371712"];
8125 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 371713"];
8126 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 371714"];
8127 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 371715"];
8128 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 371716"];
8129 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 371717"];
8130 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 371718"];
8131 [label="parameter.RefKind 371719"];
8132 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371720"];
8133 [label="_packedFlags.RefKind 371721"];
8134 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371722"];
8135 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 371723"];
8136 [label="return _packedFlags.RefKind; 371724"];
8137 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 371725"];
8138 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 371726"];
8139 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 371727"];
8140 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 371728"];
8141 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 371729"];
8142 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 371730"];
8143 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 371731"];
8144 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 371732"];
8145 [label="new SignatureData(signatureHeader, @params, returnParam) 371733"];
8146 [label="param SignatureData(SignatureHeader header) 371734"];
8147 [label="param SignatureData(ImmutableArray<ParameterSymbol> parameters) 371735"];
8148 [label="param SignatureData(PEParameterSymbol returnParam) 371736"];
8149 [label="param SignatureData(this) 371737"];
8150 [label="ReturnParam 371738"];
8151 [label="this.Header 371739"];
8152 [label="this.Parameters 371740"];
8153 [label="this.ReturnParam 371741"];
8154 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 371742"];
8155 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 371743"];
8156 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 371744"];
8157 [label="_lazySignature ?? LoadSignature() 371745"];
8158 [label="Signature.ReturnParam.TypeWithAnnotations 371746"];
8159 [label="get\n            {\n                return _typeWithAnnotations;\n            } 371747"];
8160 [label="return _typeWithAnnotations; 371748"];
8161 [label="ReturnTypeWithAnnotations.Type 371749"];
8162 [label="=> _extensions?.GetResolvedType(DefaultType) 371750"];
8163 [label="=> defaultType 371751"];
8164 [label="this.ReturnType.IsVoidType() 371752"];
8165 [label="param IsVoidType(this TypeSymbol type) 371753"];
8166 [label="type.SpecialType 371754"];
8167 [label="get\n            {\n                return _corTypeId;\n            } 371755"];
8168 [label="return type.SpecialType == SpecialType.System_Void; 371756"];
8169 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 371757"];
8170 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 371758"];
8171 [label="this.Arity 371759"];
8172 [label="get\n            {\n                if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                }\n\n                try\n                {\n                    int parameterCount;\n                    int typeParameterCount;\n                    MetadataDecoder.GetSignatureCountsOrThrow(_containingType.ContainingPEModule.Module, _handle, out parameterCount, out typeParameterCount);\n                    return typeParameterCount;\n                }\n                catch (BadImageFormatException)\n                {\n                    return TypeParameters.Length;\n                }\n            } 371760"];
8173 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 371761"];
8174 [label="return _lazyTypeParameters.Length; 371762"];
8175 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 371763"];
8176 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 371764"];
8177 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 371765"];
8178 [label="this.IsStatic 371766"];
8179 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371767"];
8180 [label="if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        } 371768"];
8181 [label="return MethodKind.Constructor; 371769"];
8182 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()); 371770"];
8183 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()) 371771"];
8184 [label="param InitializeMethodKind(MethodKind methodKind) 371772"];
8185 [label="param InitializeMethodKind(this) 371773"];
8186 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 371774"];
8187 [label="int bitsToSet = (((int)methodKind & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 371775"];
8188 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 371776"];
8189 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 371777"];
8190 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 371778"];
8191 [label="param BitsAreUnsetOrSame(int bits) 371779"];
8192 [label="param BitsAreUnsetOrSame(int mask) 371780"];
8193 [label="return (bits & mask) == 0 || (bits & mask) == mask; 371781"];
8194 [label="return (bits & mask) == 0 || (bits & mask) == mask; 371782"];
8195 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 371783"];
8196 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 371784"];
8197 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 371785"];
8198 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()); 371786"];
8199 [label="_packedFlags.MethodKind 371787"];
8200 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 371788"];
8201 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 371789"];
8202 [label="return _packedFlags.MethodKind; 371790"];
8203 [label="MethodKind methodKind = method.MethodKind; 371791"];
8204 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 371792"];
8205 [label="method.Arity 371793"];
8206 [label="get\n            {\n                if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                }\n\n                try\n                {\n                    int parameterCount;\n                    int typeParameterCount;\n                    MetadataDecoder.GetSignatureCountsOrThrow(_containingType.ContainingPEModule.Module, _handle, out parameterCount, out typeParameterCount);\n                    return typeParameterCount;\n                }\n                catch (BadImageFormatException)\n                {\n                    return TypeParameters.Length;\n                }\n            } 371794"];
8207 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 371795"];
8208 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371796"];
8209 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371797"];
8210 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371798"];
8211 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371799"];
8212 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371800"];
8213 [label="method.IsVirtual 371801"];
8214 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 371802"];
8215 [label="this.IsMetadataVirtual() 371803"];
8216 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 371804"];
8217 [label="=> HasFlag(MethodAttributes.Virtual) 371805"];
8218 [label="MethodAttributes.Virtual 371806"];
8219 [label="HasFlag(MethodAttributes.Virtual) 371807"];
8220 [label="param HasFlag(MethodAttributes flag) 371808"];
8221 [label="param HasFlag(this) 371809"];
8222 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371810"];
8223 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371811"];
8224 [label="return ((ushort)flag & _flags) != 0; 371812"];
8225 [label="return ((ushort)flag & _flags) != 0; 371813"];
8226 [label="this.IsMetadataVirtual() && !this.IsDestructor 371814"];
8227 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 371815"];
8228 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 371816"];
8229 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 371817"];
8230 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371818"];
8231 [label="method.IsOverride 371819"];
8232 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 371820"];
8233 [label="this._containingType.IsInterface 371821"];
8234 [label="get\n            {\n                return _flags.IsInterface();\n            } 371822"];
8235 [label="return _flags.IsInterface(); 371823"];
8236 [label="this.IsMetadataVirtual() 371824"];
8237 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 371825"];
8238 [label="=> HasFlag(MethodAttributes.Virtual) 371826"];
8239 [label="MethodAttributes.Virtual 371827"];
8240 [label="HasFlag(MethodAttributes.Virtual) 371828"];
8241 [label="param HasFlag(MethodAttributes flag) 371829"];
8242 [label="param HasFlag(this) 371830"];
8243 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371831"];
8244 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371832"];
8245 [label="return ((ushort)flag & _flags) != 0; 371833"];
8246 [label="return ((ushort)flag & _flags) != 0; 371834"];
8247 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 371835"];
8248 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 371836"];
8249 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 371837"];
8250 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371838"];
8251 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371839"];
8252 [label="method.IsAbstract 371840"];
8253 [label="=> HasFlag(MethodAttributes.Abstract) 371841"];
8254 [label="MethodAttributes.Abstract 371842"];
8255 [label="HasFlag(MethodAttributes.Abstract) 371843"];
8256 [label="param HasFlag(MethodAttributes flag) 371844"];
8257 [label="param HasFlag(this) 371845"];
8258 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371846"];
8259 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371847"];
8260 [label="return ((ushort)flag & _flags) != 0; 371848"];
8261 [label="return ((ushort)flag & _flags) != 0; 371849"];
8262 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371850"];
8263 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371851"];
8264 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 371852"];
8265 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 371853"];
8266 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 371854"];
8267 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 371855"];
8268 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 371856"];
8269 [label="param GetParameters(MethodSymbol method) 371857"];
8270 [label="param GetParameters(this) 371858"];
8271 [label="method.Parameters 371859"];
8272 [label="=> Signature.Parameters 371860"];
8273 [label="Signature 371861"];
8274 [label="=> _lazySignature ?? LoadSignature() 371862"];
8275 [label="Signature.Parameters 371863"];
8276 [label="return method.Parameters; 371864"];
8277 [label="param IsByRefMethod(MethodSymbol method) 371865"];
8278 [label="param IsByRefMethod(this) 371866"];
8279 [label="method.RefKind 371867"];
8280 [label="=> Signature.ReturnParam.RefKind 371868"];
8281 [label="Signature 371869"];
8282 [label="=> _lazySignature ?? LoadSignature() 371870"];
8283 [label="_lazySignature ?? LoadSignature() 371871"];
8284 [label="Signature.ReturnParam.RefKind 371872"];
8285 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371873"];
8286 [label="_packedFlags.RefKind 371874"];
8287 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371875"];
8288 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 371876"];
8289 [label="return _packedFlags.RefKind; 371877"];
8290 [label="return method.RefKind != RefKind.None; 371878"];
8291 [label="param GetReturnType(MethodSymbol method) 371879"];
8292 [label="param GetReturnType(this) 371880"];
8293 [label="method.ReturnType 371881"];
8294 [label="=> ReturnTypeWithAnnotations.Type 371882"];
8295 [label="ReturnTypeWithAnnotations 371883"];
8296 [label="Signature 371884"];
8297 [label="_lazySignature ?? LoadSignature() 371885"];
8298 [label="Signature.ReturnParam.TypeWithAnnotations 371886"];
8299 [label="ReturnTypeWithAnnotations.Type 371887"];
8300 [label="=> defaultType 371888"];
8301 [label="return method.ReturnType; 371889"];
8302 [label="param MatchTypeToTypeId(TypeSymbol type) 371890"];
8303 [label="param MatchTypeToTypeId(int typeId) 371891"];
8304 [label="param MatchTypeToTypeId(this) 371892"];
8305 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 371893"];
8306 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 371894"];
8307 [label="return base.MatchTypeToTypeId(type, typeId); 371895"];
8308 [label="return base.MatchTypeToTypeId(type, typeId); 371896"];
8309 [label="base.MatchTypeToTypeId(type, typeId) 371897"];
8310 [label="param MatchTypeToTypeId(TypeSymbol type) 371898"];
8311 [label="param MatchTypeToTypeId(int typeId) 371899"];
8312 [label="param MatchTypeToTypeId(this) 371900"];
8313 [label="type.OriginalDefinition 371901"];
8314 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 371902"];
8315 [label="OriginalTypeSymbolDefinition 371903"];
8316 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371904"];
8317 [label="this.OriginalDefinition 371905"];
8318 [label="get\n            {\n                return this;\n            } 371906"];
8319 [label="return this; 371907"];
8320 [label="return this.OriginalDefinition; 371908"];
8321 [label="return OriginalTypeSymbolDefinition; 371909"];
8322 [label="if ((int)type.OriginalDefinition.SpecialType == typeId)\n                {\n                    if (type.IsDefinition)\n                    {\n                        return true;\n                    }\n\n                    return type.Equals(type.OriginalDefinition, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 371910"];
8323 [label="type.OriginalDefinition.SpecialType 371911"];
8324 [label="get\n            {\n                return _corTypeId;\n            } 371912"];
8325 [label="return _corTypeId; 371913"];
8326 [label="if ((int)type.OriginalDefinition.SpecialType == typeId)\n                {\n                    if (type.IsDefinition)\n                    {\n                        return true;\n                    }\n\n                    return type.Equals(type.OriginalDefinition, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 371914"];
8327 [label="type.IsDefinition 371915"];
8328 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 371916"];
8329 [label="OriginalDefinition 371917"];
8330 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 371918"];
8331 [label="OriginalSymbolDefinition 371919"];
8332 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 371920"];
8333 [label="this.OriginalTypeSymbolDefinition 371921"];
8334 [label="get\n            {\n                return this.OriginalDefinition;\n            } 371922"];
8335 [label="return this.OriginalTypeSymbolDefinition; 371923"];
8336 [label="return OriginalSymbolDefinition; 371924"];
8337 [label="return (object)this == (object)OriginalDefinition; 371925"];
8338 [label="if (type.IsDefinition)\n                    {\n                        return true;\n                    } 371926"];
8339 [label="return true; 371927"];
8340 [label="param IsByRefParam(ParameterSymbol parameter) 371928"];
8341 [label="param IsByRefParam(this) 371929"];
8342 [label="parameter.RefKind 371930"];
8343 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 371931"];
8344 [label="_packedFlags.RefKind 371932"];
8345 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 371933"];
8346 [label="return parameter.RefKind != RefKind.None; 371934"];
8347 [label="param GetParamType(ParameterSymbol parameter) 371935"];
8348 [label="param GetParamType(this) 371936"];
8349 [label="parameter.Type 371937"];
8350 [label="=> TypeWithAnnotations.Type 371938"];
8351 [label="TypeWithAnnotations 371939"];
8352 [label="get\n            {\n                return _typeWithAnnotations;\n            } 371940"];
8353 [label="return _typeWithAnnotations; 371941"];
8354 [label="TypeWithAnnotations.Type 371942"];
8355 [label="=> _extensions?.GetResolvedType(DefaultType) 371943"];
8356 [label="=> defaultType 371944"];
8357 [label="return parameter.Type; 371945"];
8358 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 371946"];
8359 [label="result = member; 371947"];
8360 [label="member.Name 371948"];
8361 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 371949"];
8362 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 371950"];
8363 [label="member.Kind 371951"];
8364 [label="get\n            {\n                return SymbolKind.Method;\n            } 371952"];
8365 [label="return SymbolKind.Method; 371953"];
8366 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371954"];
8367 [label="member.IsStatic 371955"];
8368 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371956"];
8369 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371957"];
8370 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371958"];
8371 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371959"];
8372 [label="member.DeclaredAccessibility 371960"];
8373 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 371961"];
8374 [label="Flags 371962"];
8375 [label="=> (MethodAttributes)_flags 371963"];
8376 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 371964"];
8377 [label="return Accessibility.Public; 371965"];
8378 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371966"];
8379 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 371967"];
8380 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371968"];
8381 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 371969"];
8382 [label="s.Kind 371970"];
8383 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 371971"];
8384 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 371972"];
8385 [label="Debug.Assert((object)moduleSymbol != null); 371973"];
8386 [label="param GetSpecialType(this) 371974"];
8387 [label="this.Modules 371975"];
8388 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 371976"];
8389 [label="module.GetReferencedAssemblies() 371977"];
8390 [label="param GetReferencedAssemblies(this) 371978"];
8391 [label="AssertReferencesInitialized() 371979"];
8392 [label="param AssertReferencesInitialized(this) 371980"];
8393 [label="Debug.Assert(_moduleReferences != null); 371981"];
8394 [label="Debug.Assert(_moduleReferences != null); 371982"];
8395 [label="AssertReferencesInitialized(); 371983"];
8396 [label="return _moduleReferences.Identities; 371984"];
8397 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 371985"];
8398 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 371986"];
8399 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 371987"];
8400 [label="=> this.SpecialType 371988"];
8401 [label="this.SpecialType 371989"];
8402 [label="get\n            {\n                return _corTypeId;\n            } 371990"];
8403 [label="bool makeBad = (mrEx != null); 371991"];
8404 [label="bool makeBad = (mrEx != null); 371992"];
8405 [label="ImmutableArray<ParameterSymbol> @params; 371993"];
8406 [label="@params 371994"];
8407 [label="bool isBadParameter; 371995"];
8408 [label="this.IsMetadataVirtual() 371996"];
8409 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 371997"];
8410 [label="=> HasFlag(MethodAttributes.Virtual) 371998"];
8411 [label="MethodAttributes.Virtual 371999"];
8412 [label="HasFlag(MethodAttributes.Virtual) 372000"];
8413 [label="param HasFlag(MethodAttributes flag) 372001"];
8414 [label="param HasFlag(this) 372002"];
8415 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372003"];
8416 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372004"];
8417 [label="return ((ushort)flag & _flags) != 0; 372005"];
8418 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 372006"];
8419 [label="param Create(bool isContainingSymbolVirtual) 372007"];
8420 [label="param Create(bool isReturn) 372008"];
8421 [label="param Create(out bool isBad) 372009"];
8422 [label="param Create(bool isContainingSymbolVirtual) 372010"];
8423 [label="param Create(bool isReturn) 372011"];
8424 [label="param Create(out bool isBad) 372012"];
8425 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 372013"];
8426 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 372014"];
8427 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 372015"];
8428 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 372016"];
8429 [label="typeSymbol.IsNullableType() 372017"];
8430 [label="param IsNullableType(this TypeSymbol type) 372018"];
8431 [label="type.OriginalDefinition 372019"];
8432 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372020"];
8433 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372021"];
8434 [label="type.OriginalDefinition.SpecialType 372022"];
8435 [label="get\n            {\n                return _corTypeId;\n            } 372023"];
8436 [label="var a1 = defaultType is null; 372024"];
8437 [label="!a1 372025"];
8438 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 372026"];
8439 [label="defaultType.IsNullableType() 372027"];
8440 [label="param IsNullableType(this TypeSymbol type) 372028"];
8441 [label="type.OriginalDefinition 372029"];
8442 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372030"];
8443 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372031"];
8444 [label="type.OriginalDefinition.SpecialType 372032"];
8445 [label="get\n            {\n                return _corTypeId;\n            } 372033"];
8446 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 372034"];
8447 [label="Debug.Assert(a1 || a2 != true || a3); 372035"];
8448 [label="Debug.Assert(a1 || a2 != true || a3); 372036"];
8449 [label="Debug.Assert(extensions != null); 372037"];
8450 [label="param PEParameterSymbol(int countOfCustomModifiers) 372038"];
8451 [label="param PEParameterSymbol(out bool isBad) 372039"];
8452 [label="_containingSymbol 372040"];
8453 [label="_moduleSymbol 372041"];
8454 [label="_ordinal 372042"];
8455 [label="Debug.Assert((object)moduleSymbol != null); 372043"];
8456 [label="Debug.Assert((object)containingSymbol != null); 372044"];
8457 [label="Debug.Assert(ordinal >= 0); 372045"];
8458 [label="typeWithAnnotations.HasType 372046"];
8459 [label="=> !(DefaultType is null) 372047"];
8460 [label="DefaultType is null 372048"];
8461 [label="!(DefaultType is null) 372049"];
8462 [label="Debug.Assert(typeWithAnnotations.HasType); 372050"];
8463 [label="isBad = false; 372051"];
8464 [label="if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                } 372052"];
8465 [label="=> defaultType 372053"];
8466 [label="param TransformType(int targetSymbolCustomModifierCount) 372054"];
8467 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 372055"];
8468 [label="Debug.Assert((object)metadataType != null); 372056"];
8469 [label="param WithTypeAndModifiers(this) 372057"];
8470 [label="var a1 = defaultType is null; 372058"];
8471 [label="!a1 372059"];
8472 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 372060"];
8473 [label="defaultType.IsNullableType() 372061"];
8474 [label="param IsNullableType(this TypeSymbol type) 372062"];
8475 [label="type.OriginalDefinition 372063"];
8476 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372064"];
8477 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372065"];
8478 [label="type.OriginalDefinition.SpecialType 372066"];
8479 [label="get\n            {\n                return _corTypeId;\n            } 372067"];
8480 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 372068"];
8481 [label="Debug.Assert(a1 || a2 != true || a3); 372069"];
8482 [label="Debug.Assert(extensions != null); 372070"];
8483 [label="containingSymbol.Kind 372071"];
8484 [label="get\n            {\n                return SymbolKind.Method;\n            } 372072"];
8485 [label="return SymbolKind.Method; 372073"];
8486 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 372074"];
8487 [label="containingSymbol.Kind == SymbolKind.Property 372075"];
8488 [label="param TransformType(Symbol accessSymbol) 372076"];
8489 [label="metadataType.HasType 372077"];
8490 [label="=> !(DefaultType is null) 372078"];
8491 [label="DefaultType is null 372079"];
8492 [label="!(DefaultType is null) 372080"];
8493 [label="Debug.Assert(metadataType.HasType); 372081"];
8494 [label="accessSymbol.IsDefinition 372082"];
8495 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 372083"];
8496 [label="get\n            {\n                return this.OriginalDefinition;\n            } 372084"];
8497 [label="this.OriginalDefinition 372085"];
8498 [label="get\n            {\n                return this;\n            } 372086"];
8499 [label="return this; 372087"];
8500 [label="return this.OriginalDefinition; 372088"];
8501 [label="Debug.Assert(accessSymbol.IsDefinition); 372089"];
8502 [label="accessSymbol.ContainingModule 372090"];
8503 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 372091"];
8504 [label="this.ContainingSymbol 372092"];
8505 [label="=> _containingType 372093"];
8506 [label="_containingType 372094"];
8507 [label="var container = this.ContainingSymbol; 372095"];
8508 [label="return (object)container != null ? container.ContainingModule : null; 372096"];
8509 [label="return (object)container != null ? container.ContainingModule : null; 372097"];
8510 [label="(object)container != null 372098"];
8511 [label="container.ContainingModule 372099"];
8512 [label="get\n            {\n                return ContainingPEModule;\n            } 372100"];
8513 [label="ContainingPEModule 372101"];
8514 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 372102"];
8515 [label="s.Kind 372103"];
8516 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372104"];
8517 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372105"];
8518 [label="return ContainingPEModule; 372106"];
8519 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 372107"];
8520 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372108"];
8521 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372109"];
8522 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 372110"];
8523 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 372111"];
8524 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 372112"];
8525 [label="Debug.Assert(symbol is object); 372113"];
8526 [label="symbol.Kind 372114"];
8527 [label="get\n            {\n                return SymbolKind.Method;\n            } 372115"];
8528 [label="return SymbolKind.Method; 372116"];
8529 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 372117"];
8530 [label="isInternal = false; 372118"];
8531 [label="symbol.DeclaredAccessibility 372119"];
8532 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 372120"];
8533 [label="Flags 372121"];
8534 [label="=> (MethodAttributes)_flags 372122"];
8535 [label="(MethodAttributes)_flags 372123"];
8536 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 372124"];
8537 [label="return Accessibility.Public; 372125"];
8538 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 372126"];
8539 [label="symbol.ContainingType 372127"];
8540 [label="=> _containingType 372128"];
8541 [label="_containingType 372129"];
8542 [label="symbol = symbol.ContainingType; 372130"];
8543 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 372131"];
8544 [label="symbol.DeclaredAccessibility 372132"];
8545 [label="Accessibility access = Accessibility.Private; 372133"];
8546 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 372134"];
8547 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372135"];
8548 [label="return _container as NamedTypeSymbol; 372136"];
8549 [label="return true; 372137"];
8550 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372138"];
8551 [label="byte? value; 372139"];
8552 [label="param TryGetNullableContext(out byte? value) 372140"];
8553 [label="param TryGetByte(out byte? value) 372141"];
8554 [label="value = null; 372142"];
8555 [label="s.Kind 372143"];
8556 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372144"];
8557 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372145"];
8558 [label="byte? value; 372146"];
8559 [label="param TryGetByte(out byte? value) 372147"];
8560 [label="return true; 372148"];
8561 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 372149"];
8562 [label="=> defaultType 372150"];
8563 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 372151"];
8564 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 372152"];
8565 [label="_elementNames 372153"];
8566 [label="elementNames.IsDefault 372154"];
8567 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 372155"];
8568 [label="_namesIndex 372156"];
8569 [label="_foundUsableErrorType = false; 372157"];
8570 [label="_foundUsableErrorType 372158"];
8571 [label="param DecodeType(this) 372159"];
8572 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 372160"];
8573 [label="param DecodeNamedType(this) 372161"];
8574 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 372162"];
8575 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 372163"];
8576 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 372164"];
8577 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 372165"];
8578 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 372166"];
8579 [label="DecodeTypeArguments(typeArgs) 372167"];
8580 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 372168"];
8581 [label="param DecodeTypeArguments(this) 372169"];
8582 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 372170"];
8583 [label="return typeArgs; 372171"];
8584 [label="type.ContainingType 372172"];
8585 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372173"];
8586 [label="return _container as NamedTypeSymbol; 372174"];
8587 [label="NamedTypeSymbol containingType = type.ContainingType; 372175"];
8588 [label="NamedTypeSymbol? decodedContainingType; 372176"];
8589 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 372177"];
8590 [label="decodedContainingType = containingType; 372178"];
8591 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372179"];
8592 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372180"];
8593 [label="var typeArgsChanged = typeArgs != decodedArgs; 372181"];
8594 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 372182"];
8595 [label="decodedType.IsTupleType 372183"];
8596 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 372184"];
8597 [label="_ 372185"];
8598 [label="tupleCardinality: out _ 372186"];
8599 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 372187"];
8600 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 372188"];
8601 [label="param IsTupleTypeOfCardinality(this) 372189"];
8602 [label="IsUnboundGenericType 372190"];
8603 [label="get\n            {\n                return false;\n            } 372191"];
8604 [label="return false; 372192"];
8605 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372193"];
8606 [label="ContainingSymbol 372194"];
8607 [label="get\n            {\n                return _container;\n            } 372195"];
8608 [label="return _container; 372196"];
8609 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372197"];
8610 [label=".Kind 372198"];
8611 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372199"];
8612 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372200"];
8613 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372201"];
8614 [label="ContainingNamespace 372202"];
8615 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372203"];
8616 [label="get\n            {\n                return _container;\n            } 372204"];
8617 [label="return _container; 372205"];
8618 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372206"];
8619 [label="ContainingNamespace.ContainingNamespace 372207"];
8620 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372208"];
8621 [label=".IsGlobalNamespace 372209"];
8622 [label="get\n            {\n                return false;\n            } 372210"];
8623 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372211"];
8624 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372212"];
8625 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372213"];
8626 [label="tupleCardinality = 0; 372214"];
8627 [label="return false; 372215"];
8628 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 372216"];
8629 [label="this.RefKind 372217"];
8630 [label="Debug.Assert(refKind == this.RefKind); 372218"];
8631 [label="this.HasNameInMetadata 372219"];
8632 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 372220"];
8633 [label="_packedFlags.HasNameInMetadata 372221"];
8634 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 372222"];
8635 [label="return (_bits & HasNameInMetadataBit) != 0; 372223"];
8636 [label="return (_bits & HasNameInMetadataBit) != 0; 372224"];
8637 [label="return _packedFlags.HasNameInMetadata; 372225"];
8638 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 372226"];
8639 [label="parameter.RefCustomModifiers 372227"];
8640 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 372228"];
8641 [label="return ImmutableArray<CustomModifier>.Empty; 372229"];
8642 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 372230"];
8643 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 372231"];
8644 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 372232"];
8645 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 372233"];
8646 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 372234"];
8647 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 372235"];
8648 [label="parameter.RefKind 372236"];
8649 [label="if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 372237"];
8650 [label="if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 372238"];
8651 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 372239"];
8652 [label="if (isBadParameter)\n                    {\n                        makeBad = true;\n                    } 372240"];
8653 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 372241"];
8654 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 372242"];
8655 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 372243"];
8656 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 372244"];
8657 [label="param AsDynamicIfNoPia(this TypeSymbol type) 372245"];
8658 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 372246"];
8659 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 372247"];
8660 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 372248"];
8661 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 372249"];
8662 [label="type.SpecialType 372250"];
8663 [label="get\n            {\n                return _corTypeId;\n            } 372251"];
8664 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 372252"];
8665 [label="result = null; 372253"];
8666 [label="paramInfo[0].Type = returnType; 372254"];
8667 [label="paramInfo[0].Type = returnType; 372255"];
8668 [label="paramInfo[0].Type 372256"];
8669 [label="this.IsMetadataVirtual() 372257"];
8670 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 372258"];
8671 [label="=> HasFlag(MethodAttributes.Virtual) 372259"];
8672 [label="MethodAttributes.Virtual 372260"];
8673 [label="HasFlag(MethodAttributes.Virtual) 372261"];
8674 [label="param HasFlag(MethodAttributes flag) 372262"];
8675 [label="param HasFlag(this) 372263"];
8676 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372264"];
8677 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372265"];
8678 [label="return ((ushort)flag & _flags) != 0; 372266"];
8679 [label="param Create(bool isContainingSymbolVirtual) 372267"];
8680 [label="param Create(bool isReturn) 372268"];
8681 [label="param Create(out bool isBad) 372269"];
8682 [label="param Create(bool isContainingSymbolVirtual) 372270"];
8683 [label="param Create(bool isReturn) 372271"];
8684 [label="param Create(out bool isBad) 372272"];
8685 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 372273"];
8686 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 372274"];
8687 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 372275"];
8688 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 372276"];
8689 [label="typeSymbol.IsNullableType() 372277"];
8690 [label="param IsNullableType(this TypeSymbol type) 372278"];
8691 [label="type.OriginalDefinition 372279"];
8692 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372280"];
8693 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372281"];
8694 [label="type.OriginalDefinition.SpecialType 372282"];
8695 [label="get\n            {\n                return _corTypeId;\n            } 372283"];
8696 [label="var a1 = defaultType is null; 372284"];
8697 [label="!a1 372285"];
8698 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 372286"];
8699 [label="defaultType.IsNullableType() 372287"];
8700 [label="param IsNullableType(this TypeSymbol type) 372288"];
8701 [label="type.OriginalDefinition 372289"];
8702 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372290"];
8703 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372291"];
8704 [label="type.OriginalDefinition.SpecialType 372292"];
8705 [label="get\n            {\n                return _corTypeId;\n            } 372293"];
8706 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 372294"];
8707 [label="Debug.Assert(a1 || a2 != true || a3); 372295"];
8708 [label="Debug.Assert(a1 || a2 != true || a3); 372296"];
8709 [label="Debug.Assert(extensions != null); 372297"];
8710 [label="Debug.Assert(extensions != null); 372298"];
8711 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 372299"];
8712 [label="param PEParameterSymbol(out bool isBad) 372300"];
8713 [label="_containingSymbol 372301"];
8714 [label="_moduleSymbol 372302"];
8715 [label="_ordinal 372303"];
8716 [label="Debug.Assert((object)moduleSymbol != null); 372304"];
8717 [label="Debug.Assert((object)containingSymbol != null); 372305"];
8718 [label="Debug.Assert(ordinal >= 0); 372306"];
8719 [label="typeWithAnnotations.HasType 372307"];
8720 [label="=> !(DefaultType is null) 372308"];
8721 [label="DefaultType is null 372309"];
8722 [label="!(DefaultType is null) 372310"];
8723 [label="Debug.Assert(typeWithAnnotations.HasType); 372311"];
8724 [label="isBad = false; 372312"];
8725 [label="nullableContext.GetNullableContextValue() 372313"];
8726 [label="param TryGetNullableContext(out byte? value) 372314"];
8727 [label="param TryGetByte(out byte? value) 372315"];
8728 [label="return true; 372316"];
8729 [label="byte? value = nullableContext.GetNullableContextValue(); 372317"];
8730 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 372318"];
8731 [label="this.RefKind 372319"];
8732 [label="Debug.Assert(refKind == this.RefKind); 372320"];
8733 [label="this.HasNameInMetadata 372321"];
8734 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 372322"];
8735 [label="_packedFlags.HasNameInMetadata 372323"];
8736 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 372324"];
8737 [label="return (_bits & HasNameInMetadataBit) != 0; 372325"];
8738 [label="return (_bits & HasNameInMetadataBit) != 0; 372326"];
8739 [label="return _packedFlags.HasNameInMetadata; 372327"];
8740 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 372328"];
8741 [label="parameter.RefCustomModifiers 372329"];
8742 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 372330"];
8743 [label="return ImmutableArray<CustomModifier>.Empty; 372331"];
8744 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 372332"];
8745 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 372333"];
8746 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 372334"];
8747 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 372335"];
8748 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 372336"];
8749 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 372337"];
8750 [label="parameter.RefKind 372338"];
8751 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 372339"];
8752 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 372340"];
8753 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 372341"];
8754 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 372342"];
8755 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 372343"];
8756 [label="ReturnParam 372344"];
8757 [label="=> defaultType 372345"];
8758 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372346"];
8759 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 372347"];
8760 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 372348"];
8761 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 372349"];
8762 [label="param BitsAreUnsetOrSame(int bits) 372350"];
8763 [label="param BitsAreUnsetOrSame(int mask) 372351"];
8764 [label="return (bits & mask) == 0 || (bits & mask) == mask; 372352"];
8765 [label="return (bits & mask) == 0 || (bits & mask) == mask; 372353"];
8766 [label="_packedFlags.MethodKind 372354"];
8767 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 372355"];
8768 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 372356"];
8769 [label="return _packedFlags.MethodKind; 372357"];
8770 [label="MethodKind methodKind = method.MethodKind; 372358"];
8771 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 372359"];
8772 [label="method.Arity 372360"];
8773 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 372361"];
8774 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372362"];
8775 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372363"];
8776 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372364"];
8777 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372365"];
8778 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372366"];
8779 [label="method.IsVirtual 372367"];
8780 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 372368"];
8781 [label="this.IsMetadataVirtual() 372369"];
8782 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 372370"];
8783 [label="=> HasFlag(MethodAttributes.Virtual) 372371"];
8784 [label="MethodAttributes.Virtual 372372"];
8785 [label="HasFlag(MethodAttributes.Virtual) 372373"];
8786 [label="param HasFlag(MethodAttributes flag) 372374"];
8787 [label="param HasFlag(this) 372375"];
8788 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372376"];
8789 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372377"];
8790 [label="return ((ushort)flag & _flags) != 0; 372378"];
8791 [label="this.IsMetadataVirtual() && !this.IsDestructor 372379"];
8792 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 372380"];
8793 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 372381"];
8794 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 372382"];
8795 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372383"];
8796 [label="method.IsOverride 372384"];
8797 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 372385"];
8798 [label="this._containingType.IsInterface 372386"];
8799 [label="get\n            {\n                return _flags.IsInterface();\n            } 372387"];
8800 [label="return _flags.IsInterface(); 372388"];
8801 [label="this.IsMetadataVirtual() 372389"];
8802 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 372390"];
8803 [label="=> HasFlag(MethodAttributes.Virtual) 372391"];
8804 [label="MethodAttributes.Virtual 372392"];
8805 [label="HasFlag(MethodAttributes.Virtual) 372393"];
8806 [label="param HasFlag(MethodAttributes flag) 372394"];
8807 [label="param HasFlag(this) 372395"];
8808 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372396"];
8809 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372397"];
8810 [label="return ((ushort)flag & _flags) != 0; 372398"];
8811 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 372399"];
8812 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 372400"];
8813 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 372401"];
8814 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372402"];
8815 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372403"];
8816 [label="method.IsAbstract 372404"];
8817 [label="=> HasFlag(MethodAttributes.Abstract) 372405"];
8818 [label="MethodAttributes.Abstract 372406"];
8819 [label="HasFlag(MethodAttributes.Abstract) 372407"];
8820 [label="param HasFlag(MethodAttributes flag) 372408"];
8821 [label="param HasFlag(this) 372409"];
8822 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372410"];
8823 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372411"];
8824 [label="return ((ushort)flag & _flags) != 0; 372412"];
8825 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372413"];
8826 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372414"];
8827 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 372415"];
8828 [label="param GetParameters(this) 372416"];
8829 [label="param IsByRefMethod(this) 372417"];
8830 [label="param GetReturnType(this) 372418"];
8831 [label="param MatchTypeToTypeId(this) 372419"];
8832 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 372420"];
8833 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 372421"];
8834 [label="param MatchTypeToTypeId(this) 372422"];
8835 [label="param IsByRefParam(this) 372423"];
8836 [label="param GetParamType(this) 372424"];
8837 [label="return false; 372425"];
8838 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 372426"];
8839 [label="return result; 372427"];
8840 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 372428"];
8841 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 372429"];
8842 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 372430"];
8843 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 372431"];
8844 [label="return _lazyWellKnownTypeMembers[(int)member]; 372432"];
8845 [label="if ((object)memberSymbol != null)\n            {\n                diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType();\n                if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                }\n            }\n            else if (!isOptional)\n            {\n                // member is missing\n                MemberDescriptor memberDescriptor = WellKnownMembers.GetDescriptor(member);\n                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember, memberDescriptor.DeclaringTypeMetadataName, memberDescriptor.Name);\n            }\n            else\n            {\n                diagnosticInfo = null;\n            } 372433"];
8846 [label="if ((object)memberSymbol != null)\n            {\n                diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType();\n                if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                }\n            }\n            else if (!isOptional)\n            {\n                // member is missing\n                MemberDescriptor memberDescriptor = WellKnownMembers.GetDescriptor(member);\n                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember, memberDescriptor.DeclaringTypeMetadataName, memberDescriptor.Name);\n            }\n            else\n            {\n                diagnosticInfo = null;\n            } 372434"];
8847 [label="memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType() 372435"];
8848 [label="param GetUseSiteDiagnosticForSymbolOrContainingType(this) 372436"];
8849 [label="this.GetUseSiteDiagnostic() 372437"];
8850 [label="param GetUseSiteDiagnostic(this) 372438"];
8851 [label="_packedFlags.IsUseSiteDiagnosticPopulated 372439"];
8852 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 372440"];
8853 [label="_bits & IsUseSiteDiagnosticPopulatedBit 372441"];
8854 [label="0 372442"];
8855 [label="(_bits & IsUseSiteDiagnosticPopulatedBit) != 0 372443"];
8856 [label="if (!_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                EnsureTypeParametersAreLoaded(ref result);\n                if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                }\n\n                return InitializeUseSiteDiagnostic(result);\n            } 372444"];
8857 [label="DiagnosticInfo result = null; 372445"];
8858 [label="CalculateUseSiteDiagnostic(ref result); 372446"];
8859 [label="CalculateUseSiteDiagnostic(ref result) 372447"];
8860 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 372448"];
8861 [label="param CalculateUseSiteDiagnostic(this) 372449"];
8862 [label="this.IsDefinition 372450"];
8863 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 372451"];
8864 [label="get\n            {\n                return this.OriginalDefinition;\n            } 372452"];
8865 [label="this.OriginalDefinition 372453"];
8866 [label="get\n            {\n                return this;\n            } 372454"];
8867 [label="return this; 372455"];
8868 [label="return this.OriginalDefinition; 372456"];
8869 [label="Debug.Assert(this.IsDefinition); 372457"];
8870 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 372458"];
8871 [label="this.ReturnTypeWithAnnotations 372459"];
8872 [label="=> Signature.ReturnParam.TypeWithAnnotations 372460"];
8873 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 372461"];
8874 [label="IsInitOnly 372462"];
8875 [label="get\n            {\n                if (!_packedFlags.IsInitOnlyPopulated)\n                {\n                    bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier();\n                    _packedFlags.InitializeIsInitOnly(isInitOnly);\n                }\n                return _packedFlags.IsInitOnly;\n            } 372463"];
8876 [label="_packedFlags.IsInitOnlyPopulated 372464"];
8877 [label="=> (_bits & IsInitOnlyPopulatedBit) != 0 372465"];
8878 [label="_bits & IsInitOnlyPopulatedBit 372466"];
8879 [label="0 372467"];
8880 [label="(_bits & IsInitOnlyPopulatedBit) != 0 372468"];
8881 [label="if (!_packedFlags.IsInitOnlyPopulated)\n                {\n                    bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier();\n                    _packedFlags.InitializeIsInitOnly(isInitOnly);\n                } 372469"];
8882 [label="this.IsStatic 372470"];
8883 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 372471"];
8884 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 372472"];
8885 [label="this.MethodKind 372473"];
8886 [label="_packedFlags.MethodKind 372474"];
8887 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 372475"];
8888 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 372476"];
8889 [label="return _packedFlags.MethodKind; 372477"];
8890 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 372478"];
8891 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 372479"];
8892 [label="_packedFlags.InitializeIsInitOnly(isInitOnly); 372480"];
8893 [label="_packedFlags.InitializeIsInitOnly(isInitOnly) 372481"];
8894 [label="param InitializeIsInitOnly(bool isInitOnly) 372482"];
8895 [label="param InitializeIsInitOnly(this) 372483"];
8896 [label="isInitOnly 372484"];
8897 [label="int bitsToSet = (isInitOnly ? IsInitOnlyBit : 0) | IsInitOnlyPopulatedBit; 372485"];
8898 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 372486"];
8899 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 372487"];
8900 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 372488"];
8901 [label="param BitsAreUnsetOrSame(int bits) 372489"];
8902 [label="param BitsAreUnsetOrSame(int mask) 372490"];
8903 [label="return (bits & mask) == 0 || (bits & mask) == mask; 372491"];
8904 [label="return (bits & mask) == 0 || (bits & mask) == mask; 372492"];
8905 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 372493"];
8906 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 372494"];
8907 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 372495"];
8908 [label="_packedFlags.InitializeIsInitOnly(isInitOnly); 372496"];
8909 [label="_packedFlags.IsInitOnly 372497"];
8910 [label="=> (_bits & IsInitOnlyBit) != 0 372498"];
8911 [label="_bits & IsInitOnlyBit 372499"];
8912 [label="0 372500"];
8913 [label="(_bits & IsInitOnlyBit) != 0 372501"];
8914 [label="return _packedFlags.IsInitOnly; 372502"];
8915 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 372503"];
8916 [label="DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) 372504"];
8917 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 372505"];
8918 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 372506"];
8919 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 372507"];
8920 [label="param DeriveUseSiteDiagnosticFromType(this) 372508"];
8921 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 372509"];
8922 [label="type.Type 372510"];
8923 [label="=> _extensions?.GetResolvedType(DefaultType) 372511"];
8924 [label="=> defaultType 372512"];
8925 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 372513"];
8926 [label="DeriveUseSiteDiagnosticFromType(ref result, type.Type) 372514"];
8927 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 372515"];
8928 [label="param DeriveUseSiteDiagnosticFromType(TypeSymbol type) 372516"];
8929 [label="param DeriveUseSiteDiagnosticFromType(this) 372517"];
8930 [label="type.GetUseSiteDiagnostic() 372518"];
8931 [label="param GetUseSiteDiagnostic(this) 372519"];
8932 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 372520"];
8933 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 372521"];
8934 [label="GetUseSiteDiagnosticImpl() 372522"];
8935 [label="param GetUseSiteDiagnosticImpl(this) 372523"];
8936 [label="DiagnosticInfo diagnostic = null; 372524"];
8937 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 372525"];
8938 [label="CalculateUseSiteDiagnostic() 372526"];
8939 [label="param CalculateUseSiteDiagnostic(this) 372527"];
8940 [label="DiagnosticInfo result = null; 372528"];
8941 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 372529"];
8942 [label="DeriveUseSiteDiagnosticFromBase() 372530"];
8943 [label="param DeriveUseSiteDiagnosticFromBase(this) 372531"];
8944 [label="this.BaseTypeNoUseSiteDiagnostics 372532"];
8945 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 372533"];
8946 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 372534"];
8947 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 372535"];
8948 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 372536"];
8949 [label="MakeAcyclicBaseType() 372537"];
8950 [label="param MakeAcyclicBaseType(this) 372538"];
8951 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 372539"];
8952 [label="GetDeclaredBaseType(null) 372540"];
8953 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 372541"];
8954 [label="param GetDeclaredBaseType(this) 372542"];
8955 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 372543"];
8956 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 372544"];
8957 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 372545"];
8958 [label="param GetDeclaredBaseType(this) 372546"];
8959 [label="s.Kind 372547"];
8960 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372548"];
8961 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372549"];
8962 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 372550"];
8963 [label="Debug.Assert((object)moduleSymbol != null); 372551"];
8964 [label="var baseType = MakeDeclaredBaseType(); 372552"];
8965 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 372553"];
8966 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 372554"];
8967 [label="ContainingPEModule 372555"];
8968 [label="s.Kind 372556"];
8969 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372557"];
8970 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372558"];
8971 [label="var moduleSymbol = ContainingPEModule; 372559"];
8972 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 372560"];
8973 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 372561"];
8974 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 372562"];
8975 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 372563"];
8976 [label="DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol) 372564"];
8977 [label="param TransformType(TypeSymbol metadataType) 372565"];
8978 [label="param TransformType(int targetSymbolCustomModifierCount) 372566"];
8979 [label="param TransformType(EntityHandle targetSymbolToken) 372567"];
8980 [label="param TransformType(PEModuleSymbol containingModule) 372568"];
8981 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 372569"];
8982 [label="Debug.Assert((object)metadataType != null); 372570"];
8983 [label="Debug.Assert((object)metadataType != null); 372571"];
8984 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 372572"];
8985 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 372573"];
8986 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 372574"];
8987 [label="NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol) 372575"];
8988 [label="param TransformType(TypeSymbol type) 372576"];
8989 [label="param TransformType(EntityHandle handle) 372577"];
8990 [label="param TransformType(PEModuleSymbol containingModule) 372578"];
8991 [label="return _module; 372579"];
8992 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 372580"];
8993 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 372581"];
8994 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 372582"];
8995 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol) 372583"];
8996 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 372584"];
8997 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 372585"];
8998 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 372586"];
8999 [label="ImmutableArray<string?> elementNames; 372587"];
9000 [label="elementNames 372588"];
9001 [label="containingModule\n                .Module 372589"];
9002 [label="get\n            {\n                return _module;\n            } 372590"];
9003 [label="return _module; 372591"];
9004 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 372592"];
9005 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 372593"];
9006 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 372594"];
9007 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 372595"];
9008 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 372596"];
9009 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 372597"];
9010 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 372598"];
9011 [label="DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute) 372599"];
9012 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 372600"];
9013 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 372601"];
9014 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 372602"];
9015 [label="RoslynDebug.AssertNotNull(metadataType); 372603"];
9016 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 372604"];
9017 [label="_elementNames 372605"];
9018 [label="elementNames.IsDefault 372606"];
9019 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 372607"];
9020 [label="_namesIndex 372608"];
9021 [label="_foundUsableErrorType = false; 372609"];
9022 [label="_foundUsableErrorType 372610"];
9023 [label="param DecodeType(this) 372611"];
9024 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 372612"];
9025 [label="param DecodeNamedType(this) 372613"];
9026 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 372614"];
9027 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 372615"];
9028 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 372616"];
9029 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 372617"];
9030 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 372618"];
9031 [label="DecodeTypeArguments(typeArgs) 372619"];
9032 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 372620"];
9033 [label="param DecodeTypeArguments(this) 372621"];
9034 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 372622"];
9035 [label="return typeArgs; 372623"];
9036 [label="type.ContainingType 372624"];
9037 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372625"];
9038 [label="return _container as NamedTypeSymbol; 372626"];
9039 [label="NamedTypeSymbol containingType = type.ContainingType; 372627"];
9040 [label="NamedTypeSymbol? decodedContainingType; 372628"];
9041 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 372629"];
9042 [label="decodedContainingType = containingType; 372630"];
9043 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372631"];
9044 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372632"];
9045 [label="var typeArgsChanged = typeArgs != decodedArgs; 372633"];
9046 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 372634"];
9047 [label="decodedType.IsTupleType 372635"];
9048 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 372636"];
9049 [label="_ 372637"];
9050 [label="tupleCardinality: out _ 372638"];
9051 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 372639"];
9052 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 372640"];
9053 [label="param IsTupleTypeOfCardinality(this) 372641"];
9054 [label="IsUnboundGenericType 372642"];
9055 [label="get\n            {\n                return false;\n            } 372643"];
9056 [label="return false; 372644"];
9057 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372645"];
9058 [label="ContainingSymbol 372646"];
9059 [label="get\n            {\n                return _container;\n            } 372647"];
9060 [label="return _container; 372648"];
9061 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372649"];
9062 [label=".Kind 372650"];
9063 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372651"];
9064 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372652"];
9065 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372653"];
9066 [label="ContainingNamespace 372654"];
9067 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372655"];
9068 [label="get\n            {\n                return _container;\n            } 372656"];
9069 [label="return _container; 372657"];
9070 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372658"];
9071 [label="ContainingNamespace.ContainingNamespace 372659"];
9072 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372660"];
9073 [label=".IsGlobalNamespace 372661"];
9074 [label="get\n            {\n                return true;\n            } 372662"];
9075 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372663"];
9076 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372664"];
9077 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372665"];
9078 [label="Name 372666"];
9079 [label="get\n            {\n                return _name;\n            } 372667"];
9080 [label="return _name; 372668"];
9081 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372669"];
9082 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372670"];
9083 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372671"];
9084 [label="tupleCardinality = 0; 372672"];
9085 [label="return false; 372673"];
9086 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 372674"];
9087 [label="return decoded; 372675"];
9088 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372676"];
9089 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372677"];
9090 [label="TypeWithAnnotations.Create(decodedType) 372678"];
9091 [label="param Create(TypeSymbol typeSymbol) 372679"];
9092 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 372680"];
9093 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 372681"];
9094 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 372682"];
9095 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 372683"];
9096 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 372684"];
9097 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 372685"];
9098 [label="typeSymbol.IsNullableType() 372686"];
9099 [label="param IsNullableType(this TypeSymbol type) 372687"];
9100 [label="type.OriginalDefinition 372688"];
9101 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372689"];
9102 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372690"];
9103 [label="type.OriginalDefinition.SpecialType 372691"];
9104 [label="get\n            {\n                return _corTypeId;\n            } 372692"];
9105 [label="var a1 = defaultType is null; 372693"];
9106 [label="!a1 372694"];
9107 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 372695"];
9108 [label="defaultType.IsNullableType() 372696"];
9109 [label="param IsNullableType(this TypeSymbol type) 372697"];
9110 [label="type.OriginalDefinition 372698"];
9111 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372699"];
9112 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372700"];
9113 [label="type.OriginalDefinition.SpecialType 372701"];
9114 [label="get\n            {\n                return _corTypeId;\n            } 372702"];
9115 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 372703"];
9116 [label="Debug.Assert(a1 || a2 != true || a3); 372704"];
9117 [label="Debug.Assert(a1 || a2 != true || a3); 372705"];
9118 [label="Debug.Assert(extensions != null); 372706"];
9119 [label="Debug.Assert(extensions != null); 372707"];
9120 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372708"];
9121 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372709"];
9122 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372710"];
9123 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 372711"];
9124 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this) 372712"];
9125 [label="param TransformType(TypeWithAnnotations metadataType) 372713"];
9126 [label="param TransformType(EntityHandle targetSymbolToken) 372714"];
9127 [label="param TransformType(PEModuleSymbol containingModule) 372715"];
9128 [label="param TransformType(Symbol accessSymbol) 372716"];
9129 [label="param TransformType(Symbol nullableContext) 372717"];
9130 [label="metadataType.HasType 372718"];
9131 [label="=> !(DefaultType is null) 372719"];
9132 [label="DefaultType is null 372720"];
9133 [label="!(DefaultType is null) 372721"];
9134 [label="Debug.Assert(metadataType.HasType); 372722"];
9135 [label="accessSymbol.IsDefinition 372723"];
9136 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 372724"];
9137 [label="Debug.Assert(accessSymbol.IsDefinition); 372725"];
9138 [label="accessSymbol.ContainingModule 372726"];
9139 [label="get\n            {\n                return ContainingPEModule;\n            } 372727"];
9140 [label="ContainingPEModule 372728"];
9141 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 372729"];
9142 [label="Symbol s = _container; 372730"];
9143 [label="s.Kind 372731"];
9144 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372732"];
9145 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372733"];
9146 [label="return ContainingPEModule; 372734"];
9147 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 372735"];
9148 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372736"];
9149 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372737"];
9150 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 372738"];
9151 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 372739"];
9152 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 372740"];
9153 [label="Debug.Assert(symbol is object); 372741"];
9154 [label="symbol.Kind 372742"];
9155 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 372743"];
9156 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 372744"];
9157 [label="isInternal = false; 372745"];
9158 [label="symbol.DeclaredAccessibility 372746"];
9159 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 372747"];
9160 [label="Accessibility access = Accessibility.Private; 372748"];
9161 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 372749"];
9162 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 372750"];
9163 [label="symbol.ContainingType 372751"];
9164 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372752"];
9165 [label="return _container as NamedTypeSymbol; 372753"];
9166 [label="symbol = symbol.ContainingType; 372754"];
9167 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 372755"];
9168 [label="return true; 372756"];
9169 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372757"];
9170 [label="return _module; 372758"];
9171 [label="byte? value; 372759"];
9172 [label="param TryGetByte(out byte? value) 372760"];
9173 [label="value = null; 372761"];
9174 [label="s.Kind 372762"];
9175 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372763"];
9176 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372764"];
9177 [label="param GetNullableContextValue(this) 372765"];
9178 [label="param GetLocalNullableContextValue(this) 372766"];
9179 [label="get\n            {\n                return _moduleSymbol;\n            } 372767"];
9180 [label="return _moduleSymbol; 372768"];
9181 [label="param GetLocalNullableContextValue(this) 372769"];
9182 [label="get\n            {\n                return _assemblySymbol;\n            } 372770"];
9183 [label="return _assemblySymbol; 372771"];
9184 [label="param GetLocalNullableContextValue(this) 372772"];
9185 [label="get\n            {\n                return null;\n            } 372773"];
9186 [label="return metadataType; 372774"];
9187 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type 372775"];
9188 [label="=> _extensions?.GetResolvedType(DefaultType) 372776"];
9189 [label="=> defaultType 372777"];
9190 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 372778"];
9191 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 372779"];
9192 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 372780"];
9193 [label="return _lazyDeclaredBaseType; 372781"];
9194 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 372782"];
9195 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 372783"];
9196 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 372784"];
9197 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 372785"];
9198 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 372786"];
9199 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 372787"];
9200 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 372788"];
9201 [label="param TypeDependsOn(NamedTypeSymbol depends) 372789"];
9202 [label="param TypeDependsOn(NamedTypeSymbol on) 372790"];
9203 [label="Debug.Assert((object)depends != null); 372791"];
9204 [label="Debug.Assert((object)depends != null); 372792"];
9205 [label="Debug.Assert((object)on != null); 372793"];
9206 [label="Debug.Assert((object)on != null); 372794"];
9207 [label="on.IsDefinition 372795"];
9208 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 372796"];
9209 [label="Debug.Assert(on.IsDefinition); 372797"];
9210 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 372798"];
9211 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 372799"];
9212 [label="depends.DeclaringCompilation 372800"];
9213 [label="get { return null; } 372801"];
9214 [label="return null; 372802"];
9215 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 372803"];
9216 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 372804"];
9217 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 372805"];
9218 [label="param TypeDependsClosure(NamedTypeSymbol type) 372806"];
9219 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 372807"];
9220 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 372808"];
9221 [label="if ((object)type == null)\n            {\n                return;\n            } 372809"];
9222 [label="if ((object)type == null)\n            {\n                return;\n            } 372810"];
9223 [label="type.OriginalDefinition 372811"];
9224 [label="get\n            {\n                return this;\n            } 372812"];
9225 [label="type = type.OriginalDefinition; 372813"];
9226 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 372814"];
9227 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 372815"];
9228 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 372816"];
9229 [label="param GetHashCode(this) 372817"];
9230 [label="this.SpecialType 372818"];
9231 [label="get\n            {\n                return _corTypeId;\n            } 372819"];
9232 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 372820"];
9233 [label="OriginalDefinition 372821"];
9234 [label="get\n            {\n                return this;\n            } 372822"];
9235 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 372823"];
9236 [label="type.IsInterface 372824"];
9237 [label="get\n            {\n                return _flags.IsInterface();\n            } 372825"];
9238 [label="return _flags.IsInterface(); 372826"];
9239 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 372827"];
9240 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 372828"];
9241 [label="type.GetDeclaredBaseType(null) 372829"];
9242 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 372830"];
9243 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 372831"];
9244 [label="s.Kind 372832"];
9245 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372833"];
9246 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372834"];
9247 [label="Debug.Assert((object)moduleSymbol != null); 372835"];
9248 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 372836"];
9249 [label="param TransformType(int targetSymbolCustomModifierCount) 372837"];
9250 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 372838"];
9251 [label="Debug.Assert((object)metadataType != null); 372839"];
9252 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 372840"];
9253 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 372841"];
9254 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 372842"];
9255 [label="_elementNames 372843"];
9256 [label="elementNames.IsDefault 372844"];
9257 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 372845"];
9258 [label="_namesIndex 372846"];
9259 [label="_foundUsableErrorType = false; 372847"];
9260 [label="_foundUsableErrorType 372848"];
9261 [label="param DecodeType(this) 372849"];
9262 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 372850"];
9263 [label="param DecodeNamedType(this) 372851"];
9264 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 372852"];
9265 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 372853"];
9266 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 372854"];
9267 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 372855"];
9268 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 372856"];
9269 [label="DecodeTypeArguments(typeArgs) 372857"];
9270 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 372858"];
9271 [label="param DecodeTypeArguments(this) 372859"];
9272 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 372860"];
9273 [label="return typeArgs; 372861"];
9274 [label="type.ContainingType 372862"];
9275 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372863"];
9276 [label="return _container as NamedTypeSymbol; 372864"];
9277 [label="NamedTypeSymbol containingType = type.ContainingType; 372865"];
9278 [label="NamedTypeSymbol? decodedContainingType; 372866"];
9279 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 372867"];
9280 [label="decodedContainingType = containingType; 372868"];
9281 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372869"];
9282 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 372870"];
9283 [label="var typeArgsChanged = typeArgs != decodedArgs; 372871"];
9284 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 372872"];
9285 [label="decodedType.IsTupleType 372873"];
9286 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 372874"];
9287 [label="_ 372875"];
9288 [label="tupleCardinality: out _ 372876"];
9289 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 372877"];
9290 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 372878"];
9291 [label="param IsTupleTypeOfCardinality(this) 372879"];
9292 [label="IsUnboundGenericType 372880"];
9293 [label="get\n            {\n                return false;\n            } 372881"];
9294 [label="return false; 372882"];
9295 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372883"];
9296 [label="ContainingSymbol 372884"];
9297 [label="get\n            {\n                return _container;\n            } 372885"];
9298 [label="return _container; 372886"];
9299 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372887"];
9300 [label=".Kind 372888"];
9301 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372889"];
9302 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372890"];
9303 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372891"];
9304 [label="ContainingNamespace 372892"];
9305 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372893"];
9306 [label="get\n            {\n                return _container;\n            } 372894"];
9307 [label="return _container; 372895"];
9308 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372896"];
9309 [label="ContainingNamespace.ContainingNamespace 372897"];
9310 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 372898"];
9311 [label=".IsGlobalNamespace 372899"];
9312 [label="get\n            {\n                return true;\n            } 372900"];
9313 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372901"];
9314 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372902"];
9315 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372903"];
9316 [label="Name 372904"];
9317 [label="get\n            {\n                return _name;\n            } 372905"];
9318 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372906"];
9319 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372907"];
9320 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 372908"];
9321 [label="tupleCardinality = 0; 372909"];
9322 [label="return false; 372910"];
9323 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 372911"];
9324 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 372912"];
9325 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 372913"];
9326 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 372914"];
9327 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 372915"];
9328 [label="typeSymbol.IsNullableType() 372916"];
9329 [label="param IsNullableType(this TypeSymbol type) 372917"];
9330 [label="type.OriginalDefinition 372918"];
9331 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372919"];
9332 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372920"];
9333 [label="type.OriginalDefinition.SpecialType 372921"];
9334 [label="get\n            {\n                return _corTypeId;\n            } 372922"];
9335 [label="var a1 = defaultType is null; 372923"];
9336 [label="!a1 372924"];
9337 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 372925"];
9338 [label="defaultType.IsNullableType() 372926"];
9339 [label="param IsNullableType(this TypeSymbol type) 372927"];
9340 [label="type.OriginalDefinition 372928"];
9341 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 372929"];
9342 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 372930"];
9343 [label="type.OriginalDefinition.SpecialType 372931"];
9344 [label="get\n            {\n                return _corTypeId;\n            } 372932"];
9345 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 372933"];
9346 [label="Debug.Assert(a1 || a2 != true || a3); 372934"];
9347 [label="Debug.Assert(a1 || a2 != true || a3); 372935"];
9348 [label="Debug.Assert(extensions != null); 372936"];
9349 [label="Debug.Assert(extensions != null); 372937"];
9350 [label="param TransformType(Symbol accessSymbol) 372938"];
9351 [label="metadataType.HasType 372939"];
9352 [label="=> !(DefaultType is null) 372940"];
9353 [label="DefaultType is null 372941"];
9354 [label="!(DefaultType is null) 372942"];
9355 [label="Debug.Assert(metadataType.HasType); 372943"];
9356 [label="accessSymbol.IsDefinition 372944"];
9357 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 372945"];
9358 [label="Debug.Assert(accessSymbol.IsDefinition); 372946"];
9359 [label="accessSymbol.ContainingModule 372947"];
9360 [label="get\n            {\n                return ContainingPEModule;\n            } 372948"];
9361 [label="ContainingPEModule 372949"];
9362 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 372950"];
9363 [label="s.Kind 372951"];
9364 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372952"];
9365 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372953"];
9366 [label="return ContainingPEModule; 372954"];
9367 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 372955"];
9368 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372956"];
9369 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372957"];
9370 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 372958"];
9371 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 372959"];
9372 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 372960"];
9373 [label="Debug.Assert(symbol is object); 372961"];
9374 [label="symbol.Kind 372962"];
9375 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 372963"];
9376 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 372964"];
9377 [label="isInternal = false; 372965"];
9378 [label="symbol.DeclaredAccessibility 372966"];
9379 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 372967"];
9380 [label="Accessibility access = Accessibility.Private; 372968"];
9381 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 372969"];
9382 [label="symbol.ContainingType 372970"];
9383 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 372971"];
9384 [label="return _container as NamedTypeSymbol; 372972"];
9385 [label="symbol = symbol.ContainingType; 372973"];
9386 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 372974"];
9387 [label="return true; 372975"];
9388 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 372976"];
9389 [label="param TryGetByte(out byte? value) 372977"];
9390 [label="value = null; 372978"];
9391 [label="s.Kind 372979"];
9392 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 372980"];
9393 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 372981"];
9394 [label="param GetNullableContextValue(this) 372982"];
9395 [label="param GetLocalNullableContextValue(this) 372983"];
9396 [label="get\n            {\n                return _moduleSymbol;\n            } 372984"];
9397 [label="return _moduleSymbol; 372985"];
9398 [label="param GetLocalNullableContextValue(this) 372986"];
9399 [label="get\n            {\n                return _assemblySymbol;\n            } 372987"];
9400 [label="return _assemblySymbol; 372988"];
9401 [label="param GetLocalNullableContextValue(this) 372989"];
9402 [label="get\n            {\n                return null;\n            } 372990"];
9403 [label="=> defaultType 372991"];
9404 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 372992"];
9405 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 372993"];
9406 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 372994"];
9407 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 372995"];
9408 [label="param TypeDependsClosure(NamedTypeSymbol type) 372996"];
9409 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 372997"];
9410 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 372998"];
9411 [label="if ((object)type == null)\n            {\n                return;\n            } 372999"];
9412 [label="if ((object)type == null)\n            {\n                return;\n            } 373000"];
9413 [label="this.SpecialType 373001"];
9414 [label="get\n            {\n                return _corTypeId;\n            } 373002"];
9415 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 373003"];
9416 [label="return (int)SpecialType.System_Object; 373004"];
9417 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373005"];
9418 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373006"];
9419 [label="s.Kind 373007"];
9420 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373008"];
9421 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373009"];
9422 [label="return null; 373010"];
9423 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 373011"];
9424 [label="if ((object)type == null)\n            {\n                return;\n            } 373012"];
9425 [label="if ((object)type == null)\n            {\n                return;\n            } 373013"];
9426 [label="return; 373014"];
9427 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373015"];
9428 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373016"];
9429 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373017"];
9430 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373018"];
9431 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 373019"];
9432 [label="var result = hs.Contains(on); 373020"];
9433 [label="var result = hs.Contains(on); 373021"];
9434 [label="var result = hs.Contains(on); 373022"];
9435 [label="this.SpecialType 373023"];
9436 [label="OriginalDefinition 373024"];
9437 [label="hs.Free(); 373025"];
9438 [label="return result; 373026"];
9439 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 373027"];
9440 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 373028"];
9441 [label="_hasNoBaseCycles = true; 373029"];
9442 [label="_hasNoBaseCycles 373030"];
9443 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 373031"];
9444 [label="return declaredBase; 373032"];
9445 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 373033"];
9446 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 373034"];
9447 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 373035"];
9448 [label="return _lazyBaseType; 373036"];
9449 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 373037"];
9450 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 373038"];
9451 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 373039"];
9452 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373040"];
9453 [label="@base.IsErrorType() 373041"];
9454 [label="param IsErrorType(this TypeSymbol type) 373042"];
9455 [label="RoslynDebug.Assert((object)type != null); 373043"];
9456 [label="RoslynDebug.Assert((object)type != null); 373044"];
9457 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373045"];
9458 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373046"];
9459 [label="@base.BaseTypeNoUseSiteDiagnostics 373047"];
9460 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373048"];
9461 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373049"];
9462 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 373050"];
9463 [label="Debug.Assert((object)depends != null); 373051"];
9464 [label="Debug.Assert((object)on != null); 373052"];
9465 [label="on.IsDefinition 373053"];
9466 [label="Debug.Assert(on.IsDefinition); 373054"];
9467 [label="depends.DeclaringCompilation 373055"];
9468 [label="get { return null; } 373056"];
9469 [label="return null; 373057"];
9470 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 373058"];
9471 [label="if ((object)type == null)\n            {\n                return;\n            } 373059"];
9472 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373060"];
9473 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373061"];
9474 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 373062"];
9475 [label="if ((object)type == null)\n            {\n                return;\n            } 373063"];
9476 [label="return; 373064"];
9477 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373065"];
9478 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373066"];
9479 [label="return result; 373067"];
9480 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 373068"];
9481 [label="@base = @base.BaseTypeNoUseSiteDiagnostics; 373069"];
9482 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373070"];
9483 [label="@base.IsErrorType() 373071"];
9484 [label="param IsErrorType(this TypeSymbol type) 373072"];
9485 [label="RoslynDebug.Assert((object)type != null); 373073"];
9486 [label="RoslynDebug.Assert((object)type != null); 373074"];
9487 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373075"];
9488 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373076"];
9489 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373077"];
9490 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373078"];
9491 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 373079"];
9492 [label="return null; 373080"];
9493 [label="return null; 373081"];
9494 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 373082"];
9495 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 373083"];
9496 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 373084"];
9497 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 373085"];
9498 [label="param MergeUseSiteDiagnostics(this) 373086"];
9499 [label="if (info == null)\n            {\n                return false;\n            } 373087"];
9500 [label="if (info == null)\n            {\n                return false;\n            } 373088"];
9501 [label="return false; 373089"];
9502 [label="this.ContainingModule 373090"];
9503 [label="get\n            {\n                return ContainingPEModule;\n            } 373091"];
9504 [label="ContainingPEModule 373092"];
9505 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373093"];
9506 [label="Symbol s = _container; 373094"];
9507 [label="s.Kind 373095"];
9508 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373096"];
9509 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373097"];
9510 [label="return ContainingPEModule; 373098"];
9511 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 373099"];
9512 [label="this.ContainingModule.HasUnifiedReferences 373100"];
9513 [label="get { return GetUnifiedAssemblies().Length > 0; } 373101"];
9514 [label="GetUnifiedAssemblies() 373102"];
9515 [label="param GetUnifiedAssemblies(this) 373103"];
9516 [label="AssertReferencesInitialized() 373104"];
9517 [label="param AssertReferencesInitialized(this) 373105"];
9518 [label="Debug.Assert(_moduleReferences != null); 373106"];
9519 [label="Debug.Assert(_moduleReferences != null); 373107"];
9520 [label="AssertReferencesInitialized(); 373108"];
9521 [label="return GetUnifiedAssemblies().Length > 0; 373109"];
9522 [label="return GetUnifiedAssemblies().Length > 0; 373110"];
9523 [label="return result; 373111"];
9524 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 373112"];
9525 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 373113"];
9526 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 373114"];
9527 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 373115"];
9528 [label="param MergeUseSiteDiagnostics(this) 373116"];
9529 [label="if (info == null)\n            {\n                return false;\n            } 373117"];
9530 [label="if (info == null)\n            {\n                return false;\n            } 373118"];
9531 [label="return false; 373119"];
9532 [label="this.ContainingPEModule 373120"];
9533 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373121"];
9534 [label="Symbol s = _container; 373122"];
9535 [label="s.Kind 373123"];
9536 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373124"];
9537 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373125"];
9538 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 373126"];
9539 [label="this.ContainingPEModule.Module 373127"];
9540 [label="get\n            {\n                return _module;\n            } 373128"];
9541 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 373129"];
9542 [label="TypeKind 373130"];
9543 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 373131"];
9544 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373132"];
9545 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 373133"];
9546 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 373134"];
9547 [label="@base.SpecialType 373135"];
9548 [label="SpecialType baseCorTypeId = @base.SpecialType; 373136"];
9549 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 373137"];
9550 [label="this.SpecialType 373138"];
9551 [label="if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    } 373139"];
9552 [label="result = TypeKind.Struct; 373140"];
9553 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 373141"];
9554 [label="return diagnostic; 373142"];
9555 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 373143"];
9556 [label="_lazyUseSiteDiagnostic 373144"];
9557 [label="return _lazyUseSiteDiagnostic; 373145"];
9558 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 373146"];
9559 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 373147"];
9560 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 373148"];
9561 [label="return MergeUseSiteDiagnostics(ref result, info); 373149"];
9562 [label="return MergeUseSiteDiagnostics(ref result, info); 373150"];
9563 [label="MergeUseSiteDiagnostics(ref result, info) 373151"];
9564 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 373152"];
9565 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 373153"];
9566 [label="param MergeUseSiteDiagnostics(this) 373154"];
9567 [label="if (info == null)\n            {\n                return false;\n            } 373155"];
9568 [label="type.CustomModifiers 373156"];
9569 [label="=> _extensions.CustomModifiers 373157"];
9570 [label="_customModifiers 373158"];
9571 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 373159"];
9572 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 373160"];
9573 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 373161"];
9574 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 373162"];
9575 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 373163"];
9576 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 373164"];
9577 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 373165"];
9578 [label="bool checkRequiredModifiers = true; 373166"];
9579 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 373167"];
9580 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 373168"];
9581 [label="return false; 373169"];
9582 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 373170"];
9583 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 373171"];
9584 [label="this.RefCustomModifiers 373172"];
9585 [label="=> Signature.ReturnParam.RefCustomModifiers 373173"];
9586 [label="Signature 373174"];
9587 [label="=> _lazySignature ?? LoadSignature() 373175"];
9588 [label="_lazySignature ?? LoadSignature() 373176"];
9589 [label="Signature.ReturnParam.RefCustomModifiers 373177"];
9590 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 373178"];
9591 [label="return ImmutableArray<CustomModifier>.Empty; 373179"];
9592 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373180"];
9593 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373181"];
9594 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 373182"];
9595 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 373183"];
9596 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 373184"];
9597 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 373185"];
9598 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 373186"];
9599 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 373187"];
9600 [label="bool checkRequiredModifiers = true; 373188"];
9601 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 373189"];
9602 [label="return false; 373190"];
9603 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373191"];
9604 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373192"];
9605 [label="this.Parameters 373193"];
9606 [label="=> Signature.Parameters 373194"];
9607 [label="_lazySignature ?? LoadSignature() 373195"];
9608 [label="DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters) 373196"];
9609 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 373197"];
9610 [label="param DeriveUseSiteDiagnosticFromParameters(ImmutableArray<ParameterSymbol> parameters) 373198"];
9611 [label="param DeriveUseSiteDiagnosticFromParameters(this) 373199"];
9612 [label="foreach (ParameterSymbol param in parameters)\n            {\n                if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                }\n            } 373200"];
9613 [label="foreach (ParameterSymbol param in parameters)\n            {\n                if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                }\n            } 373201"];
9614 [label="if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                } 373202"];
9615 [label="if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                } 373203"];
9616 [label="DeriveUseSiteDiagnosticFromParameter(ref result, param) 373204"];
9617 [label="param DeriveUseSiteDiagnosticFromParameter(ref DiagnosticInfo result) 373205"];
9618 [label="param DeriveUseSiteDiagnosticFromParameter(ParameterSymbol param) 373206"];
9619 [label="param DeriveUseSiteDiagnosticFromParameter(this) 373207"];
9620 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373208"];
9621 [label="param.TypeWithAnnotations 373209"];
9622 [label="get\n            {\n                return _typeWithAnnotations;\n            } 373210"];
9623 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373211"];
9624 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373212"];
9625 [label="DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) 373213"];
9626 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 373214"];
9627 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 373215"];
9628 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 373216"];
9629 [label="param DeriveUseSiteDiagnosticFromType(this) 373217"];
9630 [label="=> defaultType 373218"];
9631 [label="param DeriveUseSiteDiagnosticFromType(this) 373219"];
9632 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373220"];
9633 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373221"];
9634 [label="s.Kind 373222"];
9635 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373223"];
9636 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373224"];
9637 [label="Debug.Assert((object)moduleSymbol != null); 373225"];
9638 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 373226"];
9639 [label="param TransformType(int targetSymbolCustomModifierCount) 373227"];
9640 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 373228"];
9641 [label="Debug.Assert((object)metadataType != null); 373229"];
9642 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 373230"];
9643 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 373231"];
9644 [label="_elementNames 373232"];
9645 [label="elementNames.IsDefault 373233"];
9646 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 373234"];
9647 [label="_namesIndex 373235"];
9648 [label="_foundUsableErrorType = false; 373236"];
9649 [label="_foundUsableErrorType 373237"];
9650 [label="param DecodeType(this) 373238"];
9651 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373239"];
9652 [label="param DecodeNamedType(this) 373240"];
9653 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 373241"];
9654 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 373242"];
9655 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 373243"];
9656 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 373244"];
9657 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 373245"];
9658 [label="DecodeTypeArguments(typeArgs) 373246"];
9659 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 373247"];
9660 [label="param DecodeTypeArguments(this) 373248"];
9661 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 373249"];
9662 [label="return typeArgs; 373250"];
9663 [label="type.ContainingType 373251"];
9664 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373252"];
9665 [label="return _container as NamedTypeSymbol; 373253"];
9666 [label="NamedTypeSymbol containingType = type.ContainingType; 373254"];
9667 [label="NamedTypeSymbol? decodedContainingType; 373255"];
9668 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 373256"];
9669 [label="decodedContainingType = containingType; 373257"];
9670 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373258"];
9671 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373259"];
9672 [label="var typeArgsChanged = typeArgs != decodedArgs; 373260"];
9673 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 373261"];
9674 [label="decodedType.IsTupleType 373262"];
9675 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 373263"];
9676 [label="_ 373264"];
9677 [label="tupleCardinality: out _ 373265"];
9678 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 373266"];
9679 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 373267"];
9680 [label="param IsTupleTypeOfCardinality(this) 373268"];
9681 [label="IsUnboundGenericType 373269"];
9682 [label="get\n            {\n                return false;\n            } 373270"];
9683 [label="return false; 373271"];
9684 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373272"];
9685 [label="ContainingSymbol 373273"];
9686 [label="get\n            {\n                return _container;\n            } 373274"];
9687 [label="return _container; 373275"];
9688 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373276"];
9689 [label=".Kind 373277"];
9690 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373278"];
9691 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373279"];
9692 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373280"];
9693 [label="ContainingNamespace 373281"];
9694 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373282"];
9695 [label="get\n            {\n                return _container;\n            } 373283"];
9696 [label="return _container; 373284"];
9697 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373285"];
9698 [label="ContainingNamespace.ContainingNamespace 373286"];
9699 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373287"];
9700 [label=".IsGlobalNamespace 373288"];
9701 [label="get\n            {\n                return true;\n            } 373289"];
9702 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373290"];
9703 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373291"];
9704 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373292"];
9705 [label="Name 373293"];
9706 [label="get\n            {\n                return _name;\n            } 373294"];
9707 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373295"];
9708 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373296"];
9709 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373297"];
9710 [label="tupleCardinality = 0; 373298"];
9711 [label="return false; 373299"];
9712 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 373300"];
9713 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 373301"];
9714 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 373302"];
9715 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 373303"];
9716 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 373304"];
9717 [label="typeSymbol.IsNullableType() 373305"];
9718 [label="param IsNullableType(this TypeSymbol type) 373306"];
9719 [label="type.OriginalDefinition 373307"];
9720 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373308"];
9721 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373309"];
9722 [label="type.OriginalDefinition.SpecialType 373310"];
9723 [label="get\n            {\n                return _corTypeId;\n            } 373311"];
9724 [label="var a1 = defaultType is null; 373312"];
9725 [label="!a1 373313"];
9726 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 373314"];
9727 [label="defaultType.IsNullableType() 373315"];
9728 [label="param IsNullableType(this TypeSymbol type) 373316"];
9729 [label="type.OriginalDefinition 373317"];
9730 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373318"];
9731 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373319"];
9732 [label="type.OriginalDefinition.SpecialType 373320"];
9733 [label="get\n            {\n                return _corTypeId;\n            } 373321"];
9734 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 373322"];
9735 [label="Debug.Assert(a1 || a2 != true || a3); 373323"];
9736 [label="Debug.Assert(a1 || a2 != true || a3); 373324"];
9737 [label="Debug.Assert(extensions != null); 373325"];
9738 [label="param TransformType(Symbol accessSymbol) 373326"];
9739 [label="metadataType.HasType 373327"];
9740 [label="=> !(DefaultType is null) 373328"];
9741 [label="DefaultType is null 373329"];
9742 [label="!(DefaultType is null) 373330"];
9743 [label="Debug.Assert(metadataType.HasType); 373331"];
9744 [label="accessSymbol.IsDefinition 373332"];
9745 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 373333"];
9746 [label="Debug.Assert(accessSymbol.IsDefinition); 373334"];
9747 [label="accessSymbol.ContainingModule 373335"];
9748 [label="get\n            {\n                return ContainingPEModule;\n            } 373336"];
9749 [label="ContainingPEModule 373337"];
9750 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373338"];
9751 [label="s.Kind 373339"];
9752 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373340"];
9753 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373341"];
9754 [label="return ContainingPEModule; 373342"];
9755 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 373343"];
9756 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373344"];
9757 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373345"];
9758 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 373346"];
9759 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 373347"];
9760 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 373348"];
9761 [label="Debug.Assert(symbol is object); 373349"];
9762 [label="symbol.Kind 373350"];
9763 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373351"];
9764 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 373352"];
9765 [label="isInternal = false; 373353"];
9766 [label="symbol.DeclaredAccessibility 373354"];
9767 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 373355"];
9768 [label="Accessibility access = Accessibility.Private; 373356"];
9769 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 373357"];
9770 [label="symbol.ContainingType 373358"];
9771 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373359"];
9772 [label="return _container as NamedTypeSymbol; 373360"];
9773 [label="symbol = symbol.ContainingType; 373361"];
9774 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 373362"];
9775 [label="return true; 373363"];
9776 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373364"];
9777 [label="param TryGetByte(out byte? value) 373365"];
9778 [label="value = null; 373366"];
9779 [label="param GetLocalNullableContextValue(this) 373367"];
9780 [label="get\n            {\n                return _moduleSymbol;\n            } 373368"];
9781 [label="return _moduleSymbol; 373369"];
9782 [label="param GetLocalNullableContextValue(this) 373370"];
9783 [label="get\n            {\n                return _assemblySymbol;\n            } 373371"];
9784 [label="return _assemblySymbol; 373372"];
9785 [label="param GetLocalNullableContextValue(this) 373373"];
9786 [label="get\n            {\n                return null;\n            } 373374"];
9787 [label="=> defaultType 373375"];
9788 [label="Debug.Assert((object)depends != null); 373376"];
9789 [label="Debug.Assert((object)on != null); 373377"];
9790 [label="Debug.Assert(on.IsDefinition); 373378"];
9791 [label="depends.DeclaringCompilation 373379"];
9792 [label="get { return null; } 373380"];
9793 [label="return null; 373381"];
9794 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 373382"];
9795 [label="if ((object)type == null)\n            {\n                return;\n            } 373383"];
9796 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373384"];
9797 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373385"];
9798 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 373386"];
9799 [label="if ((object)type == null)\n            {\n                return;\n            } 373387"];
9800 [label="return; 373388"];
9801 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373389"];
9802 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373390"];
9803 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373391"];
9804 [label="return result; 373392"];
9805 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 373393"];
9806 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373394"];
9807 [label="@base.IsErrorType() 373395"];
9808 [label="param IsErrorType(this TypeSymbol type) 373396"];
9809 [label="RoslynDebug.Assert((object)type != null); 373397"];
9810 [label="RoslynDebug.Assert((object)type != null); 373398"];
9811 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373399"];
9812 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373400"];
9813 [label="return null; 373401"];
9814 [label="param MergeUseSiteDiagnostics(this) 373402"];
9815 [label="this.ContainingModule 373403"];
9816 [label="get\n            {\n                return ContainingPEModule;\n            } 373404"];
9817 [label="ContainingPEModule 373405"];
9818 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373406"];
9819 [label="Symbol s = _container; 373407"];
9820 [label="s.Kind 373408"];
9821 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373409"];
9822 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373410"];
9823 [label="return ContainingPEModule; 373411"];
9824 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 373412"];
9825 [label="this.ContainingModule.HasUnifiedReferences 373413"];
9826 [label="get { return GetUnifiedAssemblies().Length > 0; } 373414"];
9827 [label="GetUnifiedAssemblies() 373415"];
9828 [label="param GetUnifiedAssemblies(this) 373416"];
9829 [label="AssertReferencesInitialized() 373417"];
9830 [label="param AssertReferencesInitialized(this) 373418"];
9831 [label="Debug.Assert(_moduleReferences != null); 373419"];
9832 [label="Debug.Assert(_moduleReferences != null); 373420"];
9833 [label="AssertReferencesInitialized(); 373421"];
9834 [label="return GetUnifiedAssemblies().Length > 0; 373422"];
9835 [label="return GetUnifiedAssemblies().Length > 0; 373423"];
9836 [label="Symbol s = _container; 373424"];
9837 [label="s.Kind 373425"];
9838 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373426"];
9839 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373427"];
9840 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 373428"];
9841 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373429"];
9842 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 373430"];
9843 [label="return _lazyUseSiteDiagnostic; 373431"];
9844 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 373432"];
9845 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 373433"];
9846 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 373434"];
9847 [label="return MergeUseSiteDiagnostics(ref result, info); 373435"];
9848 [label="MergeUseSiteDiagnostics(ref result, info) 373436"];
9849 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 373437"];
9850 [label="param MergeUseSiteDiagnostics(this) 373438"];
9851 [label="type.CustomModifiers 373439"];
9852 [label="=> _extensions.CustomModifiers 373440"];
9853 [label="_customModifiers 373441"];
9854 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 373442"];
9855 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 373443"];
9856 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 373444"];
9857 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 373445"];
9858 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 373446"];
9859 [label="bool checkRequiredModifiers = true; 373447"];
9860 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 373448"];
9861 [label="return false; 373449"];
9862 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 373450"];
9863 [label="param.RefCustomModifiers 373451"];
9864 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 373452"];
9865 [label="return ImmutableArray<CustomModifier>.Empty; 373453"];
9866 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373454"];
9867 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373455"];
9868 [label="method.MethodKind 373456"];
9869 [label="get\n            {\n                if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                }\n                return _packedFlags.MethodKind;\n            } 373457"];
9870 [label="=> (_bits & MethodKindIsPopulatedBit) != 0 373458"];
9871 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 373459"];
9872 [label="this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature 373460"];
9873 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 373461"];
9874 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 373462"];
9875 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 373463"];
9876 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 373464"];
9877 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 373465"];
9878 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 373466"];
9879 [label="bool checkRequiredModifiers = true; 373467"];
9880 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 373468"];
9881 [label="return false; 373469"];
9882 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373470"];
9883 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 373471"];
9884 [label="return false; 373472"];
9885 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373473"];
9886 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 373474"];
9887 [label="this.ContainingModule 373475"];
9888 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 373476"];
9889 [label="this.ContainingSymbol 373477"];
9890 [label="=> _containingType 373478"];
9891 [label="_containingType 373479"];
9892 [label="var container = this.ContainingSymbol; 373480"];
9893 [label="return (object)container != null ? container.ContainingModule : null; 373481"];
9894 [label="return (object)container != null ? container.ContainingModule : null; 373482"];
9895 [label="(object)container != null 373483"];
9896 [label="container.ContainingModule 373484"];
9897 [label="get\n            {\n                return ContainingPEModule;\n            } 373485"];
9898 [label="ContainingPEModule 373486"];
9899 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373487"];
9900 [label="s.Kind 373488"];
9901 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373489"];
9902 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373490"];
9903 [label="return ContainingPEModule; 373491"];
9904 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 373492"];
9905 [label=".HasUnifiedReferences 373493"];
9906 [label="get { return GetUnifiedAssemblies().Length > 0; } 373494"];
9907 [label="GetUnifiedAssemblies() 373495"];
9908 [label="param GetUnifiedAssemblies(this) 373496"];
9909 [label="AssertReferencesInitialized() 373497"];
9910 [label="param AssertReferencesInitialized(this) 373498"];
9911 [label="Debug.Assert(_moduleReferences != null); 373499"];
9912 [label="Debug.Assert(_moduleReferences != null); 373500"];
9913 [label="AssertReferencesInitialized(); 373501"];
9914 [label="return GetUnifiedAssemblies().Length > 0; 373502"];
9915 [label="return GetUnifiedAssemblies().Length > 0; 373503"];
9916 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 373504"];
9917 [label="return false; 373505"];
9918 [label="CalculateUseSiteDiagnostic(ref result); 373506"];
9919 [label="EnsureTypeParametersAreLoaded(ref result); 373507"];
9920 [label="EnsureTypeParametersAreLoaded(ref result) 373508"];
9921 [label="param EnsureTypeParametersAreLoaded(ref DiagnosticInfo diagnosticInfo) 373509"];
9922 [label="param EnsureTypeParametersAreLoaded(this) 373510"];
9923 [label="var typeParams = _lazyTypeParameters; 373511"];
9924 [label="if (!typeParams.IsDefault)\n            {\n                return typeParams;\n            } 373512"];
9925 [label="return typeParams; 373513"];
9926 [label="EnsureTypeParametersAreLoaded(ref result); 373514"];
9927 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 373515"];
9928 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 373516"];
9929 [label="GetUnmanagedCallersOnlyAttributeData(forceComplete: true) 373517"];
9930 [label="param GetUnmanagedCallersOnlyAttributeData(bool forceComplete) 373518"];
9931 [label="param GetUnmanagedCallersOnlyAttributeData(this) 373519"];
9932 [label="_packedFlags.IsUnmanagedCallersOnlyAttributePopulated 373520"];
9933 [label="=> (_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 373521"];
9934 [label="_bits & IsUnmanagedCallersOnlyAttributePopulatedBit 373522"];
9935 [label="0 373523"];
9936 [label="(_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 373524"];
9937 [label="if (!_packedFlags.IsUnmanagedCallersOnlyAttributePopulated)\n            {\n                var containingModule = (PEModuleSymbol)ContainingModule;\n                var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null));\n\n                Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n\n                var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized);\n\n                _packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated();\n                return result;\n            } 373525"];
9938 [label="ContainingModule 373526"];
9939 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 373527"];
9940 [label="this.ContainingSymbol 373528"];
9941 [label="=> _containingType 373529"];
9942 [label="_containingType 373530"];
9943 [label="var container = this.ContainingSymbol; 373531"];
9944 [label="return (object)container != null ? container.ContainingModule : null; 373532"];
9945 [label="return (object)container != null ? container.ContainingModule : null; 373533"];
9946 [label="(object)container != null 373534"];
9947 [label="container.ContainingModule 373535"];
9948 [label="get\n            {\n                return ContainingPEModule;\n            } 373536"];
9949 [label="ContainingPEModule 373537"];
9950 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 373538"];
9951 [label="s.Kind 373539"];
9952 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373540"];
9953 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373541"];
9954 [label="return ContainingPEModule; 373542"];
9955 [label="var containingModule = (PEModuleSymbol)ContainingModule; 373543"];
9956 [label="containingModule.Module 373544"];
9957 [label="get\n            {\n                return _module;\n            } 373545"];
9958 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 373546"];
9959 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 373547"];
9960 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 373548"];
9961 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 373549"];
9962 [label="new MetadataDecoder(containingModule) 373550"];
9963 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 373551"];
9964 [label="param MetadataDecoder(this) 373552"];
9965 [label="moduleSymbol 373553"];
9966 [label="null 373554"];
9967 [label="null 373555"];
9968 [label="param MetadataDecoder(this) 373556"];
9969 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 373557"];
9970 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 373558"];
9971 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 373559"];
9972 [label="Debug.Assert((object)moduleSymbol != null); 373560"];
9973 [label="Debug.Assert((object)moduleSymbol != null); 373561"];
9974 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 373562"];
9975 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 373563"];
9976 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 373564"];
9977 [label="AccessUncommonFields() 373565"];
9978 [label="param AccessUncommonFields(this) 373566"];
9979 [label="var retVal = _uncommonFields; 373567"];
9980 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 373568"];
9981 [label="CreateUncommonFields() 373569"];
9982 [label="param CreateUncommonFields(this) 373570"];
9983 [label="var retVal = new UncommonFields(); 373571"];
9984 [label="new UncommonFields() 373572"];
9985 [label="param UncommonFields(this) 373573"];
9986 [label="_lazyThisParameter 373574"];
9987 [label="_lazyDocComment 373575"];
9988 [label="_lazyOverriddenOrHiddenMembersResult 373576"];
9989 [label="_lazyObsoleteAttributeData 373577"];
9990 [label="_lazyUnmanagedCallersOnlyAttributeData 373578"];
9991 [label="_lazyUseSiteDiagnostic 373579"];
9992 [label="_lazyExplicitClassOverride 373580"];
9993 [label="_packedFlags.IsObsoleteAttributePopulated 373581"];
9994 [label="=> (_bits & IsObsoleteAttributePopulatedBit) != 0 373582"];
9995 [label="_bits & IsObsoleteAttributePopulatedBit 373583"];
9996 [label="0 373584"];
9997 [label="(_bits & IsObsoleteAttributePopulatedBit) != 0 373585"];
9998 [label="if (!_packedFlags.IsObsoleteAttributePopulated)\n            {\n                retVal._lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized;\n            } 373586"];
9999 [label="retVal._lazyObsoleteAttributeData 373587"];
10000 [label="_packedFlags.IsUnmanagedCallersOnlyAttributePopulated 373588"];
10001 [label="=> (_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 373589"];
10002 [label="if (!_packedFlags.IsUnmanagedCallersOnlyAttributePopulated)\n            {\n                retVal._lazyUnmanagedCallersOnlyAttributeData = UnmanagedCallersOnlyAttributeData.Uninitialized;\n            } 373590"];
10003 [label="retVal._lazyUnmanagedCallersOnlyAttributeData 373591"];
10004 [label="_packedFlags.IsCustomAttributesPopulated 373592"];
10005 [label="=> (_bits & IsCustomAttributesPopulatedBit) != 0 373593"];
10006 [label="_bits & IsCustomAttributesPopulatedBit 373594"];
10007 [label="0 373595"];
10008 [label="(_bits & IsCustomAttributesPopulatedBit) != 0 373596"];
10009 [label="if (_packedFlags.IsCustomAttributesPopulated)\n            {\n                retVal._lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n            } 373597"];
10010 [label="_packedFlags.IsConditionalPopulated 373598"];
10011 [label="=> (_bits & IsConditionalPopulatedBit) != 0 373599"];
10012 [label="_bits & IsConditionalPopulatedBit 373600"];
10013 [label="0 373601"];
10014 [label="(_bits & IsConditionalPopulatedBit) != 0 373602"];
10015 [label="if (_packedFlags.IsConditionalPopulated)\n            {\n                retVal._lazyConditionalAttributeSymbols = ImmutableArray<string>.Empty;\n            } 373603"];
10016 [label="_packedFlags.IsOverriddenOrHiddenMembersPopulated 373604"];
10017 [label="=> (_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 373605"];
10018 [label="_bits & IsOverriddenOrHiddenMembersPopulatedBit 373606"];
10019 [label="0 373607"];
10020 [label="(_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 373608"];
10021 [label="if (_packedFlags.IsOverriddenOrHiddenMembersPopulated)\n            {\n                retVal._lazyOverriddenOrHiddenMembersResult = OverriddenOrHiddenMembersResult.Empty;\n            } 373609"];
10022 [label="_packedFlags.IsMemberNotNullPopulated 373610"];
10023 [label="=> (_bits & IsMemberNotNullPopulatedBit) != 0 373611"];
10024 [label="_bits & IsMemberNotNullPopulatedBit 373612"];
10025 [label="0 373613"];
10026 [label="(_bits & IsMemberNotNullPopulatedBit) != 0 373614"];
10027 [label="if (_packedFlags.IsMemberNotNullPopulated)\n            {\n                retVal._lazyNotNullMembers = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenTrue = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenFalse = ImmutableArray<string>.Empty;\n            } 373615"];
10028 [label="_packedFlags.IsExplicitOverrideIsPopulated 373616"];
10029 [label="=> (_bits & IsExplicitOverrideIsPopulatedBit) != 0 373617"];
10030 [label="_bits & IsExplicitOverrideIsPopulatedBit 373618"];
10031 [label="0 373619"];
10032 [label="(_bits & IsExplicitOverrideIsPopulatedBit) != 0 373620"];
10033 [label="if (_packedFlags.IsExplicitOverrideIsPopulated)\n            {\n                retVal._lazyExplicitClassOverride = null;\n            } 373621"];
10034 [label="return retVal; 373622"];
10035 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 373623"];
10036 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 373624"];
10037 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 373625"];
10038 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 373626"];
10039 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 373627"];
10040 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 373628"];
10041 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated() 373629"];
10042 [label="param SetIsUnmanagedCallersOnlyAttributePopulated(this) 373630"];
10043 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUnmanagedCallersOnlyAttributePopulatedBit); 373631"];
10044 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUnmanagedCallersOnlyAttributePopulatedBit); 373632"];
10045 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated(); 373633"];
10046 [label="return result; 373634"];
10047 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 373635"];
10048 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 373636"];
10049 [label="return InitializeUseSiteDiagnostic(result); 373637"];
10050 [label="InitializeUseSiteDiagnostic(result) 373638"];
10051 [label="param InitializeUseSiteDiagnostic(DiagnosticInfo diagnostic) 373639"];
10052 [label="param InitializeUseSiteDiagnostic(this) 373640"];
10053 [label="_packedFlags.IsUseSiteDiagnosticPopulated 373641"];
10054 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 373642"];
10055 [label="_bits & IsUseSiteDiagnosticPopulatedBit 373643"];
10056 [label="if (_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                return _uncommonFields?._lazyUseSiteDiagnostic;\n            } 373644"];
10057 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 373645"];
10058 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 373646"];
10059 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated() 373647"];
10060 [label="param SetIsUseSiteDiagnosticPopulated(this) 373648"];
10061 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUseSiteDiagnosticPopulatedBit); 373649"];
10062 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUseSiteDiagnosticPopulatedBit); 373650"];
10063 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated(); 373651"];
10064 [label="return diagnostic; 373652"];
10065 [label="var info = this.GetUseSiteDiagnostic(); 373653"];
10066 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 373654"];
10067 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 373655"];
10068 [label="this.ContainingType 373656"];
10069 [label="=> _containingType 373657"];
10070 [label="_containingType 373658"];
10071 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 373659"];
10072 [label="this.ContainingType.GetUseSiteDiagnostic() 373660"];
10073 [label="param GetUseSiteDiagnostic(this) 373661"];
10074 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 373662"];
10075 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373663"];
10076 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373664"];
10077 [label="s.Kind 373665"];
10078 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373666"];
10079 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373667"];
10080 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 373668"];
10081 [label="Debug.Assert((object)moduleSymbol != null); 373669"];
10082 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 373670"];
10083 [label="s.Kind 373671"];
10084 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373672"];
10085 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373673"];
10086 [label="param TransformType(int targetSymbolCustomModifierCount) 373674"];
10087 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 373675"];
10088 [label="Debug.Assert((object)metadataType != null); 373676"];
10089 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 373677"];
10090 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 373678"];
10091 [label="_elementNames 373679"];
10092 [label="elementNames.IsDefault 373680"];
10093 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 373681"];
10094 [label="_namesIndex 373682"];
10095 [label="_foundUsableErrorType = false; 373683"];
10096 [label="_foundUsableErrorType 373684"];
10097 [label="param DecodeType(this) 373685"];
10098 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373686"];
10099 [label="param DecodeNamedType(this) 373687"];
10100 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 373688"];
10101 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 373689"];
10102 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 373690"];
10103 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 373691"];
10104 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 373692"];
10105 [label="DecodeTypeArguments(typeArgs) 373693"];
10106 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 373694"];
10107 [label="param DecodeTypeArguments(this) 373695"];
10108 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 373696"];
10109 [label="return typeArgs; 373697"];
10110 [label="type.ContainingType 373698"];
10111 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373699"];
10112 [label="return _container as NamedTypeSymbol; 373700"];
10113 [label="NamedTypeSymbol containingType = type.ContainingType; 373701"];
10114 [label="NamedTypeSymbol? decodedContainingType; 373702"];
10115 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 373703"];
10116 [label="decodedContainingType = containingType; 373704"];
10117 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373705"];
10118 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373706"];
10119 [label="var typeArgsChanged = typeArgs != decodedArgs; 373707"];
10120 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 373708"];
10121 [label="decodedType.IsTupleType 373709"];
10122 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 373710"];
10123 [label="_ 373711"];
10124 [label="tupleCardinality: out _ 373712"];
10125 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 373713"];
10126 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 373714"];
10127 [label="param IsTupleTypeOfCardinality(this) 373715"];
10128 [label="IsUnboundGenericType 373716"];
10129 [label="get\n            {\n                return false;\n            } 373717"];
10130 [label="return false; 373718"];
10131 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373719"];
10132 [label="ContainingSymbol 373720"];
10133 [label="get\n            {\n                return _container;\n            } 373721"];
10134 [label="return _container; 373722"];
10135 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373723"];
10136 [label=".Kind 373724"];
10137 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373725"];
10138 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373726"];
10139 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373727"];
10140 [label="ContainingNamespace 373728"];
10141 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373729"];
10142 [label="get\n            {\n                return _container;\n            } 373730"];
10143 [label="return _container; 373731"];
10144 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373732"];
10145 [label="ContainingNamespace.ContainingNamespace 373733"];
10146 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373734"];
10147 [label=".IsGlobalNamespace 373735"];
10148 [label="get\n            {\n                return true;\n            } 373736"];
10149 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373737"];
10150 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373738"];
10151 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373739"];
10152 [label="Name 373740"];
10153 [label="get\n            {\n                return _name;\n            } 373741"];
10154 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373742"];
10155 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373743"];
10156 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373744"];
10157 [label="tupleCardinality = 0; 373745"];
10158 [label="return false; 373746"];
10159 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 373747"];
10160 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 373748"];
10161 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 373749"];
10162 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 373750"];
10163 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 373751"];
10164 [label="typeSymbol.IsNullableType() 373752"];
10165 [label="param IsNullableType(this TypeSymbol type) 373753"];
10166 [label="type.OriginalDefinition 373754"];
10167 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373755"];
10168 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373756"];
10169 [label="type.OriginalDefinition.SpecialType 373757"];
10170 [label="get\n            {\n                return _corTypeId;\n            } 373758"];
10171 [label="var a1 = defaultType is null; 373759"];
10172 [label="!a1 373760"];
10173 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 373761"];
10174 [label="defaultType.IsNullableType() 373762"];
10175 [label="param IsNullableType(this TypeSymbol type) 373763"];
10176 [label="type.OriginalDefinition 373764"];
10177 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373765"];
10178 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373766"];
10179 [label="type.OriginalDefinition.SpecialType 373767"];
10180 [label="get\n            {\n                return _corTypeId;\n            } 373768"];
10181 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 373769"];
10182 [label="Debug.Assert(a1 || a2 != true || a3); 373770"];
10183 [label="Debug.Assert(a1 || a2 != true || a3); 373771"];
10184 [label="Debug.Assert(extensions != null); 373772"];
10185 [label="param TransformType(Symbol accessSymbol) 373773"];
10186 [label="metadataType.HasType 373774"];
10187 [label="=> !(DefaultType is null) 373775"];
10188 [label="DefaultType is null 373776"];
10189 [label="!(DefaultType is null) 373777"];
10190 [label="Debug.Assert(metadataType.HasType); 373778"];
10191 [label="Debug.Assert(accessSymbol.IsDefinition); 373779"];
10192 [label="accessSymbol.ContainingModule 373780"];
10193 [label="get\n            {\n                return ContainingPEModule;\n            } 373781"];
10194 [label="s.Kind 373782"];
10195 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373783"];
10196 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 373784"];
10197 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 373785"];
10198 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373786"];
10199 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373787"];
10200 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 373788"];
10201 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 373789"];
10202 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 373790"];
10203 [label="Debug.Assert(symbol is object); 373791"];
10204 [label="symbol.Kind 373792"];
10205 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373793"];
10206 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 373794"];
10207 [label="isInternal = false; 373795"];
10208 [label="symbol.DeclaredAccessibility 373796"];
10209 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 373797"];
10210 [label="Accessibility access = Accessibility.Private; 373798"];
10211 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 373799"];
10212 [label="symbol.ContainingType 373800"];
10213 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373801"];
10214 [label="return _container as NamedTypeSymbol; 373802"];
10215 [label="symbol = symbol.ContainingType; 373803"];
10216 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 373804"];
10217 [label="return true; 373805"];
10218 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373806"];
10219 [label="param TryGetByte(out byte? value) 373807"];
10220 [label="return true; 373808"];
10221 [label="=> defaultType 373809"];
10222 [label="Debug.Assert((object)depends != null); 373810"];
10223 [label="Debug.Assert((object)depends != null); 373811"];
10224 [label="Debug.Assert((object)on != null); 373812"];
10225 [label="Debug.Assert(on.IsDefinition); 373813"];
10226 [label="depends.DeclaringCompilation 373814"];
10227 [label="get { return null; } 373815"];
10228 [label="return null; 373816"];
10229 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 373817"];
10230 [label="if ((object)type == null)\n            {\n                return;\n            } 373818"];
10231 [label="if ((object)type == null)\n            {\n                return;\n            } 373819"];
10232 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373820"];
10233 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373821"];
10234 [label="Debug.Assert((object)moduleSymbol != null); 373822"];
10235 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 373823"];
10236 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373824"];
10237 [label="param TransformType(int targetSymbolCustomModifierCount) 373825"];
10238 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 373826"];
10239 [label="Debug.Assert((object)metadataType != null); 373827"];
10240 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 373828"];
10241 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 373829"];
10242 [label="_elementNames 373830"];
10243 [label="elementNames.IsDefault 373831"];
10244 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 373832"];
10245 [label="_namesIndex 373833"];
10246 [label="_foundUsableErrorType = false; 373834"];
10247 [label="_foundUsableErrorType 373835"];
10248 [label="param DecodeType(this) 373836"];
10249 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373837"];
10250 [label="param DecodeNamedType(this) 373838"];
10251 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 373839"];
10252 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 373840"];
10253 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 373841"];
10254 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 373842"];
10255 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 373843"];
10256 [label="DecodeTypeArguments(typeArgs) 373844"];
10257 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 373845"];
10258 [label="param DecodeTypeArguments(this) 373846"];
10259 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 373847"];
10260 [label="return typeArgs; 373848"];
10261 [label="type.ContainingType 373849"];
10262 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373850"];
10263 [label="return _container as NamedTypeSymbol; 373851"];
10264 [label="NamedTypeSymbol containingType = type.ContainingType; 373852"];
10265 [label="NamedTypeSymbol? decodedContainingType; 373853"];
10266 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 373854"];
10267 [label="decodedContainingType = containingType; 373855"];
10268 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373856"];
10269 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 373857"];
10270 [label="var typeArgsChanged = typeArgs != decodedArgs; 373858"];
10271 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 373859"];
10272 [label="decodedType.IsTupleType 373860"];
10273 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 373861"];
10274 [label="_ 373862"];
10275 [label="tupleCardinality: out _ 373863"];
10276 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 373864"];
10277 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 373865"];
10278 [label="param IsTupleTypeOfCardinality(this) 373866"];
10279 [label="IsUnboundGenericType 373867"];
10280 [label="get\n            {\n                return false;\n            } 373868"];
10281 [label="return false; 373869"];
10282 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373870"];
10283 [label="ContainingSymbol 373871"];
10284 [label="get\n            {\n                return _container;\n            } 373872"];
10285 [label="return _container; 373873"];
10286 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373874"];
10287 [label=".Kind 373875"];
10288 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373876"];
10289 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373877"];
10290 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373878"];
10291 [label="ContainingNamespace 373879"];
10292 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373880"];
10293 [label="get\n            {\n                return _container;\n            } 373881"];
10294 [label="return _container; 373882"];
10295 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373883"];
10296 [label="ContainingNamespace.ContainingNamespace 373884"];
10297 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 373885"];
10298 [label=".IsGlobalNamespace 373886"];
10299 [label="get\n            {\n                return true;\n            } 373887"];
10300 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373888"];
10301 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373889"];
10302 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373890"];
10303 [label="Name 373891"];
10304 [label="get\n            {\n                return _name;\n            } 373892"];
10305 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373893"];
10306 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373894"];
10307 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 373895"];
10308 [label="tupleCardinality = 0; 373896"];
10309 [label="return false; 373897"];
10310 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 373898"];
10311 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 373899"];
10312 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 373900"];
10313 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 373901"];
10314 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 373902"];
10315 [label="typeSymbol.IsNullableType() 373903"];
10316 [label="param IsNullableType(this TypeSymbol type) 373904"];
10317 [label="type.OriginalDefinition 373905"];
10318 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373906"];
10319 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373907"];
10320 [label="type.OriginalDefinition.SpecialType 373908"];
10321 [label="get\n            {\n                return _corTypeId;\n            } 373909"];
10322 [label="var a1 = defaultType is null; 373910"];
10323 [label="!a1 373911"];
10324 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 373912"];
10325 [label="defaultType.IsNullableType() 373913"];
10326 [label="param IsNullableType(this TypeSymbol type) 373914"];
10327 [label="type.OriginalDefinition 373915"];
10328 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 373916"];
10329 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 373917"];
10330 [label="type.OriginalDefinition.SpecialType 373918"];
10331 [label="get\n            {\n                return _corTypeId;\n            } 373919"];
10332 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 373920"];
10333 [label="Debug.Assert(a1 || a2 != true || a3); 373921"];
10334 [label="Debug.Assert(a1 || a2 != true || a3); 373922"];
10335 [label="Debug.Assert(extensions != null); 373923"];
10336 [label="param TransformType(Symbol accessSymbol) 373924"];
10337 [label="metadataType.HasType 373925"];
10338 [label="=> !(DefaultType is null) 373926"];
10339 [label="DefaultType is null 373927"];
10340 [label="!(DefaultType is null) 373928"];
10341 [label="Debug.Assert(metadataType.HasType); 373929"];
10342 [label="Debug.Assert(accessSymbol.IsDefinition); 373930"];
10343 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 373931"];
10344 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 373932"];
10345 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373933"];
10346 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373934"];
10347 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 373935"];
10348 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 373936"];
10349 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 373937"];
10350 [label="Debug.Assert(symbol is object); 373938"];
10351 [label="symbol.Kind 373939"];
10352 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373940"];
10353 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 373941"];
10354 [label="isInternal = false; 373942"];
10355 [label="symbol.DeclaredAccessibility 373943"];
10356 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 373944"];
10357 [label="Accessibility access = Accessibility.Private; 373945"];
10358 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 373946"];
10359 [label="symbol.ContainingType 373947"];
10360 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 373948"];
10361 [label="return _container as NamedTypeSymbol; 373949"];
10362 [label="symbol = symbol.ContainingType; 373950"];
10363 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 373951"];
10364 [label="return true; 373952"];
10365 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 373953"];
10366 [label="param TryGetByte(out byte? value) 373954"];
10367 [label="value = null; 373955"];
10368 [label="param GetLocalNullableContextValue(this) 373956"];
10369 [label="get\n            {\n                return _moduleSymbol;\n            } 373957"];
10370 [label="return _moduleSymbol; 373958"];
10371 [label="param GetLocalNullableContextValue(this) 373959"];
10372 [label="get\n            {\n                return _assemblySymbol;\n            } 373960"];
10373 [label="return _assemblySymbol; 373961"];
10374 [label="param GetLocalNullableContextValue(this) 373962"];
10375 [label="get\n            {\n                return null;\n            } 373963"];
10376 [label="=> defaultType 373964"];
10377 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 373965"];
10378 [label="if ((object)type == null)\n            {\n                return;\n            } 373966"];
10379 [label="if ((object)type == null)\n            {\n                return;\n            } 373967"];
10380 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 373968"];
10381 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 373969"];
10382 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 373970"];
10383 [label="if ((object)type == null)\n            {\n                return;\n            } 373971"];
10384 [label="return; 373972"];
10385 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373973"];
10386 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373974"];
10387 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373975"];
10388 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373976"];
10389 [label="return result; 373977"];
10390 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 373978"];
10391 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373979"];
10392 [label="@base.IsErrorType() 373980"];
10393 [label="param IsErrorType(this TypeSymbol type) 373981"];
10394 [label="RoslynDebug.Assert((object)type != null); 373982"];
10395 [label="RoslynDebug.Assert((object)type != null); 373983"];
10396 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 373984"];
10397 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 373985"];
10398 [label="Debug.Assert((object)depends != null); 373986"];
10399 [label="Debug.Assert((object)on != null); 373987"];
10400 [label="Debug.Assert(on.IsDefinition); 373988"];
10401 [label="depends.DeclaringCompilation 373989"];
10402 [label="get { return null; } 373990"];
10403 [label="return null; 373991"];
10404 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 373992"];
10405 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 373993"];
10406 [label="return result; 373994"];
10407 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 373995"];
10408 [label="param MergeUseSiteDiagnostics(this) 373996"];
10409 [label="this.ContainingModule 373997"];
10410 [label="Symbol s = _container; 373998"];
10411 [label="s.Kind 373999"];
10412 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374000"];
10413 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374001"];
10414 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 374002"];
10415 [label="this.ContainingModule.HasUnifiedReferences 374003"];
10416 [label="get { return GetUnifiedAssemblies().Length > 0; } 374004"];
10417 [label="GetUnifiedAssemblies() 374005"];
10418 [label="param GetUnifiedAssemblies(this) 374006"];
10419 [label="AssertReferencesInitialized() 374007"];
10420 [label="param AssertReferencesInitialized(this) 374008"];
10421 [label="Debug.Assert(_moduleReferences != null); 374009"];
10422 [label="Debug.Assert(_moduleReferences != null); 374010"];
10423 [label="AssertReferencesInitialized(); 374011"];
10424 [label="return GetUnifiedAssemblies().Length > 0; 374012"];
10425 [label="return GetUnifiedAssemblies().Length > 0; 374013"];
10426 [label="Symbol s = _container; 374014"];
10427 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374015"];
10428 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 374016"];
10429 [label="SpecialType 374017"];
10430 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 374018"];
10431 [label="TypeSymbol @base = GetDeclaredBaseType(null); 374019"];
10432 [label="GetDeclaredBaseType(null) 374020"];
10433 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 374021"];
10434 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 374022"];
10435 [label="TypeSymbol @base = GetDeclaredBaseType(null); 374023"];
10436 [label=".SpecialType 374024"];
10437 [label="get\n            {\n                return _corTypeId;\n            } 374025"];
10438 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 374026"];
10439 [label="@base.ContainingAssembly 374027"];
10440 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 374028"];
10441 [label="this.ContainingSymbol 374029"];
10442 [label="get\n            {\n                return _container;\n            } 374030"];
10443 [label="return _container; 374031"];
10444 [label="var container = this.ContainingSymbol; 374032"];
10445 [label="return (object)container != null ? container.ContainingAssembly : null; 374033"];
10446 [label="return (object)container != null ? container.ContainingAssembly : null; 374034"];
10447 [label="(object)container != null 374035"];
10448 [label="container.ContainingAssembly 374036"];
10449 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 374037"];
10450 [label="ContainingPEModule 374038"];
10451 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 374039"];
10452 [label="return ContainingPEModule.ContainingAssembly; 374040"];
10453 [label="ContainingPEModule.ContainingAssembly 374041"];
10454 [label="get\n            {\n                return _assemblySymbol;\n            } 374042"];
10455 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 374043"];
10456 [label=".IsMissing 374044"];
10457 [label="get\n            {\n                return false;\n            } 374045"];
10458 [label="return false; 374046"];
10459 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 374047"];
10460 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 374048"];
10461 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 374049"];
10462 [label="return _lazyUseSiteDiagnostic; 374050"];
10463 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 374051"];
10464 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 374052"];
10465 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 374053"];
10466 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 374054"];
10467 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 374055"];
10468 [label="return memberSymbol; 374056"];
10469 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 374057"];
10470 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 374058"];
10471 [label="return memberSymbol; 374059"];
10472 [label="TypeSymbol runtimeCompatibilityAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute); 374060"];
10473 [label="compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute) 374061"];
10474 [label="param GetWellKnownType(WellKnownType type) 374062"];
10475 [label="param GetWellKnownType(this) 374063"];
10476 [label="Debug.Assert(type.IsValid()); 374064"];
10477 [label="this.Options 374065"];
10478 [label="get\n            {\n                return _options;\n            } 374066"];
10479 [label="return _options; 374067"];
10480 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 374068"];
10481 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 374069"];
10482 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 374070"];
10483 [label="param Includes(this BinderFlags self) 374071"];
10484 [label="param Includes(BinderFlags other) 374072"];
10485 [label="return (self & other) == other; 374073"];
10486 [label="int index = (int)type - (int)WellKnownType.First; 374074"];
10487 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 374075"];
10488 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 374076"];
10489 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 374077"];
10490 [label="NamedTypeSymbol? result; 374078"];
10491 [label="(AssemblySymbol, AssemblySymbol) conflicts = default; 374079"];
10492 [label="GetBoundReferenceManager() 374080"];
10493 [label="GetBoundReferenceManager(); 374081"];
10494 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 374082"];
10495 [label="param GetTypeByMetadataName(bool includeReferences) 374083"];
10496 [label="param GetTypeByMetadataName(bool isWellKnownType) 374084"];
10497 [label="param GetTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 374085"];
10498 [label="param GetTypeByMetadataName(DiagnosticBag warnings = null) 374086"];
10499 [label="param GetTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 374087"];
10500 [label="NamedTypeSymbol type; 374088"];
10501 [label="MetadataTypeName mdName; 374089"];
10502 [label="mdName 374090"];
10503 [label="param GetTopLevelTypeByMetadataName(bool includeReferences) 374091"];
10504 [label="param GetTopLevelTypeByMetadataName(bool isWellKnownType) 374092"];
10505 [label="param GetTopLevelTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 374093"];
10506 [label="param GetTopLevelTypeByMetadataName(DiagnosticBag warnings = null) 374094"];
10507 [label="param GetTopLevelTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 374095"];
10508 [label="conflicts = default; 374096"];
10509 [label="NamedTypeSymbol result; 374097"];
10510 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 374098"];
10511 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 374099"];
10512 [label="NamedTypeSymbol result = null; 374100"];
10513 [label="NamedTypeSymbol result; 374101"];
10514 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 374102"];
10515 [label="if ((object)scope == null)\n                {\n                    break;\n                } 374103"];
10516 [label="param TopLevel(ModuleSymbol module) 374104"];
10517 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 374105"];
10518 [label="module 374106"];
10519 [label="1 374107"];
10520 [label="errorInfo 374108"];
10521 [label="param TopLevel(ModuleSymbol module) 374109"];
10522 [label="param TopLevel(int typeId) 374110"];
10523 [label="param TopLevel(DiagnosticInfo? errorInfo) 374111"];
10524 [label="module 374112"];
10525 [label="errorInfo 374113"];
10526 [label="typeId 374114"];
10527 [label="param TopLevel(ModuleSymbol module) 374115"];
10528 [label="param TopLevel(DiagnosticInfo? errorInfo) 374116"];
10529 [label="param TopLevel(int typeId) 374117"];
10530 [label="param TopLevel(this) 374118"];
10531 [label="module 374119"];
10532 [label="fullName.NamespaceName 374120"];
10533 [label="mangleName 374121"];
10534 [label="false 374122"];
10535 [label="errorInfo 374123"];
10536 [label="null 374124"];
10537 [label="typeId 374125"];
10538 [label="null 374126"];
10539 [label="param TopLevel(ModuleSymbol module) 374127"];
10540 [label="param TopLevel(string @namespace) 374128"];
10541 [label="param TopLevel(string name) 374129"];
10542 [label="param TopLevel(int arity) 374130"];
10543 [label="param TopLevel(bool mangleName) 374131"];
10544 [label="param TopLevel(bool isNativeInt) 374132"];
10545 [label="param TopLevel(DiagnosticInfo? errorInfo) 374133"];
10546 [label="param TopLevel(NamespaceSymbol? containingNamespace) 374134"];
10547 [label="param TopLevel(int typeId) 374135"];
10548 [label="param TopLevel(TupleExtraData? tupleData) 374136"];
10549 [label="param TopLevel(this) 374137"];
10550 [label="name 374138"];
10551 [label="arity 374139"];
10552 [label="mangleName 374140"];
10553 [label="tupleData 374141"];
10554 [label="param MissingMetadataTypeSymbol(string name) 374142"];
10555 [label="param MissingMetadataTypeSymbol(int arity) 374143"];
10556 [label="param MissingMetadataTypeSymbol(bool mangleName) 374144"];
10557 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 374145"];
10558 [label="param MissingMetadataTypeSymbol(this) 374146"];
10559 [label="tupleData 374147"];
10560 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 374148"];
10561 [label="_lazyTupleData 374149"];
10562 [label="name 374150"];
10563 [label="arity 374151"];
10564 [label="mangleName 374152"];
10565 [label="RoslynDebug.Assert(name != null); 374153"];
10566 [label="RoslynDebug.Assert(name != null); 374154"];
10567 [label="this.name 374155"];
10568 [label="this.arity 374156"];
10569 [label="this.mangleName = (mangleName && arity > 0); 374157"];
10570 [label="this.mangleName = (mangleName && arity > 0); 374158"];
10571 [label="this.mangleName = (mangleName && arity > 0); 374159"];
10572 [label="this.mangleName 374160"];
10573 [label="_namespaceName 374161"];
10574 [label="_containingModule 374162"];
10575 [label="_isNativeInt 374163"];
10576 [label="_lazyErrorInfo 374164"];
10577 [label="_lazyContainingNamespace 374165"];
10578 [label="_lazyTypeId 374166"];
10579 [label="RoslynDebug.Assert((object)module != null); 374167"];
10580 [label="RoslynDebug.Assert((object)module != null); 374168"];
10581 [label="RoslynDebug.Assert(@namespace != null); 374169"];
10582 [label="RoslynDebug.Assert(@namespace != null); 374170"];
10583 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 374171"];
10584 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 374172"];
10585 [label="_namespaceName 374173"];
10586 [label="_containingModule 374174"];
10587 [label="_isNativeInt 374175"];
10588 [label="_lazyErrorInfo 374176"];
10589 [label="_lazyContainingNamespace 374177"];
10590 [label="_lazyTypeId 374178"];
10591 [label="Debug.Assert((object)result != null); 374179"];
10592 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 374180"];
10593 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 374181"];
10594 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 374182"];
10595 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 374183"];
10596 [label="System.Diagnostics.Debug.Assert((object)result != null); 374184"];
10597 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 374185"];
10598 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 374186"];
10599 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 374187"];
10600 [label="candidate.Kind 374188"];
10601 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 374189"];
10602 [label="return SymbolKind.ErrorType; 374190"];
10603 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 374191"];
10604 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 374192"];
10605 [label="return null; 374193"];
10606 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 374194"];
10607 [label="IsValidWellKnownType(result) 374195"];
10608 [label="param IsValidWellKnownType(NamedTypeSymbol result) 374196"];
10609 [label="param IsValidWellKnownType(this) 374197"];
10610 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 374198"];
10611 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 374199"];
10612 [label="return false; 374200"];
10613 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 374201"];
10614 [label="result = null; 374202"];
10615 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 374203"];
10616 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 374204"];
10617 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 374205"];
10618 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 374206"];
10619 [label="assembly.IsMissing 374207"];
10620 [label="get\n            {\n                return false;\n            } 374208"];
10621 [label="return false; 374209"];
10622 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 374210"];
10623 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 374211"];
10624 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 374212"];
10625 [label="NamedTypeSymbol result = null; 374213"];
10626 [label="NamedTypeSymbol result; 374214"];
10627 [label="EnsureAllMembersLoaded(); 374215"];
10628 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 374216"];
10629 [label="if ((object)scope == null)\n                {\n                    break;\n                } 374217"];
10630 [label="Debug.Assert(!emittedTypeName.IsNull); 374218"];
10631 [label="scope.Kind 374219"];
10632 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374220"];
10633 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 374221"];
10634 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 374222"];
10635 [label="namespaceOrTypeMembers 374223"];
10636 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 374224"];
10637 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374225"];
10638 [label="param ToDisplayParts(bool minimal) 374226"];
10639 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 374227"];
10640 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 374228"];
10641 [label="Debug.Assert(semanticModelOpt == null); 374229"];
10642 [label="Debug.Assert(positionOpt < 0); 374230"];
10643 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 374231"];
10644 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 374232"];
10645 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 374233"];
10646 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 374234"];
10647 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 374235"];
10648 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 374236"];
10649 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 374237"];
10650 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 374238"];
10651 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 374239"];
10652 [label="=> _underlying.IsGlobalNamespace 374240"];
10653 [label="get\n            {\n                return false;\n            } 374241"];
10654 [label="get\n            {\n                return true;\n            } 374242"];
10655 [label="=> _underlying.IsGlobalNamespace 374243"];
10656 [label="get\n            {\n                return false;\n            } 374244"];
10657 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 374245"];
10658 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 374246"];
10659 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 374247"];
10660 [label="EnsureAllMembersLoaded(); 374248"];
10661 [label="get\n                {\n                    return false;\n                } 374249"];
10662 [label="get\n                {\n                    return 0;\n                } 374250"];
10663 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 374251"];
10664 [label="Debug.Assert((object)result != null); 374252"];
10665 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 374253"];
10666 [label="result.ContainingAssembly 374254"];
10667 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 374255"];
10668 [label="this.ContainingSymbol 374256"];
10669 [label="get\n            {\n                return _container;\n            } 374257"];
10670 [label="return _container; 374258"];
10671 [label="var container = this.ContainingSymbol; 374259"];
10672 [label="return (object)container != null ? container.ContainingAssembly : null; 374260"];
10673 [label="return (object)container != null ? container.ContainingAssembly : null; 374261"];
10674 [label="(object)container != null 374262"];
10675 [label="container.ContainingAssembly 374263"];
10676 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 374264"];
10677 [label="ContainingPEModule 374265"];
10678 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 374266"];
10679 [label="return ContainingPEModule.ContainingAssembly; 374267"];
10680 [label="ContainingPEModule.ContainingAssembly 374268"];
10681 [label="get\n            {\n                return _assemblySymbol;\n            } 374269"];
10682 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 374270"];
10683 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 374271"];
10684 [label="System.Diagnostics.Debug.Assert((object)result != null); 374272"];
10685 [label="NamedTypeSymbol result1 = null; 374273"];
10686 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 374274"];
10687 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 374275"];
10688 [label="TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2) 374276"];
10689 [label="param Equals(TypeSymbol left) 374277"];
10690 [label="param Equals(TypeSymbol right) 374278"];
10691 [label="param Equals(TypeCompareKind comparison) 374279"];
10692 [label="if (left is null)\n            {\n                return right is null;\n            } 374280"];
10693 [label="return left.Equals(right, comparison); 374281"];
10694 [label="return left.Equals(right, comparison); 374282"];
10695 [label="left.Equals(right, comparison) 374283"];
10696 [label="param Equals(TypeSymbol t2) 374284"];
10697 [label="param Equals(TypeCompareKind comparison) 374285"];
10698 [label="param Equals(this) 374286"];
10699 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 374287"];
10700 [label="param Equals(TypeCompareKind comparison) 374288"];
10701 [label="param Equals(this) 374289"];
10702 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 374290"];
10703 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 374291"];
10704 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 374292"];
10705 [label="candidate.Kind 374293"];
10706 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374294"];
10707 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 374295"];
10708 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 374296"];
10709 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 374297"];
10710 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 374298"];
10711 [label="param IsValidWellKnownType(this) 374299"];
10712 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 374300"];
10713 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 374301"];
10714 [label="s.Kind 374302"];
10715 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374303"];
10716 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374304"];
10717 [label="Debug.Assert((object)moduleSymbol != null); 374305"];
10718 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 374306"];
10719 [label="return baseType; 374307"];
10720 [label="result.ContainingType 374308"];
10721 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 374309"];
10722 [label="return _container as NamedTypeSymbol; 374310"];
10723 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 374311"];
10724 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 374312"];
10725 [label="result.DeclaredAccessibility 374313"];
10726 [label="Accessibility access = Accessibility.Private; 374314"];
10727 [label="return result.DeclaredAccessibility == Accessibility.Public || IsSymbolAccessible(result, this); 374315"];
10728 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 374316"];
10729 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 374317"];
10730 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374318"];
10731 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 374319"];
10732 [label="upperLevelType.ContainingType 374320"];
10733 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 374321"];
10734 [label="return _container as NamedTypeSymbol; 374322"];
10735 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 374323"];
10736 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 374324"];
10737 [label="var result = _lazyUncommonProperties; 374325"];
10738 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 374326"];
10739 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 374327"];
10740 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 374328"];
10741 [label="return uncommon.lazyHasEmbeddedAttribute.Value(); 374329"];
10742 [label="return upperLevelType.HasCodeAnalysisEmbeddedAttribute; 374330"];
10743 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 374331"];
10744 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 374332"];
10745 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 374333"];
10746 [label="TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2) 374334"];
10747 [label="param Equals(TypeSymbol left) 374335"];
10748 [label="param Equals(TypeSymbol right) 374336"];
10749 [label="param Equals(TypeCompareKind comparison) 374337"];
10750 [label="if (left is null)\n            {\n                return right is null;\n            } 374338"];
10751 [label="return left.Equals(right, comparison); 374339"];
10752 [label="return left.Equals(right, comparison); 374340"];
10753 [label="left.Equals(right, comparison) 374341"];
10754 [label="param Equals(TypeSymbol t2) 374342"];
10755 [label="param Equals(TypeCompareKind comparison) 374343"];
10756 [label="param Equals(this) 374344"];
10757 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 374345"];
10758 [label="param Equals(TypeCompareKind comparison) 374346"];
10759 [label="param Equals(this) 374347"];
10760 [label="if ((object)t2 == null) return false; 374348"];
10761 [label="return false; 374349"];
10762 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 374350"];
10763 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 374351"];
10764 [label="scope.ContainingModule 374352"];
10765 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 374353"];
10766 [label="_containingNamespaceSymbol.ContainingPEModule 374354"];
10767 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 374355"];
10768 [label="return _containingNamespaceSymbol.ContainingPEModule; 374356"];
10769 [label="param TopLevel(ModuleSymbol module) 374357"];
10770 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 374358"];
10771 [label="module 374359"];
10772 [label="1 374360"];
10773 [label="errorInfo 374361"];
10774 [label="param TopLevel(ModuleSymbol module) 374362"];
10775 [label="param TopLevel(int typeId) 374363"];
10776 [label="param TopLevel(DiagnosticInfo? errorInfo) 374364"];
10777 [label="module 374365"];
10778 [label="errorInfo 374366"];
10779 [label="typeId 374367"];
10780 [label="param TopLevel(ModuleSymbol module) 374368"];
10781 [label="param TopLevel(DiagnosticInfo? errorInfo) 374369"];
10782 [label="param TopLevel(int typeId) 374370"];
10783 [label="param TopLevel(this) 374371"];
10784 [label="module 374372"];
10785 [label="fullName.NamespaceName 374373"];
10786 [label="mangleName 374374"];
10787 [label="false 374375"];
10788 [label="errorInfo 374376"];
10789 [label="null 374377"];
10790 [label="typeId 374378"];
10791 [label="null 374379"];
10792 [label="param TopLevel(ModuleSymbol module) 374380"];
10793 [label="param TopLevel(string @namespace) 374381"];
10794 [label="param TopLevel(string name) 374382"];
10795 [label="param TopLevel(int arity) 374383"];
10796 [label="param TopLevel(bool mangleName) 374384"];
10797 [label="param TopLevel(bool isNativeInt) 374385"];
10798 [label="param TopLevel(DiagnosticInfo? errorInfo) 374386"];
10799 [label="param TopLevel(NamespaceSymbol? containingNamespace) 374387"];
10800 [label="param TopLevel(int typeId) 374388"];
10801 [label="param TopLevel(TupleExtraData? tupleData) 374389"];
10802 [label="param TopLevel(this) 374390"];
10803 [label="name 374391"];
10804 [label="arity 374392"];
10805 [label="mangleName 374393"];
10806 [label="tupleData 374394"];
10807 [label="param MissingMetadataTypeSymbol(string name) 374395"];
10808 [label="param MissingMetadataTypeSymbol(int arity) 374396"];
10809 [label="param MissingMetadataTypeSymbol(bool mangleName) 374397"];
10810 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 374398"];
10811 [label="param MissingMetadataTypeSymbol(this) 374399"];
10812 [label="tupleData 374400"];
10813 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 374401"];
10814 [label="_lazyTupleData 374402"];
10815 [label="name 374403"];
10816 [label="arity 374404"];
10817 [label="mangleName 374405"];
10818 [label="RoslynDebug.Assert(name != null); 374406"];
10819 [label="RoslynDebug.Assert(name != null); 374407"];
10820 [label="this.name 374408"];
10821 [label="this.arity 374409"];
10822 [label="this.mangleName = (mangleName && arity > 0); 374410"];
10823 [label="this.mangleName = (mangleName && arity > 0); 374411"];
10824 [label="this.mangleName = (mangleName && arity > 0); 374412"];
10825 [label="this.mangleName 374413"];
10826 [label="_namespaceName 374414"];
10827 [label="_containingModule 374415"];
10828 [label="_isNativeInt 374416"];
10829 [label="_lazyErrorInfo 374417"];
10830 [label="_lazyContainingNamespace 374418"];
10831 [label="_lazyTypeId 374419"];
10832 [label="RoslynDebug.Assert((object)module != null); 374420"];
10833 [label="RoslynDebug.Assert((object)module != null); 374421"];
10834 [label="RoslynDebug.Assert(@namespace != null); 374422"];
10835 [label="RoslynDebug.Assert(@namespace != null); 374423"];
10836 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 374424"];
10837 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 374425"];
10838 [label="_namespaceName 374426"];
10839 [label="_containingModule 374427"];
10840 [label="_isNativeInt 374428"];
10841 [label="_lazyErrorInfo 374429"];
10842 [label="_lazyContainingNamespace 374430"];
10843 [label="_lazyTypeId 374431"];
10844 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 374432"];
10845 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 374433"];
10846 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 374434"];
10847 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 374435"];
10848 [label="return SymbolKind.ErrorType; 374436"];
10849 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 374437"];
10850 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 374438"];
10851 [label="return null; 374439"];
10852 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 374440"];
10853 [label="return false; 374441"];
10854 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 374442"];
10855 [label="candidate = null; 374443"];
10856 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 374444"];
10857 [label="return ImmutableArray<Symbol>.Empty; 374445"];
10858 [label="param TopLevel(ModuleSymbol module) 374446"];
10859 [label="module 374447"];
10860 [label="param TopLevel(ModuleSymbol module) 374448"];
10861 [label="module 374449"];
10862 [label="param TopLevel(ModuleSymbol module) 374450"];
10863 [label="module 374451"];
10864 [label="param TopLevel(ModuleSymbol module) 374452"];
10865 [label="RoslynDebug.Assert((object)module != null); 374453"];
10866 [label="_containingModule 374454"];
10867 [label="param IsErrorType(this TypeSymbol type) 374455"];
10868 [label="RoslynDebug.Assert((object)type != null); 374456"];
10869 [label="RoslynDebug.Assert((object)type != null); 374457"];
10870 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374458"];
10871 [label="if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                } 374459"];
10872 [label="Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null'); 374460"];
10873 [label="Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null'); 374461"];
10874 [label="if (!(runtimeCompatibilityAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if RuntimeCompatibilityAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton);\n\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton);\n                } 374462"];
10875 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 374463"];
10876 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 374464"];
10877 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 374465"];
10878 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 374466"];
10879 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton) 374467"];
10880 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 374468"];
10881 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 374469"];
10882 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 374470"];
10883 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 374471"];
10884 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 374472"];
10885 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 374473"];
10886 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 374474"];
10887 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 374475"];
10888 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 374476"];
10889 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 374477"];
10890 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 374478"];
10891 [label="param GetWellKnownTypeMember(Location location = null) 374479"];
10892 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 374480"];
10893 [label="param GetWellKnownTypeMember(bool isOptional = false) 374481"];
10894 [label="Debug.Assert((syntax != null) ^ (location != null)); 374482"];
10895 [label="Debug.Assert((syntax != null) ^ (location != null)); 374483"];
10896 [label="Debug.Assert((syntax != null) ^ (location != null)); 374484"];
10897 [label="Debug.Assert((syntax != null) ^ (location != null)); 374485"];
10898 [label="DiagnosticInfo useSiteDiagnostic; 374486"];
10899 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 374487"];
10900 [label="param GetWellKnownTypeMember(bool isOptional = false) 374488"];
10901 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 374489"];
10902 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 374490"];
10903 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 374491"];
10904 [label="Debug.Assert(type.IsValid()); 374492"];
10905 [label="this.Options 374493"];
10906 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 374494"];
10907 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 374495"];
10908 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 374496"];
10909 [label="param Includes(this BinderFlags self) 374497"];
10910 [label="param Includes(BinderFlags other) 374498"];
10911 [label="return (self & other) == other; 374499"];
10912 [label="Symbol? result = null; 374500"];
10913 [label="param IsErrorType(this TypeSymbol type) 374501"];
10914 [label="RoslynDebug.Assert((object)type != null); 374502"];
10915 [label="RoslynDebug.Assert((object)type != null); 374503"];
10916 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374504"];
10917 [label="GetBoundReferenceManager(); 374505"];
10918 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 374506"];
10919 [label="ArrayBuilder<Symbol> members = null; 374507"];
10920 [label="s.Kind 374508"];
10921 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374509"];
10922 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374510"];
10923 [label="ImmutableArray<TypeDefinitionHandle> nestedTypeDefs; 374511"];
10924 [label="nestedTypeDefs 374512"];
10925 [label="foreach (var typeRid in nestedTypeDefs)\n            {\n                if (module.ShouldImportNestedType(typeRid))\n                {\n                    yield return PENamedTypeSymbol.Create(moduleSymbol, this, typeRid);\n                }\n            } 374513"];
10926 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 374514"];
10927 [label="this.ContainingPEModule 374515"];
10928 [label="s.Kind 374516"];
10929 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374517"];
10930 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374518"];
10931 [label="var moduleSymbol = this.ContainingPEModule; 374519"];
10932 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 374520"];
10933 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 374521"];
10934 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 374522"];
10935 [label="param OnNewTypeDeclarationsLoaded(this) 374523"];
10936 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 374524"];
10937 [label="types.Free(); 374525"];
10938 [label="EnsureNestedTypesAreLoaded(); 374526"];
10939 [label="Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder()); 374527"];
10940 [label="Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder()); 374528"];
10941 [label="Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder()); 374529"];
10942 [label="Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder()); 374530"];
10943 [label="ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance(); 374531"];
10944 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 374532"];
10945 [label="param CreateFields(ArrayBuilder<PEFieldSymbol> fieldMembers) 374533"];
10946 [label="var privateFieldNameToSymbols = new MultiDictionary<string, PEFieldSymbol>(); 374534"];
10947 [label="var isOrdinaryStruct = false; 374535"];
10948 [label="var isOrdinaryEmbeddableStruct = false; 374536"];
10949 [label="this.TypeKind 374537"];
10950 [label="if (this.TypeKind == TypeKind.Struct)\n            {\n                if (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None)\n                {\n                    isOrdinaryStruct = true;\n                    isOrdinaryEmbeddableStruct = this.ContainingAssembly.IsLinked;\n                }\n                else\n                {\n                    isOrdinaryStruct = (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Nullable_T);\n                }\n            } 374538"];
10951 [label="return privateFieldNameToSymbols; 374539"];
10952 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 374540"];
10953 [label="_containingType 374541"];
10954 [label="_flags 374542"];
10955 [label="_implFlags 374543"];
10956 [label="Debug.Assert((object)moduleSymbol != null); 374544"];
10957 [label="Debug.Assert((object)containingType != null); 374545"];
10958 [label="Debug.Assert(!methodDef.IsNil); 374546"];
10959 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 374547"];
10960 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 374548"];
10961 [label="map.Add(methodHandle, method); 374549"];
10962 [label="map.Add(methodHandle, method); 374550"];
10963 [label="Debug.Assert(!methodDef.IsNil); 374551"];
10964 [label="this.TypeKind 374552"];
10965 [label="TypeKind result = _lazyKind; 374553"];
10966 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    } 374554"];
10967 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374555"];
10968 [label="param GetAccessorMethod(PEModule module) 374556"];
10969 [label="param GetAccessorMethod(this) 374557"];
10970 [label="Debug.Assert(found || !module.ShouldImportMethod(methodDef, this.ContainingPEModule.ImportOptions)); 374558"];
10971 [label="Debug.Assert((object)moduleSymbol != null); 374559"];
10972 [label="Debug.Assert((object)containingType != null); 374560"];
10973 [label="Debug.Assert(!handle.IsNil); 374561"];
10974 [label="Debug.Assert((object)moduleSymbol != null); 374562"];
10975 [label="param GetSpecialType(this) 374563"];
10976 [label="this.Modules 374564"];
10977 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 374565"];
10978 [label="module.GetReferencedAssemblies() 374566"];
10979 [label="param GetReferencedAssemblies(this) 374567"];
10980 [label="AssertReferencesInitialized() 374568"];
10981 [label="param AssertReferencesInitialized(this) 374569"];
10982 [label="Debug.Assert(_moduleReferences != null); 374570"];
10983 [label="Debug.Assert(_moduleReferences != null); 374571"];
10984 [label="AssertReferencesInitialized(); 374572"];
10985 [label="return _moduleReferences.Identities; 374573"];
10986 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 374574"];
10987 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 374575"];
10988 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 374576"];
10989 [label="Debug.Assert(propertyParams.Length > 0); 374577"];
10990 [label="_containingType 374578"];
10991 [label="_refKind 374579"];
10992 [label="_getMethod 374580"];
10993 [label="_setMethod 374581"];
10994 [label="BadImageFormatException mrEx = null; 374582"];
10995 [label="BadImageFormatException setEx = null; 374583"];
10996 [label="setMethod.Handle 374584"];
10997 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 374585"];
10998 [label="param GetSpecialType(this) 374586"];
10999 [label="this.Modules 374587"];
11000 [label="get\n            {\n                return _modules;\n            } 374588"];
11001 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 374589"];
11002 [label="module.GetReferencedAssemblies() 374590"];
11003 [label="param GetReferencedAssemblies(this) 374591"];
11004 [label="AssertReferencesInitialized() 374592"];
11005 [label="param AssertReferencesInitialized(this) 374593"];
11006 [label="Debug.Assert(_moduleReferences != null); 374594"];
11007 [label="Debug.Assert(_moduleReferences != null); 374595"];
11008 [label="AssertReferencesInitialized(); 374596"];
11009 [label="return _moduleReferences.Identities; 374597"];
11010 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 374598"];
11011 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 374599"];
11012 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 374600"];
11013 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 374601"];
11014 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 374602"];
11015 [label="bool isBad; 374603"];
11016 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 374604"];
11017 [label="GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad) 374605"];
11018 [label="param GetParameters(PEModuleSymbol moduleSymbol) 374606"];
11019 [label="param GetParameters(PEPropertySymbol property) 374607"];
11020 [label="param GetParameters(PEMethodSymbol accessor) 374608"];
11021 [label="param GetParameters(ParamInfo<TypeSymbol>[] accessorParams) 374609"];
11022 [label="param GetParameters(out bool anyParameterIsBad) 374610"];
11023 [label="anyParameterIsBad = false; 374611"];
11024 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 374612"];
11025 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 374613"];
11026 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 374614"];
11027 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 374615"];
11028 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 374616"];
11029 [label="param TransformType(int targetSymbolCustomModifierCount) 374617"];
11030 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 374618"];
11031 [label="Debug.Assert((object)metadataType != null); 374619"];
11032 [label="Debug.Assert((object)metadataType != null); 374620"];
11033 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 374621"];
11034 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 374622"];
11035 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 374623"];
11036 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 374624"];
11037 [label="type.SpecialType 374625"];
11038 [label="get\n            {\n                return _corTypeId;\n            } 374626"];
11039 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 374627"];
11040 [label="result = null; 374628"];
11041 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 374629"];
11042 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 374630"];
11043 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 374631"];
11044 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 374632"];
11045 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 374633"];
11046 [label="typeSymbol.IsNullableType() 374634"];
11047 [label="param IsNullableType(this TypeSymbol type) 374635"];
11048 [label="type.OriginalDefinition 374636"];
11049 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 374637"];
11050 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 374638"];
11051 [label="type.OriginalDefinition.SpecialType 374639"];
11052 [label="get\n            {\n                return _corTypeId;\n            } 374640"];
11053 [label="var a1 = defaultType is null; 374641"];
11054 [label="!a1 374642"];
11055 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 374643"];
11056 [label="defaultType.IsNullableType() 374644"];
11057 [label="param IsNullableType(this TypeSymbol type) 374645"];
11058 [label="type.OriginalDefinition 374646"];
11059 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 374647"];
11060 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 374648"];
11061 [label="type.OriginalDefinition.SpecialType 374649"];
11062 [label="get\n            {\n                return _corTypeId;\n            } 374650"];
11063 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 374651"];
11064 [label="Debug.Assert(a1 || a2 != true || a3); 374652"];
11065 [label="Debug.Assert(a1 || a2 != true || a3); 374653"];
11066 [label="Debug.Assert(extensions != null); 374654"];
11067 [label="Debug.Assert(extensions != null); 374655"];
11068 [label="metadataType.HasType 374656"];
11069 [label="=> !(DefaultType is null) 374657"];
11070 [label="DefaultType is null 374658"];
11071 [label="!(DefaultType is null) 374659"];
11072 [label="Debug.Assert(metadataType.HasType); 374660"];
11073 [label="Debug.Assert(accessSymbol.IsDefinition); 374661"];
11074 [label="s.Kind 374662"];
11075 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374663"];
11076 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374664"];
11077 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 374665"];
11078 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 374666"];
11079 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 374667"];
11080 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 374668"];
11081 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 374669"];
11082 [label="Debug.Assert(symbol is object); 374670"];
11083 [label="symbol.Kind 374671"];
11084 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374672"];
11085 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 374673"];
11086 [label="isInternal = false; 374674"];
11087 [label="symbol.DeclaredAccessibility 374675"];
11088 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 374676"];
11089 [label="Accessibility access = Accessibility.Private; 374677"];
11090 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 374678"];
11091 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 374679"];
11092 [label="symbol.ContainingType 374680"];
11093 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 374681"];
11094 [label="return _container as NamedTypeSymbol; 374682"];
11095 [label="symbol = symbol.ContainingType; 374683"];
11096 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 374684"];
11097 [label="return true; 374685"];
11098 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 374686"];
11099 [label="param TryGetByte(out byte? value) 374687"];
11100 [label="value = null; 374688"];
11101 [label="s.Kind 374689"];
11102 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374690"];
11103 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 374691"];
11104 [label="param GetLocalNullableContextValue(this) 374692"];
11105 [label="get\n            {\n                return _moduleSymbol;\n            } 374693"];
11106 [label="return _moduleSymbol; 374694"];
11107 [label="param GetLocalNullableContextValue(this) 374695"];
11108 [label="get\n            {\n                return _assemblySymbol;\n            } 374696"];
11109 [label="return _assemblySymbol; 374697"];
11110 [label="param GetLocalNullableContextValue(this) 374698"];
11111 [label="get\n            {\n                return null;\n            } 374699"];
11112 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 374700"];
11113 [label="=> defaultType 374701"];
11114 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 374702"];
11115 [label="_elementNames 374703"];
11116 [label="elementNames.IsDefault 374704"];
11117 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 374705"];
11118 [label="_namesIndex 374706"];
11119 [label="_foundUsableErrorType = false; 374707"];
11120 [label="_foundUsableErrorType 374708"];
11121 [label="param DecodeType(this) 374709"];
11122 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 374710"];
11123 [label="param DecodeNamedType(this) 374711"];
11124 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 374712"];
11125 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 374713"];
11126 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 374714"];
11127 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 374715"];
11128 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 374716"];
11129 [label="DecodeTypeArguments(typeArgs) 374717"];
11130 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 374718"];
11131 [label="param DecodeTypeArguments(this) 374719"];
11132 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 374720"];
11133 [label="return typeArgs; 374721"];
11134 [label="type.ContainingType 374722"];
11135 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 374723"];
11136 [label="return _container as NamedTypeSymbol; 374724"];
11137 [label="NamedTypeSymbol containingType = type.ContainingType; 374725"];
11138 [label="NamedTypeSymbol? decodedContainingType; 374726"];
11139 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 374727"];
11140 [label="decodedContainingType = containingType; 374728"];
11141 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 374729"];
11142 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 374730"];
11143 [label="var typeArgsChanged = typeArgs != decodedArgs; 374731"];
11144 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 374732"];
11145 [label="decodedType.IsTupleType 374733"];
11146 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 374734"];
11147 [label="_ 374735"];
11148 [label="tupleCardinality: out _ 374736"];
11149 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 374737"];
11150 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 374738"];
11151 [label="param IsTupleTypeOfCardinality(this) 374739"];
11152 [label="IsUnboundGenericType 374740"];
11153 [label="get\n            {\n                return false;\n            } 374741"];
11154 [label="return false; 374742"];
11155 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374743"];
11156 [label="ContainingSymbol 374744"];
11157 [label="get\n            {\n                return _container;\n            } 374745"];
11158 [label="return _container; 374746"];
11159 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374747"];
11160 [label=".Kind 374748"];
11161 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 374749"];
11162 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374750"];
11163 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374751"];
11164 [label="ContainingNamespace 374752"];
11165 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 374753"];
11166 [label="get\n            {\n                return _container;\n            } 374754"];
11167 [label="return _container; 374755"];
11168 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374756"];
11169 [label="ContainingNamespace.ContainingNamespace 374757"];
11170 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 374758"];
11171 [label=".IsGlobalNamespace 374759"];
11172 [label="get\n            {\n                return true;\n            } 374760"];
11173 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374761"];
11174 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374762"];
11175 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374763"];
11176 [label="Name 374764"];
11177 [label="get\n            {\n                return _name;\n            } 374765"];
11178 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374766"];
11179 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374767"];
11180 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 374768"];
11181 [label="tupleCardinality = 0; 374769"];
11182 [label="return false; 374770"];
11183 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 374771"];
11184 [label="param DoSignaturesMatch(PEModule module) 374772"];
11185 [label="param DoSignaturesMatch(PEMethodSymbol getMethod) 374773"];
11186 [label="param DoSignaturesMatch(PEMethodSymbol setMethod) 374774"];
11187 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] setMethodParams) 374775"];
11188 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 374776"];
11189 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 374777"];
11190 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 374778"];
11191 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 374779"];
11192 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 374780"];
11193 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 374781"];
11194 [label="bool hasGetMethod = getMethodParams != null; 374782"];
11195 [label="bool hasSetMethod = setMethodParams != null; 374783"];
11196 [label="bool hasSetMethod = setMethodParams != null; 374784"];
11197 [label="param Equals(TypeCompareKind compareKind) 374785"];
11198 [label="param Equals(TypeCompareKind compareKind) 374786"];
11199 [label="if (t2 is null)\n            {\n                return false;\n            } 374787"];
11200 [label="param Equals(TypeCompareKind comparison) 374788"];
11201 [label="param Equals(TypeCompareKind comparison) 374789"];
11202 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374790"];
11203 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374791"];
11204 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374792"];
11205 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374793"];
11206 [label="param GetPrimitiveTypeCode(PEModuleSymbol moduleSymbol) 374794"];
11207 [label="param GetPrimitiveTypeCode(TypeSymbol type) 374795"];
11208 [label="param GetPrimitiveTypeCode(this) 374796"];
11209 [label="type.PrimitiveTypeCode 374797"];
11210 [label="=> TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 374798"];
11211 [label="TypeKind 374799"];
11212 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 374800"];
11213 [label="TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 374801"];
11214 [label="SpecialType 374802"];
11215 [label="SpecialTypes.GetTypeCode(SpecialType) 374803"];
11216 [label="return type.PrimitiveTypeCode; 374804"];
11217 [label="param Equals(TypeCompareKind compareKind) 374805"];
11218 [label="if (t2 is null)\n            {\n                return false;\n            } 374806"];
11219 [label="param Equals(TypeCompareKind comparison) 374807"];
11220 [label="param Equals(TypeCompareKind comparison) 374808"];
11221 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374809"];
11222 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 374810"];
11223 [label="if (hasGetMethod && hasSetMethod)\n            {\n                var lastPropertyParamIndex = propertyParams.Length - 1;\n                var getHandle = getMethodParams[lastPropertyParamIndex].Handle;\n                var setHandle = setMethodParams[lastPropertyParamIndex].Handle;\n                var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle);\n                var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle);\n                if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                }\n\n                if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                }\n            } 374811"];
11224 [label="var lastPropertyParamIndex = propertyParams.Length - 1; 374812"];
11225 [label="var lastPropertyParamIndex = propertyParams.Length - 1; 374813"];
11226 [label="var getHandle = getMethodParams[lastPropertyParamIndex].Handle; 374814"];
11227 [label="var setHandle = setMethodParams[lastPropertyParamIndex].Handle; 374815"];
11228 [label="var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle); 374816"];
11229 [label="var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle); 374817"];
11230 [label="if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                } 374818"];
11231 [label="getMethod.IsExtern 374819"];
11232 [label="=> HasFlag(MethodAttributes.PinvokeImpl) 374820"];
11233 [label="MethodAttributes.PinvokeImpl 374821"];
11234 [label="HasFlag(MethodAttributes.PinvokeImpl) 374822"];
11235 [label="param HasFlag(MethodAttributes flag) 374823"];
11236 [label="param HasFlag(this) 374824"];
11237 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374825"];
11238 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374826"];
11239 [label="return ((ushort)flag & _flags) != 0; 374827"];
11240 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374828"];
11241 [label="setMethod.IsExtern 374829"];
11242 [label="=> HasFlag(MethodAttributes.PinvokeImpl) 374830"];
11243 [label="MethodAttributes.PinvokeImpl 374831"];
11244 [label="HasFlag(MethodAttributes.PinvokeImpl) 374832"];
11245 [label="param HasFlag(MethodAttributes flag) 374833"];
11246 [label="param HasFlag(this) 374834"];
11247 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374835"];
11248 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374836"];
11249 [label="return ((ushort)flag & _flags) != 0; 374837"];
11250 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374838"];
11251 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374839"];
11252 [label="getMethod.IsSealed 374840"];
11253 [label="=> this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 374841"];
11254 [label="this.IsMetadataFinal 374842"];
11255 [label="=> HasFlag(MethodAttributes.Final) 374843"];
11256 [label="MethodAttributes.Final 374844"];
11257 [label="HasFlag(MethodAttributes.Final) 374845"];
11258 [label="param HasFlag(MethodAttributes flag) 374846"];
11259 [label="param HasFlag(this) 374847"];
11260 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374848"];
11261 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374849"];
11262 [label="return ((ushort)flag & _flags) != 0; 374850"];
11263 [label="this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 374851"];
11264 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374852"];
11265 [label="setMethod.IsSealed 374853"];
11266 [label="=> this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 374854"];
11267 [label="this.IsMetadataFinal 374855"];
11268 [label="=> HasFlag(MethodAttributes.Final) 374856"];
11269 [label="MethodAttributes.Final 374857"];
11270 [label="HasFlag(MethodAttributes.Final) 374858"];
11271 [label="param HasFlag(MethodAttributes flag) 374859"];
11272 [label="param HasFlag(this) 374860"];
11273 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374861"];
11274 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374862"];
11275 [label="return ((ushort)flag & _flags) != 0; 374863"];
11276 [label="this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 374864"];
11277 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374865"];
11278 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374866"];
11279 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374867"];
11280 [label="getMethod.IsOverride 374868"];
11281 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 374869"];
11282 [label="this._containingType.IsInterface 374870"];
11283 [label="get\n            {\n                return _flags.IsInterface();\n            } 374871"];
11284 [label="this.IsMetadataVirtual() 374872"];
11285 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 374873"];
11286 [label="=> HasFlag(MethodAttributes.Virtual) 374874"];
11287 [label="MethodAttributes.Virtual 374875"];
11288 [label="HasFlag(MethodAttributes.Virtual) 374876"];
11289 [label="param HasFlag(MethodAttributes flag) 374877"];
11290 [label="param HasFlag(this) 374878"];
11291 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374879"];
11292 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374880"];
11293 [label="return ((ushort)flag & _flags) != 0; 374881"];
11294 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 374882"];
11295 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 374883"];
11296 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 374884"];
11297 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374885"];
11298 [label="setMethod.IsOverride 374886"];
11299 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 374887"];
11300 [label="this._containingType.IsInterface 374888"];
11301 [label="get\n            {\n                return _flags.IsInterface();\n            } 374889"];
11302 [label="this.IsMetadataVirtual() 374890"];
11303 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 374891"];
11304 [label="=> HasFlag(MethodAttributes.Virtual) 374892"];
11305 [label="MethodAttributes.Virtual 374893"];
11306 [label="HasFlag(MethodAttributes.Virtual) 374894"];
11307 [label="param HasFlag(MethodAttributes flag) 374895"];
11308 [label="param HasFlag(this) 374896"];
11309 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374897"];
11310 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374898"];
11311 [label="return ((ushort)flag & _flags) != 0; 374899"];
11312 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 374900"];
11313 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 374901"];
11314 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 374902"];
11315 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374903"];
11316 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374904"];
11317 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374905"];
11318 [label="getMethod.IsStatic 374906"];
11319 [label="=> HasFlag(MethodAttributes.Static) 374907"];
11320 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374908"];
11321 [label="return ((ushort)flag & _flags) != 0; 374909"];
11322 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374910"];
11323 [label="setMethod.IsStatic 374911"];
11324 [label="=> HasFlag(MethodAttributes.Static) 374912"];
11325 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 374913"];
11326 [label="return ((ushort)flag & _flags) != 0; 374914"];
11327 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374915"];
11328 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374916"];
11329 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 374917"];
11330 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 374918"];
11331 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 374919"];
11332 [label="propertyOrEventSymbol.ContainingType 374920"];
11333 [label="get\n            {\n                return _containingType;\n            } 374921"];
11334 [label="return _containingType; 374922"];
11335 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374923"];
11336 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374924"];
11337 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374925"];
11338 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 374926"];
11339 [label="param Equals(TypeSymbol left) 374927"];
11340 [label="param Equals(TypeSymbol right) 374928"];
11341 [label="param Equals(TypeCompareKind comparison) 374929"];
11342 [label="if (left is null)\n            {\n                return right is null;\n            } 374930"];
11343 [label="return left.Equals(right, comparison); 374931"];
11344 [label="return left.Equals(right, comparison); 374932"];
11345 [label="left.Equals(right, comparison) 374933"];
11346 [label="param Equals(TypeSymbol t2) 374934"];
11347 [label="param Equals(TypeCompareKind comparison) 374935"];
11348 [label="param Equals(this) 374936"];
11349 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 374937"];
11350 [label="param Equals(TypeCompareKind comparison) 374938"];
11351 [label="param Equals(this) 374939"];
11352 [label="_packedFlags.MethodKind 374940"];
11353 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 374941"];
11354 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 374942"];
11355 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 374943"];
11356 [label="return true; 374944"];
11357 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 374945"];
11358 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 374946"];
11359 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 374947"];
11360 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet) 374948"];
11361 [label="param SetAssociatedProperty(PEPropertySymbol propertySymbol) 374949"];
11362 [label="param SetAssociatedProperty(MethodKind methodKind) 374950"];
11363 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 374951"];
11364 [label="propertyOrEventSymbol.ContainingType 374952"];
11365 [label="get\n            {\n                return _containingType;\n            } 374953"];
11366 [label="return _containingType; 374954"];
11367 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374955"];
11368 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374956"];
11369 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 374957"];
11370 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 374958"];
11371 [label="param Equals(TypeSymbol left) 374959"];
11372 [label="param Equals(TypeSymbol right) 374960"];
11373 [label="param Equals(TypeCompareKind comparison) 374961"];
11374 [label="if (left is null)\n            {\n                return right is null;\n            } 374962"];
11375 [label="return left.Equals(right, comparison); 374963"];
11376 [label="return left.Equals(right, comparison); 374964"];
11377 [label="left.Equals(right, comparison) 374965"];
11378 [label="param Equals(TypeSymbol t2) 374966"];
11379 [label="param Equals(TypeCompareKind comparison) 374967"];
11380 [label="param Equals(this) 374968"];
11381 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 374969"];
11382 [label="param Equals(TypeCompareKind comparison) 374970"];
11383 [label="param Equals(this) 374971"];
11384 [label="_packedFlags.MethodKind 374972"];
11385 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 374973"];
11386 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 374974"];
11387 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 374975"];
11388 [label="return true; 374976"];
11389 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 374977"];
11390 [label="if (callMethodsDirectly)\n            {\n                _flags |= Flags.CallMethodsDirectly;\n            } 374978"];
11391 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 374979"];
11392 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 374980"];
11393 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 374981"];
11394 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 374982"];
11395 [label="result.RefKind 374983"];
11396 [label="return _refKind; 374984"];
11397 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 374985"];
11398 [label="result.RefCustomModifiers 374986"];
11399 [label="get { return ImmutableArray<CustomModifier>.Empty; } 374987"];
11400 [label="return ImmutableArray<CustomModifier>.Empty; 374988"];
11401 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 374989"];
11402 [label="result.RefCustomModifiers.HasInAttributeModifier() 374990"];
11403 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 374991"];
11404 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 374992"];
11405 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 374993"];
11406 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 374994"];
11407 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 374995"];
11408 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 374996"];
11409 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 374997"];
11410 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 374998"];
11411 [label="param CreateEvents(MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols) 374999"];
11412 [label="param CreateEvents(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 375000"];
11413 [label="param CreateEvents(ArrayBuilder<Symbol> members) 375001"];
11414 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375002"];
11415 [label="foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    } 375003"];
11416 [label="fieldMembers.Free(); 375004"];
11417 [label="foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                } 375005"];
11418 [label="Symbol previous = null; 375006"];
11419 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 375007"];
11420 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 375008"];
11421 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 375009"];
11422 [label="previous == null 375010"];
11423 [label="param ==(Symbol left) 375011"];
11424 [label="param ==(Symbol right) 375012"];
11425 [label="if (right is null)\n            {\n                return left is null;\n            } 375013"];
11426 [label="return left is null; 375014"];
11427 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 375015"];
11428 [label="previous = s; 375016"];
11429 [label="param ==(Symbol left) 375017"];
11430 [label="return left is null; 375018"];
11431 [label="Symbol current = s; 375019"];
11432 [label="previous.Kind 375020"];
11433 [label="get\n            {\n                return SymbolKind.Method;\n            } 375021"];
11434 [label="return SymbolKind.Method; 375022"];
11435 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375023"];
11436 [label="current.Kind 375024"];
11437 [label="get\n            {\n                return SymbolKind.Method;\n            } 375025"];
11438 [label="return SymbolKind.Method; 375026"];
11439 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375027"];
11440 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375028"];
11441 [label="previous = current; 375029"];
11442 [label="param ==(Symbol left) 375030"];
11443 [label="return left is null; 375031"];
11444 [label="previous.Kind 375032"];
11445 [label="get\n            {\n                return SymbolKind.Method;\n            } 375033"];
11446 [label="return SymbolKind.Method; 375034"];
11447 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375035"];
11448 [label="current.Kind 375036"];
11449 [label="get\n            {\n                return SymbolKind.Method;\n            } 375037"];
11450 [label="return SymbolKind.Method; 375038"];
11451 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375039"];
11452 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375040"];
11453 [label="get\n            {\n                return SymbolKind.Property;\n            } 375041"];
11454 [label="return SymbolKind.Property; 375042"];
11455 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375043"];
11456 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 375044"];
11457 [label="IsTupleType 375045"];
11458 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 375046"];
11459 [label="_ 375047"];
11460 [label="tupleCardinality: out _ 375048"];
11461 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 375049"];
11462 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 375050"];
11463 [label="param IsTupleTypeOfCardinality(this) 375051"];
11464 [label="IsUnboundGenericType 375052"];
11465 [label="get\n            {\n                return false;\n            } 375053"];
11466 [label="return false; 375054"];
11467 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375055"];
11468 [label="ContainingSymbol 375056"];
11469 [label="get\n            {\n                return _container;\n            } 375057"];
11470 [label="return _container; 375058"];
11471 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375059"];
11472 [label=".Kind 375060"];
11473 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375061"];
11474 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375062"];
11475 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375063"];
11476 [label="ContainingNamespace 375064"];
11477 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 375065"];
11478 [label="get\n            {\n                return _container;\n            } 375066"];
11479 [label="return _container; 375067"];
11480 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375068"];
11481 [label="ContainingNamespace.ContainingNamespace 375069"];
11482 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 375070"];
11483 [label=".IsGlobalNamespace 375071"];
11484 [label="get\n            {\n                return false;\n            } 375072"];
11485 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375073"];
11486 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375074"];
11487 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375075"];
11488 [label="tupleCardinality = 0; 375076"];
11489 [label="return false; 375077"];
11490 [label="if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                } 375078"];
11491 [label="if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                } 375079"];
11492 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 375080"];
11493 [label="this.ParameterCount 375081"];
11494 [label="get\n            {\n                return this.Parameters.Length;\n            } 375082"];
11495 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 375083"];
11496 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 375084"];
11497 [label="LoadMembers(); 375085"];
11498 [label="EnsureAllMembersAreLoaded(); 375086"];
11499 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 375087"];
11500 [label="SymbolKind targetSymbolKind; 375088"];
11501 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 375089"];
11502 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 375090"];
11503 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 375091"];
11504 [label="Symbol? result = null; 375092"];
11505 [label="targetMethodKind = MethodKind.Constructor; 375093"];
11506 [label="Debug.Assert(!isStatic); 375094"];
11507 [label="member.Name 375095"];
11508 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 375096"];
11509 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 375097"];
11510 [label="member.Kind 375098"];
11511 [label="get\n            {\n                return SymbolKind.Method;\n            } 375099"];
11512 [label="return SymbolKind.Method; 375100"];
11513 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375101"];
11514 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375102"];
11515 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375103"];
11516 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375104"];
11517 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375105"];
11518 [label="member.DeclaredAccessibility 375106"];
11519 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 375107"];
11520 [label="Flags 375108"];
11521 [label="=> (MethodAttributes)_flags 375109"];
11522 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 375110"];
11523 [label="return Accessibility.Public; 375111"];
11524 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375112"];
11525 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375113"];
11526 [label="s.Kind 375114"];
11527 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375115"];
11528 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 375116"];
11529 [label="Debug.Assert((object)moduleSymbol != null); 375117"];
11530 [label="param GetSpecialType(this) 375118"];
11531 [label="this.Modules 375119"];
11532 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 375120"];
11533 [label="module.GetReferencedAssemblies() 375121"];
11534 [label="param GetReferencedAssemblies(this) 375122"];
11535 [label="AssertReferencesInitialized() 375123"];
11536 [label="param AssertReferencesInitialized(this) 375124"];
11537 [label="Debug.Assert(_moduleReferences != null); 375125"];
11538 [label="Debug.Assert(_moduleReferences != null); 375126"];
11539 [label="AssertReferencesInitialized(); 375127"];
11540 [label="return _moduleReferences.Identities; 375128"];
11541 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 375129"];
11542 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 375130"];
11543 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 375131"];
11544 [label="bool makeBad = (mrEx != null); 375132"];
11545 [label="ImmutableArray<ParameterSymbol> @params; 375133"];
11546 [label="@params 375134"];
11547 [label="bool isBadParameter; 375135"];
11548 [label="@params = ImmutableArray<ParameterSymbol>.Empty; 375136"];
11549 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 375137"];
11550 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 375138"];
11551 [label="param AsDynamicIfNoPia(this TypeSymbol type) 375139"];
11552 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 375140"];
11553 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 375141"];
11554 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 375142"];
11555 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 375143"];
11556 [label="type.SpecialType 375144"];
11557 [label="get\n            {\n                return _corTypeId;\n            } 375145"];
11558 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 375146"];
11559 [label="result = null; 375147"];
11560 [label="paramInfo[0].Type = returnType; 375148"];
11561 [label="paramInfo[0].Type 375149"];
11562 [label="this.IsMetadataVirtual() 375150"];
11563 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375151"];
11564 [label="=> HasFlag(MethodAttributes.Virtual) 375152"];
11565 [label="MethodAttributes.Virtual 375153"];
11566 [label="HasFlag(MethodAttributes.Virtual) 375154"];
11567 [label="param HasFlag(MethodAttributes flag) 375155"];
11568 [label="param HasFlag(this) 375156"];
11569 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375157"];
11570 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375158"];
11571 [label="return ((ushort)flag & _flags) != 0; 375159"];
11572 [label="param Create(bool isContainingSymbolVirtual) 375160"];
11573 [label="param Create(out bool isBad) 375161"];
11574 [label="param Create(bool isContainingSymbolVirtual) 375162"];
11575 [label="param Create(bool isReturn) 375163"];
11576 [label="param Create(out bool isBad) 375164"];
11577 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 375165"];
11578 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 375166"];
11579 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 375167"];
11580 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 375168"];
11581 [label="typeSymbol.IsNullableType() 375169"];
11582 [label="param IsNullableType(this TypeSymbol type) 375170"];
11583 [label="type.OriginalDefinition 375171"];
11584 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 375172"];
11585 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 375173"];
11586 [label="type.OriginalDefinition.SpecialType 375174"];
11587 [label="get\n            {\n                return _corTypeId;\n            } 375175"];
11588 [label="var a1 = defaultType is null; 375176"];
11589 [label="!a1 375177"];
11590 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 375178"];
11591 [label="defaultType.IsNullableType() 375179"];
11592 [label="param IsNullableType(this TypeSymbol type) 375180"];
11593 [label="type.OriginalDefinition 375181"];
11594 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 375182"];
11595 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 375183"];
11596 [label="type.OriginalDefinition.SpecialType 375184"];
11597 [label="get\n            {\n                return _corTypeId;\n            } 375185"];
11598 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 375186"];
11599 [label="Debug.Assert(a1 || a2 != true || a3); 375187"];
11600 [label="Debug.Assert(a1 || a2 != true || a3); 375188"];
11601 [label="Debug.Assert(extensions != null); 375189"];
11602 [label="param PEParameterSymbol(out bool isBad) 375190"];
11603 [label="_containingSymbol 375191"];
11604 [label="_moduleSymbol 375192"];
11605 [label="_ordinal 375193"];
11606 [label="Debug.Assert((object)moduleSymbol != null); 375194"];
11607 [label="Debug.Assert((object)containingSymbol != null); 375195"];
11608 [label="Debug.Assert(ordinal >= 0); 375196"];
11609 [label="typeWithAnnotations.HasType 375197"];
11610 [label="=> !(DefaultType is null) 375198"];
11611 [label="DefaultType is null 375199"];
11612 [label="!(DefaultType is null) 375200"];
11613 [label="Debug.Assert(typeWithAnnotations.HasType); 375201"];
11614 [label="isBad = false; 375202"];
11615 [label="nullableContext.GetNullableContextValue() 375203"];
11616 [label="param TryGetNullableContext(out byte? value) 375204"];
11617 [label="param TryGetByte(out byte? value) 375205"];
11618 [label="value = null; 375206"];
11619 [label="s.Kind 375207"];
11620 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375208"];
11621 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 375209"];
11622 [label="param TryGetByte(out byte? value) 375210"];
11623 [label="return true; 375211"];
11624 [label="byte? value = nullableContext.GetNullableContextValue(); 375212"];
11625 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 375213"];
11626 [label="this.RefKind 375214"];
11627 [label="Debug.Assert(refKind == this.RefKind); 375215"];
11628 [label="this.HasNameInMetadata 375216"];
11629 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 375217"];
11630 [label="_packedFlags.HasNameInMetadata 375218"];
11631 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 375219"];
11632 [label="return (_bits & HasNameInMetadataBit) != 0; 375220"];
11633 [label="return (_bits & HasNameInMetadataBit) != 0; 375221"];
11634 [label="return _packedFlags.HasNameInMetadata; 375222"];
11635 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 375223"];
11636 [label="parameter.RefCustomModifiers 375224"];
11637 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 375225"];
11638 [label="return ImmutableArray<CustomModifier>.Empty; 375226"];
11639 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 375227"];
11640 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 375228"];
11641 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 375229"];
11642 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 375230"];
11643 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 375231"];
11644 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 375232"];
11645 [label="parameter.RefKind 375233"];
11646 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 375234"];
11647 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 375235"];
11648 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 375236"];
11649 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 375237"];
11650 [label="ReturnParam 375238"];
11651 [label="this.Parameters 375239"];
11652 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 375240"];
11653 [label="=> defaultType 375241"];
11654 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375242"];
11655 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 375243"];
11656 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 375244"];
11657 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 375245"];
11658 [label="param BitsAreUnsetOrSame(int bits) 375246"];
11659 [label="param BitsAreUnsetOrSame(int mask) 375247"];
11660 [label="return (bits & mask) == 0 || (bits & mask) == mask; 375248"];
11661 [label="return (bits & mask) == 0 || (bits & mask) == mask; 375249"];
11662 [label="MethodKind methodKind = method.MethodKind; 375250"];
11663 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 375251"];
11664 [label="method.Arity 375252"];
11665 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 375253"];
11666 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375254"];
11667 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375255"];
11668 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375256"];
11669 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375257"];
11670 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375258"];
11671 [label="method.IsVirtual 375259"];
11672 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375260"];
11673 [label="this.IsMetadataVirtual() 375261"];
11674 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375262"];
11675 [label="=> HasFlag(MethodAttributes.Virtual) 375263"];
11676 [label="MethodAttributes.Virtual 375264"];
11677 [label="HasFlag(MethodAttributes.Virtual) 375265"];
11678 [label="param HasFlag(MethodAttributes flag) 375266"];
11679 [label="param HasFlag(this) 375267"];
11680 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375268"];
11681 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375269"];
11682 [label="return ((ushort)flag & _flags) != 0; 375270"];
11683 [label="this.IsMetadataVirtual() && !this.IsDestructor 375271"];
11684 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 375272"];
11685 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 375273"];
11686 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375274"];
11687 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375275"];
11688 [label="method.IsOverride 375276"];
11689 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375277"];
11690 [label="this._containingType.IsInterface 375278"];
11691 [label="get\n            {\n                return _flags.IsInterface();\n            } 375279"];
11692 [label="this.IsMetadataVirtual() 375280"];
11693 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375281"];
11694 [label="=> HasFlag(MethodAttributes.Virtual) 375282"];
11695 [label="MethodAttributes.Virtual 375283"];
11696 [label="HasFlag(MethodAttributes.Virtual) 375284"];
11697 [label="param HasFlag(MethodAttributes flag) 375285"];
11698 [label="param HasFlag(this) 375286"];
11699 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375287"];
11700 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375288"];
11701 [label="return ((ushort)flag & _flags) != 0; 375289"];
11702 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375290"];
11703 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375291"];
11704 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375292"];
11705 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375293"];
11706 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375294"];
11707 [label="method.IsAbstract 375295"];
11708 [label="=> HasFlag(MethodAttributes.Abstract) 375296"];
11709 [label="MethodAttributes.Abstract 375297"];
11710 [label="HasFlag(MethodAttributes.Abstract) 375298"];
11711 [label="param HasFlag(MethodAttributes flag) 375299"];
11712 [label="param HasFlag(this) 375300"];
11713 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375301"];
11714 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375302"];
11715 [label="return ((ushort)flag & _flags) != 0; 375303"];
11716 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375304"];
11717 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375305"];
11718 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 375306"];
11719 [label="param GetParameters(this) 375307"];
11720 [label="param IsByRefMethod(this) 375308"];
11721 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 375309"];
11722 [label="param GetReturnType(this) 375310"];
11723 [label="=> defaultType 375311"];
11724 [label="param MatchTypeToTypeId(this) 375312"];
11725 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 375313"];
11726 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 375314"];
11727 [label="param MatchTypeToTypeId(this) 375315"];
11728 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 375316"];
11729 [label="DiagnosticInfo result = null; 375317"];
11730 [label="CalculateUseSiteDiagnostic(ref result); 375318"];
11731 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 375319"];
11732 [label="this.IsDefinition 375320"];
11733 [label="get\n            {\n                return this.OriginalDefinition;\n            } 375321"];
11734 [label="this.OriginalDefinition 375322"];
11735 [label="get\n            {\n                return this;\n            } 375323"];
11736 [label="return this; 375324"];
11737 [label="return this.OriginalDefinition; 375325"];
11738 [label="Debug.Assert(this.IsDefinition); 375326"];
11739 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375327"];
11740 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 375328"];
11741 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 375329"];
11742 [label="param BitsAreUnsetOrSame(int bits) 375330"];
11743 [label="param BitsAreUnsetOrSame(int mask) 375331"];
11744 [label="return (bits & mask) == 0 || (bits & mask) == mask; 375332"];
11745 [label="return (bits & mask) == 0 || (bits & mask) == mask; 375333"];
11746 [label="_packedFlags.IsInitOnly 375334"];
11747 [label="=> (_bits & IsInitOnlyBit) != 0 375335"];
11748 [label="_bits & IsInitOnlyBit 375336"];
11749 [label="0 375337"];
11750 [label="(_bits & IsInitOnlyBit) != 0 375338"];
11751 [label="return _packedFlags.IsInitOnly; 375339"];
11752 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 375340"];
11753 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 375341"];
11754 [label="param DeriveUseSiteDiagnosticFromType(this) 375342"];
11755 [label="=> defaultType 375343"];
11756 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 375344"];
11757 [label="param DeriveUseSiteDiagnosticFromType(this) 375345"];
11758 [label="return _lazyUseSiteDiagnostic; 375346"];
11759 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 375347"];
11760 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 375348"];
11761 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 375349"];
11762 [label="return MergeUseSiteDiagnostics(ref result, info); 375350"];
11763 [label="return MergeUseSiteDiagnostics(ref result, info); 375351"];
11764 [label="MergeUseSiteDiagnostics(ref result, info) 375352"];
11765 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 375353"];
11766 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 375354"];
11767 [label="param MergeUseSiteDiagnostics(this) 375355"];
11768 [label="type.CustomModifiers 375356"];
11769 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 375357"];
11770 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 375358"];
11771 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 375359"];
11772 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 375360"];
11773 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 375361"];
11774 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 375362"];
11775 [label="bool checkRequiredModifiers = true; 375363"];
11776 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 375364"];
11777 [label="return false; 375365"];
11778 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 375366"];
11779 [label="this.RefCustomModifiers 375367"];
11780 [label="=> Signature.ReturnParam.RefCustomModifiers 375368"];
11781 [label="Signature 375369"];
11782 [label="=> _lazySignature ?? LoadSignature() 375370"];
11783 [label="Signature.ReturnParam.RefCustomModifiers 375371"];
11784 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 375372"];
11785 [label="return ImmutableArray<CustomModifier>.Empty; 375373"];
11786 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 375374"];
11787 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 375375"];
11788 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 375376"];
11789 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 375377"];
11790 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 375378"];
11791 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 375379"];
11792 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 375380"];
11793 [label="bool checkRequiredModifiers = true; 375381"];
11794 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 375382"];
11795 [label="return false; 375383"];
11796 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 375384"];
11797 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 375385"];
11798 [label="param DeriveUseSiteDiagnosticFromParameters(this) 375386"];
11799 [label="return false; 375387"];
11800 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 375388"];
11801 [label="this.ContainingModule 375389"];
11802 [label="s.Kind 375390"];
11803 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375391"];
11804 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 375392"];
11805 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 375393"];
11806 [label=".HasUnifiedReferences 375394"];
11807 [label="get { return GetUnifiedAssemblies().Length > 0; } 375395"];
11808 [label="GetUnifiedAssemblies() 375396"];
11809 [label="param GetUnifiedAssemblies(this) 375397"];
11810 [label="AssertReferencesInitialized() 375398"];
11811 [label="param AssertReferencesInitialized(this) 375399"];
11812 [label="Debug.Assert(_moduleReferences != null); 375400"];
11813 [label="Debug.Assert(_moduleReferences != null); 375401"];
11814 [label="AssertReferencesInitialized(); 375402"];
11815 [label="return GetUnifiedAssemblies().Length > 0; 375403"];
11816 [label="return GetUnifiedAssemblies().Length > 0; 375404"];
11817 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 375405"];
11818 [label="return false; 375406"];
11819 [label="CalculateUseSiteDiagnostic(ref result); 375407"];
11820 [label="EnsureTypeParametersAreLoaded(ref result); 375408"];
11821 [label="EnsureTypeParametersAreLoaded(ref result) 375409"];
11822 [label="param EnsureTypeParametersAreLoaded(ref DiagnosticInfo diagnosticInfo) 375410"];
11823 [label="param EnsureTypeParametersAreLoaded(this) 375411"];
11824 [label="var typeParams = _lazyTypeParameters; 375412"];
11825 [label="if (!typeParams.IsDefault)\n            {\n                return typeParams;\n            } 375413"];
11826 [label="return typeParams; 375414"];
11827 [label="EnsureTypeParametersAreLoaded(ref result); 375415"];
11828 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 375416"];
11829 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 375417"];
11830 [label="param GetUnmanagedCallersOnlyAttributeData(bool forceComplete) 375418"];
11831 [label="Debug.Assert((object)moduleSymbol != null); 375419"];
11832 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 375420"];
11833 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 375421"];
11834 [label="_lazyObsoleteAttributeData 375422"];
11835 [label="_lazyUnmanagedCallersOnlyAttributeData 375423"];
11836 [label="_packedFlags.IsCustomAttributesPopulated 375424"];
11837 [label="=> (_bits & IsCustomAttributesPopulatedBit) != 0 375425"];
11838 [label="_bits & IsCustomAttributesPopulatedBit 375426"];
11839 [label="0 375427"];
11840 [label="(_bits & IsCustomAttributesPopulatedBit) != 0 375428"];
11841 [label="if (_packedFlags.IsCustomAttributesPopulated)\n            {\n                retVal._lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n            } 375429"];
11842 [label="_packedFlags.IsConditionalPopulated 375430"];
11843 [label="=> (_bits & IsConditionalPopulatedBit) != 0 375431"];
11844 [label="_bits & IsConditionalPopulatedBit 375432"];
11845 [label="0 375433"];
11846 [label="(_bits & IsConditionalPopulatedBit) != 0 375434"];
11847 [label="if (_packedFlags.IsConditionalPopulated)\n            {\n                retVal._lazyConditionalAttributeSymbols = ImmutableArray<string>.Empty;\n            } 375435"];
11848 [label="_packedFlags.IsOverriddenOrHiddenMembersPopulated 375436"];
11849 [label="=> (_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 375437"];
11850 [label="_bits & IsOverriddenOrHiddenMembersPopulatedBit 375438"];
11851 [label="0 375439"];
11852 [label="(_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 375440"];
11853 [label="if (_packedFlags.IsOverriddenOrHiddenMembersPopulated)\n            {\n                retVal._lazyOverriddenOrHiddenMembersResult = OverriddenOrHiddenMembersResult.Empty;\n            } 375441"];
11854 [label="_packedFlags.IsMemberNotNullPopulated 375442"];
11855 [label="=> (_bits & IsMemberNotNullPopulatedBit) != 0 375443"];
11856 [label="_bits & IsMemberNotNullPopulatedBit 375444"];
11857 [label="0 375445"];
11858 [label="(_bits & IsMemberNotNullPopulatedBit) != 0 375446"];
11859 [label="if (_packedFlags.IsMemberNotNullPopulated)\n            {\n                retVal._lazyNotNullMembers = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenTrue = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenFalse = ImmutableArray<string>.Empty;\n            } 375447"];
11860 [label="_packedFlags.IsExplicitOverrideIsPopulated 375448"];
11861 [label="=> (_bits & IsExplicitOverrideIsPopulatedBit) != 0 375449"];
11862 [label="_bits & IsExplicitOverrideIsPopulatedBit 375450"];
11863 [label="0 375451"];
11864 [label="(_bits & IsExplicitOverrideIsPopulatedBit) != 0 375452"];
11865 [label="if (_packedFlags.IsExplicitOverrideIsPopulated)\n            {\n                retVal._lazyExplicitClassOverride = null;\n            } 375453"];
11866 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated(); 375454"];
11867 [label="return result; 375455"];
11868 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 375456"];
11869 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 375457"];
11870 [label="return InitializeUseSiteDiagnostic(result); 375458"];
11871 [label="param InitializeUseSiteDiagnostic(DiagnosticInfo diagnostic) 375459"];
11872 [label="_packedFlags.IsUseSiteDiagnosticPopulated 375460"];
11873 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 375461"];
11874 [label="if (_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                return _uncommonFields?._lazyUseSiteDiagnostic;\n            } 375462"];
11875 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 375463"];
11876 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 375464"];
11877 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated(); 375465"];
11878 [label="return diagnostic; 375466"];
11879 [label="var info = this.GetUseSiteDiagnostic(); 375467"];
11880 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 375468"];
11881 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 375469"];
11882 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 375470"];
11883 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 375471"];
11884 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 375472"];
11885 [label="param TransformType(int targetSymbolCustomModifierCount) 375473"];
11886 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 375474"];
11887 [label="Debug.Assert((object)metadataType != null); 375475"];
11888 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 375476"];
11889 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 375477"];
11890 [label="_elementNames 375478"];
11891 [label="elementNames.IsDefault 375479"];
11892 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 375480"];
11893 [label="_namesIndex 375481"];
11894 [label="_foundUsableErrorType = false; 375482"];
11895 [label="_foundUsableErrorType 375483"];
11896 [label="param DecodeType(this) 375484"];
11897 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 375485"];
11898 [label="param DecodeNamedType(this) 375486"];
11899 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 375487"];
11900 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 375488"];
11901 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 375489"];
11902 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 375490"];
11903 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 375491"];
11904 [label="DecodeTypeArguments(typeArgs) 375492"];
11905 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 375493"];
11906 [label="param DecodeTypeArguments(this) 375494"];
11907 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 375495"];
11908 [label="return typeArgs; 375496"];
11909 [label="type.ContainingType 375497"];
11910 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 375498"];
11911 [label="return _container as NamedTypeSymbol; 375499"];
11912 [label="NamedTypeSymbol containingType = type.ContainingType; 375500"];
11913 [label="NamedTypeSymbol? decodedContainingType; 375501"];
11914 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 375502"];
11915 [label="decodedContainingType = containingType; 375503"];
11916 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 375504"];
11917 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 375505"];
11918 [label="var typeArgsChanged = typeArgs != decodedArgs; 375506"];
11919 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 375507"];
11920 [label="decodedType.IsTupleType 375508"];
11921 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 375509"];
11922 [label="_ 375510"];
11923 [label="tupleCardinality: out _ 375511"];
11924 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 375512"];
11925 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 375513"];
11926 [label="param IsTupleTypeOfCardinality(this) 375514"];
11927 [label="IsUnboundGenericType 375515"];
11928 [label="get\n            {\n                return false;\n            } 375516"];
11929 [label="return false; 375517"];
11930 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375518"];
11931 [label="ContainingSymbol 375519"];
11932 [label="get\n            {\n                return _container;\n            } 375520"];
11933 [label="return _container; 375521"];
11934 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375522"];
11935 [label=".Kind 375523"];
11936 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 375524"];
11937 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375525"];
11938 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375526"];
11939 [label="ContainingNamespace 375527"];
11940 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 375528"];
11941 [label="get\n            {\n                return _container;\n            } 375529"];
11942 [label="return _container; 375530"];
11943 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375531"];
11944 [label="ContainingNamespace.ContainingNamespace 375532"];
11945 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 375533"];
11946 [label=".IsGlobalNamespace 375534"];
11947 [label="get\n            {\n                return true;\n            } 375535"];
11948 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375536"];
11949 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375537"];
11950 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375538"];
11951 [label="Name 375539"];
11952 [label="get\n            {\n                return _name;\n            } 375540"];
11953 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375541"];
11954 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375542"];
11955 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 375543"];
11956 [label="tupleCardinality = 0; 375544"];
11957 [label="return false; 375545"];
11958 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 375546"];
11959 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 375547"];
11960 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 375548"];
11961 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 375549"];
11962 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 375550"];
11963 [label="typeSymbol.IsNullableType() 375551"];
11964 [label="param IsNullableType(this TypeSymbol type) 375552"];
11965 [label="type.OriginalDefinition 375553"];
11966 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 375554"];
11967 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 375555"];
11968 [label="type.OriginalDefinition.SpecialType 375556"];
11969 [label="get\n            {\n                return _corTypeId;\n            } 375557"];
11970 [label="var a1 = defaultType is null; 375558"];
11971 [label="!a1 375559"];
11972 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 375560"];
11973 [label="defaultType.IsNullableType() 375561"];
11974 [label="param IsNullableType(this TypeSymbol type) 375562"];
11975 [label="type.OriginalDefinition 375563"];
11976 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 375564"];
11977 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 375565"];
11978 [label="type.OriginalDefinition.SpecialType 375566"];
11979 [label="get\n            {\n                return _corTypeId;\n            } 375567"];
11980 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 375568"];
11981 [label="Debug.Assert(a1 || a2 != true || a3); 375569"];
11982 [label="Debug.Assert(a1 || a2 != true || a3); 375570"];
11983 [label="Debug.Assert(extensions != null); 375571"];
11984 [label="metadataType.HasType 375572"];
11985 [label="=> !(DefaultType is null) 375573"];
11986 [label="DefaultType is null 375574"];
11987 [label="!(DefaultType is null) 375575"];
11988 [label="Debug.Assert(metadataType.HasType); 375576"];
11989 [label="Debug.Assert(accessSymbol.IsDefinition); 375577"];
11990 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 375578"];
11991 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 375579"];
11992 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 375580"];
11993 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 375581"];
11994 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 375582"];
11995 [label="Debug.Assert(symbol is object); 375583"];
11996 [label="symbol.Kind 375584"];
11997 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 375585"];
11998 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 375586"];
11999 [label="isInternal = false; 375587"];
12000 [label="symbol.DeclaredAccessibility 375588"];
12001 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 375589"];
12002 [label="Accessibility access = Accessibility.Private; 375590"];
12003 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 375591"];
12004 [label="symbol.ContainingType 375592"];
12005 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 375593"];
12006 [label="return _container as NamedTypeSymbol; 375594"];
12007 [label="symbol = symbol.ContainingType; 375595"];
12008 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 375596"];
12009 [label="return true; 375597"];
12010 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 375598"];
12011 [label="param TryGetByte(out byte? value) 375599"];
12012 [label="return true; 375600"];
12013 [label="=> defaultType 375601"];
12014 [label="Debug.Assert((object)depends != null); 375602"];
12015 [label="Debug.Assert((object)on != null); 375603"];
12016 [label="Debug.Assert(on.IsDefinition); 375604"];
12017 [label="depends.DeclaringCompilation 375605"];
12018 [label="get { return null; } 375606"];
12019 [label="return null; 375607"];
12020 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 375608"];
12021 [label="if ((object)type == null)\n            {\n                return;\n            } 375609"];
12022 [label="return; 375610"];
12023 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 375611"];
12024 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 375612"];
12025 [label="return result; 375613"];
12026 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 375614"];
12027 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 375615"];
12028 [label="@base.IsErrorType() 375616"];
12029 [label="param IsErrorType(this TypeSymbol type) 375617"];
12030 [label="RoslynDebug.Assert((object)type != null); 375618"];
12031 [label="RoslynDebug.Assert((object)type != null); 375619"];
12032 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 375620"];
12033 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 375621"];
12034 [label="param MergeUseSiteDiagnostics(this) 375622"];
12035 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 375623"];
12036 [label="this.ContainingModule.HasUnifiedReferences 375624"];
12037 [label="get { return GetUnifiedAssemblies().Length > 0; } 375625"];
12038 [label="GetUnifiedAssemblies() 375626"];
12039 [label="param GetUnifiedAssemblies(this) 375627"];
12040 [label="AssertReferencesInitialized() 375628"];
12041 [label="param AssertReferencesInitialized(this) 375629"];
12042 [label="Debug.Assert(_moduleReferences != null); 375630"];
12043 [label="Debug.Assert(_moduleReferences != null); 375631"];
12044 [label="AssertReferencesInitialized(); 375632"];
12045 [label="return GetUnifiedAssemblies().Length > 0; 375633"];
12046 [label="return GetUnifiedAssemblies().Length > 0; 375634"];
12047 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 375635"];
12048 [label="SpecialType 375636"];
12049 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 375637"];
12050 [label="TypeSymbol @base = GetDeclaredBaseType(null); 375638"];
12051 [label="GetDeclaredBaseType(null) 375639"];
12052 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 375640"];
12053 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 375641"];
12054 [label="TypeSymbol @base = GetDeclaredBaseType(null); 375642"];
12055 [label=".SpecialType 375643"];
12056 [label="get\n            {\n                return _corTypeId;\n            } 375644"];
12057 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 375645"];
12058 [label="@base.ContainingAssembly 375646"];
12059 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 375647"];
12060 [label="this.ContainingSymbol 375648"];
12061 [label="get\n            {\n                return _container;\n            } 375649"];
12062 [label="return _container; 375650"];
12063 [label="var container = this.ContainingSymbol; 375651"];
12064 [label="return (object)container != null ? container.ContainingAssembly : null; 375652"];
12065 [label="return (object)container != null ? container.ContainingAssembly : null; 375653"];
12066 [label="(object)container != null 375654"];
12067 [label="container.ContainingAssembly 375655"];
12068 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 375656"];
12069 [label="ContainingPEModule 375657"];
12070 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 375658"];
12071 [label="return ContainingPEModule.ContainingAssembly; 375659"];
12072 [label="ContainingPEModule.ContainingAssembly 375660"];
12073 [label="get\n            {\n                return _assemblySymbol;\n            } 375661"];
12074 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 375662"];
12075 [label=".IsMissing 375663"];
12076 [label="get\n            {\n                return false;\n            } 375664"];
12077 [label="return false; 375665"];
12078 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 375666"];
12079 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 375667"];
12080 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 375668"];
12081 [label="return _lazyUseSiteDiagnostic; 375669"];
12082 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 375670"];
12083 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 375671"];
12084 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 375672"];
12085 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 375673"];
12086 [label="return memberSymbol; 375674"];
12087 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 375675"];
12088 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 375676"];
12089 [label="return memberSymbol; 375677"];
12090 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 375678"];
12091 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 375679"];
12092 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 375680"];
12093 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 375681"];
12094 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton) 375682"];
12095 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 375683"];
12096 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 375684"];
12097 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 375685"];
12098 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 375686"];
12099 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 375687"];
12100 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 375688"];
12101 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 375689"];
12102 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 375690"];
12103 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 375691"];
12104 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 375692"];
12105 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 375693"];
12106 [label="param GetWellKnownTypeMember(Location location = null) 375694"];
12107 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 375695"];
12108 [label="param GetWellKnownTypeMember(bool isOptional = false) 375696"];
12109 [label="Debug.Assert((syntax != null) ^ (location != null)); 375697"];
12110 [label="Debug.Assert((syntax != null) ^ (location != null)); 375698"];
12111 [label="Debug.Assert((syntax != null) ^ (location != null)); 375699"];
12112 [label="Debug.Assert((syntax != null) ^ (location != null)); 375700"];
12113 [label="DiagnosticInfo useSiteDiagnostic; 375701"];
12114 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 375702"];
12115 [label="param GetWellKnownTypeMember(bool isOptional = false) 375703"];
12116 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 375704"];
12117 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 375705"];
12118 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 375706"];
12119 [label="if (IsMemberMissing(member)) return null; 375707"];
12120 [label="Debug.Assert(type.IsValid()); 375708"];
12121 [label="this.Options 375709"];
12122 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 375710"];
12123 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 375711"];
12124 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 375712"];
12125 [label="param Includes(this BinderFlags self) 375713"];
12126 [label="param Includes(BinderFlags other) 375714"];
12127 [label="return (self & other) == other; 375715"];
12128 [label="Symbol? result = null; 375716"];
12129 [label="param IsErrorType(this TypeSymbol type) 375717"];
12130 [label="RoslynDebug.Assert((object)type != null); 375718"];
12131 [label="RoslynDebug.Assert((object)type != null); 375719"];
12132 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 375720"];
12133 [label="GetBoundReferenceManager(); 375721"];
12134 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 375722"];
12135 [label="EnsureAllMembersAreLoaded(); 375723"];
12136 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 375724"];
12137 [label="SymbolKind targetSymbolKind; 375725"];
12138 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 375726"];
12139 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 375727"];
12140 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 375728"];
12141 [label="Symbol? result = null; 375729"];
12142 [label="targetSymbolKind = SymbolKind.Property; 375730"];
12143 [label="member.Name 375731"];
12144 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 375732"];
12145 [label="this.ParameterCount 375733"];
12146 [label="get\n            {\n                return this.Parameters.Length;\n            } 375734"];
12147 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 375735"];
12148 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 375736"];
12149 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 375737"];
12150 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 375738"];
12151 [label="member.Kind 375739"];
12152 [label="get\n            {\n                return SymbolKind.Property;\n            } 375740"];
12153 [label="return SymbolKind.Property; 375741"];
12154 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375742"];
12155 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375743"];
12156 [label="get\n            {\n                // All accessors static.\n                return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic);\n            } 375744"];
12157 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 375745"];
12158 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 375746"];
12159 [label="_getMethod.IsStatic 375747"];
12160 [label="=> HasFlag(MethodAttributes.Static) 375748"];
12161 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375749"];
12162 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 375750"];
12163 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375751"];
12164 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375752"];
12165 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375753"];
12166 [label="member.DeclaredAccessibility 375754"];
12167 [label="get\n            {\n                if (_declaredAccessibility == UnsetAccessibility)\n                {\n                    Accessibility accessibility;\n                    if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    }\n\n                    Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility);\n                }\n\n                return (Accessibility)_declaredAccessibility;\n            } 375755"];
12168 [label="if (_declaredAccessibility == UnsetAccessibility)\n                {\n                    Accessibility accessibility;\n                    if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    }\n\n                    Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility);\n                } 375756"];
12169 [label="Accessibility accessibility; 375757"];
12170 [label="this.IsOverride 375758"];
12171 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 375759"];
12172 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375760"];
12173 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375761"];
12174 [label="_getMethod.IsOverride 375762"];
12175 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375763"];
12176 [label="this._containingType.IsInterface 375764"];
12177 [label="get\n            {\n                return _flags.IsInterface();\n            } 375765"];
12178 [label="this.IsMetadataVirtual() 375766"];
12179 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375767"];
12180 [label="=> HasFlag(MethodAttributes.Virtual) 375768"];
12181 [label="MethodAttributes.Virtual 375769"];
12182 [label="HasFlag(MethodAttributes.Virtual) 375770"];
12183 [label="param HasFlag(MethodAttributes flag) 375771"];
12184 [label="param HasFlag(this) 375772"];
12185 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375773"];
12186 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375774"];
12187 [label="return ((ushort)flag & _flags) != 0; 375775"];
12188 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375776"];
12189 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375777"];
12190 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375778"];
12191 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375779"];
12192 [label="_setMethod.IsOverride 375780"];
12193 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375781"];
12194 [label="this._containingType.IsInterface 375782"];
12195 [label="get\n            {\n                return _flags.IsInterface();\n            } 375783"];
12196 [label="this.IsMetadataVirtual() 375784"];
12197 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375785"];
12198 [label="=> HasFlag(MethodAttributes.Virtual) 375786"];
12199 [label="MethodAttributes.Virtual 375787"];
12200 [label="HasFlag(MethodAttributes.Virtual) 375788"];
12201 [label="param HasFlag(MethodAttributes flag) 375789"];
12202 [label="param HasFlag(this) 375790"];
12203 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375791"];
12204 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375792"];
12205 [label="return ((ushort)flag & _flags) != 0; 375793"];
12206 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375794"];
12207 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375795"];
12208 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375796"];
12209 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375797"];
12210 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375798"];
12211 [label="if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    } 375799"];
12212 [label="this.GetMethod 375800"];
12213 [label="get { return _getMethod; } 375801"];
12214 [label="return _getMethod; 375802"];
12215 [label="accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod); 375803"];
12216 [label="this.SetMethod 375804"];
12217 [label="get { return _setMethod; } 375805"];
12218 [label="return _setMethod; 375806"];
12219 [label="accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod); 375807"];
12220 [label="PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod) 375808"];
12221 [label="param GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor1) 375809"];
12222 [label="param GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor2) 375810"];
12223 [label="if ((object)accessor1 == null)\n            {\n                return ((object)accessor2 == null) ? Accessibility.NotApplicable : accessor2.DeclaredAccessibility;\n            }\n            else if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 375811"];
12224 [label="if ((object)accessor1 == null)\n            {\n                return ((object)accessor2 == null) ? Accessibility.NotApplicable : accessor2.DeclaredAccessibility;\n            }\n            else if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 375812"];
12225 [label="if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 375813"];
12226 [label="if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 375814"];
12227 [label="accessor1.DeclaredAccessibility 375815"];
12228 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 375816"];
12229 [label="Flags 375817"];
12230 [label="=> (MethodAttributes)_flags 375818"];
12231 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 375819"];
12232 [label="return Accessibility.Public; 375820"];
12233 [label="return GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility); 375821"];
12234 [label="accessor2.DeclaredAccessibility 375822"];
12235 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 375823"];
12236 [label="Flags 375824"];
12237 [label="=> (MethodAttributes)_flags 375825"];
12238 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 375826"];
12239 [label="return Accessibility.Public; 375827"];
12240 [label="return GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility); 375828"];
12241 [label="GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility) 375829"];
12242 [label="param GetDeclaredAccessibilityFromAccessors(Accessibility accessibility1) 375830"];
12243 [label="param GetDeclaredAccessibilityFromAccessors(Accessibility accessibility2) 375831"];
12244 [label="var minAccessibility = (accessibility1 > accessibility2) ? accessibility2 : accessibility1; 375832"];
12245 [label="(accessibility1 > accessibility2) 375833"];
12246 [label="var maxAccessibility = (accessibility1 > accessibility2) ? accessibility1 : accessibility2; 375834"];
12247 [label="(accessibility1 > accessibility2) 375835"];
12248 [label="return ((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal))\n                ? Accessibility.ProtectedOrInternal\n                : maxAccessibility; 375836"];
12249 [label="((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal)) 375837"];
12250 [label="return ((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal))\n                ? Accessibility.ProtectedOrInternal\n                : maxAccessibility; 375838"];
12251 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 375839"];
12252 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 375840"];
12253 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 375841"];
12254 [label="return (Accessibility)_declaredAccessibility; 375842"];
12255 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375843"];
12256 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 375844"];
12257 [label="PropertySymbol property = (PropertySymbol)member; 375845"];
12258 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 375846"];
12259 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 375847"];
12260 [label="property.IsVirtual 375848"];
12261 [label="get\n            {\n                // Some accessor virtual (as long as another isn't override or abstract).\n                return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual));\n            } 375849"];
12262 [label="IsOverride 375850"];
12263 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 375851"];
12264 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375852"];
12265 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375853"];
12266 [label="_getMethod.IsOverride 375854"];
12267 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375855"];
12268 [label="this._containingType.IsInterface 375856"];
12269 [label="get\n            {\n                return _flags.IsInterface();\n            } 375857"];
12270 [label="this.IsMetadataVirtual() 375858"];
12271 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375859"];
12272 [label="=> HasFlag(MethodAttributes.Virtual) 375860"];
12273 [label="MethodAttributes.Virtual 375861"];
12274 [label="HasFlag(MethodAttributes.Virtual) 375862"];
12275 [label="param HasFlag(MethodAttributes flag) 375863"];
12276 [label="param HasFlag(this) 375864"];
12277 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375865"];
12278 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375866"];
12279 [label="return ((ushort)flag & _flags) != 0; 375867"];
12280 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375868"];
12281 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375869"];
12282 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375870"];
12283 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375871"];
12284 [label="_setMethod.IsOverride 375872"];
12285 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375873"];
12286 [label="this._containingType.IsInterface 375874"];
12287 [label="get\n            {\n                return _flags.IsInterface();\n            } 375875"];
12288 [label="this.IsMetadataVirtual() 375876"];
12289 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375877"];
12290 [label="=> HasFlag(MethodAttributes.Virtual) 375878"];
12291 [label="MethodAttributes.Virtual 375879"];
12292 [label="HasFlag(MethodAttributes.Virtual) 375880"];
12293 [label="param HasFlag(MethodAttributes flag) 375881"];
12294 [label="param HasFlag(this) 375882"];
12295 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375883"];
12296 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375884"];
12297 [label="return ((ushort)flag & _flags) != 0; 375885"];
12298 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375886"];
12299 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375887"];
12300 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375888"];
12301 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375889"];
12302 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375890"];
12303 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375891"];
12304 [label="IsAbstract 375892"];
12305 [label="get\n            {\n                // Some accessor abstract.\n                return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract);\n            } 375893"];
12306 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 375894"];
12307 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 375895"];
12308 [label="_getMethod.IsAbstract 375896"];
12309 [label="=> HasFlag(MethodAttributes.Abstract) 375897"];
12310 [label="MethodAttributes.Abstract 375898"];
12311 [label="HasFlag(MethodAttributes.Abstract) 375899"];
12312 [label="param HasFlag(MethodAttributes flag) 375900"];
12313 [label="param HasFlag(this) 375901"];
12314 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375902"];
12315 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375903"];
12316 [label="return ((ushort)flag & _flags) != 0; 375904"];
12317 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 375905"];
12318 [label="_setMethod.IsAbstract 375906"];
12319 [label="=> HasFlag(MethodAttributes.Abstract) 375907"];
12320 [label="MethodAttributes.Abstract 375908"];
12321 [label="HasFlag(MethodAttributes.Abstract) 375909"];
12322 [label="param HasFlag(MethodAttributes flag) 375910"];
12323 [label="param HasFlag(this) 375911"];
12324 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375912"];
12325 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375913"];
12326 [label="return ((ushort)flag & _flags) != 0; 375914"];
12327 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 375915"];
12328 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 375916"];
12329 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375917"];
12330 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375918"];
12331 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375919"];
12332 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375920"];
12333 [label="_getMethod.IsVirtual 375921"];
12334 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375922"];
12335 [label="this.IsMetadataVirtual() 375923"];
12336 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375924"];
12337 [label="=> HasFlag(MethodAttributes.Virtual) 375925"];
12338 [label="MethodAttributes.Virtual 375926"];
12339 [label="HasFlag(MethodAttributes.Virtual) 375927"];
12340 [label="param HasFlag(MethodAttributes flag) 375928"];
12341 [label="param HasFlag(this) 375929"];
12342 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375930"];
12343 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375931"];
12344 [label="return ((ushort)flag & _flags) != 0; 375932"];
12345 [label="this.IsMetadataVirtual() && !this.IsDestructor 375933"];
12346 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 375934"];
12347 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 375935"];
12348 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375936"];
12349 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375937"];
12350 [label="_setMethod.IsVirtual 375938"];
12351 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375939"];
12352 [label="this.IsMetadataVirtual() 375940"];
12353 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375941"];
12354 [label="=> HasFlag(MethodAttributes.Virtual) 375942"];
12355 [label="MethodAttributes.Virtual 375943"];
12356 [label="HasFlag(MethodAttributes.Virtual) 375944"];
12357 [label="param HasFlag(MethodAttributes flag) 375945"];
12358 [label="param HasFlag(this) 375946"];
12359 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375947"];
12360 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375948"];
12361 [label="return ((ushort)flag & _flags) != 0; 375949"];
12362 [label="this.IsMetadataVirtual() && !this.IsDestructor 375950"];
12363 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 375951"];
12364 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 375952"];
12365 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 375953"];
12366 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375954"];
12367 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375955"];
12368 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 375956"];
12369 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 375957"];
12370 [label="property.IsOverride 375958"];
12371 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 375959"];
12372 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375960"];
12373 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375961"];
12374 [label="_getMethod.IsOverride 375962"];
12375 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375963"];
12376 [label="this._containingType.IsInterface 375964"];
12377 [label="get\n            {\n                return _flags.IsInterface();\n            } 375965"];
12378 [label="this.IsMetadataVirtual() 375966"];
12379 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375967"];
12380 [label="=> HasFlag(MethodAttributes.Virtual) 375968"];
12381 [label="MethodAttributes.Virtual 375969"];
12382 [label="HasFlag(MethodAttributes.Virtual) 375970"];
12383 [label="param HasFlag(MethodAttributes flag) 375971"];
12384 [label="param HasFlag(this) 375972"];
12385 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375973"];
12386 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375974"];
12387 [label="return ((ushort)flag & _flags) != 0; 375975"];
12388 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375976"];
12389 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375977"];
12390 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375978"];
12391 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375979"];
12392 [label="_setMethod.IsOverride 375980"];
12393 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375981"];
12394 [label="this._containingType.IsInterface 375982"];
12395 [label="get\n            {\n                return _flags.IsInterface();\n            } 375983"];
12396 [label="this.IsMetadataVirtual() 375984"];
12397 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 375985"];
12398 [label="=> HasFlag(MethodAttributes.Virtual) 375986"];
12399 [label="MethodAttributes.Virtual 375987"];
12400 [label="HasFlag(MethodAttributes.Virtual) 375988"];
12401 [label="param HasFlag(MethodAttributes flag) 375989"];
12402 [label="param HasFlag(this) 375990"];
12403 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375991"];
12404 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 375992"];
12405 [label="return ((ushort)flag & _flags) != 0; 375993"];
12406 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 375994"];
12407 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 375995"];
12408 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 375996"];
12409 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375997"];
12410 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 375998"];
12411 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 375999"];
12412 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 376000"];
12413 [label="property.IsAbstract 376001"];
12414 [label="get\n            {\n                // Some accessor abstract.\n                return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract);\n            } 376002"];
12415 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 376003"];
12416 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 376004"];
12417 [label="_getMethod.IsAbstract 376005"];
12418 [label="=> HasFlag(MethodAttributes.Abstract) 376006"];
12419 [label="MethodAttributes.Abstract 376007"];
12420 [label="HasFlag(MethodAttributes.Abstract) 376008"];
12421 [label="param HasFlag(MethodAttributes flag) 376009"];
12422 [label="param HasFlag(this) 376010"];
12423 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 376011"];
12424 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 376012"];
12425 [label="return ((ushort)flag & _flags) != 0; 376013"];
12426 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 376014"];
12427 [label="_setMethod.IsAbstract 376015"];
12428 [label="=> HasFlag(MethodAttributes.Abstract) 376016"];
12429 [label="MethodAttributes.Abstract 376017"];
12430 [label="HasFlag(MethodAttributes.Abstract) 376018"];
12431 [label="param HasFlag(MethodAttributes flag) 376019"];
12432 [label="param HasFlag(this) 376020"];
12433 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 376021"];
12434 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 376022"];
12435 [label="return ((ushort)flag & _flags) != 0; 376023"];
12436 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 376024"];
12437 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 376025"];
12438 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 376026"];
12439 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 376027"];
12440 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 376028"];
12441 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 376029"];
12442 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 376030"];
12443 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 376031"];
12444 [label="param GetParameters(PropertySymbol property) 376032"];
12445 [label="param GetParameters(this) 376033"];
12446 [label="property.Parameters 376034"];
12447 [label="get { return _parameters; } 376035"];
12448 [label="return property.Parameters; 376036"];
12449 [label="param IsByRefProperty(PropertySymbol property) 376037"];
12450 [label="param IsByRefProperty(this) 376038"];
12451 [label="property.RefKind 376039"];
12452 [label="get { return _refKind; } 376040"];
12453 [label="return _refKind; 376041"];
12454 [label="return property.RefKind != RefKind.None; 376042"];
12455 [label="param GetPropertyType(PropertySymbol property) 376043"];
12456 [label="param GetPropertyType(this) 376044"];
12457 [label="property.Type 376045"];
12458 [label="=> TypeWithAnnotations.Type 376046"];
12459 [label="TypeWithAnnotations 376047"];
12460 [label="get { return _propertyTypeWithAnnotations; } 376048"];
12461 [label="return _propertyTypeWithAnnotations; 376049"];
12462 [label="TypeWithAnnotations.Type 376050"];
12463 [label="=> _extensions?.GetResolvedType(DefaultType) 376051"];
12464 [label="=> defaultType 376052"];
12465 [label="return property.Type; 376053"];
12466 [label="param MatchTypeToTypeId(this) 376054"];
12467 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 376055"];
12468 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 376056"];
12469 [label="param MatchTypeToTypeId(this) 376057"];
12470 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 376058"];
12471 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 376059"];
12472 [label="param GetUseSiteDiagnostic(this) 376060"];
12473 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                _lazyUseSiteDiagnostic = result;\n            } 376061"];
12474 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                _lazyUseSiteDiagnostic = result;\n            } 376062"];
12475 [label="DiagnosticInfo result = null; 376063"];
12476 [label="CalculateUseSiteDiagnostic(ref result); 376064"];
12477 [label="CalculateUseSiteDiagnostic(ref result) 376065"];
12478 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 376066"];
12479 [label="param CalculateUseSiteDiagnostic(this) 376067"];
12480 [label="this.IsDefinition 376068"];
12481 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 376069"];
12482 [label="get\n            {\n                return this.OriginalDefinition;\n            } 376070"];
12483 [label="this.OriginalDefinition 376071"];
12484 [label="get\n            {\n                return this;\n            } 376072"];
12485 [label="return this; 376073"];
12486 [label="return this.OriginalDefinition; 376074"];
12487 [label="Debug.Assert(this.IsDefinition); 376075"];
12488 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376076"];
12489 [label="this.TypeWithAnnotations 376077"];
12490 [label="get { return _propertyTypeWithAnnotations; } 376078"];
12491 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376079"];
12492 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376080"];
12493 [label="DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) 376081"];
12494 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 376082"];
12495 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 376083"];
12496 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 376084"];
12497 [label="param DeriveUseSiteDiagnosticFromType(this) 376085"];
12498 [label="=> defaultType 376086"];
12499 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 376087"];
12500 [label="param DeriveUseSiteDiagnosticFromType(this) 376088"];
12501 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 376089"];
12502 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 376090"];
12503 [label="s.Kind 376091"];
12504 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 376092"];
12505 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 376093"];
12506 [label="Debug.Assert((object)moduleSymbol != null); 376094"];
12507 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 376095"];
12508 [label="param TransformType(int targetSymbolCustomModifierCount) 376096"];
12509 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 376097"];
12510 [label="Debug.Assert((object)metadataType != null); 376098"];
12511 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 376099"];
12512 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 376100"];
12513 [label="_elementNames 376101"];
12514 [label="elementNames.IsDefault 376102"];
12515 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 376103"];
12516 [label="_namesIndex 376104"];
12517 [label="_foundUsableErrorType = false; 376105"];
12518 [label="_foundUsableErrorType 376106"];
12519 [label="param DecodeType(this) 376107"];
12520 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 376108"];
12521 [label="param DecodeNamedType(this) 376109"];
12522 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 376110"];
12523 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 376111"];
12524 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 376112"];
12525 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 376113"];
12526 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 376114"];
12527 [label="DecodeTypeArguments(typeArgs) 376115"];
12528 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 376116"];
12529 [label="param DecodeTypeArguments(this) 376117"];
12530 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 376118"];
12531 [label="return typeArgs; 376119"];
12532 [label="type.ContainingType 376120"];
12533 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 376121"];
12534 [label="return _container as NamedTypeSymbol; 376122"];
12535 [label="NamedTypeSymbol containingType = type.ContainingType; 376123"];
12536 [label="NamedTypeSymbol? decodedContainingType; 376124"];
12537 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 376125"];
12538 [label="decodedContainingType = containingType; 376126"];
12539 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 376127"];
12540 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 376128"];
12541 [label="var typeArgsChanged = typeArgs != decodedArgs; 376129"];
12542 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 376130"];
12543 [label="decodedType.IsTupleType 376131"];
12544 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 376132"];
12545 [label="_ 376133"];
12546 [label="tupleCardinality: out _ 376134"];
12547 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 376135"];
12548 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 376136"];
12549 [label="param IsTupleTypeOfCardinality(this) 376137"];
12550 [label="IsUnboundGenericType 376138"];
12551 [label="get\n            {\n                return false;\n            } 376139"];
12552 [label="return false; 376140"];
12553 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376141"];
12554 [label="ContainingSymbol 376142"];
12555 [label="get\n            {\n                return _container;\n            } 376143"];
12556 [label="return _container; 376144"];
12557 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376145"];
12558 [label=".Kind 376146"];
12559 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 376147"];
12560 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376148"];
12561 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376149"];
12562 [label="ContainingNamespace 376150"];
12563 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 376151"];
12564 [label="get\n            {\n                return _container;\n            } 376152"];
12565 [label="return _container; 376153"];
12566 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376154"];
12567 [label="ContainingNamespace.ContainingNamespace 376155"];
12568 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 376156"];
12569 [label=".IsGlobalNamespace 376157"];
12570 [label="get\n            {\n                return true;\n            } 376158"];
12571 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376159"];
12572 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376160"];
12573 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376161"];
12574 [label="Name 376162"];
12575 [label="get\n            {\n                return _name;\n            } 376163"];
12576 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376164"];
12577 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376165"];
12578 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 376166"];
12579 [label="tupleCardinality = 0; 376167"];
12580 [label="return false; 376168"];
12581 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 376169"];
12582 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 376170"];
12583 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 376171"];
12584 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 376172"];
12585 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 376173"];
12586 [label="typeSymbol.IsNullableType() 376174"];
12587 [label="param IsNullableType(this TypeSymbol type) 376175"];
12588 [label="type.OriginalDefinition 376176"];
12589 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 376177"];
12590 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 376178"];
12591 [label="type.OriginalDefinition.SpecialType 376179"];
12592 [label="get\n            {\n                return _corTypeId;\n            } 376180"];
12593 [label="var a1 = defaultType is null; 376181"];
12594 [label="!a1 376182"];
12595 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 376183"];
12596 [label="defaultType.IsNullableType() 376184"];
12597 [label="param IsNullableType(this TypeSymbol type) 376185"];
12598 [label="type.OriginalDefinition 376186"];
12599 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 376187"];
12600 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 376188"];
12601 [label="type.OriginalDefinition.SpecialType 376189"];
12602 [label="get\n            {\n                return _corTypeId;\n            } 376190"];
12603 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 376191"];
12604 [label="Debug.Assert(a1 || a2 != true || a3); 376192"];
12605 [label="Debug.Assert(a1 || a2 != true || a3); 376193"];
12606 [label="Debug.Assert(extensions != null); 376194"];
12607 [label="metadataType.HasType 376195"];
12608 [label="=> !(DefaultType is null) 376196"];
12609 [label="DefaultType is null 376197"];
12610 [label="!(DefaultType is null) 376198"];
12611 [label="Debug.Assert(metadataType.HasType); 376199"];
12612 [label="Debug.Assert(accessSymbol.IsDefinition); 376200"];
12613 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 376201"];
12614 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 376202"];
12615 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 376203"];
12616 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 376204"];
12617 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 376205"];
12618 [label="Debug.Assert(symbol is object); 376206"];
12619 [label="symbol.Kind 376207"];
12620 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 376208"];
12621 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 376209"];
12622 [label="isInternal = false; 376210"];
12623 [label="symbol.DeclaredAccessibility 376211"];
12624 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 376212"];
12625 [label="Accessibility access = Accessibility.Private; 376213"];
12626 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 376214"];
12627 [label="symbol.ContainingType 376215"];
12628 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 376216"];
12629 [label="return _container as NamedTypeSymbol; 376217"];
12630 [label="symbol = symbol.ContainingType; 376218"];
12631 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 376219"];
12632 [label="return true; 376220"];
12633 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 376221"];
12634 [label="param TryGetByte(out byte? value) 376222"];
12635 [label="value = null; 376223"];
12636 [label="param GetLocalNullableContextValue(this) 376224"];
12637 [label="get\n            {\n                return _moduleSymbol;\n            } 376225"];
12638 [label="return _moduleSymbol; 376226"];
12639 [label="param GetLocalNullableContextValue(this) 376227"];
12640 [label="get\n            {\n                return _assemblySymbol;\n            } 376228"];
12641 [label="return _assemblySymbol; 376229"];
12642 [label="param GetLocalNullableContextValue(this) 376230"];
12643 [label="get\n            {\n                return null;\n            } 376231"];
12644 [label="=> defaultType 376232"];
12645 [label="Debug.Assert((object)depends != null); 376233"];
12646 [label="Debug.Assert((object)on != null); 376234"];
12647 [label="Debug.Assert(on.IsDefinition); 376235"];
12648 [label="depends.DeclaringCompilation 376236"];
12649 [label="get { return null; } 376237"];
12650 [label="return null; 376238"];
12651 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 376239"];
12652 [label="if ((object)type == null)\n            {\n                return;\n            } 376240"];
12653 [label="return; 376241"];
12654 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 376242"];
12655 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 376243"];
12656 [label="return result; 376244"];
12657 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 376245"];
12658 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 376246"];
12659 [label="@base.IsErrorType() 376247"];
12660 [label="param IsErrorType(this TypeSymbol type) 376248"];
12661 [label="RoslynDebug.Assert((object)type != null); 376249"];
12662 [label="RoslynDebug.Assert((object)type != null); 376250"];
12663 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 376251"];
12664 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 376252"];
12665 [label="param MergeUseSiteDiagnostics(this) 376253"];
12666 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 376254"];
12667 [label="this.ContainingModule.HasUnifiedReferences 376255"];
12668 [label="get { return GetUnifiedAssemblies().Length > 0; } 376256"];
12669 [label="GetUnifiedAssemblies() 376257"];
12670 [label="param GetUnifiedAssemblies(this) 376258"];
12671 [label="AssertReferencesInitialized() 376259"];
12672 [label="param AssertReferencesInitialized(this) 376260"];
12673 [label="Debug.Assert(_moduleReferences != null); 376261"];
12674 [label="Debug.Assert(_moduleReferences != null); 376262"];
12675 [label="AssertReferencesInitialized(); 376263"];
12676 [label="return GetUnifiedAssemblies().Length > 0; 376264"];
12677 [label="return GetUnifiedAssemblies().Length > 0; 376265"];
12678 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 376266"];
12679 [label="return _lazyUseSiteDiagnostic; 376267"];
12680 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 376268"];
12681 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 376269"];
12682 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 376270"];
12683 [label="return MergeUseSiteDiagnostics(ref result, info); 376271"];
12684 [label="return MergeUseSiteDiagnostics(ref result, info); 376272"];
12685 [label="MergeUseSiteDiagnostics(ref result, info) 376273"];
12686 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 376274"];
12687 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 376275"];
12688 [label="param MergeUseSiteDiagnostics(this) 376276"];
12689 [label="type.CustomModifiers 376277"];
12690 [label="=> _extensions.CustomModifiers 376278"];
12691 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 376279"];
12692 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 376280"];
12693 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 376281"];
12694 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 376282"];
12695 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 376283"];
12696 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 376284"];
12697 [label="bool checkRequiredModifiers = true; 376285"];
12698 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 376286"];
12699 [label="return false; 376287"];
12700 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 376288"];
12701 [label="this.RefCustomModifiers 376289"];
12702 [label="get { return ImmutableArray<CustomModifier>.Empty; } 376290"];
12703 [label="return ImmutableArray<CustomModifier>.Empty; 376291"];
12704 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376292"];
12705 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376293"];
12706 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 376294"];
12707 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 376295"];
12708 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 376296"];
12709 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 376297"];
12710 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 376298"];
12711 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 376299"];
12712 [label="bool checkRequiredModifiers = true; 376300"];
12713 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 376301"];
12714 [label="return false; 376302"];
12715 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376303"];
12716 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376304"];
12717 [label="this.Parameters 376305"];
12718 [label="get { return _parameters; } 376306"];
12719 [label="return _parameters; 376307"];
12720 [label="DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters) 376308"];
12721 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 376309"];
12722 [label="param DeriveUseSiteDiagnosticFromParameters(ImmutableArray<ParameterSymbol> parameters) 376310"];
12723 [label="param DeriveUseSiteDiagnosticFromParameters(this) 376311"];
12724 [label="return false; 376312"];
12725 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376313"];
12726 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 376314"];
12727 [label="this.ContainingModule 376315"];
12728 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 376316"];
12729 [label="get\n            {\n                return _containingType;\n            } 376317"];
12730 [label="return _containingType; 376318"];
12731 [label="s.Kind 376319"];
12732 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 376320"];
12733 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 376321"];
12734 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (this.TypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 376322"];
12735 [label="this.ContainingModule.HasUnifiedReferences 376323"];
12736 [label="get { return GetUnifiedAssemblies().Length > 0; } 376324"];
12737 [label="GetUnifiedAssemblies() 376325"];
12738 [label="param GetUnifiedAssemblies(this) 376326"];
12739 [label="AssertReferencesInitialized() 376327"];
12740 [label="param AssertReferencesInitialized(this) 376328"];
12741 [label="Debug.Assert(_moduleReferences != null); 376329"];
12742 [label="Debug.Assert(_moduleReferences != null); 376330"];
12743 [label="AssertReferencesInitialized(); 376331"];
12744 [label="return GetUnifiedAssemblies().Length > 0; 376332"];
12745 [label="return GetUnifiedAssemblies().Length > 0; 376333"];
12746 [label="return false; 376334"];
12747 [label="CalculateUseSiteDiagnostic(ref result); 376335"];
12748 [label="_lazyUseSiteDiagnostic 376336"];
12749 [label="return _lazyUseSiteDiagnostic; 376337"];
12750 [label="var info = this.GetUseSiteDiagnostic(); 376338"];
12751 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 376339"];
12752 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 376340"];
12753 [label="get\n            {\n                return _containingType;\n            } 376341"];
12754 [label="return _containingType; 376342"];
12755 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 376343"];
12756 [label="return _lazyUseSiteDiagnostic; 376344"];
12757 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 376345"];
12758 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 376346"];
12759 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 376347"];
12760 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 376348"];
12761 [label="return memberSymbol; 376349"];
12762 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 376350"];
12763 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 376351"];
12764 [label="return memberSymbol; 376352"];
12765 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 376353"];
12766 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 376354"];
12767 [label="param AddDeclarationDiagnostics(this) 376355"];
12768 [label="ContainingSymbol 376356"];
12769 [label="get\n            {\n                return null;\n            } 376357"];
12770 [label="return null; 376358"];
12771 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 376359"];
12772 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 376360"];
12773 [label="Assembly.ForceComplete(location, cancellationToken); 376361"];
12774 [label="return (_completeParts & (int)part) == (int)part; 376362"];
12775 [label="return; 376363"];
12776 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 376364"];
12777 [label="param HasAtMostOneBitSet(int bits) 376365"];
12778 [label="return (bits & (bits - 1)) == 0; 376366"];
12779 [label="this.Modules 376367"];
12780 [label="return (SourceModuleSymbol)this.Modules[0]; 376368"];
12781 [label="param GetAttributes(this) 376369"];
12782 [label="this.GetAttributesBag() 376370"];
12783 [label="param GetAttributesBag(this) 376371"];
12784 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations();\n                if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                }\n            } 376372"];
12785 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations();\n                if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                }\n            } 376373"];
12786 [label="this.ContainingAssembly 376374"];
12787 [label="get\n            {\n                return _assemblySymbol;\n            } 376375"];
12788 [label="return _assemblySymbol; 376376"];
12789 [label="var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations(); 376377"];
12790 [label="((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations() 376378"];
12791 [label="param GetAttributeDeclarations(this) 376379"];
12792 [label="var builder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance(); 376380"];
12793 [label="foreach (RootSingleNamespaceDeclaration rootNs in declarations)\n            {\n                if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                }\n            } 376381"];
12794 [label="if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                } 376382"];
12795 [label="return builder.ToImmutableAndFree(); 376383"];
12796 [label="var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations(); 376384"];
12797 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 376385"];
12798 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 376386"];
12799 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 376387"];
12800 [label="LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag) 376388"];
12801 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 376389"];
12802 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 376390"];
12803 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 376391"];
12804 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 376392"];
12805 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 376393"];
12806 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 376394"];
12807 [label="param LoadAndValidateAttributes(this) 376395"];
12808 [label="var diagnostics = DiagnosticBag.GetInstance(); 376396"];
12809 [label="this.DeclaringCompilation 376397"];
12810 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 376398"];
12811 [label="get\n            {\n                return _compilation;\n            } 376399"];
12812 [label="var compilation = this.DeclaringCompilation; 376400"];
12813 [label="ImmutableArray<Binder> binders; 376401"];
12814 [label="binders 376402"];
12815 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 376403"];
12816 [label="param GetAttributesToBind(AttributeLocation symbolPart) 376404"];
12817 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 376405"];
12818 [label="param GetAttributesToBind(CSharpCompilation compilation) 376406"];
12819 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 376407"];
12820 [label="param GetAttributesToBind(Binder rootBinderOpt) 376408"];
12821 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 376409"];
12822 [label="param GetAttributesToBind(this) 376410"];
12823 [label="var attributeTarget = (IAttributeTargetSymbol)this; 376411"];
12824 [label="ArrayBuilder<Binder> bindersBuilder = null; 376412"];
12825 [label="int attributesToBindCount = 0; 376413"];
12826 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 376414"];
12827 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 376415"];
12828 [label="binders = ImmutableArray<Binder>.Empty; 376416"];
12829 [label="Debug.Assert(!attributesToBind.IsDefault); 376417"];
12830 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 376418"];
12831 [label="boundAttributes 376419"];
12832 [label="WellKnownAttributeData wellKnownAttributeData; 376420"];
12833 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 376421"];
12834 [label="wellKnownAttributeData = null; 376422"];
12835 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 376423"];
12836 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 376424"];
12837 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 376425"];
12838 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 376426"];
12839 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 376427"];
12840 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 376428"];
12841 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 376429"];
12842 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 376430"];
12843 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 376431"];
12844 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 376432"];
12845 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 376433"];
12846 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 376434"];
12847 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 376435"];
12848 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 376436"];
12849 [label="param PostDecodeWellKnownAttributes(this) 376437"];
12850 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 376438"];
12851 [label="bool lazyAttributesStoredOnThisThread = false; 376439"];
12852 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 376440"];
12853 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 376441"];
12854 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 376442"];
12855 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 376443"];
12856 [label="param RecordPresenceOfBadAttributes(this) 376444"];
12857 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 376445"];
12858 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 376446"];
12859 [label="AddDeclarationDiagnostics(diagnostics); 376447"];
12860 [label="AddDeclarationDiagnostics(diagnostics) 376448"];
12861 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 376449"];
12862 [label="param AddDeclarationDiagnostics(this) 376450"];
12863 [label="ContainingSymbol 376451"];
12864 [label="get\n            {\n                return _assemblySymbol;\n            } 376452"];
12865 [label="return _assemblySymbol; 376453"];
12866 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 376454"];
12867 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 376455"];
12868 [label="AddDeclarationDiagnostics(diagnostics); 376456"];
12869 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 376457"];
12870 [label="diagnostics.Free(); 376458"];
12871 [label="var completed = _state.NotePartComplete(CompletionPart.Attributes); 376459"];
12872 [label="_state.NotePartComplete(CompletionPart.Attributes) 376460"];
12873 [label="param NotePartComplete(CompletionPart part) 376461"];
12874 [label="Debug.Assert(completed); 376462"];
12875 [label="return _lazyCustomAttributesBag; 376463"];
12876 [label="return this.GetAttributesBag().Attributes; 376464"];
12877 [label="Assembly.ForceComplete(location, cancellationToken); 376465"];
12878 [label="return (_completeParts & (int)part) == (int)part; 376466"];
12879 [label="return; 376467"];
12880 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 376468"];
12881 [label="param HasAtMostOneBitSet(int bits) 376469"];
12882 [label="return (bits & (bits - 1)) == 0; 376470"];
12883 [label="get\n            {\n                return GetAssembliesToEmbedTypesFrom().Length > 0;\n            } 376471"];
12884 [label="GetAssembliesToEmbedTypesFrom() 376472"];
12885 [label="param GetAssembliesToEmbedTypesFrom(this) 376473"];
12886 [label="if (_lazyAssembliesToEmbedTypesFrom.IsDefault)\n            {\n                AssertReferencesInitialized();\n                var buffer = ArrayBuilder<AssemblySymbol>.GetInstance();\n\n                foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                }\n\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>));\n            } 376474"];
12887 [label="AssertReferencesInitialized() 376475"];
12888 [label="param AssertReferencesInitialized(this) 376476"];
12889 [label="Debug.Assert(_moduleReferences != null); 376477"];
12890 [label="Debug.Assert(_moduleReferences != null); 376478"];
12891 [label="AssertReferencesInitialized(); 376479"];
12892 [label="var buffer = ArrayBuilder<AssemblySymbol>.GetInstance(); 376480"];
12893 [label="this.GetReferencedAssemblySymbols() 376481"];
12894 [label="AssertReferencesInitialized() 376482"];
12895 [label="param AssertReferencesInitialized(this) 376483"];
12896 [label="Debug.Assert(_moduleReferences != null); 376484"];
12897 [label="Debug.Assert(_moduleReferences != null); 376485"];
12898 [label="AssertReferencesInitialized(); 376486"];
12899 [label="foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                } 376487"];
12900 [label="asm.IsLinked 376488"];
12901 [label="get\n            {\n                return _isLinked;\n            } 376489"];
12902 [label="return _isLinked; 376490"];
12903 [label="if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    } 376491"];
12904 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 376492"];
12905 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 376493"];
12906 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 376494"];
12907 [label="Debug.Assert(!_lazyAssembliesToEmbedTypesFrom.IsDefault); 376495"];
12908 [label="return _lazyAssembliesToEmbedTypesFrom; 376496"];
12909 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 376497"];
12910 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 376498"];
12911 [label="return (_completeParts & (int)part) == (int)part; 376499"];
12912 [label="return; 376500"];
12913 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 376501"];
12914 [label="param HasAtMostOneBitSet(int bits) 376502"];
12915 [label="return (bits & (bits - 1)) == 0; 376503"];
12916 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 376504"];
12917 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 376505"];
12918 [label="param GetMembers(this) 376506"];
12919 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 376507"];
12920 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 376508"];
12921 [label="this.GetMembersUnordered() 376509"];
12922 [label="param GetMembersUnordered(this) 376510"];
12923 [label="var result = _lazyAllMembers; 376511"];
12924 [label="if (result.IsDefault)\n            {\n                var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null));  // don't sort.\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members);\n                result = _lazyAllMembers;\n            } 376512"];
12925 [label="this.GetNameToMembersMap() 376513"];
12926 [label="var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null)); 376514"];
12927 [label="var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null)); 376515"];
12928 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members); 376516"];
12929 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members); 376517"];
12930 [label="result = _lazyAllMembers; 376518"];
12931 [label="return result.ConditionallyDeOrder(); 376519"];
12932 [label="var allMembers = this.GetMembersUnordered(); 376520"];
12933 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 376521"];
12934 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 376522"];
12935 [label="ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted); 376523"];
12936 [label="ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted); 376524"];
12937 [label="return allMembers; 376525"];
12938 [label="Assembly.ForceComplete(location, cancellationToken); 376526"];
12939 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 376527"];
12940 [label="this.Kind 376528"];
12941 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 376529"];
12942 [label="return SymbolKind.Namespace; 376530"];
12943 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 376531"];
12944 [label="this.ContainingModule 376532"];
12945 [label="get\n            {\n                return _module;\n            } 376533"];
12946 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 376534"];
12947 [label="param ForceCompleteMemberByLocation(SourceLocation locationOpt) 376535"];
12948 [label="param ForceCompleteMemberByLocation(Symbol member) 376536"];
12949 [label="param ForceCompleteMemberByLocation(CancellationToken cancellationToken) 376537"];
12950 [label="if (locationOpt == null || member.IsDefinedInSourceTree(locationOpt.SourceTree, locationOpt.SourceSpan, cancellationToken))\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                member.ForceComplete(locationOpt, cancellationToken);\n            } 376538"];
12951 [label="if (locationOpt == null || member.IsDefinedInSourceTree(locationOpt.SourceTree, locationOpt.SourceSpan, cancellationToken))\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                member.ForceComplete(locationOpt, cancellationToken);\n            } 376539"];
12952 [label="cancellationToken.ThrowIfCancellationRequested(); 376540"];
12953 [label="member.ForceComplete(locationOpt, cancellationToken); 376541"];
12954 [label="member.ForceComplete(locationOpt, cancellationToken); 376542"];
12955 [label="member.ForceComplete(locationOpt, cancellationToken); 376543"];
12956 [label="member.ForceComplete(locationOpt, cancellationToken); 376544"];
12957 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 376545"];
12958 [label="HasAtMostOneBitSet(next) 376546"];
12959 [label="param HasAtMostOneBitSet(int bits) 376547"];
12960 [label="return (bits & (bits - 1)) == 0; 376548"];
12961 [label="return (bits & (bits - 1)) == 0; 376549"];
12962 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 376550"];
12963 [label="param SpinWaitComplete(CompletionPart part) 376551"];
12964 [label="param SpinWaitComplete(CancellationToken cancellationToken) 376552"];
12965 [label="param SpinWaitComplete(this) 376553"];
12966 [label="if (HasComplete(part))\n            {\n                return;\n            } 376554"];
12967 [label="HasComplete(part) 376555"];
12968 [label="param HasComplete(CompletionPart part) 376556"];
12969 [label="param HasComplete(this) 376557"];
12970 [label="return (_completeParts & (int)part) == (int)part; 376558"];
12971 [label="return; 376559"];
12972 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 376560"];
12973 [label="param BuildSymbol(this) 376561"];
12974 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 376562"];
12975 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 376563"];
12976 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 376564"];
12977 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 376565"];
12978 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 376566"];
12979 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 376567"];
12980 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 376568"];
12981 [label="param SourceNamedTypeSymbol(this) 376569"];
12982 [label="false 376570"];
12983 [label="considerName: false 376571"];
12984 [label="false 376572"];
12985 [label="considerExplicitlyImplementedInterfaces: false 376573"];
12986 [label="true 376574"];
12987 [label="considerReturnType: true 376575"];
12988 [label="false 376576"];
12989 [label="considerTypeConstraints: false 376577"];
12990 [label="true 376578"];
12991 [label="considerRefKindDifferences: true 376579"];
12992 [label="true 376580"];
12993 [label="considerCallingConvention: true 376581"];
12994 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376582"];
12995 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376583"];
12996 [label="param MemberSignatureComparer(bool considerName) 376584"];
12997 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376585"];
12998 [label="param MemberSignatureComparer(bool considerReturnType) 376586"];
12999 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376587"];
13000 [label="param MemberSignatureComparer(bool considerCallingConvention) 376588"];
13001 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376589"];
13002 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376590"];
13003 [label="param MemberSignatureComparer(this) 376591"];
13004 [label="_considerName 376592"];
13005 [label="_considerExplicitlyImplementedInterfaces 376593"];
13006 [label="_considerReturnType 376594"];
13007 [label="_considerTypeConstraints 376595"];
13008 [label="_considerCallingConvention 376596"];
13009 [label="_considerRefKindDifferences 376597"];
13010 [label="_typeComparison 376598"];
13011 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376599"];
13012 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376600"];
13013 [label="_considerName 376601"];
13014 [label="_considerExplicitlyImplementedInterfaces 376602"];
13015 [label="_considerReturnType 376603"];
13016 [label="_considerTypeConstraints 376604"];
13017 [label="_considerCallingConvention 376605"];
13018 [label="_considerRefKindDifferences 376606"];
13019 [label="_typeComparison 376607"];
13020 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376608"];
13021 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376609"];
13022 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376610"];
13023 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376611"];
13024 [label="true 376612"];
13025 [label="considerName: true 376613"];
13026 [label="true 376614"];
13027 [label="considerExplicitlyImplementedInterfaces: true 376615"];
13028 [label="true 376616"];
13029 [label="considerReturnType: true 376617"];
13030 [label="false 376618"];
13031 [label="considerTypeConstraints: false 376619"];
13032 [label="true 376620"];
13033 [label="considerCallingConvention: true 376621"];
13034 [label="true 376622"];
13035 [label="considerRefKindDifferences: true 376623"];
13036 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376624"];
13037 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376625"];
13038 [label="param MemberSignatureComparer(bool considerName) 376626"];
13039 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376627"];
13040 [label="param MemberSignatureComparer(bool considerReturnType) 376628"];
13041 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376629"];
13042 [label="param MemberSignatureComparer(bool considerCallingConvention) 376630"];
13043 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376631"];
13044 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376632"];
13045 [label="param MemberSignatureComparer(this) 376633"];
13046 [label="_considerName 376634"];
13047 [label="_considerExplicitlyImplementedInterfaces 376635"];
13048 [label="_considerReturnType 376636"];
13049 [label="_considerTypeConstraints 376637"];
13050 [label="_considerCallingConvention 376638"];
13051 [label="_considerRefKindDifferences 376639"];
13052 [label="_typeComparison 376640"];
13053 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376641"];
13054 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376642"];
13055 [label="_considerName 376643"];
13056 [label="_considerExplicitlyImplementedInterfaces 376644"];
13057 [label="_considerReturnType 376645"];
13058 [label="_considerTypeConstraints 376646"];
13059 [label="_considerCallingConvention 376647"];
13060 [label="_considerRefKindDifferences 376648"];
13061 [label="_typeComparison 376649"];
13062 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376650"];
13063 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376651"];
13064 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376652"];
13065 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376653"];
13066 [label="true 376654"];
13067 [label="considerName: true 376655"];
13068 [label="true 376656"];
13069 [label="considerExplicitlyImplementedInterfaces: true 376657"];
13070 [label="false 376658"];
13071 [label="considerReturnType: false 376659"];
13072 [label="false 376660"];
13073 [label="considerTypeConstraints: false 376661"];
13074 [label="false 376662"];
13075 [label="considerCallingConvention: false 376663"];
13076 [label="true 376664"];
13077 [label="considerRefKindDifferences: true 376665"];
13078 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376666"];
13079 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376667"];
13080 [label="param MemberSignatureComparer(bool considerName) 376668"];
13081 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376669"];
13082 [label="param MemberSignatureComparer(bool considerReturnType) 376670"];
13083 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376671"];
13084 [label="param MemberSignatureComparer(bool considerCallingConvention) 376672"];
13085 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376673"];
13086 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376674"];
13087 [label="param MemberSignatureComparer(this) 376675"];
13088 [label="_considerName 376676"];
13089 [label="_considerExplicitlyImplementedInterfaces 376677"];
13090 [label="_considerReturnType 376678"];
13091 [label="_considerTypeConstraints 376679"];
13092 [label="_considerCallingConvention 376680"];
13093 [label="_considerRefKindDifferences 376681"];
13094 [label="_typeComparison 376682"];
13095 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376683"];
13096 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376684"];
13097 [label="_considerName 376685"];
13098 [label="_considerExplicitlyImplementedInterfaces 376686"];
13099 [label="_considerReturnType 376687"];
13100 [label="_considerTypeConstraints 376688"];
13101 [label="_considerCallingConvention 376689"];
13102 [label="_considerRefKindDifferences 376690"];
13103 [label="_typeComparison 376691"];
13104 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376692"];
13105 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376693"];
13106 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376694"];
13107 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376695"];
13108 [label="true 376696"];
13109 [label="considerName: true 376697"];
13110 [label="true 376698"];
13111 [label="considerExplicitlyImplementedInterfaces: true 376699"];
13112 [label="false 376700"];
13113 [label="considerReturnType: false 376701"];
13114 [label="false 376702"];
13115 [label="considerTypeConstraints: false 376703"];
13116 [label="false 376704"];
13117 [label="considerCallingConvention: false 376705"];
13118 [label="false 376706"];
13119 [label="considerRefKindDifferences: false 376707"];
13120 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376708"];
13121 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376709"];
13122 [label="param MemberSignatureComparer(bool considerName) 376710"];
13123 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376711"];
13124 [label="param MemberSignatureComparer(bool considerReturnType) 376712"];
13125 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376713"];
13126 [label="param MemberSignatureComparer(bool considerCallingConvention) 376714"];
13127 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376715"];
13128 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376716"];
13129 [label="param MemberSignatureComparer(this) 376717"];
13130 [label="_considerName 376718"];
13131 [label="_considerExplicitlyImplementedInterfaces 376719"];
13132 [label="_considerReturnType 376720"];
13133 [label="_considerTypeConstraints 376721"];
13134 [label="_considerCallingConvention 376722"];
13135 [label="_considerRefKindDifferences 376723"];
13136 [label="_typeComparison 376724"];
13137 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376725"];
13138 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376726"];
13139 [label="_considerName 376727"];
13140 [label="_considerExplicitlyImplementedInterfaces 376728"];
13141 [label="_considerReturnType 376729"];
13142 [label="_considerTypeConstraints 376730"];
13143 [label="_considerCallingConvention 376731"];
13144 [label="_considerRefKindDifferences 376732"];
13145 [label="_typeComparison 376733"];
13146 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376734"];
13147 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376735"];
13148 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376736"];
13149 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 376737"];
13150 [label="_typeComparison 376738"];
13151 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376739"];
13152 [label="true 376740"];
13153 [label="considerName: true 376741"];
13154 [label="true 376742"];
13155 [label="considerExplicitlyImplementedInterfaces: true 376743"];
13156 [label="false 376744"];
13157 [label="considerReturnType: false 376745"];
13158 [label="false 376746"];
13159 [label="considerTypeConstraints: false 376747"];
13160 [label="false 376748"];
13161 [label="considerCallingConvention: false 376749"];
13162 [label="true 376750"];
13163 [label="considerRefKindDifferences: true 376751"];
13164 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376752"];
13165 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376753"];
13166 [label="param MemberSignatureComparer(bool considerName) 376754"];
13167 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376755"];
13168 [label="param MemberSignatureComparer(bool considerReturnType) 376756"];
13169 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376757"];
13170 [label="param MemberSignatureComparer(bool considerCallingConvention) 376758"];
13171 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376759"];
13172 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376760"];
13173 [label="param MemberSignatureComparer(this) 376761"];
13174 [label="_considerName 376762"];
13175 [label="_considerExplicitlyImplementedInterfaces 376763"];
13176 [label="_considerReturnType 376764"];
13177 [label="_considerTypeConstraints 376765"];
13178 [label="_considerCallingConvention 376766"];
13179 [label="_considerRefKindDifferences 376767"];
13180 [label="_typeComparison 376768"];
13181 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376769"];
13182 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376770"];
13183 [label="_considerName 376771"];
13184 [label="_considerExplicitlyImplementedInterfaces 376772"];
13185 [label="_considerReturnType 376773"];
13186 [label="_considerTypeConstraints 376774"];
13187 [label="_considerCallingConvention 376775"];
13188 [label="_considerRefKindDifferences 376776"];
13189 [label="_typeComparison 376777"];
13190 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376778"];
13191 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376779"];
13192 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376780"];
13193 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376781"];
13194 [label="true 376782"];
13195 [label="considerName: true 376783"];
13196 [label="true 376784"];
13197 [label="considerExplicitlyImplementedInterfaces: true 376785"];
13198 [label="false 376786"];
13199 [label="considerReturnType: false 376787"];
13200 [label="false 376788"];
13201 [label="considerTypeConstraints: false 376789"];
13202 [label="false 376790"];
13203 [label="considerCallingConvention: false 376791"];
13204 [label="true 376792"];
13205 [label="considerRefKindDifferences: true 376793"];
13206 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376794"];
13207 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376795"];
13208 [label="param MemberSignatureComparer(bool considerName) 376796"];
13209 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376797"];
13210 [label="param MemberSignatureComparer(bool considerReturnType) 376798"];
13211 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376799"];
13212 [label="param MemberSignatureComparer(bool considerCallingConvention) 376800"];
13213 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376801"];
13214 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376802"];
13215 [label="param MemberSignatureComparer(this) 376803"];
13216 [label="_considerName 376804"];
13217 [label="_considerExplicitlyImplementedInterfaces 376805"];
13218 [label="_considerReturnType 376806"];
13219 [label="_considerTypeConstraints 376807"];
13220 [label="_considerCallingConvention 376808"];
13221 [label="_considerRefKindDifferences 376809"];
13222 [label="_typeComparison 376810"];
13223 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376811"];
13224 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376812"];
13225 [label="_considerName 376813"];
13226 [label="_considerExplicitlyImplementedInterfaces 376814"];
13227 [label="_considerReturnType 376815"];
13228 [label="_considerTypeConstraints 376816"];
13229 [label="_considerCallingConvention 376817"];
13230 [label="_considerRefKindDifferences 376818"];
13231 [label="_typeComparison 376819"];
13232 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376820"];
13233 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376821"];
13234 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376822"];
13235 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376823"];
13236 [label="true 376824"];
13237 [label="considerName: true 376825"];
13238 [label="false 376826"];
13239 [label="considerExplicitlyImplementedInterfaces: false 376827"];
13240 [label="false 376828"];
13241 [label="considerReturnType: false 376829"];
13242 [label="false 376830"];
13243 [label="considerTypeConstraints: false 376831"];
13244 [label="false 376832"];
13245 [label="considerCallingConvention: false 376833"];
13246 [label="true 376834"];
13247 [label="considerRefKindDifferences: true 376835"];
13248 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376836"];
13249 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376837"];
13250 [label="param MemberSignatureComparer(bool considerName) 376838"];
13251 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376839"];
13252 [label="param MemberSignatureComparer(bool considerReturnType) 376840"];
13253 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376841"];
13254 [label="param MemberSignatureComparer(bool considerCallingConvention) 376842"];
13255 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376843"];
13256 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376844"];
13257 [label="param MemberSignatureComparer(this) 376845"];
13258 [label="_considerName 376846"];
13259 [label="_considerExplicitlyImplementedInterfaces 376847"];
13260 [label="_considerReturnType 376848"];
13261 [label="_considerTypeConstraints 376849"];
13262 [label="_considerCallingConvention 376850"];
13263 [label="_considerRefKindDifferences 376851"];
13264 [label="_typeComparison 376852"];
13265 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376853"];
13266 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376854"];
13267 [label="_considerName 376855"];
13268 [label="_considerExplicitlyImplementedInterfaces 376856"];
13269 [label="_considerReturnType 376857"];
13270 [label="_considerTypeConstraints 376858"];
13271 [label="_considerCallingConvention 376859"];
13272 [label="_considerRefKindDifferences 376860"];
13273 [label="_typeComparison 376861"];
13274 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376862"];
13275 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376863"];
13276 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376864"];
13277 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376865"];
13278 [label="true 376866"];
13279 [label="considerName: true 376867"];
13280 [label="false 376868"];
13281 [label="considerExplicitlyImplementedInterfaces: false 376869"];
13282 [label="true 376870"];
13283 [label="considerReturnType: true 376871"];
13284 [label="false 376872"];
13285 [label="considerTypeConstraints: false 376873"];
13286 [label="false 376874"];
13287 [label="considerCallingConvention: false 376875"];
13288 [label="false 376876"];
13289 [label="considerRefKindDifferences: false 376877"];
13290 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 376878"];
13291 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 376879"];
13292 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 376880"];
13293 [label="param MemberSignatureComparer(bool considerName) 376881"];
13294 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376882"];
13295 [label="param MemberSignatureComparer(bool considerReturnType) 376883"];
13296 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376884"];
13297 [label="param MemberSignatureComparer(bool considerCallingConvention) 376885"];
13298 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376886"];
13299 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376887"];
13300 [label="param MemberSignatureComparer(this) 376888"];
13301 [label="_considerName 376889"];
13302 [label="_considerExplicitlyImplementedInterfaces 376890"];
13303 [label="_considerReturnType 376891"];
13304 [label="_considerTypeConstraints 376892"];
13305 [label="_considerCallingConvention 376893"];
13306 [label="_considerRefKindDifferences 376894"];
13307 [label="_typeComparison 376895"];
13308 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376896"];
13309 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376897"];
13310 [label="_considerName 376898"];
13311 [label="_considerExplicitlyImplementedInterfaces 376899"];
13312 [label="_considerReturnType 376900"];
13313 [label="_considerTypeConstraints 376901"];
13314 [label="_considerCallingConvention 376902"];
13315 [label="_considerRefKindDifferences 376903"];
13316 [label="_typeComparison 376904"];
13317 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376905"];
13318 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376906"];
13319 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376907"];
13320 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 376908"];
13321 [label="_typeComparison 376909"];
13322 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 376910"];
13323 [label="true 376911"];
13324 [label="considerName: true 376912"];
13325 [label="false 376913"];
13326 [label="considerExplicitlyImplementedInterfaces: false 376914"];
13327 [label="true 376915"];
13328 [label="considerReturnType: true 376916"];
13329 [label="false 376917"];
13330 [label="considerTypeConstraints: false 376918"];
13331 [label="false 376919"];
13332 [label="considerCallingConvention: false 376920"];
13333 [label="false 376921"];
13334 [label="considerRefKindDifferences: false 376922"];
13335 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376923"];
13336 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376924"];
13337 [label="param MemberSignatureComparer(bool considerName) 376925"];
13338 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376926"];
13339 [label="param MemberSignatureComparer(bool considerReturnType) 376927"];
13340 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376928"];
13341 [label="param MemberSignatureComparer(bool considerCallingConvention) 376929"];
13342 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376930"];
13343 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376931"];
13344 [label="param MemberSignatureComparer(this) 376932"];
13345 [label="_considerName 376933"];
13346 [label="_considerExplicitlyImplementedInterfaces 376934"];
13347 [label="_considerReturnType 376935"];
13348 [label="_considerTypeConstraints 376936"];
13349 [label="_considerCallingConvention 376937"];
13350 [label="_considerRefKindDifferences 376938"];
13351 [label="_typeComparison 376939"];
13352 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376940"];
13353 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376941"];
13354 [label="_considerName 376942"];
13355 [label="_considerExplicitlyImplementedInterfaces 376943"];
13356 [label="_considerReturnType 376944"];
13357 [label="_considerTypeConstraints 376945"];
13358 [label="_considerCallingConvention 376946"];
13359 [label="_considerRefKindDifferences 376947"];
13360 [label="_typeComparison 376948"];
13361 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376949"];
13362 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376950"];
13363 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376951"];
13364 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 376952"];
13365 [label="_typeComparison 376953"];
13366 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376954"];
13367 [label="false 376955"];
13368 [label="considerName: false 376956"];
13369 [label="false 376957"];
13370 [label="considerExplicitlyImplementedInterfaces: false 376958"];
13371 [label="false 376959"];
13372 [label="considerReturnType: false 376960"];
13373 [label="false 376961"];
13374 [label="considerTypeConstraints: false 376962"];
13375 [label="false 376963"];
13376 [label="considerCallingConvention: false 376964"];
13377 [label="true 376965"];
13378 [label="considerRefKindDifferences: true 376966"];
13379 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 376967"];
13380 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376968"];
13381 [label="param MemberSignatureComparer(bool considerName) 376969"];
13382 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 376970"];
13383 [label="param MemberSignatureComparer(bool considerReturnType) 376971"];
13384 [label="param MemberSignatureComparer(bool considerTypeConstraints) 376972"];
13385 [label="param MemberSignatureComparer(bool considerCallingConvention) 376973"];
13386 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 376974"];
13387 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 376975"];
13388 [label="param MemberSignatureComparer(this) 376976"];
13389 [label="_considerName 376977"];
13390 [label="_considerExplicitlyImplementedInterfaces 376978"];
13391 [label="_considerReturnType 376979"];
13392 [label="_considerTypeConstraints 376980"];
13393 [label="_considerCallingConvention 376981"];
13394 [label="_considerRefKindDifferences 376982"];
13395 [label="_typeComparison 376983"];
13396 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376984"];
13397 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 376985"];
13398 [label="_considerName 376986"];
13399 [label="_considerExplicitlyImplementedInterfaces 376987"];
13400 [label="_considerReturnType 376988"];
13401 [label="_considerTypeConstraints 376989"];
13402 [label="_considerCallingConvention 376990"];
13403 [label="_considerRefKindDifferences 376991"];
13404 [label="_typeComparison 376992"];
13405 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376993"];
13406 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 376994"];
13407 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 376995"];
13408 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 376996"];
13409 [label="true 376997"];
13410 [label="considerName: true 376998"];
13411 [label="false 376999"];
13412 [label="considerExplicitlyImplementedInterfaces: false 377000"];
13413 [label="true 377001"];
13414 [label="considerReturnType: true 377002"];
13415 [label="false 377003"];
13416 [label="considerTypeConstraints: false 377004"];
13417 [label="false 377005"];
13418 [label="considerCallingConvention: false 377006"];
13419 [label="true 377007"];
13420 [label="considerRefKindDifferences: true 377008"];
13421 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377009"];
13422 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377010"];
13423 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377011"];
13424 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377012"];
13425 [label="param MemberSignatureComparer(bool considerName) 377013"];
13426 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377014"];
13427 [label="param MemberSignatureComparer(bool considerReturnType) 377015"];
13428 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377016"];
13429 [label="param MemberSignatureComparer(bool considerCallingConvention) 377017"];
13430 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377018"];
13431 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377019"];
13432 [label="param MemberSignatureComparer(this) 377020"];
13433 [label="_considerName 377021"];
13434 [label="_considerExplicitlyImplementedInterfaces 377022"];
13435 [label="_considerReturnType 377023"];
13436 [label="_considerTypeConstraints 377024"];
13437 [label="_considerCallingConvention 377025"];
13438 [label="_considerRefKindDifferences 377026"];
13439 [label="_typeComparison 377027"];
13440 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377028"];
13441 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377029"];
13442 [label="_considerName 377030"];
13443 [label="_considerExplicitlyImplementedInterfaces 377031"];
13444 [label="_considerReturnType 377032"];
13445 [label="_considerTypeConstraints 377033"];
13446 [label="_considerCallingConvention 377034"];
13447 [label="_considerRefKindDifferences 377035"];
13448 [label="_typeComparison 377036"];
13449 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377037"];
13450 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377038"];
13451 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377039"];
13452 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377040"];
13453 [label="false 377041"];
13454 [label="considerName: false 377042"];
13455 [label="false 377043"];
13456 [label="considerExplicitlyImplementedInterfaces: false 377044"];
13457 [label="false 377045"];
13458 [label="considerReturnType: false 377046"];
13459 [label="false 377047"];
13460 [label="considerTypeConstraints: false 377048"];
13461 [label="false 377049"];
13462 [label="considerCallingConvention: false 377050"];
13463 [label="false 377051"];
13464 [label="considerRefKindDifferences: false 377052"];
13465 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377053"];
13466 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 377054"];
13467 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 377055"];
13468 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 377056"];
13469 [label="param MemberSignatureComparer(bool considerName) 377057"];
13470 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377058"];
13471 [label="param MemberSignatureComparer(bool considerReturnType) 377059"];
13472 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377060"];
13473 [label="param MemberSignatureComparer(bool considerCallingConvention) 377061"];
13474 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377062"];
13475 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377063"];
13476 [label="param MemberSignatureComparer(this) 377064"];
13477 [label="_considerName 377065"];
13478 [label="_considerExplicitlyImplementedInterfaces 377066"];
13479 [label="_considerReturnType 377067"];
13480 [label="_considerTypeConstraints 377068"];
13481 [label="_considerCallingConvention 377069"];
13482 [label="_considerRefKindDifferences 377070"];
13483 [label="_typeComparison 377071"];
13484 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377072"];
13485 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377073"];
13486 [label="_considerName 377074"];
13487 [label="_considerExplicitlyImplementedInterfaces 377075"];
13488 [label="_considerReturnType 377076"];
13489 [label="_considerTypeConstraints 377077"];
13490 [label="_considerCallingConvention 377078"];
13491 [label="_considerRefKindDifferences 377079"];
13492 [label="_typeComparison 377080"];
13493 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377081"];
13494 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377082"];
13495 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377083"];
13496 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 377084"];
13497 [label="_typeComparison 377085"];
13498 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 377086"];
13499 [label="true 377087"];
13500 [label="considerName: true 377088"];
13501 [label="false 377089"];
13502 [label="considerExplicitlyImplementedInterfaces: false 377090"];
13503 [label="true 377091"];
13504 [label="considerReturnType: true 377092"];
13505 [label="false 377093"];
13506 [label="considerTypeConstraints: false 377094"];
13507 [label="true 377095"];
13508 [label="considerCallingConvention: true 377096"];
13509 [label="false 377097"];
13510 [label="considerRefKindDifferences: false 377098"];
13511 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377099"];
13512 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377100"];
13513 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377101"];
13514 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377102"];
13515 [label="param MemberSignatureComparer(bool considerName) 377103"];
13516 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377104"];
13517 [label="param MemberSignatureComparer(bool considerReturnType) 377105"];
13518 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377106"];
13519 [label="param MemberSignatureComparer(bool considerCallingConvention) 377107"];
13520 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377108"];
13521 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377109"];
13522 [label="param MemberSignatureComparer(this) 377110"];
13523 [label="_considerName 377111"];
13524 [label="_considerExplicitlyImplementedInterfaces 377112"];
13525 [label="_considerReturnType 377113"];
13526 [label="_considerTypeConstraints 377114"];
13527 [label="_considerCallingConvention 377115"];
13528 [label="_considerRefKindDifferences 377116"];
13529 [label="_typeComparison 377117"];
13530 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377118"];
13531 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377119"];
13532 [label="_considerName 377120"];
13533 [label="_considerExplicitlyImplementedInterfaces 377121"];
13534 [label="_considerReturnType 377122"];
13535 [label="_considerTypeConstraints 377123"];
13536 [label="_considerCallingConvention 377124"];
13537 [label="_considerRefKindDifferences 377125"];
13538 [label="_typeComparison 377126"];
13539 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377127"];
13540 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377128"];
13541 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377129"];
13542 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 377130"];
13543 [label="_typeComparison 377131"];
13544 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377132"];
13545 [label="true 377133"];
13546 [label="considerName: true 377134"];
13547 [label="false 377135"];
13548 [label="considerExplicitlyImplementedInterfaces: false 377136"];
13549 [label="true 377137"];
13550 [label="considerReturnType: true 377138"];
13551 [label="false 377139"];
13552 [label="considerTypeConstraints: false 377140"];
13553 [label="true 377141"];
13554 [label="considerCallingConvention: true 377142"];
13555 [label="true 377143"];
13556 [label="considerRefKindDifferences: true 377144"];
13557 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377145"];
13558 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377146"];
13559 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377147"];
13560 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377148"];
13561 [label="param MemberSignatureComparer(bool considerName) 377149"];
13562 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377150"];
13563 [label="param MemberSignatureComparer(bool considerReturnType) 377151"];
13564 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377152"];
13565 [label="param MemberSignatureComparer(bool considerCallingConvention) 377153"];
13566 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377154"];
13567 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377155"];
13568 [label="param MemberSignatureComparer(this) 377156"];
13569 [label="_considerName 377157"];
13570 [label="_considerExplicitlyImplementedInterfaces 377158"];
13571 [label="_considerReturnType 377159"];
13572 [label="_considerTypeConstraints 377160"];
13573 [label="_considerCallingConvention 377161"];
13574 [label="_considerRefKindDifferences 377162"];
13575 [label="_typeComparison 377163"];
13576 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377164"];
13577 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377165"];
13578 [label="_considerName 377166"];
13579 [label="_considerExplicitlyImplementedInterfaces 377167"];
13580 [label="_considerReturnType 377168"];
13581 [label="_considerTypeConstraints 377169"];
13582 [label="_considerCallingConvention 377170"];
13583 [label="_considerRefKindDifferences 377171"];
13584 [label="_typeComparison 377172"];
13585 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377173"];
13586 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377174"];
13587 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377175"];
13588 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377176"];
13589 [label="true 377177"];
13590 [label="considerName: true 377178"];
13591 [label="true 377179"];
13592 [label="considerExplicitlyImplementedInterfaces: true 377180"];
13593 [label="true 377181"];
13594 [label="considerReturnType: true 377182"];
13595 [label="false 377183"];
13596 [label="considerTypeConstraints: false 377184"];
13597 [label="true 377185"];
13598 [label="considerCallingConvention: true 377186"];
13599 [label="false 377187"];
13600 [label="considerRefKindDifferences: false 377188"];
13601 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377189"];
13602 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377190"];
13603 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377191"];
13604 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377192"];
13605 [label="param MemberSignatureComparer(bool considerName) 377193"];
13606 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377194"];
13607 [label="param MemberSignatureComparer(bool considerReturnType) 377195"];
13608 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377196"];
13609 [label="param MemberSignatureComparer(bool considerCallingConvention) 377197"];
13610 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377198"];
13611 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377199"];
13612 [label="param MemberSignatureComparer(this) 377200"];
13613 [label="_considerName 377201"];
13614 [label="_considerExplicitlyImplementedInterfaces 377202"];
13615 [label="_considerReturnType 377203"];
13616 [label="_considerTypeConstraints 377204"];
13617 [label="_considerCallingConvention 377205"];
13618 [label="_considerRefKindDifferences 377206"];
13619 [label="_typeComparison 377207"];
13620 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377208"];
13621 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377209"];
13622 [label="_considerName 377210"];
13623 [label="_considerExplicitlyImplementedInterfaces 377211"];
13624 [label="_considerReturnType 377212"];
13625 [label="_considerTypeConstraints 377213"];
13626 [label="_considerCallingConvention 377214"];
13627 [label="_considerRefKindDifferences 377215"];
13628 [label="_typeComparison 377216"];
13629 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377217"];
13630 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377218"];
13631 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377219"];
13632 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 377220"];
13633 [label="_typeComparison 377221"];
13634 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377222"];
13635 [label="true 377223"];
13636 [label="considerName: true 377224"];
13637 [label="true 377225"];
13638 [label="considerExplicitlyImplementedInterfaces: true 377226"];
13639 [label="true 377227"];
13640 [label="considerReturnType: true 377228"];
13641 [label="true 377229"];
13642 [label="considerTypeConstraints: true 377230"];
13643 [label="true 377231"];
13644 [label="considerCallingConvention: true 377232"];
13645 [label="true 377233"];
13646 [label="considerRefKindDifferences: true 377234"];
13647 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377235"];
13648 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377236"];
13649 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377237"];
13650 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377238"];
13651 [label="param MemberSignatureComparer(bool considerName) 377239"];
13652 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377240"];
13653 [label="param MemberSignatureComparer(bool considerReturnType) 377241"];
13654 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377242"];
13655 [label="param MemberSignatureComparer(bool considerCallingConvention) 377243"];
13656 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377244"];
13657 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377245"];
13658 [label="param MemberSignatureComparer(this) 377246"];
13659 [label="_considerName 377247"];
13660 [label="_considerExplicitlyImplementedInterfaces 377248"];
13661 [label="_considerReturnType 377249"];
13662 [label="_considerTypeConstraints 377250"];
13663 [label="_considerCallingConvention 377251"];
13664 [label="_considerRefKindDifferences 377252"];
13665 [label="_typeComparison 377253"];
13666 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377254"];
13667 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377255"];
13668 [label="_considerName 377256"];
13669 [label="_considerExplicitlyImplementedInterfaces 377257"];
13670 [label="_considerReturnType 377258"];
13671 [label="_considerTypeConstraints 377259"];
13672 [label="_considerCallingConvention 377260"];
13673 [label="_considerRefKindDifferences 377261"];
13674 [label="_typeComparison 377262"];
13675 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377263"];
13676 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377264"];
13677 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377265"];
13678 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377266"];
13679 [label="true 377267"];
13680 [label="considerName: true 377268"];
13681 [label="false 377269"];
13682 [label="considerExplicitlyImplementedInterfaces: false 377270"];
13683 [label="true 377271"];
13684 [label="considerReturnType: true 377272"];
13685 [label="false 377273"];
13686 [label="considerTypeConstraints: false 377274"];
13687 [label="true 377275"];
13688 [label="considerCallingConvention: true 377276"];
13689 [label="true 377277"];
13690 [label="considerRefKindDifferences: true 377278"];
13691 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377279"];
13692 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377280"];
13693 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 377281"];
13694 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377282"];
13695 [label="param MemberSignatureComparer(bool considerName) 377283"];
13696 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377284"];
13697 [label="param MemberSignatureComparer(bool considerReturnType) 377285"];
13698 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377286"];
13699 [label="param MemberSignatureComparer(bool considerCallingConvention) 377287"];
13700 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377288"];
13701 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377289"];
13702 [label="param MemberSignatureComparer(this) 377290"];
13703 [label="_considerName 377291"];
13704 [label="_considerExplicitlyImplementedInterfaces 377292"];
13705 [label="_considerReturnType 377293"];
13706 [label="_considerTypeConstraints 377294"];
13707 [label="_considerCallingConvention 377295"];
13708 [label="_considerRefKindDifferences 377296"];
13709 [label="_typeComparison 377297"];
13710 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377298"];
13711 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377299"];
13712 [label="_considerName 377300"];
13713 [label="_considerExplicitlyImplementedInterfaces 377301"];
13714 [label="_considerReturnType 377302"];
13715 [label="_considerTypeConstraints 377303"];
13716 [label="_considerCallingConvention 377304"];
13717 [label="_considerRefKindDifferences 377305"];
13718 [label="_typeComparison 377306"];
13719 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377307"];
13720 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377308"];
13721 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377309"];
13722 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 377310"];
13723 [label="false 377311"];
13724 [label="considerName: false 377312"];
13725 [label="false 377313"];
13726 [label="considerExplicitlyImplementedInterfaces: false 377314"];
13727 [label="false 377315"];
13728 [label="considerReturnType: false 377316"];
13729 [label="false 377317"];
13730 [label="considerTypeConstraints: false 377318"];
13731 [label="false 377319"];
13732 [label="considerCallingConvention: false 377320"];
13733 [label="true 377321"];
13734 [label="considerRefKindDifferences: true 377322"];
13735 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 377323"];
13736 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 377324"];
13737 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 377325"];
13738 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 377326"];
13739 [label="param MemberSignatureComparer(bool considerName) 377327"];
13740 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 377328"];
13741 [label="param MemberSignatureComparer(bool considerReturnType) 377329"];
13742 [label="param MemberSignatureComparer(bool considerTypeConstraints) 377330"];
13743 [label="param MemberSignatureComparer(bool considerCallingConvention) 377331"];
13744 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 377332"];
13745 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 377333"];
13746 [label="param MemberSignatureComparer(this) 377334"];
13747 [label="_considerName 377335"];
13748 [label="_considerExplicitlyImplementedInterfaces 377336"];
13749 [label="_considerReturnType 377337"];
13750 [label="_considerTypeConstraints 377338"];
13751 [label="_considerCallingConvention 377339"];
13752 [label="_considerRefKindDifferences 377340"];
13753 [label="_typeComparison 377341"];
13754 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377342"];
13755 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 377343"];
13756 [label="_considerName 377344"];
13757 [label="_considerExplicitlyImplementedInterfaces 377345"];
13758 [label="_considerReturnType 377346"];
13759 [label="_considerTypeConstraints 377347"];
13760 [label="_considerCallingConvention 377348"];
13761 [label="_considerRefKindDifferences 377349"];
13762 [label="_typeComparison 377350"];
13763 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377351"];
13764 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 377352"];
13765 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 377353"];
13766 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 377354"];
13767 [label="MemberSignatureComparer.RecordAPISignatureComparer 377355"];
13768 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 377356"];
13769 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 377357"];
13770 [label="EmptyComparer.Instance 377358"];
13771 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 377359"];
13772 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 377360"];
13773 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 377361"];
13774 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 377362"];
13775 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 377363"];
13776 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 377364"];
13777 [label="containingSymbol 377365"];
13778 [label="declaration 377366"];
13779 [label="diagnostics 377367"];
13780 [label="tupleData 377368"];
13781 [label="param SourceNamedTypeSymbol(this) 377369"];
13782 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 377370"];
13783 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 377371"];
13784 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 377372"];
13785 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 377373"];
13786 [label="param SourceMemberContainerTypeSymbol(this) 377374"];
13787 [label="tupleData 377375"];
13788 [label="param SourceMemberContainerTypeSymbol(this) 377376"];
13789 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 377377"];
13790 [label="_lazyTupleData 377378"];
13791 [label="_declModifiers 377379"];
13792 [label="_containingSymbol 377380"];
13793 [label="declaration 377381"];
13794 [label="new DeclaredMembersAndInitializers() 377382"];
13795 [label="param DeclaredMembersAndInitializers(this) 377383"];
13796 [label="HaveIndexers 377384"];
13797 [label="RecordDeclarationWithParameters 377385"];
13798 [label="RecordPrimaryConstructor 377386"];
13799 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 377387"];
13800 [label="IsNullableEnabledForInstanceConstructorsAndFields 377388"];
13801 [label="IsNullableEnabledForStaticConstructorsAndFields 377389"];
13802 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 377390"];
13803 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 377391"];
13804 [label="_lazyMembersAndInitializers 377392"];
13805 [label="_lazyMembersDictionary 377393"];
13806 [label="_lazyEarlyAttributeDecodingMembersDictionary 377394"];
13807 [label="_lazyTypeMembers 377395"];
13808 [label="_lazyKnownCircularStruct 377396"];
13809 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 377397"];
13810 [label="_lazyContainsExtensionMethods 377398"];
13811 [label="_lazyAnyMemberHasAttributes 377399"];
13812 [label="_containingSymbol 377400"];
13813 [label="this.declaration 377401"];
13814 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 377402"];
13815 [label="declaration.Kind.ToTypeKind() 377403"];
13816 [label="param ToTypeKind(this DeclarationKind kind) 377404"];
13817 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 377405"];
13818 [label="return TypeKind.Interface; 377406"];
13819 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377407"];
13820 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377408"];
13821 [label="MakeModifiers(typeKind, diagnostics) 377409"];
13822 [label="param MakeModifiers(TypeKind typeKind) 377410"];
13823 [label="param MakeModifiers(DiagnosticBag diagnostics) 377411"];
13824 [label="param MakeModifiers(this) 377412"];
13825 [label="this.ContainingSymbol 377413"];
13826 [label="get\n            {\n                return _containingSymbol;\n            } 377414"];
13827 [label="return _containingSymbol; 377415"];
13828 [label="Symbol containingSymbol = this.ContainingSymbol; 377416"];
13829 [label="DeclarationModifiers defaultAccess; 377417"];
13830 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 377418"];
13831 [label="containingSymbol.Kind 377419"];
13832 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377420"];
13833 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 377421"];
13834 [label="defaultAccess = DeclarationModifiers.Internal; 377422"];
13835 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 377423"];
13836 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe; 377424"];
13837 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe; 377425"];
13838 [label="bool modifierErrors; 377426"];
13839 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377427"];
13840 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377428"];
13841 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377429"];
13842 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377430"];
13843 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 377431"];
13844 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 377432"];
13845 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 377433"];
13846 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 377434"];
13847 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 377435"];
13848 [label="param MakeAndCheckTypeModifiers(this) 377436"];
13849 [label="modifierErrors = false; 377437"];
13850 [label="var result = DeclarationModifiers.Unset; 377438"];
13851 [label="var partCount = declaration.Declarations.Length; 377439"];
13852 [label="var missingPartial = false; 377440"];
13853 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 377441"];
13854 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 377442"];
13855 [label="var decl = declaration.Declarations[i]; 377443"];
13856 [label="var mods = decl.Modifiers; 377444"];
13857 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 377445"];
13858 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 377446"];
13859 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377447"];
13860 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377448"];
13861 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377449"];
13862 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377450"];
13863 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377451"];
13864 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377452"];
13865 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 377453"];
13866 [label="param CheckModifiers(DeclarationModifiers modifiers) 377454"];
13867 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 377455"];
13868 [label="param CheckModifiers(Location errorLocation) 377456"];
13869 [label="param CheckModifiers(DiagnosticBag diagnostics) 377457"];
13870 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 377458"];
13871 [label="param CheckModifiers(out bool modifierErrors) 377459"];
13872 [label="modifierErrors = false; 377460"];
13873 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 377461"];
13874 [label="DeclarationModifiers result = modifiers & allowedModifiers; 377462"];
13875 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 377463"];
13876 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377464"];
13877 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377465"];
13878 [label="return result; 377466"];
13879 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 377467"];
13880 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377468"];
13881 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377469"];
13882 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377470"];
13883 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 377471"];
13884 [label="param CheckAccessibility(DeclarationModifiers modifiers) 377472"];
13885 [label="param CheckAccessibility(Symbol symbol) 377473"];
13886 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 377474"];
13887 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 377475"];
13888 [label="IsValidAccessibility(modifiers) 377476"];
13889 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 377477"];
13890 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 377478"];
13891 [label="return true; 377479"];
13892 [label="symbol.Kind 377480"];
13893 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 377481"];
13894 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377482"];
13895 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377483"];
13896 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377484"];
13897 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377485"];
13898 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377486"];
13899 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 377487"];
13900 [label="return null; 377488"];
13901 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377489"];
13902 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377490"];
13903 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377491"];
13904 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 377492"];
13905 [label="result = mods; 377493"];
13906 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377494"];
13907 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377495"];
13908 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 377496"];
13909 [label="this.Name 377497"];
13910 [label="get\n            {\n                return declaration.Name;\n            } 377498"];
13911 [label="return declaration.Name; 377499"];
13912 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377500"];
13913 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377501"];
13914 [label="return result; 377502"];
13915 [label="this.CheckUnsafeModifier(mods, diagnostics); 377503"];
13916 [label="this.CheckUnsafeModifier(mods, diagnostics); 377504"];
13917 [label="this.CheckUnsafeModifier(mods, diagnostics); 377505"];
13918 [label="this.CheckUnsafeModifier(mods, diagnostics) 377506"];
13919 [label="param CheckUnsafeModifier(this Symbol symbol) 377507"];
13920 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377508"];
13921 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377509"];
13922 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 377510"];
13923 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 377511"];
13924 [label="symbol.Locations 377512"];
13925 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 377513"];
13926 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 377514"];
13927 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 377515"];
13928 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 377516"];
13929 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 377517"];
13930 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 377518"];
13931 [label="param CheckUnsafeModifier(this Symbol symbol) 377519"];
13932 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377520"];
13933 [label="param CheckUnsafeModifier(Location errorLocation) 377521"];
13934 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377522"];
13935 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 377523"];
13936 [label="this.CheckUnsafeModifier(mods, diagnostics); 377524"];
13937 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377525"];
13938 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377526"];
13939 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377527"];
13940 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377528"];
13941 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377529"];
13942 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377530"];
13943 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 377531"];
13944 [label="mods |= DeclarationModifiers.Abstract; 377532"];
13945 [label="return mods; 377533"];
13946 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 377534"];
13947 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 377535"];
13948 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 377536"];
13949 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 377537"];
13950 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377538"];
13951 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377539"];
13952 [label="_declModifiers 377540"];
13953 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 377541"];
13954 [label="access == (int)DeclarationModifiers.Public 377542"];
13955 [label="MakeSpecialType() 377543"];
13956 [label="param MakeSpecialType(this) 377544"];
13957 [label="ContainingSymbol 377545"];
13958 [label="get\n            {\n                return _containingSymbol;\n            } 377546"];
13959 [label="return _containingSymbol; 377547"];
13960 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377548"];
13961 [label="ContainingSymbol.Kind 377549"];
13962 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377550"];
13963 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377551"];
13964 [label="ContainingSymbol 377552"];
13965 [label="get\n            {\n                return _containingSymbol;\n            } 377553"];
13966 [label="return _containingSymbol; 377554"];
13967 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377555"];
13968 [label="ContainingSymbol.ContainingAssembly 377556"];
13969 [label="=> _module.ContainingAssembly 377557"];
13970 [label="_module.ContainingAssembly 377558"];
13971 [label="get\n            {\n                return _assemblySymbol;\n            } 377559"];
13972 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 377560"];
13973 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 377561"];
13974 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377562"];
13975 [label="return SpecialType.None; 377563"];
13976 [label="0 377564"];
13977 [label="SpecialTypeOffset = 0 377565"];
13978 [label="6 377566"];
13979 [label="SpecialTypeSize = 6 377567"];
13980 [label="SpecialTypeOffset + SpecialTypeSize 377568"];
13981 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 377569"];
13982 [label="2 377570"];
13983 [label="ManagedKindSize = 2 377571"];
13984 [label="ManagedKindOffset + ManagedKindSize 377572"];
13985 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 377573"];
13986 [label="1 377574"];
13987 [label="FieldDefinitionsNotedSize = 1 377575"];
13988 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 377576"];
13989 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 377577"];
13990 [label="1 377578"];
13991 [label="FlattenedMembersIsSortedSize = 1 377579"];
13992 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 377580"];
13993 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 377581"];
13994 [label="4 377582"];
13995 [label="TypeKindSize = 4 377583"];
13996 [label="TypeKindOffset + TypeKindSize 377584"];
13997 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 377585"];
13998 [label="3 377586"];
13999 [label="NullableContextSize = 3 377587"];
14000 [label="1 377588"];
14001 [label="1 << SpecialTypeSize 377589"];
14002 [label="1 377590"];
14003 [label="(1 << SpecialTypeSize) - 1 377591"];
14004 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 377592"];
14005 [label="1 377593"];
14006 [label="1 << ManagedKindSize 377594"];
14007 [label="1 377595"];
14008 [label="(1 << ManagedKindSize) - 1 377596"];
14009 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 377597"];
14010 [label="1 377598"];
14011 [label="1 << TypeKindSize 377599"];
14012 [label="1 377600"];
14013 [label="(1 << TypeKindSize) - 1 377601"];
14014 [label="TypeKindMask = (1 << TypeKindSize) - 1 377602"];
14015 [label="1 377603"];
14016 [label="1 << NullableContextSize 377604"];
14017 [label="1 377605"];
14018 [label="(1 << NullableContextSize) - 1 377606"];
14019 [label="NullableContextMask = (1 << NullableContextSize) - 1 377607"];
14020 [label="1 377608"];
14021 [label="1 << FieldDefinitionsNotedOffset 377609"];
14022 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 377610"];
14023 [label="1 377611"];
14024 [label="1 << FlattenedMembersIsSortedOffset 377612"];
14025 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 377613"];
14026 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 377614"];
14027 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 377615"];
14028 [label="_flags = new Flags(specialType, typeKind); 377616"];
14029 [label="_flags = new Flags(specialType, typeKind); 377617"];
14030 [label="_flags = new Flags(specialType, typeKind); 377618"];
14031 [label="new Flags(specialType, typeKind) 377619"];
14032 [label="param Flags(SpecialType specialType) 377620"];
14033 [label="param Flags(TypeKind typeKind) 377621"];
14034 [label="param Flags(this) 377622"];
14035 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 377623"];
14036 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 377624"];
14037 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 377625"];
14038 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 377626"];
14039 [label="_flags = specialTypeInt | typeKindInt; 377627"];
14040 [label="_flags 377628"];
14041 [label="_flags 377629"];
14042 [label="this.ContainingType 377630"];
14043 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 377631"];
14044 [label="return _containingSymbol as NamedTypeSymbol; 377632"];
14045 [label="var containingType = this.ContainingType; 377633"];
14046 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 377634"];
14047 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 377635"];
14048 [label="state.NotePartComplete(CompletionPart.TypeArguments); 377636"];
14049 [label="state.NotePartComplete(CompletionPart.TypeArguments) 377637"];
14050 [label="param NotePartComplete(CompletionPart part) 377638"];
14051 [label="param NotePartComplete(this) 377639"];
14052 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 377640"];
14053 [label="_lazyCustomAttributesBag 377641"];
14054 [label="_lazyDocComment 377642"];
14055 [label="_lazyExpandedDocComment 377643"];
14056 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 377644"];
14057 [label="_lazyDeclaredBases 377645"];
14058 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 377646"];
14059 [label="_lazyEnumValueField 377647"];
14060 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 377648"];
14061 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 377649"];
14062 [label="containingSymbol.Kind 377650"];
14063 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377651"];
14064 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 377652"];
14065 [label="get\n            {\n                return declaration.Name;\n            } 377653"];
14066 [label="return declaration.Name; 377654"];
14067 [label="param BuildSymbol(this) 377655"];
14068 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 377656"];
14069 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 377657"];
14070 [label="containingSymbol 377658"];
14071 [label="tupleData 377659"];
14072 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 377660"];
14073 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 377661"];
14074 [label="tupleData 377662"];
14075 [label="_lazyTupleData 377663"];
14076 [label="_declModifiers 377664"];
14077 [label="_containingSymbol 377665"];
14078 [label="declaration 377666"];
14079 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 377667"];
14080 [label="_lazyMembersAndInitializers 377668"];
14081 [label="_lazyMembersDictionary 377669"];
14082 [label="_lazyEarlyAttributeDecodingMembersDictionary 377670"];
14083 [label="_lazyTypeMembers 377671"];
14084 [label="_lazyKnownCircularStruct 377672"];
14085 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 377673"];
14086 [label="_lazyContainsExtensionMethods 377674"];
14087 [label="_lazyAnyMemberHasAttributes 377675"];
14088 [label="_containingSymbol 377676"];
14089 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 377677"];
14090 [label="declaration.Kind.ToTypeKind() 377678"];
14091 [label="param ToTypeKind(this DeclarationKind kind) 377679"];
14092 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 377680"];
14093 [label="return TypeKind.Interface; 377681"];
14094 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377682"];
14095 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377683"];
14096 [label="param MakeModifiers(TypeKind typeKind) 377684"];
14097 [label="param MakeModifiers(DiagnosticBag diagnostics) 377685"];
14098 [label="this.ContainingSymbol 377686"];
14099 [label="get\n            {\n                return _containingSymbol;\n            } 377687"];
14100 [label="return _containingSymbol; 377688"];
14101 [label="Symbol containingSymbol = this.ContainingSymbol; 377689"];
14102 [label="DeclarationModifiers defaultAccess; 377690"];
14103 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 377691"];
14104 [label="containingSymbol.Kind 377692"];
14105 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377693"];
14106 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 377694"];
14107 [label="defaultAccess = DeclarationModifiers.Internal; 377695"];
14108 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 377696"];
14109 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe; 377697"];
14110 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe; 377698"];
14111 [label="bool modifierErrors; 377699"];
14112 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377700"];
14113 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377701"];
14114 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377702"];
14115 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377703"];
14116 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 377704"];
14117 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 377705"];
14118 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 377706"];
14119 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 377707"];
14120 [label="var result = DeclarationModifiers.Unset; 377708"];
14121 [label="var missingPartial = false; 377709"];
14122 [label="var mods = decl.Modifiers; 377710"];
14123 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 377711"];
14124 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 377712"];
14125 [label="param CheckModifiers(DeclarationModifiers modifiers) 377713"];
14126 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 377714"];
14127 [label="param CheckModifiers(Location errorLocation) 377715"];
14128 [label="param CheckModifiers(DiagnosticBag diagnostics) 377716"];
14129 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 377717"];
14130 [label="param CheckModifiers(out bool modifierErrors) 377718"];
14131 [label="modifierErrors = false; 377719"];
14132 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 377720"];
14133 [label="DeclarationModifiers result = modifiers & allowedModifiers; 377721"];
14134 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 377722"];
14135 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377723"];
14136 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377724"];
14137 [label="return result; 377725"];
14138 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 377726"];
14139 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377727"];
14140 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377728"];
14141 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377729"];
14142 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 377730"];
14143 [label="param CheckAccessibility(DeclarationModifiers modifiers) 377731"];
14144 [label="param CheckAccessibility(Symbol symbol) 377732"];
14145 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 377733"];
14146 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 377734"];
14147 [label="IsValidAccessibility(modifiers) 377735"];
14148 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 377736"];
14149 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 377737"];
14150 [label="return true; 377738"];
14151 [label="symbol.Kind 377739"];
14152 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 377740"];
14153 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377741"];
14154 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377742"];
14155 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377743"];
14156 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377744"];
14157 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377745"];
14158 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 377746"];
14159 [label="return null; 377747"];
14160 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377748"];
14161 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377749"];
14162 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377750"];
14163 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 377751"];
14164 [label="result = mods; 377752"];
14165 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377753"];
14166 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377754"];
14167 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 377755"];
14168 [label="this.Name 377756"];
14169 [label="get\n            {\n                return declaration.Name;\n            } 377757"];
14170 [label="return declaration.Name; 377758"];
14171 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377759"];
14172 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377760"];
14173 [label="return result; 377761"];
14174 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377762"];
14175 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377763"];
14176 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 377764"];
14177 [label="param CheckUnsafeModifier(this Symbol symbol) 377765"];
14178 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377766"];
14179 [label="param CheckUnsafeModifier(Location errorLocation) 377767"];
14180 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377768"];
14181 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 377769"];
14182 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377770"];
14183 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377771"];
14184 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377772"];
14185 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377773"];
14186 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377774"];
14187 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377775"];
14188 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 377776"];
14189 [label="mods |= DeclarationModifiers.Abstract; 377777"];
14190 [label="return mods; 377778"];
14191 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 377779"];
14192 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377780"];
14193 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377781"];
14194 [label="_declModifiers 377782"];
14195 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 377783"];
14196 [label="access == (int)DeclarationModifiers.Public 377784"];
14197 [label="MakeSpecialType() 377785"];
14198 [label="param MakeSpecialType(this) 377786"];
14199 [label="ContainingSymbol 377787"];
14200 [label="get\n            {\n                return _containingSymbol;\n            } 377788"];
14201 [label="return _containingSymbol; 377789"];
14202 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377790"];
14203 [label="ContainingSymbol.Kind 377791"];
14204 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377792"];
14205 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377793"];
14206 [label="ContainingSymbol 377794"];
14207 [label="get\n            {\n                return _containingSymbol;\n            } 377795"];
14208 [label="return _containingSymbol; 377796"];
14209 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377797"];
14210 [label="ContainingSymbol.ContainingAssembly 377798"];
14211 [label="=> _module.ContainingAssembly 377799"];
14212 [label="_module.ContainingAssembly 377800"];
14213 [label="get\n            {\n                return _assemblySymbol;\n            } 377801"];
14214 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 377802"];
14215 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 377803"];
14216 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377804"];
14217 [label="return SpecialType.None; 377805"];
14218 [label="_flags = new Flags(specialType, typeKind); 377806"];
14219 [label="_flags = new Flags(specialType, typeKind); 377807"];
14220 [label="_flags = new Flags(specialType, typeKind); 377808"];
14221 [label="new Flags(specialType, typeKind) 377809"];
14222 [label="param Flags(SpecialType specialType) 377810"];
14223 [label="param Flags(TypeKind typeKind) 377811"];
14224 [label="param Flags(this) 377812"];
14225 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 377813"];
14226 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 377814"];
14227 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 377815"];
14228 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 377816"];
14229 [label="_flags = specialTypeInt | typeKindInt; 377817"];
14230 [label="_flags 377818"];
14231 [label="_flags 377819"];
14232 [label="this.ContainingType 377820"];
14233 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 377821"];
14234 [label="return _containingSymbol as NamedTypeSymbol; 377822"];
14235 [label="var containingType = this.ContainingType; 377823"];
14236 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 377824"];
14237 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 377825"];
14238 [label="state.NotePartComplete(CompletionPart.TypeArguments); 377826"];
14239 [label="state.NotePartComplete(CompletionPart.TypeArguments) 377827"];
14240 [label="param NotePartComplete(CompletionPart part) 377828"];
14241 [label="_lazyCustomAttributesBag 377829"];
14242 [label="_lazyDocComment 377830"];
14243 [label="_lazyExpandedDocComment 377831"];
14244 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 377832"];
14245 [label="_lazyDeclaredBases 377833"];
14246 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 377834"];
14247 [label="_lazyEnumValueField 377835"];
14248 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 377836"];
14249 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 377837"];
14250 [label="containingSymbol.Kind 377838"];
14251 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377839"];
14252 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 377840"];
14253 [label="get\n            {\n                return declaration.Name;\n            } 377841"];
14254 [label="return declaration.Name; 377842"];
14255 [label="param BuildSymbol(this) 377843"];
14256 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 377844"];
14257 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 377845"];
14258 [label="containingSymbol 377846"];
14259 [label="tupleData 377847"];
14260 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 377848"];
14261 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 377849"];
14262 [label="tupleData 377850"];
14263 [label="_lazyTupleData 377851"];
14264 [label="_declModifiers 377852"];
14265 [label="_containingSymbol 377853"];
14266 [label="declaration 377854"];
14267 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 377855"];
14268 [label="_lazyMembersAndInitializers 377856"];
14269 [label="_lazyMembersDictionary 377857"];
14270 [label="_lazyEarlyAttributeDecodingMembersDictionary 377858"];
14271 [label="_lazyTypeMembers 377859"];
14272 [label="_lazyKnownCircularStruct 377860"];
14273 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 377861"];
14274 [label="_lazyContainsExtensionMethods 377862"];
14275 [label="_lazyAnyMemberHasAttributes 377863"];
14276 [label="_containingSymbol 377864"];
14277 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 377865"];
14278 [label="declaration.Kind.ToTypeKind() 377866"];
14279 [label="param ToTypeKind(this DeclarationKind kind) 377867"];
14280 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 377868"];
14281 [label="return TypeKind.Class; 377869"];
14282 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377870"];
14283 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 377871"];
14284 [label="param MakeModifiers(TypeKind typeKind) 377872"];
14285 [label="param MakeModifiers(DiagnosticBag diagnostics) 377873"];
14286 [label="this.ContainingSymbol 377874"];
14287 [label="get\n            {\n                return _containingSymbol;\n            } 377875"];
14288 [label="return _containingSymbol; 377876"];
14289 [label="Symbol containingSymbol = this.ContainingSymbol; 377877"];
14290 [label="DeclarationModifiers defaultAccess; 377878"];
14291 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 377879"];
14292 [label="containingSymbol.Kind 377880"];
14293 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377881"];
14294 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 377882"];
14295 [label="defaultAccess = DeclarationModifiers.Internal; 377883"];
14296 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 377884"];
14297 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 377885"];
14298 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 377886"];
14299 [label="this.IsRecord 377887"];
14300 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 377888"];
14301 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 377889"];
14302 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 377890"];
14303 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 377891"];
14304 [label="allowedModifiers |= DeclarationModifiers.Static; 377892"];
14305 [label="bool modifierErrors; 377893"];
14306 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377894"];
14307 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377895"];
14308 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377896"];
14309 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 377897"];
14310 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 377898"];
14311 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 377899"];
14312 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 377900"];
14313 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 377901"];
14314 [label="var result = DeclarationModifiers.Unset; 377902"];
14315 [label="var missingPartial = false; 377903"];
14316 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 377904"];
14317 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 377905"];
14318 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 377906"];
14319 [label="param CheckModifiers(DeclarationModifiers modifiers) 377907"];
14320 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 377908"];
14321 [label="param CheckModifiers(Location errorLocation) 377909"];
14322 [label="param CheckModifiers(DiagnosticBag diagnostics) 377910"];
14323 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 377911"];
14324 [label="param CheckModifiers(out bool modifierErrors) 377912"];
14325 [label="modifierErrors = false; 377913"];
14326 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 377914"];
14327 [label="DeclarationModifiers result = modifiers & allowedModifiers; 377915"];
14328 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 377916"];
14329 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377917"];
14330 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 377918"];
14331 [label="return result; 377919"];
14332 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 377920"];
14333 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377921"];
14334 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377922"];
14335 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377923"];
14336 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 377924"];
14337 [label="param CheckAccessibility(DeclarationModifiers modifiers) 377925"];
14338 [label="param CheckAccessibility(Symbol symbol) 377926"];
14339 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 377927"];
14340 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 377928"];
14341 [label="IsValidAccessibility(modifiers) 377929"];
14342 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 377930"];
14343 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 377931"];
14344 [label="return true; 377932"];
14345 [label="symbol.Kind 377933"];
14346 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 377934"];
14347 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377935"];
14348 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377936"];
14349 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377937"];
14350 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377938"];
14351 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 377939"];
14352 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 377940"];
14353 [label="return null; 377941"];
14354 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 377942"];
14355 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377943"];
14356 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 377944"];
14357 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 377945"];
14358 [label="result = mods; 377946"];
14359 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377947"];
14360 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 377948"];
14361 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 377949"];
14362 [label="this.Name 377950"];
14363 [label="get\n            {\n                return declaration.Name;\n            } 377951"];
14364 [label="return declaration.Name; 377952"];
14365 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377953"];
14366 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 377954"];
14367 [label="return result; 377955"];
14368 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377956"];
14369 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377957"];
14370 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 377958"];
14371 [label="param CheckUnsafeModifier(this Symbol symbol) 377959"];
14372 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 377960"];
14373 [label="param CheckUnsafeModifier(Location errorLocation) 377961"];
14374 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 377962"];
14375 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 377963"];
14376 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377964"];
14377 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377965"];
14378 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 377966"];
14379 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377967"];
14380 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377968"];
14381 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 377969"];
14382 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 377970"];
14383 [label="return mods; 377971"];
14384 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 377972"];
14385 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377973"];
14386 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 377974"];
14387 [label="_declModifiers 377975"];
14388 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 377976"];
14389 [label="access == (int)DeclarationModifiers.Public 377977"];
14390 [label="MakeSpecialType() 377978"];
14391 [label="param MakeSpecialType(this) 377979"];
14392 [label="ContainingSymbol 377980"];
14393 [label="get\n            {\n                return _containingSymbol;\n            } 377981"];
14394 [label="return _containingSymbol; 377982"];
14395 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377983"];
14396 [label="ContainingSymbol.Kind 377984"];
14397 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 377985"];
14398 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377986"];
14399 [label="ContainingSymbol 377987"];
14400 [label="get\n            {\n                return _containingSymbol;\n            } 377988"];
14401 [label="return _containingSymbol; 377989"];
14402 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377990"];
14403 [label="ContainingSymbol.ContainingAssembly 377991"];
14404 [label="=> _module.ContainingAssembly 377992"];
14405 [label="_module.ContainingAssembly 377993"];
14406 [label="get\n            {\n                return _assemblySymbol;\n            } 377994"];
14407 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 377995"];
14408 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 377996"];
14409 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 377997"];
14410 [label="return SpecialType.None; 377998"];
14411 [label="_flags = new Flags(specialType, typeKind); 377999"];
14412 [label="_flags = new Flags(specialType, typeKind); 378000"];
14413 [label="_flags = new Flags(specialType, typeKind); 378001"];
14414 [label="new Flags(specialType, typeKind) 378002"];
14415 [label="param Flags(SpecialType specialType) 378003"];
14416 [label="param Flags(TypeKind typeKind) 378004"];
14417 [label="param Flags(this) 378005"];
14418 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 378006"];
14419 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 378007"];
14420 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 378008"];
14421 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 378009"];
14422 [label="_flags = specialTypeInt | typeKindInt; 378010"];
14423 [label="_flags 378011"];
14424 [label="_flags 378012"];
14425 [label="this.ContainingType 378013"];
14426 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 378014"];
14427 [label="return _containingSymbol as NamedTypeSymbol; 378015"];
14428 [label="var containingType = this.ContainingType; 378016"];
14429 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 378017"];
14430 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 378018"];
14431 [label="state.NotePartComplete(CompletionPart.TypeArguments); 378019"];
14432 [label="state.NotePartComplete(CompletionPart.TypeArguments) 378020"];
14433 [label="param NotePartComplete(CompletionPart part) 378021"];
14434 [label="_lazyCustomAttributesBag 378022"];
14435 [label="_lazyDocComment 378023"];
14436 [label="_lazyExpandedDocComment 378024"];
14437 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 378025"];
14438 [label="_lazyDeclaredBases 378026"];
14439 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 378027"];
14440 [label="_lazyEnumValueField 378028"];
14441 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 378029"];
14442 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 378030"];
14443 [label="containingSymbol.Kind 378031"];
14444 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378032"];
14445 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 378033"];
14446 [label="get\n            {\n                return declaration.Name;\n            } 378034"];
14447 [label="return declaration.Name; 378035"];
14448 [label="param BuildSymbol(this) 378036"];
14449 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 378037"];
14450 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 378038"];
14451 [label="containingSymbol 378039"];
14452 [label="tupleData 378040"];
14453 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 378041"];
14454 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 378042"];
14455 [label="tupleData 378043"];
14456 [label="_lazyTupleData 378044"];
14457 [label="_declModifiers 378045"];
14458 [label="_containingSymbol 378046"];
14459 [label="declaration 378047"];
14460 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 378048"];
14461 [label="_lazyMembersAndInitializers 378049"];
14462 [label="_lazyMembersDictionary 378050"];
14463 [label="_lazyEarlyAttributeDecodingMembersDictionary 378051"];
14464 [label="_lazyTypeMembers 378052"];
14465 [label="_lazyKnownCircularStruct 378053"];
14466 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 378054"];
14467 [label="_lazyContainsExtensionMethods 378055"];
14468 [label="_lazyAnyMemberHasAttributes 378056"];
14469 [label="_containingSymbol 378057"];
14470 [label="param MakeModifiers(DiagnosticBag diagnostics) 378058"];
14471 [label="this.ContainingSymbol 378059"];
14472 [label="get\n            {\n                return _containingSymbol;\n            } 378060"];
14473 [label="return _containingSymbol; 378061"];
14474 [label="Symbol containingSymbol = this.ContainingSymbol; 378062"];
14475 [label="DeclarationModifiers defaultAccess; 378063"];
14476 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 378064"];
14477 [label="containingSymbol.Kind 378065"];
14478 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378066"];
14479 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 378067"];
14480 [label="defaultAccess = DeclarationModifiers.Internal; 378068"];
14481 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 378069"];
14482 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 378070"];
14483 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 378071"];
14484 [label="allowedModifiers |= DeclarationModifiers.Static; 378072"];
14485 [label="bool modifierErrors; 378073"];
14486 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 378074"];
14487 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 378075"];
14488 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 378076"];
14489 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 378077"];
14490 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 378078"];
14491 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 378079"];
14492 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 378080"];
14493 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 378081"];
14494 [label="var result = DeclarationModifiers.Unset; 378082"];
14495 [label="var missingPartial = false; 378083"];
14496 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 378084"];
14497 [label="param CheckModifiers(DiagnosticBag diagnostics) 378085"];
14498 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 378086"];
14499 [label="DeclarationModifiers result = modifiers & allowedModifiers; 378087"];
14500 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 378088"];
14501 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 378089"];
14502 [label="return result; 378090"];
14503 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 378091"];
14504 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 378092"];
14505 [label="param CheckAccessibility(DeclarationModifiers modifiers) 378093"];
14506 [label="param CheckAccessibility(Symbol symbol) 378094"];
14507 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 378095"];
14508 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 378096"];
14509 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 378097"];
14510 [label="return true; 378098"];
14511 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378099"];
14512 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 378100"];
14513 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 378101"];
14514 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 378102"];
14515 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 378103"];
14516 [label="result = mods; 378104"];
14517 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 378105"];
14518 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 378106"];
14519 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 378107"];
14520 [label="this.Name 378108"];
14521 [label="get\n            {\n                return declaration.Name;\n            } 378109"];
14522 [label="return declaration.Name; 378110"];
14523 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 378111"];
14524 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 378112"];
14525 [label="return result; 378113"];
14526 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 378114"];
14527 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 378115"];
14528 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 378116"];
14529 [label="param CheckUnsafeModifier(this Symbol symbol) 378117"];
14530 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 378118"];
14531 [label="param CheckUnsafeModifier(Location errorLocation) 378119"];
14532 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 378120"];
14533 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 378121"];
14534 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 378122"];
14535 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 378123"];
14536 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 378124"];
14537 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 378125"];
14538 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 378126"];
14539 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 378127"];
14540 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 378128"];
14541 [label="return mods; 378129"];
14542 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 378130"];
14543 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 378131"];
14544 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 378132"];
14545 [label="_declModifiers 378133"];
14546 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 378134"];
14547 [label="access == (int)DeclarationModifiers.Public 378135"];
14548 [label="MakeSpecialType() 378136"];
14549 [label="param MakeSpecialType(this) 378137"];
14550 [label="ContainingSymbol 378138"];
14551 [label="get\n            {\n                return _containingSymbol;\n            } 378139"];
14552 [label="return _containingSymbol; 378140"];
14553 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 378141"];
14554 [label="ContainingSymbol.Kind 378142"];
14555 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378143"];
14556 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 378144"];
14557 [label="ContainingSymbol 378145"];
14558 [label="get\n            {\n                return _containingSymbol;\n            } 378146"];
14559 [label="return _containingSymbol; 378147"];
14560 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 378148"];
14561 [label="ContainingSymbol.ContainingAssembly 378149"];
14562 [label="=> _module.ContainingAssembly 378150"];
14563 [label="_module.ContainingAssembly 378151"];
14564 [label="get\n            {\n                return _assemblySymbol;\n            } 378152"];
14565 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 378153"];
14566 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 378154"];
14567 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 378155"];
14568 [label="return SpecialType.None; 378156"];
14569 [label="_flags = new Flags(specialType, typeKind); 378157"];
14570 [label="_flags = new Flags(specialType, typeKind); 378158"];
14571 [label="new Flags(specialType, typeKind) 378159"];
14572 [label="param Flags(SpecialType specialType) 378160"];
14573 [label="param Flags(TypeKind typeKind) 378161"];
14574 [label="param Flags(this) 378162"];
14575 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 378163"];
14576 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 378164"];
14577 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 378165"];
14578 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 378166"];
14579 [label="_flags = specialTypeInt | typeKindInt; 378167"];
14580 [label="_flags 378168"];
14581 [label="_flags 378169"];
14582 [label="this.ContainingType 378170"];
14583 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 378171"];
14584 [label="return _containingSymbol as NamedTypeSymbol; 378172"];
14585 [label="var containingType = this.ContainingType; 378173"];
14586 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 378174"];
14587 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 378175"];
14588 [label="state.NotePartComplete(CompletionPart.TypeArguments); 378176"];
14589 [label="state.NotePartComplete(CompletionPart.TypeArguments) 378177"];
14590 [label="param NotePartComplete(CompletionPart part) 378178"];
14591 [label="_lazyCustomAttributesBag 378179"];
14592 [label="_lazyDocComment 378180"];
14593 [label="_lazyExpandedDocComment 378181"];
14594 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 378182"];
14595 [label="_lazyDeclaredBases 378183"];
14596 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 378184"];
14597 [label="_lazyEnumValueField 378185"];
14598 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 378186"];
14599 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 378187"];
14600 [label="containingSymbol.Kind 378188"];
14601 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378189"];
14602 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 378190"];
14603 [label="get\n            {\n                return declaration.Name;\n            } 378191"];
14604 [label="return declaration.Name; 378192"];
14605 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 378193"];
14606 [label="members 378194"];
14607 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378195"];
14608 [label="param CheckMembers(NamespaceSymbol @namespace) 378196"];
14609 [label="param CheckMembers(DiagnosticBag diagnostics) 378197"];
14610 [label="var memberOfArity = new Symbol[10]; 378198"];
14611 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 378199"];
14612 [label="@namespace.ContainingAssembly 378200"];
14613 [label="=> _module.ContainingAssembly 378201"];
14614 [label="_module.ContainingAssembly 378202"];
14615 [label="get\n            {\n                return _assemblySymbol;\n            } 378203"];
14616 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 378204"];
14617 [label="@namespace.ContainingAssembly.Modules 378205"];
14618 [label="get\n            {\n                return _modules;\n            } 378206"];
14619 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 378207"];
14620 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 378208"];
14621 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 378209"];
14622 [label="var nts = symbol as NamedTypeSymbol; 378210"];
14623 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 378211"];
14624 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 378212"];
14625 [label="((object)nts != null) 378213"];
14626 [label="nts.Arity 378214"];
14627 [label="get\n            {\n                return declaration.Arity;\n            } 378215"];
14628 [label="return declaration.Arity; 378216"];
14629 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 378217"];
14630 [label="var other = memberOfArity[arity]; 378218"];
14631 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378219"];
14632 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378220"];
14633 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378221"];
14634 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378222"];
14635 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 378223"];
14636 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 378224"];
14637 [label="memberOfArity[arity] 378225"];
14638 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 378226"];
14639 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 378227"];
14640 [label="nts.DeclaredAccessibility 378228"];
14641 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 378229"];
14642 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 378230"];
14643 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 378231"];
14644 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 378232"];
14645 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 378233"];
14646 [label="return Accessibility.Public; 378234"];
14647 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 378235"];
14648 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 378236"];
14649 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 378237"];
14650 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 378238"];
14651 [label="var other = memberOfArity[arity]; 378239"];
14652 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378240"];
14653 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378241"];
14654 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378242"];
14655 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 378243"];
14656 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 378244"];
14657 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 378245"];
14658 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 378246"];
14659 [label="nts.DeclaredAccessibility 378247"];
14660 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 378248"];
14661 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 378249"];
14662 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 378250"];
14663 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 378251"];
14664 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 378252"];
14665 [label="return Accessibility.Public; 378253"];
14666 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 378254"];
14667 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 378255"];
14668 [label="this.Kind 378256"];
14669 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378257"];
14670 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378258"];
14671 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 378259"];
14672 [label="RegisterDeclaredCorTypes() 378260"];
14673 [label="param RegisterDeclaredCorTypes(this) 378261"];
14674 [label="ContainingAssembly 378262"];
14675 [label="=> _module.ContainingAssembly 378263"];
14676 [label="_module.ContainingAssembly 378264"];
14677 [label="get\n            {\n                return _assemblySymbol;\n            } 378265"];
14678 [label="AssemblySymbol containingAssembly = ContainingAssembly; 378266"];
14679 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 378267"];
14680 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 378268"];
14681 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 378269"];
14682 [label="RegisterDeclaredCorTypes(); 378270"];
14683 [label="Debug.Assert(wasSetThisThread); 378271"];
14684 [label="return (_completeParts & (int)part) == (int)part; 378272"];
14685 [label="return; 378273"];
14686 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378274"];
14687 [label="param HasAtMostOneBitSet(int bits) 378275"];
14688 [label="return (bits & (bits - 1)) == 0; 378276"];
14689 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 378277"];
14690 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 378278"];
14691 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 378279"];
14692 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 378280"];
14693 [label="param ==(Symbol left) 378281"];
14694 [label="param ==(Symbol right) 378282"];
14695 [label="if (right is null)\n            {\n                return left is null;\n            } 378283"];
14696 [label="return (object)left == (object)right || right.Equals(left); 378284"];
14697 [label="return (object)left == (object)right || right.Equals(left); 378285"];
14698 [label="right.Equals(left) 378286"];
14699 [label="param Equals(object obj) 378287"];
14700 [label="param Equals(this) 378288"];
14701 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 378289"];
14702 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 378290"];
14703 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 378291"];
14704 [label="param Equals(Symbol other) 378292"];
14705 [label="param Equals(TypeCompareKind compareKind) 378293"];
14706 [label="param Equals(this) 378294"];
14707 [label="if (t2 is null)\n            {\n                return false;\n            } 378295"];
14708 [label="param Equals(TypeSymbol t2) 378296"];
14709 [label="param Equals(TypeCompareKind comparison) 378297"];
14710 [label="param Equals(this) 378298"];
14711 [label="t2 is NativeIntegerTypeSymbol 378299"];
14712 [label="return t2 is NativeIntegerTypeSymbol ?\n                ((NativeIntegerTypeSymbol)t2).Equals(this, comparison) :\n                base.Equals(t2, comparison); 378300"];
14713 [label="return t2 is NativeIntegerTypeSymbol ?\n                ((NativeIntegerTypeSymbol)t2).Equals(this, comparison) :\n                base.Equals(t2, comparison); 378301"];
14714 [label="base.Equals(t2, comparison) 378302"];
14715 [label="param Equals(TypeSymbol t2) 378303"];
14716 [label="param Equals(TypeCompareKind comparison) 378304"];
14717 [label="param Equals(this) 378305"];
14718 [label="if ((object)t2 == this) return true; 378306"];
14719 [label="if ((object)t2 == null) return false; 378307"];
14720 [label="if ((object)t2 == null) return false; 378308"];
14721 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 378309"];
14722 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 378310"];
14723 [label="NamedTypeSymbol other = t2 as NamedTypeSymbol; 378311"];
14724 [label="if ((object)other == null) return false; 378312"];
14725 [label="if ((object)other == null) return false; 378313"];
14726 [label="this.OriginalDefinition 378314"];
14727 [label="get\n            {\n                return this;\n            } 378315"];
14728 [label="var thisOriginalDefinition = this.OriginalDefinition; 378316"];
14729 [label="other.OriginalDefinition 378317"];
14730 [label="get\n            {\n                return this;\n            } 378318"];
14731 [label="var otherOriginalDefinition = other.OriginalDefinition; 378319"];
14732 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 378320"];
14733 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 378321"];
14734 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 378322"];
14735 [label="return false; 378323"];
14736 [label="param GetLexicalSortKey(this) 378324"];
14737 [label="_lazyLexicalSortKey.IsInitialized 378325"];
14738 [label="get\n            {\n                return Volatile.Read(ref _position) >= 0;\n            } 378326"];
14739 [label="return Volatile.Read(ref _position) >= 0; 378327"];
14740 [label="return Volatile.Read(ref _position) >= 0; 378328"];
14741 [label="if (!_lazyLexicalSortKey.IsInitialized)\n            {\n                _lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation));\n            } 378329"];
14742 [label="this.DeclaringCompilation 378330"];
14743 [label="this.Kind 378331"];
14744 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378332"];
14745 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378333"];
14746 [label="get\n            {\n                return _containingSymbol;\n            } 378334"];
14747 [label="return _containingSymbol; 378335"];
14748 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 378336"];
14749 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 378337"];
14750 [label="param LexicalSortKey(Location location) 378338"];
14751 [label="param LexicalSortKey(CSharpCompilation compilation) 378339"];
14752 [label="param LexicalSortKey(this) 378340"];
14753 [label="location.SourceTree 378341"];
14754 [label="location.SourceSpan.Start 378342"];
14755 [label="compilation 378343"];
14756 [label="param LexicalSortKey(this) 378344"];
14757 [label="param LexicalSortKey(SyntaxTree tree) 378345"];
14758 [label="param LexicalSortKey(int position) 378346"];
14759 [label="param LexicalSortKey(CSharpCompilation compilation) 378347"];
14760 [label="param LexicalSortKey(this) 378348"];
14761 [label="null 378349"];
14762 [label="tree == null 378350"];
14763 [label="tree 378351"];
14764 [label="compilation.GetSyntaxTreeOrdinal(tree) 378352"];
14765 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 378353"];
14766 [label="param GetSyntaxTreeOrdinal(this) 378354"];
14767 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 378355"];
14768 [label="this.ContainsSyntaxTree(tree) 378356"];
14769 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 378357"];
14770 [label="param ContainsSyntaxTree(this) 378358"];
14771 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 378359"];
14772 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 378360"];
14773 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 378361"];
14774 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 378362"];
14775 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 378363"];
14776 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 378364"];
14777 [label="position 378365"];
14778 [label="param LexicalSortKey(int treeOrdinal) 378366"];
14779 [label="param LexicalSortKey(int position) 378367"];
14780 [label="param LexicalSortKey(this) 378368"];
14781 [label="Debug.Assert(position >= 0); 378369"];
14782 [label="Debug.Assert(position >= 0); 378370"];
14783 [label="Debug.Assert(treeOrdinal >= 0); 378371"];
14784 [label="Debug.Assert(treeOrdinal >= 0); 378372"];
14785 [label="_treeOrdinal 378373"];
14786 [label="_position 378374"];
14787 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 378375"];
14788 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)) 378376"];
14789 [label="param SetFrom(LexicalSortKey other) 378377"];
14790 [label="param SetFrom(this) 378378"];
14791 [label="other.IsInitialized 378379"];
14792 [label="get\n            {\n                return Volatile.Read(ref _position) >= 0;\n            } 378380"];
14793 [label="Debug.Assert(other.IsInitialized); 378381"];
14794 [label="_treeOrdinal 378382"];
14795 [label="Volatile.Write(ref _position, other._position); 378383"];
14796 [label="Volatile.Write(ref _position, other._position); 378384"];
14797 [label="Volatile.Write(ref _position, other._position); 378385"];
14798 [label="return _lazyLexicalSortKey; 378386"];
14799 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 378387"];
14800 [label="this.Kind 378388"];
14801 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378389"];
14802 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378390"];
14803 [label="Debug.Assert(position >= 0); 378391"];
14804 [label="Debug.Assert(treeOrdinal >= 0); 378392"];
14805 [label="Debug.Assert(other.IsInitialized); 378393"];
14806 [label="this.Kind 378394"];
14807 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378395"];
14808 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378396"];
14809 [label="get\n            {\n                return _containingSymbol;\n            } 378397"];
14810 [label="param Compare(LexicalSortKey xSortKey) 378398"];
14811 [label="param Compare(LexicalSortKey ySortKey) 378399"];
14812 [label="int comparison; 378400"];
14813 [label="xSortKey.TreeOrdinal 378401"];
14814 [label="get { return _treeOrdinal; } 378402"];
14815 [label="return _treeOrdinal; 378403"];
14816 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378404"];
14817 [label="ySortKey.TreeOrdinal 378405"];
14818 [label="get { return _treeOrdinal; } 378406"];
14819 [label="return _treeOrdinal; 378407"];
14820 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378408"];
14821 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378409"];
14822 [label="xSortKey.Position 378410"];
14823 [label="get { return _position; } 378411"];
14824 [label="return _position; 378412"];
14825 [label="return xSortKey.Position - ySortKey.Position; 378413"];
14826 [label="ySortKey.Position 378414"];
14827 [label="get { return _position; } 378415"];
14828 [label="return _position; 378416"];
14829 [label="return xSortKey.Position - ySortKey.Position; 378417"];
14830 [label="return xSortKey.Position - ySortKey.Position; 378418"];
14831 [label="return _treeOrdinal; 378419"];
14832 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378420"];
14833 [label="return _treeOrdinal; 378421"];
14834 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378422"];
14835 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 378423"];
14836 [label="this.Kind 378424"];
14837 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378425"];
14838 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378426"];
14839 [label="Debug.Assert(position >= 0); 378427"];
14840 [label="Debug.Assert(treeOrdinal >= 0); 378428"];
14841 [label="Debug.Assert(other.IsInitialized); 378429"];
14842 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers); 378430"];
14843 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers); 378431"];
14844 [label="this.Kind 378432"];
14845 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 378433"];
14846 [label="return SymbolKind.Namespace; 378434"];
14847 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378435"];
14848 [label="this.ContainingModule 378436"];
14849 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 378437"];
14850 [label="member.ForceComplete(locationOpt, cancellationToken) 378438"];
14851 [label="param ForceComplete(SourceLocation? locationOpt) 378439"];
14852 [label="param ForceComplete(CancellationToken cancellationToken) 378440"];
14853 [label="param ForceComplete(this) 378441"];
14854 [label="while (true)\n            {\n                // NOTE: cases that depend on GetMembers[ByName] should call RequireCompletionPartMembers.\n                cancellationToken.ThrowIfCancellationRequested();\n                var incompletePart = state.NextIncompletePart;\n                switch (incompletePart)\n                {\n                    case CompletionPart.Attributes:\n                        GetAttributes();\n                        break;\n\n                    case CompletionPart.StartBaseType:\n                    case CompletionPart.FinishBaseType:\n                        if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.StartInterfaces:\n                    case CompletionPart.FinishInterfaces:\n                        if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.EnumUnderlyingType:\n                        var discarded = this.EnumUnderlyingType;\n                        break;\n\n                    case CompletionPart.TypeArguments:\n                        {\n                            var tmp = this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; // force type arguments\n                        }\n                        break;\n\n                    case CompletionPart.TypeParameters:\n                        // force type parameters\n                        foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        }\n\n                        state.NotePartComplete(CompletionPart.TypeParameters);\n                        break;\n\n                    case CompletionPart.Members:\n                        this.GetMembersByName();\n                        break;\n\n                    case CompletionPart.TypeMembers:\n                        this.GetTypeMembersUnordered();\n                        break;\n\n                    case CompletionPart.SynthesizedExplicitImplementations:\n                        this.GetSynthesizedExplicitImplementations(cancellationToken); //force interface and base class errors to be checked\n                        break;\n\n                    case CompletionPart.StartMemberChecks:\n                    case CompletionPart.FinishMemberChecks:\n                        if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.MembersCompleted:\n                        {\n                            ImmutableArray<Symbol> members = this.GetMembersUnordered();\n\n                            bool allCompleted = true;\n\n                            if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            }\n\n                            if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            }\n\n                            EnsureFieldDefinitionsNoted();\n\n                            // We've completed all members, so we're ready for the PointedAtManagedTypeChecks;\n                            // proceed to the next iteration.\n                            state.NotePartComplete(CompletionPart.MembersCompleted);\n                            break;\n                        }\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // This assert will trigger if we forgot to handle any of the completion parts\n                        Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0);\n                        // any other values are completion parts intended for other kinds of symbols\n                        state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll);\n                        break;\n                }\n\n                state.SpinWaitComplete(incompletePart, cancellationToken);\n            } 378442"];
14855 [label="cancellationToken.ThrowIfCancellationRequested(); 378443"];
14856 [label="state.NextIncompletePart 378444"];
14857 [label="get\n            {\n                // NOTE: It's very important to store this value in a local.\n                // If we were to inline the field access, the value of the\n                // field could change between the two accesses and the formula\n                // might not produce a result with a single 1-bit.\n                int incomplete = IncompleteParts;\n                int next = incomplete & ~(incomplete - 1);\n                Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.');\n                return (CompletionPart)next;\n            } 378445"];
14858 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378446"];
14859 [label="HasAtMostOneBitSet(next) 378447"];
14860 [label="param HasAtMostOneBitSet(int bits) 378448"];
14861 [label="return (bits & (bits - 1)) == 0; 378449"];
14862 [label="return (bits & (bits - 1)) == 0; 378450"];
14863 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378451"];
14864 [label="var incompletePart = state.NextIncompletePart; 378452"];
14865 [label="switch (incompletePart)\n                {\n                    case CompletionPart.Attributes:\n                        GetAttributes();\n                        break;\n\n                    case CompletionPart.StartBaseType:\n                    case CompletionPart.FinishBaseType:\n                        if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.StartInterfaces:\n                    case CompletionPart.FinishInterfaces:\n                        if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.EnumUnderlyingType:\n                        var discarded = this.EnumUnderlyingType;\n                        break;\n\n                    case CompletionPart.TypeArguments:\n                        {\n                            var tmp = this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; // force type arguments\n                        }\n                        break;\n\n                    case CompletionPart.TypeParameters:\n                        // force type parameters\n                        foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        }\n\n                        state.NotePartComplete(CompletionPart.TypeParameters);\n                        break;\n\n                    case CompletionPart.Members:\n                        this.GetMembersByName();\n                        break;\n\n                    case CompletionPart.TypeMembers:\n                        this.GetTypeMembersUnordered();\n                        break;\n\n                    case CompletionPart.SynthesizedExplicitImplementations:\n                        this.GetSynthesizedExplicitImplementations(cancellationToken); //force interface and base class errors to be checked\n                        break;\n\n                    case CompletionPart.StartMemberChecks:\n                    case CompletionPart.FinishMemberChecks:\n                        if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.MembersCompleted:\n                        {\n                            ImmutableArray<Symbol> members = this.GetMembersUnordered();\n\n                            bool allCompleted = true;\n\n                            if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            }\n\n                            if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            }\n\n                            EnsureFieldDefinitionsNoted();\n\n                            // We've completed all members, so we're ready for the PointedAtManagedTypeChecks;\n                            // proceed to the next iteration.\n                            state.NotePartComplete(CompletionPart.MembersCompleted);\n                            break;\n                        }\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // This assert will trigger if we forgot to handle any of the completion parts\n                        Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0);\n                        // any other values are completion parts intended for other kinds of symbols\n                        state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll);\n                        break;\n                } 378453"];
14866 [label="GetAttributes() 378454"];
14867 [label="param GetAttributes(this) 378455"];
14868 [label="this.GetAttributesBag() 378456"];
14869 [label="param GetAttributesBag(this) 378457"];
14870 [label="var bag = _lazyCustomAttributesBag; 378458"];
14871 [label="if (bag != null && bag.IsSealed)\n            {\n                return bag;\n            } 378459"];
14872 [label="if (bag != null && bag.IsSealed)\n            {\n                return bag;\n            } 378460"];
14873 [label="this.GetAttributeDeclarations() 378461"];
14874 [label="param GetAttributeDeclarations(this) 378462"];
14875 [label="return declaration.GetAttributeDeclarations(); 378463"];
14876 [label="if (LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag))\n            {\n                var completed = state.NotePartComplete(CompletionPart.Attributes);\n                Debug.Assert(completed);\n            } 378464"];
14877 [label="if (LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag))\n            {\n                var completed = state.NotePartComplete(CompletionPart.Attributes);\n                Debug.Assert(completed);\n            } 378465"];
14878 [label="LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag) 378466"];
14879 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 378467"];
14880 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 378468"];
14881 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 378469"];
14882 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 378470"];
14883 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 378471"];
14884 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 378472"];
14885 [label="param LoadAndValidateAttributes(this) 378473"];
14886 [label="this.DeclaringCompilation 378474"];
14887 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 378475"];
14888 [label="this.Kind 378476"];
14889 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378477"];
14890 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378478"];
14891 [label="return _containingSymbol; 378479"];
14892 [label="var compilation = this.DeclaringCompilation; 378480"];
14893 [label="ImmutableArray<Binder> binders; 378481"];
14894 [label="binders 378482"];
14895 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 378483"];
14896 [label="param GetAttributesToBind(AttributeLocation symbolPart) 378484"];
14897 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 378485"];
14898 [label="param GetAttributesToBind(CSharpCompilation compilation) 378486"];
14899 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 378487"];
14900 [label="param GetAttributesToBind(Binder rootBinderOpt) 378488"];
14901 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 378489"];
14902 [label="param GetAttributesToBind(this) 378490"];
14903 [label="var attributeTarget = (IAttributeTargetSymbol)this; 378491"];
14904 [label="ArrayBuilder<Binder> bindersBuilder = null; 378492"];
14905 [label="int attributesToBindCount = 0; 378493"];
14906 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 378494"];
14907 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 378495"];
14908 [label="binders = ImmutableArray<Binder>.Empty; 378496"];
14909 [label="Debug.Assert(!attributesToBind.IsDefault); 378497"];
14910 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 378498"];
14911 [label="boundAttributes 378499"];
14912 [label="WellKnownAttributeData wellKnownAttributeData; 378500"];
14913 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 378501"];
14914 [label="wellKnownAttributeData = null; 378502"];
14915 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 378503"];
14916 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 378504"];
14917 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 378505"];
14918 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 378506"];
14919 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 378507"];
14920 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 378508"];
14921 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 378509"];
14922 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 378510"];
14923 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 378511"];
14924 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 378512"];
14925 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 378513"];
14926 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 378514"];
14927 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 378515"];
14928 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 378516"];
14929 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 378517"];
14930 [label="param PostDecodeWellKnownAttributes(this) 378518"];
14931 [label="Debug.Assert(!boundAttributes.IsDefault); 378519"];
14932 [label="Debug.Assert(!allAttributeSyntaxNodes.IsDefault); 378520"];
14933 [label="Debug.Assert(boundAttributes.Length == allAttributeSyntaxNodes.Length); 378521"];
14934 [label="Debug.Assert(_lazyCustomAttributesBag != null); 378522"];
14935 [label="Debug.Assert(_lazyCustomAttributesBag != null); 378523"];
14936 [label="Debug.Assert(_lazyCustomAttributesBag.IsDecodedWellKnownAttributeDataComputed); 378524"];
14937 [label="Debug.Assert(symbolPart == AttributeLocation.None); 378525"];
14938 [label="var data = (TypeWellKnownAttributeData)decodedData; 378526"];
14939 [label="this.IsComImport 378527"];
14940 [label="get\n            {\n                CommonTypeEarlyWellKnownAttributeData data = this.GetEarlyDecodedWellKnownAttributeData();\n                return data != null && data.HasComImportAttribute;\n            } 378528"];
14941 [label="this.GetEarlyDecodedWellKnownAttributeData() 378529"];
14942 [label="param GetEarlyDecodedWellKnownAttributeData(this) 378530"];
14943 [label="var attributesBag = _lazyCustomAttributesBag; 378531"];
14944 [label="if (attributesBag == null || !attributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 378532"];
14945 [label="if (attributesBag == null || !attributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 378533"];
14946 [label="return (CommonTypeEarlyWellKnownAttributeData)attributesBag.EarlyDecodedWellKnownAttributeData; 378534"];
14947 [label="CommonTypeEarlyWellKnownAttributeData data = this.GetEarlyDecodedWellKnownAttributeData(); 378535"];
14948 [label="return data != null && data.HasComImportAttribute; 378536"];
14949 [label="return data != null && data.HasComImportAttribute; 378537"];
14950 [label="if (this.IsComImport)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with ComImportAttribute must have a GuidAttribute\n                if (data == null || data.GuidString == null)\n                {\n                    int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.ComImportAttribute);\n                    diagnostics.Add(ErrorCode.ERR_ComImportWithoutUuidAttribute, allAttributeSyntaxNodes[index].Name.Location, this.Name);\n                }\n\n                if (this.TypeKind == TypeKind.Class)\n                {\n                    var baseType = this.BaseTypeNoUseSiteDiagnostics;\n                    if ((object)baseType != null && baseType.SpecialType != SpecialType.System_Object)\n                    {\n                        // CS0424: '{0}': a class with the ComImport attribute cannot specify a base class\n                        diagnostics.Add(ErrorCode.ERR_ComImportWithBase, this.Locations[0], this.Name);\n                    }\n\n                    var initializers = this.StaticInitializers;\n                    if (!initializers.IsDefaultOrEmpty)\n                    {\n                        foreach (var initializerGroup in initializers)\n                        {\n                            foreach (var singleInitializer in initializerGroup)\n                            {\n                                if (!singleInitializer.FieldOpt.IsMetadataConstant)\n                                {\n                                    // CS8028: '{0}': a class with the ComImport attribute cannot specify field initializers.\n                                    diagnostics.Add(ErrorCode.ERR_ComImportWithInitializers, singleInitializer.Syntax.GetLocation(), this.Name);\n                                }\n                            }\n                        }\n                    }\n\n                    initializers = this.InstanceInitializers;\n                    if (!initializers.IsDefaultOrEmpty)\n                    {\n                        foreach (var initializerGroup in initializers)\n                        {\n                            foreach (var singleInitializer in initializerGroup)\n                            {\n                                // CS8028: '{0}': a class with the ComImport attribute cannot specify field initializers.\n                                diagnostics.Add(ErrorCode.ERR_ComImportWithInitializers, singleInitializer.Syntax.GetLocation(), this.Name);\n                            }\n                        }\n                    }\n                }\n            }\n            else if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 378538"];
14951 [label="this.ComImportCoClass 378539"];
14952 [label="get\n            {\n                TypeWellKnownAttributeData data = this.GetDecodedWellKnownAttributeData();\n                return data != null ? data.ComImportCoClass : null;\n            } 378540"];
14953 [label="this.GetDecodedWellKnownAttributeData() 378541"];
14954 [label="param GetDecodedWellKnownAttributeData(this) 378542"];
14955 [label="var attributesBag = _lazyCustomAttributesBag; 378543"];
14956 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 378544"];
14957 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 378545"];
14958 [label="return (TypeWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 378546"];
14959 [label="TypeWellKnownAttributeData data = this.GetDecodedWellKnownAttributeData(); 378547"];
14960 [label="return data != null ? data.ComImportCoClass : null; 378548"];
14961 [label="return data != null ? data.ComImportCoClass : null; 378549"];
14962 [label="data != null 378550"];
14963 [label="if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 378551"];
14964 [label="if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 378552"];
14965 [label="if (data != null && data.HasDefaultMemberAttribute && this.Indexers.Any())\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.DefaultMemberAttribute);\n                diagnostics.Add(ErrorCode.ERR_DefaultMemberOnIndexedType, allAttributeSyntaxNodes[index].Name.Location);\n            } 378553"];
14966 [label="if (data != null && data.HasDefaultMemberAttribute && this.Indexers.Any())\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.DefaultMemberAttribute);\n                diagnostics.Add(ErrorCode.ERR_DefaultMemberOnIndexedType, allAttributeSyntaxNodes[index].Name.Location);\n            } 378554"];
14967 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378555"];
14968 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378556"];
14969 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378557"];
14970 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378558"];
14971 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378559"];
14972 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData) 378560"];
14973 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 378561"];
14974 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 378562"];
14975 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 378563"];
14976 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 378564"];
14977 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 378565"];
14978 [label="param PostDecodeWellKnownAttributes(this) 378566"];
14979 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 378567"];
14980 [label="bool lazyAttributesStoredOnThisThread = false; 378568"];
14981 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378569"];
14982 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 378570"];
14983 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 378571"];
14984 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 378572"];
14985 [label="param RecordPresenceOfBadAttributes(this) 378573"];
14986 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 378574"];
14987 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 378575"];
14988 [label="AddDeclarationDiagnostics(diagnostics); 378576"];
14989 [label="AddDeclarationDiagnostics(diagnostics) 378577"];
14990 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378578"];
14991 [label="param AddDeclarationDiagnostics(this) 378579"];
14992 [label="ContainingSymbol 378580"];
14993 [label="get\n            {\n                return _containingSymbol;\n            } 378581"];
14994 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378582"];
14995 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378583"];
14996 [label="AddDeclarationDiagnostics(diagnostics); 378584"];
14997 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 378585"];
14998 [label="diagnostics.Free(); 378586"];
14999 [label="var completed = state.NotePartComplete(CompletionPart.Attributes); 378587"];
15000 [label="state.NotePartComplete(CompletionPart.Attributes) 378588"];
15001 [label="param NotePartComplete(CompletionPart part) 378589"];
15002 [label="Debug.Assert(completed); 378590"];
15003 [label="Debug.Assert(_lazyCustomAttributesBag.IsSealed); 378591"];
15004 [label="return _lazyCustomAttributesBag; 378592"];
15005 [label="return this.GetAttributesBag().Attributes; 378593"];
15006 [label="GetAttributes(); 378594"];
15007 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378595"];
15008 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378596"];
15009 [label="state.SpinWaitComplete(incompletePart, cancellationToken) 378597"];
15010 [label="param SpinWaitComplete(CompletionPart part) 378598"];
15011 [label="param SpinWaitComplete(CancellationToken cancellationToken) 378599"];
15012 [label="param SpinWaitComplete(this) 378600"];
15013 [label="if (HasComplete(part))\n            {\n                return;\n            } 378601"];
15014 [label="HasComplete(part) 378602"];
15015 [label="param HasComplete(CompletionPart part) 378603"];
15016 [label="param HasComplete(this) 378604"];
15017 [label="return (_completeParts & (int)part) == (int)part; 378605"];
15018 [label="return; 378606"];
15019 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378607"];
15020 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378608"];
15021 [label="param HasAtMostOneBitSet(int bits) 378609"];
15022 [label="return (bits & (bits - 1)) == 0; 378610"];
15023 [label="Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0); 378611"];
15024 [label="Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0); 378612"];
15025 [label="state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll); 378613"];
15026 [label="state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll) 378614"];
15027 [label="param NotePartComplete(CompletionPart part) 378615"];
15028 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378616"];
15029 [label="param SpinWaitComplete(CompletionPart part) 378617"];
15030 [label="param SpinWaitComplete(this) 378618"];
15031 [label="if (HasComplete(part))\n            {\n                return;\n            } 378619"];
15032 [label="param HasComplete(CompletionPart part) 378620"];
15033 [label="param HasComplete(this) 378621"];
15034 [label="return (_completeParts & (int)part) == (int)part; 378622"];
15035 [label="return; 378623"];
15036 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378624"];
15037 [label="param HasAtMostOneBitSet(int bits) 378625"];
15038 [label="return (bits & (bits - 1)) == 0; 378626"];
15039 [label="if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        } 378627"];
15040 [label="state.NotePartComplete(CompletionPart.StartBaseType) 378628"];
15041 [label="param NotePartComplete(CompletionPart part) 378629"];
15042 [label="var diagnostics = DiagnosticBag.GetInstance(); 378630"];
15043 [label="CheckBase(diagnostics); 378631"];
15044 [label="CheckBase(diagnostics) 378632"];
15045 [label="param CheckBase(DiagnosticBag diagnostics) 378633"];
15046 [label="param CheckBase(this) 378634"];
15047 [label="this.BaseTypeNoUseSiteDiagnostics 378635"];
15048 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 378636"];
15049 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 378637"];
15050 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 378638"];
15051 [label="ContainingType 378639"];
15052 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 378640"];
15053 [label="return _containingSymbol as NamedTypeSymbol; 378641"];
15054 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 378642"];
15055 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 378643"];
15056 [label="var diagnostics = DiagnosticBag.GetInstance(); 378644"];
15057 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 378645"];
15058 [label="this.MakeAcyclicBaseType(diagnostics) 378646"];
15059 [label="param MakeAcyclicBaseType(DiagnosticBag diagnostics) 378647"];
15060 [label="param MakeAcyclicBaseType(this) 378648"];
15061 [label="this.TypeKind 378649"];
15062 [label="get\n            {\n                return _flags.TypeKind;\n            } 378650"];
15063 [label="_flags.TypeKind 378651"];
15064 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 378652"];
15065 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 378653"];
15066 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 378654"];
15067 [label="return _flags.TypeKind; 378655"];
15068 [label="var typeKind = this.TypeKind; 378656"];
15069 [label="this.DeclaringCompilation 378657"];
15070 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 378658"];
15071 [label="this.Kind 378659"];
15072 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378660"];
15073 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378661"];
15074 [label="var compilation = this.DeclaringCompilation; 378662"];
15075 [label="NamedTypeSymbol declaredBase; 378663"];
15076 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert((object)GetDeclaredBaseType(basesBeingResolved: null) == null, 'Computation skipped for enums');\n                declaredBase = compilation.GetSpecialType(SpecialType.System_Enum);\n            }\n            else\n            {\n                declaredBase = GetDeclaredBaseType(basesBeingResolved: null);\n            } 378664"];
15077 [label="declaredBase = GetDeclaredBaseType(basesBeingResolved: null); 378665"];
15078 [label="GetDeclaredBaseType(basesBeingResolved: null) 378666"];
15079 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 378667"];
15080 [label="param GetDeclaredBaseType(this) 378668"];
15081 [label="return GetDeclaredBases(basesBeingResolved).Item1; 378669"];
15082 [label="GetDeclaredBases(basesBeingResolved) 378670"];
15083 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 378671"];
15084 [label="param GetDeclaredBases(this) 378672"];
15085 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 378673"];
15086 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 378674"];
15087 [label="var diagnostics = DiagnosticBag.GetInstance(); 378675"];
15088 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378676"];
15089 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378677"];
15090 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378678"];
15091 [label="MakeDeclaredBases(basesBeingResolved, diagnostics) 378679"];
15092 [label="param MakeDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 378680"];
15093 [label="param MakeDeclaredBases(DiagnosticBag diagnostics) 378681"];
15094 [label="param MakeDeclaredBases(this) 378682"];
15095 [label="this.TypeKind 378683"];
15096 [label="get\n            {\n                return _flags.TypeKind;\n            } 378684"];
15097 [label="if (this.TypeKind == TypeKind.Enum)\n            {\n                // Handled by GetEnumUnderlyingType().\n                return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(null, ImmutableArray<NamedTypeSymbol>.Empty);\n            } 378685"];
15098 [label="var reportedPartialConflict = false; 378686"];
15099 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 378687"];
15100 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 378688"];
15101 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 378689"];
15102 [label="this.OriginalDefinition 378690"];
15103 [label="get\n            {\n                return this;\n            } 378691"];
15104 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 378692"];
15105 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 378693"];
15106 [label="var baseInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 378694"];
15107 [label="NamedTypeSymbol baseType = null; 378695"];
15108 [label="SourceLocation baseTypeLocation = null; 378696"];
15109 [label="SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>() 378697"];
15110 [label="var instance = PooledSymbolDictionary<KSymbol, V>.s_poolInstance.Allocate(); 378698"];
15111 [label="Debug.Assert(instance.Count == 0); 378699"];
15112 [label="Debug.Assert(instance.Count == 0); 378700"];
15113 [label="return instance; 378701"];
15114 [label="var interfaceLocations = SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>(); 378702"];
15115 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics);\n                if ((object)one == null) continue;\n\n                var partBase = one.Item1;\n                var partInterfaces = one.Item2;\n                if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                }\n\n                foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                }\n            } 378703"];
15116 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 378704"];
15117 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 378705"];
15118 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 378706"];
15119 [label="MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics) 378707"];
15120 [label="param MakeOneDeclaredBases(ConsList<TypeSymbol> newBasesBeingResolved) 378708"];
15121 [label="param MakeOneDeclaredBases(SingleTypeDeclaration decl) 378709"];
15122 [label="param MakeOneDeclaredBases(DiagnosticBag diagnostics) 378710"];
15123 [label="param MakeOneDeclaredBases(this) 378711"];
15124 [label="BaseListSyntax bases = GetBaseListOpt(decl); 378712"];
15125 [label="GetBaseListOpt(decl) 378713"];
15126 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 378714"];
15127 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 378715"];
15128 [label="return null; 378716"];
15129 [label="BaseListSyntax bases = GetBaseListOpt(decl); 378717"];
15130 [label="if (bases == null)\n            {\n                return null;\n            } 378718"];
15131 [label="if (bases == null)\n            {\n                return null;\n            } 378719"];
15132 [label="return null; 378720"];
15133 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 378721"];
15134 [label="if ((object)one == null) continue; 378722"];
15135 [label="if ((object)one == null) continue; 378723"];
15136 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 378724"];
15137 [label="if (declaration.Kind == DeclarationKind.Record)\n            {\n                var type = DeclaringCompilation.GetWellKnownType(WellKnownType.System_IEquatable_T).Construct(this);\n                if (baseInterfaces.IndexOf(type, SymbolEqualityComparer.AllIgnoreOptions) < 0)\n                {\n                    baseInterfaces.Add(type);\n                    type.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                }\n            } 378725"];
15138 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 378726"];
15139 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 378727"];
15140 [label="var baseInterfacesRO = baseInterfaces.ToImmutableAndFree(); 378728"];
15141 [label="DeclaredAccessibility 378729"];
15142 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 378730"];
15143 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 378731"];
15144 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 378732"];
15145 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 378733"];
15146 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 378734"];
15147 [label="return Accessibility.Public; 378735"];
15148 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 378736"];
15149 [label="IsInterface 378737"];
15150 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 378738"];
15151 [label="this.TypeKind 378739"];
15152 [label="get\n            {\n                return _flags.TypeKind;\n            } 378740"];
15153 [label="return this.TypeKind == TypeKind.Interface; 378741"];
15154 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 378742"];
15155 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 378743"];
15156 [label="foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                } 378744"];
15157 [label="interfaceLocations.Free(); 378745"];
15158 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 378746"];
15159 [label="Locations 378747"];
15160 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 378748"];
15161 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 378749"];
15162 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 378750"];
15163 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 378751"];
15164 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 378752"];
15165 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 378753"];
15166 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 378754"];
15167 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378755"];
15168 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378756"];
15169 [label="AddDeclarationDiagnostics(diagnostics); 378757"];
15170 [label="AddDeclarationDiagnostics(diagnostics) 378758"];
15171 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378759"];
15172 [label="param AddDeclarationDiagnostics(this) 378760"];
15173 [label="ContainingSymbol 378761"];
15174 [label="get\n            {\n                return _containingSymbol;\n            } 378762"];
15175 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378763"];
15176 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378764"];
15177 [label="AddDeclarationDiagnostics(diagnostics); 378765"];
15178 [label="diagnostics.Free(); 378766"];
15179 [label="return _lazyDeclaredBases; 378767"];
15180 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 378768"];
15181 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 378769"];
15182 [label="switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                } 378770"];
15183 [label="return null; 378771"];
15184 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 378772"];
15185 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378773"];
15186 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378774"];
15187 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378775"];
15188 [label="AddDeclarationDiagnostics(diagnostics); 378776"];
15189 [label="AddDeclarationDiagnostics(diagnostics) 378777"];
15190 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378778"];
15191 [label="param AddDeclarationDiagnostics(this) 378779"];
15192 [label="ContainingSymbol 378780"];
15193 [label="get\n            {\n                return _containingSymbol;\n            } 378781"];
15194 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378782"];
15195 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378783"];
15196 [label="AddDeclarationDiagnostics(diagnostics); 378784"];
15197 [label="diagnostics.Free(); 378785"];
15198 [label="return _lazyBaseType; 378786"];
15199 [label="var localBase = this.BaseTypeNoUseSiteDiagnostics; 378787"];
15200 [label="if ((object)localBase == null)\n            {\n                // nothing to verify\n                return;\n            } 378788"];
15201 [label="if ((object)localBase == null)\n            {\n                // nothing to verify\n                return;\n            } 378789"];
15202 [label="return; 378790"];
15203 [label="CheckBase(diagnostics); 378791"];
15204 [label="AddDeclarationDiagnostics(diagnostics); 378792"];
15205 [label="AddDeclarationDiagnostics(diagnostics) 378793"];
15206 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378794"];
15207 [label="param AddDeclarationDiagnostics(this) 378795"];
15208 [label="ContainingSymbol 378796"];
15209 [label="get\n            {\n                return _containingSymbol;\n            } 378797"];
15210 [label="return _containingSymbol; 378798"];
15211 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378799"];
15212 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378800"];
15213 [label="AddDeclarationDiagnostics(diagnostics); 378801"];
15214 [label="state.NotePartComplete(CompletionPart.FinishBaseType); 378802"];
15215 [label="state.NotePartComplete(CompletionPart.FinishBaseType) 378803"];
15216 [label="param NotePartComplete(CompletionPart part) 378804"];
15217 [label="param NotePartComplete(this) 378805"];
15218 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 378806"];
15219 [label="diagnostics.Free(); 378807"];
15220 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378808"];
15221 [label="param SpinWaitComplete(CompletionPart part) 378809"];
15222 [label="param SpinWaitComplete(this) 378810"];
15223 [label="if (HasComplete(part))\n            {\n                return;\n            } 378811"];
15224 [label="param HasComplete(CompletionPart part) 378812"];
15225 [label="param HasComplete(this) 378813"];
15226 [label="return (_completeParts & (int)part) == (int)part; 378814"];
15227 [label="return; 378815"];
15228 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378816"];
15229 [label="param HasAtMostOneBitSet(int bits) 378817"];
15230 [label="return (bits & (bits - 1)) == 0; 378818"];
15231 [label="if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        } 378819"];
15232 [label="state.NotePartComplete(CompletionPart.StartInterfaces) 378820"];
15233 [label="param NotePartComplete(CompletionPart part) 378821"];
15234 [label="var diagnostics = DiagnosticBag.GetInstance(); 378822"];
15235 [label="CheckInterfaces(diagnostics); 378823"];
15236 [label="CheckInterfaces(diagnostics) 378824"];
15237 [label="param CheckInterfaces(DiagnosticBag diagnostics) 378825"];
15238 [label="param CheckInterfaces(this) 378826"];
15239 [label="this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics 378827"];
15240 [label="get\n            {\n                var info = this.GetInterfaceInfo();\n                if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                }\n\n                if (info.interfacesAndTheirBaseInterfaces == null)\n                {\n                    Interlocked.CompareExchange(ref info.interfacesAndTheirBaseInterfaces, MakeInterfacesAndTheirBaseInterfaces(this.InterfacesNoUseSiteDiagnostics()), null);\n                }\n\n                return info.interfacesAndTheirBaseInterfaces;\n            } 378828"];
15241 [label="this.GetInterfaceInfo() 378829"];
15242 [label="param GetInterfaceInfo(this) 378830"];
15243 [label="var info = _lazyInterfaceInfo; 378831"];
15244 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 378832"];
15245 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 378833"];
15246 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 378834"];
15247 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 378835"];
15248 [label="baseType.TypeKind 378836"];
15249 [label="var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); 378837"];
15250 [label="(baseType.TypeKind == TypeKind.TypeParameter) 378838"];
15251 [label="baseType.InterfacesNoUseSiteDiagnostics() 378839"];
15252 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 378840"];
15253 [label="param InterfacesNoUseSiteDiagnostics(this) 378841"];
15254 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 378842"];
15255 [label="if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                } 378843"];
15256 [label="if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                } 378844"];
15257 [label="var diagnostics = DiagnosticBag.GetInstance(); 378845"];
15258 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 378846"];
15259 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 378847"];
15260 [label="MakeAcyclicInterfaces(basesBeingResolved, diagnostics) 378848"];
15261 [label="param MakeAcyclicInterfaces(ConsList<TypeSymbol> basesBeingResolved) 378849"];
15262 [label="param MakeAcyclicInterfaces(DiagnosticBag diagnostics) 378850"];
15263 [label="param MakeAcyclicInterfaces(this) 378851"];
15264 [label="this.TypeKind 378852"];
15265 [label="get\n            {\n                return _flags.TypeKind;\n            } 378853"];
15266 [label="var typeKind = this.TypeKind; 378854"];
15267 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert(GetDeclaredInterfaces(basesBeingResolved: null).IsEmpty, 'Computation skipped for enums');\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 378855"];
15268 [label="var declaredInterfaces = GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved); 378856"];
15269 [label="GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved) 378857"];
15270 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 378858"];
15271 [label="param GetDeclaredInterfaces(this) 378859"];
15272 [label="return GetDeclaredBases(basesBeingResolved).Item2; 378860"];
15273 [label="GetDeclaredBases(basesBeingResolved) 378861"];
15274 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 378862"];
15275 [label="param GetDeclaredBases(this) 378863"];
15276 [label="return GetDeclaredBases(basesBeingResolved).Item2; 378864"];
15277 [label="var declaredInterfaces = GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved); 378865"];
15278 [label="bool isInterface = (typeKind == TypeKind.Interface); 378866"];
15279 [label="isInterface 378867"];
15280 [label="ArrayBuilder<NamedTypeSymbol> result = isInterface ? ArrayBuilder<NamedTypeSymbol>.GetInstance() : null; 378868"];
15281 [label="foreach (var t in declaredInterfaces)\n            {\n                if (isInterface)\n                {\n                    if (BaseTypeAnalysis.TypeDependsOn(depends: t, on: this))\n                    {\n                        result.Add(new ExtendedErrorTypeSymbol(t, LookupResultKind.NotReferencable,\n                            diagnostics.Add(ErrorCode.ERR_CycleInInterfaceInheritance, Locations[0], this, t)));\n                        continue;\n                    }\n                    else\n                    {\n                        result.Add(t);\n                    }\n                }\n\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                if (t.DeclaringCompilation != this.DeclaringCompilation)\n                {\n                    t.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n\n                    foreach (var @interface in t.AllInterfacesNoUseSiteDiagnostics)\n                    {\n                        if (@interface.DeclaringCompilation != this.DeclaringCompilation)\n                        {\n                            @interface.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                        }\n                    }\n                }\n\n                if (!useSiteDiagnostics.IsNullOrEmpty())\n                {\n                    diagnostics.Add(Locations[0], useSiteDiagnostics);\n                }\n            } 378869"];
15282 [label="isInterface 378870"];
15283 [label="return isInterface ? result.ToImmutableAndFree() : declaredInterfaces; 378871"];
15284 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 378872"];
15285 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378873"];
15286 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378874"];
15287 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 378875"];
15288 [label="AddDeclarationDiagnostics(diagnostics); 378876"];
15289 [label="AddDeclarationDiagnostics(diagnostics) 378877"];
15290 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378878"];
15291 [label="param AddDeclarationDiagnostics(this) 378879"];
15292 [label="ContainingSymbol 378880"];
15293 [label="get\n            {\n                return _containingSymbol;\n            } 378881"];
15294 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378882"];
15295 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378883"];
15296 [label="AddDeclarationDiagnostics(diagnostics); 378884"];
15297 [label="diagnostics.Free(); 378885"];
15298 [label="return _lazyInterfaces; 378886"];
15299 [label="if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                } 378887"];
15300 [label="baseType.BaseTypeNoUseSiteDiagnostics 378888"];
15301 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 378889"];
15302 [label="return _lazyBaseType; 378890"];
15303 [label="_lazyInterfaceInfo = info = s_noInterfaces; 378891"];
15304 [label="_lazyInterfaceInfo 378892"];
15305 [label="return info; 378893"];
15306 [label="var info = this.GetInterfaceInfo(); 378894"];
15307 [label="if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                } 378895"];
15308 [label="Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty); 378896"];
15309 [label="return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces; 378897"];
15310 [label="var interfaces = this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics; 378898"];
15311 [label="if (interfaces.IsEmpty)\n            {\n                // nothing to verify\n                return;\n            } 378899"];
15312 [label="return; 378900"];
15313 [label="CheckInterfaces(diagnostics); 378901"];
15314 [label="AddDeclarationDiagnostics(diagnostics); 378902"];
15315 [label="AddDeclarationDiagnostics(diagnostics) 378903"];
15316 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378904"];
15317 [label="param AddDeclarationDiagnostics(this) 378905"];
15318 [label="ContainingSymbol 378906"];
15319 [label="get\n            {\n                return _containingSymbol;\n            } 378907"];
15320 [label="return _containingSymbol; 378908"];
15321 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378909"];
15322 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378910"];
15323 [label="AddDeclarationDiagnostics(diagnostics); 378911"];
15324 [label="state.NotePartComplete(CompletionPart.FinishInterfaces); 378912"];
15325 [label="state.NotePartComplete(CompletionPart.FinishInterfaces) 378913"];
15326 [label="param NotePartComplete(CompletionPart part) 378914"];
15327 [label="param NotePartComplete(this) 378915"];
15328 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 378916"];
15329 [label="diagnostics.Free(); 378917"];
15330 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378918"];
15331 [label="param SpinWaitComplete(CompletionPart part) 378919"];
15332 [label="param SpinWaitComplete(this) 378920"];
15333 [label="if (HasComplete(part))\n            {\n                return;\n            } 378921"];
15334 [label="param HasComplete(CompletionPart part) 378922"];
15335 [label="param HasComplete(this) 378923"];
15336 [label="return (_completeParts & (int)part) == (int)part; 378924"];
15337 [label="return; 378925"];
15338 [label="cancellationToken.ThrowIfCancellationRequested(); 378926"];
15339 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378927"];
15340 [label="param HasAtMostOneBitSet(int bits) 378928"];
15341 [label="return (bits & (bits - 1)) == 0; 378929"];
15342 [label="this.EnumUnderlyingType 378930"];
15343 [label="get\n            {\n                if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyEnumUnderlyingType;\n            } 378931"];
15344 [label="if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                } 378932"];
15345 [label="if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                } 378933"];
15346 [label="DiagnosticBag diagnostics = DiagnosticBag.GetInstance(); 378934"];
15347 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 378935"];
15348 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 378936"];
15349 [label="this.GetEnumUnderlyingType(diagnostics) 378937"];
15350 [label="param GetEnumUnderlyingType(DiagnosticBag diagnostics) 378938"];
15351 [label="param GetEnumUnderlyingType(this) 378939"];
15352 [label="this.TypeKind 378940"];
15353 [label="get\n            {\n                return _flags.TypeKind;\n            } 378941"];
15354 [label="if (this.TypeKind != TypeKind.Enum)\n            {\n                return null;\n            } 378942"];
15355 [label="return null; 378943"];
15356 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 378944"];
15357 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 378945"];
15358 [label="AddDeclarationDiagnostics(diagnostics); 378946"];
15359 [label="AddDeclarationDiagnostics(diagnostics) 378947"];
15360 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 378948"];
15361 [label="param AddDeclarationDiagnostics(this) 378949"];
15362 [label="ContainingSymbol 378950"];
15363 [label="get\n            {\n                return _containingSymbol;\n            } 378951"];
15364 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 378952"];
15365 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 378953"];
15366 [label="AddDeclarationDiagnostics(diagnostics); 378954"];
15367 [label="this.state.NotePartComplete(CompletionPart.EnumUnderlyingType); 378955"];
15368 [label="this.state.NotePartComplete(CompletionPart.EnumUnderlyingType) 378956"];
15369 [label="param NotePartComplete(CompletionPart part) 378957"];
15370 [label="diagnostics.Free(); 378958"];
15371 [label="return _lazyEnumUnderlyingType; 378959"];
15372 [label="var discarded = this.EnumUnderlyingType; 378960"];
15373 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 378961"];
15374 [label="param SpinWaitComplete(CompletionPart part) 378962"];
15375 [label="param SpinWaitComplete(this) 378963"];
15376 [label="if (HasComplete(part))\n            {\n                return;\n            } 378964"];
15377 [label="param HasComplete(CompletionPart part) 378965"];
15378 [label="param HasComplete(this) 378966"];
15379 [label="return (_completeParts & (int)part) == (int)part; 378967"];
15380 [label="return; 378968"];
15381 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 378969"];
15382 [label="param HasAtMostOneBitSet(int bits) 378970"];
15383 [label="return (bits & (bits - 1)) == 0; 378971"];
15384 [label="this.TypeParameters 378972"];
15385 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 378973"];
15386 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 378974"];
15387 [label="var diagnostics = DiagnosticBag.GetInstance(); 378975"];
15388 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378976"];
15389 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378977"];
15390 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 378978"];
15391 [label="get\n            {\n                return this.declaration.SyntaxReferences;\n            } 378979"];
15392 [label="return this.declaration.SyntaxReferences; 378980"];
15393 [label="this.Kind 378981"];
15394 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 378982"];
15395 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 378983"];
15396 [label="param ReportTypeNamedRecord(string? name) 378984"];
15397 [label="param ReportTypeNamedRecord(CSharpCompilation compilation) 378985"];
15398 [label="param ReportTypeNamedRecord(DiagnosticBag diagnostics) 378986"];
15399 [label="param ReportTypeNamedRecord(Location location) 378987"];
15400 [label="if (name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword) &&\n                compilation.LanguageVersion >= MessageID.IDS_FeatureRecords.RequiredVersion())\n            {\n                diagnostics.Add(ErrorCode.WRN_RecordNamedDisallowed, location, name);\n            } 378988"];
15401 [label="if (name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword) &&\n                compilation.LanguageVersion >= MessageID.IDS_FeatureRecords.RequiredVersion())\n            {\n                diagnostics.Add(ErrorCode.WRN_RecordNamedDisallowed, location, name);\n            } 378989"];
15402 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 378990"];
15403 [label="return _containingSymbol as NamedTypeSymbol; 378991"];
15404 [label="param TypeParameterBuilder(SyntaxReference syntaxRef) 378992"];
15405 [label="param TypeParameterBuilder(SourceNamedTypeSymbol owner) 378993"];
15406 [label="param TypeParameterBuilder(Location location) 378994"];
15407 [label="param TypeParameterBuilder(this) 378995"];
15408 [label="_syntaxRef 378996"];
15409 [label="_owner 378997"];
15410 [label="_location 378998"];
15411 [label="_syntaxRef 378999"];
15412 [label="Debug.Assert(syntaxRef.GetSyntax().IsKind(SyntaxKind.TypeParameter)); 379000"];
15413 [label="Debug.Assert(syntaxRef.GetSyntax().IsKind(SyntaxKind.TypeParameter)); 379001"];
15414 [label="Debug.Assert(syntaxRef.GetSyntax().IsKind(SyntaxKind.TypeParameter)); 379002"];
15415 [label="_owner 379003"];
15416 [label="_location 379004"];
15417 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 379005"];
15418 [label="param MakeSymbol(int ordinal) 379006"];
15419 [label="param MakeSymbol(IList<TypeParameterBuilder> builders) 379007"];
15420 [label="param MakeSymbol(DiagnosticBag diagnostics) 379008"];
15421 [label="param MakeSymbol(this) 379009"];
15422 [label="var syntaxNode = (TypeParameterSyntax)_syntaxRef.GetSyntax(); 379010"];
15423 [label="var syntaxNode = (TypeParameterSyntax)_syntaxRef.GetSyntax(); 379011"];
15424 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379012"];
15425 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379013"];
15426 [label="syntaxNode.Identifier 379014"];
15427 [label="param ToLocations(IList<TypeParameterBuilder> builders) 379015"];
15428 [label="var arrayBuilder = ArrayBuilder<Location>.GetInstance(builders.Count); 379016"];
15429 [label="foreach (var builder in builders)\n            {\n                arrayBuilder.Add(builder._location);\n            } 379017"];
15430 [label="arrayBuilder.Add(builder._location); 379018"];
15431 [label="arrayBuilder.Add(builder._location); 379019"];
15432 [label="return arrayBuilder.ToImmutableAndFree(); 379020"];
15433 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379021"];
15434 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379022"];
15435 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379023"];
15436 [label="ToSyntaxRefs(builders) 379024"];
15437 [label="param ToSyntaxRefs(IList<TypeParameterBuilder> builders) 379025"];
15438 [label="var arrayBuilder = ArrayBuilder<SyntaxReference>.GetInstance(builders.Count); 379026"];
15439 [label="foreach (var builder in builders)\n            {\n                arrayBuilder.Add(builder._syntaxRef);\n            } 379027"];
15440 [label="foreach (var builder in builders)\n            {\n                arrayBuilder.Add(builder._syntaxRef);\n            } 379028"];
15441 [label="arrayBuilder.Add(builder._syntaxRef); 379029"];
15442 [label="arrayBuilder.Add(builder._syntaxRef); 379030"];
15443 [label="return arrayBuilder.ToImmutableAndFree(); 379031"];
15444 [label="var result = new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)); 379032"];
15445 [label="new SourceTypeParameterSymbol(\n                _owner,\n                syntaxNode.Identifier.ValueText,\n                ordinal,\n                syntaxNode.VarianceKeyword.VarianceKindFromToken(),\n                ToLocations(builders),\n                ToSyntaxRefs(builders)) 379033"];
15446 [label="param SourceTypeParameterSymbol(SourceNamedTypeSymbol owner) 379034"];
15447 [label="param SourceTypeParameterSymbol(string name) 379035"];
15448 [label="param SourceTypeParameterSymbol(int ordinal) 379036"];
15449 [label="param SourceTypeParameterSymbol(VarianceKind varianceKind) 379037"];
15450 [label="param SourceTypeParameterSymbol(ImmutableArray<Location> locations) 379038"];
15451 [label="param SourceTypeParameterSymbol(ImmutableArray<SyntaxReference> syntaxRefs) 379039"];
15452 [label="param SourceTypeParameterSymbol(this) 379040"];
15453 [label="name 379041"];
15454 [label="ordinal 379042"];
15455 [label="locations 379043"];
15456 [label="syntaxRefs 379044"];
15457 [label="param SourceTypeParameterSymbol(this) 379045"];
15458 [label="param SourceTypeParameterSymbolBase(string name) 379046"];
15459 [label="param SourceTypeParameterSymbolBase(int ordinal) 379047"];
15460 [label="param SourceTypeParameterSymbolBase(ImmutableArray<Location> locations) 379048"];
15461 [label="param SourceTypeParameterSymbolBase(ImmutableArray<SyntaxReference> syntaxRefs) 379049"];
15462 [label="param SourceTypeParameterSymbolBase(this) 379050"];
15463 [label="param SourceTypeParameterSymbolBase(this) 379051"];
15464 [label="param TypeParameterSymbol(this) 379052"];
15465 [label="param TypeParameterSymbol(this) 379053"];
15466 [label="_lazyAdapter 379054"];
15467 [label="_name 379055"];
15468 [label="_ordinal 379056"];
15469 [label="_lazyCustomAttributesBag 379057"];
15470 [label="new TypeParameterBounds() 379058"];
15471 [label="param TypeParameterBounds(this) 379059"];
15472 [label="EffectiveBaseClass 379060"];
15473 [label="DeducedBaseType 379061"];
15474 [label="EffectiveBaseClass = null!; 379062"];
15475 [label="EffectiveBaseClass 379063"];
15476 [label="DeducedBaseType = null!; 379064"];
15477 [label="DeducedBaseType 379065"];
15478 [label="Unset = new TypeParameterBounds() 379066"];
15479 [label="_lazyBounds = TypeParameterBounds.Unset 379067"];
15480 [label="Debug.Assert(!syntaxRefs.IsEmpty); 379068"];
15481 [label="_name 379069"];
15482 [label="_ordinal 379070"];
15483 [label="_locations 379071"];
15484 [label="_syntaxRefs 379072"];
15485 [label="_owner 379073"];
15486 [label="_varianceKind 379074"];
15487 [label="_owner 379075"];
15488 [label="_varianceKind 379076"];
15489 [label="result.Name 379077"];
15490 [label="get\n            {\n                return _name;\n            } 379078"];
15491 [label="return _name; 379079"];
15492 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379080"];
15493 [label="result.ContainingSymbol 379081"];
15494 [label="get { return _owner; } 379082"];
15495 [label="return _owner; 379083"];
15496 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379084"];
15497 [label="result.ContainingSymbol.Name 379085"];
15498 [label="get\n            {\n                return declaration.Name;\n            } 379086"];
15499 [label="return declaration.Name; 379087"];
15500 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379088"];
15501 [label="return result; 379089"];
15502 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 379090"];
15503 [label="Debug.Assert(!syntaxRefs.IsEmpty); 379091"];
15504 [label="return _name; 379092"];
15505 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379093"];
15506 [label="return _owner; 379094"];
15507 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379095"];
15508 [label="get\n            {\n                return declaration.Name;\n            } 379096"];
15509 [label="if (result.Name == result.ContainingSymbol.Name)\n            {\n                diagnostics.Add(ErrorCode.ERR_TypeVariableSameAsParent, result.Locations[0], result.Name);\n            } 379097"];
15510 [label="AddDeclarationDiagnostics(diagnostics); 379098"];
15511 [label="AddDeclarationDiagnostics(diagnostics) 379099"];
15512 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 379100"];
15513 [label="param AddDeclarationDiagnostics(this) 379101"];
15514 [label="ContainingSymbol 379102"];
15515 [label="get\n            {\n                return _containingSymbol;\n            } 379103"];
15516 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 379104"];
15517 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 379105"];
15518 [label="AddDeclarationDiagnostics(diagnostics); 379106"];
15519 [label="diagnostics.Free(); 379107"];
15520 [label="return _lazyTypeParameters; 379108"];
15521 [label="foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        } 379109"];
15522 [label="typeParameter.ForceComplete(locationOpt, cancellationToken); 379110"];
15523 [label="typeParameter.ForceComplete(locationOpt, cancellationToken); 379111"];
15524 [label="typeParameter.ForceComplete(locationOpt, cancellationToken); 379112"];
15525 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 379113"];
15526 [label="HasAtMostOneBitSet(next) 379114"];
15527 [label="param HasAtMostOneBitSet(int bits) 379115"];
15528 [label="return (bits & (bits - 1)) == 0; 379116"];
15529 [label="return (bits & (bits - 1)) == 0; 379117"];
15530 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 379118"];
15531 [label="param GetAttributes(this) 379119"];
15532 [label="this.GetAttributesBag() 379120"];
15533 [label="param GetAttributesBag(this) 379121"];
15534 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                bool lazyAttributesStored = false;\n\n                var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol;\n                if ((object)sourceMethod == null || (object)sourceMethod.SourcePartialDefinition == null)\n                {\n                    lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null);\n                }\n                else\n                {\n                    var typeParameter = (SourceTypeParameterSymbolBase)sourceMethod.SourcePartialDefinition.TypeParameters[_ordinal];\n                    CustomAttributesBag<CSharpAttributeData> attributesBag = typeParameter.GetAttributesBag();\n\n                    lazyAttributesStored = Interlocked.CompareExchange(ref _lazyCustomAttributesBag, attributesBag, null) == null;\n                }\n\n                if (lazyAttributesStored)\n                {\n                    _state.NotePartComplete(CompletionPart.Attributes);\n                }\n            } 379122"];
15535 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                bool lazyAttributesStored = false;\n\n                var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol;\n                if ((object)sourceMethod == null || (object)sourceMethod.SourcePartialDefinition == null)\n                {\n                    lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null);\n                }\n                else\n                {\n                    var typeParameter = (SourceTypeParameterSymbolBase)sourceMethod.SourcePartialDefinition.TypeParameters[_ordinal];\n                    CustomAttributesBag<CSharpAttributeData> attributesBag = typeParameter.GetAttributesBag();\n\n                    lazyAttributesStored = Interlocked.CompareExchange(ref _lazyCustomAttributesBag, attributesBag, null) == null;\n                }\n\n                if (lazyAttributesStored)\n                {\n                    _state.NotePartComplete(CompletionPart.Attributes);\n                }\n            } 379123"];
15536 [label="bool lazyAttributesStored = false; 379124"];
15537 [label="this.ContainingSymbol 379125"];
15538 [label="get { return _owner; } 379126"];
15539 [label="return _owner; 379127"];
15540 [label="var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol; 379128"];
15541 [label="if ((object)sourceMethod == null || (object)sourceMethod.SourcePartialDefinition == null)\n                {\n                    lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null);\n                }\n                else\n                {\n                    var typeParameter = (SourceTypeParameterSymbolBase)sourceMethod.SourcePartialDefinition.TypeParameters[_ordinal];\n                    CustomAttributesBag<CSharpAttributeData> attributesBag = typeParameter.GetAttributesBag();\n\n                    lazyAttributesStored = Interlocked.CompareExchange(ref _lazyCustomAttributesBag, attributesBag, null) == null;\n                } 379129"];
15542 [label="if ((object)sourceMethod == null || (object)sourceMethod.SourcePartialDefinition == null)\n                {\n                    lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null);\n                }\n                else\n                {\n                    var typeParameter = (SourceTypeParameterSymbolBase)sourceMethod.SourcePartialDefinition.TypeParameters[_ordinal];\n                    CustomAttributesBag<CSharpAttributeData> attributesBag = typeParameter.GetAttributesBag();\n\n                    lazyAttributesStored = Interlocked.CompareExchange(ref _lazyCustomAttributesBag, attributesBag, null) == null;\n                } 379130"];
15543 [label="this.MergedAttributeDeclarationSyntaxLists 379131"];
15544 [label="get\n            {\n                var mergedAttributesBuilder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance();\n\n                foreach (var syntaxRef in _syntaxRefs)\n                {\n                    var syntax = (TypeParameterSyntax)syntaxRef.GetSyntax();\n                    mergedAttributesBuilder.Add(syntax.AttributeLists);\n                }\n\n                var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol;\n                if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                }\n\n                return mergedAttributesBuilder.ToImmutableAndFree();\n            } 379132"];
15545 [label="var mergedAttributesBuilder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance(); 379133"];
15546 [label="foreach (var syntaxRef in _syntaxRefs)\n                {\n                    var syntax = (TypeParameterSyntax)syntaxRef.GetSyntax();\n                    mergedAttributesBuilder.Add(syntax.AttributeLists);\n                } 379134"];
15547 [label="var syntax = (TypeParameterSyntax)syntaxRef.GetSyntax(); 379135"];
15548 [label="mergedAttributesBuilder.Add(syntax.AttributeLists); 379136"];
15549 [label="mergedAttributesBuilder.Add(syntax.AttributeLists); 379137"];
15550 [label="this.ContainingSymbol 379138"];
15551 [label="get { return _owner; } 379139"];
15552 [label="return _owner; 379140"];
15553 [label="var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol; 379141"];
15554 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 379142"];
15555 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 379143"];
15556 [label="return mergedAttributesBuilder.ToImmutableAndFree(); 379144"];
15557 [label="lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null); 379145"];
15558 [label="ContainingSymbol 379146"];
15559 [label="return _owner; 379147"];
15560 [label="(ContainingSymbol is LocalFunctionSymbol) 379148"];
15561 [label="lazyAttributesStored = LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null); 379149"];
15562 [label="LoadAndValidateAttributes(\n                        OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists),\n                        ref _lazyCustomAttributesBag,\n                        binderOpt:\n                        // LAFHIS\n                        //(ContainingSymbol as LocalFunctionSymbol)?.SignatureBinder)\n                        (ContainingSymbol is LocalFunctionSymbol) ? ((LocalFunctionSymbol)ContainingSymbol).SignatureBinder : null) 379150"];
15563 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 379151"];
15564 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 379152"];
15565 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 379153"];
15566 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 379154"];
15567 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 379155"];
15568 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 379156"];
15569 [label="param LoadAndValidateAttributes(this) 379157"];
15570 [label="this.DeclaringCompilation 379158"];
15571 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 379159"];
15572 [label="this.Kind 379160"];
15573 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 379161"];
15574 [label="return SymbolKind.TypeParameter; 379162"];
15575 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 379163"];
15576 [label="return _owner; 379164"];
15577 [label="var compilation = this.DeclaringCompilation; 379165"];
15578 [label="binders 379166"];
15579 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 379167"];
15580 [label="param GetAttributesToBind(AttributeLocation symbolPart) 379168"];
15581 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 379169"];
15582 [label="param GetAttributesToBind(CSharpCompilation compilation) 379170"];
15583 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 379171"];
15584 [label="param GetAttributesToBind(Binder rootBinderOpt) 379172"];
15585 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 379173"];
15586 [label="param GetAttributesToBind(this) 379174"];
15587 [label="var attributeTarget = (IAttributeTargetSymbol)this; 379175"];
15588 [label="ArrayBuilder<Binder> bindersBuilder = null; 379176"];
15589 [label="int attributesToBindCount = 0; 379177"];
15590 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 379178"];
15591 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 379179"];
15592 [label="var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex]; 379180"];
15593 [label="if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                } 379181"];
15594 [label="binders = ImmutableArray<Binder>.Empty; 379182"];
15595 [label="Debug.Assert(!attributesToBind.IsDefault); 379183"];
15596 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 379184"];
15597 [label="boundAttributes 379185"];
15598 [label="WellKnownAttributeData wellKnownAttributeData; 379186"];
15599 [label="wellKnownAttributeData = null; 379187"];
15600 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 379188"];
15601 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 379189"];
15602 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 379190"];
15603 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 379191"];
15604 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 379192"];
15605 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 379193"];
15606 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 379194"];
15607 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 379195"];
15608 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 379196"];
15609 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 379197"];
15610 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 379198"];
15611 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 379199"];
15612 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 379200"];
15613 [label="param PostDecodeWellKnownAttributes(this) 379201"];
15614 [label="bool lazyAttributesStoredOnThisThread = false; 379202"];
15615 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 379203"];
15616 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 379204"];
15617 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 379205"];
15618 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 379206"];
15619 [label="param RecordPresenceOfBadAttributes(this) 379207"];
15620 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 379208"];
15621 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 379209"];
15622 [label="AddDeclarationDiagnostics(diagnostics); 379210"];
15623 [label="AddDeclarationDiagnostics(diagnostics) 379211"];
15624 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 379212"];
15625 [label="param AddDeclarationDiagnostics(this) 379213"];
15626 [label="ContainingSymbol 379214"];
15627 [label="get { return _owner; } 379215"];
15628 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 379216"];
15629 [label="container.AssertMemberExposure(this, forDiagnostics: true); 379217"];
15630 [label="container.AssertMemberExposure(this, forDiagnostics: true); 379218"];
15631 [label="container.AssertMemberExposure(this, forDiagnostics: true) 379219"];
15632 [label="param AssertMemberExposure(Symbol member) 379220"];
15633 [label="param AssertMemberExposure(bool forDiagnostics = false) 379221"];
15634 [label="param AssertMemberExposure(this) 379222"];
15635 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 379223"];
15636 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 379224"];
15637 [label="Debug.Assert(forDiagnostics); 379225"];
15638 [label="return; 379226"];
15639 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 379227"];
15640 [label="AddDeclarationDiagnostics(diagnostics); 379228"];
15641 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 379229"];
15642 [label="diagnostics.Free(); 379230"];
15643 [label="if (lazyAttributesStored)\n                {\n                    _state.NotePartComplete(CompletionPart.Attributes);\n                } 379231"];
15644 [label="_state.NotePartComplete(CompletionPart.Attributes); 379232"];
15645 [label="_state.NotePartComplete(CompletionPart.Attributes) 379233"];
15646 [label="param NotePartComplete(CompletionPart part) 379234"];
15647 [label="return _lazyCustomAttributesBag; 379235"];
15648 [label="return this.GetAttributesBag().Attributes; 379236"];
15649 [label="typeParameter.ForceComplete(locationOpt, cancellationToken); 379237"];
15650 [label="param SpinWaitComplete(CompletionPart part) 379238"];
15651 [label="param SpinWaitComplete(CancellationToken cancellationToken) 379239"];
15652 [label="param SpinWaitComplete(this) 379240"];
15653 [label="if (HasComplete(part))\n            {\n                return;\n            } 379241"];
15654 [label="HasComplete(part) 379242"];
15655 [label="param HasComplete(CompletionPart part) 379243"];
15656 [label="param HasComplete(this) 379244"];
15657 [label="return (_completeParts & (int)part) == (int)part; 379245"];
15658 [label="return; 379246"];
15659 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 379247"];
15660 [label="param HasAtMostOneBitSet(int bits) 379248"];
15661 [label="return (bits & (bits - 1)) == 0; 379249"];
15662 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 379250"];
15663 [label="this.EnsureAllConstraintsAreResolved() 379251"];
15664 [label="param EnsureAllConstraintsAreResolved(this) 379252"];
15665 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 379253"];
15666 [label="_lazyBounds.IsSet() 379254"];
15667 [label="param IsSet(this TypeParameterBounds boundsOpt) 379255"];
15668 [label="return boundsOpt != TypeParameterBounds.Unset; 379256"];
15669 [label="this.ContainerTypeParameters 379257"];
15670 [label="get { return _owner.TypeParameters; } 379258"];
15671 [label="_owner.TypeParameters 379259"];
15672 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 379260"];
15673 [label="return _owner.TypeParameters; 379261"];
15674 [label="EnsureAllConstraintsAreResolved(this.ContainerTypeParameters); 379262"];
15675 [label="EnsureAllConstraintsAreResolved(this.ContainerTypeParameters) 379263"];
15676 [label="param EnsureAllConstraintsAreResolved(ImmutableArray<TypeParameterSymbol> typeParameters) 379264"];
15677 [label="foreach (var typeParameter in typeParameters)\n            {\n                // Invoke any method that forces constraints to be resolved.\n                var unused = typeParameter.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 379265"];
15678 [label="var unused = typeParameter.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 379266"];
15679 [label="typeParameter.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 379267"];
15680 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 379268"];
15681 [label="param GetConstraintTypes(this) 379269"];
15682 [label="var bounds = this.GetBounds(inProgress); 379270"];
15683 [label="this.GetBounds(inProgress) 379271"];
15684 [label="param GetBounds(ConsList<TypeParameterSymbol> inProgress) 379272"];
15685 [label="param GetBounds(this) 379273"];
15686 [label="Debug.Assert(!inProgress.ContainsReference(this)); 379274"];
15687 [label="Debug.Assert(!inProgress.ContainsReference(this)); 379275"];
15688 [label="Debug.Assert(!inProgress.ContainsReference(this)); 379276"];
15689 [label="Debug.Assert(!inProgress.Any() || ReferenceEquals(inProgress.Head.ContainingSymbol, this.ContainingSymbol)); 379277"];
15690 [label="if (!_lazyBounds.IsSet())\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var bounds = this.ResolveBounds(inProgress, diagnostics);\n\n                if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBounds, bounds, TypeParameterBounds.Unset), TypeParameterBounds.Unset))\n                {\n                    this.CheckConstraintTypeConstraints(diagnostics);\n                    this.CheckUnmanagedConstraint(diagnostics);\n                    this.EnsureAttributesFromConstraints(diagnostics);\n                    this.AddDeclarationDiagnostics(diagnostics);\n                    _state.NotePartComplete(CompletionPart.TypeParameterConstraints);\n                }\n\n                diagnostics.Free();\n            } 379278"];
15691 [label="_lazyBounds.IsSet() 379279"];
15692 [label="param IsSet(this TypeParameterBounds boundsOpt) 379280"];
15693 [label="var diagnostics = DiagnosticBag.GetInstance(); 379281"];
15694 [label="var bounds = this.ResolveBounds(inProgress, diagnostics); 379282"];
15695 [label="var bounds = this.ResolveBounds(inProgress, diagnostics); 379283"];
15696 [label="this.ResolveBounds(inProgress, diagnostics) 379284"];
15697 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 379285"];
15698 [label="param ResolveBounds(DiagnosticBag diagnostics) 379286"];
15699 [label="param ResolveBounds(this) 379287"];
15700 [label="this.Ordinal 379288"];
15701 [label="get\n            {\n                return _ordinal;\n            } 379289"];
15702 [label="return _ordinal; 379290"];
15703 [label="var constraintTypes = _owner.GetTypeParameterConstraintTypes(this.Ordinal); 379291"];
15704 [label="_owner.GetTypeParameterConstraintTypes(this.Ordinal) 379292"];
15705 [label="param GetTypeParameterConstraintTypes(int ordinal) 379293"];
15706 [label="param GetTypeParameterConstraintTypes(this) 379294"];
15707 [label="GetTypeParameterConstraintTypes() 379295"];
15708 [label="param GetTypeParameterConstraintTypes(this) 379296"];
15709 [label="var constraintTypes = _lazyTypeParameterConstraintTypes; 379297"];
15710 [label="if (constraintTypes.IsDefault)\n            {\n                GetTypeParameterConstraintKinds();\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintTypes, MakeTypeParameterConstraintTypes(diagnostics)))\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n                constraintTypes = _lazyTypeParameterConstraintTypes;\n            } 379298"];
15711 [label="GetTypeParameterConstraintKinds() 379299"];
15712 [label="param GetTypeParameterConstraintKinds(this) 379300"];
15713 [label="var constraintKinds = _lazyTypeParameterConstraintKinds; 379301"];
15714 [label="if (constraintKinds.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintKinds, MakeTypeParameterConstraintKinds());\n                constraintKinds = _lazyTypeParameterConstraintKinds;\n            } 379302"];
15715 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintKinds, MakeTypeParameterConstraintKinds()); 379303"];
15716 [label="MakeTypeParameterConstraintKinds() 379304"];
15717 [label="param MakeTypeParameterConstraintKinds(this) 379305"];
15718 [label="this.TypeParameters 379306"];
15719 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 379307"];
15720 [label="var typeParameters = this.TypeParameters; 379308"];
15721 [label="var results = ImmutableArray<TypeParameterConstraintClause>.Empty; 379309"];
15722 [label="int arity = typeParameters.Length; 379310"];
15723 [label="if (arity > 0)\n            {\n                bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses();\n                ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null;\n\n                foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        // Also, suppress type argument binding in constraint types, this helps to avoid cycles while we figure out constraint kinds. \n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressTypeArgumentBinding);\n\n                        var discarded = DiagnosticBag.GetInstance(); // We will recompute this diagnostics more accurately later, when binding without BinderFlags.SuppressTypeArgumentBinding  \n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, discarded, performOnlyCycleSafeValidation: true);\n                        discarded.Free();\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                }\n\n                results = MergeConstraintKindsForPartialDeclarations(results, otherPartialClauses);\n                results = ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results);\n\n                if (results.All(clause => clause.Constraints == TypeParameterConstraintKind.None))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                }\n\n                otherPartialClauses?.Free();\n            } 379311"];
15724 [label="if (arity > 0)\n            {\n                bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses();\n                ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null;\n\n                foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        // Also, suppress type argument binding in constraint types, this helps to avoid cycles while we figure out constraint kinds. \n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressTypeArgumentBinding);\n\n                        var discarded = DiagnosticBag.GetInstance(); // We will recompute this diagnostics more accurately later, when binding without BinderFlags.SuppressTypeArgumentBinding  \n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, discarded, performOnlyCycleSafeValidation: true);\n                        discarded.Free();\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                }\n\n                results = MergeConstraintKindsForPartialDeclarations(results, otherPartialClauses);\n                results = ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results);\n\n                if (results.All(clause => clause.Constraints == TypeParameterConstraintKind.None))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                }\n\n                otherPartialClauses?.Free();\n            } 379312"];
15725 [label="SkipPartialDeclarationsWithoutConstraintClauses() 379313"];
15726 [label="param SkipPartialDeclarationsWithoutConstraintClauses(this) 379314"];
15727 [label="foreach (var decl in declaration.Declarations)\n            {\n                if (GetConstraintClauses((CSharpSyntaxNode)decl.SyntaxReference.GetSyntax(), out _).Count != 0)\n                {\n                    return true;\n                }\n            } 379315"];
15728 [label="if (GetConstraintClauses((CSharpSyntaxNode)decl.SyntaxReference.GetSyntax(), out _).Count != 0)\n                {\n                    return true;\n                } 379316"];
15729 [label="GetConstraintClauses((CSharpSyntaxNode)decl.SyntaxReference.GetSyntax(), out _) 379317"];
15730 [label="param GetConstraintClauses(CSharpSyntaxNode node) 379318"];
15731 [label="param GetConstraintClauses(out TypeParameterListSyntax typeParameterList) 379319"];
15732 [label="switch (node.Kind())\n            {\n                case SyntaxKind.ClassDeclaration:\n                case SyntaxKind.StructDeclaration:\n                case SyntaxKind.InterfaceDeclaration:\n                case SyntaxKind.RecordDeclaration:\n                    var typeDeclaration = (TypeDeclarationSyntax)node;\n                    typeParameterList = typeDeclaration.TypeParameterList;\n                    return typeDeclaration.ConstraintClauses;\n                case SyntaxKind.DelegateDeclaration:\n                    var delegateDeclaration = (DelegateDeclarationSyntax)node;\n                    typeParameterList = delegateDeclaration.TypeParameterList;\n                    return delegateDeclaration.ConstraintClauses;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(node.Kind());\n            } 379320"];
15733 [label="var typeDeclaration = (TypeDeclarationSyntax)node; 379321"];
15734 [label="typeParameterList = typeDeclaration.TypeParameterList; 379322"];
15735 [label="return typeDeclaration.ConstraintClauses; 379323"];
15736 [label="return false; 379324"];
15737 [label="bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses(); 379325"];
15738 [label="ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null; 379326"];
15739 [label="foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        // Also, suppress type argument binding in constraint types, this helps to avoid cycles while we figure out constraint kinds. \n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressTypeArgumentBinding);\n\n                        var discarded = DiagnosticBag.GetInstance(); // We will recompute this diagnostics more accurately later, when binding without BinderFlags.SuppressTypeArgumentBinding  \n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, discarded, performOnlyCycleSafeValidation: true);\n                        discarded.Free();\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                } 379327"];
15740 [label="var syntaxRef = decl.SyntaxReference; 379328"];
15741 [label="var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList); 379329"];
15742 [label="var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList); 379330"];
15743 [label="GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList) 379331"];
15744 [label="param GetConstraintClauses(CSharpSyntaxNode node) 379332"];
15745 [label="param GetConstraintClauses(out TypeParameterListSyntax typeParameterList) 379333"];
15746 [label="var typeDeclaration = (TypeDeclarationSyntax)node; 379334"];
15747 [label="typeParameterList = typeDeclaration.TypeParameterList; 379335"];
15748 [label="return typeDeclaration.ConstraintClauses; 379336"];
15749 [label="if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    } 379337"];
15750 [label="this.DeclaringCompilation 379338"];
15751 [label="this.Kind 379339"];
15752 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 379340"];
15753 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 379341"];
15754 [label="return _containingSymbol; 379342"];
15755 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 379343"];
15756 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 379344"];
15757 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 379345"];
15758 [label="this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree) 379346"];
15759 [label="param GetBinderFactory(SyntaxTree syntaxTree) 379347"];
15760 [label="param GetBinderFactory(bool ignoreAccessibility = false) 379348"];
15761 [label="param GetBinderFactory(this) 379349"];
15762 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 379350"];
15763 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 379351"];
15764 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 379352"];
15765 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 379353"];
15766 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 379354"];
15767 [label="param GetBinderFactory(SyntaxTree syntaxTree) 379355"];
15768 [label="param GetBinderFactory(bool ignoreAccessibility) 379356"];
15769 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 379357"];
15770 [label="param GetBinderFactory(this) 379358"];
15771 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 379359"];
15772 [label="ignoreAccessibility 379360"];
15773 [label="_binderFactories 379361"];
15774 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 379362"];
15775 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 379363"];
15776 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 379364"];
15777 [label="GetSyntaxTreeOrdinal(syntaxTree) 379365"];
15778 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 379366"];
15779 [label="param GetSyntaxTreeOrdinal(this) 379367"];
15780 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 379368"];
15781 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 379369"];
15782 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 379370"];
15783 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 379371"];
15784 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 379372"];
15785 [label="BinderFactory? previousFactory; 379373"];
15786 [label="var previousWeakReference = binderFactories[treeNum]; 379374"];
15787 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 379375"];
15788 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 379376"];
15789 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 379377"];
15790 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 379378"];
15791 [label="return previousFactory; 379379"];
15792 [label="Binder binder; 379380"];
15793 [label="ImmutableArray<TypeParameterConstraintClause> constraints; 379381"];
15794 [label="constraints 379382"];
15795 [label="if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        // Also, suppress type argument binding in constraint types, this helps to avoid cycles while we figure out constraint kinds. \n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressTypeArgumentBinding);\n\n                        var discarded = DiagnosticBag.GetInstance(); // We will recompute this diagnostics more accurately later, when binding without BinderFlags.SuppressTypeArgumentBinding  \n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, discarded, performOnlyCycleSafeValidation: true);\n                        discarded.Free();\n                    } 379383"];
15796 [label="if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        // Also, suppress type argument binding in constraint types, this helps to avoid cycles while we figure out constraint kinds. \n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressTypeArgumentBinding);\n\n                        var discarded = DiagnosticBag.GetInstance(); // We will recompute this diagnostics more accurately later, when binding without BinderFlags.SuppressTypeArgumentBinding  \n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, discarded, performOnlyCycleSafeValidation: true);\n                        discarded.Free();\n                    } 379384"];
15797 [label="binder = binderFactory.GetBinder(typeParameterList.Parameters[0]); 379385"];
15798 [label="binder = binderFactory.GetBinder(typeParameterList.Parameters[0]); 379386"];
15799 [label="binderFactory.GetBinder(typeParameterList.Parameters[0]) 379387"];
15800 [label="param GetBinder(SyntaxNode node) 379388"];
15801 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 379389"];
15802 [label="param GetBinder(Symbol memberOpt = null) 379390"];
15803 [label="param GetBinder(this) 379391"];
15804 [label="int position = node.SpanStart; 379392"];
15805 [label="InScript 379393"];
15806 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 379394"];
15807 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 379395"];
15808 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 379396"];
15809 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 379397"];
15810 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 379398"];
15811 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 379399"];
15812 [label="node = node.Parent; 379400"];
15813 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 379401"];
15814 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 379402"];
15815 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 379403"];
15816 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 379404"];
15817 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 379405"];
15818 [label="param GetBinder(SyntaxNode node) 379406"];
15819 [label="param GetBinder(int position) 379407"];
15820 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 379408"];
15821 [label="param GetBinder(Symbol memberOpt = null) 379409"];
15822 [label="param GetBinder(this) 379410"];
15823 [label="Debug.Assert(node != null); 379411"];
15824 [label="Debug.Assert(node != null); 379412"];
15825 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 379413"];
15826 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 379414"];
15827 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 379415"];
15828 [label="param BinderFactoryVisitor(BinderFactory factory) 379416"];
15829 [label="param BinderFactoryVisitor(this) 379417"];
15830 [label="param BinderFactoryVisitor(this) 379418"];
15831 [label="_position 379419"];
15832 [label="_memberDeclarationOpt 379420"];
15833 [label="_memberOpt 379421"];
15834 [label="_factory 379422"];
15835 [label="_factory 379423"];
15836 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 379424"];
15837 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 379425"];
15838 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 379426"];
15839 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 379427"];
15840 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 379428"];
15841 [label="param Initialize(int position) 379429"];
15842 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 379430"];
15843 [label="param Initialize(Symbol memberOpt) 379431"];
15844 [label="param Initialize(this) 379432"];
15845 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379433"];
15846 [label="memberDeclarationOpt == null 379434"];
15847 [label="param ==(Symbol left) 379435"];
15848 [label="param ==(Symbol right) 379436"];
15849 [label="if (right is null)\n            {\n                return left is null;\n            } 379437"];
15850 [label="return left is null; 379438"];
15851 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379439"];
15852 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379440"];
15853 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379441"];
15854 [label="_position 379442"];
15855 [label="_memberDeclarationOpt 379443"];
15856 [label="_memberOpt 379444"];
15857 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 379445"];
15858 [label="Binder result = visitor.Visit(node); 379446"];
15859 [label="visitor.Visit(node) 379447"];
15860 [label="param Visit(SyntaxNode node) 379448"];
15861 [label="param Visit(this) 379449"];
15862 [label="return VisitCore(node); 379450"];
15863 [label="VisitCore(node) 379451"];
15864 [label="param VisitCore(SyntaxNode node) 379452"];
15865 [label="param VisitCore(this) 379453"];
15866 [label="return ((CSharpSyntaxNode)node).Accept(this); 379454"];
15867 [label="return ((CSharpSyntaxNode)node).Accept(this); 379455"];
15868 [label="return ((CSharpSyntaxNode)node).Accept(this); 379456"];
15869 [label="param DefaultVisit(SyntaxNode parent) 379457"];
15870 [label="param DefaultVisit(this) 379458"];
15871 [label="return VisitCore(parent.Parent); 379459"];
15872 [label="VisitCore(parent.Parent) 379460"];
15873 [label="param VisitCore(SyntaxNode node) 379461"];
15874 [label="param VisitCore(this) 379462"];
15875 [label="return ((CSharpSyntaxNode)node).Accept(this); 379463"];
15876 [label="param VisitInterfaceDeclaration(InterfaceDeclarationSyntax node) 379464"];
15877 [label="param VisitInterfaceDeclaration(this) 379465"];
15878 [label="return VisitTypeDeclarationCore(node); 379466"];
15879 [label="VisitTypeDeclarationCore(node) 379467"];
15880 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 379468"];
15881 [label="param VisitTypeDeclarationCore(this) 379469"];
15882 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379470"];
15883 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379471"];
15884 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379472"];
15885 [label="NodeUsage extraInfo = NodeUsage.Normal; 379473"];
15886 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379474"];
15887 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379475"];
15888 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379476"];
15889 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379477"];
15890 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379478"];
15891 [label="if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 379479"];
15892 [label="extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters; 379480"];
15893 [label="return VisitTypeDeclarationCore(parent, extraInfo); 379481"];
15894 [label="return VisitTypeDeclarationCore(parent, extraInfo); 379482"];
15895 [label="VisitTypeDeclarationCore(parent, extraInfo) 379483"];
15896 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 379484"];
15897 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 379485"];
15898 [label="param VisitTypeDeclarationCore(this) 379486"];
15899 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379487"];
15900 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379488"];
15901 [label="CreateBinderCacheKey(parent, extraInfo) 379489"];
15902 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 379490"];
15903 [label="param CreateBinderCacheKey(NodeUsage usage) 379491"];
15904 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379492"];
15905 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379493"];
15906 [label="return new BinderCacheKey(node, usage); 379494"];
15907 [label="return new BinderCacheKey(node, usage); 379495"];
15908 [label="return new BinderCacheKey(node, usage); 379496"];
15909 [label="new BinderCacheKey(node, usage) 379497"];
15910 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 379498"];
15911 [label="param BinderCacheKey(NodeUsage usage) 379499"];
15912 [label="param BinderCacheKey(this) 379500"];
15913 [label="this.syntaxNode 379501"];
15914 [label="this.usage 379502"];
15915 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379503"];
15916 [label="Binder resultBinder; 379504"];
15917 [label="binderCache 379505"];
15918 [label="get\n                {\n                    return _factory._binderCache;\n                } 379506"];
15919 [label="return _factory._binderCache; 379507"];
15920 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 379508"];
15921 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 379509"];
15922 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 379510"];
15923 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 379511"];
15924 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 379512"];
15925 [label="param GetHashCode(this) 379513"];
15926 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 379514"];
15927 [label="resultBinder = VisitCore(parent.Parent); 379515"];
15928 [label="VisitCore(parent.Parent) 379516"];
15929 [label="param VisitCore(SyntaxNode node) 379517"];
15930 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 379518"];
15931 [label="param VisitNamespaceDeclaration(this) 379519"];
15932 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379520"];
15933 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379521"];
15934 [label="if (!LookupPosition.IsInNamespaceDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 379522"];
15935 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 379523"];
15936 [label="bool inBody = LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken); 379524"];
15937 [label="bool inUsing = IsInUsing(parent); 379525"];
15938 [label="IsInUsing(parent) 379526"];
15939 [label="param IsInUsing(CSharpSyntaxNode containingNode) 379527"];
15940 [label="param IsInUsing(this) 379528"];
15941 [label="TextSpan containingSpan = containingNode.Span; 379529"];
15942 [label="SyntaxToken token; 379530"];
15943 [label="token 379531"];
15944 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 379532"];
15945 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 379533"];
15946 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 379534"];
15947 [label="token = containingNode.FindToken(_position); 379535"];
15948 [label="token = containingNode.FindToken(_position); 379536"];
15949 [label="var node = token.Parent; 379537"];
15950 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 379538"];
15951 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 379539"];
15952 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 379540"];
15953 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 379541"];
15954 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 379542"];
15955 [label="node = node.Parent; 379543"];
15956 [label="return false; 379544"];
15957 [label="bool inUsing = IsInUsing(parent); 379545"];
15958 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 379546"];
15959 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 379547"];
15960 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 379548"];
15961 [label="return VisitNamespaceDeclaration(parent, _position, inBody, inUsing); 379549"];
15962 [label="VisitNamespaceDeclaration(parent, _position, inBody, inUsing) 379550"];
15963 [label="param VisitNamespaceDeclaration(NamespaceDeclarationSyntax parent) 379551"];
15964 [label="param VisitNamespaceDeclaration(int position) 379552"];
15965 [label="param VisitNamespaceDeclaration(bool inBody) 379553"];
15966 [label="param VisitNamespaceDeclaration(bool inUsing) 379554"];
15967 [label="param VisitNamespaceDeclaration(this) 379555"];
15968 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 379556"];
15969 [label="Debug.Assert(!inUsing || inBody, 'inUsing => inBody'); 379557"];
15970 [label="inUsing 379558"];
15971 [label="inBody 379559"];
15972 [label="var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal); 379560"];
15973 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379561"];
15974 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379562"];
15975 [label="CreateBinderCacheKey(parent, extraInfo) 379563"];
15976 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 379564"];
15977 [label="param CreateBinderCacheKey(NodeUsage usage) 379565"];
15978 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379566"];
15979 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379567"];
15980 [label="var key = CreateBinderCacheKey(parent, extraInfo); 379568"];
15981 [label="Binder result; 379569"];
15982 [label="binderCache 379570"];
15983 [label="get\n                {\n                    return _factory._binderCache;\n                } 379571"];
15984 [label="return _factory._binderCache; 379572"];
15985 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379573"];
15986 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379574"];
15987 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379575"];
15988 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379576"];
15989 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    Binder outer;\n                    var container = parent.Parent;\n\n                    if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    }\n\n                    if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379577"];
15990 [label="Binder outer; 379578"];
15991 [label="var container = parent.Parent; 379579"];
15992 [label="InScript 379580"];
15993 [label="get\n                {\n                    return _factory.InScript;\n                } 379581"];
15994 [label="_factory.InScript 379582"];
15995 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 379583"];
15996 [label="return _factory.InScript; 379584"];
15997 [label="if (InScript && container.Kind() == SyntaxKind.CompilationUnit)\n                    {\n                        // Although namespaces are not allowed in script code we still bind them so that we don't report useless errors.\n                        // A namespace in script code is not bound within the scope of a Script class, \n                        // but still within scope of compilation unit extern aliases and usings.\n                        outer = VisitCompilationUnit((CompilationUnitSyntax)container, inUsing: false, inScript: false);\n                    }\n                    else\n                    {\n                        outer = _factory.GetBinder(parent.Parent, position);\n                    } 379585"];
15998 [label="outer = _factory.GetBinder(parent.Parent, position); 379586"];
15999 [label="outer = _factory.GetBinder(parent.Parent, position); 379587"];
16000 [label="outer = _factory.GetBinder(parent.Parent, position); 379588"];
16001 [label="_factory.GetBinder(parent.Parent, position) 379589"];
16002 [label="param GetBinder(SyntaxNode node) 379590"];
16003 [label="param GetBinder(int position) 379591"];
16004 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 379592"];
16005 [label="param GetBinder(Symbol memberOpt = null) 379593"];
16006 [label="Debug.Assert(node != null); 379594"];
16007 [label="Debug.Assert(node != null); 379595"];
16008 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 379596"];
16009 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379597"];
16010 [label="memberDeclarationOpt == null 379598"];
16011 [label="param ==(Symbol left) 379599"];
16012 [label="param ==(Symbol right) 379600"];
16013 [label="if (right is null)\n            {\n                return left is null;\n            } 379601"];
16014 [label="return left is null; 379602"];
16015 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379603"];
16016 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 379604"];
16017 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 379605"];
16018 [label="param VisitCompilationUnit(this) 379606"];
16019 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 379607"];
16020 [label="IsInUsing(parent) 379608"];
16021 [label="param IsInUsing(CSharpSyntaxNode containingNode) 379609"];
16022 [label="param IsInUsing(this) 379610"];
16023 [label="SyntaxToken token; 379611"];
16024 [label="token 379612"];
16025 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 379613"];
16026 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 379614"];
16027 [label="InScript 379615"];
16028 [label="get\n                {\n                    return _factory.InScript;\n                } 379616"];
16029 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 379617"];
16030 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 379618"];
16031 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 379619"];
16032 [label="param VisitCompilationUnit(bool inUsing) 379620"];
16033 [label="param VisitCompilationUnit(bool inScript) 379621"];
16034 [label="param VisitCompilationUnit(this) 379622"];
16035 [label="syntaxTree 379623"];
16036 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 379624"];
16037 [label="return _factory._syntaxTree; 379625"];
16038 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 379626"];
16039 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 379627"];
16040 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 379628"];
16041 [label="inUsing 379629"];
16042 [label="inScript 379630"];
16043 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 379631"];
16044 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 379632"];
16045 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 379633"];
16046 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 379634"];
16047 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 379635"];
16048 [label="param CreateBinderCacheKey(NodeUsage usage) 379636"];
16049 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379637"];
16050 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 379638"];
16051 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 379639"];
16052 [label="Binder result; 379640"];
16053 [label="binderCache 379641"];
16054 [label="get\n                {\n                    return _factory._binderCache;\n                } 379642"];
16055 [label="return _factory._binderCache; 379643"];
16056 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379644"];
16057 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379645"];
16058 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379646"];
16059 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379647"];
16060 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 379648"];
16061 [label="param Equals(BinderCacheKey other) 379649"];
16062 [label="param Equals(this) 379650"];
16063 [label="return syntaxNode == other.syntaxNode && this.usage == other.usage; 379651"];
16064 [label="return result; 379652"];
16065 [label="_binderFactoryVisitorPool.Free(visitor); 379653"];
16066 [label="_binderFactoryVisitorPool.Free(visitor); 379654"];
16067 [label="return result; 379655"];
16068 [label="if (!inBody)\n                    {\n                        // not between the curlies\n                        result = outer;\n                    }\n                    else\n                    {\n                        // if between the curlies, members are in scope\n                        result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing);\n                    } 379656"];
16069 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 379657"];
16070 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 379658"];
16071 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 379659"];
16072 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 379660"];
16073 [label="MakeNamespaceBinder(parent, parent.Name, outer, inUsing) 379661"];
16074 [label="param MakeNamespaceBinder(CSharpSyntaxNode node) 379662"];
16075 [label="param MakeNamespaceBinder(NameSyntax name) 379663"];
16076 [label="param MakeNamespaceBinder(Binder outer) 379664"];
16077 [label="param MakeNamespaceBinder(bool inUsing) 379665"];
16078 [label="param MakeNamespaceBinder(this) 379666"];
16079 [label="QualifiedNameSyntax dotted; 379667"];
16080 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 379668"];
16081 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 379669"];
16082 [label="while ((dotted = name as QualifiedNameSyntax) != null)\n                {\n                    outer = MakeNamespaceBinder(dotted.Left, dotted.Left, outer, inUsing: false);\n                    name = dotted.Right;\n                } 379670"];
16083 [label="NamespaceOrTypeSymbol container; 379671"];
16084 [label="if (outer is InContainerBinder inContainerBinder)\n                {\n                    container = inContainerBinder.Container;\n                }\n                else\n                {\n                    Debug.Assert(outer is SimpleProgramUnitBinder);\n                    container = outer.Compilation.GlobalNamespace;\n                } 379672"];
16085 [label="inContainerBinder.Container 379673"];
16086 [label="get\n            {\n                return _container;\n            } 379674"];
16087 [label="return _container; 379675"];
16088 [label="container = inContainerBinder.Container; 379676"];
16089 [label="NamespaceSymbol ns = ((NamespaceSymbol)container).GetNestedNamespace(name); 379677"];
16090 [label="((NamespaceSymbol)container).GetNestedNamespace(name) 379678"];
16091 [label="param GetNestedNamespace(NameSyntax name) 379679"];
16092 [label="param GetNestedNamespace(this) 379680"];
16093 [label="switch (name.Kind())\n            {\n                case SyntaxKind.GenericName: // DeclarationTreeBuilder.VisitNamespace uses the PlainName, even for generic names\n                case SyntaxKind.IdentifierName:\n                    return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText);\n\n                case SyntaxKind.QualifiedName:\n                    var qn = (QualifiedNameSyntax)name;\n                    var leftNs = this.GetNestedNamespace(qn.Left);\n                    if ((object)leftNs != null)\n                    {\n                        return leftNs.GetNestedNamespace(qn.Right);\n                    }\n\n                    break;\n\n                case SyntaxKind.AliasQualifiedName:\n                    // This is an error scenario, but we should still handle it.\n                    // We recover in the same way as DeclarationTreeBuilder.VisitNamespaceDeclaration.\n                    return this.GetNestedNamespace(name.GetUnqualifiedName().Identifier.ValueText);\n            } 379681"];
16094 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 379682"];
16095 [label="((SimpleNameSyntax)name).Identifier 379683"];
16096 [label="param GetNestedNamespace(string name) 379684"];
16097 [label="param GetNestedNamespace(this) 379685"];
16098 [label="foreach (var sym in this.GetMembers(name))\n            {\n                if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                }\n            } 379686"];
16099 [label="this.GetMembers(name) 379687"];
16100 [label="param GetMembers(string name) 379688"];
16101 [label="param GetMembers(this) 379689"];
16102 [label="return _cachedLookup[name]; 379690"];
16103 [label="_cachedLookup 379691"];
16104 [label="param SlowGetChildrenOfName(string name) 379692"];
16105 [label="param SlowGetChildrenOfName(this) 379693"];
16106 [label="ArrayBuilder<NamespaceSymbol> namespaceSymbols = null; 379694"];
16107 [label="var otherSymbols = ArrayBuilder<Symbol>.GetInstance(); 379695"];
16108 [label="foreach (NamespaceSymbol namespaceSymbol in _namespacesToMerge)\n            {\n                foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                }\n            } 379696"];
16109 [label="foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                } 379697"];
16110 [label="namespaceSymbol.GetMembers(name) 379698"];
16111 [label="param GetMembers(string name) 379699"];
16112 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 379700"];
16113 [label="childSymbol.Kind 379701"];
16114 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 379702"];
16115 [label="if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    } 379703"];
16116 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 379704"];
16117 [label="namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance(); 379705"];
16118 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 379706"];
16119 [label="namespaceSymbols.Add((NamespaceSymbol)childSymbol); 379707"];
16120 [label="EnsureAllMembersLoaded(); 379708"];
16121 [label="return ImmutableArray<Symbol>.Empty; 379709"];
16122 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 379710"];
16123 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 379711"];
16124 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 379712"];
16125 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 379713"];
16126 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 379714"];
16127 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 379715"];
16128 [label="MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()) 379716"];
16129 [label="param Create(NamespaceExtent extent) 379717"];
16130 [label="param Create(NamespaceSymbol containingNamespace) 379718"];
16131 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 379719"];
16132 [label="param Create(string nameOpt = null) 379720"];
16133 [label="Debug.Assert(namespacesToMerge.Length != 0); 379721"];
16134 [label="Debug.Assert(namespacesToMerge.Length != 0); 379722"];
16135 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 379723"];
16136 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 379724"];
16137 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 379725"];
16138 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 379726"];
16139 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 379727"];
16140 [label="otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree())); 379728"];
16141 [label="return otherSymbols.ToImmutableAndFree(); 379729"];
16142 [label="sym.Kind 379730"];
16143 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 379731"];
16144 [label="if (sym.Kind == SymbolKind.Namespace)\n                {\n                    return (NamespaceSymbol)sym;\n                } 379732"];
16145 [label="return (NamespaceSymbol)sym; 379733"];
16146 [label="return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText); 379734"];
16147 [label="if ((object)ns == null) return outer; 379735"];
16148 [label="if ((object)ns == null) return outer; 379736"];
16149 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 379737"];
16150 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 379738"];
16151 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 379739"];
16152 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 379740"];
16153 [label="return new InContainerBinder(ns, outer, node, inUsing: inUsing); 379741"];
16154 [label="new InContainerBinder(ns, outer, node, inUsing: inUsing) 379742"];
16155 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 379743"];
16156 [label="param InContainerBinder(Binder next) 379744"];
16157 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 379745"];
16158 [label="param InContainerBinder(bool inUsing) 379746"];
16159 [label="param InContainerBinder(this) 379747"];
16160 [label="next 379748"];
16161 [label="param InContainerBinder(this) 379749"];
16162 [label="param Binder(Binder next) 379750"];
16163 [label="param Binder(this) 379751"];
16164 [label="param Binder(Conversions? conversions = null) 379752"];
16165 [label="internal CSharpCompilation Compilation { get; } 379753"];
16166 [label="Flags 379754"];
16167 [label="protected internal Binder? Next { get; } 379755"];
16168 [label="_lazyConversions 379756"];
16169 [label="_lazyOverloadResolution 379757"];
16170 [label="RoslynDebug.Assert(next != null); 379758"];
16171 [label="RoslynDebug.Assert(next != null); 379759"];
16172 [label="Next 379760"];
16173 [label="this.Flags 379761"];
16174 [label="this.Compilation 379762"];
16175 [label="_lazyConversions 379763"];
16176 [label="_container 379764"];
16177 [label="_computeImports 379765"];
16178 [label="_lazyImports 379766"];
16179 [label="_lazyImportChain 379767"];
16180 [label="_lazyQuickAttributeChecker 379768"];
16181 [label="Debug.Assert((object)container != null); 379769"];
16182 [label="Debug.Assert((object)container != null); 379770"];
16183 [label="Debug.Assert(declarationSyntax != null); 379771"];
16184 [label="Debug.Assert(declarationSyntax != null); 379772"];
16185 [label="_container 379773"];
16186 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 379774"];
16187 [label="_computeImports 379775"];
16188 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 379776"];
16189 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 379777"];
16190 [label="if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 379778"];
16191 [label="var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax; 379779"];
16192 [label="_usingsSyntax 379780"];
16193 [label="result = MakeNamespaceBinder(parent, parent.Name, outer, inUsing); 379781"];
16194 [label="binderCache 379782"];
16195 [label="return _factory._binderCache; 379783"];
16196 [label="binderCache.TryAdd(key, result); 379784"];
16197 [label="binderCache.TryAdd(key, result); 379785"];
16198 [label="binderCache.TryAdd(key, result); 379786"];
16199 [label="binderCache.TryAdd(key, result); 379787"];
16200 [label="binderCache.TryAdd(key, result); 379788"];
16201 [label="return result; 379789"];
16202 [label="return ((CSharpSyntaxNode)node).Accept(this); 379790"];
16203 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 379791"];
16204 [label="resultBinder.ContainingMemberOrLambda 379792"];
16205 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 379793"];
16206 [label="var merged = _container as MergedNamespaceSymbol; 379794"];
16207 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 379795"];
16208 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 379796"];
16209 [label="((object)merged != null) 379797"];
16210 [label="_container 379798"];
16211 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 379799"];
16212 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 379800"];
16213 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 379801"];
16214 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 379802"];
16215 [label="param GetSourceTypeMember(this) 379803"];
16216 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 379804"];
16217 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 379805"];
16218 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 379806"];
16219 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 379807"];
16220 [label="param GetSourceTypeMember(string name) 379808"];
16221 [label="param GetSourceTypeMember(int arity) 379809"];
16222 [label="param GetSourceTypeMember(SyntaxKind kind) 379810"];
16223 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 379811"];
16224 [label="param GetSourceTypeMember(this) 379812"];
16225 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 379813"];
16226 [label="kind.ToDeclarationKind().ToTypeKind() 379814"];
16227 [label="param ToTypeKind(this DeclarationKind kind) 379815"];
16228 [label="return TypeKind.Interface; 379816"];
16229 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 379817"];
16230 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 379818"];
16231 [label="GetTypeMembers(name, arity) 379819"];
16232 [label="param GetTypeMembers(string name) 379820"];
16233 [label="param GetTypeMembers(int arity) 379821"];
16234 [label="param GetTypeMembers(this) 379822"];
16235 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 379823"];
16236 [label="GetTypeMembers(name) 379824"];
16237 [label="param GetTypeMembers(string name) 379825"];
16238 [label="param GetTypeMembers(this) 379826"];
16239 [label="ImmutableArray<NamedTypeSymbol> members; 379827"];
16240 [label="members 379828"];
16241 [label="this.GetNameToTypeMembersMap() 379829"];
16242 [label="param GetNameToTypeMembersMap(this) 379830"];
16243 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 379831"];
16244 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 379832"];
16245 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 379833"];
16246 [label="GetNameToMembersMap() 379834"];
16247 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 379835"];
16248 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 379836"];
16249 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 379837"];
16250 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 379838"];
16251 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 379839"];
16252 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 379840"];
16253 [label="bool hasType = false; 379841"];
16254 [label="bool hasNamespace = false; 379842"];
16255 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 379843"];
16256 [label="symbol.Kind 379844"];
16257 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 379845"];
16258 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 379846"];
16259 [label="hasType = true; 379847"];
16260 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 379848"];
16261 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 379849"];
16262 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 379850"];
16263 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 379851"];
16264 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 379852"];
16265 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 379853"];
16266 [label="bool hasType = false; 379854"];
16267 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 379855"];
16268 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 379856"];
16269 [label="return dictionary; 379857"];
16270 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 379858"];
16271 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 379859"];
16272 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 379860"];
16273 [label="return _nameToTypeMembersMap; 379861"];
16274 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 379862"];
16275 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 379863"];
16276 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 379864"];
16277 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 379865"];
16278 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 379866"];
16279 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 379867"];
16280 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 379868"];
16281 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 379869"];
16282 [label="var memberT = member as SourceNamedTypeSymbol; 379870"];
16283 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 379871"];
16284 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 379872"];
16285 [label="memberT.TypeKind 379873"];
16286 [label="get\n            {\n                return _flags.TypeKind;\n            } 379874"];
16287 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 379875"];
16288 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 379876"];
16289 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 379877"];
16290 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 379878"];
16291 [label="memberT.Locations 379879"];
16292 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 379880"];
16293 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 379881"];
16294 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 379882"];
16295 [label="return memberT; 379883"];
16296 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 379884"];
16297 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 379885"];
16298 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 379886"];
16299 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 379887"];
16300 [label="new InContainerBinder(typeSymbol, resultBinder) 379888"];
16301 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 379889"];
16302 [label="param InContainerBinder(Binder next) 379890"];
16303 [label="param InContainerBinder(Imports imports = null) 379891"];
16304 [label="param InContainerBinder(this) 379892"];
16305 [label="next 379893"];
16306 [label="param InContainerBinder(this) 379894"];
16307 [label="param Binder(Binder next) 379895"];
16308 [label="param Binder(this) 379896"];
16309 [label="param Binder(Conversions? conversions = null) 379897"];
16310 [label="internal CSharpCompilation Compilation { get; } 379898"];
16311 [label="Flags 379899"];
16312 [label="protected internal Binder? Next { get; } 379900"];
16313 [label="_lazyConversions 379901"];
16314 [label="_lazyOverloadResolution 379902"];
16315 [label="RoslynDebug.Assert(next != null); 379903"];
16316 [label="RoslynDebug.Assert(next != null); 379904"];
16317 [label="this.Flags 379905"];
16318 [label="this.Compilation 379906"];
16319 [label="_lazyConversions 379907"];
16320 [label="_container 379908"];
16321 [label="_computeImports 379909"];
16322 [label="_lazyImports 379910"];
16323 [label="_lazyImportChain 379911"];
16324 [label="_lazyQuickAttributeChecker 379912"];
16325 [label="Debug.Assert((object)container != null || imports != null); 379913"];
16326 [label="Debug.Assert((object)container != null || imports != null); 379914"];
16327 [label="_container 379915"];
16328 [label="_lazyImports = imports ?? Imports.Empty; 379916"];
16329 [label="_lazyImports = imports ?? Imports.Empty; 379917"];
16330 [label="_lazyImports 379918"];
16331 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 379919"];
16332 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 379920"];
16333 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 379921"];
16334 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 379922"];
16335 [label="resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder); 379923"];
16336 [label="new WithClassTypeParametersBinder(typeSymbol, resultBinder) 379924"];
16337 [label="param WithClassTypeParametersBinder(NamedTypeSymbol container) 379925"];
16338 [label="param WithClassTypeParametersBinder(Binder next) 379926"];
16339 [label="param WithClassTypeParametersBinder(this) 379927"];
16340 [label="next 379928"];
16341 [label="param WithClassTypeParametersBinder(this) 379929"];
16342 [label="param WithTypeParametersBinder(Binder next) 379930"];
16343 [label="param WithTypeParametersBinder(this) 379931"];
16344 [label="next 379932"];
16345 [label="param WithTypeParametersBinder(this) 379933"];
16346 [label="param Binder(Binder next) 379934"];
16347 [label="internal CSharpCompilation Compilation { get; } 379935"];
16348 [label="Flags 379936"];
16349 [label="protected internal Binder? Next { get; } 379937"];
16350 [label="_lazyConversions 379938"];
16351 [label="RoslynDebug.Assert(next != null); 379939"];
16352 [label="RoslynDebug.Assert(next != null); 379940"];
16353 [label="this.Flags 379941"];
16354 [label="this.Compilation 379942"];
16355 [label="_namedType 379943"];
16356 [label="_lazyTypeParameterMap 379944"];
16357 [label="Debug.Assert((object)container != null); 379945"];
16358 [label="Debug.Assert((object)container != null); 379946"];
16359 [label="_namedType 379947"];
16360 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 379948"];
16361 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 379949"];
16362 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 379950"];
16363 [label="param WithUnsafeRegionIfNecessary(this) 379951"];
16364 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 379952"];
16365 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 379953"];
16366 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 379954"];
16367 [label="param Includes(this BinderFlags self) 379955"];
16368 [label="param Includes(BinderFlags other) 379956"];
16369 [label="return (self & other) == other; 379957"];
16370 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 379958"];
16371 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 379959"];
16372 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 379960"];
16373 [label="binderCache 379961"];
16374 [label="return _factory._binderCache; 379962"];
16375 [label="binderCache.TryAdd(key, resultBinder); 379963"];
16376 [label="binderCache.TryAdd(key, resultBinder); 379964"];
16377 [label="binderCache.TryAdd(key, resultBinder); 379965"];
16378 [label="binderCache.TryAdd(key, resultBinder); 379966"];
16379 [label="binderCache.TryAdd(key, resultBinder); 379967"];
16380 [label="return resultBinder; 379968"];
16381 [label="return ((CSharpSyntaxNode)node).Accept(this); 379969"];
16382 [label="_binderFactoryVisitorPool.Free(visitor); 379970"];
16383 [label="constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList); 379971"];
16384 [label="binder.GetDefaultTypeParameterConstraintClauses(typeParameterList) 379972"];
16385 [label="param GetDefaultTypeParameterConstraintClauses(TypeParameterListSyntax typeParameterList) 379973"];
16386 [label="param GetDefaultTypeParameterConstraintClauses(this) 379974"];
16387 [label="var builder = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(typeParameterList.Parameters.Count); 379975"];
16388 [label="foreach (TypeParameterSyntax typeParameterSyntax in typeParameterList.Parameters)\n            {\n                builder.Add(GetDefaultTypeParameterConstraintClause(typeParameterSyntax));\n            } 379976"];
16389 [label="builder.Add(GetDefaultTypeParameterConstraintClause(typeParameterSyntax)); 379977"];
16390 [label="GetDefaultTypeParameterConstraintClause(typeParameterSyntax) 379978"];
16391 [label="param GetDefaultTypeParameterConstraintClause(TypeParameterSyntax typeParameterSyntax) 379979"];
16392 [label="param GetDefaultTypeParameterConstraintClause(bool isForOverride = false) 379980"];
16393 [label="param GetDefaultTypeParameterConstraintClause(this) 379981"];
16394 [label="return isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) ? TypeParameterConstraintClause.Empty : TypeParameterConstraintClause.ObliviousNullabilityIfReferenceType; 379982"];
16395 [label="AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) 379983"];
16396 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 379984"];
16397 [label="param AreNullableAnnotationsEnabled(this) 379985"];
16398 [label="RoslynDebug.Assert(token.SyntaxTree is object); 379986"];
16399 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 379987"];
16400 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 379988"];
16401 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 379989"];
16402 [label="param AreNullableAnnotationsEnabled(int position) 379990"];
16403 [label="param AreNullableAnnotationsEnabled(this) 379991"];
16404 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 379992"];
16405 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 379993"];
16406 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 379994"];
16407 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 379995"];
16408 [label="this.Compilation.Options 379996"];
16409 [label="get\n            {\n                return _options;\n            } 379997"];
16410 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 379998"];
16411 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 379999"];
16412 [label="AreNullableAnnotationsGloballyEnabled() 380000"];
16413 [label="param AreNullableAnnotationsGloballyEnabled(this) 380001"];
16414 [label="RoslynDebug.Assert(Next is object); 380002"];
16415 [label="Next.AreNullableAnnotationsGloballyEnabled() 380003"];
16416 [label="param AreNullableAnnotationsGloballyEnabled(this) 380004"];
16417 [label="param AreNullableAnnotationsGloballyEnabled(this) 380005"];
16418 [label="GetGlobalAnnotationState() 380006"];
16419 [label="param GetGlobalAnnotationState(this) 380007"];
16420 [label="Compilation.Options 380008"];
16421 [label="get\n            {\n                return _options;\n            } 380009"];
16422 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 380010"];
16423 [label="return false; 380011"];
16424 [label="return GetGlobalAnnotationState(); 380012"];
16425 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 380013"];
16426 [label="return isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) ? TypeParameterConstraintClause.Empty : TypeParameterConstraintClause.ObliviousNullabilityIfReferenceType; 380014"];
16427 [label="isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) 380015"];
16428 [label="TypeParameterConstraintKind.None 380016"];
16429 [label="ImmutableArray<TypeWithAnnotations>.Empty 380017"];
16430 [label="new TypeParameterConstraintClause(\n            TypeParameterConstraintKind.None,\n            ImmutableArray<TypeWithAnnotations>.Empty) 380018"];
16431 [label="param TypeParameterConstraintClause(TypeParameterConstraintKind constraints) 380019"];
16432 [label="param TypeParameterConstraintClause(ImmutableArray<TypeWithAnnotations> constraintTypes) 380020"];
16433 [label="param TypeParameterConstraintClause(this) 380021"];
16434 [label="Constraints 380022"];
16435 [label="switch (constraints & TypeParameterConstraintKind.AllReferenceTypeKinds)\n            {\n                case TypeParameterConstraintKind.None:\n                case TypeParameterConstraintKind.ReferenceType:\n                case TypeParameterConstraintKind.NullableReferenceType:\n                case TypeParameterConstraintKind.NotNullableReferenceType:\n                    break;\n                default:\n                    ExceptionUtilities.UnexpectedValue(constraints); // This call asserts.\n                    break;\n            } 380023"];
16436 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380024"];
16437 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380025"];
16438 [label="this.Constraints 380026"];
16439 [label="this.ConstraintTypes 380027"];
16440 [label="Empty = new TypeParameterConstraintClause(\n            TypeParameterConstraintKind.None,\n            ImmutableArray<TypeWithAnnotations>.Empty) 380028"];
16441 [label="TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType 380029"];
16442 [label="ImmutableArray<TypeWithAnnotations>.Empty 380030"];
16443 [label="new TypeParameterConstraintClause(\n            TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType,\n            ImmutableArray<TypeWithAnnotations>.Empty) 380031"];
16444 [label="param TypeParameterConstraintClause(TypeParameterConstraintKind constraints) 380032"];
16445 [label="param TypeParameterConstraintClause(ImmutableArray<TypeWithAnnotations> constraintTypes) 380033"];
16446 [label="param TypeParameterConstraintClause(this) 380034"];
16447 [label="Constraints 380035"];
16448 [label="switch (constraints & TypeParameterConstraintKind.AllReferenceTypeKinds)\n            {\n                case TypeParameterConstraintKind.None:\n                case TypeParameterConstraintKind.ReferenceType:\n                case TypeParameterConstraintKind.NullableReferenceType:\n                case TypeParameterConstraintKind.NotNullableReferenceType:\n                    break;\n                default:\n                    ExceptionUtilities.UnexpectedValue(constraints); // This call asserts.\n                    break;\n            } 380036"];
16449 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380037"];
16450 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380038"];
16451 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380039"];
16452 [label="Debug.Assert((constraints & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) == 0 ||\n                         (constraints & ~(TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType | TypeParameterConstraintKind.Constructor | TypeParameterConstraintKind.Default |\n                                          TypeParameterConstraintKind.PartialMismatch | TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380040"];
16453 [label="this.Constraints 380041"];
16454 [label="this.ConstraintTypes 380042"];
16455 [label="ObliviousNullabilityIfReferenceType = new TypeParameterConstraintClause(\n            TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType,\n            ImmutableArray<TypeWithAnnotations>.Empty) 380043"];
16456 [label="return isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) ? TypeParameterConstraintClause.Empty : TypeParameterConstraintClause.ObliviousNullabilityIfReferenceType; 380044"];
16457 [label="builder.Add(GetDefaultTypeParameterConstraintClause(typeParameterSyntax)); 380045"];
16458 [label="param GetDefaultTypeParameterConstraintClause(bool isForOverride = false) 380046"];
16459 [label="param AreNullableAnnotationsGloballyEnabled(this) 380047"];
16460 [label="GetGlobalAnnotationState() 380048"];
16461 [label="param GetGlobalAnnotationState(this) 380049"];
16462 [label="Compilation.Options 380050"];
16463 [label="get\n            {\n                return _options;\n            } 380051"];
16464 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 380052"];
16465 [label="return false; 380053"];
16466 [label="return GetGlobalAnnotationState(); 380054"];
16467 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 380055"];
16468 [label="return isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) ? TypeParameterConstraintClause.Empty : TypeParameterConstraintClause.ObliviousNullabilityIfReferenceType; 380056"];
16469 [label="isForOverride || AreNullableAnnotationsEnabled(typeParameterSyntax.Identifier) 380057"];
16470 [label="return builder.ToImmutableAndFree(); 380058"];
16471 [label="Debug.Assert(constraints.Length == arity); 380059"];
16472 [label="if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    } 380060"];
16473 [label="if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    } 380061"];
16474 [label="results = constraints; 380062"];
16475 [label="results = MergeConstraintKindsForPartialDeclarations(results, otherPartialClauses); 380063"];
16476 [label="results = MergeConstraintKindsForPartialDeclarations(results, otherPartialClauses); 380064"];
16477 [label="MergeConstraintKindsForPartialDeclarations(results, otherPartialClauses) 380065"];
16478 [label="param MergeConstraintKindsForPartialDeclarations(ImmutableArray<TypeParameterConstraintClause> constraintClauses) 380066"];
16479 [label="param MergeConstraintKindsForPartialDeclarations(ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses) 380067"];
16480 [label="param MergeConstraintKindsForPartialDeclarations(this) 380068"];
16481 [label="if (otherPartialClauses == null)\n            {\n                return constraintClauses;\n            } 380069"];
16482 [label="if (otherPartialClauses == null)\n            {\n                return constraintClauses;\n            } 380070"];
16483 [label="return constraintClauses; 380071"];
16484 [label="results = ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results); 380072"];
16485 [label="results = ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results); 380073"];
16486 [label="results = ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results); 380074"];
16487 [label="ConstraintsHelper.AdjustConstraintKindsBasedOnConstraintTypes(this, typeParameters, results) 380075"];
16488 [label="param AdjustConstraintKindsBasedOnConstraintTypes(Symbol container) 380076"];
16489 [label="param AdjustConstraintKindsBasedOnConstraintTypes(ImmutableArray<TypeParameterSymbol> typeParameters) 380077"];
16490 [label="param AdjustConstraintKindsBasedOnConstraintTypes(ImmutableArray<TypeParameterConstraintClause> constraintClauses) 380078"];
16491 [label="int arity = typeParameters.Length; 380079"];
16492 [label="Debug.Assert(constraintClauses.Length == arity); 380080"];
16493 [label="SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap = TypeParameterConstraintClause.BuildIsValueTypeMap(container, typeParameters, constraintClauses); 380081"];
16494 [label="SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap = TypeParameterConstraintClause.BuildIsValueTypeMap(container, typeParameters, constraintClauses); 380082"];
16495 [label="SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap = TypeParameterConstraintClause.BuildIsValueTypeMap(container, typeParameters, constraintClauses); 380083"];
16496 [label="TypeParameterConstraintClause.BuildIsValueTypeMap(container, typeParameters, constraintClauses) 380084"];
16497 [label="param BuildIsValueTypeMap(Symbol container) 380085"];
16498 [label="param BuildIsValueTypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 380086"];
16499 [label="param BuildIsValueTypeMap(ImmutableArray<TypeParameterConstraintClause> constraintClauses) 380087"];
16500 [label="Debug.Assert(constraintClauses.Length == typeParameters.Length); 380088"];
16501 [label="var isValueTypeMap = new SmallDictionary<TypeParameterSymbol, bool>(ReferenceEqualityComparer.Instance); 380089"];
16502 [label="foreach (TypeParameterSymbol typeParameter in typeParameters)\n            {\n                isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty);\n            } 380090"];
16503 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty); 380091"];
16504 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty); 380092"];
16505 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty); 380093"];
16506 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty); 380094"];
16507 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty) 380095"];
16508 [label="static bool isValueType(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses, SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n\n                isValueTypeMap.Add(thisTypeParameter, result);\n                return result;\n            } 380096"];
16509 [label="static bool isValueType(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses, SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n\n                isValueTypeMap.Add(thisTypeParameter, result);\n                return result;\n            } 380097"];
16510 [label="static bool isValueType(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses, SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n\n                isValueTypeMap.Add(thisTypeParameter, result);\n                return result;\n            } 380098"];
16511 [label="static bool isValueType(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses, SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n\n                isValueTypeMap.Add(thisTypeParameter, result);\n                return result;\n            } 380099"];
16512 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380100"];
16513 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380101"];
16514 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380102"];
16515 [label="if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                } 380103"];
16516 [label="if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                } 380104"];
16517 [label="if (isValueTypeMap.TryGetValue(thisTypeParameter, out bool knownIsValueType))\n                {\n                    return knownIsValueType;\n                } 380105"];
16518 [label="thisTypeParameter.Ordinal 380106"];
16519 [label="get\n            {\n                return _ordinal;\n            } 380107"];
16520 [label="return _ordinal; 380108"];
16521 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380109"];
16522 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380110"];
16523 [label="bool result = false; 380111"];
16524 [label="if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                } 380112"];
16525 [label="if ((constraintClause.Constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0)\n                {\n                    result = true;\n                }\n                else\n                {\n                    Symbol container = thisTypeParameter.ContainingSymbol;\n                    inProgress = inProgress.Prepend(thisTypeParameter);\n\n                    foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                } 380113"];
16526 [label="thisTypeParameter.ContainingSymbol 380114"];
16527 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380115"];
16528 [label="inProgress = inProgress.Prepend(thisTypeParameter); 380116"];
16529 [label="inProgress = inProgress.Prepend(thisTypeParameter); 380117"];
16530 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    } 380118"];
16531 [label="isValueTypeMap.Add(thisTypeParameter, result); 380119"];
16532 [label="isValueTypeMap.Add(thisTypeParameter, result); 380120"];
16533 [label="isValueTypeMap.Add(thisTypeParameter, result); 380121"];
16534 [label="return result; 380122"];
16535 [label="isValueType(typeParameter, constraintClauses, isValueTypeMap, ConsList<TypeParameterSymbol>.Empty); 380123"];
16536 [label="thisTypeParameter.ContainingSymbol 380124"];
16537 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380125"];
16538 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    } 380126"];
16539 [label="return result; 380127"];
16540 [label="thisTypeParameter.ContainingSymbol 380128"];
16541 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380129"];
16542 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                    {\n                        TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                        if (type is TypeParameterSymbol typeParameter && (object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isValueType(typeParameter, constraintClauses, isValueTypeMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (type.IsValueType)\n                        {\n                            result = true;\n                            break;\n                        }\n                    } 380130"];
16543 [label="return isValueTypeMap; 380131"];
16544 [label="SmallDictionary<TypeParameterSymbol, bool> isValueTypeMap = TypeParameterConstraintClause.BuildIsValueTypeMap(container, typeParameters, constraintClauses); 380132"];
16545 [label="SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap = TypeParameterConstraintClause.BuildIsReferenceTypeFromConstraintTypesMap(container, typeParameters, constraintClauses); 380133"];
16546 [label="SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap = TypeParameterConstraintClause.BuildIsReferenceTypeFromConstraintTypesMap(container, typeParameters, constraintClauses); 380134"];
16547 [label="SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap = TypeParameterConstraintClause.BuildIsReferenceTypeFromConstraintTypesMap(container, typeParameters, constraintClauses); 380135"];
16548 [label="TypeParameterConstraintClause.BuildIsReferenceTypeFromConstraintTypesMap(container, typeParameters, constraintClauses) 380136"];
16549 [label="param BuildIsReferenceTypeFromConstraintTypesMap(Symbol container) 380137"];
16550 [label="param BuildIsReferenceTypeFromConstraintTypesMap(ImmutableArray<TypeParameterSymbol> typeParameters) 380138"];
16551 [label="param BuildIsReferenceTypeFromConstraintTypesMap(ImmutableArray<TypeParameterConstraintClause> constraintClauses) 380139"];
16552 [label="Debug.Assert(constraintClauses.Length == typeParameters.Length); 380140"];
16553 [label="var isReferenceTypeFromConstraintTypesMap = new SmallDictionary<TypeParameterSymbol, bool>(ReferenceEqualityComparer.Instance); 380141"];
16554 [label="var isReferenceTypeFromConstraintTypesMap = new SmallDictionary<TypeParameterSymbol, bool>(ReferenceEqualityComparer.Instance); 380142"];
16555 [label="foreach (TypeParameterSymbol typeParameter in typeParameters)\n            {\n                isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty);\n            } 380143"];
16556 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380144"];
16557 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380145"];
16558 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380146"];
16559 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380147"];
16560 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty) 380148"];
16561 [label="static bool isReferenceTypeFromConstraintTypes(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses,\n                                                           SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                Symbol container = thisTypeParameter.ContainingSymbol;\n                inProgress = inProgress.Prepend(thisTypeParameter);\n\n                foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                }\n\n                isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result);\n                return result;\n            } 380149"];
16562 [label="static bool isReferenceTypeFromConstraintTypes(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses,\n                                                           SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                Symbol container = thisTypeParameter.ContainingSymbol;\n                inProgress = inProgress.Prepend(thisTypeParameter);\n\n                foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                }\n\n                isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result);\n                return result;\n            } 380150"];
16563 [label="static bool isReferenceTypeFromConstraintTypes(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses,\n                                                           SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                Symbol container = thisTypeParameter.ContainingSymbol;\n                inProgress = inProgress.Prepend(thisTypeParameter);\n\n                foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                }\n\n                isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result);\n                return result;\n            } 380151"];
16564 [label="static bool isReferenceTypeFromConstraintTypes(TypeParameterSymbol thisTypeParameter, ImmutableArray<TypeParameterConstraintClause> constraintClauses,\n                                                           SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol> inProgress)\n            {\n                if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                }\n\n                TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal];\n\n                bool result = false;\n\n                Symbol container = thisTypeParameter.ContainingSymbol;\n                inProgress = inProgress.Prepend(thisTypeParameter);\n\n                foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                }\n\n                isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result);\n                return result;\n            } 380152"];
16565 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380153"];
16566 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380154"];
16567 [label="if (inProgress.ContainsReference(thisTypeParameter))\n                {\n                    return false;\n                } 380155"];
16568 [label="if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                } 380156"];
16569 [label="if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                } 380157"];
16570 [label="if (isReferenceTypeFromConstraintTypesMap.TryGetValue(thisTypeParameter, out bool knownIsReferenceTypeFromConstraintTypes))\n                {\n                    return knownIsReferenceTypeFromConstraintTypes;\n                } 380158"];
16571 [label="thisTypeParameter.Ordinal 380159"];
16572 [label="get\n            {\n                return _ordinal;\n            } 380160"];
16573 [label="return _ordinal; 380161"];
16574 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380162"];
16575 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380163"];
16576 [label="bool result = false; 380164"];
16577 [label="thisTypeParameter.ContainingSymbol 380165"];
16578 [label="get { return _owner; } 380166"];
16579 [label="return _owner; 380167"];
16580 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380168"];
16581 [label="inProgress = inProgress.Prepend(thisTypeParameter); 380169"];
16582 [label="inProgress = inProgress.Prepend(thisTypeParameter); 380170"];
16583 [label="inProgress = inProgress.Prepend(thisTypeParameter); 380171"];
16584 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                } 380172"];
16585 [label="isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result); 380173"];
16586 [label="isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result); 380174"];
16587 [label="isReferenceTypeFromConstraintTypesMap.Add(thisTypeParameter, result); 380175"];
16588 [label="return result; 380176"];
16589 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380177"];
16590 [label="isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, ConsList<TypeParameterSymbol>.Empty); 380178"];
16591 [label="thisTypeParameter.Ordinal 380179"];
16592 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380180"];
16593 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380181"];
16594 [label="thisTypeParameter.ContainingSymbol 380182"];
16595 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380183"];
16596 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                } 380184"];
16597 [label="return result; 380185"];
16598 [label="get\n            {\n                return _ordinal;\n            } 380186"];
16599 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380187"];
16600 [label="TypeParameterConstraintClause constraintClause = constraintClauses[thisTypeParameter.Ordinal]; 380188"];
16601 [label="get { return _owner; } 380189"];
16602 [label="Symbol container = thisTypeParameter.ContainingSymbol; 380190"];
16603 [label="foreach (TypeWithAnnotations constraintType in constraintClause.ConstraintTypes)\n                {\n                    TypeSymbol type = constraintType.IsResolved ? constraintType.Type : constraintType.DefaultType;\n\n                    if (type is TypeParameterSymbol typeParameter)\n                    {\n                        if ((object)typeParameter.ContainingSymbol == (object)container)\n                        {\n                            if (isReferenceTypeFromConstraintTypes(typeParameter, constraintClauses, isReferenceTypeFromConstraintTypesMap, inProgress))\n                            {\n                                result = true;\n                                break;\n                            }\n                        }\n                        else if (typeParameter.IsReferenceTypeFromConstraintTypes)\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    else if (TypeParameterSymbol.NonTypeParameterConstraintImpliesReferenceType(type))\n                    {\n                        result = true;\n                        break;\n                    }\n                } 380191"];
16604 [label="return isReferenceTypeFromConstraintTypesMap; 380192"];
16605 [label="SmallDictionary<TypeParameterSymbol, bool> isReferenceTypeFromConstraintTypesMap = TypeParameterConstraintClause.BuildIsReferenceTypeFromConstraintTypesMap(container, typeParameters, constraintClauses); 380193"];
16606 [label="ArrayBuilder<TypeParameterConstraintClause> builder = null; 380194"];
16607 [label="for (int i = 0; i < arity; i++)\n            {\n                var constraint = constraintClauses[i];\n                var typeParameter = typeParameters[i];\n                TypeParameterConstraintKind constraintKind = constraint.Constraints;\n\n                Debug.Assert((constraintKind & (TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0);\n\n                if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes;\n                }\n\n                if (constraint.Constraints != constraintKind)\n                {\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(constraintClauses.Length);\n                        builder.AddRange(constraintClauses);\n                    }\n\n                    builder[i] = TypeParameterConstraintClause.Create(constraintKind, constraint.ConstraintTypes);\n                }\n            } 380195"];
16608 [label="for (int i = 0; i < arity; i++)\n            {\n                var constraint = constraintClauses[i];\n                var typeParameter = typeParameters[i];\n                TypeParameterConstraintKind constraintKind = constraint.Constraints;\n\n                Debug.Assert((constraintKind & (TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0);\n\n                if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                }\n\n                if (isReferenceTypeFromConstraintTypesMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes;\n                }\n\n                if (constraint.Constraints != constraintKind)\n                {\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(constraintClauses.Length);\n                        builder.AddRange(constraintClauses);\n                    }\n\n                    builder[i] = TypeParameterConstraintClause.Create(constraintKind, constraint.ConstraintTypes);\n                }\n            } 380196"];
16609 [label="var constraint = constraintClauses[i]; 380197"];
16610 [label="var typeParameter = typeParameters[i]; 380198"];
16611 [label="TypeParameterConstraintKind constraintKind = constraint.Constraints; 380199"];
16612 [label="Debug.Assert((constraintKind & (TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380200"];
16613 [label="Debug.Assert((constraintKind & (TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380201"];
16614 [label="Debug.Assert((constraintKind & (TypeParameterConstraintKind.ValueTypeFromConstraintTypes | TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes)) == 0); 380202"];
16615 [label="if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                } 380203"];
16616 [label="if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                } 380204"];
16617 [label="if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                } 380205"];
16618 [label="if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                } 380206"];
16619 [label="if (isReferenceTypeFromConstraintTypesMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ReferenceTypeFromConstraintTypes;\n                } 380207"];
16620 [label="if (constraint.Constraints != constraintKind)\n                {\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(constraintClauses.Length);\n                        builder.AddRange(constraintClauses);\n                    }\n\n                    builder[i] = TypeParameterConstraintClause.Create(constraintKind, constraint.ConstraintTypes);\n                } 380208"];
16621 [label="if ((constraintKind & TypeParameterConstraintKind.AllValueTypeKinds) == 0 && isValueTypeMap[typeParameter])\n                {\n                    constraintKind |= TypeParameterConstraintKind.ValueTypeFromConstraintTypes;\n                } 380209"];
16622 [label="if (builder != null)\n            {\n                constraintClauses = builder.ToImmutableAndFree();\n            } 380210"];
16623 [label="if (builder != null)\n            {\n                constraintClauses = builder.ToImmutableAndFree();\n            } 380211"];
16624 [label="return constraintClauses; 380212"];
16625 [label="if (results.All(clause => clause.Constraints == TypeParameterConstraintKind.None))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                } 380213"];
16626 [label="if (results.All(clause => clause.Constraints == TypeParameterConstraintKind.None))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                } 380214"];
16627 [label="if (results.All(clause => clause.Constraints == TypeParameterConstraintKind.None))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                } 380215"];
16628 [label="otherPartialClauses?.Free(); 380216"];
16629 [label="return results.SelectAsArray(clause => clause.Constraints); 380217"];
16630 [label="return results.SelectAsArray(clause => clause.Constraints); 380218"];
16631 [label="return results.SelectAsArray(clause => clause.Constraints); 380219"];
16632 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintKinds, MakeTypeParameterConstraintKinds()); 380220"];
16633 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintKinds, MakeTypeParameterConstraintKinds()); 380221"];
16634 [label="constraintKinds = _lazyTypeParameterConstraintKinds; 380222"];
16635 [label="return constraintKinds; 380223"];
16636 [label="GetTypeParameterConstraintKinds(); 380224"];
16637 [label="var diagnostics = DiagnosticBag.GetInstance(); 380225"];
16638 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintTypes, MakeTypeParameterConstraintTypes(diagnostics)))\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 380226"];
16639 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintTypes, MakeTypeParameterConstraintTypes(diagnostics)))\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 380227"];
16640 [label="MakeTypeParameterConstraintTypes(diagnostics) 380228"];
16641 [label="param MakeTypeParameterConstraintTypes(DiagnosticBag diagnostics) 380229"];
16642 [label="param MakeTypeParameterConstraintTypes(this) 380230"];
16643 [label="this.TypeParameters 380231"];
16644 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 380232"];
16645 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 380233"];
16646 [label="return _lazyTypeParameters; 380234"];
16647 [label="var typeParameters = this.TypeParameters; 380235"];
16648 [label="var results = ImmutableArray<TypeParameterConstraintClause>.Empty; 380236"];
16649 [label="int arity = typeParameters.Length; 380237"];
16650 [label="if (arity > 0)\n            {\n                bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses();\n                ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null;\n\n                foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks);\n\n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, diagnostics, performOnlyCycleSafeValidation: false);\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                }\n\n                results = MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics);\n\n                if (results.All(clause => clause.ConstraintTypes.IsEmpty))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                }\n\n                otherPartialClauses?.Free();\n            } 380238"];
16651 [label="if (arity > 0)\n            {\n                bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses();\n                ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null;\n\n                foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks);\n\n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, diagnostics, performOnlyCycleSafeValidation: false);\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                }\n\n                results = MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics);\n\n                if (results.All(clause => clause.ConstraintTypes.IsEmpty))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                }\n\n                otherPartialClauses?.Free();\n            } 380239"];
16652 [label="SkipPartialDeclarationsWithoutConstraintClauses() 380240"];
16653 [label="param GetConstraintClauses(out TypeParameterListSyntax typeParameterList) 380241"];
16654 [label="return false; 380242"];
16655 [label="bool skipPartialDeclarationsWithoutConstraintClauses = SkipPartialDeclarationsWithoutConstraintClauses(); 380243"];
16656 [label="ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses = null; 380244"];
16657 [label="foreach (var decl in declaration.Declarations)\n                {\n                    var syntaxRef = decl.SyntaxReference;\n                    var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList);\n\n                    if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    }\n\n                    var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree);\n                    Binder binder;\n                    ImmutableArray<TypeParameterConstraintClause> constraints;\n\n                    if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks);\n\n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, diagnostics, performOnlyCycleSafeValidation: false);\n                    }\n\n                    Debug.Assert(constraints.Length == arity);\n\n                    if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    }\n                } 380245"];
16658 [label="var syntaxRef = decl.SyntaxReference; 380246"];
16659 [label="var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList); 380247"];
16660 [label="var constraintClauses = GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList); 380248"];
16661 [label="GetConstraintClauses((CSharpSyntaxNode)syntaxRef.GetSyntax(), out TypeParameterListSyntax typeParameterList) 380249"];
16662 [label="param GetConstraintClauses(CSharpSyntaxNode node) 380250"];
16663 [label="param GetConstraintClauses(out TypeParameterListSyntax typeParameterList) 380251"];
16664 [label="if (skipPartialDeclarationsWithoutConstraintClauses && constraintClauses.Count == 0)\n                    {\n                        continue;\n                    } 380252"];
16665 [label="this.DeclaringCompilation 380253"];
16666 [label="this.Kind 380254"];
16667 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 380255"];
16668 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380256"];
16669 [label="return _containingSymbol; 380257"];
16670 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 380258"];
16671 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 380259"];
16672 [label="var binderFactory = this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree); 380260"];
16673 [label="this.DeclaringCompilation.GetBinderFactory(syntaxRef.SyntaxTree) 380261"];
16674 [label="param GetBinderFactory(SyntaxTree syntaxTree) 380262"];
16675 [label="param GetBinderFactory(bool ignoreAccessibility = false) 380263"];
16676 [label="param GetBinderFactory(this) 380264"];
16677 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 380265"];
16678 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 380266"];
16679 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 380267"];
16680 [label="Binder binder; 380268"];
16681 [label="ImmutableArray<TypeParameterConstraintClause> constraints; 380269"];
16682 [label="constraints 380270"];
16683 [label="if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks);\n\n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, diagnostics, performOnlyCycleSafeValidation: false);\n                    } 380271"];
16684 [label="if (constraintClauses.Count == 0)\n                    {\n                        binder = binderFactory.GetBinder(typeParameterList.Parameters[0]);\n\n                        constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList);\n                    }\n                    else\n                    {\n                        binder = binderFactory.GetBinder(constraintClauses[0]);\n\n                        // Wrap binder from factory in a generic constraints specific binder \n                        // to avoid checking constraints when binding type names.\n                        Debug.Assert(!binder.Flags.Includes(BinderFlags.GenericConstraintsClause));\n                        binder = binder.WithContainingMemberOrLambda(this).WithAdditionalFlags(BinderFlags.GenericConstraintsClause | BinderFlags.SuppressConstraintChecks);\n\n                        constraints = binder.BindTypeParameterConstraintClauses(this, typeParameters, typeParameterList, constraintClauses, diagnostics, performOnlyCycleSafeValidation: false);\n                    } 380272"];
16685 [label="binder = binderFactory.GetBinder(typeParameterList.Parameters[0]); 380273"];
16686 [label="binder = binderFactory.GetBinder(typeParameterList.Parameters[0]); 380274"];
16687 [label="binderFactory.GetBinder(typeParameterList.Parameters[0]) 380275"];
16688 [label="param GetBinder(SyntaxNode node) 380276"];
16689 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 380277"];
16690 [label="param GetBinder(Symbol memberOpt = null) 380278"];
16691 [label="param GetBinder(this) 380279"];
16692 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 380280"];
16693 [label="Debug.Assert(node != null); 380281"];
16694 [label="Debug.Assert(node != null); 380282"];
16695 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 380283"];
16696 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 380284"];
16697 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 380285"];
16698 [label="memberDeclarationOpt == null 380286"];
16699 [label="param ==(Symbol left) 380287"];
16700 [label="param ==(Symbol right) 380288"];
16701 [label="if (right is null)\n            {\n                return left is null;\n            } 380289"];
16702 [label="return left is null; 380290"];
16703 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 380291"];
16704 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 380292"];
16705 [label="NodeUsage extraInfo = NodeUsage.Normal; 380293"];
16706 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 380294"];
16707 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 380295"];
16708 [label="constraints = binder.GetDefaultTypeParameterConstraintClauses(typeParameterList); 380296"];
16709 [label="binder.GetDefaultTypeParameterConstraintClauses(typeParameterList) 380297"];
16710 [label="param GetDefaultTypeParameterConstraintClauses(TypeParameterListSyntax typeParameterList) 380298"];
16711 [label="param GetDefaultTypeParameterConstraintClauses(this) 380299"];
16712 [label="var builder = ArrayBuilder<TypeParameterConstraintClause>.GetInstance(typeParameterList.Parameters.Count); 380300"];
16713 [label="foreach (TypeParameterSyntax typeParameterSyntax in typeParameterList.Parameters)\n            {\n                builder.Add(GetDefaultTypeParameterConstraintClause(typeParameterSyntax));\n            } 380301"];
16714 [label="Debug.Assert(constraints.Length == arity); 380302"];
16715 [label="if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    } 380303"];
16716 [label="if (results.Length == 0)\n                    {\n                        results = constraints;\n                    }\n                    else\n                    {\n                        // LAFHIS\n                        if (otherPartialClauses == null)\n                        { \n                            otherPartialClauses = ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>>.GetInstance();\n                            otherPartialClauses.Add(constraints);\n                        }\n                    } 380304"];
16717 [label="results = constraints; 380305"];
16718 [label="results = MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics); 380306"];
16719 [label="results = MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics); 380307"];
16720 [label="results = MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics); 380308"];
16721 [label="MergeConstraintTypesForPartialDeclarations(results, otherPartialClauses, diagnostics) 380309"];
16722 [label="param MergeConstraintTypesForPartialDeclarations(ImmutableArray<TypeParameterConstraintClause> constraintClauses) 380310"];
16723 [label="param MergeConstraintTypesForPartialDeclarations(ArrayBuilder<ImmutableArray<TypeParameterConstraintClause>> otherPartialClauses) 380311"];
16724 [label="param MergeConstraintTypesForPartialDeclarations(DiagnosticBag diagnostics) 380312"];
16725 [label="param MergeConstraintTypesForPartialDeclarations(this) 380313"];
16726 [label="if (otherPartialClauses == null)\n            {\n                return constraintClauses;\n            } 380314"];
16727 [label="if (otherPartialClauses == null)\n            {\n                return constraintClauses;\n            } 380315"];
16728 [label="return constraintClauses; 380316"];
16729 [label="if (results.All(clause => clause.ConstraintTypes.IsEmpty))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                } 380317"];
16730 [label="if (results.All(clause => clause.ConstraintTypes.IsEmpty))\n                {\n                    results = ImmutableArray<TypeParameterConstraintClause>.Empty;\n                } 380318"];
16731 [label="results = ImmutableArray<TypeParameterConstraintClause>.Empty; 380319"];
16732 [label="otherPartialClauses?.Free(); 380320"];
16733 [label="return results.SelectAsArray(clause => clause.ConstraintTypes); 380321"];
16734 [label="return results.SelectAsArray(clause => clause.ConstraintTypes); 380322"];
16735 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraintTypes, MakeTypeParameterConstraintTypes(diagnostics)))\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 380323"];
16736 [label="this.AddDeclarationDiagnostics(diagnostics); 380324"];
16737 [label="this.AddDeclarationDiagnostics(diagnostics) 380325"];
16738 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 380326"];
16739 [label="param AddDeclarationDiagnostics(this) 380327"];
16740 [label="ContainingSymbol 380328"];
16741 [label="get\n            {\n                return _containingSymbol;\n            } 380329"];
16742 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 380330"];
16743 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 380331"];
16744 [label="this.AddDeclarationDiagnostics(diagnostics); 380332"];
16745 [label="diagnostics.Free(); 380333"];
16746 [label="constraintTypes = _lazyTypeParameterConstraintTypes; 380334"];
16747 [label="return constraintTypes; 380335"];
16748 [label="var constraintTypes = GetTypeParameterConstraintTypes(); 380336"];
16749 [label="return (constraintTypes.Length > 0) ? constraintTypes[ordinal] : ImmutableArray<TypeWithAnnotations>.Empty; 380337"];
16750 [label="return (constraintTypes.Length > 0) ? constraintTypes[ordinal] : ImmutableArray<TypeWithAnnotations>.Empty; 380338"];
16751 [label="(constraintTypes.Length > 0) 380339"];
16752 [label="var constraintTypes = _owner.GetTypeParameterConstraintTypes(this.Ordinal); 380340"];
16753 [label="GetConstraintKinds() 380341"];
16754 [label="param GetConstraintKinds(this) 380342"];
16755 [label="this.Ordinal 380343"];
16756 [label="get\n            {\n                return _ordinal;\n            } 380344"];
16757 [label="return _ordinal; 380345"];
16758 [label="return _owner.GetTypeParameterConstraintKind(this.Ordinal); 380346"];
16759 [label="_owner.GetTypeParameterConstraintKind(this.Ordinal) 380347"];
16760 [label="param GetTypeParameterConstraintKind(int ordinal) 380348"];
16761 [label="param GetTypeParameterConstraintKind(this) 380349"];
16762 [label="GetTypeParameterConstraintKinds() 380350"];
16763 [label="param GetTypeParameterConstraintKinds(this) 380351"];
16764 [label="return constraintKinds; 380352"];
16765 [label="var constraintKinds = GetTypeParameterConstraintKinds(); 380353"];
16766 [label="return (constraintKinds.Length > 0) ? constraintKinds[ordinal] : TypeParameterConstraintKind.None; 380354"];
16767 [label="return (constraintKinds.Length > 0) ? constraintKinds[ordinal] : TypeParameterConstraintKind.None; 380355"];
16768 [label="(constraintKinds.Length > 0) 380356"];
16769 [label="return (constraintKinds.Length > 0) ? constraintKinds[ordinal] : TypeParameterConstraintKind.None; 380357"];
16770 [label="if (constraintTypes.IsEmpty && GetConstraintKinds() == TypeParameterConstraintKind.None)\n            {\n                return null;\n            } 380358"];
16771 [label="if (constraintTypes.IsEmpty && GetConstraintKinds() == TypeParameterConstraintKind.None)\n            {\n                return null;\n            } 380359"];
16772 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380360"];
16773 [label="this.ContainingAssembly 380361"];
16774 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 380362"];
16775 [label="this.ContainingSymbol 380363"];
16776 [label="get { return _owner; } 380364"];
16777 [label="return _owner; 380365"];
16778 [label="var container = this.ContainingSymbol; 380366"];
16779 [label="return (object)container != null ? container.ContainingAssembly : null; 380367"];
16780 [label="return (object)container != null ? container.ContainingAssembly : null; 380368"];
16781 [label="(object)container != null 380369"];
16782 [label="container.ContainingAssembly 380370"];
16783 [label="=> _module.ContainingAssembly 380371"];
16784 [label="_module.ContainingAssembly 380372"];
16785 [label="get\n            {\n                return _assemblySymbol;\n            } 380373"];
16786 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380374"];
16787 [label="this.ContainingAssembly.CorLibrary 380375"];
16788 [label="get\n            {\n                return _corLibrary;\n            } 380376"];
16789 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380377"];
16790 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380378"];
16791 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380379"];
16792 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380380"];
16793 [label="this.DeclaringCompilation 380381"];
16794 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 380382"];
16795 [label="this.Kind 380383"];
16796 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380384"];
16797 [label="return SymbolKind.TypeParameter; 380385"];
16798 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380386"];
16799 [label="return _owner; 380387"];
16800 [label="return this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics); 380388"];
16801 [label="this.ResolveBounds(this.ContainingAssembly.CorLibrary, inProgress.Prepend(this), constraintTypes, inherited: false, this.DeclaringCompilation, diagnostics) 380389"];
16802 [label="param ResolveBounds(this TypeParameterSymbol typeParameter) 380390"];
16803 [label="param ResolveBounds(AssemblySymbol corLibrary) 380391"];
16804 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380392"];
16805 [label="param ResolveBounds(ImmutableArray<TypeWithAnnotations> constraintTypes) 380393"];
16806 [label="param ResolveBounds(bool inherited) 380394"];
16807 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380395"];
16808 [label="param ResolveBounds(DiagnosticBag diagnostics) 380396"];
16809 [label="var diagnosticsBuilder = ArrayBuilder<TypeParameterDiagnosticInfo>.GetInstance(); 380397"];
16810 [label="ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder = null; 380398"];
16811 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380399"];
16812 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380400"];
16813 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380401"];
16814 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380402"];
16815 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380403"];
16816 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380404"];
16817 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380405"];
16818 [label="var bounds = typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder); 380406"];
16819 [label="typeParameter.ResolveBounds(corLibrary, inProgress, constraintTypes, inherited, currentCompilation, diagnosticsBuilder, ref useSiteDiagnosticsBuilder) 380407"];
16820 [label="param ResolveBounds(this TypeParameterSymbol typeParameter) 380408"];
16821 [label="param ResolveBounds(AssemblySymbol corLibrary) 380409"];
16822 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380410"];
16823 [label="param ResolveBounds(ImmutableArray<TypeWithAnnotations> constraintTypes) 380411"];
16824 [label="param ResolveBounds(bool inherited) 380412"];
16825 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380413"];
16826 [label="param ResolveBounds(ArrayBuilder<TypeParameterDiagnosticInfo> diagnosticsBuilder) 380414"];
16827 [label="param ResolveBounds(ref ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder) 380415"];
16828 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380416"];
16829 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380417"];
16830 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380418"];
16831 [label="typeParameter.IsFromCompilation(currentCompilation) 380419"];
16832 [label="param IsFromCompilation(CSharpCompilation compilation) 380420"];
16833 [label="param IsFromCompilation(this) 380421"];
16834 [label="Debug.Assert(compilation != null); 380422"];
16835 [label="Debug.Assert(compilation != null); 380423"];
16836 [label="this.DeclaringCompilation 380424"];
16837 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 380425"];
16838 [label="this.Kind 380426"];
16839 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380427"];
16840 [label="return SymbolKind.TypeParameter; 380428"];
16841 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380429"];
16842 [label="return _owner; 380430"];
16843 [label="return compilation == this.DeclaringCompilation; 380431"];
16844 [label="return compilation == this.DeclaringCompilation; 380432"];
16845 [label="ImmutableArray<NamedTypeSymbol> interfaces; 380433"];
16846 [label="interfaces 380434"];
16847 [label="typeParameter.HasValueTypeConstraint 380435"];
16848 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0;\n            } 380436"];
16849 [label="this.GetConstraintKinds() 380437"];
16850 [label="param GetConstraintKinds(this) 380438"];
16851 [label="this.Ordinal 380439"];
16852 [label="get\n            {\n                return _ordinal;\n            } 380440"];
16853 [label="return _ordinal; 380441"];
16854 [label="_owner.GetTypeParameterConstraintKind(this.Ordinal) 380442"];
16855 [label="param GetTypeParameterConstraintKind(this) 380443"];
16856 [label="GetTypeParameterConstraintKinds() 380444"];
16857 [label="return (constraintKinds.Length > 0) ? constraintKinds[ordinal] : TypeParameterConstraintKind.None; 380445"];
16858 [label="var constraints = this.GetConstraintKinds(); 380446"];
16859 [label="return (constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0; 380447"];
16860 [label="return (constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0; 380448"];
16861 [label="NamedTypeSymbol effectiveBaseClass = corLibrary.GetSpecialType(typeParameter.HasValueTypeConstraint ? SpecialType.System_ValueType : SpecialType.System_Object); 380449"];
16862 [label="corLibrary.GetSpecialType(typeParameter.HasValueTypeConstraint ? SpecialType.System_ValueType : SpecialType.System_Object) 380450"];
16863 [label="param GetSpecialType(SpecialType type) 380451"];
16864 [label="param GetSpecialType(this) 380452"];
16865 [label="return _corLibrary; 380453"];
16866 [label="this.Modules 380454"];
16867 [label="get\n            {\n                return _modules;\n            } 380455"];
16868 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 380456"];
16869 [label="module.GetReferencedAssemblies() 380457"];
16870 [label="param GetReferencedAssemblies(this) 380458"];
16871 [label="AssertReferencesInitialized() 380459"];
16872 [label="param AssertReferencesInitialized(this) 380460"];
16873 [label="Debug.Assert(_moduleReferences != null); 380461"];
16874 [label="Debug.Assert(_moduleReferences != null); 380462"];
16875 [label="AssertReferencesInitialized(); 380463"];
16876 [label="return _moduleReferences.Identities; 380464"];
16877 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380465"];
16878 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380466"];
16879 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380467"];
16880 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380468"];
16881 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380469"];
16882 [label="return _lazySpecialTypes[(int)type]; 380470"];
16883 [label="TypeSymbol deducedBaseType = effectiveBaseClass; 380471"];
16884 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380472"];
16885 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380473"];
16886 [label="interfaces = ImmutableArray<NamedTypeSymbol>.Empty; 380474"];
16887 [label="effectiveBaseClass.SpecialType 380475"];
16888 [label="get\n            {\n                return _corTypeId;\n            } 380476"];
16889 [label="Debug.Assert((effectiveBaseClass.SpecialType == SpecialType.System_Object) || (deducedBaseType.SpecialType != SpecialType.System_Object)); 380477"];
16890 [label="if ((constraintTypes.Length == 0) && (deducedBaseType.SpecialType == SpecialType.System_Object))\n            {\n                Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object);\n                Debug.Assert(interfaces.Length == 0);\n                return null;\n            } 380478"];
16891 [label="if ((constraintTypes.Length == 0) && (deducedBaseType.SpecialType == SpecialType.System_Object))\n            {\n                Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object);\n                Debug.Assert(interfaces.Length == 0);\n                return null;\n            } 380479"];
16892 [label="deducedBaseType.SpecialType 380480"];
16893 [label="get\n            {\n                return _corTypeId;\n            } 380481"];
16894 [label="if ((constraintTypes.Length == 0) && (deducedBaseType.SpecialType == SpecialType.System_Object))\n            {\n                Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object);\n                Debug.Assert(interfaces.Length == 0);\n                return null;\n            } 380482"];
16895 [label="if ((constraintTypes.Length == 0) && (deducedBaseType.SpecialType == SpecialType.System_Object))\n            {\n                Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object);\n                Debug.Assert(interfaces.Length == 0);\n                return null;\n            } 380483"];
16896 [label="effectiveBaseClass.SpecialType 380484"];
16897 [label="Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object); 380485"];
16898 [label="Debug.Assert(interfaces.Length == 0); 380486"];
16899 [label="Debug.Assert(interfaces.Length == 0); 380487"];
16900 [label="return null; 380488"];
16901 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380489"];
16902 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380490"];
16903 [label="foreach (var pair in diagnosticsBuilder)\n            {\n                diagnostics.Add(new CSDiagnostic(pair.DiagnosticInfo, pair.TypeParameter.Locations[0]));\n            } 380491"];
16904 [label="diagnosticsBuilder.Free(); 380492"];
16905 [label="return bounds; 380493"];
16906 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBounds, bounds, TypeParameterBounds.Unset), TypeParameterBounds.Unset))\n                {\n                    this.CheckConstraintTypeConstraints(diagnostics);\n                    this.CheckUnmanagedConstraint(diagnostics);\n                    this.EnsureAttributesFromConstraints(diagnostics);\n                    this.AddDeclarationDiagnostics(diagnostics);\n                    _state.NotePartComplete(CompletionPart.TypeParameterConstraints);\n                } 380494"];
16907 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBounds, bounds, TypeParameterBounds.Unset), TypeParameterBounds.Unset))\n                {\n                    this.CheckConstraintTypeConstraints(diagnostics);\n                    this.CheckUnmanagedConstraint(diagnostics);\n                    this.EnsureAttributesFromConstraints(diagnostics);\n                    this.AddDeclarationDiagnostics(diagnostics);\n                    _state.NotePartComplete(CompletionPart.TypeParameterConstraints);\n                } 380495"];
16908 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBounds, bounds, TypeParameterBounds.Unset), TypeParameterBounds.Unset))\n                {\n                    this.CheckConstraintTypeConstraints(diagnostics);\n                    this.CheckUnmanagedConstraint(diagnostics);\n                    this.EnsureAttributesFromConstraints(diagnostics);\n                    this.AddDeclarationDiagnostics(diagnostics);\n                    _state.NotePartComplete(CompletionPart.TypeParameterConstraints);\n                } 380496"];
16909 [label="this.CheckConstraintTypeConstraints(diagnostics); 380497"];
16910 [label="this.CheckConstraintTypeConstraints(diagnostics) 380498"];
16911 [label="param CheckConstraintTypeConstraints(DiagnosticBag diagnostics) 380499"];
16912 [label="param CheckConstraintTypeConstraints(this) 380500"];
16913 [label="this.ConstraintTypesNoUseSiteDiagnostics 380501"];
16914 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 380502"];
16915 [label="this.EnsureAllConstraintsAreResolved(); 380503"];
16916 [label="return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 380504"];
16917 [label="this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 380505"];
16918 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 380506"];
16919 [label="param GetConstraintTypes(this) 380507"];
16920 [label="Debug.Assert(!inProgress.ContainsReference(this)); 380508"];
16921 [label="return _lazyBounds; 380509"];
16922 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380510"];
16923 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380511"];
16924 [label="(bounds != null) 380512"];
16925 [label="var constraintTypes = this.ConstraintTypesNoUseSiteDiagnostics; 380513"];
16926 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380514"];
16927 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380515"];
16928 [label="return; 380516"];
16929 [label="this.CheckConstraintTypeConstraints(diagnostics); 380517"];
16930 [label="this.CheckUnmanagedConstraint(diagnostics); 380518"];
16931 [label="this.CheckUnmanagedConstraint(diagnostics) 380519"];
16932 [label="param CheckUnmanagedConstraint(DiagnosticBag diagnostics) 380520"];
16933 [label="param CheckUnmanagedConstraint(this) 380521"];
16934 [label="this.HasUnmanagedTypeConstraint 380522"];
16935 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.Unmanaged) != 0;\n            } 380523"];
16936 [label="this.GetConstraintKinds() 380524"];
16937 [label="param GetConstraintKinds(this) 380525"];
16938 [label="return _ordinal; 380526"];
16939 [label="param GetTypeParameterConstraintKind(this) 380527"];
16940 [label="var constraints = this.GetConstraintKinds(); 380528"];
16941 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380529"];
16942 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380530"];
16943 [label="if (this.HasUnmanagedTypeConstraint)\n            {\n                DeclaringCompilation.EnsureIsUnmanagedAttributeExists(diagnostics, this.GetNonNullSyntaxNode().Location, ModifyCompilationForAttributeEmbedding());\n            } 380531"];
16944 [label="this.CheckUnmanagedConstraint(diagnostics); 380532"];
16945 [label="this.EnsureAttributesFromConstraints(diagnostics); 380533"];
16946 [label="this.EnsureAttributesFromConstraints(diagnostics) 380534"];
16947 [label="param EnsureAttributesFromConstraints(DiagnosticBag diagnostics) 380535"];
16948 [label="param EnsureAttributesFromConstraints(this) 380536"];
16949 [label="ConstraintTypesNoUseSiteDiagnostics 380537"];
16950 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 380538"];
16951 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 380539"];
16952 [label="this.EnsureAllConstraintsAreResolved(); 380540"];
16953 [label="return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 380541"];
16954 [label="this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 380542"];
16955 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 380543"];
16956 [label="param GetConstraintTypes(this) 380544"];
16957 [label="Debug.Assert(!inProgress.ContainsReference(this)); 380545"];
16958 [label="return _lazyBounds; 380546"];
16959 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380547"];
16960 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380548"];
16961 [label="(bounds != null) 380549"];
16962 [label="if (ConstraintTypesNoUseSiteDiagnostics.Any(t => t.ContainsNativeInteger()))\n            {\n                DeclaringCompilation.EnsureNativeIntegerAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380550"];
16963 [label="if (ConstraintTypesNoUseSiteDiagnostics.Any(t => t.ContainsNativeInteger()))\n            {\n                DeclaringCompilation.EnsureNativeIntegerAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380551"];
16964 [label="ConstraintsNeedNullableAttribute() 380552"];
16965 [label="param ConstraintsNeedNullableAttribute(this) 380553"];
16966 [label="DeclaringCompilation 380554"];
16967 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 380555"];
16968 [label="this.Kind 380556"];
16969 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380557"];
16970 [label="return SymbolKind.TypeParameter; 380558"];
16971 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380559"];
16972 [label="return _owner; 380560"];
16973 [label="if (!DeclaringCompilation.ShouldEmitNullableAttributes(this))\n            {\n                return false;\n            } 380561"];
16974 [label="if (!DeclaringCompilation.ShouldEmitNullableAttributes(this))\n            {\n                return false;\n            } 380562"];
16975 [label="DeclaringCompilation.ShouldEmitNullableAttributes(this) 380563"];
16976 [label="param ShouldEmitNullableAttributes(Symbol symbol) 380564"];
16977 [label="param ShouldEmitNullableAttributes(this) 380565"];
16978 [label="RoslynDebug.Assert(symbol is object); 380566"];
16979 [label="RoslynDebug.Assert(symbol is object); 380567"];
16980 [label="symbol.IsDefinition 380568"];
16981 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 380569"];
16982 [label="get\n            {\n                return this.OriginalDefinition;\n            } 380570"];
16983 [label="this.OriginalDefinition 380571"];
16984 [label="get\n            {\n                return this;\n            } 380572"];
16985 [label="return this; 380573"];
16986 [label="return this.OriginalDefinition; 380574"];
16987 [label="Debug.Assert(symbol.IsDefinition); 380575"];
16988 [label="symbol.ContainingModule 380576"];
16989 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 380577"];
16990 [label="return _owner; 380578"];
16991 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380579"];
16992 [label="SourceModule 380580"];
16993 [label="get\n            {\n                return Assembly.Modules[0];\n            } 380581"];
16994 [label="Assembly 380582"];
16995 [label="get\n            {\n                return SourceAssembly;\n            } 380583"];
16996 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 380584"];
16997 [label="return _referenceManager; 380585"];
16998 [label="GetBoundReferenceManager(); 380586"];
16999 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 380587"];
17000 [label="return Assembly.Modules[0]; 380588"];
17001 [label="Assembly.Modules 380589"];
17002 [label="get\n            {\n                return _modules;\n            } 380590"];
17003 [label="return Assembly.Modules[0]; 380591"];
17004 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380592"];
17005 [label="symbol.ContainingModule != SourceModule 380593"];
17006 [label="param !=(Symbol left) 380594"];
17007 [label="param !=(Symbol right) 380595"];
17008 [label="if (right is null)\n            {\n                return left is object;\n            } 380596"];
17009 [label="return (object)left != (object)right && !right.Equals(left); 380597"];
17010 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380598"];
17011 [label="EmitNullablePublicOnly 380599"];
17012 [label="get\n            {\n                if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                }\n                return _lazyEmitNullablePublicOnly.Value();\n            } 380600"];
17013 [label="if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                } 380601"];
17014 [label="SyntaxTrees 380602"];
17015 [label="var firstSt = SyntaxTrees.FirstOrDefault(); 380603"];
17016 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 380604"];
17017 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 380605"];
17018 [label="_lazyEmitNullablePublicOnly = value.ToThreeState(); 380606"];
17019 [label="_lazyEmitNullablePublicOnly 380607"];
17020 [label="return _lazyEmitNullablePublicOnly.Value(); 380608"];
17021 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 380609"];
17022 [label="return true; 380610"];
17023 [label="this.HasReferenceTypeConstraint 380611"];
17024 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.ReferenceType) != 0;\n            } 380612"];
17025 [label="this.GetConstraintKinds() 380613"];
17026 [label="param GetConstraintKinds(this) 380614"];
17027 [label="return _ordinal; 380615"];
17028 [label="param GetTypeParameterConstraintKind(this) 380616"];
17029 [label="return (constraintKinds.Length > 0) ? constraintKinds[ordinal] : TypeParameterConstraintKind.None; 380617"];
17030 [label="var constraints = this.GetConstraintKinds(); 380618"];
17031 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380619"];
17032 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380620"];
17033 [label="if (this.HasReferenceTypeConstraint && this.ReferenceTypeConstraintIsNullable != null)\n            {\n                return true;\n            } 380621"];
17034 [label="this.ConstraintTypesNoUseSiteDiagnostics 380622"];
17035 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 380623"];
17036 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 380624"];
17037 [label="this.EnsureAllConstraintsAreResolved(); 380625"];
17038 [label="return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 380626"];
17039 [label="this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 380627"];
17040 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 380628"];
17041 [label="param GetConstraintTypes(this) 380629"];
17042 [label="Debug.Assert(!inProgress.ContainsReference(this)); 380630"];
17043 [label="return _lazyBounds; 380631"];
17044 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380632"];
17045 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380633"];
17046 [label="(bounds != null) 380634"];
17047 [label="if (this.ConstraintTypesNoUseSiteDiagnostics.Any(c => c.NeedsNullableAttribute()))\n            {\n                return true;\n            } 380635"];
17048 [label="if (this.ConstraintTypesNoUseSiteDiagnostics.Any(c => c.NeedsNullableAttribute()))\n            {\n                return true;\n            } 380636"];
17049 [label="this.HasNotNullConstraint 380637"];
17050 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.NotNull) != 0;\n            } 380638"];
17051 [label="this.GetConstraintKinds() 380639"];
17052 [label="param GetConstraintKinds(this) 380640"];
17053 [label="return _ordinal; 380641"];
17054 [label="param GetTypeParameterConstraintKind(this) 380642"];
17055 [label="var constraints = this.GetConstraintKinds(); 380643"];
17056 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380644"];
17057 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380645"];
17058 [label="if (this.HasNotNullConstraint)\n            {\n                return true;\n            } 380646"];
17059 [label="this.HasReferenceTypeConstraint 380647"];
17060 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.ReferenceType) != 0;\n            } 380648"];
17061 [label="this.GetConstraintKinds() 380649"];
17062 [label="param GetConstraintKinds(this) 380650"];
17063 [label="return _ordinal; 380651"];
17064 [label="param GetTypeParameterConstraintKind(this) 380652"];
17065 [label="var constraints = this.GetConstraintKinds(); 380653"];
17066 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380654"];
17067 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380655"];
17068 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380656"];
17069 [label="this.HasValueTypeConstraint 380657"];
17070 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.AllValueTypeKinds) != 0;\n            } 380658"];
17071 [label="return _ordinal; 380659"];
17072 [label="param GetTypeParameterConstraintKind(this) 380660"];
17073 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380661"];
17074 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380662"];
17075 [label="this.ConstraintTypesNoUseSiteDiagnostics 380663"];
17076 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty);\n            } 380664"];
17077 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 380665"];
17078 [label="this.EnsureAllConstraintsAreResolved(); 380666"];
17079 [label="return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 380667"];
17080 [label="this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 380668"];
17081 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 380669"];
17082 [label="param GetConstraintTypes(this) 380670"];
17083 [label="Debug.Assert(!inProgress.ContainsReference(this)); 380671"];
17084 [label="return _lazyBounds; 380672"];
17085 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380673"];
17086 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380674"];
17087 [label="(bounds != null) 380675"];
17088 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380676"];
17089 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380677"];
17090 [label="this.IsNotNullable 380678"];
17091 [label="get\n            {\n                if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                }\n\n                return CalculateIsNotNullable();\n            } 380679"];
17092 [label="this.GetConstraintKinds() 380680"];
17093 [label="param GetConstraintKinds(this) 380681"];
17094 [label="return _ordinal; 380682"];
17095 [label="param GetTypeParameterConstraintKind(this) 380683"];
17096 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 380684"];
17097 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 380685"];
17098 [label="return null; 380686"];
17099 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380687"];
17100 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380688"];
17101 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380689"];
17102 [label="if (ConstraintsNeedNullableAttribute())\n            {\n                DeclaringCompilation.EnsureNullableAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380690"];
17103 [label="this.EnsureAttributesFromConstraints(diagnostics); 380691"];
17104 [label="this.AddDeclarationDiagnostics(diagnostics); 380692"];
17105 [label="this.AddDeclarationDiagnostics(diagnostics) 380693"];
17106 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 380694"];
17107 [label="param AddDeclarationDiagnostics(this) 380695"];
17108 [label="ContainingSymbol 380696"];
17109 [label="get { return _owner; } 380697"];
17110 [label="return _owner; 380698"];
17111 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 380699"];
17112 [label="container.AssertMemberExposure(this, forDiagnostics: true); 380700"];
17113 [label="container.AssertMemberExposure(this, forDiagnostics: true); 380701"];
17114 [label="container.AssertMemberExposure(this, forDiagnostics: true) 380702"];
17115 [label="param AssertMemberExposure(Symbol member) 380703"];
17116 [label="param AssertMemberExposure(bool forDiagnostics = false) 380704"];
17117 [label="param AssertMemberExposure(this) 380705"];
17118 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 380706"];
17119 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 380707"];
17120 [label="Debug.Assert(forDiagnostics); 380708"];
17121 [label="return; 380709"];
17122 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 380710"];
17123 [label="this.AddDeclarationDiagnostics(diagnostics); 380711"];
17124 [label="_state.NotePartComplete(CompletionPart.TypeParameterConstraints); 380712"];
17125 [label="_state.NotePartComplete(CompletionPart.TypeParameterConstraints) 380713"];
17126 [label="param NotePartComplete(CompletionPart part) 380714"];
17127 [label="param NotePartComplete(this) 380715"];
17128 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 380716"];
17129 [label="diagnostics.Free(); 380717"];
17130 [label="return _lazyBounds; 380718"];
17131 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380719"];
17132 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380720"];
17133 [label="(bounds != null) 380721"];
17134 [label="var diagnostics = DiagnosticBag.GetInstance(); 380722"];
17135 [label="param ResolveBounds(DiagnosticBag diagnostics) 380723"];
17136 [label="this.Ordinal 380724"];
17137 [label="param GetTypeParameterConstraintTypes(int ordinal) 380725"];
17138 [label="return (constraintTypes.Length > 0) ? constraintTypes[ordinal] : ImmutableArray<TypeWithAnnotations>.Empty; 380726"];
17139 [label="if (constraintTypes.IsEmpty && GetConstraintKinds() == TypeParameterConstraintKind.None)\n            {\n                return null;\n            } 380727"];
17140 [label="if (constraintTypes.IsEmpty && GetConstraintKinds() == TypeParameterConstraintKind.None)\n            {\n                return null;\n            } 380728"];
17141 [label="this.DeclaringCompilation 380729"];
17142 [label="this.Kind 380730"];
17143 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380731"];
17144 [label="return SymbolKind.TypeParameter; 380732"];
17145 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380733"];
17146 [label="return _owner; 380734"];
17147 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380735"];
17148 [label="param ResolveBounds(bool inherited) 380736"];
17149 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380737"];
17150 [label="param ResolveBounds(DiagnosticBag diagnostics) 380738"];
17151 [label="var diagnosticsBuilder = ArrayBuilder<TypeParameterDiagnosticInfo>.GetInstance(); 380739"];
17152 [label="ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder = null; 380740"];
17153 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380741"];
17154 [label="param ResolveBounds(bool inherited) 380742"];
17155 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380743"];
17156 [label="param ResolveBounds(ArrayBuilder<TypeParameterDiagnosticInfo> diagnosticsBuilder) 380744"];
17157 [label="param ResolveBounds(ref ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder) 380745"];
17158 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380746"];
17159 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380747"];
17160 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380748"];
17161 [label="typeParameter.IsFromCompilation(currentCompilation) 380749"];
17162 [label="param IsFromCompilation(CSharpCompilation compilation) 380750"];
17163 [label="param IsFromCompilation(this) 380751"];
17164 [label="Debug.Assert(compilation != null); 380752"];
17165 [label="Debug.Assert(compilation != null); 380753"];
17166 [label="this.DeclaringCompilation 380754"];
17167 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 380755"];
17168 [label="this.Kind 380756"];
17169 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380757"];
17170 [label="return SymbolKind.TypeParameter; 380758"];
17171 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380759"];
17172 [label="return _owner; 380760"];
17173 [label="return compilation == this.DeclaringCompilation; 380761"];
17174 [label="return compilation == this.DeclaringCompilation; 380762"];
17175 [label="ImmutableArray<NamedTypeSymbol> interfaces; 380763"];
17176 [label="interfaces 380764"];
17177 [label="this.Modules 380765"];
17178 [label="get\n            {\n                return _modules;\n            } 380766"];
17179 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 380767"];
17180 [label="module.GetReferencedAssemblies() 380768"];
17181 [label="param GetReferencedAssemblies(this) 380769"];
17182 [label="AssertReferencesInitialized() 380770"];
17183 [label="param AssertReferencesInitialized(this) 380771"];
17184 [label="Debug.Assert(_moduleReferences != null); 380772"];
17185 [label="Debug.Assert(_moduleReferences != null); 380773"];
17186 [label="AssertReferencesInitialized(); 380774"];
17187 [label="return _moduleReferences.Identities; 380775"];
17188 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380776"];
17189 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380777"];
17190 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380778"];
17191 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380779"];
17192 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380780"];
17193 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380781"];
17194 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380782"];
17195 [label="interfaces = ImmutableArray<NamedTypeSymbol>.Empty; 380783"];
17196 [label="effectiveBaseClass.SpecialType 380784"];
17197 [label="get\n            {\n                return _corTypeId;\n            } 380785"];
17198 [label="Debug.Assert((effectiveBaseClass.SpecialType == SpecialType.System_Object) || (deducedBaseType.SpecialType != SpecialType.System_Object)); 380786"];
17199 [label="if ((constraintTypes.Length == 0) && (deducedBaseType.SpecialType == SpecialType.System_Object))\n            {\n                Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object);\n                Debug.Assert(interfaces.Length == 0);\n                return null;\n            } 380787"];
17200 [label="effectiveBaseClass.SpecialType 380788"];
17201 [label="Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object); 380789"];
17202 [label="Debug.Assert(interfaces.Length == 0); 380790"];
17203 [label="Debug.Assert(interfaces.Length == 0); 380791"];
17204 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380792"];
17205 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380793"];
17206 [label="foreach (var pair in diagnosticsBuilder)\n            {\n                diagnostics.Add(new CSDiagnostic(pair.DiagnosticInfo, pair.TypeParameter.Locations[0]));\n            } 380794"];
17207 [label="diagnosticsBuilder.Free(); 380795"];
17208 [label="this.CheckConstraintTypeConstraints(diagnostics); 380796"];
17209 [label="param CheckConstraintTypeConstraints(DiagnosticBag diagnostics) 380797"];
17210 [label="this.EnsureAllConstraintsAreResolved(); 380798"];
17211 [label="var constraintTypes = this.ConstraintTypesNoUseSiteDiagnostics; 380799"];
17212 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380800"];
17213 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380801"];
17214 [label="return; 380802"];
17215 [label="this.CheckConstraintTypeConstraints(diagnostics); 380803"];
17216 [label="this.CheckUnmanagedConstraint(diagnostics); 380804"];
17217 [label="param CheckUnmanagedConstraint(DiagnosticBag diagnostics) 380805"];
17218 [label="var constraints = this.GetConstraintKinds(); 380806"];
17219 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380807"];
17220 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380808"];
17221 [label="if (this.HasUnmanagedTypeConstraint)\n            {\n                DeclaringCompilation.EnsureIsUnmanagedAttributeExists(diagnostics, this.GetNonNullSyntaxNode().Location, ModifyCompilationForAttributeEmbedding());\n            } 380809"];
17222 [label="this.CheckUnmanagedConstraint(diagnostics); 380810"];
17223 [label="this.EnsureAttributesFromConstraints(diagnostics); 380811"];
17224 [label="param EnsureAttributesFromConstraints(DiagnosticBag diagnostics) 380812"];
17225 [label="if (ConstraintTypesNoUseSiteDiagnostics.Any(t => t.ContainsNativeInteger()))\n            {\n                DeclaringCompilation.EnsureNativeIntegerAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380813"];
17226 [label="this.Kind 380814"];
17227 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380815"];
17228 [label="return SymbolKind.TypeParameter; 380816"];
17229 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380817"];
17230 [label="symbol.IsDefinition 380818"];
17231 [label="get\n            {\n                return this.OriginalDefinition;\n            } 380819"];
17232 [label="this.OriginalDefinition 380820"];
17233 [label="get\n            {\n                return this;\n            } 380821"];
17234 [label="return this; 380822"];
17235 [label="return this.OriginalDefinition; 380823"];
17236 [label="Debug.Assert(symbol.IsDefinition); 380824"];
17237 [label="symbol.ContainingModule 380825"];
17238 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380826"];
17239 [label="GetBoundReferenceManager(); 380827"];
17240 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380828"];
17241 [label="symbol.ContainingModule != SourceModule 380829"];
17242 [label="param !=(Symbol left) 380830"];
17243 [label="param !=(Symbol right) 380831"];
17244 [label="if (right is null)\n            {\n                return left is object;\n            } 380832"];
17245 [label="return (object)left != (object)right && !right.Equals(left); 380833"];
17246 [label="return _lazyEmitNullablePublicOnly.Value(); 380834"];
17247 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 380835"];
17248 [label="return true; 380836"];
17249 [label="var constraints = this.GetConstraintKinds(); 380837"];
17250 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380838"];
17251 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380839"];
17252 [label="if (this.HasReferenceTypeConstraint && this.ReferenceTypeConstraintIsNullable != null)\n            {\n                return true;\n            } 380840"];
17253 [label="if (this.ConstraintTypesNoUseSiteDiagnostics.Any(c => c.NeedsNullableAttribute()))\n            {\n                return true;\n            } 380841"];
17254 [label="var constraints = this.GetConstraintKinds(); 380842"];
17255 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380843"];
17256 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380844"];
17257 [label="if (this.HasNotNullConstraint)\n            {\n                return true;\n            } 380845"];
17258 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380846"];
17259 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380847"];
17260 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 380848"];
17261 [label="return null; 380849"];
17262 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380850"];
17263 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380851"];
17264 [label="if (ConstraintsNeedNullableAttribute())\n            {\n                DeclaringCompilation.EnsureNullableAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380852"];
17265 [label="this.EnsureAttributesFromConstraints(diagnostics); 380853"];
17266 [label="this.AddDeclarationDiagnostics(diagnostics); 380854"];
17267 [label="this.AddDeclarationDiagnostics(diagnostics) 380855"];
17268 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 380856"];
17269 [label="param AddDeclarationDiagnostics(this) 380857"];
17270 [label="ContainingSymbol 380858"];
17271 [label="get { return _owner; } 380859"];
17272 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 380860"];
17273 [label="container.AssertMemberExposure(this, forDiagnostics: true); 380861"];
17274 [label="container.AssertMemberExposure(this, forDiagnostics: true); 380862"];
17275 [label="container.AssertMemberExposure(this, forDiagnostics: true) 380863"];
17276 [label="param AssertMemberExposure(Symbol member) 380864"];
17277 [label="param AssertMemberExposure(bool forDiagnostics = false) 380865"];
17278 [label="param AssertMemberExposure(this) 380866"];
17279 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 380867"];
17280 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 380868"];
17281 [label="Debug.Assert(forDiagnostics); 380869"];
17282 [label="return; 380870"];
17283 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 380871"];
17284 [label="this.AddDeclarationDiagnostics(diagnostics); 380872"];
17285 [label="diagnostics.Free(); 380873"];
17286 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 380874"];
17287 [label="var diagnostics = DiagnosticBag.GetInstance(); 380875"];
17288 [label="param ResolveBounds(DiagnosticBag diagnostics) 380876"];
17289 [label="param GetTypeParameterConstraintTypes(int ordinal) 380877"];
17290 [label="if (constraintTypes.IsEmpty && GetConstraintKinds() == TypeParameterConstraintKind.None)\n            {\n                return null;\n            } 380878"];
17291 [label="this.DeclaringCompilation 380879"];
17292 [label="this.Kind 380880"];
17293 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380881"];
17294 [label="return SymbolKind.TypeParameter; 380882"];
17295 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380883"];
17296 [label="return _owner; 380884"];
17297 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380885"];
17298 [label="param ResolveBounds(bool inherited) 380886"];
17299 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380887"];
17300 [label="param ResolveBounds(DiagnosticBag diagnostics) 380888"];
17301 [label="var diagnosticsBuilder = ArrayBuilder<TypeParameterDiagnosticInfo>.GetInstance(); 380889"];
17302 [label="ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder = null; 380890"];
17303 [label="param ResolveBounds(ConsList<TypeParameterSymbol> inProgress) 380891"];
17304 [label="param ResolveBounds(bool inherited) 380892"];
17305 [label="param ResolveBounds(CSharpCompilation currentCompilation) 380893"];
17306 [label="param ResolveBounds(ArrayBuilder<TypeParameterDiagnosticInfo> diagnosticsBuilder) 380894"];
17307 [label="param ResolveBounds(ref ArrayBuilder<TypeParameterDiagnosticInfo> useSiteDiagnosticsBuilder) 380895"];
17308 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380896"];
17309 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380897"];
17310 [label="Debug.Assert(currentCompilation == null || typeParameter.IsFromCompilation(currentCompilation)); 380898"];
17311 [label="typeParameter.IsFromCompilation(currentCompilation) 380899"];
17312 [label="param IsFromCompilation(CSharpCompilation compilation) 380900"];
17313 [label="param IsFromCompilation(this) 380901"];
17314 [label="Debug.Assert(compilation != null); 380902"];
17315 [label="Debug.Assert(compilation != null); 380903"];
17316 [label="this.DeclaringCompilation 380904"];
17317 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 380905"];
17318 [label="this.Kind 380906"];
17319 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380907"];
17320 [label="return SymbolKind.TypeParameter; 380908"];
17321 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380909"];
17322 [label="return _owner; 380910"];
17323 [label="return compilation == this.DeclaringCompilation; 380911"];
17324 [label="return compilation == this.DeclaringCompilation; 380912"];
17325 [label="ImmutableArray<NamedTypeSymbol> interfaces; 380913"];
17326 [label="interfaces 380914"];
17327 [label="this.Modules 380915"];
17328 [label="get\n            {\n                return _modules;\n            } 380916"];
17329 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 380917"];
17330 [label="module.GetReferencedAssemblies() 380918"];
17331 [label="param GetReferencedAssemblies(this) 380919"];
17332 [label="AssertReferencesInitialized() 380920"];
17333 [label="param AssertReferencesInitialized(this) 380921"];
17334 [label="Debug.Assert(_moduleReferences != null); 380922"];
17335 [label="Debug.Assert(_moduleReferences != null); 380923"];
17336 [label="AssertReferencesInitialized(); 380924"];
17337 [label="return _moduleReferences.Identities; 380925"];
17338 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380926"];
17339 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 380927"];
17340 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380928"];
17341 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380929"];
17342 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 380930"];
17343 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380931"];
17344 [label="if (constraintTypes.Length == 0)\n            {\n                interfaces = ImmutableArray<NamedTypeSymbol>.Empty;\n            }\n            else\n            {\n                var constraintTypesBuilder = ArrayBuilder<TypeWithAnnotations>.GetInstance();\n                var interfacesBuilder = ArrayBuilder<NamedTypeSymbol>.GetInstance();\n                var conversions = new TypeConversions(corLibrary);\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                // Resolve base types, determine the effective base class and\n                // interfaces, and filter out any constraint types that cause cycles.\n                foreach (var constraintType in constraintTypes)\n                {\n                    Debug.Assert(!constraintType.Type.ContainsDynamic());\n\n                    NamedTypeSymbol constraintEffectiveBase;\n                    TypeSymbol constraintDeducedBase;\n\n                    switch (constraintType.TypeKind)\n                    {\n                        case TypeKind.TypeParameter:\n                            {\n                                var constraintTypeParameter = (TypeParameterSymbol)constraintType.Type;\n                                ConsList<TypeParameterSymbol> constraintsInProgress;\n\n                                if (constraintTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                {\n                                    // The constraint type parameter is from the same containing type or method.\n                                    if (inProgress.ContainsReference(constraintTypeParameter))\n                                    {\n                                        // 'Circular constraint dependency involving '{0}' and '{1}''\n                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, constraintTypeParameter, typeParameter)));\n                                        continue;\n                                    }\n\n                                    constraintsInProgress = inProgress;\n                                }\n                                else\n                                {\n                                    // The constraint type parameter is from a different containing symbol so no cycle.\n                                    constraintsInProgress = ConsList<TypeParameterSymbol>.Empty;\n                                }\n\n                                // Use the calculated bounds from the constraint type parameter.\n                                constraintEffectiveBase = constraintTypeParameter.GetEffectiveBaseClass(constraintsInProgress);\n                                constraintDeducedBase = constraintTypeParameter.GetDeducedBaseType(constraintsInProgress);\n                                AddInterfaces(interfacesBuilder, constraintTypeParameter.GetInterfaces(constraintsInProgress));\n\n                                if (!inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation))\n                                {\n                                    ErrorCode errorCode;\n                                    if (constraintTypeParameter.HasUnmanagedTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithUnmanagedCon;\n                                    }\n                                    else if (constraintTypeParameter.HasValueTypeConstraint)\n                                    {\n                                        errorCode = ErrorCode.ERR_ConWithValCon;\n                                    }\n                                    else\n                                    {\n                                        break;\n                                    }\n\n                                    // 'Type parameter '{1}' has the '?' constraint so '{1}' cannot be used as a constraint for '{0}''\n                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(errorCode, typeParameter, constraintTypeParameter)));\n                                    continue;\n                                }\n                            }\n                            break;\n\n                        case TypeKind.Interface:\n                        case TypeKind.Class:\n                        case TypeKind.Delegate:\n\n                            Debug.Assert(inherited || currentCompilation == null || constraintType.TypeKind != TypeKind.Delegate);\n\n                            if (constraintType.Type.IsInterfaceType())\n                            {\n                                AddInterface(interfacesBuilder, (NamedTypeSymbol)constraintType.Type);\n                                constraintTypesBuilder.Add(constraintType);\n                                continue;\n                            }\n                            else\n                            {\n                                constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                                constraintDeducedBase = constraintType.Type;\n                                break;\n                            }\n\n                        case TypeKind.Struct:\n                            if (constraintType.IsNullableType())\n                            {\n                                var underlyingType = constraintType.Type.GetNullableUnderlyingType();\n                                if (underlyingType.TypeKind == TypeKind.TypeParameter)\n                                {\n                                    var underlyingTypeParameter = (TypeParameterSymbol)underlyingType;\n                                    if (underlyingTypeParameter.ContainingSymbol == typeParameter.ContainingSymbol)\n                                    {\n                                        // The constraint type parameter is from the same containing type or method.\n                                        if (inProgress.ContainsReference(underlyingTypeParameter))\n                                        {\n                                            // 'Circular constraint dependency involving '{0}' and '{1}''\n                                            diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(underlyingTypeParameter, new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint, underlyingTypeParameter, typeParameter)));\n                                            continue;\n                                        }\n                                    }\n                                }\n                            }\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_ValueType);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Enum:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Enum);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Array:\n                            Debug.Assert(inherited || currentCompilation == null);\n                            constraintEffectiveBase = corLibrary.GetSpecialType(SpecialType.System_Array);\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Error:\n                            constraintEffectiveBase = (NamedTypeSymbol)constraintType.Type;\n                            constraintDeducedBase = constraintType.Type;\n                            break;\n\n                        case TypeKind.Pointer:\n                        case TypeKind.FunctionPointer:\n                            // Such a constraint can only be introduced by type substitution,\n                            // in which case it is already reported elsewhere, so we ignore this constraint.\n                            continue;\n\n                        case TypeKind.Submission:\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(constraintType.TypeKind);\n                    }\n\n                    CheckEffectiveAndDeducedBaseTypes(conversions, constraintEffectiveBase, constraintDeducedBase);\n\n                    constraintTypesBuilder.Add(constraintType);\n\n                    // Determine the more encompassed of the current effective base\n                    // class and the previously computed effective base class.\n                    if (!deducedBaseType.IsErrorType() && !constraintDeducedBase.IsErrorType())\n                    {\n                        if (!IsEncompassedBy(conversions, deducedBaseType, constraintDeducedBase, ref useSiteDiagnostics))\n                        {\n                            if (!IsEncompassedBy(conversions, constraintDeducedBase, deducedBaseType, ref useSiteDiagnostics))\n                            {\n                                // 'Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}''\n                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter, new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict, typeParameter, constraintDeducedBase, deducedBaseType)));\n                            }\n                            else\n                            {\n                                deducedBaseType = constraintDeducedBase;\n                                effectiveBaseClass = constraintEffectiveBase;\n                            }\n                        }\n                    }\n                }\n\n                AppendUseSiteDiagnostics(useSiteDiagnostics, typeParameter, ref useSiteDiagnosticsBuilder);\n\n                CheckEffectiveAndDeducedBaseTypes(conversions, effectiveBaseClass, deducedBaseType);\n\n                constraintTypes = constraintTypesBuilder.ToImmutableAndFree();\n                interfaces = interfacesBuilder.ToImmutableAndFree();\n            } 380932"];
17345 [label="interfaces = ImmutableArray<NamedTypeSymbol>.Empty; 380933"];
17346 [label="effectiveBaseClass.SpecialType 380934"];
17347 [label="get\n            {\n                return _corTypeId;\n            } 380935"];
17348 [label="Debug.Assert((effectiveBaseClass.SpecialType == SpecialType.System_Object) || (deducedBaseType.SpecialType != SpecialType.System_Object)); 380936"];
17349 [label="effectiveBaseClass.SpecialType 380937"];
17350 [label="Debug.Assert(effectiveBaseClass.SpecialType == SpecialType.System_Object); 380938"];
17351 [label="Debug.Assert(interfaces.Length == 0); 380939"];
17352 [label="Debug.Assert(interfaces.Length == 0); 380940"];
17353 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380941"];
17354 [label="if (useSiteDiagnosticsBuilder != null)\n            {\n                diagnosticsBuilder.AddRange(useSiteDiagnosticsBuilder);\n            } 380942"];
17355 [label="foreach (var pair in diagnosticsBuilder)\n            {\n                diagnostics.Add(new CSDiagnostic(pair.DiagnosticInfo, pair.TypeParameter.Locations[0]));\n            } 380943"];
17356 [label="diagnosticsBuilder.Free(); 380944"];
17357 [label="this.CheckConstraintTypeConstraints(diagnostics); 380945"];
17358 [label="param CheckConstraintTypeConstraints(DiagnosticBag diagnostics) 380946"];
17359 [label="this.EnsureAllConstraintsAreResolved(); 380947"];
17360 [label="var constraintTypes = this.ConstraintTypesNoUseSiteDiagnostics; 380948"];
17361 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380949"];
17362 [label="if (constraintTypes.Length == 0)\n            {\n                return;\n            } 380950"];
17363 [label="return; 380951"];
17364 [label="this.CheckConstraintTypeConstraints(diagnostics); 380952"];
17365 [label="this.CheckUnmanagedConstraint(diagnostics); 380953"];
17366 [label="param CheckUnmanagedConstraint(DiagnosticBag diagnostics) 380954"];
17367 [label="var constraints = this.GetConstraintKinds(); 380955"];
17368 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380956"];
17369 [label="return (constraints & TypeParameterConstraintKind.Unmanaged) != 0; 380957"];
17370 [label="if (this.HasUnmanagedTypeConstraint)\n            {\n                DeclaringCompilation.EnsureIsUnmanagedAttributeExists(diagnostics, this.GetNonNullSyntaxNode().Location, ModifyCompilationForAttributeEmbedding());\n            } 380958"];
17371 [label="this.CheckUnmanagedConstraint(diagnostics); 380959"];
17372 [label="this.EnsureAttributesFromConstraints(diagnostics); 380960"];
17373 [label="param EnsureAttributesFromConstraints(DiagnosticBag diagnostics) 380961"];
17374 [label="if (ConstraintTypesNoUseSiteDiagnostics.Any(t => t.ContainsNativeInteger()))\n            {\n                DeclaringCompilation.EnsureNativeIntegerAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380962"];
17375 [label="this.Kind 380963"];
17376 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 380964"];
17377 [label="return SymbolKind.TypeParameter; 380965"];
17378 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 380966"];
17379 [label="symbol.IsDefinition 380967"];
17380 [label="get\n            {\n                return this.OriginalDefinition;\n            } 380968"];
17381 [label="this.OriginalDefinition 380969"];
17382 [label="get\n            {\n                return this;\n            } 380970"];
17383 [label="return this; 380971"];
17384 [label="return this.OriginalDefinition; 380972"];
17385 [label="Debug.Assert(symbol.IsDefinition); 380973"];
17386 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 380974"];
17387 [label="GetBoundReferenceManager(); 380975"];
17388 [label="symbol.ContainingModule != SourceModule 380976"];
17389 [label="param !=(Symbol left) 380977"];
17390 [label="param !=(Symbol right) 380978"];
17391 [label="if (right is null)\n            {\n                return left is object;\n            } 380979"];
17392 [label="return (object)left != (object)right && !right.Equals(left); 380980"];
17393 [label="return _lazyEmitNullablePublicOnly.Value(); 380981"];
17394 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 380982"];
17395 [label="return true; 380983"];
17396 [label="var constraints = this.GetConstraintKinds(); 380984"];
17397 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380985"];
17398 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 380986"];
17399 [label="if (this.HasReferenceTypeConstraint && this.ReferenceTypeConstraintIsNullable != null)\n            {\n                return true;\n            } 380987"];
17400 [label="if (this.ConstraintTypesNoUseSiteDiagnostics.Any(c => c.NeedsNullableAttribute()))\n            {\n                return true;\n            } 380988"];
17401 [label="var constraints = this.GetConstraintKinds(); 380989"];
17402 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380990"];
17403 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 380991"];
17404 [label="if (this.HasNotNullConstraint)\n            {\n                return true;\n            } 380992"];
17405 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380993"];
17406 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380994"];
17407 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 380995"];
17408 [label="return null; 380996"];
17409 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380997"];
17410 [label="return !this.HasReferenceTypeConstraint &&\n                !this.HasValueTypeConstraint &&\n                this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty &&\n                this.IsNotNullable == false; 380998"];
17411 [label="if (ConstraintsNeedNullableAttribute())\n            {\n                DeclaringCompilation.EnsureNullableAttributeExists(diagnostics, getLocation(), ModifyCompilationForAttributeEmbedding());\n            } 380999"];
17412 [label="this.EnsureAttributesFromConstraints(diagnostics); 381000"];
17413 [label="this.AddDeclarationDiagnostics(diagnostics); 381001"];
17414 [label="this.AddDeclarationDiagnostics(diagnostics) 381002"];
17415 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381003"];
17416 [label="param AddDeclarationDiagnostics(this) 381004"];
17417 [label="ContainingSymbol 381005"];
17418 [label="get { return _owner; } 381006"];
17419 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381007"];
17420 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381008"];
17421 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381009"];
17422 [label="container.AssertMemberExposure(this, forDiagnostics: true) 381010"];
17423 [label="param AssertMemberExposure(Symbol member) 381011"];
17424 [label="param AssertMemberExposure(bool forDiagnostics = false) 381012"];
17425 [label="param AssertMemberExposure(this) 381013"];
17426 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381014"];
17427 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381015"];
17428 [label="Debug.Assert(forDiagnostics); 381016"];
17429 [label="return; 381017"];
17430 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381018"];
17431 [label="this.AddDeclarationDiagnostics(diagnostics); 381019"];
17432 [label="diagnostics.Free(); 381020"];
17433 [label="EnsureAllConstraintsAreResolved(this.ContainerTypeParameters); 381021"];
17434 [label="this.EnsureAllConstraintsAreResolved(); 381022"];
17435 [label="return this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty); 381023"];
17436 [label="this.GetConstraintTypes(ConsList<TypeParameterSymbol>.Empty) 381024"];
17437 [label="param GetConstraintTypes(ConsList<TypeParameterSymbol> inProgress) 381025"];
17438 [label="param GetConstraintTypes(this) 381026"];
17439 [label="var bounds = this.GetBounds(inProgress); 381027"];
17440 [label="this.GetBounds(inProgress) 381028"];
17441 [label="param GetBounds(ConsList<TypeParameterSymbol> inProgress) 381029"];
17442 [label="param GetBounds(this) 381030"];
17443 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381031"];
17444 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381032"];
17445 [label="_lazyBounds.IsSet() 381033"];
17446 [label="return (bounds != null) ? bounds.ConstraintTypes : ImmutableArray<TypeWithAnnotations>.Empty; 381034"];
17447 [label="get { return _owner; } 381035"];
17448 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetEffectiveBaseClass(ConsList<TypeParameterSymbol>.Empty);\n            } 381036"];
17449 [label="this.EnsureAllConstraintsAreResolved() 381037"];
17450 [label="param EnsureAllConstraintsAreResolved(this) 381038"];
17451 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 381039"];
17452 [label="_lazyBounds.IsSet() 381040"];
17453 [label="this.EnsureAllConstraintsAreResolved(); 381041"];
17454 [label="return this.GetEffectiveBaseClass(ConsList<TypeParameterSymbol>.Empty); 381042"];
17455 [label="this.GetEffectiveBaseClass(ConsList<TypeParameterSymbol>.Empty) 381043"];
17456 [label="param GetEffectiveBaseClass(ConsList<TypeParameterSymbol> inProgress) 381044"];
17457 [label="param GetEffectiveBaseClass(this) 381045"];
17458 [label="var bounds = this.GetBounds(inProgress); 381046"];
17459 [label="this.GetBounds(inProgress) 381047"];
17460 [label="param GetBounds(ConsList<TypeParameterSymbol> inProgress) 381048"];
17461 [label="param GetBounds(this) 381049"];
17462 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381050"];
17463 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381051"];
17464 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381052"];
17465 [label="_lazyBounds.IsSet() 381053"];
17466 [label="return (bounds != null) ? bounds.EffectiveBaseClass : this.GetDefaultBaseType(); 381054"];
17467 [label="return (bounds != null) ? bounds.EffectiveBaseClass : this.GetDefaultBaseType(); 381055"];
17468 [label="(bounds != null) 381056"];
17469 [label="this.GetDefaultBaseType() 381057"];
17470 [label="param GetDefaultBaseType(this) 381058"];
17471 [label="this.ContainingAssembly 381059"];
17472 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 381060"];
17473 [label="return this.ContainingAssembly.GetSpecialType(SpecialType.System_Object); 381061"];
17474 [label="return this.ContainingAssembly.GetSpecialType(SpecialType.System_Object); 381062"];
17475 [label="this.ContainingAssembly.GetSpecialType(SpecialType.System_Object) 381063"];
17476 [label="param GetSpecialType(SpecialType type) 381064"];
17477 [label="param GetSpecialType(this) 381065"];
17478 [label="this.Modules 381066"];
17479 [label="get\n            {\n                return _modules;\n            } 381067"];
17480 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 381068"];
17481 [label="module.GetReferencedAssemblies() 381069"];
17482 [label="param GetReferencedAssemblies(this) 381070"];
17483 [label="AssertReferencesInitialized() 381071"];
17484 [label="param AssertReferencesInitialized(this) 381072"];
17485 [label="Debug.Assert(_moduleReferences != null); 381073"];
17486 [label="Debug.Assert(_moduleReferences != null); 381074"];
17487 [label="AssertReferencesInitialized(); 381075"];
17488 [label="return _moduleReferences.Identities; 381076"];
17489 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 381077"];
17490 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 381078"];
17491 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 381079"];
17492 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 381080"];
17493 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 381081"];
17494 [label="param IsContainingSymbolOfAllTypeParameters(this Symbol containingSymbol) 381082"];
17495 [label="param IsContainingSymbolOfAllTypeParameters(TypeSymbol type) 381083"];
17496 [label="return type.VisitType(s_hasInvalidTypeParameterFunc, containingSymbol) is null; 381084"];
17497 [label="return type.VisitType(s_hasInvalidTypeParameterFunc, containingSymbol) is null; 381085"];
17498 [label="return type.VisitType(s_hasInvalidTypeParameterFunc, containingSymbol) is null; 381086"];
17499 [label="return type.VisitType(s_hasInvalidTypeParameterFunc, containingSymbol) is null; 381087"];
17500 [label="type.VisitType(s_hasInvalidTypeParameterFunc, containingSymbol) 381088"];
17501 [label="param VisitType(this TypeSymbol type) 381089"];
17502 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 381090"];
17503 [label="param VisitType(T arg) 381091"];
17504 [label="param VisitType(bool canDigThroughNullable = false) 381092"];
17505 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 381093"];
17506 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 381094"];
17507 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 381095"];
17508 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 381096"];
17509 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 381097"];
17510 [label="VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable) 381098"];
17511 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 381099"];
17512 [label="param VisitType(TypeSymbol? type) 381100"];
17513 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 381101"];
17514 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 381102"];
17515 [label="param VisitType(T arg) 381103"];
17516 [label="param VisitType(bool canDigThroughNullable = false) 381104"];
17517 [label="param VisitType(bool useDefaultType = false) 381105"];
17518 [label="typeWithAnnotationsOpt.HasType 381106"];
17519 [label="=> !(DefaultType is null) 381107"];
17520 [label="DefaultType is null 381108"];
17521 [label="!(DefaultType is null) 381109"];
17522 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 381110"];
17523 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 381111"];
17524 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 381112"];
17525 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 381113"];
17526 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 381114"];
17527 [label="while (true)\n            {\n                TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type);\n                bool isNestedNamedType = false;\n\n                // Visit containing types from outer-most to inner-most.\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                }\n\n                if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n\n                TypeWithAnnotations next;\n\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                }\n\n                // Let's try to avoid early resolution of nullable types\n                typeWithAnnotationsOpt = canDigThroughNullable ? default : next;\n                type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null;\n            } 381115"];
17528 [label="TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type); 381116"];
17529 [label="bool isNestedNamedType = false; 381117"];
17530 [label="current.TypeKind 381118"];
17531 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 381119"];
17532 [label="TypeKind result = _lazyKind; 381120"];
17533 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 381121"];
17534 [label="current.ContainingType 381122"];
17535 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 381123"];
17536 [label="return _container as NamedTypeSymbol; 381124"];
17537 [label="var containingType = current.ContainingType; 381125"];
17538 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 381126"];
17539 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 381127"];
17540 [label="typeWithAnnotationsOpt.HasType 381128"];
17541 [label="=> !(DefaultType is null) 381129"];
17542 [label="DefaultType is null 381130"];
17543 [label="!(DefaultType is null) 381131"];
17544 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 381132"];
17545 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 381133"];
17546 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 381134"];
17547 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381135"];
17548 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381136"];
17549 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381137"];
17550 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381138"];
17551 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381139"];
17552 [label="param HasInvalidTypeParameter(TypeSymbol type) 381140"];
17553 [label="param HasInvalidTypeParameter(Symbol? containingSymbol) 381141"];
17554 [label="type.TypeKind 381142"];
17555 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 381143"];
17556 [label="if (type.TypeKind == TypeKind.TypeParameter)\n            {\n                var symbol = type.ContainingSymbol;\n                for (; ((object?)containingSymbol != null) && (containingSymbol.Kind != SymbolKind.Namespace); containingSymbol = containingSymbol.ContainingSymbol)\n                {\n                    if (containingSymbol == symbol)\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            } 381144"];
17557 [label="return false; 381145"];
17558 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 381146"];
17559 [label="TypeWithAnnotations next; 381147"];
17560 [label="next 381148"];
17561 [label="current.TypeKind 381149"];
17562 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 381150"];
17563 [label="TypeKind result = _lazyKind; 381151"];
17564 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 381152"];
17565 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 381153"];
17566 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 381154"];
17567 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 381155"];
17568 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 381156"];
17569 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 381157"];
17570 [label="return null; 381158"];
17571 [label="get\n            {\n                this.EnsureAllConstraintsAreResolved();\n                return this.GetDeducedBaseType(ConsList<TypeParameterSymbol>.Empty);\n            } 381159"];
17572 [label="this.EnsureAllConstraintsAreResolved() 381160"];
17573 [label="param EnsureAllConstraintsAreResolved(this) 381161"];
17574 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 381162"];
17575 [label="_lazyBounds.IsSet() 381163"];
17576 [label="this.EnsureAllConstraintsAreResolved(); 381164"];
17577 [label="return this.GetDeducedBaseType(ConsList<TypeParameterSymbol>.Empty); 381165"];
17578 [label="this.GetDeducedBaseType(ConsList<TypeParameterSymbol>.Empty) 381166"];
17579 [label="param GetDeducedBaseType(ConsList<TypeParameterSymbol> inProgress) 381167"];
17580 [label="param GetDeducedBaseType(this) 381168"];
17581 [label="var bounds = this.GetBounds(inProgress); 381169"];
17582 [label="this.GetBounds(inProgress) 381170"];
17583 [label="param GetBounds(ConsList<TypeParameterSymbol> inProgress) 381171"];
17584 [label="param GetBounds(this) 381172"];
17585 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381173"];
17586 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381174"];
17587 [label="Debug.Assert(!inProgress.ContainsReference(this)); 381175"];
17588 [label="_lazyBounds.IsSet() 381176"];
17589 [label="return (bounds != null) ? bounds.DeducedBaseType : this.GetDefaultBaseType(); 381177"];
17590 [label="return (bounds != null) ? bounds.DeducedBaseType : this.GetDefaultBaseType(); 381178"];
17591 [label="(bounds != null) 381179"];
17592 [label="this.GetDefaultBaseType() 381180"];
17593 [label="this.Modules 381181"];
17594 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 381182"];
17595 [label="module.GetReferencedAssemblies() 381183"];
17596 [label="param GetReferencedAssemblies(this) 381184"];
17597 [label="AssertReferencesInitialized() 381185"];
17598 [label="param AssertReferencesInitialized(this) 381186"];
17599 [label="Debug.Assert(_moduleReferences != null); 381187"];
17600 [label="Debug.Assert(_moduleReferences != null); 381188"];
17601 [label="AssertReferencesInitialized(); 381189"];
17602 [label="return _moduleReferences.Identities; 381190"];
17603 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 381191"];
17604 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 381192"];
17605 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 381193"];
17606 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 381194"];
17607 [label="TypeKind result = _lazyKind; 381195"];
17608 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 381196"];
17609 [label="current.ContainingType 381197"];
17610 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 381198"];
17611 [label="return _container as NamedTypeSymbol; 381199"];
17612 [label="var containingType = current.ContainingType; 381200"];
17613 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 381201"];
17614 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 381202"];
17615 [label="param HasInvalidTypeParameter(TypeSymbol type) 381203"];
17616 [label="param HasInvalidTypeParameter(Symbol? containingSymbol) 381204"];
17617 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 381205"];
17618 [label="if (type.TypeKind == TypeKind.TypeParameter)\n            {\n                var symbol = type.ContainingSymbol;\n                for (; ((object?)containingSymbol != null) && (containingSymbol.Kind != SymbolKind.Namespace); containingSymbol = containingSymbol.ContainingSymbol)\n                {\n                    if (containingSymbol == symbol)\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            } 381206"];
17619 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 381207"];
17620 [label="return (_completeParts & (int)part) == (int)part; 381208"];
17621 [label="return; 381209"];
17622 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381210"];
17623 [label="param HasAtMostOneBitSet(int bits) 381211"];
17624 [label="return (bits & (bits - 1)) == 0; 381212"];
17625 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381213"];
17626 [label="HasAtMostOneBitSet(next) 381214"];
17627 [label="param HasAtMostOneBitSet(int bits) 381215"];
17628 [label="return (bits & (bits - 1)) == 0; 381216"];
17629 [label="return (bits & (bits - 1)) == 0; 381217"];
17630 [label="bool lazyAttributesStored = false; 381218"];
17631 [label="this.ContainingSymbol 381219"];
17632 [label="var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol; 381220"];
17633 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 381221"];
17634 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 381222"];
17635 [label="ContainingSymbol 381223"];
17636 [label="(ContainingSymbol is LocalFunctionSymbol) 381224"];
17637 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 381225"];
17638 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 381226"];
17639 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 381227"];
17640 [label="param LoadAndValidateAttributes(this) 381228"];
17641 [label="this.DeclaringCompilation 381229"];
17642 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 381230"];
17643 [label="this.Kind 381231"];
17644 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 381232"];
17645 [label="return SymbolKind.TypeParameter; 381233"];
17646 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 381234"];
17647 [label="var compilation = this.DeclaringCompilation; 381235"];
17648 [label="binders 381236"];
17649 [label="param GetAttributesToBind(AttributeLocation symbolPart) 381237"];
17650 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 381238"];
17651 [label="param GetAttributesToBind(CSharpCompilation compilation) 381239"];
17652 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 381240"];
17653 [label="param GetAttributesToBind(Binder rootBinderOpt) 381241"];
17654 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 381242"];
17655 [label="param GetAttributesToBind(this) 381243"];
17656 [label="var attributeTarget = (IAttributeTargetSymbol)this; 381244"];
17657 [label="ArrayBuilder<Binder> bindersBuilder = null; 381245"];
17658 [label="int attributesToBindCount = 0; 381246"];
17659 [label="binders = ImmutableArray<Binder>.Empty; 381247"];
17660 [label="Debug.Assert(!attributesToBind.IsDefault); 381248"];
17661 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 381249"];
17662 [label="boundAttributes 381250"];
17663 [label="WellKnownAttributeData wellKnownAttributeData; 381251"];
17664 [label="wellKnownAttributeData = null; 381252"];
17665 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 381253"];
17666 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 381254"];
17667 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 381255"];
17668 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381256"];
17669 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381257"];
17670 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381258"];
17671 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381259"];
17672 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 381260"];
17673 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 381261"];
17674 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 381262"];
17675 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 381263"];
17676 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 381264"];
17677 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 381265"];
17678 [label="param PostDecodeWellKnownAttributes(this) 381266"];
17679 [label="bool lazyAttributesStoredOnThisThread = false; 381267"];
17680 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 381268"];
17681 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 381269"];
17682 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 381270"];
17683 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 381271"];
17684 [label="param RecordPresenceOfBadAttributes(this) 381272"];
17685 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 381273"];
17686 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 381274"];
17687 [label="AddDeclarationDiagnostics(diagnostics); 381275"];
17688 [label="AddDeclarationDiagnostics(diagnostics) 381276"];
17689 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381277"];
17690 [label="param AddDeclarationDiagnostics(this) 381278"];
17691 [label="ContainingSymbol 381279"];
17692 [label="get { return _owner; } 381280"];
17693 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381281"];
17694 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381282"];
17695 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381283"];
17696 [label="container.AssertMemberExposure(this, forDiagnostics: true) 381284"];
17697 [label="param AssertMemberExposure(Symbol member) 381285"];
17698 [label="param AssertMemberExposure(bool forDiagnostics = false) 381286"];
17699 [label="param AssertMemberExposure(this) 381287"];
17700 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381288"];
17701 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381289"];
17702 [label="Debug.Assert(forDiagnostics); 381290"];
17703 [label="return; 381291"];
17704 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381292"];
17705 [label="AddDeclarationDiagnostics(diagnostics); 381293"];
17706 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 381294"];
17707 [label="diagnostics.Free(); 381295"];
17708 [label="param SpinWaitComplete(CompletionPart part) 381296"];
17709 [label="param SpinWaitComplete(CancellationToken cancellationToken) 381297"];
17710 [label="param SpinWaitComplete(this) 381298"];
17711 [label="if (HasComplete(part))\n            {\n                return;\n            } 381299"];
17712 [label="HasComplete(part) 381300"];
17713 [label="param HasComplete(CompletionPart part) 381301"];
17714 [label="param HasComplete(this) 381302"];
17715 [label="return (_completeParts & (int)part) == (int)part; 381303"];
17716 [label="return; 381304"];
17717 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381305"];
17718 [label="HasAtMostOneBitSet(next) 381306"];
17719 [label="param HasAtMostOneBitSet(int bits) 381307"];
17720 [label="return (bits & (bits - 1)) == 0; 381308"];
17721 [label="return (bits & (bits - 1)) == 0; 381309"];
17722 [label="bool lazyAttributesStored = false; 381310"];
17723 [label="this.ContainingSymbol 381311"];
17724 [label="var sourceMethod = this.ContainingSymbol as SourceOrdinaryMethodSymbol; 381312"];
17725 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 381313"];
17726 [label="if ((object)sourceMethod != null && sourceMethod.IsPartial)\n                {\n                    var implementingPart = sourceMethod.SourcePartialImplementation;\n                    if ((object)implementingPart != null)\n                    {\n                        var typeParameter = (SourceTypeParameterSymbolBase)implementingPart.TypeParameters[_ordinal];\n                        mergedAttributesBuilder.AddRange(typeParameter.MergedAttributeDeclarationSyntaxLists);\n                    }\n                } 381314"];
17727 [label="(ContainingSymbol is LocalFunctionSymbol) 381315"];
17728 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 381316"];
17729 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 381317"];
17730 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 381318"];
17731 [label="param LoadAndValidateAttributes(this) 381319"];
17732 [label="this.DeclaringCompilation 381320"];
17733 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 381321"];
17734 [label="this.Kind 381322"];
17735 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 381323"];
17736 [label="return SymbolKind.TypeParameter; 381324"];
17737 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 381325"];
17738 [label="var compilation = this.DeclaringCompilation; 381326"];
17739 [label="binders 381327"];
17740 [label="param GetAttributesToBind(AttributeLocation symbolPart) 381328"];
17741 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 381329"];
17742 [label="param GetAttributesToBind(CSharpCompilation compilation) 381330"];
17743 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 381331"];
17744 [label="param GetAttributesToBind(Binder rootBinderOpt) 381332"];
17745 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 381333"];
17746 [label="param GetAttributesToBind(this) 381334"];
17747 [label="var attributeTarget = (IAttributeTargetSymbol)this; 381335"];
17748 [label="ArrayBuilder<Binder> bindersBuilder = null; 381336"];
17749 [label="int attributesToBindCount = 0; 381337"];
17750 [label="binders = ImmutableArray<Binder>.Empty; 381338"];
17751 [label="Debug.Assert(!attributesToBind.IsDefault); 381339"];
17752 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 381340"];
17753 [label="boundAttributes 381341"];
17754 [label="WellKnownAttributeData wellKnownAttributeData; 381342"];
17755 [label="wellKnownAttributeData = null; 381343"];
17756 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 381344"];
17757 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 381345"];
17758 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 381346"];
17759 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381347"];
17760 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381348"];
17761 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381349"];
17762 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 381350"];
17763 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 381351"];
17764 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 381352"];
17765 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 381353"];
17766 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 381354"];
17767 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 381355"];
17768 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 381356"];
17769 [label="param PostDecodeWellKnownAttributes(this) 381357"];
17770 [label="bool lazyAttributesStoredOnThisThread = false; 381358"];
17771 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 381359"];
17772 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 381360"];
17773 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 381361"];
17774 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 381362"];
17775 [label="param RecordPresenceOfBadAttributes(this) 381363"];
17776 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 381364"];
17777 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 381365"];
17778 [label="AddDeclarationDiagnostics(diagnostics); 381366"];
17779 [label="AddDeclarationDiagnostics(diagnostics) 381367"];
17780 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381368"];
17781 [label="param AddDeclarationDiagnostics(this) 381369"];
17782 [label="ContainingSymbol 381370"];
17783 [label="get { return _owner; } 381371"];
17784 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381372"];
17785 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381373"];
17786 [label="container.AssertMemberExposure(this, forDiagnostics: true); 381374"];
17787 [label="container.AssertMemberExposure(this, forDiagnostics: true) 381375"];
17788 [label="param AssertMemberExposure(Symbol member) 381376"];
17789 [label="param AssertMemberExposure(bool forDiagnostics = false) 381377"];
17790 [label="param AssertMemberExposure(this) 381378"];
17791 [label="if (member is NamedTypeSymbol type)\n            {\n                Debug.Assert(forDiagnostics);\n                // Lafhis\n                var temp = Volatile.Read(ref _lazyTypeMembers);\n                Debug.Assert(temp != null ? temp.Values.Any(types => types.Contains(t => t == (object)type)) == true : false);\n                return;\n            }\n            else if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381379"];
17792 [label="if (member is TypeParameterSymbol || member is SynthesizedMethodBaseSymbol)\n            {\n                Debug.Assert(forDiagnostics);\n                return;\n            }\n            else if (member is FieldSymbol field && field.AssociatedSymbol is EventSymbol e)\n            {\n                Debug.Assert(forDiagnostics);\n                member = e;\n            } 381380"];
17793 [label="Debug.Assert(forDiagnostics); 381381"];
17794 [label="return; 381382"];
17795 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381383"];
17796 [label="AddDeclarationDiagnostics(diagnostics); 381384"];
17797 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 381385"];
17798 [label="diagnostics.Free(); 381386"];
17799 [label="param SpinWaitComplete(CompletionPart part) 381387"];
17800 [label="param SpinWaitComplete(CancellationToken cancellationToken) 381388"];
17801 [label="param SpinWaitComplete(this) 381389"];
17802 [label="if (HasComplete(part))\n            {\n                return;\n            } 381390"];
17803 [label="HasComplete(part) 381391"];
17804 [label="param HasComplete(CompletionPart part) 381392"];
17805 [label="param HasComplete(this) 381393"];
17806 [label="return (_completeParts & (int)part) == (int)part; 381394"];
17807 [label="return; 381395"];
17808 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381396"];
17809 [label="HasAtMostOneBitSet(next) 381397"];
17810 [label="param HasAtMostOneBitSet(int bits) 381398"];
17811 [label="return (bits & (bits - 1)) == 0; 381399"];
17812 [label="return (bits & (bits - 1)) == 0; 381400"];
17813 [label="state.NotePartComplete(CompletionPart.TypeParameters); 381401"];
17814 [label="state.NotePartComplete(CompletionPart.TypeParameters) 381402"];
17815 [label="param NotePartComplete(CompletionPart part) 381403"];
17816 [label="param NotePartComplete(this) 381404"];
17817 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 381405"];
17818 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 381406"];
17819 [label="param SpinWaitComplete(CompletionPart part) 381407"];
17820 [label="param SpinWaitComplete(this) 381408"];
17821 [label="if (HasComplete(part))\n            {\n                return;\n            } 381409"];
17822 [label="param HasComplete(CompletionPart part) 381410"];
17823 [label="param HasComplete(this) 381411"];
17824 [label="return (_completeParts & (int)part) == (int)part; 381412"];
17825 [label="return; 381413"];
17826 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381414"];
17827 [label="param HasAtMostOneBitSet(int bits) 381415"];
17828 [label="return (bits & (bits - 1)) == 0; 381416"];
17829 [label="this.GetMembersByName() 381417"];
17830 [label="param GetMembersByName(this) 381418"];
17831 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 381419"];
17832 [label="this.state.HasComplete(CompletionPart.Members) 381420"];
17833 [label="param HasComplete(CompletionPart part) 381421"];
17834 [label="param HasComplete(this) 381422"];
17835 [label="return (_completeParts & (int)part) == (int)part; 381423"];
17836 [label="GetMembersByNameSlow() 381424"];
17837 [label="param GetMembersByNameSlow(this) 381425"];
17838 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 381426"];
17839 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 381427"];
17840 [label="var diagnostics = DiagnosticBag.GetInstance(); 381428"];
17841 [label="var membersDictionary = MakeAllMembers(diagnostics); 381429"];
17842 [label="MakeAllMembers(diagnostics) 381430"];
17843 [label="param MakeAllMembers(DiagnosticBag diagnostics) 381431"];
17844 [label="param MakeAllMembers(this) 381432"];
17845 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName; 381433"];
17846 [label="GetMembersAndInitializers() 381434"];
17847 [label="param GetMembersAndInitializers(this) 381435"];
17848 [label="var membersAndInitializers = _lazyMembersAndInitializers; 381436"];
17849 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 381437"];
17850 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 381438"];
17851 [label="var diagnostics = DiagnosticBag.GetInstance(); 381439"];
17852 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 381440"];
17853 [label="BuildMembersAndInitializers(diagnostics) 381441"];
17854 [label="param BuildMembersAndInitializers(DiagnosticBag diagnostics) 381442"];
17855 [label="param BuildMembersAndInitializers(this) 381443"];
17856 [label="getDeclaredMembersAndInitializers() 381444"];
17857 [label="DeclaredMembersAndInitializers? getDeclaredMembersAndInitializers()\n            {\n                var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers;\n                if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                }\n\n                if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics);\n\n                var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel);\n                if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                }\n\n                AddDeclarationDiagnostics(diagnostics);\n                diagnostics.Free();\n\n                return declaredMembersAndInitializers!;\n            } 381445"];
17858 [label="var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers; 381446"];
17859 [label="if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                } 381447"];
17860 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                } 381448"];
17861 [label="var diagnostics = DiagnosticBag.GetInstance(); 381449"];
17862 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 381450"];
17863 [label="buildDeclaredMembersAndInitializers(diagnostics) 381451"];
17864 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 381452"];
17865 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 381453"];
17866 [label="var builder = new DeclaredMembersAndInitializersBuilder(); 381454"];
17867 [label="new DeclaredMembersAndInitializersBuilder() 381455"];
17868 [label="param DeclaredMembersAndInitializersBuilder(this) 381456"];
17869 [label="ArrayBuilder<Symbol>.GetInstance() 381457"];
17870 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance() 381458"];
17871 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 381459"];
17872 [label="StaticInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 381460"];
17873 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 381461"];
17874 [label="InstanceInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 381462"];
17875 [label="HaveIndexers 381463"];
17876 [label="RecordDeclarationWithParameters 381464"];
17877 [label="RecordPrimaryConstructor 381465"];
17878 [label="1 381466"];
17879 [label="InstanceInitializersIndexForRecordDeclarationWithParameters = -1 381467"];
17880 [label="IsNullableEnabledForInstanceConstructorsAndFields 381468"];
17881 [label="IsNullableEnabledForStaticConstructorsAndFields 381469"];
17882 [label="AddDeclaredNontypeMembers(builder, diagnostics); 381470"];
17883 [label="AddDeclaredNontypeMembers(builder, diagnostics); 381471"];
17884 [label="AddDeclaredNontypeMembers(builder, diagnostics) 381472"];
17885 [label="param AddDeclaredNontypeMembers(DeclaredMembersAndInitializersBuilder builder) 381473"];
17886 [label="param AddDeclaredNontypeMembers(DiagnosticBag diagnostics) 381474"];
17887 [label="param AddDeclaredNontypeMembers(this) 381475"];
17888 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                }\n\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                var syntax = decl.SyntaxReference.GetSyntax();\n\n                switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                }\n            } 381476"];
17889 [label="if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                } 381477"];
17890 [label="AddDeclaredNontypeMembers(builder, diagnostics); 381478"];
17891 [label="TypeKind 381479"];
17892 [label="get\n            {\n                return _flags.TypeKind;\n            } 381480"];
17893 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 381481"];
17894 [label="switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                } 381482"];
17895 [label="IsTupleType 381483"];
17896 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 381484"];
17897 [label="_ 381485"];
17898 [label="tupleCardinality: out _ 381486"];
17899 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 381487"];
17900 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 381488"];
17901 [label="param IsTupleTypeOfCardinality(this) 381489"];
17902 [label="IsUnboundGenericType 381490"];
17903 [label="get\n            {\n                return false;\n            } 381491"];
17904 [label="return false; 381492"];
17905 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381493"];
17906 [label="ContainingSymbol 381494"];
17907 [label="get\n            {\n                return _containingSymbol;\n            } 381495"];
17908 [label="return _containingSymbol; 381496"];
17909 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381497"];
17910 [label=".Kind 381498"];
17911 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 381499"];
17912 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381500"];
17913 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381501"];
17914 [label="ContainingNamespace 381502"];
17915 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381503"];
17916 [label="return _containingSymbol; 381504"];
17917 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381505"];
17918 [label="ContainingNamespace.ContainingNamespace 381506"];
17919 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381507"];
17920 [label="=> _container 381508"];
17921 [label="_container 381509"];
17922 [label=".IsGlobalNamespace 381510"];
17923 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 381511"];
17924 [label="ContainingNamespace 381512"];
17925 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381513"];
17926 [label="container.ContainingSymbol 381514"];
17927 [label="get\n            {\n                return _assemblySymbol;\n            } 381515"];
17928 [label="return _assemblySymbol; 381516"];
17929 [label="get\n            {\n                return null;\n            } 381517"];
17930 [label="return null; 381518"];
17931 [label="return (object)ContainingNamespace == null; 381519"];
17932 [label="return (object)ContainingNamespace == null; 381520"];
17933 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381521"];
17934 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381522"];
17935 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381523"];
17936 [label="Name 381524"];
17937 [label="get\n            {\n                return declaration.Name;\n            } 381525"];
17938 [label="return declaration.Name; 381526"];
17939 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381527"];
17940 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381528"];
17941 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381529"];
17942 [label="tupleCardinality = 0; 381530"];
17943 [label="return false; 381531"];
17944 [label="if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                } 381532"];
17945 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 381533"];
17946 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 381534"];
17947 [label="builder.ToReadOnlyAndFree() 381535"];
17948 [label="param ToReadOnlyAndFree(this) 381536"];
17949 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381537"];
17950 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381538"];
17951 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers) 381539"];
17952 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 381540"];
17953 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 381541"];
17954 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 381542"];
17955 [label="initializers.Free(); 381543"];
17956 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 381544"];
17957 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381545"];
17958 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers) 381546"];
17959 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 381547"];
17960 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 381548"];
17961 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 381549"];
17962 [label="initializers.Free(); 381550"];
17963 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 381551"];
17964 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381552"];
17965 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381553"];
17966 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381554"];
17967 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381555"];
17968 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381556"];
17969 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381557"];
17970 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381558"];
17971 [label="new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 381559"];
17972 [label="param DeclaredMembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 381560"];
17973 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 381561"];
17974 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 381562"];
17975 [label="param DeclaredMembersAndInitializers(bool haveIndexers) 381563"];
17976 [label="param DeclaredMembersAndInitializers(RecordDeclarationSyntax? recordDeclarationWithParameters) 381564"];
17977 [label="param DeclaredMembersAndInitializers(SynthesizedRecordConstructor? recordPrimaryConstructor) 381565"];
17978 [label="param DeclaredMembersAndInitializers(int instanceInitializersIndexForRecordDeclarationWithParameters) 381566"];
17979 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 381567"];
17980 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 381568"];
17981 [label="param DeclaredMembersAndInitializers(this) 381569"];
17982 [label="HaveIndexers 381570"];
17983 [label="RecordDeclarationWithParameters 381571"];
17984 [label="RecordPrimaryConstructor 381572"];
17985 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 381573"];
17986 [label="IsNullableEnabledForInstanceConstructorsAndFields 381574"];
17987 [label="IsNullableEnabledForStaticConstructorsAndFields 381575"];
17988 [label="Debug.Assert(!nonTypeMembers.IsDefault); 381576"];
17989 [label="Debug.Assert(!staticInitializers.IsDefault); 381577"];
17990 [label="Debug.Assert(!instanceInitializers.IsDefault); 381578"];
17991 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 381579"];
17992 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 381580"];
17993 [label="Debug.Assert(recordDeclarationWithParameters is object == recordPrimaryConstructor is object); 381581"];
17994 [label="this.NonTypeMembers 381582"];
17995 [label="this.StaticInitializers 381583"];
17996 [label="this.InstanceInitializers 381584"];
17997 [label="this.HaveIndexers 381585"];
17998 [label="this.RecordDeclarationWithParameters 381586"];
17999 [label="this.RecordPrimaryConstructor 381587"];
18000 [label="this.InstanceInitializersIndexForRecordDeclarationWithParameters 381588"];
18001 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 381589"];
18002 [label="this.IsNullableEnabledForStaticConstructorsAndFields 381590"];
18003 [label="return builder.ToReadOnlyAndFree(); 381591"];
18004 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 381592"];
18005 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 381593"];
18006 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 381594"];
18007 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 381595"];
18008 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 381596"];
18009 [label="if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                } 381597"];
18010 [label="AddDeclarationDiagnostics(diagnostics); 381598"];
18011 [label="AddDeclarationDiagnostics(diagnostics) 381599"];
18012 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381600"];
18013 [label="param AddDeclarationDiagnostics(this) 381601"];
18014 [label="ContainingSymbol 381602"];
18015 [label="get\n            {\n                return _containingSymbol;\n            } 381603"];
18016 [label="return _containingSymbol; 381604"];
18017 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381605"];
18018 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381606"];
18019 [label="AddDeclarationDiagnostics(diagnostics); 381607"];
18020 [label="diagnostics.Free(); 381608"];
18021 [label="return declaredMembersAndInitializers!; 381609"];
18022 [label="var declaredMembersAndInitializers = getDeclaredMembersAndInitializers(); 381610"];
18023 [label="if (declaredMembersAndInitializers is null)\n            {\n                // Another thread completed the work before this one\n                return null;\n            } 381611"];
18024 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 381612"];
18025 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 381613"];
18026 [label="new MembersAndInitializersBuilder(declaredMembersAndInitializers) 381614"];
18027 [label="param MembersAndInitializersBuilder(DeclaredMembersAndInitializers declaredMembersAndInitializers) 381615"];
18028 [label="param MembersAndInitializersBuilder(this) 381616"];
18029 [label="NonTypeMembers 381617"];
18030 [label="InstanceInitializersForPositionalMembers 381618"];
18031 [label="IsNullableEnabledForInstanceConstructorsAndFields 381619"];
18032 [label="IsNullableEnabledForStaticConstructorsAndFields 381620"];
18033 [label="Debug.Assert(declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel); 381621"];
18034 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 381622"];
18035 [label="this.IsNullableEnabledForStaticConstructorsAndFields 381623"];
18036 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 381624"];
18037 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 381625"];
18038 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 381626"];
18039 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics) 381627"];
18040 [label="param AddSynthesizedMembers(MembersAndInitializersBuilder builder) 381628"];
18041 [label="param AddSynthesizedMembers(DeclaredMembersAndInitializers declaredMembersAndInitializers) 381629"];
18042 [label="param AddSynthesizedMembers(DiagnosticBag diagnostics) 381630"];
18043 [label="param AddSynthesizedMembers(this) 381631"];
18044 [label="TypeKind 381632"];
18045 [label="get\n            {\n                return _flags.TypeKind;\n            } 381633"];
18046 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 381634"];
18047 [label="switch (TypeKind)\n            {\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                case TypeKind.Class:\n                case TypeKind.Interface:\n                case TypeKind.Submission:\n                    AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    break;\n\n                default:\n                    break;\n            } 381635"];
18048 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381636"];
18049 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381637"];
18050 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381638"];
18051 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 381639"];
18052 [label="param AddSynthesizedRecordMembersIfNecessary(MembersAndInitializersBuilder builder) 381640"];
18053 [label="param AddSynthesizedRecordMembersIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 381641"];
18054 [label="param AddSynthesizedRecordMembersIfNecessary(DiagnosticBag diagnostics) 381642"];
18055 [label="param AddSynthesizedRecordMembersIfNecessary(this) 381643"];
18056 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 381644"];
18057 [label="return; 381645"];
18058 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381646"];
18059 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381647"];
18060 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381648"];
18061 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381649"];
18062 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 381650"];
18063 [label="param AddSynthesizedConstructorsIfNecessary(MembersAndInitializersBuilder builder) 381651"];
18064 [label="param AddSynthesizedConstructorsIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 381652"];
18065 [label="param AddSynthesizedConstructorsIfNecessary(DiagnosticBag diagnostics) 381653"];
18066 [label="param AddSynthesizedConstructorsIfNecessary(this) 381654"];
18067 [label="var hasInstanceConstructor = false; 381655"];
18068 [label="var hasParameterlessInstanceConstructor = false; 381656"];
18069 [label="var hasStaticConstructor = false; 381657"];
18070 [label="var membersSoFar = builder.GetNonTypeMembers(declaredMembersAndInitializers); 381658"];
18071 [label="builder.GetNonTypeMembers(declaredMembersAndInitializers) 381659"];
18072 [label="param GetNonTypeMembers(DeclaredMembersAndInitializers declaredMembers) 381660"];
18073 [label="param GetNonTypeMembers(this) 381661"];
18074 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 381662"];
18075 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 381663"];
18076 [label="foreach (var member in membersSoFar)\n            {\n                if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                }\n\n                //kick out early if we've seen everything we're looking for\n                if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                }\n            } 381664"];
18077 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381665"];
18078 [label="this.IsStructType() 381666"];
18079 [label="param IsStructType(this TypeSymbol type) 381667"];
18080 [label="RoslynDebug.Assert((object)type != null); 381668"];
18081 [label="RoslynDebug.Assert((object)type != null); 381669"];
18082 [label="type.TypeKind 381670"];
18083 [label="get\n            {\n                return _flags.TypeKind;\n            } 381671"];
18084 [label="return type.TypeKind == TypeKind.Struct; 381672"];
18085 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381673"];
18086 [label="this.IsStatic 381674"];
18087 [label="=> HasFlag(DeclarationModifiers.Static) 381675"];
18088 [label="DeclarationModifiers.Static 381676"];
18089 [label="HasFlag(DeclarationModifiers.Static) 381677"];
18090 [label="param HasFlag(DeclarationModifiers flag) 381678"];
18091 [label="=> (_declModifiers & flag) != 0 381679"];
18092 [label="_declModifiers & flag 381680"];
18093 [label="0 381681"];
18094 [label="(_declModifiers & flag) != 0 381682"];
18095 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381683"];
18096 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381684"];
18097 [label="this.IsInterface 381685"];
18098 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 381686"];
18099 [label="this.TypeKind 381687"];
18100 [label="get\n            {\n                return _flags.TypeKind;\n            } 381688"];
18101 [label="return this.TypeKind == TypeKind.Interface; 381689"];
18102 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381690"];
18103 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381691"];
18104 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 381692"];
18105 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 381693"];
18106 [label="hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers) 381694"];
18107 [label="static bool hasNonConstantInitializer(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers)\n            {\n                return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst));\n            } 381695"];
18108 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 381696"];
18109 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 381697"];
18110 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 381698"];
18111 [label="this.IsScriptClass 381699"];
18112 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 381700"];
18113 [label="var kind = this.declaration.Declarations[0].Kind; 381701"];
18114 [label="var kind = this.declaration.Declarations[0].Kind; 381702"];
18115 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 381703"];
18116 [label="if (this.IsScriptClass)\n            {\n                var scriptInitializer = new SynthesizedInteractiveInitializerMethod(this, diagnostics);\n                builder.AddNonTypeMember(scriptInitializer, declaredMembersAndInitializers);\n                var scriptEntryPoint = SynthesizedEntryPointSymbol.Create(scriptInitializer, diagnostics);\n                builder.AddNonTypeMember(scriptEntryPoint, declaredMembersAndInitializers);\n            } 381704"];
18117 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 381705"];
18118 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 381706"];
18119 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 381707"];
18120 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 381708"];
18121 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 381709"];
18122 [label="membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers) 381710"];
18123 [label="param ToReadOnlyAndFree(DeclaredMembersAndInitializers declaredMembers) 381711"];
18124 [label="param ToReadOnlyAndFree(this) 381712"];
18125 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 381713"];
18126 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 381714"];
18127 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 381715"];
18128 [label="var instanceInitializers = InstanceInitializersForPositionalMembers is null\n                    ? declaredMembers.InstanceInitializers\n                    : mergeInitializers(); 381716"];
18129 [label="InstanceInitializersForPositionalMembers is null 381717"];
18130 [label="declaredMembers.InstanceInitializers 381718"];
18131 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381719"];
18132 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381720"];
18133 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381721"];
18134 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381722"];
18135 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381723"];
18136 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 381724"];
18137 [label="new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 381725"];
18138 [label="param MembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 381726"];
18139 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 381727"];
18140 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 381728"];
18141 [label="param MembersAndInitializers(bool haveIndexers) 381729"];
18142 [label="param MembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 381730"];
18143 [label="param MembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 381731"];
18144 [label="param MembersAndInitializers(this) 381732"];
18145 [label="HaveIndexers 381733"];
18146 [label="IsNullableEnabledForInstanceConstructorsAndFields 381734"];
18147 [label="IsNullableEnabledForStaticConstructorsAndFields 381735"];
18148 [label="Debug.Assert(!nonTypeMembers.IsDefault); 381736"];
18149 [label="Debug.Assert(!staticInitializers.IsDefault); 381737"];
18150 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 381738"];
18151 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 381739"];
18152 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 381740"];
18153 [label="Debug.Assert(!instanceInitializers.IsDefault); 381741"];
18154 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 381742"];
18155 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 381743"];
18156 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 381744"];
18157 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 381745"];
18158 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 381746"];
18159 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 381747"];
18160 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 381748"];
18161 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 381749"];
18162 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 381750"];
18163 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 381751"];
18164 [label="this.NonTypeMembers 381752"];
18165 [label="this.StaticInitializers 381753"];
18166 [label="this.InstanceInitializers 381754"];
18167 [label="this.HaveIndexers 381755"];
18168 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 381756"];
18169 [label="this.IsNullableEnabledForStaticConstructorsAndFields 381757"];
18170 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 381758"];
18171 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 381759"];
18172 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 381760"];
18173 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 381761"];
18174 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 381762"];
18175 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 381763"];
18176 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 381764"];
18177 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 381765"];
18178 [label="AddDeclarationDiagnostics(diagnostics); 381766"];
18179 [label="AddDeclarationDiagnostics(diagnostics) 381767"];
18180 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381768"];
18181 [label="param AddDeclarationDiagnostics(this) 381769"];
18182 [label="ContainingSymbol 381770"];
18183 [label="get\n            {\n                return _containingSymbol;\n            } 381771"];
18184 [label="return _containingSymbol; 381772"];
18185 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381773"];
18186 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381774"];
18187 [label="AddDeclarationDiagnostics(diagnostics); 381775"];
18188 [label="diagnostics.Free(); 381776"];
18189 [label="_lazyDeclaredMembersAndInitializers = null; 381777"];
18190 [label="_lazyDeclaredMembersAndInitializers 381778"];
18191 [label="return membersAndInitializers!; 381779"];
18192 [label="var membersAndInitializers = GetMembersAndInitializers(); 381780"];
18193 [label="this.IsTupleType 381781"];
18194 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 381782"];
18195 [label="_ 381783"];
18196 [label="tupleCardinality: out _ 381784"];
18197 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 381785"];
18198 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 381786"];
18199 [label="param IsTupleTypeOfCardinality(this) 381787"];
18200 [label="IsUnboundGenericType 381788"];
18201 [label="get\n            {\n                return false;\n            } 381789"];
18202 [label="return false; 381790"];
18203 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381791"];
18204 [label="ContainingSymbol 381792"];
18205 [label="get\n            {\n                return _containingSymbol;\n            } 381793"];
18206 [label="return _containingSymbol; 381794"];
18207 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381795"];
18208 [label=".Kind 381796"];
18209 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 381797"];
18210 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381798"];
18211 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381799"];
18212 [label="ContainingNamespace 381800"];
18213 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381801"];
18214 [label="return _containingSymbol; 381802"];
18215 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381803"];
18216 [label="ContainingNamespace.ContainingNamespace 381804"];
18217 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381805"];
18218 [label="=> _container 381806"];
18219 [label="_container 381807"];
18220 [label=".IsGlobalNamespace 381808"];
18221 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 381809"];
18222 [label="ContainingNamespace 381810"];
18223 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 381811"];
18224 [label="container.ContainingSymbol 381812"];
18225 [label="get\n            {\n                return _assemblySymbol;\n            } 381813"];
18226 [label="return _assemblySymbol; 381814"];
18227 [label="get\n            {\n                return null;\n            } 381815"];
18228 [label="return null; 381816"];
18229 [label="return (object)ContainingNamespace == null; 381817"];
18230 [label="return (object)ContainingNamespace == null; 381818"];
18231 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381819"];
18232 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381820"];
18233 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381821"];
18234 [label="Name 381822"];
18235 [label="get\n            {\n                return declaration.Name;\n            } 381823"];
18236 [label="return declaration.Name; 381824"];
18237 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381825"];
18238 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381826"];
18239 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 381827"];
18240 [label="tupleCardinality = 0; 381828"];
18241 [label="return false; 381829"];
18242 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 381830"];
18243 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 381831"];
18244 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 381832"];
18245 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 381833"];
18246 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 381834"];
18247 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 381835"];
18248 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 381836"];
18249 [label="GetTypeMembersDictionary() 381837"];
18250 [label="param GetTypeMembersDictionary(this) 381838"];
18251 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 381839"];
18252 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 381840"];
18253 [label="var diagnostics = DiagnosticBag.GetInstance(); 381841"];
18254 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 381842"];
18255 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 381843"];
18256 [label="MakeTypeMembers(diagnostics) 381844"];
18257 [label="param MakeTypeMembers(DiagnosticBag diagnostics) 381845"];
18258 [label="param MakeTypeMembers(this) 381846"];
18259 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 381847"];
18260 [label="var conflictDict = new Dictionary<(string, int), SourceNamedTypeSymbol>(); 381848"];
18261 [label="foreach (var childDeclaration in declaration.Children)\n                {\n                    var t = new SourceNamedTypeSymbol(this, childDeclaration, diagnostics);\n                    this.CheckMemberNameDistinctFromType(t, diagnostics);\n\n                    var key = (t.Name, t.Arity);\n                    SourceNamedTypeSymbol? other;\n                    if (conflictDict.TryGetValue(key, out other))\n                    {\n                        if (Locations.Length == 1 || IsPartial)\n                        {\n                            if (t.IsPartial && other.IsPartial)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, t.Locations[0], t);\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, t.Locations[0], this, t.Name);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        conflictDict.Add(key, t);\n                    }\n\n                    symbols.Add(t);\n                } 381849"];
18262 [label="IsInterface 381850"];
18263 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 381851"];
18264 [label="this.TypeKind 381852"];
18265 [label="get\n            {\n                return _flags.TypeKind;\n            } 381853"];
18266 [label="return this.TypeKind == TypeKind.Interface; 381854"];
18267 [label="if (IsInterface)\n                {\n                    foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    }\n                } 381855"];
18268 [label="foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    } 381856"];
18269 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 381857"];
18270 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 381858"];
18271 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 381859"];
18272 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 381860"];
18273 [label="symbols.Count > 0 381861"];
18274 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 381862"];
18275 [label="symbols.Free(); 381863"];
18276 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 381864"];
18277 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 381865"];
18278 [label="AddDeclarationDiagnostics(diagnostics); 381866"];
18279 [label="AddDeclarationDiagnostics(diagnostics) 381867"];
18280 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381868"];
18281 [label="param AddDeclarationDiagnostics(this) 381869"];
18282 [label="ContainingSymbol 381870"];
18283 [label="get\n            {\n                return _containingSymbol;\n            } 381871"];
18284 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381872"];
18285 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381873"];
18286 [label="AddDeclarationDiagnostics(diagnostics); 381874"];
18287 [label="state.NotePartComplete(CompletionPart.TypeMembers); 381875"];
18288 [label="state.NotePartComplete(CompletionPart.TypeMembers) 381876"];
18289 [label="param NotePartComplete(CompletionPart part) 381877"];
18290 [label="diagnostics.Free(); 381878"];
18291 [label="return _lazyTypeMembers; 381879"];
18292 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 381880"];
18293 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()) 381881"];
18294 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<Symbol>> membersByName) 381882"];
18295 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<NamedTypeSymbol>> typesByName) 381883"];
18296 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 381884"];
18297 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 381885"];
18298 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 381886"];
18299 [label="MergePartialMembers(ref membersByName, diagnostics); 381887"];
18300 [label="MergePartialMembers(ref membersByName, diagnostics); 381888"];
18301 [label="MergePartialMembers(ref membersByName, diagnostics) 381889"];
18302 [label="param MergePartialMembers(ref Dictionary<string, ImmutableArray<Symbol>> membersByName) 381890"];
18303 [label="param MergePartialMembers(DiagnosticBag diagnostics) 381891"];
18304 [label="param MergePartialMembers(this) 381892"];
18305 [label="var memberNames = ArrayBuilder<string>.GetInstance(membersByName.Count); 381893"];
18306 [label="memberNames.AddRange(membersByName.Keys); 381894"];
18307 [label="memberNames.AddRange(membersByName.Keys); 381895"];
18308 [label="var methodsBySignature = new Dictionary<MethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.PartialMethodsComparer); 381896"];
18309 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 381897"];
18310 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 381898"];
18311 [label="memberNames.Free(); 381899"];
18312 [label="MergePartialMembers(ref membersByName, diagnostics); 381900"];
18313 [label="return membersByName; 381901"];
18314 [label="var membersDictionary = MakeAllMembers(diagnostics); 381902"];
18315 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 381903"];
18316 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 381904"];
18317 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 381905"];
18318 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 381906"];
18319 [label="AddDeclarationDiagnostics(diagnostics); 381907"];
18320 [label="AddDeclarationDiagnostics(diagnostics) 381908"];
18321 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 381909"];
18322 [label="param AddDeclarationDiagnostics(this) 381910"];
18323 [label="ContainingSymbol 381911"];
18324 [label="get\n            {\n                return _containingSymbol;\n            } 381912"];
18325 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 381913"];
18326 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 381914"];
18327 [label="AddDeclarationDiagnostics(diagnostics); 381915"];
18328 [label="state.NotePartComplete(CompletionPart.Members); 381916"];
18329 [label="state.NotePartComplete(CompletionPart.Members) 381917"];
18330 [label="param NotePartComplete(CompletionPart part) 381918"];
18331 [label="diagnostics.Free(); 381919"];
18332 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 381920"];
18333 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 381921"];
18334 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)) 381922"];
18335 [label="param SpinWaitComplete(CompletionPart part) 381923"];
18336 [label="param SpinWaitComplete(CancellationToken cancellationToken) 381924"];
18337 [label="param SpinWaitComplete(this) 381925"];
18338 [label="if (HasComplete(part))\n            {\n                return;\n            } 381926"];
18339 [label="HasComplete(part) 381927"];
18340 [label="param HasComplete(CompletionPart part) 381928"];
18341 [label="param HasComplete(this) 381929"];
18342 [label="return (_completeParts & (int)part) == (int)part; 381930"];
18343 [label="return; 381931"];
18344 [label="return _lazyMembersDictionary; 381932"];
18345 [label="return GetMembersByNameSlow(); 381933"];
18346 [label="this.GetMembersByName(); 381934"];
18347 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 381935"];
18348 [label="param SpinWaitComplete(CompletionPart part) 381936"];
18349 [label="param SpinWaitComplete(this) 381937"];
18350 [label="if (HasComplete(part))\n            {\n                return;\n            } 381938"];
18351 [label="param HasComplete(CompletionPart part) 381939"];
18352 [label="param HasComplete(this) 381940"];
18353 [label="return (_completeParts & (int)part) == (int)part; 381941"];
18354 [label="return; 381942"];
18355 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 381943"];
18356 [label="param HasAtMostOneBitSet(int bits) 381944"];
18357 [label="return (bits & (bits - 1)) == 0; 381945"];
18358 [label="this.GetSynthesizedExplicitImplementations(cancellationToken); 381946"];
18359 [label="this.GetSynthesizedExplicitImplementations(cancellationToken) 381947"];
18360 [label="param GetSynthesizedExplicitImplementations(CancellationToken cancellationToken) 381948"];
18361 [label="param GetSynthesizedExplicitImplementations(this) 381949"];
18362 [label="if (_lazySynthesizedExplicitImplementations.IsDefault)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                try\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckMembersAgainstBaseType(diagnostics, cancellationToken);\n\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckAbstractClassImplementations(diagnostics);\n\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckInterfaceUnification(diagnostics);\n\n                    if (this.IsInterface)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        this.CheckInterfaceVarianceSafety(diagnostics);\n                    }\n\n                    if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    }\n                }\n                finally\n                {\n                    diagnostics.Free();\n                }\n            } 381950"];
18363 [label="var diagnostics = DiagnosticBag.GetInstance(); 381951"];
18364 [label="cancellationToken.ThrowIfCancellationRequested(); 381952"];
18365 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 381953"];
18366 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 381954"];
18367 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken) 381955"];
18368 [label="param CheckMembersAgainstBaseType(DiagnosticBag diagnostics) 381956"];
18369 [label="param CheckMembersAgainstBaseType(CancellationToken cancellationToken) 381957"];
18370 [label="param CheckMembersAgainstBaseType(this) 381958"];
18371 [label="this.TypeKind 381959"];
18372 [label="get\n            {\n                return _flags.TypeKind;\n            } 381960"];
18373 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 381961"];
18374 [label="switch (this.TypeKind)\n            {\n                // These checks don't make sense for enums and delegates:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                    return;\n\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Submission: // we have to check that 'override' is not used\n                    break;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.TypeKind);\n            } 381962"];
18375 [label="this.GetMembersUnordered() 381963"];
18376 [label="param GetMembersUnordered(this) 381964"];
18377 [label="var result = _lazyMembersFlattened; 381965"];
18378 [label="if (result.IsDefault)\n            {\n                result = GetMembersByName().Flatten(null);  // do not sort.\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result);\n                result = _lazyMembersFlattened;\n            } 381966"];
18379 [label="GetMembersByName() 381967"];
18380 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 381968"];
18381 [label="this.state.HasComplete(CompletionPart.Members) 381969"];
18382 [label="param HasComplete(CompletionPart part) 381970"];
18383 [label="param HasComplete(this) 381971"];
18384 [label="return (_completeParts & (int)part) == (int)part; 381972"];
18385 [label="return _lazyMembersDictionary!; 381973"];
18386 [label="result = GetMembersByName().Flatten(null); 381974"];
18387 [label="result = GetMembersByName().Flatten(null); 381975"];
18388 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 381976"];
18389 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 381977"];
18390 [label="result = _lazyMembersFlattened; 381978"];
18391 [label="return result.ConditionallyDeOrder(); 381979"];
18392 [label="foreach (var member in this.GetMembersUnordered())\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n\n                bool suppressAccessors;\n                switch (member.Kind)\n                {\n                    case SymbolKind.Method:\n                        var method = (MethodSymbol)member;\n                        if (MethodSymbol.CanOverrideOrHide(method.MethodKind) && !method.IsAccessor())\n                        {\n                            if (member.IsOverride)\n                            {\n                                CheckOverrideMember(method, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                            }\n                            else\n                            {\n                                var sourceMethod = method as SourceMemberMethodSymbol;\n                                if ((object)sourceMethod != null) // skip submission initializer\n                                {\n                                    var isNew = sourceMethod.IsNew;\n                                    CheckNonOverrideMember(method, isNew, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (method.MethodKind == MethodKind.Destructor)\n                        {\n                            // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.\n\n                            // First is fine, since there should only be one, since there are no parameters.\n                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(out _);\n\n                            // NOTE: Dev11 doesn't expose symbols, so it can treat destructors as override and let them go through the normal\n                            // checks.  Roslyn can't, since the language says they are not virtual/override and that's what we need to expose\n                            // in the symbol model.  Having said that, Dev11 doesn't seem to produce override errors other than this one\n                            // (see SymbolPreparer::prepareOperator).\n                            if ((object)overridden != null && overridden.IsMetadataFinal)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_CantOverrideSealed, method.Locations[0], method, overridden);\n                            }\n                        }\n                        break;\n                    case SymbolKind.Property:\n                        var property = (PropertySymbol)member;\n                        var getMethod = property.GetMethod;\n                        var setMethod = property.SetMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding property.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(property, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckOverrideMember(getMethod, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckOverrideMember(setMethod, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (property is SourcePropertySymbolBase sourceProperty)\n                        {\n                            var isNewProperty = sourceProperty.IsNew;\n                            CheckNonOverrideMember(property, isNewProperty, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckNonOverrideMember(getMethod, isNewProperty, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckNonOverrideMember(setMethod, isNewProperty, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Event:\n                        var @event = (EventSymbol)member;\n                        var addMethod = @event.AddMethod;\n                        var removeMethod = @event.RemoveMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding event.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(@event, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckOverrideMember(addMethod, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckOverrideMember(removeMethod, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            var isNewEvent = ((SourceEventSymbol)@event).IsNew;\n                            CheckNonOverrideMember(@event, isNewEvent, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckNonOverrideMember(addMethod, isNewEvent, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckNonOverrideMember(removeMethod, isNewEvent, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        var sourceField = member as SourceFieldSymbol;\n                        var isNewField = (object)sourceField != null && sourceField.IsNew;\n\n                        // We don't want to report diagnostics for field-like event backing fields (redundant),\n                        // but that shouldn't be an issue since they shouldn't be in the member list.\n                        Debug.Assert((object)sourceField == null || (object)sourceField.AssociatedSymbol == null ||\n                            sourceField.AssociatedSymbol.Kind != SymbolKind.Event);\n\n                        CheckNewModifier(member, isNewField, diagnostics);\n                        break;\n                    case SymbolKind.NamedType:\n                        CheckNewModifier(member, ((SourceMemberContainerTypeSymbol)member).IsNew, diagnostics);\n                        break;\n                }\n            } 381980"];
18393 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 381981"];
18394 [label="cancellationToken.ThrowIfCancellationRequested(); 381982"];
18395 [label="CheckAbstractClassImplementations(diagnostics); 381983"];
18396 [label="CheckAbstractClassImplementations(diagnostics) 381984"];
18397 [label="param CheckAbstractClassImplementations(DiagnosticBag diagnostics) 381985"];
18398 [label="param CheckAbstractClassImplementations(this) 381986"];
18399 [label="this.BaseTypeNoUseSiteDiagnostics 381987"];
18400 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 381988"];
18401 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 381989"];
18402 [label="return _lazyBaseType; 381990"];
18403 [label="NamedTypeSymbol baseType = this.BaseTypeNoUseSiteDiagnostics; 381991"];
18404 [label="this.IsAbstract 381992"];
18405 [label="=> HasFlag(DeclarationModifiers.Abstract) 381993"];
18406 [label="DeclarationModifiers.Abstract 381994"];
18407 [label="HasFlag(DeclarationModifiers.Abstract) 381995"];
18408 [label="param HasFlag(DeclarationModifiers flag) 381996"];
18409 [label="=> (_declModifiers & flag) != 0 381997"];
18410 [label="_declModifiers & flag 381998"];
18411 [label="0 381999"];
18412 [label="(_declModifiers & flag) != 0 382000"];
18413 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 382001"];
18414 [label="return; 382002"];
18415 [label="CheckAbstractClassImplementations(diagnostics); 382003"];
18416 [label="cancellationToken.ThrowIfCancellationRequested(); 382004"];
18417 [label="CheckInterfaceUnification(diagnostics); 382005"];
18418 [label="CheckInterfaceUnification(diagnostics) 382006"];
18419 [label="param CheckInterfaceUnification(DiagnosticBag diagnostics) 382007"];
18420 [label="param CheckInterfaceUnification(this) 382008"];
18421 [label="this.IsGenericType 382009"];
18422 [label="get\n            {\n                for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            } 382010"];
18423 [label="for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                } 382011"];
18424 [label="for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                } 382012"];
18425 [label="current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 382013"];
18426 [label="get\n            {\n                return GetTypeParametersAsTypeArguments();\n            } 382014"];
18427 [label="GetTypeParametersAsTypeArguments() 382015"];
18428 [label="param GetTypeParametersAsTypeArguments(this) 382016"];
18429 [label="this.TypeParameters 382017"];
18430 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 382018"];
18431 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 382019"];
18432 [label="return _lazyTypeParameters; 382020"];
18433 [label="return TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters); 382021"];
18434 [label="TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters) 382022"];
18435 [label="param TypeParametersAsTypeSymbolsWithAnnotations(ImmutableArray<TypeParameterSymbol> typeParameters) 382023"];
18436 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 382024"];
18437 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 382025"];
18438 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 382026"];
18439 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 382027"];
18440 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 382028"];
18441 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 382029"];
18442 [label="typeSymbol.IsNullableType() 382030"];
18443 [label="param IsNullableType(this TypeSymbol type) 382031"];
18444 [label="type.OriginalDefinition 382032"];
18445 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 382033"];
18446 [label="get\n            {\n                return this.OriginalDefinition;\n            } 382034"];
18447 [label="this.OriginalDefinition 382035"];
18448 [label="get\n            {\n                return this;\n            } 382036"];
18449 [label="return this; 382037"];
18450 [label="return this.OriginalDefinition; 382038"];
18451 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 382039"];
18452 [label="type.OriginalDefinition.SpecialType 382040"];
18453 [label="get\n            {\n                return SpecialType.None;\n            } 382041"];
18454 [label="return SpecialType.None; 382042"];
18455 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 382043"];
18456 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 382044"];
18457 [label="var a1 = defaultType is null; 382045"];
18458 [label="!a1 382046"];
18459 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 382047"];
18460 [label="defaultType.IsNullableType() 382048"];
18461 [label="param IsNullableType(this TypeSymbol type) 382049"];
18462 [label="type.OriginalDefinition 382050"];
18463 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 382051"];
18464 [label="get\n            {\n                return this.OriginalDefinition;\n            } 382052"];
18465 [label="this.OriginalDefinition 382053"];
18466 [label="get\n            {\n                return this;\n            } 382054"];
18467 [label="return this; 382055"];
18468 [label="return this.OriginalDefinition; 382056"];
18469 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 382057"];
18470 [label="type.OriginalDefinition.SpecialType 382058"];
18471 [label="get\n            {\n                return SpecialType.None;\n            } 382059"];
18472 [label="return SpecialType.None; 382060"];
18473 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 382061"];
18474 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 382062"];
18475 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 382063"];
18476 [label="Debug.Assert(a1 || a2 != true || a3); 382064"];
18477 [label="Debug.Assert(a1 || a2 != true || a3); 382065"];
18478 [label="Debug.Assert(extensions != null); 382066"];
18479 [label="Debug.Assert(extensions != null); 382067"];
18480 [label="return GetTypeParametersAsTypeArguments(); 382068"];
18481 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 382069"];
18482 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 382070"];
18483 [label="return true; 382071"];
18484 [label="if (!this.IsGenericType)\n            {\n                return;\n            } 382072"];
18485 [label="this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics 382073"];
18486 [label="get\n            {\n                var info = this.GetInterfaceInfo();\n                if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                }\n\n                if (info.interfacesAndTheirBaseInterfaces == null)\n                {\n                    Interlocked.CompareExchange(ref info.interfacesAndTheirBaseInterfaces, MakeInterfacesAndTheirBaseInterfaces(this.InterfacesNoUseSiteDiagnostics()), null);\n                }\n\n                return info.interfacesAndTheirBaseInterfaces;\n            } 382074"];
18487 [label="var info = _lazyInterfaceInfo; 382075"];
18488 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382076"];
18489 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382077"];
18490 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382078"];
18491 [label="info.IsDefaultValue() 382079"];
18492 [label="param IsDefaultValue(this) 382080"];
18493 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382081"];
18494 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382082"];
18495 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382083"];
18496 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382084"];
18497 [label="return info; 382085"];
18498 [label="var info = this.GetInterfaceInfo(); 382086"];
18499 [label="if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                } 382087"];
18500 [label="Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty); 382088"];
18501 [label="return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces; 382089"];
18502 [label="int numInterfaces = this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Count; 382090"];
18503 [label="if (numInterfaces < 2)\n            {\n                return;\n            } 382091"];
18504 [label="if (numInterfaces < 2)\n            {\n                return;\n            } 382092"];
18505 [label="return; 382093"];
18506 [label="CheckInterfaceUnification(diagnostics); 382094"];
18507 [label="this.IsInterface 382095"];
18508 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 382096"];
18509 [label="this.TypeKind 382097"];
18510 [label="get\n            {\n                return _flags.TypeKind;\n            } 382098"];
18511 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 382099"];
18512 [label="return this.TypeKind == TypeKind.Interface; 382100"];
18513 [label="if (this.IsInterface)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        this.CheckInterfaceVarianceSafety(diagnostics);\n                    } 382101"];
18514 [label="cancellationToken.ThrowIfCancellationRequested(); 382102"];
18515 [label="this.CheckInterfaceVarianceSafety(diagnostics); 382103"];
18516 [label="this.CheckInterfaceVarianceSafety(diagnostics); 382104"];
18517 [label="this.CheckInterfaceVarianceSafety(diagnostics) 382105"];
18518 [label="param CheckInterfaceVarianceSafety(this NamedTypeSymbol interfaceType) 382106"];
18519 [label="param CheckInterfaceVarianceSafety(DiagnosticBag diagnostics) 382107"];
18520 [label="Debug.Assert((object)interfaceType != null && interfaceType.IsInterface); 382108"];
18521 [label="Debug.Assert((object)interfaceType != null && interfaceType.IsInterface); 382109"];
18522 [label="interfaceType.IsInterface 382110"];
18523 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 382111"];
18524 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 382112"];
18525 [label="Debug.Assert((object)interfaceType != null && interfaceType.IsInterface); 382113"];
18526 [label="foreach (NamedTypeSymbol baseInterface in interfaceType.InterfacesNoUseSiteDiagnostics())\n            {\n                IsVarianceUnsafe(\n                    baseInterface,\n                    requireOutputSafety: true,\n                    requireInputSafety: false,\n                    context: baseInterface,\n                    locationProvider: i => null,\n                    locationArg: baseInterface,\n                    diagnostics: diagnostics);\n            } 382114"];
18527 [label="interfaceType.InterfacesNoUseSiteDiagnostics() 382115"];
18528 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 382116"];
18529 [label="param InterfacesNoUseSiteDiagnostics(this) 382117"];
18530 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 382118"];
18531 [label="return _lazyInterfaces; 382119"];
18532 [label="foreach (NamedTypeSymbol baseInterface in interfaceType.InterfacesNoUseSiteDiagnostics())\n            {\n                IsVarianceUnsafe(\n                    baseInterface,\n                    requireOutputSafety: true,\n                    requireInputSafety: false,\n                    context: baseInterface,\n                    locationProvider: i => null,\n                    locationArg: baseInterface,\n                    diagnostics: diagnostics);\n            } 382120"];
18533 [label="interfaceType.GetMembersUnordered() 382121"];
18534 [label="param GetMembersUnordered(this) 382122"];
18535 [label="var result = _lazyMembersFlattened; 382123"];
18536 [label="foreach (Symbol member in interfaceType.GetMembersUnordered())\n            {\n                switch (member.Kind)\n                {\n                    case SymbolKind.Method:\n                        if (!member.IsAccessor())\n                        {\n                            CheckMethodVarianceSafety((MethodSymbol)member, diagnostics);\n                        }\n                        break;\n                    case SymbolKind.Property:\n                        CheckPropertyVarianceSafety((PropertySymbol)member, diagnostics);\n                        break;\n                    case SymbolKind.Event:\n                        CheckEventVarianceSafety((EventSymbol)member, diagnostics);\n                        break;\n                    case SymbolKind.NamedType:\n                        CheckNestedTypeVarianceSafety((NamedTypeSymbol)member, diagnostics);\n                        break;\n                }\n            } 382124"];
18537 [label="this.CheckInterfaceVarianceSafety(diagnostics); 382125"];
18538 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382126"];
18539 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382127"];
18540 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382128"];
18541 [label="ComputeInterfaceImplementations(diagnostics, cancellationToken) 382129"];
18542 [label="param ComputeInterfaceImplementations(DiagnosticBag diagnostics) 382130"];
18543 [label="param ComputeInterfaceImplementations(CancellationToken cancellationToken) 382131"];
18544 [label="param ComputeInterfaceImplementations(this) 382132"];
18545 [label="var synthesizedImplementations = ArrayBuilder<SynthesizedExplicitImplementationForwardingMethod>.GetInstance(); 382133"];
18546 [label="this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics 382134"];
18547 [label="get\n            {\n                var info = this.GetInterfaceInfo();\n                if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                }\n\n                if (info.interfacesAndTheirBaseInterfaces == null)\n                {\n                    Interlocked.CompareExchange(ref info.interfacesAndTheirBaseInterfaces, MakeInterfacesAndTheirBaseInterfaces(this.InterfacesNoUseSiteDiagnostics()), null);\n                }\n\n                return info.interfacesAndTheirBaseInterfaces;\n            } 382135"];
18548 [label="var info = _lazyInterfaceInfo; 382136"];
18549 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382137"];
18550 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382138"];
18551 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382139"];
18552 [label="info.IsDefaultValue() 382140"];
18553 [label="param IsDefaultValue(this) 382141"];
18554 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382142"];
18555 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382143"];
18556 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382144"];
18557 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382145"];
18558 [label="return info; 382146"];
18559 [label="var info = this.GetInterfaceInfo(); 382147"];
18560 [label="if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                } 382148"];
18561 [label="Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty); 382149"];
18562 [label="return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces; 382150"];
18563 [label="MultiDictionary<NamedTypeSymbol, NamedTypeSymbol> interfacesAndTheirBases = this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics; 382151"];
18564 [label="this.AllInterfacesNoUseSiteDiagnostics 382152"];
18565 [label="get\n            {\n                return GetAllInterfaces();\n            } 382153"];
18566 [label="GetAllInterfaces() 382154"];
18567 [label="param GetAllInterfaces(this) 382155"];
18568 [label="this.GetInterfaceInfo() 382156"];
18569 [label="param GetInterfaceInfo(this) 382157"];
18570 [label="var info = _lazyInterfaceInfo; 382158"];
18571 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382159"];
18572 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 382160"];
18573 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382161"];
18574 [label="info.IsDefaultValue() 382162"];
18575 [label="param IsDefaultValue(this) 382163"];
18576 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382164"];
18577 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 382165"];
18578 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382166"];
18579 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 382167"];
18580 [label="return info; 382168"];
18581 [label="var info = this.GetInterfaceInfo(); 382169"];
18582 [label="if (info == s_noInterfaces)\n            {\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 382170"];
18583 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 382171"];
18584 [label="return GetAllInterfaces(); 382172"];
18585 [label="foreach (var @interface in this.AllInterfacesNoUseSiteDiagnostics)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n\n                if (!interfacesAndTheirBases[@interface].Contains(@interface))\n                {\n                    continue;\n                }\n\n                HasBaseTypeDeclaringInterfaceResult? hasBaseClassDeclaringInterface = null;\n\n                foreach (var interfaceMember in @interface.GetMembersUnordered())\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    // Only require implementations for members that can be implemented in C#.\n                    SymbolKind interfaceMemberKind = interfaceMember.Kind;\n                    switch (interfaceMemberKind)\n                    {\n                        case SymbolKind.Method:\n                        case SymbolKind.Property:\n                        case SymbolKind.Event:\n                            if (!interfaceMember.IsImplementableInterfaceMember())\n                            {\n                                continue;\n                            }\n                            break;\n                        default:\n                            continue;\n                    }\n\n                    SymbolAndDiagnostics implementingMemberAndDiagnostics;\n\n                    if (this.IsInterface)\n                    {\n                        MultiDictionary<Symbol, Symbol>.ValueSet explicitImpl = this.GetExplicitImplementationForInterfaceMember(interfaceMember);\n\n                        switch (explicitImpl.Count)\n                        {\n                            case 0:\n                                continue; // There is no requirement to implement anything in an interface\n                            case 1:\n                                implementingMemberAndDiagnostics = new SymbolAndDiagnostics(explicitImpl.Single(), ImmutableArray<Diagnostic>.Empty);\n                                break;\n                            default:\n                                Diagnostic diag = new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_DuplicateExplicitImpl, interfaceMember), this.Locations[0]);\n                                implementingMemberAndDiagnostics = new SymbolAndDiagnostics(null, ImmutableArray.Create(diag));\n                                break;\n                        }\n                    }\n                    else\n                    {\n                        implementingMemberAndDiagnostics = this.FindImplementationForInterfaceMemberInNonInterfaceWithDiagnostics(interfaceMember);\n                    }\n\n                    var implementingMember = implementingMemberAndDiagnostics.Symbol;\n                    var synthesizedImplementation = this.SynthesizeInterfaceMemberImplementation(implementingMemberAndDiagnostics, interfaceMember);\n\n                    bool wasImplementingMemberFound = (object)implementingMember != null;\n\n                    if ((object)synthesizedImplementation != null)\n                    {\n                        if (synthesizedImplementation.IsVararg)\n                        {\n                            diagnostics.Add(\n                                ErrorCode.ERR_InterfaceImplementedImplicitlyByVariadic,\n                                GetImplicitImplementationDiagnosticLocation(interfaceMember, this, implementingMember), implementingMember, interfaceMember, this);\n                        }\n                        else\n                        {\n                            synthesizedImplementations.Add(synthesizedImplementation);\n                        }\n                    }\n\n                    if (wasImplementingMemberFound && interfaceMemberKind == SymbolKind.Event)\n                    {\n                        // NOTE: unlike dev11, we're including a related location for the implementing type, because\n                        // otherwise the only error location will be in the containing type of the implementing event\n                        // (i.e. no indication of which type's interface list is actually problematic).\n\n                        EventSymbol interfaceEvent = (EventSymbol)interfaceMember;\n                        EventSymbol implementingEvent = (EventSymbol)implementingMember;\n                        EventSymbol maybeWinRTEvent;\n                        EventSymbol maybeRegularEvent;\n\n                        if (interfaceEvent.IsWindowsRuntimeEvent)\n                        {\n                            maybeWinRTEvent = interfaceEvent; // Definitely WinRT.\n                            maybeRegularEvent = implementingEvent; // Maybe regular.\n                        }\n                        else\n                        {\n                            maybeWinRTEvent = implementingEvent; // Maybe WinRT.\n                            maybeRegularEvent = interfaceEvent; // Definitely regular.\n                        }\n\n                        if (interfaceEvent.IsWindowsRuntimeEvent != implementingEvent.IsWindowsRuntimeEvent)\n                        {\n                            // At this point (and not before), we know that maybeWinRTEvent is definitely a WinRT event and maybeRegularEvent is definitely a regular event.\n                            var args = new object[] { implementingEvent, interfaceEvent, maybeWinRTEvent, maybeRegularEvent };\n                            var info = new CSDiagnosticInfo(ErrorCode.ERR_MixingWinRTEventWithRegular, args, ImmutableArray<Symbol>.Empty, ImmutableArray.Create<Location>(this.Locations[0]));\n                            diagnostics.Add(info, implementingEvent.Locations[0]);\n                        }\n                    }\n\n                    // Dev10: If a whole property is missing, report the property.  If the property is present, but an accessor\n                    // is missing, report just the accessor.\n\n                    var associatedPropertyOrEvent = interfaceMemberKind == SymbolKind.Method ? ((MethodSymbol)interfaceMember).AssociatedSymbol : null;\n                    if ((object)associatedPropertyOrEvent == null ||\n                        ReportAccessorOfInterfacePropertyOrEvent(associatedPropertyOrEvent) ||\n                        (wasImplementingMemberFound && !implementingMember.IsAccessor()))\n                    {\n                        //we're here because\n                        //(a) the interface member is not an accessor, or\n                        //(b) the interface member is an accessor of an interesting (see ReportAccessorOfInterfacePropertyOrEvent) property or event, or\n                        //(c) the implementing member exists and is not an accessor.\n                        bool reportedAnError = false;\n                        if (implementingMemberAndDiagnostics.Diagnostics.Any())\n                        {\n                            diagnostics.AddRange(implementingMemberAndDiagnostics.Diagnostics);\n                            reportedAnError = implementingMemberAndDiagnostics.Diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error);\n                        }\n\n                        if (!reportedAnError)\n                        {\n                            if (!wasImplementingMemberFound ||\n                                (!implementingMember.ContainingType.Equals(this, TypeCompareKind.ConsiderEverything) &&\n                                implementingMember.GetExplicitInterfaceImplementations().Contains(interfaceMember, ExplicitInterfaceImplementationTargetMemberEqualityComparer.Instance)))\n                            {\n                                // NOTE: An alternative approach would be to keep track of this while searching for the implementing member.\n                                // In some cases, we might even be able to stop looking and just accept that a base type has things covered\n                                // (though we'd have to be careful about losing diagnostics and we might produce fewer bridge methods).\n                                // However, this approach has the advantage that there is no cost unless we encounter a base type that\n                                // claims to implement an interface, but we can't figure out how (i.e. free in nearly all cases).\n                                hasBaseClassDeclaringInterface = hasBaseClassDeclaringInterface ?? HasBaseClassDeclaringInterface(@interface);\n\n                                HasBaseTypeDeclaringInterfaceResult matchResult = hasBaseClassDeclaringInterface.GetValueOrDefault();\n\n                                if (matchResult != HasBaseTypeDeclaringInterfaceResult.ExactMatch &&\n                                    wasImplementingMemberFound && implementingMember.ContainingType.IsInterface)\n                                {\n                                    HasBaseInterfaceDeclaringInterface(implementingMember.ContainingType, @interface, ref matchResult);\n                                }\n\n                                // If a base type from metadata declares that it implements the interface, we'll just trust it.\n                                // (See fFoundImport in SymbolPreparer::CheckInterfaceMethodImplementation.)\n                                switch (matchResult)\n                                {\n                                    case HasBaseTypeDeclaringInterfaceResult.NoMatch:\n                                        {\n                                            // CONSIDER: Dev10 does not emit this diagnostic for interface properties if the\n                                            // derived type attempts to implement an accessor directly as a method.\n\n                                            // Suppress for bogus properties and events and for indexed properties.\n                                            if (!interfaceMember.MustCallMethodsDirectly() && !interfaceMember.IsIndexedProperty())\n                                            {\n                                                DiagnosticInfo useSiteDiagnostic = interfaceMember.GetUseSiteDiagnostic();\n\n                                                if (useSiteDiagnostic != null && useSiteDiagnostic.DefaultSeverity == DiagnosticSeverity.Error)\n                                                {\n                                                    diagnostics.Add(useSiteDiagnostic, GetImplementsLocationOrFallback(@interface));\n                                                }\n                                                else\n                                                {\n                                                    diagnostics.Add(ErrorCode.ERR_UnimplementedInterfaceMember, GetImplementsLocationOrFallback(@interface), this, interfaceMember);\n                                                }\n                                            }\n                                        }\n                                        break;\n\n                                    case HasBaseTypeDeclaringInterfaceResult.ExactMatch:\n                                        break;\n\n                                    case HasBaseTypeDeclaringInterfaceResult.IgnoringNullableMatch:\n                                        diagnostics.Add(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase, GetImplementsLocationOrFallback(@interface), this, interfaceMember);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(matchResult);\n                                }\n                            }\n\n                            if (wasImplementingMemberFound && interfaceMemberKind == SymbolKind.Method)\n                            {\n                                // Don't report use site errors on properties - we'll report them on each of their accessors.\n\n                                // Don't report use site errors for implementations in other types unless\n                                // a synthesized implementation is needed that invokes the base method.\n                                // We can do so only if there are no use-site errors.\n\n                                if ((object)synthesizedImplementation != null || TypeSymbol.Equals(implementingMember.ContainingType, this, TypeCompareKind.ConsiderEverything2))\n                                {\n                                    DiagnosticInfo useSiteDiagnostic = interfaceMember.GetUseSiteDiagnostic();\n                                    // CAVEAT: don't report ERR_ByRefReturnUnsupported since by-ref return types are\n                                    // specifically allowed for the purposes of interface implementation (for C++ interop).\n                                    // However, if there's a reference to the interface member in source, then we do want\n                                    // to produce a use site error.\n                                    if (useSiteDiagnostic != null && (ErrorCode)useSiteDiagnostic.Code != ErrorCode.ERR_ByRefReturnUnsupported)\n                                    {\n                                        // Don't report a use site error with a location in another compilation.  For example,\n                                        // if the error is that a base type in another assembly implemented an interface member\n                                        // on our behalf and the use site error is that the current assembly does not reference\n                                        // some required assembly, then we want to report the error in the current assembly -\n                                        // not in the implementing assembly.\n                                        Location location = implementingMember.IsFromCompilation(this.DeclaringCompilation)\n                                            ? implementingMember.Locations[0]\n                                            : this.Locations[0];\n                                        Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } 382173"];
18586 [label="return synthesizedImplementations.ToImmutableAndFree(); 382174"];
18587 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382175"];
18588 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382176"];
18589 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 382177"];
18590 [label="AddDeclarationDiagnostics(diagnostics); 382178"];
18591 [label="AddDeclarationDiagnostics(diagnostics) 382179"];
18592 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 382180"];
18593 [label="param AddDeclarationDiagnostics(this) 382181"];
18594 [label="ContainingSymbol 382182"];
18595 [label="get\n            {\n                return _containingSymbol;\n            } 382183"];
18596 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 382184"];
18597 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 382185"];
18598 [label="AddDeclarationDiagnostics(diagnostics); 382186"];
18599 [label="state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations); 382187"];
18600 [label="state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations) 382188"];
18601 [label="param NotePartComplete(CompletionPart part) 382189"];
18602 [label="diagnostics.Free(); 382190"];
18603 [label="return _lazySynthesizedExplicitImplementations; 382191"];
18604 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 382192"];
18605 [label="param SpinWaitComplete(CompletionPart part) 382193"];
18606 [label="param SpinWaitComplete(this) 382194"];
18607 [label="if (HasComplete(part))\n            {\n                return;\n            } 382195"];
18608 [label="param HasComplete(CompletionPart part) 382196"];
18609 [label="param HasComplete(this) 382197"];
18610 [label="return (_completeParts & (int)part) == (int)part; 382198"];
18611 [label="return; 382199"];
18612 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 382200"];
18613 [label="param HasAtMostOneBitSet(int bits) 382201"];
18614 [label="return (bits & (bits - 1)) == 0; 382202"];
18615 [label="if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        } 382203"];
18616 [label="state.NotePartComplete(CompletionPart.StartMemberChecks) 382204"];
18617 [label="param NotePartComplete(CompletionPart part) 382205"];
18618 [label="var diagnostics = DiagnosticBag.GetInstance(); 382206"];
18619 [label="AfterMembersChecks(diagnostics); 382207"];
18620 [label="AfterMembersChecks(diagnostics) 382208"];
18621 [label="param AfterMembersChecks(DiagnosticBag diagnostics) 382209"];
18622 [label="param AfterMembersChecks(this) 382210"];
18623 [label="IsInterface 382211"];
18624 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 382212"];
18625 [label="if (IsInterface)\n            {\n                CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics);\n            } 382213"];
18626 [label="this.GetMembersAndInitializers() 382214"];
18627 [label="var membersAndInitializers = _lazyMembersAndInitializers; 382215"];
18628 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 382216"];
18629 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 382217"];
18630 [label="return membersAndInitializers; 382218"];
18631 [label="CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics); 382219"];
18632 [label="CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics); 382220"];
18633 [label="CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics) 382221"];
18634 [label="param CheckInterfaceMembers(ImmutableArray<Symbol> nonTypeMembers) 382222"];
18635 [label="param CheckInterfaceMembers(DiagnosticBag diagnostics) 382223"];
18636 [label="foreach (var member in nonTypeMembers)\n            {\n                CheckInterfaceMember(member, diagnostics);\n            } 382224"];
18637 [label="CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics); 382225"];
18638 [label="CheckMemberNamesDistinctFromType(diagnostics); 382226"];
18639 [label="CheckMemberNamesDistinctFromType(diagnostics) 382227"];
18640 [label="param CheckMemberNamesDistinctFromType(DiagnosticBag diagnostics) 382228"];
18641 [label="param CheckMemberNamesDistinctFromType(this) 382229"];
18642 [label="GetMembersAndInitializers() 382230"];
18643 [label="param GetMembersAndInitializers(this) 382231"];
18644 [label="var membersAndInitializers = _lazyMembersAndInitializers; 382232"];
18645 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 382233"];
18646 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 382234"];
18647 [label="return membersAndInitializers; 382235"];
18648 [label="foreach (var member in GetMembersAndInitializers().NonTypeMembers)\n            {\n                CheckMemberNameDistinctFromType(member, diagnostics);\n            } 382236"];
18649 [label="CheckMemberNamesDistinctFromType(diagnostics); 382237"];
18650 [label="CheckMemberNameConflicts(diagnostics); 382238"];
18651 [label="CheckMemberNameConflicts(diagnostics) 382239"];
18652 [label="param CheckMemberNameConflicts(DiagnosticBag diagnostics) 382240"];
18653 [label="param CheckMemberNameConflicts(this) 382241"];
18654 [label="GetMembersByName() 382242"];
18655 [label="param GetMembersByName(this) 382243"];
18656 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName = GetMembersByName(); 382244"];
18657 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 382245"];
18658 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 382246"];
18659 [label="CheckIndexerNameConflicts(diagnostics, membersByName) 382247"];
18660 [label="param CheckIndexerNameConflicts(DiagnosticBag diagnostics) 382248"];
18661 [label="param CheckIndexerNameConflicts(Dictionary<string, ImmutableArray<Symbol>> membersByName) 382249"];
18662 [label="param CheckIndexerNameConflicts(this) 382250"];
18663 [label="PooledHashSet<string>? typeParameterNames = null; 382251"];
18664 [label="this.Arity 382252"];
18665 [label="get\n            {\n                return declaration.Arity;\n            } 382253"];
18666 [label="if (this.Arity > 0)\n            {\n                typeParameterNames = PooledHashSet<string>.GetInstance();\n                foreach (TypeParameterSymbol typeParameter in this.TypeParameters)\n                {\n                    typeParameterNames.Add(typeParameter.Name);\n                }\n            } 382254"];
18667 [label="if (this.Arity > 0)\n            {\n                typeParameterNames = PooledHashSet<string>.GetInstance();\n                foreach (TypeParameterSymbol typeParameter in this.TypeParameters)\n                {\n                    typeParameterNames.Add(typeParameter.Name);\n                }\n            } 382255"];
18668 [label="typeParameterNames = PooledHashSet<string>.GetInstance(); 382256"];
18669 [label="this.TypeParameters 382257"];
18670 [label="foreach (TypeParameterSymbol typeParameter in this.TypeParameters)\n                {\n                    typeParameterNames.Add(typeParameter.Name);\n                } 382258"];
18671 [label="typeParameter.Name 382259"];
18672 [label="get\n            {\n                return _name;\n            } 382260"];
18673 [label="return _name; 382261"];
18674 [label="typeParameterNames.Add(typeParameter.Name); 382262"];
18675 [label="typeParameterNames.Add(typeParameter.Name); 382263"];
18676 [label="var indexersBySignature = new Dictionary<PropertySymbol, PropertySymbol>(MemberSignatureComparer.DuplicateSourceComparer); 382264"];
18677 [label="foreach (var members in membersByName.Values)\n            {\n                string? lastIndexerName = null;\n                indexersBySignature.Clear();\n                foreach (var symbol in members)\n                {\n                    if (symbol.IsIndexer())\n                    {\n                        PropertySymbol indexer = (PropertySymbol)symbol;\n                        CheckIndexerSignatureCollisions(\n                            indexer,\n                            diagnostics,\n                            membersByName,\n                            indexersBySignature,\n                            ref lastIndexerName);\n\n                        // Also check for collisions with type parameters, which aren't in the member map.\n                        // NOTE: Accessors have normal names and are handled in CheckTypeParameterNameConflicts.\n                        if (typeParameterNames != null)\n                        {\n                            string indexerName = indexer.MetadataName;\n                            if (typeParameterNames.Contains(indexerName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, indexer.Locations[0], this, indexerName);\n                                continue;\n                            }\n                        }\n                    }\n                }\n            } 382265"];
18678 [label="typeParameterNames?.Free(); 382266"];
18679 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 382267"];
18680 [label="var methodsBySignature = new Dictionary<SourceMemberMethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); 382268"];
18681 [label="var conversionsAsMethods = new Dictionary<SourceMemberMethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); 382269"];
18682 [label="new ConversionSignatureComparer() 382270"];
18683 [label="param ConversionSignatureComparer(this) 382271"];
18684 [label="s_comparer = new ConversionSignatureComparer() 382272"];
18685 [label="ConversionSignatureComparer.Comparer 382273"];
18686 [label="return s_comparer; 382274"];
18687 [label="var conversionsAsConversions = new HashSet<SourceUserDefinedConversionSymbol>(ConversionSignatureComparer.Comparer); 382275"];
18688 [label="foreach (var pair in membersByName)\n            {\n                var name = pair.Key;\n                Symbol? lastSym = GetTypeMembers(name).FirstOrDefault();\n                methodsBySignature.Clear();\n                // Conversion collisions do not consider the name of the conversion,\n                // so do not clear that dictionary.\n                foreach (var symbol in pair.Value)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    }\n\n                    // We detect the first category of conflict by running down the list of members\n                    // of the same name, and producing an error when we discover any of the following\n                    // 'bad transitions'.\n                    //\n                    // * a method or conversion that comes after any field (not necessarily directly)\n                    // * a field directly following a field\n                    // * a field directly following a method or conversion\n                    //\n                    // Furthermore: we do not wish to detect collisions between nested types in\n                    // this code; that is tested elsewhere. However, we do wish to detect a collision\n                    // between a nested type and a field, method or conversion. Therefore we\n                    // initialize our 'bad transition' detector with a type of the given name,\n                    // if there is one. That way we also detect the transitions of 'method following\n                    // type', and so on.\n                    //\n                    // The 'lastSym' local below is used to detect these transitions. Its value is\n                    // one of the following:\n                    //\n                    // * a nested type of the given name, or\n                    // * the first method of the given name, or\n                    // * the most recently processed field of the given name.\n                    //\n                    // If either the current symbol or the 'last symbol' are not methods then\n                    // there must be a collision:\n                    //\n                    // * if the current symbol is not a method and the last symbol is, then\n                    //   there is a field directly following a method of the same name\n                    // * if the current symbol is a method and the last symbol is not, then\n                    //   there is a method directly or indirectly following a field of the same name,\n                    //   or a method of the same name as a nested type.\n                    // * if neither are methods then either we have a field directly\n                    //   following a field of the same name, or a field and a nested type of the same name.\n                    //\n\n                    if (lastSym is object)\n                    {\n                        if (symbol.Kind != SymbolKind.Method || lastSym.Kind != SymbolKind.Method)\n                        {\n                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared)\n                            {\n                                // The type '{0}' already contains a definition for '{1}'\n                                if (Locations.Length == 1 || IsPartial)\n                                {\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, symbol.Locations[0], this, symbol.Name);\n                                }\n                            }\n\n                            if (lastSym.Kind == SymbolKind.Method)\n                            {\n                                lastSym = symbol;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        lastSym = symbol;\n                    }\n\n                    // That takes care of the first category of conflict; we detect the\n                    // second and third categories as follows:\n\n                    var conversion = symbol as SourceUserDefinedConversionSymbol;\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (!(conversion is null))\n                    {\n                        // Does this conversion collide *as a conversion* with any previously-seen\n                        // conversion?\n\n                        if (!conversionsAsConversions.Add(conversion))\n                        {\n                            // CS0557: Duplicate user-defined conversion in type 'C'\n                            diagnostics.Add(ErrorCode.ERR_DuplicateConversionInClass, conversion.Locations[0], this);\n                        }\n                        else\n                        {\n                            // The other set might already contain a conversion which would collide\n                            // *as a method* with the current conversion.\n                            if (!conversionsAsMethods.ContainsKey(conversion))\n                            {\n                                conversionsAsMethods.Add(conversion, conversion);\n                            }\n                        }\n\n                        // Does this conversion collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(conversion, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, conversion, previousMethod);\n                        }\n                        // Do not add the conversion to the set of previously-seen methods; that set\n                        // is only non-conversion methods.\n                    }\n                    else if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    }\n                }\n            } 382276"];
18689 [label="CheckMemberNameConflicts(diagnostics); 382277"];
18690 [label="CheckRecordMemberNames(diagnostics); 382278"];
18691 [label="CheckRecordMemberNames(diagnostics) 382279"];
18692 [label="param CheckRecordMemberNames(DiagnosticBag diagnostics) 382280"];
18693 [label="param CheckRecordMemberNames(this) 382281"];
18694 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 382282"];
18695 [label="return; 382283"];
18696 [label="CheckRecordMemberNames(diagnostics); 382284"];
18697 [label="CheckSpecialMemberErrors(diagnostics); 382285"];
18698 [label="CheckSpecialMemberErrors(diagnostics) 382286"];
18699 [label="param CheckSpecialMemberErrors(DiagnosticBag diagnostics) 382287"];
18700 [label="param CheckSpecialMemberErrors(this) 382288"];
18701 [label="this.ContainingAssembly 382289"];
18702 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 382290"];
18703 [label="var conversions = new TypeConversions(this.ContainingAssembly.CorLibrary); 382291"];
18704 [label="this.ContainingAssembly.CorLibrary 382292"];
18705 [label="get\n            {\n                return _corLibrary;\n            } 382293"];
18706 [label="var conversions = new TypeConversions(this.ContainingAssembly.CorLibrary); 382294"];
18707 [label="new TypeConversions(this.ContainingAssembly.CorLibrary) 382295"];
18708 [label="param TypeConversions(AssemblySymbol corLibrary) 382296"];
18709 [label="param TypeConversions(bool includeNullability = false) 382297"];
18710 [label="param TypeConversions(this) 382298"];
18711 [label="corLibrary 382299"];
18712 [label="0 382300"];
18713 [label="includeNullability 382301"];
18714 [label="null 382302"];
18715 [label="param TypeConversions(this) 382303"];
18716 [label="param TypeConversions(AssemblySymbol corLibrary) 382304"];
18717 [label="param TypeConversions(int currentRecursionDepth) 382305"];
18718 [label="param TypeConversions(bool includeNullability) 382306"];
18719 [label="param TypeConversions(TypeConversions otherNullabilityOpt) 382307"];
18720 [label="param TypeConversions(this) 382308"];
18721 [label="corLibrary 382309"];
18722 [label="currentRecursionDepth 382310"];
18723 [label="includeNullability 382311"];
18724 [label="otherNullabilityOpt 382312"];
18725 [label="param TypeConversions(this) 382313"];
18726 [label="param ConversionsBase(AssemblySymbol corLibrary) 382314"];
18727 [label="param ConversionsBase(int currentRecursionDepth) 382315"];
18728 [label="param ConversionsBase(bool includeNullability) 382316"];
18729 [label="param ConversionsBase(ConversionsBase otherNullabilityOpt) 382317"];
18730 [label="param ConversionsBase(this) 382318"];
18731 [label="corLibrary 382319"];
18732 [label="currentRecursionDepth 382320"];
18733 [label="IncludeNullability 382321"];
18734 [label="_lazyOtherNullability 382322"];
18735 [label="Debug.Assert((object)corLibrary != null); 382323"];
18736 [label="Debug.Assert((object)corLibrary != null); 382324"];
18737 [label="Debug.Assert(otherNullabilityOpt == null || includeNullability != otherNullabilityOpt.IncludeNullability); 382325"];
18738 [label="Debug.Assert(otherNullabilityOpt == null || includeNullability != otherNullabilityOpt.IncludeNullability); 382326"];
18739 [label="Debug.Assert(otherNullabilityOpt == null || currentRecursionDepth == otherNullabilityOpt.currentRecursionDepth); 382327"];
18740 [label="Debug.Assert(otherNullabilityOpt == null || currentRecursionDepth == otherNullabilityOpt.currentRecursionDepth); 382328"];
18741 [label="this.corLibrary 382329"];
18742 [label="this.currentRecursionDepth 382330"];
18743 [label="IncludeNullability 382331"];
18744 [label="_lazyOtherNullability 382332"];
18745 [label="this.GetMembersUnordered() 382333"];
18746 [label="param GetMembersUnordered(this) 382334"];
18747 [label="foreach (var member in this.GetMembersUnordered())\n            {\n                member.AfterAddingTypeMembersChecks(conversions, diagnostics);\n            } 382335"];
18748 [label="CheckSpecialMemberErrors(diagnostics); 382336"];
18749 [label="CheckTypeParameterNameConflicts(diagnostics); 382337"];
18750 [label="CheckTypeParameterNameConflicts(diagnostics) 382338"];
18751 [label="param CheckTypeParameterNameConflicts(DiagnosticBag diagnostics) 382339"];
18752 [label="param CheckTypeParameterNameConflicts(this) 382340"];
18753 [label="this.TypeKind 382341"];
18754 [label="get\n            {\n                return _flags.TypeKind;\n            } 382342"];
18755 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 382343"];
18756 [label="if (this.TypeKind == TypeKind.Delegate)\n            {\n                // Delegates do not have conflicts between their type parameter\n                // names and their methods; it is legal (though odd) to say\n                // delegate void D<Invoke>(Invoke x);\n\n                return;\n            } 382344"];
18757 [label="Locations 382345"];
18758 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 382346"];
18759 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 382347"];
18760 [label="if (Locations.Length == 1 || IsPartial)\n            {\n                foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                }\n            } 382348"];
18761 [label="if (Locations.Length == 1 || IsPartial)\n            {\n                foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                }\n            } 382349"];
18762 [label="TypeParameters 382350"];
18763 [label="foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                } 382351"];
18764 [label="tp.Name 382352"];
18765 [label="get\n            {\n                return _name;\n            } 382353"];
18766 [label="return _name; 382354"];
18767 [label="foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    } 382355"];
18768 [label="GetMembers(tp.Name) 382356"];
18769 [label="param GetMembers(string name) 382357"];
18770 [label="param GetMembers(this) 382358"];
18771 [label="ImmutableArray<Symbol> members; 382359"];
18772 [label="members 382360"];
18773 [label="GetMembersByName() 382361"];
18774 [label="param GetMembersByName(this) 382362"];
18775 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 382363"];
18776 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 382364"];
18777 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 382365"];
18778 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 382366"];
18779 [label="return ImmutableArray<Symbol>.Empty; 382367"];
18780 [label="foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    } 382368"];
18781 [label="return ImmutableArray<Symbol>.Empty; 382369"];
18782 [label="CheckTypeParameterNameConflicts(diagnostics); 382370"];
18783 [label="CheckAccessorNameConflicts(diagnostics); 382371"];
18784 [label="CheckAccessorNameConflicts(diagnostics) 382372"];
18785 [label="param CheckAccessorNameConflicts(DiagnosticBag diagnostics) 382373"];
18786 [label="param CheckAccessorNameConflicts(this) 382374"];
18787 [label="this.GetMembersUnordered() 382375"];
18788 [label="param GetMembersUnordered(this) 382376"];
18789 [label="var result = _lazyMembersFlattened; 382377"];
18790 [label="foreach (Symbol symbol in this.GetMembersUnordered())\n            {\n                if (symbol.IsExplicitInterfaceImplementation())\n                {\n                    // If there's a name conflict it will show up as a more specific\n                    // interface implementation error.\n                    continue;\n                }\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Property:\n                        {\n                            var propertySymbol = (PropertySymbol)symbol;\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: false, diagnostics: diagnostics);\n                            break;\n                        }\n                    case SymbolKind.Event:\n                        {\n                            var eventSymbol = (EventSymbol)symbol;\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: false, diagnostics: diagnostics);\n                            break;\n                        }\n                }\n            } 382378"];
18791 [label="CheckAccessorNameConflicts(diagnostics); 382379"];
18792 [label="KnownCircularStruct 382380"];
18793 [label="get\n            {\n                if (_lazyKnownCircularStruct == (int)ThreeState.Unknown)\n                {\n                    if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    }\n                }\n\n                return _lazyKnownCircularStruct == (int)ThreeState.True;\n            } 382381"];
18794 [label="if (_lazyKnownCircularStruct == (int)ThreeState.Unknown)\n                {\n                    if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    }\n                } 382382"];
18795 [label="TypeKind 382383"];
18796 [label="if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    } 382384"];
18797 [label="Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown); 382385"];
18798 [label="Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown); 382386"];
18799 [label="return _lazyKnownCircularStruct == (int)ThreeState.True; 382387"];
18800 [label="bool unused = KnownCircularStruct; 382388"];
18801 [label="CheckSequentialOnPartialType(diagnostics); 382389"];
18802 [label="CheckSequentialOnPartialType(diagnostics) 382390"];
18803 [label="param CheckSequentialOnPartialType(DiagnosticBag diagnostics) 382391"];
18804 [label="param CheckSequentialOnPartialType(this) 382392"];
18805 [label="IsPartial 382393"];
18806 [label="=> HasFlag(DeclarationModifiers.Partial) 382394"];
18807 [label="DeclarationModifiers.Partial 382395"];
18808 [label="HasFlag(DeclarationModifiers.Partial) 382396"];
18809 [label="param HasFlag(DeclarationModifiers flag) 382397"];
18810 [label="=> (_declModifiers & flag) != 0 382398"];
18811 [label="_declModifiers & flag 382399"];
18812 [label="0 382400"];
18813 [label="(_declModifiers & flag) != 0 382401"];
18814 [label="if (!IsPartial || this.Layout.Kind != LayoutKind.Sequential)\n            {\n                return;\n            } 382402"];
18815 [label="return; 382403"];
18816 [label="CheckSequentialOnPartialType(diagnostics); 382404"];
18817 [label="CheckForProtectedInStaticClass(diagnostics); 382405"];
18818 [label="CheckForProtectedInStaticClass(diagnostics) 382406"];
18819 [label="param CheckForProtectedInStaticClass(DiagnosticBag diagnostics) 382407"];
18820 [label="param CheckForProtectedInStaticClass(this) 382408"];
18821 [label="IsStatic 382409"];
18822 [label="=> HasFlag(DeclarationModifiers.Static) 382410"];
18823 [label="DeclarationModifiers.Static 382411"];
18824 [label="HasFlag(DeclarationModifiers.Static) 382412"];
18825 [label="param HasFlag(DeclarationModifiers flag) 382413"];
18826 [label="=> (_declModifiers & flag) != 0 382414"];
18827 [label="_declModifiers & flag 382415"];
18828 [label="0 382416"];
18829 [label="(_declModifiers & flag) != 0 382417"];
18830 [label="if (!IsStatic)\n            {\n                return;\n            } 382418"];
18831 [label="return; 382419"];
18832 [label="CheckForProtectedInStaticClass(diagnostics); 382420"];
18833 [label="CheckForUnmatchedOperators(diagnostics); 382421"];
18834 [label="CheckForUnmatchedOperators(diagnostics) 382422"];
18835 [label="param CheckForUnmatchedOperators(DiagnosticBag diagnostics) 382423"];
18836 [label="param CheckForUnmatchedOperators(this) 382424"];
18837 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 382425"];
18838 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 382426"];
18839 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName) 382427"];
18840 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382428"];
18841 [label="param CheckForUnmatchedOperator(string operatorName1) 382429"];
18842 [label="param CheckForUnmatchedOperator(string operatorName2) 382430"];
18843 [label="param CheckForUnmatchedOperator(this) 382431"];
18844 [label="var ops1 = this.GetOperators(operatorName1); 382432"];
18845 [label="this.GetOperators(operatorName1) 382433"];
18846 [label="param GetOperators(string name) 382434"];
18847 [label="param GetOperators(this) 382435"];
18848 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382436"];
18849 [label="GetSimpleNonTypeMembers(name) 382437"];
18850 [label="param GetSimpleNonTypeMembers(string name) 382438"];
18851 [label="param GetSimpleNonTypeMembers(this) 382439"];
18852 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382440"];
18853 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382441"];
18854 [label="return GetMembers(name); 382442"];
18855 [label="GetMembers(name) 382443"];
18856 [label="param GetMembers(string name) 382444"];
18857 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 382445"];
18858 [label="return ImmutableArray<Symbol>.Empty; 382446"];
18859 [label="return GetMembers(name); 382447"];
18860 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382448"];
18861 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382449"];
18862 [label="return ImmutableArray<MethodSymbol>.Empty; 382450"];
18863 [label="var ops1 = this.GetOperators(operatorName1); 382451"];
18864 [label="var ops2 = this.GetOperators(operatorName2); 382452"];
18865 [label="this.GetOperators(operatorName2) 382453"];
18866 [label="param GetOperators(string name) 382454"];
18867 [label="param GetOperators(this) 382455"];
18868 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382456"];
18869 [label="GetSimpleNonTypeMembers(name) 382457"];
18870 [label="param GetSimpleNonTypeMembers(string name) 382458"];
18871 [label="param GetSimpleNonTypeMembers(this) 382459"];
18872 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382460"];
18873 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382461"];
18874 [label="return GetMembers(name); 382462"];
18875 [label="return ImmutableArray<Symbol>.Empty; 382463"];
18876 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382464"];
18877 [label="return ImmutableArray<MethodSymbol>.Empty; 382465"];
18878 [label="var ops2 = this.GetOperators(operatorName2); 382466"];
18879 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382467"];
18880 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382468"];
18881 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382469"];
18882 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382470"];
18883 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 382471"];
18884 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382472"];
18885 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382473"];
18886 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382474"];
18887 [label="param CheckForUnmatchedOperator(string operatorName2) 382475"];
18888 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382476"];
18889 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382477"];
18890 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382478"];
18891 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382479"];
18892 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382480"];
18893 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382481"];
18894 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 382482"];
18895 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382483"];
18896 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382484"];
18897 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382485"];
18898 [label="param CheckForUnmatchedOperator(string operatorName2) 382486"];
18899 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382487"];
18900 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382488"];
18901 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 382489"];
18902 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 382490"];
18903 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 382491"];
18904 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName) 382492"];
18905 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382493"];
18906 [label="param CheckForUnmatchedOperator(string operatorName1) 382494"];
18907 [label="param CheckForUnmatchedOperator(string operatorName2) 382495"];
18908 [label="param CheckForUnmatchedOperator(this) 382496"];
18909 [label="var ops1 = this.GetOperators(operatorName1); 382497"];
18910 [label="this.GetOperators(operatorName1) 382498"];
18911 [label="param GetOperators(string name) 382499"];
18912 [label="param GetOperators(this) 382500"];
18913 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382501"];
18914 [label="GetSimpleNonTypeMembers(name) 382502"];
18915 [label="param GetSimpleNonTypeMembers(string name) 382503"];
18916 [label="param GetSimpleNonTypeMembers(this) 382504"];
18917 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382505"];
18918 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382506"];
18919 [label="return GetMembers(name); 382507"];
18920 [label="return ImmutableArray<Symbol>.Empty; 382508"];
18921 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382509"];
18922 [label="return ImmutableArray<MethodSymbol>.Empty; 382510"];
18923 [label="var ops2 = this.GetOperators(operatorName2); 382511"];
18924 [label="this.GetOperators(operatorName2) 382512"];
18925 [label="param GetOperators(string name) 382513"];
18926 [label="param GetOperators(this) 382514"];
18927 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382515"];
18928 [label="GetSimpleNonTypeMembers(name) 382516"];
18929 [label="param GetSimpleNonTypeMembers(string name) 382517"];
18930 [label="param GetSimpleNonTypeMembers(this) 382518"];
18931 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382519"];
18932 [label="return ImmutableArray<Symbol>.Empty; 382520"];
18933 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382521"];
18934 [label="return ImmutableArray<MethodSymbol>.Empty; 382522"];
18935 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382523"];
18936 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382524"];
18937 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382525"];
18938 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382526"];
18939 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 382527"];
18940 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382528"];
18941 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382529"];
18942 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382530"];
18943 [label="param CheckForUnmatchedOperator(string operatorName2) 382531"];
18944 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382532"];
18945 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382533"];
18946 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382534"];
18947 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382535"];
18948 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382536"];
18949 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382537"];
18950 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 382538"];
18951 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382539"];
18952 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382540"];
18953 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382541"];
18954 [label="param CheckForUnmatchedOperator(string operatorName2) 382542"];
18955 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382543"];
18956 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382544"];
18957 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 382545"];
18958 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 382546"];
18959 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 382547"];
18960 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName) 382548"];
18961 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382549"];
18962 [label="param CheckForUnmatchedOperator(string operatorName1) 382550"];
18963 [label="param CheckForUnmatchedOperator(string operatorName2) 382551"];
18964 [label="param CheckForUnmatchedOperator(this) 382552"];
18965 [label="var ops1 = this.GetOperators(operatorName1); 382553"];
18966 [label="this.GetOperators(operatorName1) 382554"];
18967 [label="param GetOperators(string name) 382555"];
18968 [label="param GetOperators(this) 382556"];
18969 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382557"];
18970 [label="GetSimpleNonTypeMembers(name) 382558"];
18971 [label="param GetSimpleNonTypeMembers(string name) 382559"];
18972 [label="param GetSimpleNonTypeMembers(this) 382560"];
18973 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382561"];
18974 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382562"];
18975 [label="return GetMembers(name); 382563"];
18976 [label="return ImmutableArray<Symbol>.Empty; 382564"];
18977 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382565"];
18978 [label="return ImmutableArray<MethodSymbol>.Empty; 382566"];
18979 [label="var ops2 = this.GetOperators(operatorName2); 382567"];
18980 [label="this.GetOperators(operatorName2) 382568"];
18981 [label="param GetOperators(string name) 382569"];
18982 [label="param GetOperators(this) 382570"];
18983 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382571"];
18984 [label="GetSimpleNonTypeMembers(name) 382572"];
18985 [label="param GetSimpleNonTypeMembers(string name) 382573"];
18986 [label="param GetSimpleNonTypeMembers(this) 382574"];
18987 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382575"];
18988 [label="return ImmutableArray<Symbol>.Empty; 382576"];
18989 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382577"];
18990 [label="return ImmutableArray<MethodSymbol>.Empty; 382578"];
18991 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382579"];
18992 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382580"];
18993 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382581"];
18994 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382582"];
18995 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 382583"];
18996 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382584"];
18997 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382585"];
18998 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382586"];
18999 [label="param CheckForUnmatchedOperator(string operatorName2) 382587"];
19000 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382588"];
19001 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382589"];
19002 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382590"];
19003 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382591"];
19004 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382592"];
19005 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382593"];
19006 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 382594"];
19007 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382595"];
19008 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382596"];
19009 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382597"];
19010 [label="param CheckForUnmatchedOperator(string operatorName2) 382598"];
19011 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382599"];
19012 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382600"];
19013 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 382601"];
19014 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 382602"];
19015 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 382603"];
19016 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName) 382604"];
19017 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382605"];
19018 [label="param CheckForUnmatchedOperator(string operatorName1) 382606"];
19019 [label="param CheckForUnmatchedOperator(string operatorName2) 382607"];
19020 [label="param CheckForUnmatchedOperator(this) 382608"];
19021 [label="var ops1 = this.GetOperators(operatorName1); 382609"];
19022 [label="this.GetOperators(operatorName1) 382610"];
19023 [label="param GetOperators(string name) 382611"];
19024 [label="param GetOperators(this) 382612"];
19025 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382613"];
19026 [label="GetSimpleNonTypeMembers(name) 382614"];
19027 [label="param GetSimpleNonTypeMembers(string name) 382615"];
19028 [label="param GetSimpleNonTypeMembers(this) 382616"];
19029 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382617"];
19030 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382618"];
19031 [label="return GetMembers(name); 382619"];
19032 [label="return ImmutableArray<Symbol>.Empty; 382620"];
19033 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382621"];
19034 [label="return ImmutableArray<MethodSymbol>.Empty; 382622"];
19035 [label="var ops2 = this.GetOperators(operatorName2); 382623"];
19036 [label="this.GetOperators(operatorName2) 382624"];
19037 [label="param GetOperators(string name) 382625"];
19038 [label="param GetOperators(this) 382626"];
19039 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 382627"];
19040 [label="GetSimpleNonTypeMembers(name) 382628"];
19041 [label="param GetSimpleNonTypeMembers(string name) 382629"];
19042 [label="param GetSimpleNonTypeMembers(this) 382630"];
19043 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 382631"];
19044 [label="return ImmutableArray<Symbol>.Empty; 382632"];
19045 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 382633"];
19046 [label="return ImmutableArray<MethodSymbol>.Empty; 382634"];
19047 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382635"];
19048 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382636"];
19049 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382637"];
19050 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382638"];
19051 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 382639"];
19052 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382640"];
19053 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382641"];
19054 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382642"];
19055 [label="param CheckForUnmatchedOperator(string operatorName2) 382643"];
19056 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382644"];
19057 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 382645"];
19058 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382646"];
19059 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382647"];
19060 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382648"];
19061 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382649"];
19062 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 382650"];
19063 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 382651"];
19064 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 382652"];
19065 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 382653"];
19066 [label="param CheckForUnmatchedOperator(string operatorName2) 382654"];
19067 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 382655"];
19068 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 382656"];
19069 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 382657"];
19070 [label="CheckForEqualityAndGetHashCode(diagnostics); 382658"];
19071 [label="CheckForEqualityAndGetHashCode(diagnostics) 382659"];
19072 [label="param CheckForEqualityAndGetHashCode(DiagnosticBag diagnostics) 382660"];
19073 [label="param CheckForEqualityAndGetHashCode(this) 382661"];
19074 [label="if (this.IsInterfaceType())\n            {\n                // Interfaces are allowed to define Equals without GetHashCode if they want.\n                return;\n            } 382662"];
19075 [label="this.IsInterfaceType() 382663"];
19076 [label="param IsInterfaceType(this TypeSymbol type) 382664"];
19077 [label="RoslynDebug.Assert((object)type != null); 382665"];
19078 [label="RoslynDebug.Assert((object)type != null); 382666"];
19079 [label="type.Kind 382667"];
19080 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 382668"];
19081 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 382669"];
19082 [label="((NamedTypeSymbol)type).IsInterface 382670"];
19083 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 382671"];
19084 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 382672"];
19085 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 382673"];
19086 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 382674"];
19087 [label="return; 382675"];
19088 [label="CheckForEqualityAndGetHashCode(diagnostics); 382676"];
19089 [label="CheckForUnmatchedOperators(diagnostics); 382677"];
19090 [label="Locations 382678"];
19091 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 382679"];
19092 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 382680"];
19093 [label="var location = Locations[0]; 382681"];
19094 [label="var location = Locations[0]; 382682"];
19095 [label="DeclaringCompilation 382683"];
19096 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 382684"];
19097 [label="this.Kind 382685"];
19098 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 382686"];
19099 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 382687"];
19100 [label="return _containingSymbol; 382688"];
19101 [label="var compilation = DeclaringCompilation; 382689"];
19102 [label="this.IsRefLikeType 382690"];
19103 [label="=> HasFlag(DeclarationModifiers.Ref) 382691"];
19104 [label="DeclarationModifiers.Ref 382692"];
19105 [label="HasFlag(DeclarationModifiers.Ref) 382693"];
19106 [label="param HasFlag(DeclarationModifiers flag) 382694"];
19107 [label="=> (_declModifiers & flag) != 0 382695"];
19108 [label="_declModifiers & flag 382696"];
19109 [label="0 382697"];
19110 [label="(_declModifiers & flag) != 0 382698"];
19111 [label="if (this.IsRefLikeType)\n            {\n                compilation.EnsureIsByRefLikeAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 382699"];
19112 [label="this.IsReadOnly 382700"];
19113 [label="=> HasFlag(DeclarationModifiers.ReadOnly) 382701"];
19114 [label="DeclarationModifiers.ReadOnly 382702"];
19115 [label="HasFlag(DeclarationModifiers.ReadOnly) 382703"];
19116 [label="param HasFlag(DeclarationModifiers flag) 382704"];
19117 [label="=> (_declModifiers & flag) != 0 382705"];
19118 [label="_declModifiers & flag 382706"];
19119 [label="0 382707"];
19120 [label="(_declModifiers & flag) != 0 382708"];
19121 [label="if (this.IsReadOnly)\n            {\n                compilation.EnsureIsReadOnlyAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 382709"];
19122 [label="BaseTypeNoUseSiteDiagnostics 382710"];
19123 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 382711"];
19124 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 382712"];
19125 [label="return _lazyBaseType; 382713"];
19126 [label="var baseType = BaseTypeNoUseSiteDiagnostics; 382714"];
19127 [label="GetInterfacesToEmit() 382715"];
19128 [label="param GetInterfacesToEmit(this) 382716"];
19129 [label="CalculateInterfacesToEmit() 382717"];
19130 [label="param CalculateInterfacesToEmit(this) 382718"];
19131 [label="this.IsDefinition 382719"];
19132 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 382720"];
19133 [label="Debug.Assert(this.IsDefinition); 382721"];
19134 [label="this.ContainingModule 382722"];
19135 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 382723"];
19136 [label="return _containingSymbol; 382724"];
19137 [label="Debug.Assert(this.ContainingModule is SourceModuleSymbol); 382725"];
19138 [label="ArrayBuilder<NamedTypeSymbol> builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 382726"];
19139 [label="HashSet<NamedTypeSymbol> seen = null; 382727"];
19140 [label="InterfacesVisit(this, builder, ref seen); 382728"];
19141 [label="InterfacesVisit(this, builder, ref seen); 382729"];
19142 [label="InterfacesVisit(this, builder, ref seen); 382730"];
19143 [label="InterfacesVisit(this, builder, ref seen) 382731"];
19144 [label="param InterfacesVisit(NamedTypeSymbol namedType) 382732"];
19145 [label="param InterfacesVisit(ArrayBuilder<NamedTypeSymbol> builder) 382733"];
19146 [label="param InterfacesVisit(ref HashSet<NamedTypeSymbol> seen) 382734"];
19147 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 382735"];
19148 [label="namedType.InterfacesNoUseSiteDiagnostics() 382736"];
19149 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 382737"];
19150 [label="param InterfacesNoUseSiteDiagnostics(this) 382738"];
19151 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 382739"];
19152 [label="return _lazyInterfaces; 382740"];
19153 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 382741"];
19154 [label="InterfacesVisit(this, builder, ref seen); 382742"];
19155 [label="return builder.ToImmutableAndFree(); 382743"];
19156 [label="return CalculateInterfacesToEmit(); 382744"];
19157 [label="var interfaces = GetInterfacesToEmit(); 382745"];
19158 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 382746"];
19159 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 382747"];
19160 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 382748"];
19161 [label="hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces) 382749"];
19162 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382750"];
19163 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382751"];
19164 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382752"];
19165 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382753"];
19166 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382754"];
19167 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382755"];
19168 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382756"];
19169 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382757"];
19170 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382758"];
19171 [label="if (compilation.ShouldEmitNullableAttributes(this))\n            {\n                if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                }\n\n                if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                }\n            } 382759"];
19172 [label="compilation.ShouldEmitNullableAttributes(this) 382760"];
19173 [label="param ShouldEmitNullableAttributes(Symbol symbol) 382761"];
19174 [label="param ShouldEmitNullableAttributes(this) 382762"];
19175 [label="RoslynDebug.Assert(symbol is object); 382763"];
19176 [label="symbol.IsDefinition 382764"];
19177 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 382765"];
19178 [label="Debug.Assert(symbol.IsDefinition); 382766"];
19179 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 382767"];
19180 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 382768"];
19181 [label="return _referenceManager; 382769"];
19182 [label="GetBoundReferenceManager(); 382770"];
19183 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 382771"];
19184 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 382772"];
19185 [label="symbol.ContainingModule != SourceModule 382773"];
19186 [label="param !=(Symbol left) 382774"];
19187 [label="param !=(Symbol right) 382775"];
19188 [label="if (right is null)\n            {\n                return left is object;\n            } 382776"];
19189 [label="return (object)left != (object)right && !right.Equals(left); 382777"];
19190 [label="return _lazyEmitNullablePublicOnly.Value(); 382778"];
19191 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 382779"];
19192 [label="return true; 382780"];
19193 [label="if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 382781"];
19194 [label="ShouldEmitNullableContextValue(out _) 382782"];
19195 [label="param ShouldEmitNullableContextValue(out byte value) 382783"];
19196 [label="param ShouldEmitNullableContextValue(this) 382784"];
19197 [label="GetLocalNullableContextValue() 382785"];
19198 [label="param GetLocalNullableContextValue(this) 382786"];
19199 [label="byte? value; 382787"];
19200 [label="if (!_flags.TryGetNullableContext(out value))\n            {\n                value = ComputeNullableContextValue();\n                _flags.SetNullableContext(value);\n            } 382788"];
19201 [label="_flags.TryGetNullableContext(out value) 382789"];
19202 [label="param TryGetNullableContext(out byte? value) 382790"];
19203 [label="param TryGetNullableContext(this) 382791"];
19204 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 382792"];
19205 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 382793"];
19206 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 382794"];
19207 [label="((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value) 382795"];
19208 [label="param TryGetByte(this NullableContextKind kind) 382796"];
19209 [label="param TryGetByte(out byte? value) 382797"];
19210 [label="value = null; 382798"];
19211 [label="if (!_flags.TryGetNullableContext(out value))\n            {\n                value = ComputeNullableContextValue();\n                _flags.SetNullableContext(value);\n            } 382799"];
19212 [label="ComputeNullableContextValue() 382800"];
19213 [label="param ComputeNullableContextValue(this) 382801"];
19214 [label="DeclaringCompilation 382802"];
19215 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 382803"];
19216 [label="this.Kind 382804"];
19217 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 382805"];
19218 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 382806"];
19219 [label="var compilation = DeclaringCompilation; 382807"];
19220 [label="if (!compilation.ShouldEmitNullableAttributes(this))\n            {\n                return null;\n            } 382808"];
19221 [label="compilation.ShouldEmitNullableAttributes(this) 382809"];
19222 [label="param ShouldEmitNullableAttributes(Symbol symbol) 382810"];
19223 [label="param ShouldEmitNullableAttributes(this) 382811"];
19224 [label="symbol.IsDefinition 382812"];
19225 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 382813"];
19226 [label="Debug.Assert(symbol.IsDefinition); 382814"];
19227 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 382815"];
19228 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 382816"];
19229 [label="return _referenceManager; 382817"];
19230 [label="GetBoundReferenceManager(); 382818"];
19231 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 382819"];
19232 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 382820"];
19233 [label="symbol.ContainingModule != SourceModule 382821"];
19234 [label="param !=(Symbol left) 382822"];
19235 [label="param !=(Symbol right) 382823"];
19236 [label="if (right is null)\n            {\n                return left is object;\n            } 382824"];
19237 [label="return (object)left != (object)right && !right.Equals(left); 382825"];
19238 [label="var builder = new MostCommonNullableValueBuilder(); 382826"];
19239 [label="new MostCommonNullableValueBuilder() 382827"];
19240 [label="BaseTypeNoUseSiteDiagnostics 382828"];
19241 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 382829"];
19242 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 382830"];
19243 [label="return _lazyBaseType; 382831"];
19244 [label="var baseType = BaseTypeNoUseSiteDiagnostics; 382832"];
19245 [label="if (baseType is object)\n            {\n                builder.AddValue(TypeWithAnnotations.Create(baseType));\n            } 382833"];
19246 [label="GetInterfacesToEmit() 382834"];
19247 [label="param GetInterfacesToEmit(this) 382835"];
19248 [label="CalculateInterfacesToEmit() 382836"];
19249 [label="param CalculateInterfacesToEmit(this) 382837"];
19250 [label="this.IsDefinition 382838"];
19251 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 382839"];
19252 [label="Debug.Assert(this.IsDefinition); 382840"];
19253 [label="this.ContainingModule 382841"];
19254 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 382842"];
19255 [label="return _containingSymbol; 382843"];
19256 [label="Debug.Assert(this.ContainingModule is SourceModuleSymbol); 382844"];
19257 [label="ArrayBuilder<NamedTypeSymbol> builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 382845"];
19258 [label="HashSet<NamedTypeSymbol> seen = null; 382846"];
19259 [label="InterfacesVisit(this, builder, ref seen); 382847"];
19260 [label="InterfacesVisit(this, builder, ref seen); 382848"];
19261 [label="InterfacesVisit(this, builder, ref seen); 382849"];
19262 [label="InterfacesVisit(this, builder, ref seen) 382850"];
19263 [label="param InterfacesVisit(NamedTypeSymbol namedType) 382851"];
19264 [label="param InterfacesVisit(ArrayBuilder<NamedTypeSymbol> builder) 382852"];
19265 [label="param InterfacesVisit(ref HashSet<NamedTypeSymbol> seen) 382853"];
19266 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 382854"];
19267 [label="namedType.InterfacesNoUseSiteDiagnostics() 382855"];
19268 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 382856"];
19269 [label="param InterfacesNoUseSiteDiagnostics(this) 382857"];
19270 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 382858"];
19271 [label="return _lazyInterfaces; 382859"];
19272 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 382860"];
19273 [label="InterfacesVisit(this, builder, ref seen); 382861"];
19274 [label="return builder.ToImmutableAndFree(); 382862"];
19275 [label="return CalculateInterfacesToEmit(); 382863"];
19276 [label="foreach (var @interface in GetInterfacesToEmit())\n            {\n                builder.AddValue(TypeWithAnnotations.Create(@interface));\n            } 382864"];
19277 [label="TypeParameters 382865"];
19278 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 382866"];
19279 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 382867"];
19280 [label="return _lazyTypeParameters; 382868"];
19281 [label="foreach (var typeParameter in TypeParameters)\n            {\n                typeParameter.GetCommonNullableValues(compilation, ref builder);\n            } 382869"];
19282 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382870"];
19283 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382871"];
19284 [label="typeParameter.GetCommonNullableValues(compilation, ref builder) 382872"];
19285 [label="param GetCommonNullableValues(CSharpCompilation compilation) 382873"];
19286 [label="param GetCommonNullableValues(ref MostCommonNullableValueBuilder builder) 382874"];
19287 [label="param GetCommonNullableValues(this) 382875"];
19288 [label="this.Kind 382876"];
19289 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 382877"];
19290 [label="return SymbolKind.TypeParameter; 382878"];
19291 [label="switch (this.Kind)\n            {\n                case SymbolKind.NamedType:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(this.GetLocalNullableContextValue());\n                    }\n                    break;\n                case SymbolKind.Event:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(((EventSymbol)this).TypeWithAnnotations);\n                    }\n                    break;\n                case SymbolKind.Field:\n                    var field = (FieldSymbol)this;\n                    if (field is TupleElementFieldSymbol tupleElement)\n                    {\n                        field = tupleElement.TupleUnderlyingField;\n                    }\n\n                    if (compilation.ShouldEmitNullableAttributes(field))\n                    {\n                        builder.AddValue(field.TypeWithAnnotations);\n                    }\n                    break;\n                case SymbolKind.Method:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(this.GetLocalNullableContextValue());\n                    }\n                    break;\n                case SymbolKind.Property:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(((PropertySymbol)this).TypeWithAnnotations);\n                        // Attributes are not emitted for property parameters.\n                    }\n                    break;\n                case SymbolKind.Parameter:\n                    builder.AddValue(((ParameterSymbol)this).TypeWithAnnotations);\n                    break;\n                case SymbolKind.TypeParameter:\n                    if (this is SourceTypeParameterSymbolBase typeParameter)\n                    {\n                        builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue());\n                        foreach (var constraintType in typeParameter.ConstraintTypesNoUseSiteDiagnostics)\n                        {\n                            builder.AddValue(constraintType);\n                        }\n                    }\n                    break;\n            } 382879"];
19292 [label="if (this is SourceTypeParameterSymbolBase typeParameter)\n                    {\n                        builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue());\n                        foreach (var constraintType in typeParameter.ConstraintTypesNoUseSiteDiagnostics)\n                        {\n                            builder.AddValue(constraintType);\n                        }\n                    } 382880"];
19293 [label="typeParameter.GetSynthesizedNullableAttributeValue() 382881"];
19294 [label="param GetSynthesizedNullableAttributeValue(this) 382882"];
19295 [label="this.HasReferenceTypeConstraint 382883"];
19296 [label="get\n            {\n                var constraints = this.GetConstraintKinds();\n                return (constraints & TypeParameterConstraintKind.ReferenceType) != 0;\n            } 382884"];
19297 [label="var constraints = this.GetConstraintKinds(); 382885"];
19298 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 382886"];
19299 [label="return (constraints & TypeParameterConstraintKind.ReferenceType) != 0; 382887"];
19300 [label="if (this.HasReferenceTypeConstraint)\n            {\n                switch (this.ReferenceTypeConstraintIsNullable)\n                {\n                    case true:\n                        return NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    case false:\n                        return NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                }\n            }\n            else if (this.HasNotNullConstraint)\n            {\n                return NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n            }\n            else if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382888"];
19301 [label="this.HasNotNullConstraint 382889"];
19302 [label="var constraints = this.GetConstraintKinds(); 382890"];
19303 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 382891"];
19304 [label="return (constraints & TypeParameterConstraintKind.NotNull) != 0; 382892"];
19305 [label="if (this.HasNotNullConstraint)\n            {\n                return NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n            }\n            else if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382893"];
19306 [label="this.HasValueTypeConstraint 382894"];
19307 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382895"];
19308 [label="this.ConstraintTypesNoUseSiteDiagnostics 382896"];
19309 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 382897"];
19310 [label="this.EnsureAllConstraintsAreResolved(); 382898"];
19311 [label="Debug.Assert(!inProgress.ContainsReference(this)); 382899"];
19312 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382900"];
19313 [label="this.IsNotNullable 382901"];
19314 [label="return _ordinal; 382902"];
19315 [label="param GetTypeParameterConstraintKind(this) 382903"];
19316 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 382904"];
19317 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 382905"];
19318 [label="return null; 382906"];
19319 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382907"];
19320 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382908"];
19321 [label="return NullableAnnotationExtensions.ObliviousAttributeValue; 382909"];
19322 [label="builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue()); 382910"];
19323 [label="builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue()); 382911"];
19324 [label="typeParameter.ConstraintTypesNoUseSiteDiagnostics 382912"];
19325 [label="if (!_lazyBounds.IsSet())\n            {\n                EnsureAllConstraintsAreResolved(this.ContainerTypeParameters);\n            } 382913"];
19326 [label="this.EnsureAllConstraintsAreResolved(); 382914"];
19327 [label="Debug.Assert(!inProgress.ContainsReference(this)); 382915"];
19328 [label="foreach (var constraintType in typeParameter.ConstraintTypesNoUseSiteDiagnostics)\n                        {\n                            builder.AddValue(constraintType);\n                        } 382916"];
19329 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382917"];
19330 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382918"];
19331 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382919"];
19332 [label="param GetCommonNullableValues(CSharpCompilation compilation) 382920"];
19333 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 382921"];
19334 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382922"];
19335 [label="this.EnsureAllConstraintsAreResolved(); 382923"];
19336 [label="if ((this.GetConstraintKinds() & TypeParameterConstraintKind.ObliviousNullabilityIfReferenceType) != 0)\n                {\n                    return null;\n                } 382924"];
19337 [label="return null; 382925"];
19338 [label="if (!this.HasValueTypeConstraint && this.ConstraintTypesNoUseSiteDiagnostics.IsEmpty && this.IsNotNullable == false)\n            {\n                return NullableAnnotationExtensions.AnnotatedAttributeValue;\n            } 382926"];
19339 [label="return NullableAnnotationExtensions.ObliviousAttributeValue; 382927"];
19340 [label="builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue()); 382928"];
19341 [label="builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue()); 382929"];
19342 [label="foreach (var constraintType in typeParameter.ConstraintTypesNoUseSiteDiagnostics)\n                        {\n                            builder.AddValue(constraintType);\n                        } 382930"];
19343 [label="typeParameter.GetCommonNullableValues(compilation, ref builder); 382931"];
19344 [label="GetMembersUnordered() 382932"];
19345 [label="param GetMembersUnordered(this) 382933"];
19346 [label="var result = _lazyMembersFlattened; 382934"];
19347 [label="foreach (var member in GetMembersUnordered())\n            {\n                member.GetCommonNullableValues(compilation, ref builder);\n            } 382935"];
19348 [label="return builder.MostCommonValue; 382936"];
19349 [label="value = ComputeNullableContextValue(); 382937"];
19350 [label="_flags.SetNullableContext(value); 382938"];
19351 [label="_flags.SetNullableContext(value) 382939"];
19352 [label="param SetNullableContext(byte? value) 382940"];
19353 [label="param SetNullableContext(this) 382941"];
19354 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 382942"];
19355 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 382943"];
19356 [label="value.ToNullableContextFlags() 382944"];
19357 [label="param ToNullableContextFlags(this byte? value) 382945"];
19358 [label="return NullableContextKind.Oblivious; 382946"];
19359 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 382947"];
19360 [label="return value; 382948"];
19361 [label="byte? localValue = GetLocalNullableContextValue(); 382949"];
19362 [label="if (localValue == null)\n            {\n                value = 0;\n                return false;\n            } 382950"];
19363 [label="if (localValue == null)\n            {\n                value = 0;\n                return false;\n            } 382951"];
19364 [label="value = localValue.GetValueOrDefault(); 382952"];
19365 [label="ContainingSymbol 382953"];
19366 [label="get\n            {\n                return _containingSymbol;\n            } 382954"];
19367 [label="return _containingSymbol; 382955"];
19368 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 382956"];
19369 [label=".GetNullableContextValue() 382957"];
19370 [label="param GetNullableContextValue(this) 382958"];
19371 [label="param GetLocalNullableContextValue(this) 382959"];
19372 [label="=> _container 382960"];
19373 [label="_container 382961"];
19374 [label="param GetLocalNullableContextValue(this) 382962"];
19375 [label="get\n            {\n                return _assemblySymbol;\n            } 382963"];
19376 [label="return _assemblySymbol; 382964"];
19377 [label="param GetLocalNullableContextValue(this) 382965"];
19378 [label="get\n            {\n                return null;\n            } 382966"];
19379 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 382967"];
19380 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 382968"];
19381 [label="return value != containingValue; 382969"];
19382 [label="if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 382970"];
19383 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 382971"];
19384 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 382972"];
19385 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 382973"];
19386 [label="hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces) 382974"];
19387 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382975"];
19388 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382976"];
19389 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382977"];
19390 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 382978"];
19391 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382979"];
19392 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382980"];
19393 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382981"];
19394 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382982"];
19395 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382983"];
19396 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 382984"];
19397 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 382985"];
19398 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 382986"];
19399 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 382987"];
19400 [label="AfterMembersChecks(diagnostics); 382988"];
19401 [label="AddDeclarationDiagnostics(diagnostics); 382989"];
19402 [label="AddDeclarationDiagnostics(diagnostics) 382990"];
19403 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 382991"];
19404 [label="param AddDeclarationDiagnostics(this) 382992"];
19405 [label="ContainingSymbol 382993"];
19406 [label="get\n            {\n                return _containingSymbol;\n            } 382994"];
19407 [label="return _containingSymbol; 382995"];
19408 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 382996"];
19409 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 382997"];
19410 [label="AddDeclarationDiagnostics(diagnostics); 382998"];
19411 [label="DeclaringCompilation 382999"];
19412 [label="this.Kind 383000"];
19413 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 383001"];
19414 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 383002"];
19415 [label="return _containingSymbol; 383003"];
19416 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 383004"];
19417 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 383005"];
19418 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 383006"];
19419 [label="param SymbolDeclaredEvent(Symbol symbol) 383007"];
19420 [label="param SymbolDeclaredEvent(this) 383008"];
19421 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 383009"];
19422 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 383010"];
19423 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 383011"];
19424 [label="var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks); 383012"];
19425 [label="state.NotePartComplete(CompletionPart.FinishMemberChecks) 383013"];
19426 [label="param NotePartComplete(CompletionPart part) 383014"];
19427 [label="param NotePartComplete(this) 383015"];
19428 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 383016"];
19429 [label="Debug.Assert(thisThreadCompleted); 383017"];
19430 [label="diagnostics.Free(); 383018"];
19431 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 383019"];
19432 [label="param SpinWaitComplete(CompletionPart part) 383020"];
19433 [label="param SpinWaitComplete(this) 383021"];
19434 [label="if (HasComplete(part))\n            {\n                return;\n            } 383022"];
19435 [label="param HasComplete(CompletionPart part) 383023"];
19436 [label="param HasComplete(this) 383024"];
19437 [label="return (_completeParts & (int)part) == (int)part; 383025"];
19438 [label="return; 383026"];
19439 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383027"];
19440 [label="param HasAtMostOneBitSet(int bits) 383028"];
19441 [label="return (bits & (bits - 1)) == 0; 383029"];
19442 [label="this.GetMembersUnordered() 383030"];
19443 [label="ImmutableArray<Symbol> members = this.GetMembersUnordered(); 383031"];
19444 [label="bool allCompleted = true; 383032"];
19445 [label="if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            } 383033"];
19446 [label="foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                } 383034"];
19447 [label="if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            } 383035"];
19448 [label="EnsureFieldDefinitionsNoted() 383036"];
19449 [label="param EnsureFieldDefinitionsNoted(this) 383037"];
19450 [label="_flags.FieldDefinitionsNoted 383038"];
19451 [label="get { return (_flags & FieldDefinitionsNotedBit) != 0; } 383039"];
19452 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 383040"];
19453 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 383041"];
19454 [label="if (_flags.FieldDefinitionsNoted)\n            {\n                return;\n            } 383042"];
19455 [label="NoteFieldDefinitions() 383043"];
19456 [label="param NoteFieldDefinitions(this) 383044"];
19457 [label="this.GetMembersAndInitializers() 383045"];
19458 [label="param GetMembersAndInitializers(this) 383046"];
19459 [label="var membersAndInitializers = _lazyMembersAndInitializers; 383047"];
19460 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 383048"];
19461 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 383049"];
19462 [label="return membersAndInitializers; 383050"];
19463 [label="var membersAndInitializers = this.GetMembersAndInitializers(); 383051"];
19464 [label="_flags.FieldDefinitionsNoted 383052"];
19465 [label="get { return (_flags & FieldDefinitionsNotedBit) != 0; } 383053"];
19466 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 383054"];
19467 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 383055"];
19468 [label="if (!_flags.FieldDefinitionsNoted)\n                {\n                    var assembly = (SourceAssemblySymbol)ContainingAssembly;\n\n                    Accessibility containerEffectiveAccessibility = EffectiveAccessibility();\n\n                    foreach (var member in membersAndInitializers.NonTypeMembers)\n                    {\n                        FieldSymbol field;\n                        if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        }\n\n                        Accessibility fieldDeclaredAccessibility = field.DeclaredAccessibility;\n                        if (fieldDeclaredAccessibility == Accessibility.Private)\n                        {\n                            // mark private fields as tentatively unassigned and unread unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: true);\n                        }\n                        else if (containerEffectiveAccessibility == Accessibility.Private)\n                        {\n                            // mark effectively private fields as tentatively unassigned unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: false);\n                        }\n                        else if (fieldDeclaredAccessibility == Accessibility.Internal || containerEffectiveAccessibility == Accessibility.Internal)\n                        {\n                            // mark effectively internal fields as tentatively unassigned unless we discover otherwise.\n                            // NOTE: These fields will be reported as unassigned only if internals are not visible from this assembly.\n                            // See property SourceAssemblySymbol.UnusedFieldWarnings.\n                            assembly.NoteFieldDefinition(field, isInternal: true, isUnread: false);\n                        }\n                    }\n                    _flags.SetFieldDefinitionsNoted();\n                } 383056"];
19469 [label="ContainingAssembly 383057"];
19470 [label="var assembly = (SourceAssemblySymbol)ContainingAssembly; 383058"];
19471 [label="EffectiveAccessibility() 383059"];
19472 [label="param EffectiveAccessibility(this) 383060"];
19473 [label="DeclaredAccessibility 383061"];
19474 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 383062"];
19475 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 383063"];
19476 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 383064"];
19477 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 383065"];
19478 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 383066"];
19479 [label="return Accessibility.Public; 383067"];
19480 [label="var result = DeclaredAccessibility; 383068"];
19481 [label="if (result == Accessibility.Private) return Accessibility.Private; 383069"];
19482 [label="this.ContainingType 383070"];
19483 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 383071"];
19484 [label="for (Symbol? container = this.ContainingType; !(container is null); container = container.ContainingType)\n            {\n                switch (container.DeclaredAccessibility)\n                {\n                    case Accessibility.Private:\n                        return Accessibility.Private;\n                    case Accessibility.Internal:\n                        result = Accessibility.Internal;\n                        continue;\n                }\n            } 383072"];
19485 [label="return result; 383073"];
19486 [label="Accessibility containerEffectiveAccessibility = EffectiveAccessibility(); 383074"];
19487 [label="foreach (var member in membersAndInitializers.NonTypeMembers)\n                    {\n                        FieldSymbol field;\n                        if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        }\n\n                        Accessibility fieldDeclaredAccessibility = field.DeclaredAccessibility;\n                        if (fieldDeclaredAccessibility == Accessibility.Private)\n                        {\n                            // mark private fields as tentatively unassigned and unread unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: true);\n                        }\n                        else if (containerEffectiveAccessibility == Accessibility.Private)\n                        {\n                            // mark effectively private fields as tentatively unassigned unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: false);\n                        }\n                        else if (fieldDeclaredAccessibility == Accessibility.Internal || containerEffectiveAccessibility == Accessibility.Internal)\n                        {\n                            // mark effectively internal fields as tentatively unassigned unless we discover otherwise.\n                            // NOTE: These fields will be reported as unassigned only if internals are not visible from this assembly.\n                            // See property SourceAssemblySymbol.UnusedFieldWarnings.\n                            assembly.NoteFieldDefinition(field, isInternal: true, isUnread: false);\n                        }\n                    } 383075"];
19488 [label="_flags.SetFieldDefinitionsNoted() 383076"];
19489 [label="param SetFieldDefinitionsNoted(this) 383077"];
19490 [label="ThreadSafeFlagOperations.Set(ref _flags, FieldDefinitionsNotedBit); 383078"];
19491 [label="ThreadSafeFlagOperations.Set(ref _flags, FieldDefinitionsNotedBit); 383079"];
19492 [label="_flags.SetFieldDefinitionsNoted(); 383080"];
19493 [label="NoteFieldDefinitions(); 383081"];
19494 [label="EnsureFieldDefinitionsNoted(); 383082"];
19495 [label="state.NotePartComplete(CompletionPart.MembersCompleted); 383083"];
19496 [label="state.NotePartComplete(CompletionPart.MembersCompleted) 383084"];
19497 [label="param NotePartComplete(CompletionPart part) 383085"];
19498 [label="param NotePartComplete(this) 383086"];
19499 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 383087"];
19500 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 383088"];
19501 [label="param SpinWaitComplete(CompletionPart part) 383089"];
19502 [label="param SpinWaitComplete(this) 383090"];
19503 [label="if (HasComplete(part))\n            {\n                return;\n            } 383091"];
19504 [label="param HasComplete(CompletionPart part) 383092"];
19505 [label="param HasComplete(this) 383093"];
19506 [label="return (_completeParts & (int)part) == (int)part; 383094"];
19507 [label="return; 383095"];
19508 [label="cancellationToken.ThrowIfCancellationRequested(); 383096"];
19509 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383097"];
19510 [label="param HasAtMostOneBitSet(int bits) 383098"];
19511 [label="return (bits & (bits - 1)) == 0; 383099"];
19512 [label="return; 383100"];
19513 [label="param HasComplete(CompletionPart part) 383101"];
19514 [label="param HasComplete(this) 383102"];
19515 [label="return state.HasComplete(part); 383103"];
19516 [label="state.HasComplete(part) 383104"];
19517 [label="param HasComplete(CompletionPart part) 383105"];
19518 [label="param HasComplete(this) 383106"];
19519 [label="return (_completeParts & (int)part) == (int)part; 383107"];
19520 [label="return (_completeParts & (int)part) == (int)part; 383108"];
19521 [label="return; 383109"];
19522 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383110"];
19523 [label="param HasAtMostOneBitSet(int bits) 383111"];
19524 [label="return (bits & (bits - 1)) == 0; 383112"];
19525 [label="param HasComplete(CompletionPart part) 383113"];
19526 [label="param HasComplete(this) 383114"];
19527 [label="return _state.HasComplete(part); 383115"];
19528 [label="_state.HasComplete(part) 383116"];
19529 [label="param HasComplete(CompletionPart part) 383117"];
19530 [label="param HasComplete(this) 383118"];
19531 [label="return (_completeParts & (int)part) == (int)part; 383119"];
19532 [label="return (_completeParts & (int)part) == (int)part; 383120"];
19533 [label="return; 383121"];
19534 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383122"];
19535 [label="param HasAtMostOneBitSet(int bits) 383123"];
19536 [label="return (bits & (bits - 1)) == 0; 383124"];
19537 [label="param HasComplete(CompletionPart part) 383125"];
19538 [label="param HasComplete(this) 383126"];
19539 [label="return _state.HasComplete(part); 383127"];
19540 [label="_state.HasComplete(part) 383128"];
19541 [label="param HasComplete(CompletionPart part) 383129"];
19542 [label="param HasComplete(this) 383130"];
19543 [label="return (_completeParts & (int)part) == (int)part; 383131"];
19544 [label="return (_completeParts & (int)part) == (int)part; 383132"];
19545 [label="return; 383133"];
19546 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383134"];
19547 [label="param HasAtMostOneBitSet(int bits) 383135"];
19548 [label="return (bits & (bits - 1)) == 0; 383136"];
19549 [label="param ReportDiagnosticsForAddedModules(this) 383137"];
19550 [label="var diagnostics = DiagnosticBag.GetInstance(); 383138"];
19551 [label="_compilation.GetBoundReferenceManager() 383139"];
19552 [label="param GetBoundReferenceManager(this) 383140"];
19553 [label="foreach (var pair in _compilation.GetBoundReferenceManager().ReferencedModuleIndexMap)\n            {\n                var fileRef = pair.Key as PortableExecutableReference;\n\n                if ((object)fileRef != null && (object)fileRef.FilePath != null)\n                {\n                    string fileName = FileNameUtilities.GetFileName(fileRef.FilePath);\n                    string moduleName = _modules[pair.Value].Name;\n\n                    if (!string.Equals(fileName, moduleName, StringComparison.OrdinalIgnoreCase))\n                    {\n                        // Used to be ERR_ALinkFailed\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMismatch, NoLocation.Singleton, moduleName, fileName);\n                    }\n                }\n            } 383141"];
19554 [label="if (_modules.Length > 1 && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                var assemblyMachine = this.Machine;\n                bool isPlatformAgnostic = (assemblyMachine == System.Reflection.PortableExecutable.Machine.I386 && !this.Bit32Required);\n                var knownModuleNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);\n\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    ModuleSymbol m = _modules[i];\n                    if (!knownModuleNames.Add(m.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMustBeUnique, NoLocation.Singleton, m.Name);\n                    }\n\n                    if (!((PEModuleSymbol)m).Module.IsCOFFOnly)\n                    {\n                        var moduleMachine = m.Machine;\n\n                        if (moduleMachine == System.Reflection.PortableExecutable.Machine.I386 && !m.Bit32Required)\n                        {\n                            // Other module is agnostic, this is always safe\n                            ;\n                        }\n                        else if (isPlatformAgnostic)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_AgnosticToMachineModule, NoLocation.Singleton, m);\n                        }\n                        else if (assemblyMachine != moduleMachine)\n                        {\n                            // Different machine types, and neither is agnostic\n                            // So it is a conflict\n                            diagnostics.Add(ErrorCode.ERR_ConflictingMachineModule, NoLocation.Singleton, m);\n                        }\n                    }\n                }\n\n                // Assembly main module must explicitly reference all the modules referenced by other assembly \n                // modules, i.e. all modules from transitive closure must be referenced explicitly here\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    var m = (PEModuleSymbol)_modules[i];\n\n                    try\n                    {\n                        foreach (var referencedModuleName in m.Module.GetReferencedManagedModulesOrThrow())\n                        {\n                            // Do not report error for this module twice\n                            if (knownModuleNames.Add(referencedModuleName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_MissingNetModuleReference, NoLocation.Singleton, referencedModuleName);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    }\n                }\n            } 383142"];
19555 [label="if (_modules.Length > 1 && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                var assemblyMachine = this.Machine;\n                bool isPlatformAgnostic = (assemblyMachine == System.Reflection.PortableExecutable.Machine.I386 && !this.Bit32Required);\n                var knownModuleNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);\n\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    ModuleSymbol m = _modules[i];\n                    if (!knownModuleNames.Add(m.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMustBeUnique, NoLocation.Singleton, m.Name);\n                    }\n\n                    if (!((PEModuleSymbol)m).Module.IsCOFFOnly)\n                    {\n                        var moduleMachine = m.Machine;\n\n                        if (moduleMachine == System.Reflection.PortableExecutable.Machine.I386 && !m.Bit32Required)\n                        {\n                            // Other module is agnostic, this is always safe\n                            ;\n                        }\n                        else if (isPlatformAgnostic)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_AgnosticToMachineModule, NoLocation.Singleton, m);\n                        }\n                        else if (assemblyMachine != moduleMachine)\n                        {\n                            // Different machine types, and neither is agnostic\n                            // So it is a conflict\n                            diagnostics.Add(ErrorCode.ERR_ConflictingMachineModule, NoLocation.Singleton, m);\n                        }\n                    }\n                }\n\n                // Assembly main module must explicitly reference all the modules referenced by other assembly \n                // modules, i.e. all modules from transitive closure must be referenced explicitly here\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    var m = (PEModuleSymbol)_modules[i];\n\n                    try\n                    {\n                        foreach (var referencedModuleName in m.Module.GetReferencedManagedModulesOrThrow())\n                        {\n                            // Do not report error for this module twice\n                            if (knownModuleNames.Add(referencedModuleName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_MissingNetModuleReference, NoLocation.Singleton, referencedModuleName);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    }\n                }\n            } 383143"];
19556 [label="this.GlobalNamespace 383144"];
19557 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                }\n\n                return _globalNamespace;\n            } 383145"];
19558 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383146"];
19559 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383147"];
19560 [label="return _globalNamespace; 383148"];
19561 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 383149"];
19562 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 383150"];
19563 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics) 383151"];
19564 [label="param ReportNameCollisionDiagnosticsForAddedModules(NamespaceSymbol ns) 383152"];
19565 [label="param ReportNameCollisionDiagnosticsForAddedModules(DiagnosticBag diagnostics) 383153"];
19566 [label="param ReportNameCollisionDiagnosticsForAddedModules(this) 383154"];
19567 [label="var mergedNs = ns as MergedNamespaceSymbol; 383155"];
19568 [label="if ((object)mergedNs == null)\n            {\n                return;\n            } 383156"];
19569 [label="if ((object)mergedNs == null)\n            {\n                return;\n            } 383157"];
19570 [label="return; 383158"];
19571 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 383159"];
19572 [label="_compilation.DeclarationDiagnostics 383160"];
19573 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 383161"];
19574 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 383162"];
19575 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 383163"];
19576 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 383164"];
19577 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 383165"];
19578 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 383166"];
19579 [label="diagnostics.Free(); 383167"];
19580 [label="return (_completeParts & (int)part) == (int)part; 383168"];
19581 [label="return; 383169"];
19582 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383170"];
19583 [label="param HasAtMostOneBitSet(int bits) 383171"];
19584 [label="return (bits & (bits - 1)) == 0; 383172"];
19585 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 383173"];
19586 [label="_declarationDiagnosticsFrozen = true; 383174"];
19587 [label="_declarationDiagnosticsFrozen 383175"];
19588 [label="_needsGeneratedAttributes_IsFrozen = true; 383176"];
19589 [label="_needsGeneratedAttributes_IsFrozen 383177"];
19590 [label="var result = _lazyDeclarationDiagnostics?.AsEnumerable() ?? Enumerable.Empty<Diagnostic>(); 383178"];
19591 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 383179"];
19592 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 383180"];
19593 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 383181"];
19594 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 383182"];
19595 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 383183"];
19596 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 383184"];
19597 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 383185"];
19598 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 383186"];
19599 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 383187"];
19600 [label="param GetClsComplianceDiagnostics(this) 383188"];
19601 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 383189"];
19602 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 383190"];
19603 [label="if (_lazyClsComplianceDiagnostics.IsDefault)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken);\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree());\n            } 383191"];
19604 [label="var builder = DiagnosticBag.GetInstance(); 383192"];
19605 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 383193"];
19606 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 383194"];
19607 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 383195"];
19608 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 383196"];
19609 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 383197"];
19610 [label="param CSharpSymbolVisitor(this) 383198"];
19611 [label="GetBoundReferenceManager(); 383199"];
19612 [label="param Visit(Symbol symbol) 383200"];
19613 [label="param Visit(this) 383201"];
19614 [label="if ((object)symbol != null)\n            {\n                symbol.Accept(this);\n            } 383202"];
19615 [label="if ((object)symbol != null)\n            {\n                symbol.Accept(this);\n            } 383203"];
19616 [label="symbol.Accept(this); 383204"];
19617 [label="symbol.Accept(this) 383205"];
19618 [label="param Accept(CSharpSymbolVisitor visitor) 383206"];
19619 [label="param Accept(this) 383207"];
19620 [label="visitor.VisitAssembly(this); 383208"];
19621 [label="visitor.VisitAssembly(this); 383209"];
19622 [label="visitor.VisitAssembly(this); 383210"];
19623 [label="get\n            {\n                return SymbolKind.Assembly;\n            } 383211"];
19624 [label="return SymbolKind.Assembly; 383212"];
19625 [label="visitor.VisitAssembly(this); 383213"];
19626 [label="param GetHashCode(Symbol obj) 383214"];
19627 [label="param GetHashCode(this) 383215"];
19628 [label="return obj is null ? 0 : obj.GetHashCode(); 383216"];
19629 [label="obj is null 383217"];
19630 [label="obj.GetHashCode() 383218"];
19631 [label="param GetHashCode(this) 383219"];
19632 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 383220"];
19633 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 383221"];
19634 [label="param GetAttributes(this) 383222"];
19635 [label="this.GetSourceAttributesBag() 383223"];
19636 [label="param GetSourceAttributesBag(this) 383224"];
19637 [label="EnsureAttributesAreBound() 383225"];
19638 [label="param EnsureAttributesAreBound(this) 383226"];
19639 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 383227"];
19640 [label="EnsureAttributesAreBound(); 383228"];
19641 [label="return _lazySourceAttributesBag; 383229"];
19642 [label="var attributes = this.GetSourceAttributesBag().Attributes; 383230"];
19643 [label="this.GetNetModuleAttributesBag() 383231"];
19644 [label="param GetNetModuleAttributesBag(this) 383232"];
19645 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 383233"];
19646 [label="EnsureNetModuleAttributesAreBound(); 383234"];
19647 [label="return _lazyNetModuleAttributesBag; 383235"];
19648 [label="var netmoduleAttributes = this.GetNetModuleAttributesBag().Attributes; 383236"];
19649 [label="Debug.Assert(!attributes.IsDefault); 383237"];
19650 [label="Debug.Assert(!netmoduleAttributes.IsDefault); 383238"];
19651 [label="if (attributes.Length > 0)\n            {\n                if (netmoduleAttributes.Length > 0)\n                {\n                    attributes = attributes.Concat(netmoduleAttributes);\n                }\n            }\n            else\n            {\n                attributes = netmoduleAttributes;\n            } 383239"];
19652 [label="if (attributes.Length > 0)\n            {\n                if (netmoduleAttributes.Length > 0)\n                {\n                    attributes = attributes.Concat(netmoduleAttributes);\n                }\n            }\n            else\n            {\n                attributes = netmoduleAttributes;\n            } 383240"];
19653 [label="attributes = netmoduleAttributes; 383241"];
19654 [label="Debug.Assert(!attributes.IsDefault); 383242"];
19655 [label="return attributes; 383243"];
19656 [label="get\n            {\n                return SymbolKind.NetModule;\n            } 383244"];
19657 [label="return SymbolKind.NetModule; 383245"];
19658 [label="visitor.VisitAssembly(this); 383246"];
19659 [label="get\n            {\n                Symbol container = this.ContainingSymbol;\n\n                NamedTypeSymbol containerAsType = container as NamedTypeSymbol;\n\n                // NOTE: container could be null, so we do not check \n                //       whether containerAsType is not null, but \n                //       instead check if it did not change after \n                //       the cast.\n                if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                }\n\n                // this is recursive, but recursion should be very short \n                // before we reach symbol that definitely knows its containing type.\n                return container.ContainingType;\n            } 383247"];
19660 [label="this.ContainingSymbol 383248"];
19661 [label="get\n            {\n                return _assemblySymbol;\n            } 383249"];
19662 [label="return _assemblySymbol; 383250"];
19663 [label="Symbol container = this.ContainingSymbol; 383251"];
19664 [label="NamedTypeSymbol containerAsType = container as NamedTypeSymbol; 383252"];
19665 [label="if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                } 383253"];
19666 [label="container.ContainingType 383254"];
19667 [label="get\n            {\n                Symbol container = this.ContainingSymbol;\n\n                NamedTypeSymbol containerAsType = container as NamedTypeSymbol;\n\n                // NOTE: container could be null, so we do not check \n                //       whether containerAsType is not null, but \n                //       instead check if it did not change after \n                //       the cast.\n                if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                }\n\n                // this is recursive, but recursion should be very short \n                // before we reach symbol that definitely knows its containing type.\n                return container.ContainingType;\n            } 383255"];
19668 [label="this.ContainingSymbol 383256"];
19669 [label="get\n            {\n                return null;\n            } 383257"];
19670 [label="Symbol container = this.ContainingSymbol; 383258"];
19671 [label="NamedTypeSymbol containerAsType = container as NamedTypeSymbol; 383259"];
19672 [label="if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                } 383260"];
19673 [label="return containerAsType; 383261"];
19674 [label="return container.ContainingType; 383262"];
19675 [label="visitor.VisitAssembly(this); 383263"];
19676 [label="param Equals(Symbol x) 383264"];
19677 [label="param Equals(Symbol y) 383265"];
19678 [label="param Equals(this) 383266"];
19679 [label="return x is null ? y is null : x.Equals(y, _comparison); 383267"];
19680 [label="x is null 383268"];
19681 [label="return x is null ? y is null : x.Equals(y, _comparison); 383269"];
19682 [label="return x is null ? y is null : x.Equals(y, _comparison); 383270"];
19683 [label="x.Equals(y, _comparison) 383271"];
19684 [label="param Equals(Symbol other) 383272"];
19685 [label="param Equals(TypeCompareKind compareKind) 383273"];
19686 [label="param Equals(this) 383274"];
19687 [label="return (object)this == other; 383275"];
19688 [label="visitor.VisitAssembly(this); 383276"];
19689 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                }\n\n                return _globalNamespace;\n            } 383277"];
19690 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383278"];
19691 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383279"];
19692 [label="return _globalNamespace; 383280"];
19693 [label="param Accept(CSharpSymbolVisitor visitor) 383281"];
19694 [label="param Accept(this) 383282"];
19695 [label="visitor.VisitNamespace(this); 383283"];
19696 [label="visitor.VisitNamespace(this); 383284"];
19697 [label="visitor.VisitNamespace(this); 383285"];
19698 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 383286"];
19699 [label="get\n            {\n                return SymbolKind.Assembly;\n            } 383287"];
19700 [label="return SymbolKind.Assembly; 383288"];
19701 [label="param GetHashCode(this) 383289"];
19702 [label="param Equals(this) 383290"];
19703 [label="param Equals(TypeCompareKind compareKind) 383291"];
19704 [label="symbol.Accept(this); 383292"];
19705 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 383293"];
19706 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 383294"];
19707 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 383295"];
19708 [label="return _lazyClsComplianceDiagnostics; 383296"];
19709 [label="return result.AsImmutable().Concat(clsDiagnostics); 383297"];
19710 [label="return result.AsImmutable().Concat(clsDiagnostics); 383298"];
19711 [label="return result.AsImmutable().Concat(clsDiagnostics); 383299"];
19712 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 383300"];
19713 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 383301"];
19714 [label="cancellationToken.ThrowIfCancellationRequested(); 383302"];
19715 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 383303"];
19716 [label="var methodBodyDiagnostics = DiagnosticBag.GetInstance(); 383304"];
19717 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 383305"];
19718 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 383306"];
19719 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken) 383307"];
19720 [label="param GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics) 383308"];
19721 [label="param GetDiagnosticsForAllMethodBodies(CancellationToken cancellationToken) 383309"];
19722 [label="param GetDiagnosticsForAllMethodBodies(this) 383310"];
19723 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 383311"];
19724 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 383312"];
19725 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 383313"];
19726 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 383314"];
19727 [label="MethodCompiler.CompileMethodBodies(\n                compilation: this,\n                moduleBeingBuiltOpt: null,\n                emittingPdb: false,\n                emitTestCoverageData: false,\n                hasDeclarationErrors: false,\n                diagnostics: diagnostics,\n                filterOpt: null,\n                cancellationToken: cancellationToken); 383315"];
19728 [label="param GetEntryPointAndDiagnostics(CancellationToken cancellationToken) 383316"];
19729 [label="param GetEntryPointAndDiagnostics(this) 383317"];
19730 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 383318"];
19731 [label="if (_lazyEntryPoint == null)\n            {\n                EntryPoint? entryPoint;\n                var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this);\n\n                if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                }\n\n                Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null);\n            } 383319"];
19732 [label="EntryPoint? entryPoint; 383320"];
19733 [label="var simpleProgramEntryPointSymbol = SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this); 383321"];
19734 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) 383322"];
19735 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 383323"];
19736 [label="var temp2 = GetSimpleProgramNamedTypeSymbol(compilation); 383324"];
19737 [label="GetSimpleProgramNamedTypeSymbol(compilation) 383325"];
19738 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 383326"];
19739 [label="compilation.SourceModule 383327"];
19740 [label="get\n            {\n                return Assembly.Modules[0];\n            } 383328"];
19741 [label="GetBoundReferenceManager(); 383329"];
19742 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 383330"];
19743 [label="compilation.SourceModule.GlobalNamespace 383331"];
19744 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 383332"];
19745 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 383333"];
19746 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 383334"];
19747 [label="param GetTypeMembers(string name) 383335"];
19748 [label="param GetTypeMembers(this) 383336"];
19749 [label="var temp3 = temp2?.GetMembersAndInitializers(); 383337"];
19750 [label="var temp = temp3 != null ? temp3.NonTypeMembers[0] : null; 383338"];
19751 [label="var temp = temp3 != null ? temp3.NonTypeMembers[0] : null; 383339"];
19752 [label="temp3 != null 383340"];
19753 [label="return (SynthesizedSimpleProgramEntryPointSymbol?)temp; 383341"];
19754 [label="this.Options 383342"];
19755 [label="return _options; 383343"];
19756 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 383344"];
19757 [label="this.ScriptClass 383345"];
19758 [label="get { return _scriptClass.Value; } 383346"];
19759 [label="return _scriptClass.Value; 383347"];
19760 [label="_scriptClass.Value 383348"];
19761 [label="param BindScriptClass(this) 383349"];
19762 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 383350"];
19763 [label="return (ImplicitNamedTypeSymbol?)CommonBindScriptClass().GetSymbol(); 383351"];
19764 [label="get { return this.SourceModule.GetPublicSymbol(); } 383352"];
19765 [label="this.SourceModule 383353"];
19766 [label="get\n            {\n                return Assembly.Modules[0];\n            } 383354"];
19767 [label="GetBoundReferenceManager(); 383355"];
19768 [label="return this.SourceModule.GetPublicSymbol(); 383356"];
19769 [label="this.SourceModule.GetPublicSymbol() 383357"];
19770 [label="param GetPublicSymbol(this ModuleSymbol? symbol) 383358"];
19771 [label="return symbol.GetPublicSymbol<IModuleSymbol>(); 383359"];
19772 [label="symbol.GetPublicSymbol<IModuleSymbol>() 383360"];
19773 [label="param GetPublicSymbol(this Symbol? symbol) 383361"];
19774 [label="param CreateISymbol(this) 383362"];
19775 [label="return new PublicModel.ModuleSymbol(this); 383363"];
19776 [label="return new PublicModel.ModuleSymbol(this); 383364"];
19777 [label="new PublicModel.ModuleSymbol(this) 383365"];
19778 [label="param ModuleSymbol(Symbols.ModuleSymbol underlying) 383366"];
19779 [label="param ModuleSymbol(this) 383367"];
19780 [label="param ModuleSymbol(this) 383368"];
19781 [label="param Symbol(this) 383369"];
19782 [label="_underlying 383370"];
19783 [label="Debug.Assert(underlying is object); 383371"];
19784 [label="_underlying 383372"];
19785 [label="get\n            {\n                return _underlying.GlobalNamespace.GetPublicSymbol();\n            } 383373"];
19786 [label="_underlying.GlobalNamespace 383374"];
19787 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 383375"];
19788 [label="return _underlying.GlobalNamespace.GetPublicSymbol(); 383376"];
19789 [label="_underlying.GlobalNamespace.GetPublicSymbol() 383377"];
19790 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 383378"];
19791 [label="param NamespaceOrTypeSymbol(this) 383379"];
19792 [label="param Symbol(this) 383380"];
19793 [label="_underlying 383381"];
19794 [label="Debug.Assert(underlying is object); 383382"];
19795 [label="param GetTypeMembers(string name) 383383"];
19796 [label="param GetTypeMembers(this) 383384"];
19797 [label="UnderlyingNamespaceOrTypeSymbol 383385"];
19798 [label="=> _underlying 383386"];
19799 [label="_underlying 383387"];
19800 [label="return UnderlyingNamespaceOrTypeSymbol.GetTypeMembers(name).GetPublicSymbols(); 383388"];
19801 [label="return UnderlyingNamespaceOrTypeSymbol.GetTypeMembers(name).GetPublicSymbols(); 383389"];
19802 [label="UnderlyingNamespaceOrTypeSymbol.GetTypeMembers(name) 383390"];
19803 [label="param GetTypeMembers(string name) 383391"];
19804 [label="param GetTypeMembers(this) 383392"];
19805 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 383393"];
19806 [label="UnderlyingNamespaceOrTypeSymbol.GetTypeMembers(name).GetPublicSymbols() 383394"];
19807 [label="param GetPublicSymbols(this ImmutableArray<NamedTypeSymbol> symbols) 383395"];
19808 [label="return GetPublicSymbols<INamedTypeSymbol>(StaticCast<Symbol>.From(symbols)); 383396"];
19809 [label="GetPublicSymbols<INamedTypeSymbol>(StaticCast<Symbol>.From(symbols)) 383397"];
19810 [label="param GetPublicSymbols(this ImmutableArray<Symbol> symbols) 383398"];
19811 [label="if (symbols.IsDefault)\n            {\n                return default;\n            } 383399"];
19812 [label="return symbols.SelectAsArray(p => p.GetPublicSymbol<TISymbol>()); 383400"];
19813 [label="return symbols.SelectAsArray(p => p.GetPublicSymbol<TISymbol>()); 383401"];
19814 [label="get\n            {\n                return this.SyntaxTrees;\n            } 383402"];
19815 [label="this.SyntaxTrees 383403"];
19816 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 383404"];
19817 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 383405"];
19818 [label="return this.SyntaxTrees; 383406"];
19819 [label="CommonBindScriptClass().GetSymbol() 383407"];
19820 [label="param GetSymbol(this INamedTypeSymbol? symbol) 383408"];
19821 [label="return symbol.GetSymbol<NamedTypeSymbol>(); 383409"];
19822 [label="symbol.GetSymbol<NamedTypeSymbol>() 383410"];
19823 [label="param GetSymbol(this ISymbol? symbol) 383411"];
19824 [label="return (TSymbol?)((PublicModel.Symbol?)symbol)?.UnderlyingSymbol; 383412"];
19825 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 383413"];
19826 [label="if (!this.Options.OutputKind.IsApplication() && (this.ScriptClass is null))\n                {\n                    if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    }\n                }\n                else\n                {\n                    entryPoint = null;\n\n                    if (this.Options.MainTypeName != null && !this.Options.MainTypeName.IsValidClrTypeName())\n                    {\n                        Debug.Assert(!this.Options.Errors.IsDefaultOrEmpty);\n                        entryPoint = EntryPoint.None;\n                    }\n\n                    if (entryPoint is null)\n                    {\n                        ImmutableArray<Diagnostic> diagnostics;\n                        var entryPointMethod = FindEntryPoint(simpleProgramEntryPointSymbol, cancellationToken, out diagnostics);\n                        entryPoint = new EntryPoint(entryPointMethod, diagnostics);\n                    }\n\n                    if (this.Options.MainTypeName != null && simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramDisallowsMainType, NoLocation.Singleton);\n                        entryPoint = new EntryPoint(entryPoint.MethodSymbol, entryPoint.Diagnostics.Concat(diagnostics.ToReadOnlyAndFree()));\n                    }\n                } 383414"];
19827 [label="if (simpleProgramEntryPointSymbol is object)\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        diagnostics.Add(ErrorCode.ERR_SimpleProgramNotAnExecutable, simpleProgramEntryPointSymbol.ReturnTypeSyntax.Location);\n                        entryPoint = new EntryPoint(null, diagnostics.ToReadOnlyAndFree());\n                    }\n                    else\n                    {\n                        entryPoint = EntryPoint.None;\n                    } 383415"];
19828 [label="null 383416"];
19829 [label="ImmutableArray<Diagnostic>.Empty 383417"];
19830 [label="new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 383418"];
19831 [label="param EntryPoint(MethodSymbol? methodSymbol) 383419"];
19832 [label="param EntryPoint(ImmutableArray<Diagnostic> diagnostics) 383420"];
19833 [label="param EntryPoint(this) 383421"];
19834 [label="MethodSymbol 383422"];
19835 [label="this.MethodSymbol 383423"];
19836 [label="this.Diagnostics 383424"];
19837 [label="None = new EntryPoint(null, ImmutableArray<Diagnostic>.Empty) 383425"];
19838 [label="entryPoint = EntryPoint.None; 383426"];
19839 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 383427"];
19840 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 383428"];
19841 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 383429"];
19842 [label="Interlocked.CompareExchange(ref _lazyEntryPoint, entryPoint, null); 383430"];
19843 [label="return _lazyEntryPoint; 383431"];
19844 [label="param CSharpSymbolVisitor(this) 383432"];
19845 [label="Assembly 383433"];
19846 [label="SourceAssembly 383434"];
19847 [label="GetBoundReferenceManager() 383435"];
19848 [label="GetBoundReferenceManager(); 383436"];
19849 [label="Assembly.Modules 383437"];
19850 [label="return Assembly.Modules[0]; 383438"];
19851 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 383439"];
19852 [label="param Accept(CSharpSymbolVisitor<TArgument, TResult> visitor) 383440"];
19853 [label="param Accept(TArgument argument) 383441"];
19854 [label="param Accept(this) 383442"];
19855 [label="return visitor.VisitNamespace(this, argument); 383443"];
19856 [label="return visitor.VisitNamespace(this, argument); 383444"];
19857 [label="return visitor.VisitNamespace(this, argument); 383445"];
19858 [label="return visitor.VisitNamespace(this, argument); 383446"];
19859 [label="SourceAssembly 383447"];
19860 [label="GetBoundReferenceManager() 383448"];
19861 [label="GetBoundReferenceManager(); 383449"];
19862 [label="param GetUnusedFieldWarnings(CancellationToken cancellationToken) 383450"];
19863 [label="param GetUnusedFieldWarnings(this) 383451"];
19864 [label="if (_unusedFieldWarnings.IsDefault)\n            {\n                //Our maps of unread and unassigned fields won't be done until the assembly is complete.\n                this.ForceComplete(locationOpt: null, cancellationToken: cancellationToken);\n\n                Debug.Assert(this.HasComplete(CompletionPart.Module),\n                    'Don't consume unused field information if there are still types to be processed.');\n\n                // Build this up in a local before we assign it to this.unusedFieldWarnings (so other threads\n                // can see that it's not done).\n                DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n\n                // NOTE: two threads can come in here at the same time.  If they do, then they will\n                // share the diagnostic bag.  That's alright, as long as each one processes only\n                // the fields that it successfully removes from the shared map/set.  Furthermore,\n                // there should be no problem with re-calling this method on the same assembly,\n                // since there will be nothing left in the map/set the second time.\n                bool internalsAreVisible =\n                    this.InternalsAreVisible ||\n                    this.IsNetModule();\n\n                HashSet<FieldSymbol> handledUnreadFields = null;\n\n                foreach (FieldSymbol field in _unassignedFieldsMap.Keys) // Not mutating, so no snapshot required.\n                {\n                    bool isInternalAccessibility;\n                    bool success = _unassignedFieldsMap.TryGetValue(field, out isInternalAccessibility);\n                    Debug.Assert(success, 'Once CompletionPart.Module is set, no-one should be modifying the map.');\n\n                    if (isInternalAccessibility && internalsAreVisible)\n                    {\n                        continue;\n                    }\n\n                    if (!field.CanBeReferencedByName)\n                    {\n                        continue;\n                    }\n\n                    var containingType = field.ContainingType as SourceNamedTypeSymbol;\n                    if ((object)containingType == null)\n                    {\n                        continue;\n                    }\n\n                    if (field is TupleErrorFieldSymbol)\n                    {\n                        continue;\n                    }\n\n                    bool unread = _unreadFields.Contains(field);\n                    if (unread)\n                    {\n                        if (handledUnreadFields == null)\n                        {\n                            handledUnreadFields = new HashSet<FieldSymbol>();\n                        }\n                        handledUnreadFields.Add(field);\n                    }\n\n                    if (containingType.HasStructLayoutAttribute)\n                    {\n                        continue;\n                    }\n\n                    Symbol associatedPropertyOrEvent = field.AssociatedSymbol;\n                    if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n                    {\n                        if (unread)\n                        {\n                            diagnostics.Add(ErrorCode.WRN_UnreferencedEvent, associatedPropertyOrEvent.Locations.FirstOrNone(), associatedPropertyOrEvent);\n                        }\n                    }\n                    else if (unread)\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnreferencedField, field.Locations.FirstOrNone(), field);\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnassignedInternalField, field.Locations.FirstOrNone(), field, DefaultValue(field.Type));\n                    }\n                }\n\n                foreach (FieldSymbol field in _unreadFields) // Not mutating, so no snapshot required.\n                {\n                    if (handledUnreadFields != null && handledUnreadFields.Contains(field))\n                    {\n                        // Handled in the first foreach loop.\n                        continue;\n                    }\n\n                    if (!field.CanBeReferencedByName)\n                    {\n                        continue;\n                    }\n\n                    var containingType = field.ContainingType as SourceNamedTypeSymbol;\n                    if ((object)containingType != null && !containingType.HasStructLayoutAttribute)\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnreferencedFieldAssg, field.Locations.FirstOrNone(), field);\n                    }\n                }\n\n                ImmutableInterlocked.InterlockedInitialize(ref _unusedFieldWarnings, diagnostics.ToReadOnlyAndFree());\n            } 383452"];
19865 [label="this.ForceComplete(locationOpt: null, cancellationToken: cancellationToken); 383453"];
19866 [label="this.ForceComplete(locationOpt: null, cancellationToken: cancellationToken); 383454"];
19867 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383455"];
19868 [label="HasAtMostOneBitSet(next) 383456"];
19869 [label="param HasAtMostOneBitSet(int bits) 383457"];
19870 [label="return (bits & (bits - 1)) == 0; 383458"];
19871 [label="return (bits & (bits - 1)) == 0; 383459"];
19872 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 383460"];
19873 [label="Debug.Assert(this.HasComplete(CompletionPart.Module),\n                    'Don't consume unused field information if there are still types to be processed.'); 383461"];
19874 [label="this.HasComplete(CompletionPart.Module) 383462"];
19875 [label="param HasComplete(CompletionPart part) 383463"];
19876 [label="param HasComplete(this) 383464"];
19877 [label="return _state.HasComplete(part); 383465"];
19878 [label="_state.HasComplete(part) 383466"];
19879 [label="param HasComplete(CompletionPart part) 383467"];
19880 [label="param HasComplete(this) 383468"];
19881 [label="return (_completeParts & (int)part) == (int)part; 383469"];
19882 [label="Debug.Assert(this.HasComplete(CompletionPart.Module),\n                    'Don't consume unused field information if there are still types to be processed.'); 383470"];
19883 [label="DiagnosticBag diagnostics = DiagnosticBag.GetInstance(); 383471"];
19884 [label="this.InternalsAreVisible 383472"];
19885 [label="get\n            {\n                EnsureAttributesAreBound();\n                return _lazyInternalsVisibleToMap != null;\n            } 383473"];
19886 [label="EnsureAttributesAreBound() 383474"];
19887 [label="param EnsureAttributesAreBound(this) 383475"];
19888 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 383476"];
19889 [label="EnsureAttributesAreBound(); 383477"];
19890 [label="return _lazyInternalsVisibleToMap != null; 383478"];
19891 [label="return _lazyInternalsVisibleToMap != null; 383479"];
19892 [label="bool internalsAreVisible =\n                    this.InternalsAreVisible ||\n                    this.IsNetModule(); 383480"];
19893 [label="this.IsNetModule() 383481"];
19894 [label="=> this._compilation.Options.OutputKind.IsNetModule() 383482"];
19895 [label="this._compilation.Options 383483"];
19896 [label="get\n            {\n                return _options;\n            } 383484"];
19897 [label="this._compilation.Options.OutputKind 383485"];
19898 [label="this._compilation.Options.OutputKind.IsNetModule() 383486"];
19899 [label="bool internalsAreVisible =\n                    this.InternalsAreVisible ||\n                    this.IsNetModule(); 383487"];
19900 [label="bool internalsAreVisible =\n                    this.InternalsAreVisible ||\n                    this.IsNetModule(); 383488"];
19901 [label="HashSet<FieldSymbol> handledUnreadFields = null; 383489"];
19902 [label="foreach (FieldSymbol field in _unassignedFieldsMap.Keys) // Not mutating, so no snapshot required.\n                {\n                    bool isInternalAccessibility;\n                    bool success = _unassignedFieldsMap.TryGetValue(field, out isInternalAccessibility);\n                    Debug.Assert(success, 'Once CompletionPart.Module is set, no-one should be modifying the map.');\n\n                    if (isInternalAccessibility && internalsAreVisible)\n                    {\n                        continue;\n                    }\n\n                    if (!field.CanBeReferencedByName)\n                    {\n                        continue;\n                    }\n\n                    var containingType = field.ContainingType as SourceNamedTypeSymbol;\n                    if ((object)containingType == null)\n                    {\n                        continue;\n                    }\n\n                    if (field is TupleErrorFieldSymbol)\n                    {\n                        continue;\n                    }\n\n                    bool unread = _unreadFields.Contains(field);\n                    if (unread)\n                    {\n                        if (handledUnreadFields == null)\n                        {\n                            handledUnreadFields = new HashSet<FieldSymbol>();\n                        }\n                        handledUnreadFields.Add(field);\n                    }\n\n                    if (containingType.HasStructLayoutAttribute)\n                    {\n                        continue;\n                    }\n\n                    Symbol associatedPropertyOrEvent = field.AssociatedSymbol;\n                    if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n                    {\n                        if (unread)\n                        {\n                            diagnostics.Add(ErrorCode.WRN_UnreferencedEvent, associatedPropertyOrEvent.Locations.FirstOrNone(), associatedPropertyOrEvent);\n                        }\n                    }\n                    else if (unread)\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnreferencedField, field.Locations.FirstOrNone(), field);\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnassignedInternalField, field.Locations.FirstOrNone(), field, DefaultValue(field.Type));\n                    }\n                } 383490"];
19903 [label="foreach (FieldSymbol field in _unreadFields) // Not mutating, so no snapshot required.\n                {\n                    if (handledUnreadFields != null && handledUnreadFields.Contains(field))\n                    {\n                        // Handled in the first foreach loop.\n                        continue;\n                    }\n\n                    if (!field.CanBeReferencedByName)\n                    {\n                        continue;\n                    }\n\n                    var containingType = field.ContainingType as SourceNamedTypeSymbol;\n                    if ((object)containingType != null && !containingType.HasStructLayoutAttribute)\n                    {\n                        diagnostics.Add(ErrorCode.WRN_UnreferencedFieldAssg, field.Locations.FirstOrNone(), field);\n                    }\n                } 383491"];
19904 [label="ImmutableInterlocked.InterlockedInitialize(ref _unusedFieldWarnings, diagnostics.ToReadOnlyAndFree()); 383492"];
19905 [label="ImmutableInterlocked.InterlockedInitialize(ref _unusedFieldWarnings, diagnostics.ToReadOnlyAndFree()); 383493"];
19906 [label="ImmutableInterlocked.InterlockedInitialize(ref _unusedFieldWarnings, diagnostics.ToReadOnlyAndFree()); 383494"];
19907 [label="Debug.Assert(!_unusedFieldWarnings.IsDefault); 383495"];
19908 [label="return _unusedFieldWarnings; 383496"];
19909 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 383497"];
19910 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 383498"];
19911 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 383499"];
19912 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 383500"];
19913 [label="DocumentationCommentCompiler.WriteDocumentationCommentXml(this, null, null, diagnostics, cancellationToken); 383501"];
19914 [label="GetBoundReferenceManager() 383502"];
19915 [label="GetBoundReferenceManager(); 383503"];
19916 [label="get\n            {\n                return _assemblySimpleName;\n            } 383504"];
19917 [label="return _assemblySimpleName; 383505"];
19918 [label="param CSharpSymbolVisitor(this) 383506"];
19919 [label="GetBoundReferenceManager(); 383507"];
19920 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383508"];
19921 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 383509"];
19922 [label="if ((object)symbol != null)\n            {\n                symbol.Accept(this);\n            } 383510"];
19923 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 383511"];
19924 [label="ContainingNamespace 383512"];
19925 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 383513"];
19926 [label="=> _container 383514"];
19927 [label="_container 383515"];
19928 [label="container.ContainingSymbol 383516"];
19929 [label="get\n            {\n                return _assemblySymbol;\n            } 383517"];
19930 [label="return _assemblySymbol; 383518"];
19931 [label="get\n            {\n                return null;\n            } 383519"];
19932 [label="return null; 383520"];
19933 [label="return (object)ContainingNamespace == null; 383521"];
19934 [label="return (object)ContainingNamespace == null; 383522"];
19935 [label="visitor.VisitNamespace(this); 383523"];
19936 [label="return _lazyAllMembers; 383524"];
19937 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 383525"];
19938 [label="=> _container 383526"];
19939 [label="_container 383527"];
19940 [label="param Accept(CSharpSymbolVisitor visitor) 383528"];
19941 [label="param Accept(this) 383529"];
19942 [label="visitor.VisitNamedType(this); 383530"];
19943 [label="visitor.VisitNamedType(this); 383531"];
19944 [label="visitor.VisitNamedType(this); 383532"];
19945 [label="get\n            {\n                return IsImplicitClass || IsScriptClass;\n            } 383533"];
19946 [label="IsImplicitClass 383534"];
19947 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass;\n            } 383535"];
19948 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 383536"];
19949 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 383537"];
19950 [label="return IsImplicitClass || IsScriptClass; 383538"];
19951 [label="IsScriptClass 383539"];
19952 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 383540"];
19953 [label="var kind = this.declaration.Declarations[0].Kind; 383541"];
19954 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 383542"];
19955 [label="return IsImplicitClass || IsScriptClass; 383543"];
19956 [label="param IsAccessor(this Symbol symbol) 383544"];
19957 [label="symbol.Kind 383545"];
19958 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 383546"];
19959 [label="return symbol.Kind == SymbolKind.Method && IsAccessor((MethodSymbol)symbol); 383547"];
19960 [label="visitor.VisitNamedType(this); 383548"];
19961 [label="param IsPartialDefinition(this Symbol member) 383549"];
19962 [label="var sms = member as SourceOrdinaryMethodSymbol; 383550"];
19963 [label="return sms?.IsPartialDefinition == true; 383551"];
19964 [label="return sms?.IsPartialDefinition == true; 383552"];
19965 [label="visitor.VisitNamedType(this); 383553"];
19966 [label="get\n            {\n                return SyntaxReferences;\n            } 383554"];
19967 [label="SyntaxReferences 383555"];
19968 [label="get\n            {\n                return this.declaration.SyntaxReferences;\n            } 383556"];
19969 [label="return this.declaration.SyntaxReferences; 383557"];
19970 [label="return SyntaxReferences; 383558"];
19971 [label="param GetMembers(this) 383559"];
19972 [label="_flags.FlattenedMembersIsSorted 383560"];
19973 [label="get { return (_flags & FlattenedMembersIsSortedBit) != 0; } 383561"];
19974 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 383562"];
19975 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 383563"];
19976 [label="if (_flags.FlattenedMembersIsSorted)\n            {\n                return _lazyMembersFlattened;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                }\n\n                _flags.SetFlattenedMembersIsSorted();\n                return allMembers;\n            } 383564"];
19977 [label="return _lazyMembersFlattened; 383565"];
19978 [label="param IsAccessor(this Symbol symbol) 383566"];
19979 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 383567"];
19980 [label="param Accept(CSharpSymbolVisitor visitor) 383568"];
19981 [label="param Accept(this) 383569"];
19982 [label="visitor.VisitMethod(this); 383570"];
19983 [label="visitor.VisitMethod(this) 383571"];
19984 [label="param VisitMethod(MethodSymbol symbol) 383572"];
19985 [label="param VisitMethod(this) 383573"];
19986 [label="DefaultVisit(symbol); 383574"];
19987 [label="DefaultVisit(symbol); 383575"];
19988 [label="DefaultVisit(symbol); 383576"];
19989 [label="get\n            {\n                return true;\n            } 383577"];
19990 [label="return true; 383578"];
19991 [label="DefaultVisit(symbol); 383579"];
19992 [label="visitor.VisitMethod(this); 383580"];
19993 [label="param IsAccessor(this Symbol symbol) 383581"];
19994 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 383582"];
19995 [label="get\n            {\n                return true;\n            } 383583"];
19996 [label="container.ContainingSymbol 383584"];
19997 [label="get\n            {\n                return _assemblySymbol;\n            } 383585"];
19998 [label="return _assemblySymbol; 383586"];
19999 [label="get\n            {\n                return null;\n            } 383587"];
20000 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 383588"];
20001 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 383589"];
20002 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken); 383590"];
20003 [label="this.ReportUnusedImports(filterTree: null, diagnostics, cancellationToken) 383591"];
20004 [label="param ReportUnusedImports(SyntaxTree? filterTree) 383592"];
20005 [label="param ReportUnusedImports(DiagnosticBag diagnostics) 383593"];
20006 [label="param ReportUnusedImports(CancellationToken cancellationToken) 383594"];
20007 [label="param ReportUnusedImports(this) 383595"];
20008 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 383596"];
20009 [label="if (_lazyImportInfos != null &&\n                filterTree != null &&\n                filterTree.Options.DocumentationMode != DocumentationMode.None)\n            {\n                foreach (ImportInfo info in _lazyImportInfos)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    SyntaxTree infoTree = info.Tree;\n                    if ((filterTree == null || filterTree == infoTree) && infoTree.Options.DocumentationMode != DocumentationMode.None)\n                    {\n                        TextSpan infoSpan = info.Span;\n                        if (!this.IsImportDirectiveUsed(infoTree, infoSpan.Start))\n                        {\n                            ErrorCode code = info.Kind == SyntaxKind.ExternAliasDirective\n                                ? ErrorCode.HDN_UnusedExternAlias\n                                : ErrorCode.HDN_UnusedUsingDirective;\n                            diagnostics.Add(code, infoTree.GetLocation(infoSpan));\n                        }\n                    }\n                }\n            } 383597"];
20010 [label="CompleteTrees(filterTree); 383598"];
20011 [label="CompleteTrees(filterTree) 383599"];
20012 [label="param CompleteTrees(SyntaxTree? filterTree) 383600"];
20013 [label="param CompleteTrees(this) 383601"];
20014 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 383602"];
20015 [label="if (EventQueue != null)\n            {\n                if (filterTree != null)\n                {\n                    CompleteTree(filterTree);\n                }\n                else\n                {\n                    foreach (var tree in this.SyntaxTrees)\n                    {\n                        CompleteTree(tree);\n                    }\n                }\n            } 383603"];
20016 [label="CompleteTrees(filterTree); 383604"];
20017 [label="GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken); 383605"];
20018 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 383606"];
20019 [label="builder.AddRangeAndFree(methodBodyDiagnostics); 383607"];
20020 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 383608"];
20021 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 383609"];
20022 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 383610"];
20023 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 383611"];
20024 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 383612"];
20025 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 383613"];
20026 [label="return diagnostics.ToReadOnlyAndFree(); 383614"];
20027 [label="comp.SourceModule 383615"];
20028 [label="get\n            {\n                return Assembly.Modules[0];\n            } 383616"];
20029 [label="Assembly 383617"];
20030 [label="get\n            {\n                return SourceAssembly;\n            } 383618"];
20031 [label="SourceAssembly 383619"];
20032 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 383620"];
20033 [label="GetBoundReferenceManager() 383621"];
20034 [label="param GetBoundReferenceManager(this) 383622"];
20035 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 383623"];
20036 [label="return _referenceManager; 383624"];
20037 [label="GetBoundReferenceManager(); 383625"];
20038 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 383626"];
20039 [label="Assembly.Modules 383627"];
20040 [label="return Assembly.Modules[0]; 383628"];
20041 [label="var global = comp.SourceModule.GlobalNamespace; 383629"];
20042 [label="comp.SourceModule.GlobalNamespace 383630"];
20043 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 383631"];
20044 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 383632"];
20045 [label="var ns = global.GetMember<NamespaceSymbol>('N'); 383633"];
20046 [label="var ns = global.GetMember<NamespaceSymbol>('N'); 383634"];
20047 [label="global.GetMember<NamespaceSymbol>('N') 383635"];
20048 [label="param GetMember(this NamespaceOrTypeSymbol symbol) 383636"];
20049 [label="param GetMember(string qualifiedName) 383637"];
20050 [label="return (T)symbol.GetMember(qualifiedName); 383638"];
20051 [label="return (T)symbol.GetMember(qualifiedName); 383639"];
20052 [label="symbol.GetMember(qualifiedName) 383640"];
20053 [label="param GetMember(this NamespaceOrTypeSymbol container) 383641"];
20054 [label="param GetMember(string qualifiedName) 383642"];
20055 [label="NamespaceOrTypeSymbol lastContainer; 383643"];
20056 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383644"];
20057 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383645"];
20058 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383646"];
20059 [label="GetMembers(container, qualifiedName, out lastContainer) 383647"];
20060 [label="param GetMembers(NamespaceOrTypeSymbol container) 383648"];
20061 [label="param GetMembers(string qualifiedName) 383649"];
20062 [label="param GetMembers(out NamespaceOrTypeSymbol lastContainer) 383650"];
20063 [label="var parts = SplitMemberName(qualifiedName); 383651"];
20064 [label="SplitMemberName(qualifiedName) 383652"];
20065 [label="param SplitMemberName(string name) 383653"];
20066 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383654"];
20067 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383655"];
20068 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383656"];
20069 [label="var builder = ArrayBuilder<string>.GetInstance(); 383657"];
20070 [label="string part = name; 383658"];
20071 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383659"];
20072 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383660"];
20073 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383661"];
20074 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383662"];
20075 [label="builder.ReverseContents(); 383663"];
20076 [label="return builder.ToImmutableAndFree(); 383664"];
20077 [label="lastContainer = container; 383665"];
20078 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383666"];
20079 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383667"];
20080 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383668"];
20081 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383669"];
20082 [label="lastContainer.GetMembers(parts[parts.Length - 1]) 383670"];
20083 [label="param GetMembers(string name) 383671"];
20084 [label="param GetMembers(this) 383672"];
20085 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 383673"];
20086 [label="members 383674"];
20087 [label="this.GetNameToMembersMap() 383675"];
20088 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 383676"];
20089 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383677"];
20090 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383678"];
20091 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383679"];
20092 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383680"];
20093 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383681"];
20094 [label="if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383682"];
20095 [label="return members.Single(); 383683"];
20096 [label="var typeA = ns.GetMember<NamedTypeSymbol>('A'); 383684"];
20097 [label="var typeA = ns.GetMember<NamedTypeSymbol>('A'); 383685"];
20098 [label="ns.GetMember<NamedTypeSymbol>('A') 383686"];
20099 [label="param GetMember(this NamespaceOrTypeSymbol symbol) 383687"];
20100 [label="param GetMember(string qualifiedName) 383688"];
20101 [label="return (T)symbol.GetMember(qualifiedName); 383689"];
20102 [label="symbol.GetMember(qualifiedName) 383690"];
20103 [label="param GetMember(string qualifiedName) 383691"];
20104 [label="NamespaceOrTypeSymbol lastContainer; 383692"];
20105 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383693"];
20106 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383694"];
20107 [label="GetMembers(container, qualifiedName, out lastContainer) 383695"];
20108 [label="param GetMembers(string qualifiedName) 383696"];
20109 [label="param GetMembers(out NamespaceOrTypeSymbol lastContainer) 383697"];
20110 [label="var parts = SplitMemberName(qualifiedName); 383698"];
20111 [label="SplitMemberName(qualifiedName) 383699"];
20112 [label="param SplitMemberName(string name) 383700"];
20113 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383701"];
20114 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383702"];
20115 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383703"];
20116 [label="var builder = ArrayBuilder<string>.GetInstance(); 383704"];
20117 [label="string part = name; 383705"];
20118 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383706"];
20119 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383707"];
20120 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383708"];
20121 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383709"];
20122 [label="builder.ReverseContents(); 383710"];
20123 [label="return builder.ToImmutableAndFree(); 383711"];
20124 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383712"];
20125 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383713"];
20126 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383714"];
20127 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383715"];
20128 [label="lastContainer.GetMembers(parts[parts.Length - 1]) 383716"];
20129 [label="param GetMembers(string name) 383717"];
20130 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 383718"];
20131 [label="members 383719"];
20132 [label="this.GetNameToMembersMap() 383720"];
20133 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 383721"];
20134 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383722"];
20135 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383723"];
20136 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383724"];
20137 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383725"];
20138 [label="if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383726"];
20139 [label="var typeAb = typeA.BaseType(); 383727"];
20140 [label="typeA.BaseType() 383728"];
20141 [label="param BaseType(this TypeSymbol symbol) 383729"];
20142 [label="symbol.BaseTypeNoUseSiteDiagnostics 383730"];
20143 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 383731"];
20144 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 383732"];
20145 [label="return _lazyBaseType; 383733"];
20146 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 383734"];
20147 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeAb.Kind); 383735"];
20148 [label="typeAb.Kind 383736"];
20149 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 383737"];
20150 [label="return SymbolKind.ErrorType; 383738"];
20151 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeAb.Kind); 383739"];
20152 [label="CustomAssert.Equal(2, typeAb.Arity); 383740"];
20153 [label="typeAb.Arity 383741"];
20154 [label="get { return _originalDefinition.Arity; } 383742"];
20155 [label="_originalDefinition.Arity 383743"];
20156 [label="get\n            {\n                return _arity;\n            } 383744"];
20157 [label="return _arity; 383745"];
20158 [label="return _originalDefinition.Arity; 383746"];
20159 [label="CustomAssert.Equal(2, typeAb.Arity); 383747"];
20160 [label="var typeB = typeA.GetMember<NamedTypeSymbol>('B'); 383748"];
20161 [label="var typeB = typeA.GetMember<NamedTypeSymbol>('B'); 383749"];
20162 [label="typeA.GetMember<NamedTypeSymbol>('B') 383750"];
20163 [label="param GetMember(this NamespaceOrTypeSymbol symbol) 383751"];
20164 [label="param GetMember(string qualifiedName) 383752"];
20165 [label="return (T)symbol.GetMember(qualifiedName); 383753"];
20166 [label="symbol.GetMember(qualifiedName) 383754"];
20167 [label="param GetMember(string qualifiedName) 383755"];
20168 [label="NamespaceOrTypeSymbol lastContainer; 383756"];
20169 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383757"];
20170 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383758"];
20171 [label="GetMembers(container, qualifiedName, out lastContainer) 383759"];
20172 [label="param GetMembers(string qualifiedName) 383760"];
20173 [label="param GetMembers(out NamespaceOrTypeSymbol lastContainer) 383761"];
20174 [label="var parts = SplitMemberName(qualifiedName); 383762"];
20175 [label="SplitMemberName(qualifiedName) 383763"];
20176 [label="param SplitMemberName(string name) 383764"];
20177 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383765"];
20178 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383766"];
20179 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383767"];
20180 [label="var builder = ArrayBuilder<string>.GetInstance(); 383768"];
20181 [label="string part = name; 383769"];
20182 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383770"];
20183 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383771"];
20184 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383772"];
20185 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383773"];
20186 [label="builder.ReverseContents(); 383774"];
20187 [label="return builder.ToImmutableAndFree(); 383775"];
20188 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383776"];
20189 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383777"];
20190 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383778"];
20191 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383779"];
20192 [label="lastContainer.GetMembers(parts[parts.Length - 1]) 383780"];
20193 [label="param GetMembers(string name) 383781"];
20194 [label="ImmutableArray<Symbol> members; 383782"];
20195 [label="members 383783"];
20196 [label="GetMembersByName() 383784"];
20197 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 383785"];
20198 [label="this.state.HasComplete(CompletionPart.Members) 383786"];
20199 [label="param HasComplete(CompletionPart part) 383787"];
20200 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 383788"];
20201 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 383789"];
20202 [label="return members; 383790"];
20203 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383791"];
20204 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383792"];
20205 [label="if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383793"];
20206 [label="CustomAssert.Equal('BB', typeB.BaseType().Name); 383794"];
20207 [label="CustomAssert.Equal('BB', typeB.BaseType().Name); 383795"];
20208 [label="typeB.BaseType() 383796"];
20209 [label="param BaseType(this TypeSymbol symbol) 383797"];
20210 [label="symbol.BaseTypeNoUseSiteDiagnostics 383798"];
20211 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 383799"];
20212 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 383800"];
20213 [label="return _lazyBaseType; 383801"];
20214 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 383802"];
20215 [label="typeB.BaseType().Name 383803"];
20216 [label="get\n            {\n                return declaration.Name;\n            } 383804"];
20217 [label="var typeBi = typeB.Interfaces().Single(); 383805"];
20218 [label="typeB.Interfaces() 383806"];
20219 [label="param Interfaces(this TypeSymbol symbol) 383807"];
20220 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383808"];
20221 [label="symbol.InterfacesNoUseSiteDiagnostics() 383809"];
20222 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 383810"];
20223 [label="param InterfacesNoUseSiteDiagnostics(this) 383811"];
20224 [label="return _lazyInterfaces; 383812"];
20225 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383813"];
20226 [label="CustomAssert.Equal('IGoo', typeBi.Name); 383814"];
20227 [label="typeBi.Name 383815"];
20228 [label="get { return _originalDefinition.Name; } 383816"];
20229 [label="_originalDefinition.Name 383817"];
20230 [label="get\n            {\n                return _name;\n            } 383818"];
20231 [label="return _name; 383819"];
20232 [label="return _originalDefinition.Name; 383820"];
20233 [label="CustomAssert.Equal('IGoo', typeBi.Name); 383821"];
20234 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeBi.Kind); 383822"];
20235 [label="typeBi.Kind 383823"];
20236 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 383824"];
20237 [label="return SymbolKind.ErrorType; 383825"];
20238 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeBi.Kind); 383826"];
20239 [label="CustomAssert.Equal(2, typeBi.Arity); 383827"];
20240 [label="typeBi.Arity 383828"];
20241 [label="get { return _originalDefinition.Arity; } 383829"];
20242 [label="_originalDefinition.Arity 383830"];
20243 [label="get\n            {\n                return _arity;\n            } 383831"];
20244 [label="return _arity; 383832"];
20245 [label="return _originalDefinition.Arity; 383833"];
20246 [label="CustomAssert.Equal(2, typeBi.Arity); 383834"];
20247 [label="var typeC = ns.GetMember<NamedTypeSymbol>('C'); 383835"];
20248 [label="var typeC = ns.GetMember<NamedTypeSymbol>('C'); 383836"];
20249 [label="ns.GetMember<NamedTypeSymbol>('C') 383837"];
20250 [label="param GetMember(this NamespaceOrTypeSymbol symbol) 383838"];
20251 [label="param GetMember(string qualifiedName) 383839"];
20252 [label="return (T)symbol.GetMember(qualifiedName); 383840"];
20253 [label="symbol.GetMember(qualifiedName) 383841"];
20254 [label="param GetMember(string qualifiedName) 383842"];
20255 [label="NamespaceOrTypeSymbol lastContainer; 383843"];
20256 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383844"];
20257 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383845"];
20258 [label="GetMembers(container, qualifiedName, out lastContainer) 383846"];
20259 [label="param GetMembers(string qualifiedName) 383847"];
20260 [label="param GetMembers(out NamespaceOrTypeSymbol lastContainer) 383848"];
20261 [label="var parts = SplitMemberName(qualifiedName); 383849"];
20262 [label="SplitMemberName(qualifiedName) 383850"];
20263 [label="param SplitMemberName(string name) 383851"];
20264 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383852"];
20265 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383853"];
20266 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383854"];
20267 [label="var builder = ArrayBuilder<string>.GetInstance(); 383855"];
20268 [label="string part = name; 383856"];
20269 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383857"];
20270 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383858"];
20271 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383859"];
20272 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383860"];
20273 [label="builder.ReverseContents(); 383861"];
20274 [label="return builder.ToImmutableAndFree(); 383862"];
20275 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383863"];
20276 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383864"];
20277 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383865"];
20278 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383866"];
20279 [label="lastContainer.GetMembers(parts[parts.Length - 1]) 383867"];
20280 [label="param GetMembers(string name) 383868"];
20281 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 383869"];
20282 [label="members 383870"];
20283 [label="this.GetNameToMembersMap() 383871"];
20284 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 383872"];
20285 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 383873"];
20286 [label="return _nameToMembersMap; 383874"];
20287 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383875"];
20288 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 383876"];
20289 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383877"];
20290 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383878"];
20291 [label="if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383879"];
20292 [label="CustomAssert.Equal(SpecialType.System_Object, typeC.BaseType().SpecialType); 383880"];
20293 [label="CustomAssert.Equal(SpecialType.System_Object, typeC.BaseType().SpecialType); 383881"];
20294 [label="typeC.BaseType() 383882"];
20295 [label="param BaseType(this TypeSymbol symbol) 383883"];
20296 [label="symbol.BaseTypeNoUseSiteDiagnostics 383884"];
20297 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 383885"];
20298 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 383886"];
20299 [label="return _lazyBaseType; 383887"];
20300 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 383888"];
20301 [label="typeC.BaseType().SpecialType 383889"];
20302 [label="get\n            {\n                return _corTypeId;\n            } 383890"];
20303 [label="var typeCi = typeC.Interfaces().Single(); 383891"];
20304 [label="typeC.Interfaces() 383892"];
20305 [label="param Interfaces(this TypeSymbol symbol) 383893"];
20306 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383894"];
20307 [label="symbol.InterfacesNoUseSiteDiagnostics() 383895"];
20308 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 383896"];
20309 [label="param InterfacesNoUseSiteDiagnostics(this) 383897"];
20310 [label="return _lazyInterfaces; 383898"];
20311 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383899"];
20312 [label="CustomAssert.Equal('IBar', typeCi.Name); 383900"];
20313 [label="typeCi.Name 383901"];
20314 [label="get { return _originalDefinition.Name; } 383902"];
20315 [label="_originalDefinition.Name 383903"];
20316 [label="get\n            {\n                return _name;\n            } 383904"];
20317 [label="return _name; 383905"];
20318 [label="return _originalDefinition.Name; 383906"];
20319 [label="CustomAssert.Equal('IBar', typeCi.Name); 383907"];
20320 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeCi.Kind); 383908"];
20321 [label="typeCi.Kind 383909"];
20322 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 383910"];
20323 [label="return SymbolKind.ErrorType; 383911"];
20324 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeCi.Kind); 383912"];
20325 [label="CustomAssert.Equal(2, typeCi.Arity); 383913"];
20326 [label="typeCi.Arity 383914"];
20327 [label="get { return _originalDefinition.Arity; } 383915"];
20328 [label="_originalDefinition.Arity 383916"];
20329 [label="get\n            {\n                return _arity;\n            } 383917"];
20330 [label="return _arity; 383918"];
20331 [label="return _originalDefinition.Arity; 383919"];
20332 [label="CustomAssert.Equal(2, typeCi.Arity); 383920"];
20333 [label="var typeD = typeC.GetMember<NamedTypeSymbol>('D'); 383921"];
20334 [label="var typeD = typeC.GetMember<NamedTypeSymbol>('D'); 383922"];
20335 [label="typeC.GetMember<NamedTypeSymbol>('D') 383923"];
20336 [label="param GetMember(this NamespaceOrTypeSymbol symbol) 383924"];
20337 [label="param GetMember(string qualifiedName) 383925"];
20338 [label="return (T)symbol.GetMember(qualifiedName); 383926"];
20339 [label="symbol.GetMember(qualifiedName) 383927"];
20340 [label="param GetMember(string qualifiedName) 383928"];
20341 [label="NamespaceOrTypeSymbol lastContainer; 383929"];
20342 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383930"];
20343 [label="var members = GetMembers(container, qualifiedName, out lastContainer); 383931"];
20344 [label="GetMembers(container, qualifiedName, out lastContainer) 383932"];
20345 [label="param GetMembers(string qualifiedName) 383933"];
20346 [label="param GetMembers(out NamespaceOrTypeSymbol lastContainer) 383934"];
20347 [label="var parts = SplitMemberName(qualifiedName); 383935"];
20348 [label="SplitMemberName(qualifiedName) 383936"];
20349 [label="param SplitMemberName(string name) 383937"];
20350 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383938"];
20351 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383939"];
20352 [label="if (name.StartsWith('.', StringComparison.Ordinal))\n            {\n                return ImmutableArray.Create(name);\n            } 383940"];
20353 [label="var builder = ArrayBuilder<string>.GetInstance(); 383941"];
20354 [label="string part = name; 383942"];
20355 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383943"];
20356 [label="while (part.Length > 0)\n            {\n                builder.Add(MetadataHelpers.SplitQualifiedName(part, out part));\n            } 383944"];
20357 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383945"];
20358 [label="builder.Add(MetadataHelpers.SplitQualifiedName(part, out part)); 383946"];
20359 [label="builder.ReverseContents(); 383947"];
20360 [label="return builder.ToImmutableAndFree(); 383948"];
20361 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383949"];
20362 [label="for (int i = 0; i < parts.Length - 1; i++)\n            {\n                var nestedContainer = (NamespaceOrTypeSymbol)lastContainer.GetMember(parts[i]);\n                if (nestedContainer == null)\n                {\n                    // If there wasn't a nested namespace or type with that name, assume it's a\n                    // member name that includes dots (e.g. explicit interface implementation).\n                    return lastContainer.GetMembers(string.Join('.', parts.Skip(i)));\n                }\n                else\n                {\n                    lastContainer = nestedContainer;\n                }\n            } 383950"];
20363 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383951"];
20364 [label="return lastContainer.GetMembers(parts[parts.Length - 1]); 383952"];
20365 [label="lastContainer.GetMembers(parts[parts.Length - 1]) 383953"];
20366 [label="param GetMembers(string name) 383954"];
20367 [label="ImmutableArray<Symbol> members; 383955"];
20368 [label="members 383956"];
20369 [label="GetMembersByName() 383957"];
20370 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 383958"];
20371 [label="this.state.HasComplete(CompletionPart.Members) 383959"];
20372 [label="param HasComplete(CompletionPart part) 383960"];
20373 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 383961"];
20374 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 383962"];
20375 [label="return members; 383963"];
20376 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383964"];
20377 [label="if (members.Length == 0)\n            {\n                return null;\n            }\n            else if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383965"];
20378 [label="if (members.Length > 1)\n            {\n                CustomAssert.True(false, 'Found multiple members of specified name:\\r\\n' + string.Join('\\r\\n', members));\n            } 383966"];
20379 [label="var typeDi = typeD.Interfaces().Single(); 383967"];
20380 [label="typeD.Interfaces() 383968"];
20381 [label="param Interfaces(this TypeSymbol symbol) 383969"];
20382 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383970"];
20383 [label="symbol.InterfacesNoUseSiteDiagnostics() 383971"];
20384 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 383972"];
20385 [label="param InterfacesNoUseSiteDiagnostics(this) 383973"];
20386 [label="return _lazyInterfaces; 383974"];
20387 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 383975"];
20388 [label="CustomAssert.Equal('IGoo', typeDi.Name); 383976"];
20389 [label="typeDi.Name 383977"];
20390 [label="get\n            {\n                return _underlyingType.Name;\n            } 383978"];
20391 [label="_underlyingType.Name 383979"];
20392 [label="get\n            {\n                return declaration.Name;\n            } 383980"];
20393 [label="return _underlyingType.Name; 383981"];
20394 [label="CustomAssert.Equal('IGoo', typeDi.Name); 383982"];
20395 [label="CustomAssert.Equal(3, typeDi.TypeParameters.Length); 383983"];
20396 [label="typeDi.TypeParameters 383984"];
20397 [label="get\n            {\n                EnsureMapAndTypeParameters();\n                return _lazyTypeParameters;\n            } 383985"];
20398 [label="EnsureMapAndTypeParameters() 383986"];
20399 [label="param EnsureMapAndTypeParameters(this) 383987"];
20400 [label="if (!_lazyTypeParameters.IsDefault)\n            {\n                return;\n            } 383988"];
20401 [label="return; 383989"];
20402 [label="EnsureMapAndTypeParameters(); 383990"];
20403 [label="return _lazyTypeParameters; 383991"];
20404 [label="CustomAssert.Equal(3, typeDi.TypeParameters.Length); 383992"];
20405 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeDi.TypeArguments()[2].Kind); 383993"];
20406 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeDi.TypeArguments()[2].Kind); 383994"];
20407 [label="typeDi.TypeArguments() 383995"];
20408 [label="param TypeArguments(this NamedTypeSymbol symbol) 383996"];
20409 [label="symbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 383997"];
20410 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 383998"];
20411 [label="return _typeArgumentsWithAnnotations; 383999"];
20412 [label="return TypeMap.AsTypeSymbols(symbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics); 384000"];
20413 [label="TypeMap.AsTypeSymbols(symbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics) 384001"];
20414 [label="param AsTypeSymbols(ImmutableArray<TypeWithAnnotations> typesOpt) 384002"];
20415 [label="typesOpt.IsDefault 384003"];
20416 [label="return typesOpt.IsDefault ? default : typesOpt.SelectAsArray(AsTypeSymbol); 384004"];
20417 [label="return typesOpt.IsDefault ? default : typesOpt.SelectAsArray(AsTypeSymbol); 384005"];
20418 [label="return typesOpt.IsDefault ? default : typesOpt.SelectAsArray(AsTypeSymbol); 384006"];
20419 [label="=> defaultType 384007"];
20420 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeDi.TypeArguments()[2].Kind); 384008"];
20421 [label="typeDi.TypeArguments()[2].Kind 384009"];
20422 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 384010"];
20423 [label="return SymbolKind.ErrorType; 384011"];
20424 [label="CustomAssert.Equal(SymbolKind.ErrorType, typeDi.TypeArguments()[2].Kind); 384012"];
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
196 -> 1;
197 -> 196;
197 -> 1;
198 -> 1;
199 -> 197;
199 -> 198;
200 -> 199;
200 -> 198;
201 -> 198;
202 -> 200;
202 -> 201;
203 -> 201;
204 -> 202;
204 -> 203;
204 -> 201;
205 -> 201;
205 -> 1;
206 -> 1;
207 -> 1;
208 -> 205;
208 -> 207;
209 -> 206;
209 -> 207;
210 -> 206;
210 -> 207;
211 -> 206;
211 -> 207;
212 -> 206;
212 -> 207;
213 -> 206;
213 -> 207;
214 -> 206;
214 -> 207;
215 -> 206;
215 -> 207;
216 -> 208;
216 -> 207;
217 -> 212;
217 -> 207;
218 -> 209;
218 -> 207;
219 -> 207;
220 -> 217;
220 -> 219;
221 -> 218;
221 -> 219;
222 -> 220;
222 -> 219;
223 -> 219;
224 -> 222;
224 -> 223;
225 -> 224;
225 -> 223;
226 -> 225;
227 -> 0;
227 -> 226;
228 -> 227;
229 -> 228;
230 -> 229;
230 -> 226;
231 -> 219;
232 -> 221;
232 -> 231;
232 -> 219;
233 -> 230;
233 -> 232;
234 -> 210;
234 -> 207;
235 -> 211;
235 -> 207;
236 -> 213;
236 -> 207;
237 -> 214;
237 -> 207;
238 -> 215;
238 -> 207;
239 -> 207;
240 -> 216;
240 -> 239;
241 -> 233;
241 -> 239;
242 -> 234;
242 -> 239;
243 -> 235;
243 -> 239;
244 -> 236;
244 -> 239;
245 -> 237;
245 -> 239;
246 -> 238;
246 -> 239;
247 -> 240;
247 -> 239;
248 -> 241;
248 -> 239;
249 -> 242;
249 -> 239;
250 -> 243;
250 -> 239;
251 -> 244;
251 -> 239;
252 -> 245;
252 -> 239;
253 -> 246;
253 -> 239;
254 -> 239;
255 -> 254;
255 -> 239;
256 -> 239;
257 -> 247;
257 -> 256;
258 -> 248;
258 -> 256;
259 -> 249;
259 -> 256;
260 -> 250;
260 -> 256;
261 -> 251;
261 -> 256;
262 -> 252;
262 -> 256;
263 -> 253;
263 -> 256;
264 -> 255;
264 -> 256;
265 -> 260;
265 -> 256;
266 -> 262;
266 -> 256;
267 -> 256;
268 -> 265;
268 -> 267;
269 -> 266;
269 -> 267;
270 -> 257;
270 -> 267;
271 -> 270;
271 -> 204;
271 -> 267;
272 -> 271;
273 -> 269;
273 -> 271;
274 -> 268;
274 -> 271;
275 -> 271;
276 -> 272;
276 -> 275;
277 -> 273;
277 -> 275;
278 -> 274;
278 -> 275;
279 -> 272;
279 -> 275;
280 -> 275;
281 -> 278;
281 -> 280;
281 -> 275;
282 -> 0;
283 -> 0;
285 -> 282;
285 -> 283;
285 -> 284;
286 -> 285;
287 -> 0;
288 -> 286;
288 -> 285;
288 -> 287;
289 -> 288;
290 -> 0;
291 -> 286;
291 -> 285;
291 -> 290;
292 -> 291;
293 -> 0;
294 -> 286;
294 -> 285;
294 -> 293;
295 -> 294;
296 -> 0;
297 -> 286;
297 -> 285;
297 -> 296;
298 -> 297;
299 -> 0;
300 -> 286;
300 -> 285;
300 -> 299;
301 -> 300;
302 -> 0;
303 -> 286;
303 -> 285;
303 -> 302;
304 -> 303;
305 -> 0;
306 -> 286;
306 -> 285;
306 -> 305;
307 -> 306;
308 -> 0;
309 -> 286;
309 -> 285;
309 -> 308;
310 -> 309;
311 -> 0;
312 -> 286;
312 -> 285;
312 -> 311;
313 -> 312;
314 -> 0;
315 -> 286;
315 -> 285;
315 -> 314;
316 -> 315;
317 -> 0;
318 -> 286;
318 -> 285;
318 -> 317;
319 -> 318;
320 -> 286;
323 -> 320;
323 -> 322;
324 -> 321;
324 -> 322;
325 -> 322;
326 -> 323;
326 -> 285;
326 -> 322;
327 -> 322;
328 -> 324;
328 -> 322;
329 -> 325;
329 -> 322;
330 -> 328;
330 -> 329;
330 -> 322;
331 -> 330;
331 -> 327;
331 -> 322;
332 -> 326;
332 -> 327;
332 -> 285;
332 -> 331;
332 -> 330;
332 -> 322;
333 -> 332;
334 -> 0;
335 -> 334;
337 -> 335;
337 -> 336;
338 -> 286;
338 -> 285;
338 -> 337;
339 -> 338;
340 -> 0;
341 -> 340;
342 -> 286;
342 -> 285;
342 -> 341;
343 -> 342;
344 -> 0;
345 -> 286;
345 -> 285;
345 -> 344;
346 -> 345;
347 -> 310;
349 -> 348;
350 -> 0;
351 -> 0;
352 -> 0;
354 -> 350;
354 -> 351;
354 -> 352;
354 -> 353;
355 -> 349;
356 -> 354;
356 -> 355;
356 -> 348;
357 -> 356;
361 -> 358;
361 -> 359;
361 -> 360;
362 -> 292;
362 -> 285;
362 -> 291;
362 -> 358;
362 -> 361;
363 -> 362;
364 -> 304;
365 -> 313;
366 -> 313;
367 -> 310;
368 -> 0;
369 -> 0;
371 -> 368;
371 -> 370;
372 -> 369;
372 -> 370;
373 -> 370;
374 -> 371;
374 -> 370;
375 -> 372;
375 -> 370;
376 -> 0;
376 -> 370;
377 -> 373;
377 -> 370;
378 -> 370;
379 -> 374;
379 -> 375;
379 -> 376;
379 -> 377;
379 -> 378;
379 -> 370;
380 -> 379;
381 -> 0;
382 -> 0;
384 -> 381;
384 -> 383;
385 -> 382;
385 -> 383;
386 -> 383;
387 -> 384;
387 -> 383;
388 -> 385;
388 -> 383;
389 -> 0;
389 -> 383;
390 -> 386;
390 -> 383;
391 -> 383;
392 -> 387;
392 -> 388;
392 -> 389;
392 -> 390;
392 -> 391;
392 -> 383;
393 -> 392;
395 -> 380;
395 -> 379;
395 -> 394;
396 -> 395;
398 -> 393;
398 -> 392;
398 -> 397;
399 -> 398;
400 -> 0;
401 -> 0;
403 -> 400;
403 -> 402;
404 -> 401;
404 -> 402;
405 -> 402;
406 -> 403;
406 -> 402;
407 -> 404;
407 -> 402;
408 -> 0;
408 -> 402;
409 -> 405;
409 -> 402;
410 -> 402;
411 -> 406;
411 -> 407;
411 -> 408;
411 -> 409;
411 -> 410;
411 -> 402;
412 -> 411;
413 -> 0;
414 -> 0;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 415;
419 -> 416;
419 -> 415;
420 -> 417;
420 -> 415;
421 -> 0;
421 -> 415;
422 -> 418;
422 -> 415;
423 -> 415;
424 -> 419;
424 -> 420;
424 -> 421;
424 -> 422;
424 -> 423;
424 -> 415;
425 -> 424;
426 -> 0;
427 -> 0;
429 -> 426;
429 -> 428;
430 -> 427;
430 -> 428;
431 -> 428;
432 -> 429;
432 -> 428;
433 -> 430;
433 -> 428;
434 -> 0;
434 -> 428;
435 -> 431;
435 -> 428;
436 -> 428;
437 -> 432;
437 -> 433;
437 -> 434;
437 -> 435;
437 -> 436;
437 -> 428;
438 -> 437;
439 -> 0;
440 -> 0;
442 -> 439;
442 -> 441;
443 -> 440;
443 -> 441;
444 -> 441;
445 -> 442;
445 -> 441;
446 -> 443;
446 -> 441;
447 -> 0;
447 -> 441;
448 -> 444;
448 -> 441;
449 -> 441;
450 -> 445;
450 -> 446;
450 -> 447;
450 -> 448;
450 -> 449;
450 -> 441;
451 -> 450;
452 -> 0;
453 -> 0;
455 -> 452;
455 -> 454;
456 -> 453;
456 -> 454;
457 -> 454;
458 -> 455;
458 -> 454;
459 -> 456;
459 -> 454;
460 -> 0;
460 -> 454;
461 -> 457;
461 -> 454;
462 -> 454;
463 -> 458;
463 -> 459;
463 -> 460;
463 -> 461;
463 -> 462;
463 -> 454;
464 -> 463;
465 -> 0;
466 -> 0;
468 -> 465;
468 -> 467;
469 -> 466;
469 -> 467;
470 -> 467;
471 -> 468;
471 -> 467;
472 -> 469;
472 -> 467;
473 -> 0;
473 -> 467;
474 -> 470;
474 -> 467;
475 -> 467;
476 -> 471;
476 -> 472;
476 -> 473;
476 -> 474;
476 -> 475;
476 -> 467;
477 -> 476;
479 -> 380;
479 -> 379;
479 -> 478;
480 -> 479;
482 -> 393;
482 -> 392;
482 -> 481;
483 -> 482;
485 -> 412;
485 -> 411;
485 -> 484;
486 -> 485;
488 -> 425;
488 -> 424;
488 -> 487;
489 -> 488;
490 -> 0;
491 -> 380;
491 -> 379;
491 -> 490;
491 -> 0;
492 -> 491;
493 -> 0;
494 -> 393;
494 -> 392;
494 -> 493;
494 -> 0;
495 -> 494;
496 -> 0;
497 -> 464;
497 -> 463;
497 -> 496;
497 -> 0;
498 -> 497;
499 -> 0;
500 -> 412;
500 -> 411;
500 -> 499;
500 -> 0;
501 -> 500;
502 -> 0;
503 -> 0;
503 -> 502;
504 -> 503;
505 -> 286;
505 -> 281;
506 -> 276;
506 -> 275;
507 -> 0;
507 -> 275;
508 -> 507;
508 -> 279;
508 -> 275;
509 -> 275;
510 -> 506;
510 -> 508;
510 -> 509;
510 -> 0;
510 -> 275;
511 -> 510;
511 -> 275;
512 -> 505;
512 -> 275;
513 -> 277;
513 -> 275;
514 -> 275;
515 -> 511;
515 -> 512;
515 -> 513;
515 -> 514;
515 -> 510;
515 -> 285;
515 -> 275;
516 -> 275;
517 -> 515;
517 -> 516;
518 -> 516;
519 -> 516;
520 -> 517;
520 -> 515;
520 -> 519;
520 -> 516;
521 -> 518;
521 -> 516;
522 -> 516;
523 -> 520;
523 -> 515;
523 -> 519;
523 -> 521;
523 -> 522;
523 -> 518;
523 -> 516;
524 -> 516;
525 -> 524;
525 -> 518;
525 -> 516;
526 -> 518;
526 -> 516;
527 -> 516;
528 -> 526;
528 -> 527;
528 -> 518;
528 -> 525;
528 -> 516;
529 -> 517;
529 -> 516;
530 -> 529;
530 -> 272;
530 -> 271;
531 -> 272;
531 -> 256;
532 -> 256;
533 -> 259;
533 -> 532;
533 -> 256;
534 -> 531;
534 -> 533;
535 -> 533;
536 -> 534;
536 -> 535;
536 -> 272;
536 -> 530;
536 -> 515;
536 -> 533;
537 -> 536;
537 -> 533;
538 -> 380;
538 -> 537;
539 -> 0;
539 -> 256;
540 -> 264;
540 -> 256;
541 -> 261;
541 -> 531;
541 -> 258;
541 -> 538;
541 -> 256;
543 -> 542;
544 -> 543;
545 -> 544;
546 -> 541;
546 -> 256;
547 -> 256;
548 -> 546;
548 -> 547;
549 -> 545;
549 -> 547;
550 -> 549;
551 -> 256;
552 -> 541;
552 -> 272;
552 -> 530;
552 -> 515;
552 -> 229;
552 -> 0;
552 -> 379;
552 -> 256;
553 -> 256;
554 -> 553;
555 -> 552;
555 -> 554;
555 -> 256;
556 -> 0;
558 -> 556;
558 -> 557;
559 -> 558;
560 -> 0;
562 -> 560;
562 -> 561;
564 -> 562;
564 -> 563;
565 -> 564;
566 -> 552;
566 -> 553;
567 -> 552;
567 -> 553;
568 -> 552;
568 -> 553;
569 -> 552;
569 -> 553;
570 -> 566;
570 -> 553;
571 -> 569;
571 -> 553;
572 -> 567;
572 -> 553;
573 -> 568;
573 -> 553;
574 -> 553;
575 -> 553;
576 -> 570;
576 -> 575;
577 -> 571;
577 -> 575;
578 -> 572;
578 -> 575;
579 -> 573;
579 -> 575;
580 -> 574;
580 -> 575;
581 -> 574;
581 -> 575;
582 -> 574;
582 -> 575;
583 -> 574;
583 -> 575;
584 -> 575;
585 -> 577;
585 -> 584;
585 -> 575;
586 -> 583;
586 -> 575;
587 -> 579;
587 -> 575;
588 -> 587;
588 -> 555;
588 -> 575;
589 -> 576;
589 -> 575;
590 -> 577;
590 -> 575;
591 -> 588;
591 -> 575;
592 -> 580;
592 -> 575;
593 -> 581;
593 -> 575;
594 -> 582;
594 -> 575;
595 -> 583;
595 -> 575;
596 -> 575;
597 -> 0;
597 -> 575;
598 -> 577;
598 -> 588;
598 -> 575;
599 -> 597;
599 -> 598;
599 -> 595;
599 -> 596;
599 -> 0;
599 -> 588;
599 -> 575;
600 -> 575;
601 -> 589;
601 -> 600;
602 -> 590;
602 -> 600;
603 -> 591;
603 -> 600;
604 -> 592;
604 -> 600;
605 -> 593;
605 -> 600;
606 -> 594;
606 -> 600;
607 -> 595;
607 -> 600;
608 -> 596;
608 -> 600;
609 -> 596;
609 -> 600;
610 -> 599;
610 -> 600;
611 -> 596;
611 -> 600;
612 -> 596;
612 -> 600;
613 -> 596;
613 -> 600;
614 -> 601;
614 -> 600;
615 -> 602;
615 -> 600;
616 -> 603;
616 -> 600;
617 -> 604;
617 -> 600;
618 -> 605;
618 -> 600;
619 -> 606;
619 -> 600;
620 -> 607;
620 -> 600;
621 -> 608;
621 -> 600;
622 -> 609;
622 -> 600;
623 -> 610;
623 -> 600;
624 -> 610;
624 -> 599;
624 -> 600;
625 -> 624;
625 -> 599;
625 -> 600;
626 -> 611;
626 -> 600;
627 -> 612;
627 -> 600;
628 -> 600;
629 -> 614;
629 -> 628;
630 -> 615;
630 -> 628;
631 -> 616;
631 -> 628;
632 -> 617;
632 -> 628;
633 -> 618;
633 -> 628;
634 -> 619;
634 -> 628;
635 -> 620;
635 -> 628;
636 -> 621;
636 -> 628;
637 -> 622;
637 -> 628;
638 -> 623;
638 -> 628;
639 -> 625;
639 -> 628;
640 -> 626;
640 -> 628;
641 -> 627;
641 -> 628;
642 -> 613;
642 -> 628;
643 -> 629;
643 -> 628;
644 -> 631;
644 -> 628;
645 -> 639;
645 -> 628;
646 -> 635;
646 -> 628;
647 -> 640;
647 -> 628;
648 -> 641;
648 -> 628;
649 -> 628;
650 -> 649;
650 -> 643;
650 -> 644;
650 -> 645;
650 -> 646;
650 -> 647;
650 -> 648;
650 -> 588;
650 -> 625;
650 -> 628;
651 -> 649;
651 -> 628;
652 -> 649;
652 -> 628;
653 -> 649;
653 -> 628;
654 -> 649;
654 -> 628;
655 -> 649;
655 -> 628;
656 -> 649;
656 -> 628;
657 -> 649;
657 -> 628;
658 -> 649;
658 -> 628;
659 -> 649;
659 -> 628;
660 -> 649;
660 -> 628;
661 -> 649;
661 -> 628;
662 -> 649;
662 -> 628;
663 -> 649;
663 -> 628;
664 -> 649;
664 -> 628;
665 -> 649;
665 -> 628;
666 -> 649;
666 -> 628;
667 -> 649;
667 -> 628;
668 -> 649;
668 -> 628;
669 -> 649;
669 -> 628;
670 -> 649;
670 -> 628;
671 -> 649;
671 -> 628;
672 -> 649;
672 -> 628;
673 -> 649;
673 -> 628;
674 -> 649;
674 -> 628;
675 -> 649;
675 -> 628;
676 -> 649;
676 -> 628;
677 -> 628;
678 -> 677;
678 -> 649;
678 -> 628;
679 -> 649;
679 -> 628;
680 -> 649;
680 -> 628;
681 -> 649;
681 -> 628;
682 -> 649;
682 -> 628;
683 -> 649;
683 -> 628;
684 -> 649;
684 -> 628;
685 -> 649;
685 -> 628;
686 -> 628;
687 -> 628;
688 -> 685;
688 -> 687;
689 -> 686;
689 -> 687;
691 -> 690;
692 -> 690;
693 -> 687;
694 -> 689;
694 -> 693;
695 -> 693;
696 -> 689;
696 -> 687;
697 -> 688;
697 -> 689;
697 -> 687;
698 -> 686;
698 -> 649;
698 -> 628;
699 -> 630;
699 -> 649;
699 -> 628;
700 -> 649;
700 -> 628;
701 -> 700;
701 -> 650;
701 -> 651;
701 -> 699;
701 -> 652;
701 -> 653;
701 -> 654;
701 -> 655;
701 -> 656;
701 -> 657;
701 -> 658;
701 -> 659;
701 -> 660;
701 -> 661;
701 -> 662;
701 -> 663;
701 -> 664;
701 -> 665;
701 -> 666;
701 -> 667;
701 -> 668;
701 -> 669;
701 -> 670;
701 -> 671;
701 -> 672;
701 -> 673;
701 -> 674;
701 -> 675;
701 -> 676;
701 -> 678;
701 -> 679;
701 -> 698;
701 -> 680;
701 -> 681;
701 -> 682;
701 -> 683;
701 -> 684;
701 -> 677;
701 -> 695;
701 -> 696;
701 -> 697;
701 -> 628;
702 -> 701;
702 -> 649;
702 -> 628;
703 -> 649;
703 -> 701;
703 -> 628;
704 -> 703;
704 -> 701;
704 -> 702;
704 -> 628;
705 -> 704;
705 -> 649;
705 -> 628;
706 -> 649;
706 -> 704;
706 -> 628;
707 -> 706;
707 -> 704;
707 -> 705;
707 -> 628;
708 -> 707;
708 -> 649;
708 -> 628;
709 -> 649;
709 -> 707;
709 -> 628;
710 -> 709;
710 -> 707;
710 -> 708;
710 -> 628;
711 -> 710;
711 -> 649;
711 -> 628;
712 -> 649;
712 -> 710;
712 -> 628;
713 -> 712;
713 -> 710;
713 -> 711;
713 -> 628;
714 -> 713;
714 -> 649;
714 -> 628;
715 -> 649;
715 -> 628;
716 -> 628;
717 -> 628;
718 -> 715;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 717;
721 -> 720;
721 -> 717;
722 -> 720;
722 -> 717;
723 -> 720;
723 -> 717;
724 -> 717;
725 -> 724;
725 -> 720;
725 -> 717;
726 -> 717;
727 -> 718;
727 -> 726;
727 -> 717;
728 -> 718;
728 -> 720;
728 -> 717;
729 -> 716;
729 -> 649;
729 -> 628;
730 -> 638;
730 -> 713;
730 -> 628;
731 -> 628;
732 -> 730;
732 -> 731;
733 -> 731;
734 -> 732;
734 -> 731;
735 -> 734;
735 -> 713;
735 -> 714;
735 -> 729;
735 -> 731;
736 -> 0;
736 -> 731;
737 -> 736;
737 -> 733;
737 -> 731;
738 -> 737;
738 -> 628;
739 -> 738;
739 -> 649;
739 -> 628;
740 -> 635;
740 -> 628;
741 -> 740;
742 -> 632;
742 -> 741;
742 -> 740;
743 -> 633;
743 -> 741;
743 -> 740;
744 -> 742;
744 -> 743;
744 -> 740;
745 -> 634;
745 -> 741;
745 -> 740;
746 -> 744;
746 -> 745;
746 -> 740;
747 -> 637;
747 -> 628;
748 -> 649;
748 -> 713;
748 -> 714;
748 -> 729;
748 -> 739;
748 -> 720;
748 -> 721;
748 -> 728;
748 -> 722;
748 -> 723;
748 -> 725;
748 -> 724;
748 -> 747;
749 -> 747;
750 -> 649;
750 -> 749;
751 -> 750;
751 -> 748;
751 -> 749;
752 -> 636;
752 -> 747;
753 -> 747;
754 -> 747;
755 -> 748;
755 -> 754;
756 -> 751;
756 -> 754;
757 -> 752;
757 -> 754;
758 -> 753;
758 -> 754;
759 -> 755;
759 -> 754;
760 -> 756;
760 -> 754;
761 -> 757;
761 -> 754;
762 -> 754;
763 -> 762;
763 -> 759;
763 -> 760;
763 -> 761;
763 -> 748;
763 -> 754;
764 -> 753;
764 -> 649;
764 -> 747;
765 -> 638;
765 -> 649;
765 -> 628;
766 -> 649;
766 -> 763;
766 -> 628;
767 -> 628;
768 -> 649;
768 -> 763;
768 -> 767;
768 -> 628;
769 -> 575;
770 -> 578;
770 -> 769;
770 -> 575;
771 -> 578;
771 -> 770;
772 -> 770;
773 -> 771;
773 -> 772;
774 -> 596;
774 -> 772;
775 -> 772;
776 -> 773;
776 -> 775;
776 -> 772;
777 -> 773;
777 -> 772;
778 -> 777;
778 -> 763;
778 -> 764;
778 -> 765;
778 -> 772;
779 -> 772;
780 -> 774;
780 -> 778;
780 -> 772;
781 -> 779;
781 -> 772;
782 -> 780;
782 -> 778;
782 -> 772;
783 -> 781;
783 -> 782;
783 -> 779;
783 -> 778;
783 -> 772;
784 -> 772;
785 -> 772;
786 -> 773;
786 -> 772;
787 -> 786;
787 -> 783;
787 -> 772;
788 -> 787;
789 -> 787;
790 -> 787;
791 -> 774;
791 -> 790;
791 -> 787;
792 -> 787;
793 -> 779;
793 -> 792;
793 -> 790;
793 -> 787;
794 -> 784;
794 -> 787;
794 -> 793;
795 -> 785;
795 -> 787;
796 -> 779;
796 -> 793;
796 -> 772;
797 -> 774;
797 -> 796;
797 -> 772;
798 -> 773;
798 -> 772;
799 -> 780;
799 -> 798;
799 -> 796;
799 -> 772;
800 -> 774;
800 -> 799;
800 -> 772;
801 -> 794;
801 -> 772;
802 -> 799;
802 -> 772;
803 -> 772;
804 -> 800;
804 -> 803;
805 -> 801;
805 -> 803;
806 -> 802;
806 -> 803;
807 -> 774;
807 -> 803;
808 -> 807;
808 -> 799;
808 -> 803;
809 -> 803;
810 -> 807;
810 -> 809;
811 -> 810;
811 -> 799;
811 -> 809;
812 -> 811;
812 -> 809;
813 -> 812;
813 -> 803;
814 -> 803;
815 -> 808;
815 -> 814;
816 -> 815;
816 -> 808;
816 -> 814;
817 -> 803;
818 -> 816;
818 -> 817;
819 -> 804;
819 -> 803;
820 -> 805;
820 -> 803;
821 -> 806;
821 -> 803;
822 -> 803;
823 -> 803;
824 -> 808;
824 -> 823;
825 -> 808;
825 -> 823;
826 -> 808;
826 -> 823;
827 -> 813;
827 -> 823;
828 -> 816;
828 -> 823;
829 -> 818;
829 -> 823;
830 -> 818;
830 -> 823;
831 -> 819;
831 -> 823;
832 -> 820;
832 -> 823;
833 -> 821;
833 -> 823;
834 -> 818;
834 -> 823;
835 -> 822;
835 -> 823;
836 -> 822;
836 -> 823;
837 -> 827;
837 -> 823;
838 -> 828;
838 -> 823;
839 -> 829;
839 -> 823;
840 -> 833;
840 -> 818;
840 -> 823;
841 -> 835;
841 -> 823;
842 -> 823;
843 -> 837;
843 -> 842;
844 -> 838;
844 -> 842;
845 -> 839;
845 -> 842;
846 -> 841;
846 -> 842;
847 -> 836;
847 -> 842;
848 -> 846;
848 -> 842;
849 -> 842;
850 -> 849;
850 -> 842;
851 -> 849;
851 -> 842;
852 -> 849;
852 -> 842;
853 -> 849;
853 -> 842;
854 -> 849;
854 -> 842;
855 -> 849;
855 -> 842;
856 -> 849;
856 -> 842;
857 -> 849;
857 -> 842;
858 -> 849;
858 -> 842;
859 -> 849;
859 -> 842;
860 -> 849;
860 -> 842;
861 -> 849;
861 -> 842;
862 -> 849;
862 -> 842;
863 -> 849;
863 -> 842;
864 -> 849;
864 -> 842;
865 -> 849;
865 -> 842;
866 -> 849;
866 -> 842;
867 -> 849;
867 -> 842;
868 -> 849;
868 -> 842;
869 -> 849;
869 -> 842;
870 -> 849;
870 -> 842;
871 -> 849;
871 -> 842;
872 -> 849;
872 -> 842;
873 -> 849;
873 -> 842;
874 -> 849;
874 -> 842;
875 -> 849;
875 -> 842;
876 -> 842;
877 -> 876;
877 -> 849;
877 -> 842;
878 -> 849;
878 -> 842;
879 -> 849;
879 -> 842;
880 -> 849;
880 -> 842;
881 -> 849;
881 -> 842;
882 -> 849;
882 -> 842;
883 -> 849;
883 -> 842;
884 -> 849;
884 -> 842;
885 -> 842;
886 -> 842;
887 -> 884;
887 -> 886;
888 -> 885;
888 -> 886;
889 -> 886;
890 -> 888;
890 -> 889;
891 -> 889;
892 -> 888;
892 -> 886;
893 -> 887;
893 -> 888;
893 -> 886;
894 -> 885;
894 -> 849;
894 -> 842;
895 -> 849;
895 -> 842;
896 -> 849;
896 -> 842;
897 -> 842;
898 -> 842;
899 -> 896;
899 -> 898;
900 -> 897;
900 -> 898;
901 -> 898;
902 -> 901;
902 -> 898;
903 -> 901;
903 -> 898;
904 -> 901;
904 -> 898;
905 -> 898;
906 -> 905;
906 -> 901;
906 -> 898;
907 -> 898;
908 -> 899;
908 -> 907;
908 -> 898;
909 -> 899;
909 -> 901;
909 -> 898;
910 -> 897;
910 -> 849;
910 -> 842;
911 -> 842;
912 -> 840;
912 -> 911;
913 -> 911;
914 -> 912;
914 -> 911;
915 -> 914;
915 -> 840;
915 -> 910;
915 -> 901;
915 -> 902;
915 -> 909;
915 -> 903;
915 -> 904;
915 -> 906;
915 -> 905;
916 -> 914;
917 -> 915;
917 -> 916;
918 -> 830;
918 -> 842;
919 -> 918;
920 -> 843;
920 -> 919;
920 -> 918;
921 -> 844;
921 -> 919;
921 -> 918;
922 -> 920;
922 -> 921;
922 -> 918;
923 -> 845;
923 -> 919;
923 -> 918;
924 -> 922;
924 -> 923;
924 -> 918;
925 -> 831;
925 -> 832;
926 -> 849;
926 -> 832;
927 -> 831;
927 -> 926;
927 -> 840;
927 -> 910;
927 -> 917;
927 -> 901;
927 -> 902;
927 -> 909;
927 -> 903;
927 -> 904;
927 -> 906;
927 -> 905;
927 -> 832;
928 -> 831;
928 -> 849;
928 -> 832;
929 -> 849;
929 -> 927;
929 -> 842;
930 -> 842;
931 -> 849;
931 -> 927;
931 -> 930;
931 -> 842;
932 -> 822;
932 -> 772;
933 -> 932;
933 -> 770;
934 -> 933;
934 -> 927;
934 -> 575;
935 -> 933;
935 -> 575;
936 -> 552;
936 -> 935;
936 -> 927;
936 -> 928;
936 -> 833;
936 -> 256;
937 -> 936;
937 -> 256;
938 -> 256;
939 -> 937;
939 -> 938;
940 -> 938;
941 -> 939;
941 -> 940;
942 -> 941;
942 -> 936;
942 -> 940;
943 -> 942;
943 -> 938;
944 -> 943;
944 -> 942;
944 -> 938;
945 -> 938;
946 -> 943;
946 -> 945;
946 -> 942;
946 -> 938;
947 -> 0;
947 -> 938;
948 -> 946;
948 -> 947;
948 -> 938;
949 -> 263;
949 -> 948;
949 -> 256;
950 -> 936;
950 -> 256;
951 -> 1;
952 -> 1;
953 -> 951;
953 -> 952;
954 -> 950;
954 -> 952;
955 -> 0;
955 -> 952;
956 -> 952;
957 -> 953;
957 -> 952;
958 -> 952;
959 -> 955;
959 -> 958;
960 -> 956;
960 -> 958;
961 -> 957;
961 -> 958;
962 -> 954;
962 -> 958;
963 -> 958;
964 -> 959;
964 -> 958;
965 -> 960;
965 -> 958;
966 -> 963;
966 -> 958;
967 -> 961;
967 -> 958;
968 -> 958;
969 -> 964;
969 -> 968;
970 -> 965;
970 -> 968;
971 -> 966;
971 -> 968;
972 -> 967;
972 -> 968;
973 -> 962;
973 -> 968;
974 -> 968;
975 -> 969;
975 -> 0;
975 -> 968;
976 -> 975;
976 -> 970;
976 -> 968;
977 -> 976;
978 -> 973;
978 -> 977;
979 -> 978;
979 -> 948;
979 -> 977;
980 -> 979;
980 -> 976;
981 -> 976;
982 -> 973;
982 -> 981;
983 -> 982;
983 -> 979;
983 -> 981;
984 -> 983;
984 -> 976;
985 -> 984;
986 -> 980;
986 -> 979;
986 -> 984;
987 -> 972;
987 -> 984;
988 -> 985;
988 -> 986;
988 -> 987;
988 -> 951;
988 -> 984;
989 -> 988;
989 -> 985;
990 -> 988;
990 -> 985;
991 -> 988;
991 -> 985;
992 -> 988;
992 -> 985;
993 -> 985;
994 -> 993;
994 -> 985;
995 -> 990;
995 -> 988;
995 -> 985;
996 -> 991;
996 -> 985;
997 -> 993;
997 -> 985;
998 -> 995;
998 -> 996;
998 -> 997;
998 -> 994;
998 -> 985;
999 -> 976;
1000 -> 980;
1000 -> 976;
1001 -> 972;
1001 -> 951;
1001 -> 998;
1001 -> 1000;
1002 -> 1000;
1002 -> 979;
1003 -> 969;
1003 -> 0;
1003 -> 968;
1004 -> 1003;
1004 -> 970;
1004 -> 968;
1005 -> 974;
1005 -> 1004;
1006 -> 1005;
1006 -> 973;
1006 -> 974;
1006 -> 979;
1006 -> 1004;
1007 -> 1004;
1008 -> 1006;
1008 -> 1007;
1009 -> 1008;
1009 -> 1006;
1009 -> 1007;
1010 -> 1004;
1011 -> 973;
1011 -> 1010;
1012 -> 1011;
1012 -> 1009;
1012 -> 1010;
1013 -> 1012;
1013 -> 1004;
1014 -> 1004;
1015 -> 973;
1015 -> 1014;
1016 -> 1015;
1016 -> 1013;
1016 -> 1014;
1017 -> 1016;
1017 -> 1004;
1018 -> 972;
1018 -> 1001;
1018 -> 1004;
1019 -> 1004;
1020 -> 973;
1020 -> 1019;
1021 -> 1020;
1021 -> 1013;
1021 -> 1019;
1022 -> 1020;
1022 -> 1021;
1023 -> 1021;
1024 -> 1022;
1024 -> 1023;
1025 -> 1020;
1025 -> 1013;
1025 -> 1023;
1026 -> 1024;
1026 -> 1023;
1027 -> 1023;
1028 -> 1026;
1028 -> 1027;
1029 -> 1025;
1029 -> 1027;
1030 -> 1027;
1031 -> 1027;
1032 -> 1027;
1033 -> 1028;
1033 -> 1032;
1034 -> 1033;
1034 -> 1027;
1035 -> 1027;
1036 -> 1027;
1037 -> 1036;
1037 -> 1027;
1038 -> 1027;
1039 -> 1038;
1039 -> 1027;
1040 -> 1027;
1041 -> 1040;
1041 -> 1027;
1042 -> 1027;
1043 -> 1042;
1043 -> 1027;
1044 -> 1028;
1044 -> 1027;
1045 -> 1031;
1045 -> 1027;
1046 -> 1042;
1046 -> 1027;
1047 -> 1035;
1047 -> 1027;
1048 -> 1036;
1048 -> 1027;
1049 -> 1038;
1049 -> 1027;
1050 -> 1040;
1050 -> 1027;
1051 -> 1030;
1051 -> 1027;
1052 -> 1044;
1052 -> 1045;
1052 -> 1046;
1052 -> 1047;
1052 -> 1048;
1052 -> 1049;
1052 -> 1050;
1052 -> 1051;
1052 -> 1029;
1052 -> 1013;
1052 -> 1031;
1052 -> 1030;
1052 -> 1043;
1052 -> 1037;
1052 -> 1039;
1052 -> 1041;
1052 -> 1027;
1053 -> 1027;
1054 -> 1052;
1054 -> 1053;
1055 -> 1053;
1056 -> 1054;
1056 -> 1055;
1057 -> 1056;
1057 -> 1052;
1057 -> 1055;
1058 -> 1057;
1058 -> 1053;
1059 -> 1053;
1060 -> 1058;
1060 -> 1059;
1061 -> 1058;
1061 -> 1059;
1062 -> 0;
1062 -> 1059;
1063 -> 1059;
1064 -> 1059;
1065 -> 1060;
1065 -> 1059;
1066 -> 1065;
1067 -> 1065;
1068 -> 1066;
1068 -> 1067;
1069 -> 1068;
1069 -> 1067;
1070 -> 0;
1070 -> 1069;
1071 -> 1065;
1072 -> 1070;
1072 -> 1065;
1073 -> 1062;
1073 -> 1065;
1074 -> 1063;
1074 -> 1065;
1075 -> 1064;
1075 -> 1065;
1076 -> 1061;
1076 -> 1065;
1077 -> 1065;
1078 -> 1071;
1078 -> 1077;
1079 -> 1072;
1079 -> 1077;
1080 -> 1073;
1080 -> 1077;
1081 -> 1074;
1081 -> 1077;
1082 -> 1075;
1082 -> 1077;
1083 -> 1076;
1083 -> 1077;
1084 -> 1080;
1084 -> 1079;
1084 -> 1077;
1085 -> 1077;
1086 -> 1062;
1086 -> 1070;
1086 -> 1065;
1087 -> 1086;
1087 -> 0;
1087 -> 1059;
1088 -> 1086;
1088 -> 1059;
1089 -> 1088;
1090 -> 1062;
1090 -> 1088;
1091 -> 1063;
1091 -> 1088;
1092 -> 1064;
1092 -> 1088;
1093 -> 1061;
1093 -> 1088;
1094 -> 1088;
1095 -> 1089;
1095 -> 1094;
1096 -> 1089;
1096 -> 1094;
1097 -> 1090;
1097 -> 1094;
1098 -> 1091;
1098 -> 1094;
1099 -> 1092;
1099 -> 1094;
1100 -> 1093;
1100 -> 1094;
1101 -> 1097;
1101 -> 1096;
1101 -> 1094;
1102 -> 1094;
1103 -> 1088;
1103 -> 0;
1103 -> 1059;
1104 -> 0;
1105 -> 0;
1105 -> 1104;
1106 -> 0;
1107 -> 1105;
1107 -> 0;
1107 -> 1106;
1108 -> 1107;
1109 -> 1058;
1109 -> 1059;
1110 -> 1058;
1110 -> 1059;
1111 -> 1059;
1112 -> 1109;
1112 -> 1088;
1112 -> 1111;
1112 -> 1059;
1113 -> 1052;
1113 -> 1053;
1114 -> 1113;
1114 -> 1088;
1114 -> 1053;
1115 -> 1052;
1115 -> 1053;
1116 -> 0;
1116 -> 1053;
1117 -> 1052;
1117 -> 1116;
1117 -> 1114;
1117 -> 1027;
1118 -> 1052;
1118 -> 1053;
1119 -> 1052;
1119 -> 1053;
1120 -> 1052;
1120 -> 1053;
1121 -> 1052;
1121 -> 1053;
1122 -> 1052;
1122 -> 1053;
1123 -> 1052;
1123 -> 1053;
1124 -> 1052;
1124 -> 1053;
1125 -> 1118;
1125 -> 1053;
1126 -> 1119;
1126 -> 1053;
1127 -> 1123;
1127 -> 1053;
1128 -> 1120;
1128 -> 1053;
1129 -> 1121;
1129 -> 1053;
1130 -> 1122;
1130 -> 1053;
1131 -> 1053;
1132 -> 1053;
1133 -> 1125;
1133 -> 1132;
1134 -> 1126;
1134 -> 1132;
1135 -> 1127;
1135 -> 1132;
1136 -> 1128;
1136 -> 1132;
1137 -> 1129;
1137 -> 1132;
1138 -> 1130;
1138 -> 1132;
1139 -> 1131;
1139 -> 1132;
1140 -> 1133;
1140 -> 1117;
1140 -> 1132;
1141 -> 1133;
1141 -> 1117;
1141 -> 1132;
1142 -> 1135;
1142 -> 1132;
1143 -> 1132;
1144 -> 1140;
1144 -> 1143;
1145 -> 1141;
1145 -> 1143;
1146 -> 1142;
1146 -> 1143;
1147 -> 1139;
1147 -> 1143;
1148 -> 1143;
1149 -> 1148;
1149 -> 1143;
1150 -> 1148;
1150 -> 1143;
1151 -> 1148;
1151 -> 1143;
1152 -> 1143;
1153 -> 1144;
1153 -> 1152;
1153 -> 1143;
1154 -> 1145;
1154 -> 1117;
1154 -> 1143;
1155 -> 1146;
1155 -> 1148;
1155 -> 1143;
1156 -> 1144;
1156 -> 1148;
1156 -> 1143;
1157 -> 1145;
1157 -> 1148;
1157 -> 1143;
1158 -> 1139;
1158 -> 1132;
1159 -> 1139;
1159 -> 1132;
1160 -> 1139;
1160 -> 1132;
1161 -> 1139;
1161 -> 1132;
1162 -> 1139;
1162 -> 1132;
1163 -> 1139;
1163 -> 1132;
1164 -> 1139;
1164 -> 1132;
1165 -> 1132;
1166 -> 1136;
1166 -> 1165;
1166 -> 1132;
1167 -> 1132;
1168 -> 1134;
1168 -> 1167;
1168 -> 1132;
1169 -> 1134;
1169 -> 1139;
1169 -> 1132;
1170 -> 1133;
1170 -> 1139;
1170 -> 1132;
1171 -> 1136;
1171 -> 1139;
1171 -> 1132;
1172 -> 1138;
1172 -> 1139;
1172 -> 1132;
1173 -> 1137;
1173 -> 1139;
1173 -> 1132;
1174 -> 1052;
1174 -> 1131;
1174 -> 1117;
1174 -> 1148;
1174 -> 1149;
1174 -> 1150;
1174 -> 1156;
1174 -> 1151;
1174 -> 1155;
1174 -> 1157;
1174 -> 1158;
1174 -> 1170;
1174 -> 1159;
1174 -> 1169;
1174 -> 1160;
1174 -> 1171;
1174 -> 1161;
1174 -> 1172;
1174 -> 1162;
1174 -> 1173;
1174 -> 1163;
1174 -> 1164;
1174 -> 1027;
1175 -> 1174;
1175 -> 1152;
1175 -> 1143;
1176 -> 1174;
1176 -> 1143;
1177 -> 1029;
1177 -> 1174;
1177 -> 1027;
1178 -> 1027;
1179 -> 1174;
1179 -> 1027;
1180 -> 1177;
1180 -> 1178;
1181 -> 1180;
1181 -> 1177;
1181 -> 1178;
1182 -> 1027;
1183 -> 1181;
1183 -> 1027;
1184 -> 1027;
1185 -> 1027;
1186 -> 1027;
1187 -> 1186;
1187 -> 1027;
1188 -> 1027;
1189 -> 1188;
1189 -> 1027;
1190 -> 1027;
1191 -> 1190;
1191 -> 1027;
1192 -> 1028;
1192 -> 1183;
1192 -> 1027;
1193 -> 1027;
1194 -> 1192;
1194 -> 1193;
1194 -> 1027;
1195 -> 1194;
1195 -> 1027;
1196 -> 1027;
1197 -> 1195;
1197 -> 1196;
1197 -> 1027;
1198 -> 1197;
1198 -> 1027;
1199 -> 1027;
1200 -> 1198;
1200 -> 1199;
1200 -> 1027;
1201 -> 1200;
1201 -> 1027;
1202 -> 0;
1202 -> 1027;
1203 -> 1202;
1203 -> 1201;
1203 -> 1027;
1204 -> 1028;
1204 -> 1027;
1205 -> 1183;
1205 -> 1027;
1206 -> 1174;
1206 -> 1027;
1207 -> 1027;
1208 -> 1028;
1208 -> 1207;
1209 -> 1208;
1209 -> 1183;
1209 -> 1207;
1210 -> 1209;
1210 -> 1027;
1211 -> 1027;
1212 -> 1028;
1212 -> 1211;
1213 -> 1212;
1213 -> 1183;
1213 -> 1211;
1214 -> 1213;
1214 -> 1027;
1215 -> 1034;
1215 -> 1027;
1216 -> 1031;
1216 -> 1027;
1217 -> 1190;
1217 -> 1027;
1218 -> 1186;
1218 -> 1027;
1219 -> 1188;
1219 -> 1027;
1220 -> 1203;
1220 -> 1027;
1221 -> 1030;
1221 -> 1027;
1222 -> 1184;
1222 -> 1027;
1223 -> 1185;
1223 -> 1027;
1224 -> 1204;
1224 -> 1205;
1224 -> 1206;
1224 -> 1210;
1224 -> 1214;
1224 -> 1215;
1224 -> 1216;
1224 -> 1217;
1224 -> 1218;
1224 -> 1219;
1224 -> 1220;
1224 -> 1221;
1224 -> 1222;
1224 -> 1223;
1224 -> 1029;
1224 -> 1183;
1224 -> 1174;
1224 -> 1191;
1224 -> 1187;
1224 -> 1189;
1224 -> 0;
1224 -> 1027;
1225 -> 1027;
1226 -> 1224;
1226 -> 1225;
1227 -> 1224;
1227 -> 1225;
1228 -> 1224;
1228 -> 1225;
1229 -> 1228;
1229 -> 1224;
1229 -> 1225;
1230 -> 1226;
1230 -> 1225;
1231 -> 1225;
1232 -> 1227;
1232 -> 1225;
1233 -> 1229;
1233 -> 1230;
1233 -> 1231;
1233 -> 1232;
1233 -> 1224;
1233 -> 1225;
1234 -> 1224;
1234 -> 1225;
1235 -> 1234;
1235 -> 1233;
1235 -> 1225;
1236 -> 1224;
1236 -> 1225;
1237 -> 1236;
1237 -> 1235;
1237 -> 1225;
1238 -> 1224;
1238 -> 1225;
1239 -> 1238;
1239 -> 1237;
1239 -> 1225;
1240 -> 1224;
1240 -> 1225;
1241 -> 1240;
1241 -> 1239;
1241 -> 1225;
1242 -> 1224;
1242 -> 1225;
1243 -> 1225;
1244 -> 1242;
1244 -> 1241;
1244 -> 1243;
1244 -> 1225;
1245 -> 1244;
1246 -> 1245;
1246 -> 1242;
1246 -> 1244;
1247 -> 1242;
1247 -> 1241;
1247 -> 1246;
1247 -> 1244;
1248 -> 1244;
1249 -> 1247;
1249 -> 1248;
1250 -> 1242;
1250 -> 1248;
1251 -> 1250;
1251 -> 1241;
1251 -> 1248;
1252 -> 1251;
1252 -> 1241;
1252 -> 1246;
1252 -> 1248;
1253 -> 1244;
1254 -> 1242;
1254 -> 1241;
1254 -> 1246;
1254 -> 1225;
1255 -> 1242;
1255 -> 1254;
1256 -> 1254;
1257 -> 1255;
1257 -> 1256;
1258 -> 1242;
1258 -> 1256;
1259 -> 1258;
1259 -> 1254;
1259 -> 1256;
1260 -> 1254;
1261 -> 1254;
1261 -> 1027;
1262 -> 1254;
1262 -> 1027;
1263 -> 1254;
1263 -> 1027;
1264 -> 1174;
1264 -> 1263;
1264 -> 1254;
1264 -> 1262;
1264 -> 1027;
1265 -> 1027;
1266 -> 1027;
1267 -> 1266;
1267 -> 1027;
1268 -> 1254;
1268 -> 1027;
1269 -> 1262;
1269 -> 1027;
1270 -> 1264;
1270 -> 1027;
1271 -> 1174;
1271 -> 1027;
1272 -> 1174;
1272 -> 1264;
1272 -> 1027;
1273 -> 1031;
1273 -> 1027;
1274 -> 1034;
1274 -> 1027;
1275 -> 1265;
1275 -> 1027;
1276 -> 1266;
1276 -> 1027;
1277 -> 1268;
1277 -> 1269;
1277 -> 1270;
1277 -> 1271;
1277 -> 1272;
1277 -> 1273;
1277 -> 1274;
1277 -> 1275;
1277 -> 1276;
1277 -> 1264;
1277 -> 1262;
1277 -> 1267;
1277 -> 1027;
1278 -> 1027;
1279 -> 1027;
1280 -> 1279;
1280 -> 1254;
1280 -> 1277;
1280 -> 1027;
1281 -> 1254;
1281 -> 1277;
1281 -> 1279;
1281 -> 1280;
1282 -> 1281;
1282 -> 1277;
1282 -> 1280;
1283 -> 1254;
1283 -> 1279;
1283 -> 1277;
1283 -> 1282;
1284 -> 1282;
1285 -> 1283;
1285 -> 1284;
1286 -> 1285;
1286 -> 1283;
1286 -> 1284;
1287 -> 1284;
1288 -> 1285;
1288 -> 1287;
1289 -> 1288;
1289 -> 1284;
1290 -> 1284;
1291 -> 1285;
1291 -> 1290;
1292 -> 1290;
1293 -> 1291;
1293 -> 1292;
1294 -> 1293;
1294 -> 1283;
1294 -> 1292;
1295 -> 1293;
1295 -> 1283;
1295 -> 1294;
1296 -> 1295;
1296 -> 1293;
1296 -> 1294;
1297 -> 1294;
1298 -> 1297;
1298 -> 1293;
1298 -> 1294;
1299 -> 1293;
1299 -> 1295;
1299 -> 1296;
1299 -> 1292;
1300 -> 1299;
1300 -> 1290;
1301 -> 1291;
1301 -> 1295;
1301 -> 1290;
1302 -> 1301;
1302 -> 1284;
1303 -> 1284;
1304 -> 1284;
1305 -> 1286;
1305 -> 1304;
1306 -> 1286;
1306 -> 1304;
1307 -> 1289;
1307 -> 1304;
1308 -> 1302;
1308 -> 1304;
1309 -> 1303;
1309 -> 1304;
1310 -> 1304;
1311 -> 1309;
1311 -> 1310;
1312 -> 1310;
1313 -> 1311;
1313 -> 1312;
1316 -> 1315;
1316 -> 1314;
1317 -> 1314;
1318 -> 1312;
1319 -> 1313;
1319 -> 1318;
1320 -> 1318;
1321 -> 1319;
1321 -> 1320;
1322 -> 1321;
1322 -> 1320;
1323 -> 1319;
1323 -> 1318;
1324 -> 1312;
1325 -> 1324;
1325 -> 1313;
1325 -> 1312;
1326 -> 1313;
1326 -> 1312;
1327 -> 1311;
1327 -> 1310;
1328 -> 1311;
1328 -> 1310;
1329 -> 1311;
1329 -> 1310;
1330 -> 1311;
1330 -> 1310;
1331 -> 1311;
1331 -> 1310;
1332 -> 1311;
1332 -> 1310;
1333 -> 1311;
1333 -> 1310;
1334 -> 1309;
1334 -> 1304;
1335 -> 1309;
1335 -> 1304;
1336 -> 1309;
1336 -> 1304;
1337 -> 1304;
1338 -> 1305;
1338 -> 1337;
1338 -> 1304;
1339 -> 1304;
1340 -> 1306;
1340 -> 1339;
1340 -> 1304;
1341 -> 1305;
1341 -> 1309;
1341 -> 1304;
1342 -> 1306;
1342 -> 1309;
1342 -> 1304;
1343 -> 1305;
1343 -> 1295;
1343 -> 1296;
1343 -> 1298;
1343 -> 1304;
1344 -> 1304;
1345 -> 1344;
1345 -> 1305;
1345 -> 1295;
1345 -> 1296;
1345 -> 1298;
1345 -> 1304;
1346 -> 1309;
1346 -> 1345;
1348 -> 1347;
1349 -> 1305;
1349 -> 1295;
1349 -> 1344;
1349 -> 1296;
1349 -> 1298;
1349 -> 1345;
1350 -> 1308;
1350 -> 1345;
1351 -> 1344;
1351 -> 1345;
1352 -> 1345;
1353 -> 1345;
1354 -> 1346;
1354 -> 1353;
1355 -> 1349;
1355 -> 1353;
1356 -> 1350;
1356 -> 1353;
1357 -> 1351;
1357 -> 1353;
1358 -> 1352;
1358 -> 1353;
1359 -> 1354;
1359 -> 1353;
1360 -> 1355;
1360 -> 1353;
1361 -> 1356;
1361 -> 1353;
1362 -> 1357;
1362 -> 1353;
1363 -> 1353;
1364 -> 1359;
1364 -> 1363;
1365 -> 1360;
1365 -> 1363;
1366 -> 1361;
1366 -> 1363;
1367 -> 1362;
1367 -> 1363;
1368 -> 1358;
1368 -> 1363;
1369 -> 1363;
1370 -> 1368;
1370 -> 1369;
1371 -> 1369;
1372 -> 1370;
1372 -> 1371;
1373 -> 1371;
1374 -> 1372;
1374 -> 1373;
1375 -> 1374;
1375 -> 1373;
1376 -> 1370;
1376 -> 1369;
1377 -> 1368;
1377 -> 1363;
1378 -> 1368;
1378 -> 1363;
1379 -> 1368;
1379 -> 1363;
1380 -> 1368;
1380 -> 1363;
1381 -> 1368;
1381 -> 1363;
1382 -> 1368;
1382 -> 1363;
1383 -> 1368;
1383 -> 1363;
1384 -> 1363;
1385 -> 1384;
1385 -> 1363;
1386 -> 1348;
1386 -> 1363;
1387 -> 1385;
1387 -> 1386;
1387 -> 1363;
1388 -> 1387;
1388 -> 1368;
1388 -> 1363;
1389 -> 1363;
1390 -> 1389;
1390 -> 1363;
1391 -> 1348;
1391 -> 1363;
1392 -> 1390;
1392 -> 1391;
1392 -> 1363;
1393 -> 1392;
1393 -> 1368;
1393 -> 1363;
1394 -> 1368;
1394 -> 1363;
1395 -> 1368;
1395 -> 1363;
1396 -> 1368;
1396 -> 1363;
1397 -> 1368;
1397 -> 1363;
1398 -> 1363;
1399 -> 1364;
1399 -> 1398;
1399 -> 1363;
1400 -> 1363;
1401 -> 1365;
1401 -> 1400;
1401 -> 1363;
1402 -> 1364;
1402 -> 1368;
1402 -> 1363;
1403 -> 1367;
1403 -> 1368;
1403 -> 1363;
1404 -> 1365;
1404 -> 1368;
1404 -> 1363;
1405 -> 1366;
1405 -> 1368;
1405 -> 1363;
1406 -> 1368;
1406 -> 1363;
1407 -> 1363;
1408 -> 1363;
1409 -> 1406;
1409 -> 1408;
1410 -> 1407;
1410 -> 1408;
1411 -> 1408;
1412 -> 1410;
1412 -> 1411;
1413 -> 1411;
1414 -> 1412;
1414 -> 1413;
1415 -> 1413;
1416 -> 1414;
1416 -> 1415;
1417 -> 1415;
1418 -> 1416;
1418 -> 1417;
1419 -> 1418;
1419 -> 1417;
1420 -> 1414;
1420 -> 1413;
1421 -> 1414;
1421 -> 1413;
1422 -> 1412;
1422 -> 1411;
1423 -> 1412;
1423 -> 1411;
1424 -> 1412;
1424 -> 1411;
1425 -> 1410;
1425 -> 1408;
1426 -> 1408;
1427 -> 1409;
1427 -> 1426;
1427 -> 1408;
1428 -> 1409;
1428 -> 1410;
1428 -> 1408;
1429 -> 1407;
1429 -> 1368;
1429 -> 1363;
1430 -> 1368;
1430 -> 1363;
1431 -> 1430;
1431 -> 1375;
1431 -> 1376;
1431 -> 1402;
1431 -> 1403;
1431 -> 1404;
1431 -> 1429;
1431 -> 1381;
1431 -> 1382;
1431 -> 1383;
1431 -> 1388;
1431 -> 1393;
1431 -> 1405;
1431 -> 1395;
1431 -> 1396;
1431 -> 1397;
1431 -> 1387;
1431 -> 1392;
1431 -> 1322;
1431 -> 1323;
1431 -> 1325;
1431 -> 1326;
1431 -> 1327;
1431 -> 1328;
1431 -> 1329;
1431 -> 1330;
1431 -> 1331;
1431 -> 1332;
1431 -> 1333;
1431 -> 1341;
1431 -> 1342;
1431 -> 1336;
1431 -> 1324;
1431 -> 1349;
1431 -> 1419;
1431 -> 1420;
1431 -> 1421;
1431 -> 1422;
1431 -> 1423;
1431 -> 1424;
1431 -> 1428;
1431 -> 1363;
1432 -> 1431;
1432 -> 1368;
1432 -> 1363;
1433 -> 1353;
1434 -> 1357;
1434 -> 1433;
1434 -> 1353;
1435 -> 1352;
1435 -> 1344;
1435 -> 1343;
1435 -> 1345;
1436 -> 1343;
1436 -> 1304;
1437 -> 1436;
1437 -> 1343;
1437 -> 1435;
1437 -> 1431;
1437 -> 1432;
1437 -> 1304;
1438 -> 1437;
1438 -> 1309;
1438 -> 1304;
1439 -> 1307;
1439 -> 1309;
1439 -> 1304;
1440 -> 1303;
1440 -> 1282;
1441 -> 1440;
1441 -> 1281;
1441 -> 1282;
1442 -> 1279;
1442 -> 1282;
1443 -> 1278;
1443 -> 1442;
1443 -> 1282;
1444 -> 1254;
1444 -> 1279;
1444 -> 1437;
1444 -> 1438;
1444 -> 1439;
1444 -> 1280;
1445 -> 1280;
1446 -> 1444;
1446 -> 1445;
1447 -> 1280;
1448 -> 1281;
1448 -> 1277;
1448 -> 1441;
1448 -> 1447;
1449 -> 1448;
1449 -> 1444;
1449 -> 1447;
1450 -> 1446;
1450 -> 1449;
1450 -> 1280;
1451 -> 1444;
1452 -> 1451;
1452 -> 1444;
1453 -> 1444;
1454 -> 1444;
1455 -> 1444;
1456 -> 1444;
1457 -> 1444;
1458 -> 1444;
1459 -> 1444;
1460 -> 1444;
1461 -> 1444;
1462 -> 1444;
1463 -> 1444;
1464 -> 1444;
1465 -> 1444;
1466 -> 1444;
1467 -> 1444;
1468 -> 1280;
1468 -> 1444;
1469 -> 1278;
1469 -> 1443;
1469 -> 1468;
1469 -> 1444;
1470 -> 1444;
1471 -> 1444;
1472 -> 1444;
1472 -> 1467;
1472 -> 1471;
1473 -> 1472;
1473 -> 1444;
1473 -> 1471;
1474 -> 1470;
1474 -> 1473;
1474 -> 1444;
1475 -> 1470;
1475 -> 1444;
1476 -> 1470;
1476 -> 1444;
1477 -> 1470;
1478 -> 1470;
1479 -> 1470;
1480 -> 1470;
1481 -> 1470;
1482 -> 1470;
1483 -> 1470;
1484 -> 1470;
1485 -> 1470;
1486 -> 1470;
1486 -> 1466;
1486 -> 1444;
1487 -> 1470;
1487 -> 1444;
1488 -> 1444;
1489 -> 1444;
1489 -> 1487;
1489 -> 1471;
1490 -> 1489;
1490 -> 1470;
1490 -> 1471;
1491 -> 1470;
1492 -> 1491;
1492 -> 1470;
1493 -> 1470;
1494 -> 1470;
1495 -> 1470;
1496 -> 1470;
1497 -> 1470;
1498 -> 1470;
1499 -> 1444;
1499 -> 1470;
1500 -> 1278;
1500 -> 1443;
1500 -> 1469;
1500 -> 1499;
1500 -> 1470;
1501 -> 1470;
1502 -> 1470;
1502 -> 1498;
1502 -> 1501;
1503 -> 1502;
1503 -> 1470;
1503 -> 1501;
1504 -> 1470;
1505 -> 1028;
1505 -> 1027;
1506 -> 1029;
1506 -> 1470;
1506 -> 1027;
1507 -> 1028;
1507 -> 1470;
1507 -> 1027;
1508 -> 1027;
1510 -> 1174;
1510 -> 1027;
1511 -> 1027;
1512 -> 1505;
1512 -> 1511;
1513 -> 1506;
1513 -> 1511;
1514 -> 1507;
1514 -> 1511;
1515 -> 1510;
1515 -> 1511;
1516 -> 1508;
1516 -> 1511;
1517 -> 1511;
1518 -> 1516;
1518 -> 1517;
1519 -> 1517;
1520 -> 1518;
1520 -> 1519;
1521 -> 1519;
1522 -> 1520;
1522 -> 1521;
1523 -> 1521;
1524 -> 1522;
1524 -> 1523;
1525 -> 1524;
1525 -> 1523;
1526 -> 1522;
1526 -> 1521;
1527 -> 1519;
1528 -> 1527;
1528 -> 1520;
1528 -> 1519;
1529 -> 1520;
1529 -> 1519;
1530 -> 1518;
1530 -> 1517;
1531 -> 1518;
1531 -> 1517;
1532 -> 1518;
1532 -> 1517;
1533 -> 1518;
1533 -> 1517;
1534 -> 1518;
1534 -> 1517;
1535 -> 1518;
1535 -> 1517;
1536 -> 1518;
1536 -> 1517;
1537 -> 1516;
1537 -> 1511;
1538 -> 1516;
1538 -> 1511;
1539 -> 1516;
1539 -> 1511;
1540 -> 1516;
1540 -> 1511;
1541 -> 1516;
1541 -> 1511;
1542 -> 1516;
1542 -> 1511;
1543 -> 1516;
1543 -> 1511;
1544 -> 1516;
1544 -> 1511;
1545 -> 1516;
1545 -> 1511;
1546 -> 1511;
1547 -> 1546;
1547 -> 1516;
1547 -> 1511;
1548 -> 1511;
1549 -> 1548;
1549 -> 1516;
1549 -> 1511;
1550 -> 1511;
1551 -> 1550;
1551 -> 1516;
1551 -> 1511;
1552 -> 1516;
1552 -> 1511;
1553 -> 1516;
1553 -> 1511;
1554 -> 1511;
1555 -> 1512;
1555 -> 1554;
1555 -> 1511;
1556 -> 1511;
1557 -> 1513;
1557 -> 1556;
1557 -> 1511;
1558 -> 1514;
1558 -> 1511;
1559 -> 1515;
1559 -> 1174;
1559 -> 1511;
1560 -> 1512;
1560 -> 1516;
1560 -> 1511;
1561 -> 1513;
1561 -> 1516;
1561 -> 1511;
1562 -> 1511;
1563 -> 1562;
1563 -> 1515;
1563 -> 1174;
1563 -> 1511;
1564 -> 1516;
1564 -> 1511;
1565 -> 1511;
1566 -> 1512;
1566 -> 1565;
1567 -> 1566;
1567 -> 1507;
1567 -> 1565;
1568 -> 1567;
1568 -> 1511;
1569 -> 1514;
1569 -> 1511;
1570 -> 1511;
1571 -> 1511;
1572 -> 1564;
1572 -> 1571;
1573 -> 1568;
1573 -> 1571;
1574 -> 1569;
1574 -> 1571;
1575 -> 1570;
1575 -> 1571;
1576 -> 1571;
1577 -> 1575;
1577 -> 1576;
1578 -> 1576;
1579 -> 1577;
1579 -> 1578;
1580 -> 1578;
1581 -> 1579;
1581 -> 1580;
1582 -> 1581;
1582 -> 1580;
1583 -> 1577;
1583 -> 1576;
1584 -> 1575;
1584 -> 1571;
1585 -> 0;
1585 -> 1575;
1585 -> 1571;
1586 -> 1575;
1586 -> 1571;
1587 -> 1575;
1587 -> 1571;
1588 -> 1575;
1588 -> 1571;
1589 -> 1575;
1589 -> 1571;
1590 -> 1575;
1590 -> 1571;
1591 -> 1571;
1592 -> 1572;
1592 -> 1591;
1592 -> 1571;
1593 -> 1572;
1593 -> 1575;
1593 -> 1571;
1594 -> 1573;
1594 -> 1575;
1594 -> 1571;
1595 -> 1574;
1595 -> 1575;
1595 -> 1571;
1596 -> 1563;
1596 -> 1570;
1596 -> 1582;
1596 -> 1583;
1596 -> 1593;
1596 -> 1585;
1596 -> 1594;
1596 -> 1587;
1596 -> 1588;
1596 -> 1589;
1596 -> 1595;
1596 -> 1525;
1596 -> 1526;
1596 -> 1528;
1596 -> 1529;
1596 -> 1530;
1596 -> 1531;
1596 -> 1532;
1596 -> 1533;
1596 -> 1534;
1596 -> 1535;
1596 -> 1536;
1596 -> 1560;
1596 -> 1538;
1596 -> 1561;
1596 -> 1540;
1596 -> 1541;
1596 -> 1542;
1596 -> 1543;
1596 -> 1544;
1596 -> 1545;
1596 -> 1547;
1596 -> 1549;
1596 -> 1551;
1596 -> 1552;
1596 -> 1553;
1596 -> 1527;
1596 -> 1567;
1596 -> 1546;
1596 -> 1548;
1596 -> 1550;
1596 -> 1511;
1597 -> 1511;
1598 -> 1512;
1598 -> 1597;
1599 -> 1598;
1599 -> 1596;
1599 -> 1597;
1600 -> 1599;
1600 -> 1511;
1601 -> 1600;
1601 -> 1511;
1602 -> 1515;
1602 -> 1511;
1603 -> 1563;
1603 -> 1596;
1603 -> 1511;
1604 -> 1603;
1604 -> 1516;
1604 -> 1511;
1605 -> 1511;
1606 -> 1512;
1606 -> 1605;
1607 -> 1606;
1607 -> 1596;
1607 -> 1605;
1608 -> 1607;
1608 -> 1511;
1609 -> 1608;
1609 -> 1596;
1609 -> 1604;
1609 -> 1511;
1610 -> 1027;
1611 -> 1027;
1612 -> 1254;
1612 -> 1611;
1612 -> 1027;
1613 -> 1612;
1614 -> 1254;
1614 -> 1596;
1614 -> 1604;
1614 -> 1613;
1615 -> 1614;
1615 -> 1027;
1616 -> 1027;
1617 -> 1615;
1617 -> 1616;
1618 -> 1508;
1618 -> 1616;
1619 -> 1616;
1620 -> 1618;
1620 -> 1596;
1620 -> 1619;
1620 -> 1616;
1621 -> 1617;
1621 -> 1618;
1621 -> 1616;
1622 -> 1027;
1623 -> 1027;
1624 -> 1027;
1625 -> 1254;
1625 -> 1596;
1625 -> 1624;
1625 -> 1027;
1626 -> 1027;
1627 -> 1626;
1627 -> 1027;
1628 -> 1508;
1628 -> 1027;
1629 -> 1174;
1629 -> 1027;
1630 -> 1625;
1630 -> 1027;
1631 -> 1254;
1631 -> 1027;
1632 -> 1623;
1632 -> 1027;
1633 -> 1626;
1633 -> 1027;
1634 -> 1027;
1635 -> 1628;
1635 -> 1634;
1636 -> 1629;
1636 -> 1634;
1637 -> 1630;
1637 -> 1634;
1638 -> 1631;
1638 -> 1634;
1639 -> 1632;
1639 -> 1634;
1640 -> 1633;
1640 -> 1634;
1641 -> 1634;
1642 -> 1635;
1642 -> 1641;
1643 -> 1642;
1643 -> 1596;
1643 -> 1604;
1643 -> 1641;
1644 -> 1643;
1644 -> 1634;
1645 -> 1634;
1646 -> 1645;
1646 -> 1636;
1646 -> 1174;
1646 -> 1634;
1647 -> 1644;
1647 -> 1596;
1647 -> 1603;
1647 -> 1646;
1647 -> 1634;
1648 -> 1634;
1649 -> 1644;
1649 -> 1596;
1649 -> 1603;
1649 -> 1648;
1649 -> 1634;
1650 -> 1649;
1650 -> 1634;
1651 -> 1634;
1652 -> 1634;
1653 -> 1652;
1653 -> 1644;
1653 -> 1596;
1653 -> 1603;
1653 -> 1634;
1654 -> 1653;
1655 -> 1654;
1655 -> 1653;
1656 -> 1637;
1656 -> 1655;
1657 -> 1656;
1657 -> 1653;
1658 -> 1656;
1658 -> 1653;
1659 -> 1653;
1660 -> 1653;
1661 -> 1660;
1661 -> 1656;
1661 -> 1653;
1662 -> 1661;
1663 -> 1638;
1663 -> 1596;
1663 -> 1604;
1663 -> 1621;
1663 -> 1662;
1663 -> 1661;
1664 -> 1661;
1665 -> 1638;
1665 -> 1596;
1665 -> 1604;
1665 -> 1621;
1665 -> 1664;
1665 -> 1661;
1666 -> 1651;
1666 -> 1660;
1666 -> 1661;
1667 -> 1665;
1667 -> 1596;
1667 -> 1604;
1667 -> 1621;
1667 -> 1603;
1667 -> 1666;
1667 -> 1661;
1668 -> 1667;
1668 -> 1596;
1668 -> 1603;
1668 -> 1661;
1669 -> 1667;
1669 -> 1596;
1669 -> 1603;
1669 -> 1661;
1670 -> 1638;
1670 -> 1669;
1671 -> 1667;
1671 -> 1669;
1672 -> 1659;
1672 -> 1669;
1673 -> 1669;
1674 -> 1670;
1674 -> 1673;
1675 -> 1671;
1675 -> 1673;
1676 -> 1672;
1676 -> 1673;
1677 -> 1675;
1677 -> 1596;
1677 -> 1603;
1677 -> 1673;
1678 -> 1675;
1678 -> 1596;
1678 -> 1603;
1678 -> 1673;
1679 -> 1674;
1679 -> 1596;
1679 -> 1604;
1679 -> 1621;
1679 -> 1675;
1679 -> 1603;
1679 -> 1673;
1680 -> 1679;
1680 -> 1673;
1681 -> 1673;
1682 -> 1675;
1682 -> 1596;
1682 -> 1603;
1682 -> 1681;
1682 -> 1673;
1683 -> 1679;
1683 -> 1673;
1684 -> 1683;
1684 -> 1660;
1684 -> 1658;
1684 -> 1669;
1685 -> 1667;
1685 -> 1596;
1685 -> 1603;
1685 -> 1660;
1685 -> 1657;
1685 -> 1661;
1686 -> 1651;
1686 -> 1661;
1687 -> 1665;
1687 -> 1596;
1687 -> 1604;
1687 -> 1621;
1687 -> 1603;
1687 -> 1686;
1687 -> 1661;
1688 -> 1687;
1688 -> 1596;
1688 -> 1603;
1688 -> 1661;
1689 -> 1687;
1689 -> 1596;
1689 -> 1603;
1689 -> 1661;
1690 -> 1638;
1690 -> 1689;
1691 -> 1687;
1691 -> 1689;
1692 -> 1689;
1693 -> 1690;
1693 -> 1692;
1694 -> 1691;
1694 -> 1692;
1695 -> 1694;
1695 -> 1596;
1695 -> 1603;
1695 -> 1692;
1696 -> 1694;
1696 -> 1596;
1696 -> 1603;
1696 -> 1692;
1697 -> 1693;
1697 -> 1596;
1697 -> 1604;
1697 -> 1621;
1697 -> 1694;
1697 -> 1603;
1697 -> 1692;
1698 -> 1697;
1698 -> 1692;
1699 -> 1692;
1700 -> 1694;
1700 -> 1596;
1700 -> 1603;
1700 -> 1699;
1700 -> 1692;
1701 -> 1697;
1701 -> 1692;
1702 -> 1701;
1702 -> 1661;
1702 -> 1658;
1702 -> 1689;
1703 -> 1687;
1703 -> 1596;
1703 -> 1603;
1703 -> 1661;
1703 -> 1657;
1704 -> 1657;
1704 -> 1653;
1705 -> 1704;
1705 -> 1657;
1705 -> 1685;
1705 -> 1703;
1705 -> 1596;
1705 -> 1604;
1705 -> 1621;
1705 -> 1603;
1705 -> 1653;
1706 -> 1658;
1706 -> 1653;
1707 -> 1706;
1707 -> 1658;
1707 -> 1684;
1707 -> 1702;
1707 -> 1705;
1707 -> 1653;
1708 -> 1676;
1708 -> 1653;
1709 -> 1705;
1709 -> 1707;
1709 -> 1708;
1709 -> 1653;
1710 -> 1653;
1711 -> 1644;
1711 -> 1652;
1711 -> 1596;
1711 -> 1604;
1711 -> 1621;
1711 -> 1603;
1711 -> 1709;
1711 -> 1653;
1712 -> 1709;
1712 -> 1653;
1713 -> 1635;
1713 -> 1653;
1714 -> 1653;
1715 -> 1712;
1715 -> 1714;
1716 -> 1713;
1716 -> 1714;
1717 -> 1711;
1717 -> 1714;
1718 -> 1714;
1719 -> 1715;
1719 -> 1718;
1719 -> 1714;
1720 -> 1714;
1721 -> 1717;
1721 -> 1720;
1722 -> 1720;
1723 -> 1721;
1723 -> 1711;
1723 -> 1722;
1723 -> 1720;
1724 -> 1714;
1725 -> 1715;
1725 -> 1717;
1725 -> 1714;
1726 -> 1653;
1727 -> 1651;
1727 -> 1656;
1727 -> 1653;
1728 -> 1650;
1728 -> 1634;
1729 -> 1027;
1730 -> 1027;
1731 -> 1278;
1731 -> 1443;
1731 -> 1469;
1731 -> 1500;
1731 -> 1730;
1731 -> 1027;
1732 -> 1254;
1732 -> 1731;
1733 -> 1278;
1733 -> 1731;
1734 -> 1508;
1734 -> 1731;
1735 -> 1254;
1735 -> 1731;
1736 -> 1639;
1736 -> 1731;
1737 -> 1731;
1738 -> 1733;
1738 -> 1737;
1739 -> 1734;
1739 -> 1737;
1740 -> 1735;
1740 -> 1737;
1741 -> 1735;
1741 -> 1737;
1742 -> 1736;
1742 -> 1737;
1743 -> 1737;
1744 -> 1738;
1744 -> 1278;
1744 -> 1443;
1744 -> 1469;
1744 -> 1500;
1744 -> 1743;
1744 -> 1737;
1745 -> 1737;
1746 -> 1739;
1746 -> 1745;
1747 -> 1746;
1747 -> 1711;
1747 -> 1745;
1748 -> 1747;
1748 -> 1737;
1749 -> 1737;
1750 -> 1748;
1750 -> 1749;
1750 -> 1737;
1751 -> 1738;
1751 -> 1737;
1752 -> 1740;
1752 -> 1751;
1752 -> 1711;
1752 -> 1725;
1753 -> 1751;
1754 -> 1752;
1754 -> 1753;
1754 -> 1751;
1755 -> 1740;
1755 -> 1751;
1755 -> 1752;
1755 -> 1754;
1756 -> 1755;
1756 -> 1754;
1757 -> 1741;
1757 -> 1754;
1758 -> 1741;
1758 -> 1755;
1758 -> 1751;
1758 -> 1754;
1759 -> 1742;
1759 -> 1754;
1760 -> 1739;
1760 -> 1754;
1761 -> 1754;
1762 -> 1756;
1762 -> 1761;
1763 -> 1757;
1763 -> 1761;
1764 -> 1758;
1764 -> 1761;
1765 -> 1759;
1765 -> 1761;
1766 -> 1760;
1766 -> 1761;
1767 -> 1764;
1767 -> 1755;
1767 -> 1761;
1768 -> 1764;
1768 -> 1755;
1768 -> 1761;
1769 -> 1764;
1769 -> 1755;
1769 -> 1761;
1770 -> 1761;
1771 -> 1769;
1771 -> 1770;
1772 -> 1771;
1772 -> 1755;
1772 -> 1770;
1773 -> 1772;
1773 -> 1761;
1774 -> 1773;
1774 -> 1755;
1774 -> 1761;
1775 -> 1761;
1776 -> 1761;
1777 -> 1776;
1777 -> 1774;
1777 -> 1761;
1778 -> 1762;
1778 -> 1755;
1778 -> 1776;
1778 -> 1777;
1779 -> 1778;
1779 -> 1777;
1780 -> 1778;
1780 -> 1777;
1781 -> 1777;
1782 -> 1762;
1782 -> 1781;
1783 -> 1782;
1783 -> 1778;
1783 -> 1781;
1784 -> 1783;
1784 -> 1777;
1785 -> 1775;
1785 -> 1777;
1786 -> 1779;
1786 -> 1777;
1787 -> 1777;
1788 -> 1778;
1788 -> 1777;
1789 -> 1784;
1789 -> 1785;
1789 -> 1786;
1789 -> 1787;
1789 -> 1788;
1789 -> 1778;
1789 -> 1779;
1789 -> 1777;
1790 -> 1777;
1791 -> 1777;
1792 -> 1791;
1792 -> 1778;
1792 -> 1777;
1793 -> 1779;
1793 -> 1777;
1794 -> 1793;
1794 -> 1789;
1794 -> 1777;
1795 -> 1780;
1795 -> 1777;
1796 -> 1790;
1796 -> 1777;
1797 -> 1794;
1797 -> 1795;
1797 -> 1796;
1797 -> 1777;
1798 -> 1773;
1798 -> 1776;
1798 -> 1755;
1798 -> 1797;
1798 -> 1777;
1799 -> 1797;
1799 -> 1777;
1800 -> 1766;
1800 -> 1777;
1801 -> 1777;
1802 -> 1799;
1802 -> 1801;
1803 -> 1800;
1803 -> 1801;
1804 -> 1798;
1804 -> 1801;
1805 -> 1801;
1806 -> 1802;
1806 -> 1805;
1806 -> 1801;
1807 -> 1801;
1808 -> 1804;
1808 -> 1807;
1809 -> 1807;
1810 -> 1808;
1810 -> 1798;
1810 -> 1809;
1810 -> 1807;
1811 -> 1801;
1812 -> 1777;
1813 -> 1775;
1813 -> 1778;
1813 -> 1777;
1814 -> 1754;
1815 -> 1765;
1815 -> 1802;
1816 -> 1739;
1816 -> 1802;
1817 -> 1802;
1818 -> 1816;
1818 -> 1802;
1819 -> 1802;
1820 -> 1802;
1821 -> 1802;
1822 -> 1802;
1822 -> 1821;
1823 -> 1822;
1823 -> 1802;
1823 -> 1821;
1824 -> 1817;
1824 -> 1823;
1825 -> 1822;
1825 -> 1823;
1826 -> 1802;
1826 -> 1823;
1827 -> 1823;
1828 -> 1824;
1828 -> 1827;
1829 -> 1825;
1829 -> 1827;
1830 -> 1826;
1830 -> 1827;
1831 -> 1829;
1831 -> 1802;
1831 -> 1827;
1832 -> 1829;
1832 -> 1802;
1832 -> 1827;
1833 -> 1828;
1833 -> 1827;
1834 -> 1827;
1835 -> 1829;
1835 -> 1802;
1835 -> 1834;
1835 -> 1827;
1836 -> 1828;
1836 -> 1821;
1836 -> 1802;
1836 -> 1823;
1837 -> 1802;
1837 -> 1821;
1837 -> 1823;
1838 -> 1815;
1838 -> 1823;
1839 -> 1823;
1840 -> 1837;
1840 -> 1839;
1841 -> 1838;
1841 -> 1839;
1842 -> 1839;
1843 -> 1839;
1844 -> 1841;
1844 -> 1843;
1844 -> 1839;
1845 -> 1844;
1846 -> 1840;
1846 -> 1839;
1847 -> 1839;
1848 -> 1839;
1849 -> 1846;
1849 -> 1848;
1850 -> 1847;
1850 -> 1848;
1851 -> 1848;
1852 -> 1850;
1852 -> 1848;
1853 -> 1850;
1853 -> 1848;
1854 -> 1848;
1855 -> 1849;
1855 -> 1854;
1855 -> 1848;
1856 -> 1849;
1856 -> 1850;
1856 -> 1848;
1857 -> 1850;
1857 -> 1848;
1858 -> 1848;
1859 -> 1848;
1860 -> 1857;
1860 -> 1859;
1861 -> 1858;
1861 -> 1859;
1862 -> 1858;
1862 -> 1859;
1863 -> 1859;
1864 -> 1862;
1864 -> 1859;
1865 -> 1862;
1865 -> 1859;
1866 -> 1862;
1866 -> 1859;
1867 -> 1859;
1868 -> 1860;
1868 -> 1867;
1868 -> 1859;
1869 -> 1859;
1870 -> 1861;
1870 -> 1869;
1870 -> 1859;
1871 -> 1860;
1871 -> 1862;
1871 -> 1859;
1872 -> 1861;
1872 -> 1862;
1872 -> 1859;
1873 -> 1862;
1873 -> 1859;
1874 -> 1859;
1875 -> 1859;
1876 -> 1873;
1876 -> 1875;
1877 -> 1874;
1877 -> 1875;
1878 -> 1875;
1879 -> 1877;
1879 -> 1875;
1880 -> 1877;
1880 -> 1875;
1881 -> 1875;
1882 -> 1876;
1882 -> 1881;
1882 -> 1875;
1883 -> 1876;
1883 -> 1877;
1883 -> 1875;
1884 -> 0;
1884 -> 1877;
1884 -> 1875;
1885 -> 1874;
1885 -> 1862;
1885 -> 1859;
1886 -> 1858;
1886 -> 1850;
1886 -> 1848;
1887 -> 1840;
1887 -> 1839;
1888 -> 1847;
1888 -> 1839;
1889 -> 1845;
1889 -> 1887;
1889 -> 1888;
1889 -> 1839;
1890 -> 1847;
1890 -> 1839;
1891 -> 1890;
1891 -> 1823;
1892 -> 1891;
1892 -> 1821;
1892 -> 1802;
1892 -> 1823;
1893 -> 1840;
1893 -> 1845;
1894 -> 1842;
1894 -> 1845;
1895 -> 1845;
1895 -> 1893;
1895 -> 1894;
1895 -> 1802;
1895 -> 1889;
1895 -> 1850;
1895 -> 1856;
1895 -> 1886;
1895 -> 1862;
1895 -> 1871;
1895 -> 1872;
1895 -> 1885;
1895 -> 1877;
1895 -> 1884;
1895 -> 1883;
1896 -> 1895;
1897 -> 1895;
1898 -> 1895;
1899 -> 1895;
1900 -> 1895;
1901 -> 1895;
1902 -> 1895;
1903 -> 1895;
1904 -> 1895;
1905 -> 1895;
1906 -> 1895;
1907 -> 1895;
1908 -> 1907;
1908 -> 1821;
1908 -> 1802;
1908 -> 1895;
1909 -> 1802;
1909 -> 1836;
1909 -> 1892;
1909 -> 1908;
1909 -> 1895;
1910 -> 1818;
1910 -> 1802;
1911 -> 1802;
1912 -> 1909;
1912 -> 1911;
1912 -> 1802;
1913 -> 1802;
1914 -> 1909;
1914 -> 1913;
1915 -> 1913;
1916 -> 1914;
1916 -> 1909;
1916 -> 1915;
1916 -> 1913;
1917 -> 1802;
1918 -> 1802;
1919 -> 1739;
1919 -> 1909;
1920 -> 1919;
1920 -> 1909;
1921 -> 1909;
1922 -> 1909;
1923 -> 1909;
1924 -> 1909;
1925 -> 1909;
1926 -> 1909;
1927 -> 1920;
1927 -> 1909;
1928 -> 1909;
1929 -> 1909;
1930 -> 1909;
1930 -> 1929;
1931 -> 1929;
1932 -> 1930;
1932 -> 1909;
1932 -> 1931;
1932 -> 1929;
1933 -> 1909;
1934 -> 1909;
1935 -> 1737;
1936 -> 1737;
1937 -> 1739;
1937 -> 1936;
1938 -> 1937;
1938 -> 1909;
1938 -> 1936;
1939 -> 1938;
1939 -> 1737;
1940 -> 1737;
1941 -> 1737;
1942 -> 1939;
1942 -> 1941;
1943 -> 1941;
1944 -> 1942;
1944 -> 1943;
1945 -> 1943;
1946 -> 1944;
1946 -> 1939;
1946 -> 1945;
1946 -> 1943;
1947 -> 1941;
1948 -> 1942;
1948 -> 1939;
1948 -> 1941;
1949 -> 1738;
1949 -> 1737;
1950 -> 1741;
1950 -> 1939;
1950 -> 1949;
1951 -> 1950;
1951 -> 1939;
1951 -> 1949;
1952 -> 1950;
1952 -> 1939;
1952 -> 1949;
1953 -> 1740;
1953 -> 1949;
1953 -> 1939;
1954 -> 1949;
1955 -> 1953;
1955 -> 1954;
1956 -> 1935;
1956 -> 1949;
1957 -> 1740;
1957 -> 1949;
1957 -> 1955;
1958 -> 1949;
1959 -> 1957;
1959 -> 1958;
1960 -> 1950;
1960 -> 1939;
1960 -> 1949;
1961 -> 1960;
1961 -> 1957;
1961 -> 1949;
1962 -> 1949;
1963 -> 1935;
1963 -> 1956;
1963 -> 1962;
1963 -> 1949;
1964 -> 1748;
1964 -> 1949;
1965 -> 1949;
1966 -> 1964;
1966 -> 1965;
1967 -> 1950;
1967 -> 1939;
1967 -> 1965;
1968 -> 1965;
1969 -> 1967;
1969 -> 1957;
1969 -> 1968;
1969 -> 1965;
1970 -> 1966;
1970 -> 1967;
1970 -> 1965;
1971 -> 1949;
1972 -> 1741;
1972 -> 1957;
1972 -> 1970;
1972 -> 1949;
1973 -> 1972;
1973 -> 1957;
1973 -> 1949;
1974 -> 1972;
1974 -> 1957;
1974 -> 1949;
1975 -> 1740;
1975 -> 1949;
1975 -> 1957;
1975 -> 1970;
1976 -> 1975;
1976 -> 1958;
1977 -> 1972;
1977 -> 1957;
1977 -> 1949;
1978 -> 1740;
1978 -> 1977;
1978 -> 1975;
1979 -> 1977;
1980 -> 1978;
1980 -> 1979;
1981 -> 1972;
1981 -> 1978;
1981 -> 1968;
1981 -> 1965;
1982 -> 1978;
1982 -> 1949;
1983 -> 1978;
1983 -> 1949;
1984 -> 1978;
1984 -> 1958;
1985 -> 1978;
1986 -> 1978;
1986 -> 1968;
1986 -> 1965;
1987 -> 1935;
1987 -> 1956;
1987 -> 1737;
1988 -> 1737;
1989 -> 1909;
1989 -> 1988;
1989 -> 1737;
1990 -> 1909;
1990 -> 1978;
1990 -> 1989;
1991 -> 1748;
1991 -> 1990;
1992 -> 1990;
1993 -> 1991;
1993 -> 1992;
1994 -> 1992;
1995 -> 1990;
1996 -> 1993;
1997 -> 1731;
1998 -> 1028;
1998 -> 1978;
1998 -> 1027;
1999 -> 1028;
1999 -> 1978;
1999 -> 1998;
2000 -> 1029;
2000 -> 1978;
2000 -> 1999;
2001 -> 1278;
2001 -> 1999;
2002 -> 1254;
2002 -> 1999;
2003 -> 1999;
2004 -> 2001;
2004 -> 2003;
2005 -> 2002;
2005 -> 2003;
2006 -> 2002;
2006 -> 2003;
2007 -> 2004;
2007 -> 2003;
2008 -> 2006;
2008 -> 1978;
2008 -> 1993;
2008 -> 2007;
2009 -> 2008;
2009 -> 1978;
2009 -> 2007;
2010 -> 2005;
2010 -> 2007;
2010 -> 1978;
2010 -> 1993;
2011 -> 2007;
2012 -> 2010;
2012 -> 2011;
2012 -> 2007;
2013 -> 2005;
2013 -> 2007;
2013 -> 2010;
2013 -> 2012;
2014 -> 2008;
2014 -> 1978;
2014 -> 2012;
2015 -> 2013;
2015 -> 2014;
2015 -> 2012;
2016 -> 2015;
2016 -> 2007;
2017 -> 1999;
2018 -> 1277;
2018 -> 1999;
2019 -> 1174;
2019 -> 1999;
2020 -> 1254;
2020 -> 1999;
2021 -> 1030;
2021 -> 2015;
2021 -> 1999;
2022 -> 1614;
2022 -> 1999;
2023 -> 1508;
2023 -> 1999;
2024 -> 2022;
2024 -> 1999;
2025 -> 1728;
2025 -> 1999;
2026 -> 1999;
2027 -> 1508;
2027 -> 2026;
2028 -> 2026;
2029 -> 2027;
2029 -> 2028;
2030 -> 2029;
2030 -> 2021;
2030 -> 2028;
2031 -> 2030;
2031 -> 2026;
2032 -> 2026;
2033 -> 1999;
2034 -> 2031;
2034 -> 2033;
2035 -> 2033;
2036 -> 2034;
2036 -> 2035;
2037 -> 2035;
2038 -> 2036;
2038 -> 2031;
2038 -> 2037;
2038 -> 2035;
2039 -> 2033;
2040 -> 2034;
2040 -> 2031;
2040 -> 2033;
2041 -> 1999;
2042 -> 1508;
2042 -> 2041;
2043 -> 2041;
2044 -> 2042;
2044 -> 2043;
2045 -> 2044;
2045 -> 2031;
2045 -> 2043;
2046 -> 2041;
2047 -> 1999;
2048 -> 2045;
2048 -> 2047;
2049 -> 2047;
2050 -> 2048;
2050 -> 2049;
2051 -> 2049;
2052 -> 2050;
2052 -> 2045;
2052 -> 2051;
2052 -> 2049;
2053 -> 2047;
2054 -> 2048;
2054 -> 2045;
2054 -> 2047;
2055 -> 1029;
2055 -> 2018;
2055 -> 2019;
2055 -> 2020;
2055 -> 2021;
2055 -> 2024;
2055 -> 2025;
2055 -> 2040;
2055 -> 2054;
2055 -> 2045;
2055 -> 2031;
2055 -> 1174;
2055 -> 2015;
2055 -> 1728;
2055 -> 1277;
2055 -> 1999;
2056 -> 1028;
2056 -> 2055;
2056 -> 1999;
2057 -> 1029;
2057 -> 1999;
2058 -> 1029;
2058 -> 1028;
2058 -> 1999;
2059 -> 1508;
2059 -> 1028;
2059 -> 1999;
2060 -> 1027;
2061 -> 1030;
2061 -> 2055;
2061 -> 2058;
2061 -> 2059;
2061 -> 1027;
2062 -> 1031;
2062 -> 2061;
2062 -> 1027;
2063 -> 2060;
2063 -> 1023;
2064 -> 1025;
2064 -> 2062;
2064 -> 2063;
2064 -> 1023;
2065 -> 1025;
2065 -> 2062;
2065 -> 1023;
2066 -> 1024;
2066 -> 2065;
2066 -> 1023;
2067 -> 1021;
2068 -> 1020;
2068 -> 2065;
2068 -> 1021;
2069 -> 1020;
2069 -> 2065;
2069 -> 1019;
2070 -> 2069;
2070 -> 1004;
2071 -> 972;
2071 -> 1018;
2071 -> 1004;
2072 -> 972;
2072 -> 1004;
2073 -> 1004;
2074 -> 1004;
2075 -> 2073;
2075 -> 2074;
2076 -> 2073;
2076 -> 2074;
2077 -> 2073;
2077 -> 2074;
2078 -> 2072;
2078 -> 2074;
2079 -> 973;
2079 -> 2074;
2080 -> 2074;
2081 -> 2079;
2081 -> 2080;
2082 -> 2081;
2082 -> 2070;
2082 -> 2080;
2083 -> 2080;
2084 -> 2082;
2084 -> 2083;
2086 -> 0;
2087 -> 0;
2088 -> 0;
2091 -> 2085;
2091 -> 2090;
2092 -> 2086;
2092 -> 2090;
2093 -> 2087;
2093 -> 2090;
2094 -> 2088;
2094 -> 2090;
2095 -> 2089;
2095 -> 2090;
2096 -> 2090;
2097 -> 2096;
2097 -> 2090;
2098 -> 2096;
2098 -> 2090;
2099 -> 2096;
2099 -> 2090;
2100 -> 2090;
2101 -> 2092;
2101 -> 2100;
2101 -> 2090;
2102 -> 2093;
2102 -> 0;
2102 -> 2090;
2103 -> 2094;
2103 -> 0;
2103 -> 2090;
2104 -> 2091;
2104 -> 2096;
2104 -> 2090;
2105 -> 2092;
2105 -> 2096;
2105 -> 2090;
2106 -> 2093;
2106 -> 2096;
2106 -> 2090;
2107 -> 2095;
2107 -> 2096;
2107 -> 2090;
2108 -> 2094;
2108 -> 2096;
2108 -> 2090;
2109 -> 2090;
2110 -> 2084;
2110 -> 2083;
2111 -> 2083;
2112 -> 2110;
2112 -> 2111;
2113 -> 2111;
2114 -> 2112;
2114 -> 2113;
2115 -> 2114;
2115 -> 2111;
2116 -> 2111;
2117 -> 2115;
2117 -> 2082;
2117 -> 2116;
2117 -> 2111;
2118 -> 2111;
2119 -> 2112;
2119 -> 2118;
2120 -> 2119;
2120 -> 2082;
2120 -> 2118;
2121 -> 2120;
2121 -> 2118;
2122 -> 2121;
2122 -> 2111;
2123 -> 2117;
2123 -> 2122;
2123 -> 2111;
2124 -> 2109;
2124 -> 2123;
2125 -> 2082;
2125 -> 2124;
2125 -> 2104;
2125 -> 2107;
2125 -> 2105;
2125 -> 2106;
2125 -> 2108;
2125 -> 0;
2125 -> 2080;
2126 -> 2125;
2126 -> 2074;
2127 -> 2078;
2127 -> 2074;
2128 -> 2074;
2129 -> 2127;
2129 -> 2128;
2130 -> 2126;
2130 -> 2128;
2131 -> 2128;
2132 -> 2129;
2132 -> 2071;
2132 -> 2131;
2133 -> 2131;
2134 -> 2130;
2134 -> 2125;
2134 -> 2133;
2135 -> 2133;
2136 -> 2134;
2136 -> 2135;
2137 -> 2136;
2137 -> 2125;
2137 -> 0;
2137 -> 2135;
2138 -> 2137;
2138 -> 2133;
2139 -> 2133;
2140 -> 2138;
2140 -> 2139;
2140 -> 2133;
2141 -> 2140;
2141 -> 2133;
2142 -> 2133;
2143 -> 2141;
2143 -> 2142;
2144 -> 2142;
2145 -> 2143;
2145 -> 2144;
2145 -> 2142;
2146 -> 2133;
2147 -> 2140;
2147 -> 2133;
2148 -> 2147;
2148 -> 2131;
2149 -> 2148;
2149 -> 2131;
2150 -> 0;
2150 -> 2149;
2151 -> 2149;
2152 -> 2150;
2152 -> 2151;
2153 -> 2130;
2153 -> 2125;
2153 -> 2151;
2154 -> 2153;
2154 -> 2125;
2154 -> 2151;
2155 -> 2152;
2155 -> 2151;
2156 -> 2154;
2156 -> 2155;
2156 -> 2151;
2157 -> 2148;
2157 -> 2131;
2158 -> 2129;
2158 -> 2131;
2159 -> 2131;
2160 -> 2157;
2160 -> 2159;
2161 -> 2158;
2161 -> 2159;
2162 -> 2130;
2162 -> 2125;
2162 -> 2159;
2163 -> 2160;
2163 -> 2159;
2164 -> 2159;
2165 -> 2163;
2165 -> 2164;
2166 -> 2162;
2166 -> 2164;
2167 -> 2166;
2167 -> 2125;
2167 -> 2156;
2167 -> 2165;
2167 -> 2164;
2168 -> 2167;
2169 -> 2131;
2170 -> 2156;
2170 -> 2133;
2171 -> 2170;
2171 -> 2142;
2172 -> 2171;
2172 -> 2144;
2172 -> 2142;
2173 -> 0;
2173 -> 2156;
2174 -> 2156;
2175 -> 2173;
2175 -> 2174;
2176 -> 2175;
2177 -> 2130;
2177 -> 2176;
2178 -> 2177;
2178 -> 2109;
2178 -> 2176;
2179 -> 2178;
2180 -> 2175;
2181 -> 0;
2181 -> 2175;
2182 -> 2175;
2183 -> 2181;
2183 -> 2182;
2184 -> 2156;
2184 -> 2131;
2185 -> 2184;
2185 -> 2159;
2186 -> 2185;
2186 -> 2159;
2187 -> 2186;
2187 -> 2164;
2188 -> 2166;
2188 -> 2125;
2188 -> 2156;
2188 -> 2175;
2188 -> 2183;
2188 -> 2187;
2188 -> 2164;
2189 -> 2188;
2190 -> 2183;
2190 -> 2133;
2191 -> 2190;
2191 -> 2142;
2192 -> 2191;
2192 -> 2144;
2192 -> 2142;
2193 -> 2183;
2194 -> 2074;
2195 -> 2074;
2196 -> 2074;
2197 -> 2075;
2197 -> 2196;
2197 -> 2074;
2198 -> 2074;
2199 -> 2079;
2199 -> 2198;
2200 -> 2198;
2201 -> 2199;
2201 -> 2200;
2202 -> 2200;
2203 -> 2201;
2203 -> 2202;
2204 -> 2203;
2204 -> 2125;
2204 -> 2202;
2205 -> 2203;
2205 -> 2125;
2205 -> 2202;
2206 -> 2205;
2206 -> 2200;
2207 -> 2201;
2207 -> 2125;
2207 -> 2200;
2208 -> 2207;
2208 -> 2125;
2208 -> 2156;
2208 -> 2175;
2208 -> 2183;
2208 -> 2200;
2209 -> 2201;
2209 -> 2208;
2209 -> 2200;
2210 -> 2209;
2210 -> 2198;
2211 -> 2210;
2211 -> 2074;
2212 -> 2195;
2212 -> 2074;
2213 -> 2078;
2213 -> 2074;
2214 -> 2212;
2214 -> 2213;
2214 -> 2211;
2214 -> 2071;
2214 -> 2208;
2214 -> 2132;
2214 -> 2074;
2215 -> 2074;
2216 -> 2215;
2217 -> 2215;
2218 -> 2214;
2218 -> 2215;
2219 -> 2215;
2220 -> 2218;
2220 -> 2219;
2221 -> 2219;
2222 -> 2220;
2222 -> 2221;
2222 -> 2219;
2223 -> 2215;
2224 -> 2214;
2224 -> 2215;
2225 -> 2215;
2226 -> 2224;
2226 -> 2214;
2226 -> 2225;
2226 -> 2215;
2227 -> 2215;
2228 -> 2224;
2228 -> 2227;
2229 -> 2227;
2230 -> 2227;
2231 -> 2228;
2231 -> 2230;
2232 -> 2231;
2232 -> 2214;
2232 -> 2230;
2233 -> 2232;
2233 -> 2227;
2234 -> 2227;
2235 -> 2233;
2235 -> 2234;
2236 -> 2234;
2237 -> 2235;
2237 -> 2236;
2238 -> 2237;
2238 -> 2234;
2239 -> 2235;
2239 -> 2234;
2240 -> 2234;
2241 -> 2238;
2241 -> 2227;
2242 -> 2241;
2242 -> 2238;
2243 -> 2229;
2243 -> 2227;
2244 -> 2243;
2244 -> 2215;
2245 -> 2224;
2245 -> 2238;
2245 -> 2215;
2246 -> 2215;
2247 -> 2244;
2247 -> 2246;
2248 -> 2245;
2248 -> 2246;
2249 -> 2225;
2249 -> 2246;
2250 -> 2225;
2250 -> 2246;
2251 -> 2225;
2251 -> 2246;
2252 -> 2225;
2252 -> 2246;
2253 -> 2224;
2253 -> 2246;
2254 -> 2246;
2255 -> 2246;
2256 -> 2253;
2256 -> 2255;
2257 -> 2256;
2257 -> 2238;
2257 -> 2255;
2258 -> 2257;
2258 -> 2246;
2259 -> 2246;
2260 -> 2259;
2260 -> 2246;
2261 -> 2247;
2261 -> 2246;
2262 -> 2249;
2262 -> 2246;
2263 -> 2254;
2263 -> 2246;
2264 -> 2258;
2264 -> 2246;
2265 -> 2252;
2265 -> 2246;
2266 -> 2251;
2266 -> 2246;
2267 -> 2259;
2267 -> 2246;
2268 -> 2246;
2269 -> 2261;
2269 -> 2268;
2270 -> 2262;
2270 -> 2268;
2271 -> 2263;
2271 -> 2268;
2272 -> 2264;
2272 -> 2268;
2273 -> 2265;
2273 -> 2268;
2274 -> 2266;
2274 -> 2268;
2275 -> 2267;
2275 -> 2268;
2276 -> 2253;
2276 -> 2268;
2277 -> 2276;
2277 -> 2268;
2278 -> 2268;
2279 -> 2268;
2280 -> 2268;
2281 -> 2268;
2282 -> 2281;
2282 -> 2269;
2282 -> 2244;
2282 -> 2268;
2283 -> 2268;
2284 -> 2278;
2284 -> 2283;
2284 -> 2268;
2285 -> 0;
2285 -> 2284;
2286 -> 0;
2286 -> 2284;
2287 -> 2286;
2287 -> 2246;
2288 -> 2287;
2288 -> 0;
2288 -> 2246;
2289 -> 2246;
2290 -> 2289;
2290 -> 2246;
2291 -> 2246;
2292 -> 2287;
2292 -> 2246;
2293 -> 2250;
2293 -> 2292;
2294 -> 0;
2294 -> 2293;
2295 -> 2293;
2296 -> 2248;
2296 -> 2293;
2297 -> 2293;
2298 -> 2293;
2299 -> 2253;
2299 -> 2298;
2300 -> 2293;
2301 -> 2294;
2301 -> 2246;
2302 -> 2287;
2302 -> 2246;
2303 -> 2254;
2303 -> 2246;
2304 -> 2249;
2304 -> 2246;
2305 -> 2295;
2305 -> 2246;
2306 -> 2246;
2307 -> 2301;
2307 -> 2306;
2308 -> 2302;
2308 -> 2306;
2309 -> 2303;
2309 -> 2306;
2310 -> 2304;
2310 -> 2306;
2311 -> 2305;
2311 -> 2306;
2312 -> 2253;
2312 -> 2306;
2313 -> 2246;
2314 -> 2246;
2315 -> 2294;
2315 -> 2246;
2316 -> 2296;
2316 -> 2315;
2316 -> 0;
2316 -> 2246;
2317 -> 2252;
2317 -> 2316;
2318 -> 2294;
2318 -> 2317;
2319 -> 2317;
2320 -> 2318;
2320 -> 2319;
2321 -> 2253;
2321 -> 2319;
2322 -> 2320;
2322 -> 2319;
2323 -> 2317;
2324 -> 2254;
2324 -> 2317;
2325 -> 2317;
2326 -> 2324;
2326 -> 2325;
2327 -> 2253;
2327 -> 2325;
2328 -> 2325;
2329 -> 2327;
2329 -> 2328;
2330 -> 2328;
2331 -> 2330;
2331 -> 2325;
2332 -> 2326;
2332 -> 2254;
2332 -> 2325;
2333 -> 2317;
2334 -> 2316;
2335 -> 2296;
2335 -> 2316;
2336 -> 0;
2336 -> 2335;
2337 -> 2336;
2337 -> 0;
2337 -> 2246;
2338 -> 2254;
2338 -> 2246;
2339 -> 2334;
2339 -> 2246;
2340 -> 0;
2340 -> 2339;
2341 -> 2339;
2342 -> 2340;
2342 -> 2341;
2343 -> 2214;
2343 -> 2215;
2344 -> 2214;
2344 -> 2215;
2345 -> 2214;
2345 -> 2215;
2346 -> 2343;
2346 -> 2215;
2347 -> 2215;
2348 -> 2346;
2348 -> 2347;
2349 -> 2345;
2349 -> 2347;
2350 -> 2349;
2350 -> 2316;
2350 -> 2342;
2350 -> 2348;
2350 -> 2347;
2351 -> 2350;
2352 -> 2342;
2352 -> 2215;
2353 -> 2352;
2353 -> 2219;
2354 -> 2353;
2354 -> 2221;
2354 -> 2219;
2355 -> 2214;
2355 -> 2342;
2355 -> 2316;
2355 -> 2336;
2355 -> 0;
2355 -> 2074;
2356 -> 2349;
2356 -> 2355;
2356 -> 2348;
2356 -> 2347;
2357 -> 2356;
2358 -> 2355;
2358 -> 2215;
2359 -> 2358;
2359 -> 2219;
2360 -> 2359;
2360 -> 2221;
2360 -> 2219;
2361 -> 2214;
2361 -> 2215;
2362 -> 2214;
2362 -> 2215;
2363 -> 2215;
2364 -> 2362;
2364 -> 2363;
2365 -> 2363;
2366 -> 2364;
2366 -> 2355;
2366 -> 2365;
2366 -> 2363;
2367 -> 2364;
2367 -> 2366;
2368 -> 2364;
2368 -> 2355;
2368 -> 2366;
2369 -> 2366;
2370 -> 2364;
2370 -> 2369;
2371 -> 2369;
2372 -> 2370;
2372 -> 2371;
2373 -> 2369;
2374 -> 2369;
2375 -> 2370;
2375 -> 2355;
2375 -> 2374;
2376 -> 2375;
2376 -> 2369;
2377 -> 2369;
2378 -> 2370;
2378 -> 2377;
2379 -> 2378;
2379 -> 2369;
2380 -> 2369;
2381 -> 2379;
2381 -> 2380;
2382 -> 2376;
2382 -> 2369;
2383 -> 2382;
2384 -> 2370;
2384 -> 2383;
2385 -> 2383;
2386 -> 0;
2386 -> 2383;
2387 -> 2383;
2388 -> 2385;
2388 -> 2387;
2389 -> 2386;
2389 -> 2387;
2390 -> 2384;
2390 -> 2387;
2391 -> 2389;
2391 -> 2387;
2392 -> 2387;
2393 -> 2390;
2393 -> 2392;
2394 -> 2393;
2394 -> 2355;
2394 -> 2392;
2395 -> 2392;
2396 -> 2394;
2396 -> 2395;
2396 -> 2392;
2397 -> 2394;
2397 -> 2355;
2397 -> 2392;
2398 -> 2397;
2398 -> 2387;
2399 -> 2387;
2400 -> 2398;
2400 -> 2399;
2400 -> 2387;
2401 -> 2391;
2401 -> 2389;
2401 -> 2387;
2402 -> 2401;
2403 -> 2390;
2403 -> 2402;
2404 -> 2402;
2405 -> 2403;
2405 -> 2404;
2406 -> 2404;
2407 -> 2405;
2407 -> 2406;
2408 -> 2406;
2409 -> 2407;
2409 -> 2355;
2409 -> 2408;
2409 -> 2406;
2410 -> 2407;
2410 -> 2355;
2410 -> 2409;
2411 -> 2409;
2412 -> 2410;
2412 -> 2411;
2413 -> 2407;
2413 -> 2411;
2414 -> 2411;
2415 -> 2413;
2415 -> 2355;
2415 -> 2414;
2416 -> 2415;
2416 -> 2411;
2417 -> 2416;
2418 -> 2416;
2419 -> 2418;
2419 -> 2416;
2420 -> 2418;
2420 -> 2416;
2421 -> 2416;
2422 -> 2420;
2422 -> 2421;
2423 -> 2413;
2423 -> 2421;
2424 -> 2421;
2425 -> 2421;
2426 -> 2421;
2427 -> 2426;
2427 -> 2423;
2427 -> 2355;
2427 -> 2421;
2428 -> 2421;
2429 -> 2425;
2429 -> 2428;
2429 -> 2421;
2430 -> 0;
2430 -> 2429;
2431 -> 0;
2431 -> 2429;
2432 -> 2431;
2432 -> 2416;
2433 -> 2416;
2434 -> 2432;
2434 -> 2416;
2435 -> 2434;
2436 -> 2413;
2436 -> 2435;
2437 -> 2435;
2438 -> 2436;
2438 -> 2437;
2439 -> 2437;
2440 -> 2438;
2440 -> 2439;
2441 -> 2437;
2442 -> 2438;
2442 -> 2355;
2442 -> 2437;
2443 -> 2442;
2443 -> 2435;
2444 -> 2435;
2445 -> 2435;
2446 -> 2445;
2446 -> 2443;
2446 -> 2355;
2446 -> 2435;
2447 -> 2444;
2447 -> 2435;
2448 -> 2447;
2448 -> 2434;
2449 -> 2416;
2450 -> 2416;
2451 -> 2416;
2452 -> 2416;
2453 -> 2433;
2453 -> 2452;
2453 -> 2416;
2454 -> 2432;
2454 -> 2416;
2455 -> 2453;
2455 -> 2454;
2455 -> 2416;
2456 -> 0;
2456 -> 2455;
2457 -> 2412;
2457 -> 2416;
2458 -> 2456;
2458 -> 2416;
2459 -> 2416;
2460 -> 2457;
2460 -> 2458;
2460 -> 2459;
2460 -> 2355;
2460 -> 2416;
2461 -> 2417;
2461 -> 2460;
2462 -> 2460;
2463 -> 2461;
2463 -> 2462;
2464 -> 2413;
2464 -> 2462;
2465 -> 2462;
2466 -> 2464;
2466 -> 2465;
2467 -> 2465;
2468 -> 2467;
2468 -> 2462;
2469 -> 2463;
2469 -> 2417;
2469 -> 2462;
2470 -> 2460;
2471 -> 2417;
2471 -> 2416;
2472 -> 2460;
2472 -> 2411;
2473 -> 2409;
2474 -> 2404;
2475 -> 2405;
2475 -> 2460;
2475 -> 2404;
2476 -> 2475;
2476 -> 2402;
2477 -> 2476;
2477 -> 2460;
2477 -> 2402;
2478 -> 2476;
2478 -> 2460;
2478 -> 2402;
2479 -> 2478;
2479 -> 2401;
2480 -> 2401;
2481 -> 2479;
2481 -> 2480;
2481 -> 2401;
2482 -> 2391;
2482 -> 2387;
2483 -> 2482;
2483 -> 2382;
2484 -> 2483;
2484 -> 0;
2484 -> 2382;
2485 -> 2484;
2486 -> 2369;
2487 -> 2370;
2487 -> 2460;
2487 -> 2486;
2488 -> 2487;
2488 -> 2369;
2489 -> 2488;
2489 -> 2369;
2490 -> 2489;
2491 -> 2370;
2491 -> 2490;
2492 -> 2490;
2493 -> 0;
2493 -> 2490;
2494 -> 2490;
2495 -> 2492;
2495 -> 2494;
2496 -> 2493;
2496 -> 2494;
2497 -> 2491;
2497 -> 2494;
2498 -> 2494;
2499 -> 2497;
2499 -> 2498;
2500 -> 2499;
2500 -> 2460;
2500 -> 2498;
2501 -> 2498;
2502 -> 2500;
2502 -> 2501;
2502 -> 2498;
2503 -> 2500;
2503 -> 2460;
2503 -> 2498;
2504 -> 2503;
2504 -> 2494;
2505 -> 2494;
2506 -> 2504;
2506 -> 2505;
2506 -> 2494;
2507 -> 2497;
2507 -> 2496;
2508 -> 2496;
2509 -> 2507;
2509 -> 2460;
2509 -> 2496;
2510 -> 2509;
2510 -> 2496;
2511 -> 2510;
2511 -> 2460;
2511 -> 2496;
2512 -> 2510;
2512 -> 2460;
2512 -> 2496;
2513 -> 2512;
2513 -> 2496;
2514 -> 2496;
2515 -> 2513;
2515 -> 2514;
2515 -> 2496;
2516 -> 2496;
2516 -> 2494;
2517 -> 2516;
2517 -> 2489;
2518 -> 2517;
2518 -> 0;
2518 -> 2489;
2519 -> 2518;
2520 -> 2369;
2521 -> 2370;
2521 -> 2520;
2522 -> 2520;
2523 -> 2520;
2524 -> 2522;
2524 -> 2523;
2525 -> 2522;
2525 -> 2523;
2526 -> 2521;
2526 -> 2523;
2527 -> 2525;
2527 -> 2523;
2528 -> 2523;
2529 -> 2526;
2529 -> 2528;
2530 -> 2529;
2530 -> 2460;
2530 -> 2528;
2531 -> 2528;
2532 -> 2530;
2532 -> 2531;
2532 -> 2528;
2533 -> 2530;
2533 -> 2460;
2533 -> 2528;
2534 -> 2533;
2534 -> 2523;
2535 -> 2523;
2536 -> 2534;
2536 -> 2535;
2536 -> 2523;
2537 -> 2527;
2537 -> 2525;
2537 -> 2523;
2538 -> 2537;
2539 -> 2526;
2539 -> 2538;
2540 -> 2538;
2541 -> 2539;
2541 -> 2540;
2542 -> 2540;
2543 -> 2541;
2543 -> 2542;
2544 -> 2542;
2545 -> 2543;
2545 -> 2460;
2545 -> 2544;
2545 -> 2542;
2546 -> 2540;
2547 -> 2541;
2547 -> 2460;
2547 -> 2540;
2548 -> 2547;
2548 -> 2538;
2549 -> 2548;
2549 -> 2460;
2549 -> 2538;
2550 -> 2548;
2550 -> 2460;
2550 -> 2538;
2551 -> 2550;
2551 -> 2537;
2552 -> 2537;
2553 -> 2551;
2553 -> 2552;
2553 -> 2537;
2554 -> 2527;
2554 -> 2523;
2555 -> 2554;
2555 -> 2369;
2556 -> 2369;
2557 -> 2370;
2557 -> 2556;
2558 -> 2557;
2558 -> 2460;
2558 -> 2556;
2559 -> 2558;
2559 -> 2369;
2560 -> 2369;
2561 -> 2559;
2561 -> 2560;
2562 -> 2485;
2562 -> 2369;
2563 -> 2519;
2563 -> 2369;
2564 -> 2555;
2564 -> 2369;
2565 -> 0;
2565 -> 2369;
2566 -> 2561;
2566 -> 2562;
2566 -> 2563;
2566 -> 2564;
2566 -> 2565;
2566 -> 2460;
2566 -> 2369;
2567 -> 2566;
2567 -> 2366;
2568 -> 2366;
2569 -> 2366;
2570 -> 2364;
2570 -> 2567;
2570 -> 2363;
2571 -> 2570;
2571 -> 2215;
2572 -> 2215;
2573 -> 2361;
2573 -> 2215;
2574 -> 2215;
2575 -> 2573;
2575 -> 2574;
2576 -> 2362;
2576 -> 2574;
2577 -> 2574;
2578 -> 2576;
2578 -> 2577;
2579 -> 2577;
2580 -> 2578;
2580 -> 2567;
2580 -> 2579;
2580 -> 2577;
2581 -> 2574;
2582 -> 2574;
2583 -> 2576;
2583 -> 2582;
2584 -> 2582;
2585 -> 2583;
2585 -> 2567;
2585 -> 2584;
2585 -> 2582;
2586 -> 2583;
2586 -> 2567;
2586 -> 2585;
2587 -> 2585;
2588 -> 2583;
2588 -> 2587;
2589 -> 2588;
2589 -> 2567;
2589 -> 2587;
2590 -> 2587;
2591 -> 2588;
2591 -> 2567;
2591 -> 2590;
2592 -> 2591;
2592 -> 2587;
2593 -> 2587;
2594 -> 2588;
2594 -> 2593;
2595 -> 2593;
2596 -> 2595;
2596 -> 2593;
2597 -> 2593;
2598 -> 2594;
2598 -> 2597;
2599 -> 2598;
2599 -> 2567;
2599 -> 2597;
2600 -> 2597;
2601 -> 2599;
2601 -> 2600;
2601 -> 2597;
2602 -> 2599;
2602 -> 2567;
2602 -> 2597;
2603 -> 2602;
2603 -> 2593;
2604 -> 2593;
2605 -> 2603;
2605 -> 2604;
2605 -> 2593;
2606 -> 2596;
2606 -> 2595;
2606 -> 2593;
2607 -> 2606;
2608 -> 2594;
2608 -> 2607;
2609 -> 2607;
2610 -> 2608;
2610 -> 2567;
2610 -> 2607;
2611 -> 2610;
2611 -> 2607;
2612 -> 2611;
2612 -> 2567;
2612 -> 2607;
2613 -> 2611;
2613 -> 2567;
2613 -> 2607;
2614 -> 2613;
2614 -> 2606;
2615 -> 2606;
2616 -> 2614;
2616 -> 2615;
2616 -> 2606;
2617 -> 2596;
2617 -> 2593;
2618 -> 2617;
2618 -> 2587;
2619 -> 2592;
2619 -> 2618;
2619 -> 2567;
2619 -> 2587;
2620 -> 2587;
2621 -> 2588;
2621 -> 2620;
2622 -> 2620;
2623 -> 2620;
2624 -> 2622;
2624 -> 2623;
2625 -> 2622;
2625 -> 2623;
2626 -> 2621;
2626 -> 2623;
2627 -> 2623;
2628 -> 2626;
2628 -> 2627;
2629 -> 2628;
2629 -> 2619;
2629 -> 2627;
2630 -> 2627;
2631 -> 2629;
2631 -> 2630;
2631 -> 2627;
2632 -> 2629;
2632 -> 2619;
2632 -> 2627;
2633 -> 2632;
2633 -> 2623;
2634 -> 2623;
2635 -> 2633;
2635 -> 2634;
2635 -> 2623;
2636 -> 2626;
2636 -> 2625;
2637 -> 2636;
2637 -> 2619;
2637 -> 2625;
2638 -> 2625;
2639 -> 2636;
2639 -> 2619;
2639 -> 2625;
2640 -> 2639;
2640 -> 2625;
2641 -> 2640;
2641 -> 2619;
2641 -> 2625;
2642 -> 2640;
2642 -> 2619;
2642 -> 2625;
2643 -> 2642;
2643 -> 2625;
2644 -> 2625;
2645 -> 2643;
2645 -> 2644;
2645 -> 2625;
2646 -> 2625;
2646 -> 2587;
2647 -> 2587;
2648 -> 2588;
2648 -> 2647;
2649 -> 2648;
2649 -> 2619;
2649 -> 2647;
2650 -> 2648;
2650 -> 2619;
2650 -> 2647;
2651 -> 2587;
2652 -> 2588;
2652 -> 2651;
2653 -> 2652;
2653 -> 2619;
2653 -> 2651;
2654 -> 2652;
2654 -> 2619;
2654 -> 2651;
2655 -> 2589;
2655 -> 2619;
2655 -> 2646;
2655 -> 2650;
2655 -> 2654;
2655 -> 2587;
2656 -> 2655;
2656 -> 2585;
2657 -> 2585;
2658 -> 2583;
2658 -> 2656;
2658 -> 2582;
2659 -> 2658;
2659 -> 2574;
2660 -> 2659;
2661 -> 2215;
2662 -> 2361;
2662 -> 2215;
2663 -> 2215;
2664 -> 2662;
2664 -> 2663;
2665 -> 2362;
2665 -> 2663;
2666 -> 2665;
2666 -> 2656;
2666 -> 2663;
2667 -> 2663;
2668 -> 2666;
2668 -> 2667;
2668 -> 2663;
2669 -> 2215;
2670 -> 2361;
2670 -> 2215;
2671 -> 2215;
2672 -> 2670;
2672 -> 2671;
2673 -> 2362;
2673 -> 2671;
2674 -> 2671;
2675 -> 2673;
2675 -> 2674;
2676 -> 2674;
2677 -> 2675;
2677 -> 2656;
2677 -> 2676;
2677 -> 2674;
2678 -> 2671;
2679 -> 2671;
2680 -> 2673;
2680 -> 2679;
2681 -> 0;
2681 -> 2679;
2682 -> 2681;
2682 -> 2679;
2683 -> 2679;
2684 -> 2680;
2684 -> 2683;
2685 -> 2684;
2685 -> 2656;
2685 -> 2683;
2686 -> 2683;
2687 -> 2685;
2687 -> 2686;
2687 -> 2683;
2688 -> 2685;
2688 -> 2656;
2688 -> 2683;
2689 -> 2688;
2689 -> 2679;
2690 -> 2679;
2691 -> 2689;
2691 -> 2690;
2691 -> 2679;
2692 -> 2682;
2692 -> 2681;
2692 -> 2679;
2693 -> 2692;
2694 -> 2680;
2694 -> 2693;
2695 -> 2693;
2696 -> 2694;
2696 -> 2695;
2697 -> 2695;
2698 -> 2696;
2698 -> 2697;
2699 -> 2697;
2700 -> 2698;
2700 -> 2656;
2700 -> 2699;
2700 -> 2697;
2701 -> 2695;
2702 -> 2696;
2702 -> 2656;
2702 -> 2695;
2703 -> 2702;
2703 -> 2693;
2704 -> 2703;
2704 -> 2656;
2704 -> 2693;
2705 -> 2703;
2705 -> 2656;
2705 -> 2693;
2706 -> 2705;
2706 -> 2692;
2707 -> 2692;
2708 -> 2706;
2708 -> 2707;
2708 -> 2692;
2709 -> 2682;
2709 -> 2679;
2710 -> 2709;
2710 -> 2671;
2711 -> 2671;
2712 -> 2673;
2712 -> 2656;
2712 -> 2711;
2713 -> 2712;
2713 -> 2671;
2714 -> 2671;
2715 -> 2673;
2715 -> 2656;
2715 -> 2714;
2716 -> 2715;
2716 -> 2671;
2717 -> 2671;
2718 -> 2673;
2718 -> 2656;
2718 -> 2717;
2719 -> 2718;
2719 -> 2671;
2720 -> 2671;
2721 -> 2673;
2721 -> 2656;
2721 -> 2720;
2722 -> 2721;
2722 -> 2671;
2723 -> 2671;
2724 -> 2673;
2724 -> 2656;
2724 -> 2723;
2725 -> 2724;
2725 -> 2671;
2726 -> 2671;
2727 -> 2673;
2727 -> 2656;
2727 -> 2726;
2728 -> 2727;
2728 -> 2671;
2729 -> 2215;
2730 -> 2215;
2731 -> 2362;
2731 -> 2730;
2732 -> 2730;
2733 -> 2731;
2733 -> 2656;
2733 -> 2732;
2734 -> 2733;
2734 -> 2730;
2735 -> 2730;
2736 -> 2731;
2736 -> 2656;
2736 -> 2735;
2737 -> 2736;
2737 -> 2730;
2738 -> 2730;
2739 -> 2731;
2739 -> 2738;
2740 -> 0;
2740 -> 2738;
2741 -> 2740;
2741 -> 2738;
2742 -> 2738;
2743 -> 2739;
2743 -> 2742;
2744 -> 2743;
2744 -> 2656;
2744 -> 2742;
2745 -> 2742;
2746 -> 2744;
2746 -> 2745;
2746 -> 2742;
2747 -> 2744;
2747 -> 2656;
2747 -> 2742;
2748 -> 2747;
2748 -> 2738;
2749 -> 2738;
2750 -> 2748;
2750 -> 2749;
2750 -> 2738;
2751 -> 2741;
2751 -> 2740;
2751 -> 2738;
2752 -> 2751;
2753 -> 2739;
2753 -> 2752;
2754 -> 2752;
2755 -> 2753;
2755 -> 2754;
2756 -> 2754;
2757 -> 2755;
2757 -> 2756;
2758 -> 2756;
2759 -> 2757;
2759 -> 2656;
2759 -> 2758;
2759 -> 2756;
2760 -> 2754;
2761 -> 2755;
2761 -> 2656;
2761 -> 2754;
2762 -> 2761;
2762 -> 2752;
2763 -> 2762;
2763 -> 2656;
2763 -> 2752;
2764 -> 2762;
2764 -> 2656;
2764 -> 2752;
2765 -> 2764;
2765 -> 2751;
2766 -> 2751;
2767 -> 2765;
2767 -> 2766;
2767 -> 2751;
2768 -> 2741;
2768 -> 2738;
2769 -> 2768;
2769 -> 2730;
2770 -> 2769;
2770 -> 2215;
2771 -> 2215;
2772 -> 2362;
2772 -> 2771;
2773 -> 2772;
2773 -> 2656;
2773 -> 2771;
2774 -> 2773;
2774 -> 2215;
2775 -> 2215;
2776 -> 2774;
2776 -> 2775;
2777 -> 2215;
2778 -> 2362;
2778 -> 2777;
2779 -> 2778;
2779 -> 2656;
2779 -> 2777;
2780 -> 2779;
2780 -> 2215;
2781 -> 2215;
2782 -> 2780;
2782 -> 2781;
2783 -> 2215;
2784 -> 2362;
2784 -> 2783;
2785 -> 2784;
2785 -> 2656;
2785 -> 2783;
2786 -> 2785;
2786 -> 2215;
2787 -> 2215;
2788 -> 2786;
2788 -> 2787;
2789 -> 2782;
2789 -> 2788;
2789 -> 2656;
2789 -> 2215;
2790 -> 2215;
2791 -> 2362;
2791 -> 2790;
2792 -> 2790;
2793 -> 2791;
2793 -> 2656;
2793 -> 2792;
2793 -> 2790;
2794 -> 2791;
2794 -> 2656;
2794 -> 2790;
2795 -> 2794;
2795 -> 2215;
2796 -> 2789;
2796 -> 2795;
2796 -> 2656;
2796 -> 2215;
2797 -> 2362;
2797 -> 2656;
2797 -> 2215;
2798 -> 2361;
2798 -> 2215;
2799 -> 2215;
2800 -> 2797;
2800 -> 2799;
2801 -> 2798;
2801 -> 2799;
2802 -> 2800;
2802 -> 2799;
2803 -> 2801;
2803 -> 2799;
2804 -> 2799;
2805 -> 2802;
2805 -> 2804;
2806 -> 2803;
2806 -> 2804;
2807 -> 2804;
2808 -> 2805;
2808 -> 2807;
2809 -> 2808;
2809 -> 2804;
2810 -> 2809;
2810 -> 2656;
2810 -> 2804;
2811 -> 2810;
2812 -> 2799;
2813 -> 2799;
2814 -> 2800;
2814 -> 2813;
2815 -> 2814;
2815 -> 2799;
2816 -> 2815;
2816 -> 2656;
2816 -> 2799;
2817 -> 0;
2817 -> 2816;
2818 -> 2816;
2819 -> 2817;
2819 -> 2818;
2820 -> 2800;
2820 -> 2818;
2821 -> 2819;
2821 -> 2818;
2822 -> 2818;
2823 -> 2820;
2823 -> 2822;
2824 -> 2823;
2824 -> 2818;
2825 -> 0;
2825 -> 2818;
2826 -> 2818;
2827 -> 2824;
2827 -> 2826;
2828 -> 2825;
2828 -> 2826;
2829 -> 2827;
2829 -> 2828;
2829 -> 2826;
2830 -> 2819;
2830 -> 0;
2830 -> 2818;
2831 -> 2818;
2832 -> 2820;
2832 -> 2656;
2832 -> 2831;
2832 -> 2818;
2833 -> 2832;
2834 -> 2820;
2834 -> 2656;
2834 -> 2833;
2835 -> 0;
2835 -> 2833;
2836 -> 2833;
2837 -> 2819;
2837 -> 2832;
2838 -> 2832;
2839 -> 2832;
2840 -> 2832;
2841 -> 2819;
2841 -> 2832;
2842 -> 2820;
2842 -> 2841;
2842 -> 2834;
2842 -> 2832;
2843 -> 2819;
2843 -> 0;
2843 -> 2842;
2844 -> 2843;
2844 -> 2842;
2845 -> 2838;
2845 -> 2844;
2846 -> 2842;
2847 -> 2846;
2848 -> 2847;
2848 -> 2846;
2849 -> 2846;
2849 -> 2842;
2850 -> 2837;
2850 -> 2842;
2851 -> 2842;
2852 -> 2840;
2852 -> 2842;
2853 -> 2845;
2853 -> 2842;
2854 -> 2829;
2854 -> 2842;
2855 -> 2842;
2856 -> 2850;
2856 -> 2855;
2857 -> 2851;
2857 -> 2855;
2858 -> 2851;
2858 -> 2855;
2859 -> 2852;
2859 -> 2855;
2860 -> 2851;
2860 -> 2855;
2861 -> 2853;
2861 -> 2855;
2862 -> 2854;
2862 -> 2855;
2863 -> 2849;
2863 -> 2855;
2864 -> 2855;
2865 -> 2855;
2866 -> 2865;
2866 -> 2855;
2867 -> 2855;
2868 -> 2856;
2868 -> 2867;
2868 -> 2855;
2869 -> 2856;
2869 -> 2868;
2870 -> 2860;
2870 -> 2868;
2871 -> 2868;
2872 -> 2870;
2872 -> 2868;
2873 -> 2868;
2874 -> 2857;
2874 -> 2868;
2875 -> 2858;
2875 -> 2868;
2876 -> 2859;
2876 -> 2868;
2877 -> 2861;
2877 -> 2868;
2878 -> 2862;
2878 -> 2868;
2879 -> 2868;
2880 -> 2872;
2880 -> 2879;
2881 -> 2873;
2881 -> 2879;
2882 -> 2874;
2882 -> 2879;
2883 -> 2875;
2883 -> 2879;
2884 -> 2876;
2884 -> 2879;
2885 -> 2877;
2885 -> 2879;
2886 -> 2878;
2886 -> 2879;
2887 -> 2863;
2887 -> 2879;
2888 -> 2879;
2889 -> 2879;
2890 -> 2887;
2890 -> 2879;
2891 -> 2880;
2891 -> 2879;
2892 -> 2881;
2892 -> 2879;
2893 -> 2879;
2894 -> 2890;
2894 -> 2893;
2895 -> 2891;
2895 -> 2893;
2896 -> 2892;
2896 -> 2893;
2897 -> 2895;
2897 -> 2893;
2898 -> 2893;
2899 -> 2893;
2900 -> 2897;
2900 -> 2899;
2901 -> 2898;
2901 -> 2899;
2902 -> 2894;
2902 -> 2899;
2903 -> 2900;
2903 -> 2899;
2904 -> 2899;
2905 -> 2901;
2905 -> 2899;
2906 -> 2899;
2907 -> 2903;
2907 -> 2906;
2908 -> 2904;
2908 -> 2906;
2909 -> 2905;
2909 -> 2906;
2910 -> 2902;
2910 -> 2906;
2911 -> 2906;
2912 -> 2907;
2912 -> 2906;
2913 -> 2906;
2914 -> 2912;
2914 -> 2913;
2915 -> 2910;
2915 -> 2913;
2916 -> 2913;
2917 -> 2914;
2917 -> 2870;
2917 -> 2913;
2918 -> 2916;
2918 -> 2913;
2919 -> 2915;
2919 -> 2846;
2919 -> 2917;
2919 -> 2918;
2919 -> 2913;
2920 -> 2913;
2921 -> 2920;
2921 -> 2906;
2922 -> 2906;
2923 -> 2921;
2923 -> 2922;
2923 -> 2906;
2924 -> 2923;
2925 -> 2910;
2925 -> 2924;
2926 -> 2925;
2926 -> 2919;
2926 -> 2924;
2927 -> 2926;
2927 -> 2923;
2928 -> 2927;
2928 -> 2919;
2928 -> 2923;
2929 -> 2923;
2930 -> 2927;
2930 -> 2929;
2930 -> 2919;
2930 -> 2923;
2931 -> 2914;
2931 -> 2923;
2932 -> 2923;
2933 -> 2931;
2933 -> 2932;
2934 -> 2930;
2934 -> 2932;
2935 -> 2932;
2936 -> 2932;
2937 -> 2934;
2937 -> 2936;
2938 -> 2936;
2939 -> 2937;
2939 -> 2930;
2939 -> 2938;
2939 -> 2936;
2940 -> 2939;
2941 -> 2937;
2941 -> 2939;
2942 -> 2939;
2943 -> 2937;
2943 -> 2942;
2944 -> 2942;
2945 -> 2943;
2945 -> 2930;
2945 -> 2944;
2946 -> 2945;
2946 -> 2942;
2947 -> 2946;
2947 -> 2939;
2948 -> 2939;
2949 -> 2947;
2949 -> 2948;
2951 -> 2950;
2953 -> 2952;
2954 -> 2940;
2954 -> 2939;
2955 -> 2939;
2956 -> 2939;
2957 -> 2941;
2957 -> 2956;
2958 -> 2941;
2958 -> 2956;
2959 -> 2949;
2959 -> 2956;
2960 -> 2954;
2960 -> 2956;
2961 -> 2955;
2961 -> 2956;
2962 -> 2956;
2963 -> 2961;
2963 -> 2956;
2964 -> 2961;
2964 -> 2956;
2965 -> 2961;
2965 -> 2956;
2966 -> 2961;
2966 -> 2956;
2967 -> 2961;
2967 -> 2956;
2968 -> 2961;
2968 -> 2956;
2971 -> 2970;
2971 -> 2969;
2973 -> 2972;
2973 -> 2969;
2974 -> 2969;
2977 -> 2976;
2977 -> 2975;
2979 -> 2978;
2979 -> 2975;
2980 -> 2975;
2982 -> 0;
2982 -> 2981;
2984 -> 0;
2984 -> 2983;
2985 -> 2984;
2985 -> 2981;
2986 -> 2981;
2988 -> 0;
2988 -> 2987;
2989 -> 0;
2989 -> 2987;
2990 -> 2987;
2991 -> 2980;
2991 -> 2961;
2991 -> 2956;
2992 -> 2956;
2993 -> 2959;
2993 -> 2992;
2993 -> 2956;
2994 -> 2957;
2994 -> 2961;
2994 -> 2956;
2995 -> 2958;
2995 -> 2961;
2995 -> 2956;
2996 -> 2959;
2996 -> 2961;
2996 -> 2956;
2997 -> 2959;
2997 -> 2949;
2997 -> 2956;
2998 -> 2997;
2998 -> 2949;
2999 -> 2960;
2999 -> 2998;
2999 -> 2940;
2999 -> 2949;
2999 -> 2997;
3000 -> 2940;
3000 -> 2999;
3000 -> 2939;
3001 -> 2940;
3001 -> 2999;
3001 -> 2939;
3002 -> 2937;
3002 -> 3001;
3002 -> 2939;
3003 -> 2955;
3003 -> 2939;
3004 -> 2939;
3005 -> 3002;
3005 -> 3003;
3005 -> 3004;
3005 -> 2961;
3005 -> 2994;
3005 -> 2995;
3005 -> 2996;
3005 -> 2966;
3005 -> 2967;
3005 -> 2968;
3005 -> 2991;
3005 -> 3001;
3005 -> 2977;
3005 -> 2979;
3005 -> 2975;
3005 -> 2939;
3006 -> 2937;
3006 -> 3005;
3006 -> 2936;
3007 -> 3006;
3007 -> 2932;
3008 -> 2933;
3008 -> 2919;
3008 -> 2932;
3009 -> 2932;
3010 -> 3008;
3010 -> 3009;
3011 -> 3007;
3011 -> 3009;
3012 -> 3011;
3012 -> 3009;
3013 -> 3010;
3013 -> 3009;
3014 -> 3013;
3014 -> 3005;
3014 -> 3009;
3015 -> 3014;
3016 -> 3014;
3017 -> 3014;
3018 -> 3016;
3018 -> 3017;
3019 -> 3012;
3019 -> 3017;
3020 -> 3017;
3021 -> 3020;
3021 -> 3017;
3022 -> 3017;
3023 -> 3019;
3023 -> 3022;
3024 -> 3022;
3025 -> 3023;
3025 -> 3005;
3025 -> 3024;
3025 -> 3022;
3026 -> 3025;
3027 -> 3023;
3027 -> 3005;
3027 -> 3025;
3028 -> 3026;
3028 -> 3025;
3029 -> 3025;
3030 -> 3028;
3030 -> 3029;
3031 -> 3023;
3031 -> 3029;
3032 -> 3031;
3032 -> 3005;
3032 -> 3029;
3033 -> 3029;
3034 -> 3032;
3034 -> 3033;
3035 -> 3032;
3035 -> 3033;
3036 -> 3034;
3036 -> 3033;
3037 -> 0;
3037 -> 3033;
3038 -> 3036;
3038 -> 3035;
3038 -> 3033;
3039 -> 3031;
3039 -> 3038;
3039 -> 3029;
3040 -> 3039;
3041 -> 3030;
3041 -> 3039;
3042 -> 3039;
3043 -> 3040;
3043 -> 3042;
3044 -> 3041;
3044 -> 3042;
3045 -> 3031;
3045 -> 3042;
3046 -> 3043;
3046 -> 3038;
3046 -> 3042;
3047 -> 3045;
3047 -> 3038;
3047 -> 3046;
3048 -> 3045;
3048 -> 3046;
3049 -> 3043;
3049 -> 3046;
3050 -> 3044;
3050 -> 3046;
3051 -> 3046;
3052 -> 3046;
3053 -> 3047;
3053 -> 3052;
3054 -> 3048;
3054 -> 3052;
3055 -> 3049;
3055 -> 3052;
3056 -> 3050;
3056 -> 3052;
3057 -> 3051;
3057 -> 3052;
3058 -> 3057;
3058 -> 3052;
3059 -> 3057;
3059 -> 3052;
3060 -> 3057;
3060 -> 3052;
3061 -> 3052;
3062 -> 3055;
3062 -> 3061;
3062 -> 3052;
3063 -> 3039;
3064 -> 3051;
3064 -> 3063;
3065 -> 3038;
3065 -> 3063;
3066 -> 3063;
3067 -> 3064;
3067 -> 3066;
3068 -> 3067;
3068 -> 3055;
3068 -> 3056;
3068 -> 3066;
3069 -> 3068;
3069 -> 3063;
3070 -> 3063;
3071 -> 3069;
3071 -> 3063;
3072 -> 3070;
3072 -> 3063;
3073 -> 3065;
3073 -> 3038;
3073 -> 3071;
3073 -> 3072;
3073 -> 3063;
3074 -> 3064;
3074 -> 3069;
3074 -> 3065;
3074 -> 3073;
3075 -> 3029;
3076 -> 3038;
3076 -> 3075;
3077 -> 3076;
3077 -> 3038;
3077 -> 3074;
3077 -> 3073;
3077 -> 3075;
3078 -> 0;
3078 -> 3075;
3079 -> 3076;
3079 -> 3038;
3079 -> 3074;
3079 -> 3075;
3080 -> 3079;
3080 -> 3073;
3081 -> 3079;
3082 -> 3081;
3082 -> 3079;
3083 -> 3080;
3083 -> 3079;
3084 -> 3079;
3085 -> 3083;
3085 -> 3084;
3085 -> 3079;
3086 -> 3080;
3086 -> 3085;
3087 -> 3085;
3088 -> 3086;
3088 -> 3087;
3089 -> 0;
3089 -> 3087;
3090 -> 3089;
3090 -> 3085;
3091 -> 3090;
3091 -> 3085;
3092 -> 3086;
3092 -> 3091;
3093 -> 3079;
3093 -> 3073;
3094 -> 3092;
3094 -> 3079;
3095 -> 3077;
3095 -> 3093;
3095 -> 3094;
3095 -> 3079;
3096 -> 3077;
3096 -> 3075;
3097 -> 3096;
3097 -> 3029;
3098 -> 3031;
3098 -> 3029;
3099 -> 3097;
3099 -> 3029;
3100 -> 3030;
3100 -> 3029;
3101 -> 3029;
3102 -> 3098;
3102 -> 3101;
3103 -> 3099;
3103 -> 3101;
3104 -> 3100;
3104 -> 3101;
3105 -> 3101;
3106 -> 3101;
3107 -> 3101;
3108 -> 3102;
3108 -> 3107;
3109 -> 3107;
3110 -> 3108;
3110 -> 3056;
3110 -> 3109;
3111 -> 3110;
3111 -> 3056;
3111 -> 3109;
3112 -> 3111;
3112 -> 3101;
3113 -> 3101;
3114 -> 3112;
3114 -> 3113;
3115 -> 3101;
3116 -> 3103;
3116 -> 3077;
3116 -> 3101;
3117 -> 3116;
3117 -> 3077;
3117 -> 3095;
3117 -> 3101;
3118 -> 3105;
3118 -> 3117;
3119 -> 3117;
3120 -> 3103;
3120 -> 3117;
3120 -> 3077;
3120 -> 3095;
3120 -> 3056;
3120 -> 3073;
3120 -> 3092;
3121 -> 3120;
3122 -> 3120;
3123 -> 3121;
3123 -> 3122;
3123 -> 3120;
3124 -> 3123;
3124 -> 3120;
3125 -> 3124;
3125 -> 3105;
3125 -> 3118;
3125 -> 3120;
3126 -> 3105;
3126 -> 3118;
3126 -> 3124;
3126 -> 3120;
3127 -> 3120;
3128 -> 3126;
3128 -> 3127;
3128 -> 3120;
3129 -> 3106;
3129 -> 3127;
3129 -> 3120;
3130 -> 3128;
3130 -> 3129;
3130 -> 3120;
3131 -> 3120;
3132 -> 3126;
3132 -> 3131;
3132 -> 3120;
3133 -> 3120;
3133 -> 3124;
3133 -> 3105;
3134 -> 3120;
3135 -> 3121;
3135 -> 3134;
3135 -> 3120;
3136 -> 3029;
3137 -> 3097;
3137 -> 3029;
3138 -> 3025;
3139 -> 3027;
3139 -> 3137;
3139 -> 3138;
3139 -> 3120;
3139 -> 3025;
3140 -> 3139;
3141 -> 3023;
3141 -> 3140;
3142 -> 3140;
3143 -> 3141;
3143 -> 3142;
3144 -> 3142;
3144 -> 3140;
3145 -> 3140;
3146 -> 3141;
3146 -> 3145;
3147 -> 3146;
3147 -> 3139;
3147 -> 3145;
3148 -> 3147;
3148 -> 3140;
3149 -> 3140;
3150 -> 3148;
3150 -> 3149;
3150 -> 3140;
3151 -> 3150;
3151 -> 3140;
3152 -> 3151;
3153 -> 3152;
3153 -> 3139;
3154 -> 3139;
3155 -> 3153;
3155 -> 3154;
3156 -> 3155;
3156 -> 3139;
3156 -> 3154;
3157 -> 3154;
3158 -> 3155;
3158 -> 3139;
3158 -> 3157;
3158 -> 3154;
3159 -> 3158;
3160 -> 3155;
3160 -> 3139;
3160 -> 3158;
3161 -> 3159;
3161 -> 3158;
3162 -> 3158;
3163 -> 3155;
3163 -> 3161;
3163 -> 3154;
3164 -> 3026;
3164 -> 3139;
3165 -> 3139;
3166 -> 3023;
3166 -> 3165;
3167 -> 3165;
3168 -> 3166;
3168 -> 3167;
3169 -> 3167;
3170 -> 3168;
3170 -> 3163;
3170 -> 3169;
3171 -> 3170;
3171 -> 3163;
3171 -> 3169;
3172 -> 3171;
3172 -> 3165;
3173 -> 3165;
3174 -> 3172;
3174 -> 3173;
3175 -> 3173;
3176 -> 3174;
3176 -> 3175;
3177 -> 3176;
3177 -> 3173;
3178 -> 3174;
3178 -> 3173;
3179 -> 3177;
3179 -> 3165;
3180 -> 3139;
3181 -> 3139;
3182 -> 3023;
3182 -> 3181;
3183 -> 3181;
3184 -> 3182;
3184 -> 3183;
3185 -> 3183;
3185 -> 3181;
3186 -> 3181;
3187 -> 3182;
3187 -> 3186;
3188 -> 3187;
3188 -> 3163;
3188 -> 3186;
3189 -> 3181;
3190 -> 3188;
3190 -> 3139;
3191 -> 3023;
3191 -> 3139;
3192 -> 3139;
3193 -> 3191;
3193 -> 3192;
3194 -> 3190;
3194 -> 3192;
3195 -> 3194;
3195 -> 3192;
3196 -> 3193;
3196 -> 3192;
3197 -> 3196;
3197 -> 3163;
3197 -> 3192;
3198 -> 3192;
3199 -> 3195;
3199 -> 3197;
3199 -> 3198;
3199 -> 3192;
3200 -> 3139;
3201 -> 0;
3201 -> 3139;
3202 -> 3139;
3203 -> 3201;
3203 -> 3202;
3204 -> 3023;
3204 -> 3199;
3204 -> 3202;
3205 -> 3204;
3205 -> 3203;
3205 -> 3202;
3206 -> 3205;
3206 -> 3139;
3207 -> 3026;
3207 -> 3199;
3207 -> 3205;
3207 -> 3025;
3208 -> 3023;
3208 -> 3207;
3208 -> 3022;
3209 -> 3208;
3209 -> 3017;
3210 -> 3018;
3210 -> 3017;
3211 -> 3020;
3211 -> 3017;
3212 -> 3209;
3212 -> 3210;
3212 -> 3211;
3212 -> 3207;
3212 -> 3021;
3212 -> 3017;
3213 -> 3212;
3213 -> 3017;
3214 -> 3015;
3214 -> 3014;
3215 -> 3014;
3216 -> 3214;
3216 -> 3215;
3216 -> 3014;
3217 -> 3214;
3217 -> 3009;
3218 -> 2932;
3219 -> 3217;
3219 -> 3218;
3219 -> 2932;
3220 -> 2934;
3220 -> 3219;
3221 -> 2933;
3221 -> 3219;
3222 -> 3219;
3223 -> 3219;
3224 -> 3220;
3224 -> 3223;
3225 -> 3221;
3225 -> 3223;
3226 -> 3222;
3226 -> 3223;
3227 -> 3222;
3227 -> 3223;
3228 -> 3224;
3228 -> 3223;
3229 -> 3225;
3229 -> 3223;
3230 -> 3223;
3231 -> 3226;
3231 -> 3223;
3232 -> 3223;
3233 -> 3228;
3233 -> 3232;
3234 -> 3229;
3234 -> 3232;
3235 -> 3230;
3235 -> 3232;
3236 -> 3231;
3236 -> 3232;
3237 -> 3227;
3237 -> 3232;
3238 -> 3233;
3238 -> 3232;
3239 -> 3234;
3239 -> 3232;
3240 -> 3232;
3241 -> 3234;
3241 -> 2919;
3241 -> 3240;
3241 -> 3232;
3242 -> 3241;
3242 -> 3232;
3243 -> 3236;
3243 -> 3232;
3244 -> 3235;
3244 -> 3232;
3245 -> 3232;
3246 -> 3238;
3246 -> 3245;
3247 -> 3239;
3247 -> 3245;
3248 -> 3242;
3248 -> 3245;
3249 -> 3243;
3249 -> 3245;
3250 -> 3244;
3250 -> 3245;
3251 -> 3237;
3251 -> 3245;
3252 -> 3246;
3252 -> 3245;
3253 -> 3247;
3253 -> 2919;
3253 -> 3245;
3254 -> 3248;
3254 -> 3245;
3255 -> 3247;
3255 -> 2919;
3255 -> 3254;
3256 -> 3248;
3256 -> 3245;
3257 -> 3247;
3257 -> 2919;
3257 -> 3256;
3258 -> 3248;
3258 -> 3245;
3259 -> 3245;
3260 -> 3249;
3260 -> 3245;
3261 -> 3245;
3262 -> 3250;
3262 -> 3245;
3263 -> 3245;
3264 -> 3245;
3265 -> 3252;
3265 -> 3264;
3266 -> 3253;
3266 -> 3264;
3267 -> 3255;
3267 -> 3264;
3268 -> 3257;
3268 -> 3264;
3269 -> 3258;
3269 -> 3264;
3270 -> 3259;
3270 -> 3264;
3271 -> 3260;
3271 -> 3264;
3272 -> 3261;
3272 -> 3264;
3273 -> 3262;
3273 -> 3264;
3274 -> 3263;
3274 -> 3264;
3275 -> 3251;
3275 -> 3264;
3276 -> 3267;
3276 -> 3264;
3277 -> 3268;
3277 -> 3264;
3278 -> 3269;
3278 -> 3264;
3279 -> 3274;
3279 -> 3264;
3280 -> 3264;
3281 -> 3276;
3281 -> 3280;
3282 -> 3277;
3282 -> 3280;
3283 -> 3278;
3283 -> 3280;
3284 -> 3279;
3284 -> 3280;
3285 -> 3275;
3285 -> 3280;
3287 -> 3286;
3288 -> 3286;
3289 -> 3288;
3290 -> 3288;
3292 -> 3291;
3294 -> 3293;
3296 -> 3295;
3298 -> 3297;
3300 -> 3298;
3300 -> 3299;
3301 -> 3300;
3303 -> 3302;
3305 -> 3304;
3307 -> 3306;
3309 -> 3308;
3319 -> 3311;
3319 -> 3310;
3320 -> 3312;
3320 -> 3310;
3321 -> 3313;
3321 -> 3310;
3322 -> 3314;
3322 -> 3310;
3323 -> 3315;
3323 -> 3310;
3324 -> 3316;
3324 -> 3310;
3325 -> 3317;
3325 -> 3310;
3326 -> 3318;
3326 -> 3310;
3327 -> 3310;
3328 -> 3290;
3328 -> 3288;
3329 -> 3328;
3329 -> 3289;
3330 -> 3289;
3332 -> 3331;
3334 -> 0;
3336 -> 3334;
3336 -> 3335;
3337 -> 3335;
3338 -> 3337;
3338 -> 3335;
3339 -> 3336;
3339 -> 3337;
3339 -> 3335;
3340 -> 3335;
3341 -> 0;
3343 -> 3341;
3343 -> 3342;
3344 -> 3342;
3345 -> 3344;
3345 -> 3342;
3346 -> 3343;
3346 -> 3344;
3346 -> 3342;
3347 -> 3342;
3348 -> 0;
3350 -> 3348;
3350 -> 3349;
3351 -> 3349;
3352 -> 3351;
3352 -> 3349;
3353 -> 3350;
3353 -> 3351;
3353 -> 3349;
3354 -> 3349;
3355 -> 0;
3357 -> 3355;
3357 -> 3356;
3358 -> 3356;
3359 -> 3358;
3359 -> 3356;
3360 -> 3357;
3360 -> 3358;
3360 -> 3356;
3361 -> 3356;
3362 -> 0;
3364 -> 3362;
3364 -> 3363;
3365 -> 3363;
3366 -> 3365;
3366 -> 3363;
3367 -> 3364;
3367 -> 3365;
3367 -> 3363;
3368 -> 3363;
3369 -> 0;
3371 -> 3369;
3371 -> 3370;
3372 -> 3370;
3373 -> 3372;
3373 -> 3370;
3374 -> 3371;
3374 -> 3372;
3374 -> 3370;
3375 -> 3370;
3376 -> 0;
3378 -> 3376;
3378 -> 3377;
3379 -> 3377;
3380 -> 3379;
3380 -> 3377;
3381 -> 3378;
3381 -> 3379;
3381 -> 3377;
3382 -> 3377;
3383 -> 0;
3385 -> 3383;
3385 -> 3384;
3386 -> 3384;
3387 -> 3386;
3387 -> 3384;
3388 -> 3385;
3388 -> 3386;
3388 -> 3384;
3389 -> 3384;
3390 -> 3389;
3392 -> 3333;
3392 -> 3390;
3392 -> 3391;
3392 -> 3386;
3392 -> 3387;
3392 -> 3388;
3393 -> 3392;
3395 -> 3394;
3396 -> 3395;
3396 -> 3394;
3397 -> 3395;
3397 -> 3394;
3398 -> 3395;
3398 -> 3394;
3399 -> 3394;
3401 -> 3400;
3402 -> 3330;
3403 -> 3402;
3404 -> 3403;
3405 -> 3404;
3405 -> 3403;
3406 -> 3402;
3406 -> 3330;
3407 -> 3402;
3407 -> 3330;
3408 -> 3330;
3408 -> 3289;
3409 -> 3330;
3409 -> 3289;
3410 -> 3330;
3410 -> 3289;
3411 -> 3329;
3411 -> 3330;
3411 -> 3289;
3412 -> 3288;
3412 -> 3286;
3413 -> 3287;
3413 -> 3288;
3413 -> 3286;
3414 -> 3286;
3415 -> 3284;
3415 -> 3280;
3416 -> 3280;
3417 -> 3415;
3417 -> 3416;
3418 -> 3285;
3418 -> 3416;
3419 -> 3417;
3419 -> 3416;
3420 -> 3416;
3421 -> 3419;
3421 -> 3420;
3422 -> 3418;
3422 -> 3420;
3423 -> 3420;
3424 -> 3422;
3424 -> 3423;
3425 -> 3423;
3426 -> 3424;
3426 -> 3423;
3427 -> 3424;
3427 -> 3423;
3428 -> 3422;
3428 -> 3420;
3429 -> 3422;
3429 -> 3420;
3430 -> 3422;
3430 -> 3420;
3431 -> 3421;
3431 -> 3422;
3431 -> 3420;
3432 -> 3285;
3432 -> 3280;
3433 -> 3285;
3433 -> 3280;
3434 -> 3285;
3434 -> 3280;
3435 -> 3280;
3436 -> 3281;
3436 -> 3435;
3436 -> 3280;
3437 -> 3281;
3437 -> 3285;
3437 -> 3280;
3438 -> 3282;
3438 -> 3285;
3438 -> 3280;
3439 -> 3280;
3440 -> 3282;
3440 -> 3439;
3440 -> 3280;
3441 -> 3283;
3441 -> 3440;
3441 -> 3280;
3442 -> 3441;
3442 -> 3285;
3442 -> 3280;
3443 -> 3275;
3443 -> 3264;
3444 -> 3275;
3444 -> 3264;
3445 -> 3275;
3445 -> 3264;
3446 -> 3275;
3446 -> 3264;
3447 -> 3275;
3447 -> 3264;
3448 -> 3275;
3448 -> 3264;
3449 -> 3264;
3450 -> 3265;
3450 -> 3449;
3450 -> 3264;
3451 -> 3264;
3452 -> 3266;
3452 -> 3451;
3452 -> 3264;
3453 -> 3264;
3454 -> 3273;
3454 -> 3453;
3454 -> 3264;
3455 -> 3266;
3455 -> 3275;
3455 -> 3264;
3456 -> 3265;
3456 -> 3275;
3456 -> 3264;
3457 -> 3270;
3457 -> 3275;
3457 -> 3264;
3458 -> 3271;
3458 -> 3275;
3458 -> 3264;
3459 -> 3272;
3459 -> 3275;
3459 -> 3264;
3460 -> 3273;
3460 -> 3275;
3460 -> 3264;
3461 -> 2932;
3462 -> 3222;
3462 -> 3461;
3462 -> 2932;
3463 -> 3222;
3463 -> 2932;
3464 -> 3463;
3464 -> 2923;
3465 -> 3464;
3466 -> 3465;
3466 -> 2928;
3466 -> 3464;
3467 -> 3465;
3467 -> 2928;
3467 -> 2923;
3468 -> 3467;
3468 -> 2923;
3469 -> 3467;
3469 -> 2909;
3469 -> 2923;
3470 -> 2923;
3471 -> 3463;
3471 -> 3470;
3471 -> 2923;
3472 -> 2909;
3472 -> 3467;
3472 -> 2923;
3473 -> 3463;
3473 -> 2923;
3474 -> 3473;
3474 -> 2893;
3475 -> 2893;
3476 -> 3474;
3476 -> 3475;
3477 -> 3475;
3478 -> 3476;
3478 -> 3477;
3479 -> 0;
3479 -> 3477;
3480 -> 3479;
3480 -> 3475;
3481 -> 3480;
3481 -> 3476;
3481 -> 3475;
3482 -> 3481;
3483 -> 3482;
3483 -> 2879;
3484 -> 2879;
3485 -> 3483;
3485 -> 3484;
3486 -> 2887;
3486 -> 3484;
3487 -> 3484;
3488 -> 3485;
3488 -> 3487;
3488 -> 3484;
3489 -> 3488;
3490 -> 2883;
3490 -> 3489;
3490 -> 2879;
3491 -> 3490;
3492 -> 2879;
3493 -> 3491;
3493 -> 3492;
3493 -> 2879;
3494 -> 3493;
3494 -> 2882;
3494 -> 2879;
3495 -> 2887;
3495 -> 2879;
3496 -> 2879;
3497 -> 2879;
3498 -> 2879;
3499 -> 2881;
3499 -> 3498;
3499 -> 2879;
3500 -> 3499;
3501 -> 2887;
3501 -> 3500;
3502 -> 3501;
3502 -> 3212;
3502 -> 3500;
3503 -> 3502;
3503 -> 3499;
3504 -> 3497;
3504 -> 3499;
3505 -> 3499;
3506 -> 3504;
3506 -> 3505;
3507 -> 3503;
3507 -> 3505;
3508 -> 3505;
3509 -> 3507;
3509 -> 3508;
3510 -> 3509;
3510 -> 3505;
3511 -> 3505;
3512 -> 3511;
3512 -> 3510;
3512 -> 3212;
3512 -> 3505;
3513 -> 3511;
3513 -> 3512;
3514 -> 3510;
3514 -> 3513;
3514 -> 3511;
3515 -> 3506;
3515 -> 3514;
3515 -> 3497;
3515 -> 3513;
3516 -> 3499;
3517 -> 3497;
3517 -> 2879;
3518 -> 3517;
3518 -> 3515;
3518 -> 2879;
3519 -> 3518;
3520 -> 3518;
3520 -> 3519;
3521 -> 3519;
3522 -> 3521;
3522 -> 3518;
3523 -> 3518;
3524 -> 3247;
3524 -> 3518;
3525 -> 2881;
3525 -> 3518;
3526 -> 3518;
3527 -> 3523;
3527 -> 3526;
3528 -> 3524;
3528 -> 3526;
3529 -> 3525;
3529 -> 3526;
3530 -> 3526;
3531 -> 3526;
3532 -> 3530;
3532 -> 3526;
3533 -> 3526;
3534 -> 3528;
3534 -> 2919;
3534 -> 3255;
3534 -> 3257;
3534 -> 3515;
3534 -> 3526;
3535 -> 3534;
3535 -> 3526;
3536 -> 3526;
3537 -> 3534;
3537 -> 3526;
3538 -> 3537;
3538 -> 3534;
3538 -> 3526;
3539 -> 3534;
3540 -> 3538;
3540 -> 3534;
3541 -> 3534;
3542 -> 3540;
3542 -> 3541;
3543 -> 3541;
3544 -> 3542;
3544 -> 3534;
3544 -> 3543;
3544 -> 3541;
3545 -> 3544;
3546 -> 3544;
3547 -> 3542;
3547 -> 3534;
3547 -> 3546;
3548 -> 3547;
3548 -> 3534;
3548 -> 3546;
3549 -> 3548;
3549 -> 3544;
3550 -> 0;
3550 -> 3544;
3551 -> 3549;
3551 -> 3544;
3552 -> 3544;
3553 -> 3551;
3553 -> 3552;
3554 -> 3542;
3554 -> 3552;
3555 -> 3552;
3556 -> 3553;
3556 -> 3555;
3556 -> 3552;
3557 -> 3552;
3558 -> 3552;
3559 -> 3552;
3560 -> 3554;
3560 -> 3559;
3561 -> 3559;
3562 -> 3561;
3562 -> 3552;
3563 -> 3562;
3563 -> 3552;
3564 -> 3562;
3564 -> 3552;
3565 -> 3564;
3566 -> 3553;
3566 -> 3552;
3567 -> 0;
3567 -> 3552;
3568 -> 3557;
3568 -> 3552;
3569 -> 3558;
3569 -> 3552;
3570 -> 3563;
3570 -> 3565;
3570 -> 3566;
3570 -> 3567;
3570 -> 3568;
3570 -> 3569;
3570 -> 3549;
3570 -> 3552;
3571 -> 3570;
3571 -> 3552;
3572 -> 3552;
3573 -> 3571;
3573 -> 3572;
3574 -> 3554;
3574 -> 3572;
3575 -> 3572;
3576 -> 3574;
3576 -> 3570;
3576 -> 3575;
3576 -> 3572;
3577 -> 0;
3577 -> 3576;
3578 -> 3573;
3578 -> 3576;
3579 -> 3578;
3579 -> 3570;
3580 -> 3574;
3580 -> 3578;
3581 -> 3578;
3582 -> 3578;
3583 -> 3579;
3583 -> 3582;
3584 -> 3580;
3584 -> 3582;
3585 -> 3579;
3585 -> 3582;
3586 -> 3581;
3586 -> 3582;
3587 -> 3582;
3588 -> 3586;
3588 -> 3582;
3589 -> 3586;
3589 -> 3582;
3590 -> 3586;
3590 -> 3582;
3591 -> 3582;
3592 -> 3583;
3592 -> 3591;
3592 -> 3582;
3593 -> 3582;
3594 -> 3584;
3594 -> 3593;
3594 -> 3582;
3595 -> 3582;
3596 -> 3585;
3596 -> 3595;
3596 -> 3582;
3597 -> 3584;
3597 -> 3586;
3597 -> 3582;
3598 -> 3583;
3598 -> 3586;
3598 -> 3582;
3599 -> 3585;
3599 -> 3586;
3599 -> 3582;
3600 -> 3578;
3601 -> 3581;
3601 -> 3600;
3602 -> 3601;
3602 -> 3598;
3602 -> 3600;
3603 -> 3602;
3603 -> 3578;
3604 -> 3581;
3604 -> 3578;
3605 -> 3577;
3605 -> 3603;
3605 -> 3604;
3605 -> 3578;
3606 -> 3574;
3606 -> 3570;
3606 -> 3576;
3607 -> 3577;
3607 -> 3576;
3608 -> 3576;
3609 -> 3606;
3609 -> 3607;
3609 -> 3608;
3609 -> 3577;
3609 -> 3570;
3609 -> 3605;
3609 -> 3586;
3609 -> 3597;
3609 -> 3598;
3609 -> 3599;
3609 -> 3576;
3610 -> 3552;
3611 -> 3570;
3611 -> 3552;
3612 -> 3552;
3613 -> 3611;
3613 -> 3612;
3614 -> 3554;
3614 -> 3612;
3615 -> 3612;
3616 -> 3614;
3616 -> 3609;
3616 -> 3615;
3616 -> 3612;
3617 -> 3616;
3618 -> 3614;
3618 -> 3617;
3619 -> 3618;
3619 -> 3609;
3619 -> 3617;
3620 -> 3619;
3620 -> 3616;
3621 -> 3616;
3622 -> 3616;
3623 -> 3620;
3623 -> 3622;
3624 -> 3623;
3624 -> 3616;
3625 -> 3616;
3626 -> 3613;
3626 -> 3616;
3627 -> 3626;
3627 -> 3624;
3627 -> 3616;
3628 -> 3627;
3629 -> 3624;
3629 -> 3628;
3630 -> 3620;
3630 -> 3629;
3631 -> 3614;
3631 -> 3629;
3632 -> 3628;
3632 -> 3629;
3633 -> 0;
3634 -> 3633;
3635 -> 3634;
3637 -> 3636;
3638 -> 3637;
3638 -> 3636;
3639 -> 0;
3639 -> 3637;
3639 -> 3636;
3640 -> 0;
3640 -> 3637;
3640 -> 3636;
3641 -> 3637;
3641 -> 3636;
3642 -> 3637;
3642 -> 3636;
3643 -> 3637;
3643 -> 3636;
3644 -> 3637;
3644 -> 3636;
3645 -> 3414;
3645 -> 3637;
3645 -> 3636;
3646 -> 0;
3646 -> 3637;
3646 -> 3636;
3647 -> 3636;
3648 -> 3627;
3648 -> 3624;
3648 -> 3629;
3649 -> 3629;
3650 -> 3630;
3650 -> 3649;
3651 -> 3631;
3651 -> 3649;
3652 -> 3632;
3652 -> 3649;
3653 -> 3648;
3653 -> 3649;
3654 -> 3649;
3655 -> 3654;
3655 -> 3649;
3656 -> 3649;
3657 -> 3649;
3658 -> 3650;
3658 -> 3649;
3659 -> 3652;
3659 -> 3649;
3660 -> 3654;
3660 -> 3649;
3661 -> 3656;
3661 -> 3649;
3662 -> 3657;
3662 -> 3649;
3663 -> 3649;
3664 -> 3658;
3664 -> 3663;
3665 -> 3659;
3665 -> 3663;
3666 -> 3660;
3666 -> 3663;
3667 -> 3661;
3667 -> 3663;
3668 -> 3662;
3668 -> 3663;
3669 -> 3663;
3670 -> 3664;
3670 -> 3669;
3671 -> 3670;
3671 -> 3663;
3672 -> 3665;
3672 -> 3663;
3673 -> 3671;
3673 -> 3672;
3673 -> 3624;
3673 -> 3663;
3674 -> 3673;
3674 -> 3663;
3675 -> 3663;
3676 -> 3649;
3677 -> 3649;
3678 -> 3649;
3679 -> 3649;
3680 -> 3674;
3680 -> 3679;
3680 -> 3649;
3681 -> 3650;
3681 -> 3680;
3682 -> 3651;
3682 -> 3680;
3683 -> 3652;
3683 -> 3680;
3684 -> 3653;
3684 -> 3680;
3685 -> 3677;
3685 -> 3680;
3686 -> 3680;
3687 -> 3680;
3688 -> 3681;
3688 -> 3687;
3689 -> 3682;
3689 -> 3687;
3690 -> 3683;
3690 -> 3687;
3691 -> 3684;
3691 -> 3687;
3692 -> 3685;
3692 -> 3687;
3693 -> 3686;
3693 -> 3687;
3694 -> 3688;
3694 -> 3687;
3695 -> 3689;
3695 -> 3687;
3696 -> 3690;
3696 -> 3687;
3697 -> 3691;
3697 -> 3687;
3698 -> 3687;
3699 -> 3692;
3699 -> 3687;
3700 -> 3687;
3701 -> 3694;
3701 -> 3700;
3702 -> 3695;
3702 -> 3700;
3703 -> 3696;
3703 -> 3700;
3704 -> 3697;
3704 -> 3700;
3705 -> 3698;
3705 -> 3700;
3706 -> 3699;
3706 -> 3700;
3707 -> 3693;
3707 -> 3700;
3708 -> 3700;
3709 -> 3707;
3709 -> 3708;
3710 -> 3708;
3711 -> 3708;
3712 -> 3709;
3712 -> 3711;
3713 -> 3711;
3714 -> 3712;
3714 -> 3711;
3715 -> 3712;
3715 -> 3711;
3716 -> 3709;
3716 -> 3708;
3717 -> 3709;
3717 -> 3708;
3718 -> 3709;
3718 -> 3708;
3719 -> 3710;
3719 -> 3709;
3719 -> 3708;
3720 -> 3707;
3720 -> 3700;
3721 -> 3707;
3721 -> 3700;
3722 -> 3707;
3722 -> 3700;
3723 -> 3707;
3723 -> 3700;
3724 -> 3707;
3724 -> 3700;
3725 -> 3707;
3725 -> 3700;
3726 -> 3707;
3726 -> 3700;
3727 -> 3707;
3727 -> 3700;
3728 -> 3707;
3728 -> 3700;
3729 -> 3414;
3729 -> 3707;
3729 -> 3700;
3730 -> 3700;
3731 -> 3730;
3731 -> 3707;
3731 -> 3700;
3732 -> 3414;
3732 -> 3707;
3732 -> 3700;
3733 -> 3700;
3734 -> 3733;
3734 -> 3707;
3734 -> 3700;
3735 -> 3707;
3735 -> 3700;
3736 -> 0;
3736 -> 3707;
3736 -> 3700;
3737 -> 3707;
3737 -> 3700;
3738 -> 3707;
3738 -> 3700;
3739 -> 3703;
3739 -> 3624;
3739 -> 3700;
3740 -> 3700;
3741 -> 3702;
3741 -> 3740;
3741 -> 3700;
3742 -> 3700;
3743 -> 3705;
3743 -> 3742;
3743 -> 3700;
3744 -> 3700;
3745 -> 3700;
3746 -> 3700;
3747 -> 3701;
3747 -> 3746;
3748 -> 3747;
3748 -> 3700;
3749 -> 3703;
3749 -> 3700;
3750 -> 3748;
3750 -> 3749;
3750 -> 3673;
3750 -> 3624;
3750 -> 3700;
3751 -> 3703;
3751 -> 3707;
3751 -> 3700;
3752 -> 3702;
3752 -> 3707;
3752 -> 3700;
3753 -> 3700;
3754 -> 3701;
3754 -> 3753;
3755 -> 3754;
3755 -> 3750;
3755 -> 3753;
3756 -> 3755;
3756 -> 3700;
3757 -> 3703;
3757 -> 3700;
3758 -> 3756;
3758 -> 3707;
3758 -> 3700;
3759 -> 3700;
3760 -> 3705;
3760 -> 3759;
3760 -> 3700;
3761 -> 3750;
3761 -> 3707;
3761 -> 3760;
3762 -> 3760;
3763 -> 3700;
3764 -> 3704;
3764 -> 3763;
3764 -> 3700;
3765 -> 3700;
3766 -> 3701;
3766 -> 3765;
3767 -> 3766;
3767 -> 3756;
3767 -> 3765;
3768 -> 3767;
3768 -> 3700;
3769 -> 3700;
3770 -> 3768;
3770 -> 3769;
3771 -> 3769;
3772 -> 3770;
3772 -> 3771;
3773 -> 3772;
3773 -> 3769;
3774 -> 3770;
3774 -> 3769;
3775 -> 3770;
3775 -> 3756;
3775 -> 0;
3775 -> 3769;
3776 -> 3764;
3776 -> 3773;
3776 -> 3700;
3777 -> 3700;
3778 -> 3707;
3778 -> 3777;
3779 -> 0;
3779 -> 3777;
3780 -> 3778;
3780 -> 3758;
3780 -> 0;
3780 -> 3777;
3781 -> 0;
3781 -> 3780;
3782 -> 3781;
3782 -> 3777;
3783 -> 3782;
3783 -> 3700;
3784 -> 3776;
3784 -> 3783;
3784 -> 3700;
3785 -> 0;
3785 -> 3707;
3785 -> 3784;
3786 -> 3745;
3786 -> 3700;
3787 -> 3649;
3788 -> 3675;
3788 -> 3787;
3788 -> 3649;
3789 -> 3686;
3789 -> 3649;
3790 -> 3621;
3790 -> 3789;
3790 -> 3712;
3790 -> 3714;
3790 -> 3715;
3790 -> 3716;
3790 -> 3717;
3790 -> 3719;
3790 -> 3752;
3790 -> 3761;
3790 -> 3758;
3790 -> 3785;
3790 -> 3724;
3790 -> 3725;
3790 -> 3726;
3790 -> 3727;
3790 -> 3728;
3790 -> 3729;
3790 -> 3731;
3790 -> 3732;
3790 -> 3734;
3790 -> 3735;
3790 -> 3736;
3790 -> 3737;
3790 -> 3738;
3790 -> 3751;
3790 -> 3405;
3790 -> 3406;
3790 -> 3407;
3790 -> 3408;
3790 -> 3409;
3790 -> 3411;
3790 -> 3413;
3790 -> 3730;
3790 -> 3733;
3790 -> 0;
3790 -> 3624;
3790 -> 3756;
3790 -> 3629;
3791 -> 3616;
3792 -> 0;
3792 -> 3616;
3793 -> 3791;
3793 -> 3792;
3793 -> 3621;
3793 -> 3790;
3793 -> 3616;
3794 -> 3793;
3794 -> 3791;
3795 -> 3794;
3795 -> 3793;
3795 -> 3791;
3796 -> 3621;
3796 -> 3795;
3796 -> 3616;
3797 -> 3616;
3798 -> 3625;
3798 -> 3797;
3798 -> 3616;
3799 -> 3614;
3799 -> 3796;
3799 -> 3616;
3800 -> 3795;
3800 -> 3616;
3801 -> 3616;
3802 -> 3616;
3803 -> 3799;
3803 -> 3802;
3803 -> 3616;
3804 -> 3795;
3804 -> 3803;
3805 -> 3803;
3806 -> 3804;
3806 -> 3805;
3807 -> 3620;
3807 -> 3805;
3808 -> 3805;
3809 -> 3807;
3809 -> 3799;
3809 -> 3808;
3809 -> 3805;
3810 -> 3805;
3811 -> 3807;
3811 -> 3799;
3811 -> 3810;
3812 -> 3811;
3812 -> 3805;
3813 -> 3806;
3813 -> 3799;
3813 -> 3805;
3814 -> 3813;
3815 -> 3814;
3816 -> 3814;
3817 -> 3814;
3817 -> 3816;
3818 -> 3817;
3818 -> 3799;
3818 -> 3816;
3819 -> 3818;
3819 -> 3814;
3820 -> 3814;
3821 -> 3807;
3821 -> 3799;
3821 -> 3819;
3821 -> 3820;
3821 -> 3814;
3822 -> 3821;
3822 -> 3814;
3823 -> 3814;
3824 -> 3814;
3824 -> 3823;
3825 -> 3824;
3825 -> 3821;
3825 -> 3823;
3826 -> 3825;
3826 -> 3814;
3827 -> 3812;
3827 -> 3826;
3827 -> 3814;
3828 -> 3803;
3829 -> 3552;
3830 -> 3544;
3831 -> 3534;
3832 -> 3534;
3833 -> 3534;
3834 -> 3833;
3834 -> 3534;
3835 -> 3539;
3835 -> 3534;
3836 -> 3832;
3836 -> 3534;
3837 -> 3540;
3837 -> 3821;
3837 -> 3835;
3837 -> 3836;
3837 -> 3534;
3838 -> 3539;
3838 -> 3837;
3839 -> 3833;
3839 -> 3837;
3840 -> 3540;
3840 -> 3837;
3840 -> 3838;
3840 -> 3839;
3840 -> 3834;
3841 -> 3837;
3841 -> 3840;
3842 -> 3841;
3843 -> 3841;
3844 -> 3842;
3844 -> 3843;
3844 -> 3841;
3845 -> 3844;
3846 -> 3842;
3846 -> 3844;
3847 -> 3534;
3848 -> 3846;
3848 -> 3847;
3848 -> 3534;
3849 -> 3846;
3849 -> 3840;
3850 -> 3849;
3850 -> 3841;
3850 -> 3840;
3851 -> 3840;
3852 -> 3849;
3852 -> 3841;
3852 -> 3840;
3852 -> 3851;
3853 -> 3852;
3854 -> 3850;
3854 -> 3853;
3854 -> 3852;
3855 -> 3850;
3855 -> 3852;
3856 -> 3852;
3857 -> 3855;
3857 -> 3856;
3858 -> 3856;
3859 -> 3857;
3859 -> 3858;
3859 -> 3856;
3860 -> 3856;
3861 -> 3856;
3862 -> 3861;
3863 -> 3856;
3863 -> 3862;
3864 -> 3862;
3865 -> 3863;
3865 -> 3864;
3866 -> 3865;
3866 -> 3862;
3867 -> 3862;
3868 -> 3863;
3868 -> 3867;
3869 -> 3867;
3870 -> 3868;
3870 -> 3869;
3871 -> 3870;
3871 -> 3841;
3871 -> 3840;
3871 -> 3869;
3872 -> 3871;
3872 -> 3867;
3873 -> 3867;
3874 -> 3872;
3875 -> 3872;
3876 -> 3874;
3876 -> 3875;
3876 -> 3872;
3877 -> 3874;
3877 -> 3876;
3878 -> 3877;
3878 -> 3862;
3879 -> 3862;
3880 -> 3878;
3880 -> 3879;
3881 -> 3879;
3881 -> 3862;
3882 -> 3862;
3883 -> 3866;
3883 -> 3862;
3884 -> 3861;
3884 -> 3883;
3884 -> 3857;
3884 -> 3856;
3884 -> 3841;
3884 -> 3840;
3885 -> 3884;
3886 -> 3884;
3887 -> 3884;
3888 -> 3884;
3889 -> 3884;
3890 -> 3884;
3891 -> 3856;
3891 -> 3884;
3892 -> 3884;
3893 -> 3891;
3893 -> 3884;
3893 -> 3892;
3894 -> 3893;
3894 -> 3884;
3895 -> 3884;
3896 -> 3894;
3897 -> 3896;
3897 -> 3894;
3898 -> 3894;
3899 -> 3894;
3900 -> 3896;
3900 -> 3894;
3901 -> 3898;
3901 -> 3894;
3902 -> 3899;
3902 -> 3894;
3903 -> 3894;
3904 -> 3894;
3905 -> 3894;
3906 -> 3904;
3906 -> 3894;
3907 -> 3906;
3907 -> 3894;
3908 -> 3907;
3908 -> 3904;
3909 -> 3904;
3910 -> 3904;
3911 -> 3904;
3912 -> 3904;
3913 -> 3904;
3914 -> 3904;
3914 -> 3894;
3915 -> 3904;
3916 -> 3904;
3917 -> 3904;
3918 -> 3904;
3919 -> 3904;
3920 -> 0;
3920 -> 3904;
3921 -> 0;
3921 -> 3904;
3922 -> 3904;
3922 -> 3921;
3923 -> 3922;
3923 -> 3904;
3923 -> 3921;
3924 -> 3918;
3924 -> 3904;
3925 -> 3894;
3926 -> 3903;
3926 -> 3925;
3926 -> 3894;
3927 -> 3923;
3928 -> 3927;
3928 -> 3923;
3929 -> 3923;
3930 -> 3923;
3931 -> 3927;
3931 -> 3923;
3932 -> 3929;
3932 -> 3923;
3933 -> 3930;
3933 -> 3923;
3934 -> 3923;
3935 -> 3923;
3936 -> 3923;
3937 -> 3936;
3937 -> 3923;
3938 -> 3937;
3938 -> 3923;
3939 -> 3923;
3940 -> 3923;
3941 -> 3923;
3942 -> 3923;
3943 -> 3923;
3944 -> 3923;
3945 -> 3923;
3946 -> 3923;
3947 -> 3923;
3948 -> 3923;
3949 -> 3923;
3950 -> 0;
3950 -> 3923;
3951 -> 3948;
3951 -> 3923;
3952 -> 3923;
3953 -> 3934;
3953 -> 3952;
3953 -> 3923;
3954 -> 3923;
3954 -> 3927;
3955 -> 3927;
3956 -> 3927;
3957 -> 3954;
3957 -> 3956;
3958 -> 3954;
3958 -> 3956;
3959 -> 3954;
3959 -> 3956;
3960 -> 3954;
3960 -> 3956;
3961 -> 3955;
3961 -> 3956;
3962 -> 3955;
3962 -> 3956;
3963 -> 3954;
3963 -> 3956;
3964 -> 3955;
3964 -> 3956;
3965 -> 3957;
3965 -> 3956;
3966 -> 3958;
3966 -> 3956;
3967 -> 3959;
3967 -> 3956;
3968 -> 3960;
3968 -> 3956;
3969 -> 3962;
3969 -> 3956;
3970 -> 3963;
3970 -> 3956;
3971 -> 3956;
3972 -> 3965;
3972 -> 3971;
3973 -> 3966;
3973 -> 3971;
3974 -> 3967;
3974 -> 3971;
3975 -> 3968;
3975 -> 3971;
3976 -> 3969;
3976 -> 3971;
3977 -> 3970;
3977 -> 3971;
3978 -> 3964;
3978 -> 3971;
3979 -> 3964;
3979 -> 3971;
3980 -> 3964;
3980 -> 3971;
3981 -> 3964;
3981 -> 3971;
3982 -> 3964;
3982 -> 3971;
3983 -> 3974;
3983 -> 3923;
3983 -> 3971;
3984 -> 3971;
3985 -> 3973;
3985 -> 3984;
3985 -> 3971;
3986 -> 3971;
3987 -> 3976;
3987 -> 3986;
3987 -> 3971;
3988 -> 3971;
3989 -> 3971;
3990 -> 3972;
3990 -> 3974;
3990 -> 3927;
3990 -> 3923;
3990 -> 3971;
3991 -> 3990;
3991 -> 3976;
3992 -> 3976;
3993 -> 3991;
3993 -> 3964;
3993 -> 3976;
3994 -> 3964;
3994 -> 3993;
3994 -> 3976;
3995 -> 3990;
3995 -> 3976;
3996 -> 3964;
3996 -> 3993;
3996 -> 3990;
3996 -> 3976;
3997 -> 3964;
3997 -> 3993;
3997 -> 3976;
3998 -> 3990;
3998 -> 3976;
3999 -> 3975;
3999 -> 3990;
3999 -> 3971;
4000 -> 0;
4000 -> 3971;
4001 -> 3989;
4001 -> 3971;
4002 -> 3964;
4002 -> 3956;
4003 -> 3964;
4003 -> 3956;
4004 -> 3956;
4005 -> 3961;
4005 -> 3927;
4005 -> 4004;
4005 -> 3956;
4006 -> 3962;
4006 -> 3964;
4006 -> 3956;
4007 -> 3961;
4007 -> 3964;
4007 -> 3956;
4008 -> 3997;
4008 -> 3964;
4008 -> 3956;
4009 -> 3884;
4009 -> 3955;
4009 -> 3990;
4009 -> 3964;
4009 -> 3973;
4009 -> 3993;
4009 -> 3999;
4009 -> 3974;
4009 -> 4006;
4009 -> 4008;
4009 -> 4007;
4009 -> 3971;
4009 -> 3923;
4009 -> 3927;
4010 -> 4009;
4011 -> 4009;
4012 -> 4009;
4013 -> 4009;
4014 -> 4011;
4014 -> 4009;
4015 -> 4012;
4015 -> 4009;
4016 -> 4009;
4017 -> 4009;
4018 -> 4009;
4019 -> 4018;
4019 -> 4009;
4020 -> 4019;
4020 -> 4009;
4021 -> 4009;
4022 -> 4009;
4023 -> 4009;
4024 -> 4009;
4025 -> 4009;
4026 -> 4009;
4027 -> 4009;
4028 -> 4009;
4029 -> 4009;
4030 -> 4009;
4031 -> 4009;
4032 -> 0;
4032 -> 4009;
4033 -> 4030;
4033 -> 4009;
4034 -> 4009;
4035 -> 4009;
4036 -> 4009;
4037 -> 4009;
4038 -> 4016;
4038 -> 4037;
4038 -> 4009;
4039 -> 4011;
4039 -> 4009;
4040 -> 4011;
4041 -> 4040;
4041 -> 4011;
4042 -> 4041;
4042 -> 4011;
4043 -> 4011;
4044 -> 4011;
4045 -> 4011;
4046 -> 4011;
4047 -> 4011;
4048 -> 4011;
4048 -> 4009;
4049 -> 4011;
4050 -> 4011;
4051 -> 4011;
4052 -> 4011;
4053 -> 4011;
4054 -> 0;
4054 -> 4011;
4055 -> 4052;
4055 -> 4011;
4056 -> 4011;
4057 -> 4011;
4058 -> 4011;
4059 -> 4011;
4060 -> 4011;
4061 -> 4011;
4062 -> 4011;
4063 -> 4060;
4063 -> 4011;
4064 -> 4011;
4065 -> 4011;
4066 -> 4011;
4067 -> 4011;
4068 -> 4064;
4068 -> 4067;
4068 -> 4011;
4069 -> 4060;
4069 -> 4011;
4070 -> 4060;
4070 -> 4011;
4071 -> 4060;
4072 -> 4071;
4072 -> 4060;
4073 -> 4072;
4073 -> 4060;
4074 -> 4060;
4075 -> 4060;
4076 -> 4060;
4077 -> 4060;
4078 -> 4060;
4079 -> 4060;
4079 -> 4011;
4080 -> 4060;
4081 -> 4060;
4082 -> 4060;
4083 -> 4060;
4084 -> 4060;
4085 -> 0;
4085 -> 4060;
4086 -> 4083;
4086 -> 4060;
4087 -> 4060;
4088 -> 4060;
4089 -> 4060;
4090 -> 4060;
4091 -> 4060;
4092 -> 4060;
4093 -> 4060;
4094 -> 4060;
4095 -> 4060;
4096 -> 4060;
4097 -> 4060;
4098 -> 4094;
4098 -> 4097;
4098 -> 4060;
4099 -> 4060;
4100 -> 4099;
4100 -> 4060;
4101 -> 4100;
4101 -> 4060;
4102 -> 4060;
4103 -> 3884;
4104 -> 3895;
4104 -> 4103;
4104 -> 3884;
4105 -> 4060;
4106 -> 4060;
4107 -> 4106;
4107 -> 4060;
4108 -> 4060;
4109 -> 4060;
4110 -> 4060;
4111 -> 4060;
4111 -> 4110;
4112 -> 4111;
4112 -> 4060;
4112 -> 4110;
4113 -> 4112;
4113 -> 4060;
4114 -> 4107;
4114 -> 4113;
4114 -> 4060;
4115 -> 4060;
4115 -> 4114;
4116 -> 4114;
4117 -> 4115;
4117 -> 4116;
4118 -> 4060;
4118 -> 4116;
4119 -> 4116;
4120 -> 4117;
4120 -> 4119;
4121 -> 4120;
4121 -> 4116;
4122 -> 4121;
4122 -> 0;
4122 -> 4116;
4123 -> 4116;
4124 -> 4117;
4124 -> 4123;
4125 -> 4123;
4126 -> 4124;
4126 -> 4125;
4127 -> 4126;
4127 -> 4060;
4127 -> 4125;
4128 -> 4127;
4128 -> 4123;
4129 -> 4123;
4130 -> 4128;
4130 -> 4129;
4130 -> 4123;
4131 -> 4130;
4131 -> 4123;
4132 -> 4131;
4133 -> 4128;
4133 -> 4132;
4134 -> 4132;
4135 -> 4133;
4135 -> 4134;
4136 -> 4135;
4136 -> 4132;
4137 -> 4132;
4138 -> 4136;
4138 -> 4137;
4139 -> 4138;
4139 -> 4116;
4140 -> 4118;
4140 -> 4116;
4141 -> 4139;
4141 -> 4140;
4141 -> 4116;
4142 -> 4116;
4143 -> 4117;
4143 -> 4142;
4144 -> 4142;
4145 -> 4143;
4145 -> 4144;
4146 -> 4145;
4146 -> 4060;
4146 -> 4144;
4147 -> 4144;
4148 -> 4146;
4148 -> 4147;
4149 -> 4147;
4149 -> 4144;
4150 -> 4144;
4151 -> 4146;
4151 -> 4150;
4152 -> 4151;
4152 -> 4144;
4153 -> 4152;
4153 -> 4142;
4154 -> 4153;
4154 -> 4116;
4155 -> 4116;
4156 -> 4154;
4156 -> 4155;
4157 -> 4156;
4157 -> 4060;
4157 -> 4155;
4158 -> 4116;
4159 -> 4116;
4160 -> 4118;
4160 -> 4159;
4161 -> 4160;
4161 -> 4116;
4162 -> 4118;
4162 -> 4116;
4163 -> 4116;
4164 -> 4118;
4164 -> 4060;
4164 -> 4163;
4164 -> 4116;
4165 -> 4118;
4165 -> 4060;
4165 -> 4164;
4166 -> 4164;
4167 -> 4118;
4167 -> 4165;
4167 -> 4121;
4167 -> 4116;
4168 -> 4117;
4168 -> 4116;
4169 -> 4116;
4170 -> 4118;
4170 -> 4167;
4171 -> 4167;
4172 -> 4118;
4172 -> 4167;
4172 -> 4170;
4172 -> 4171;
4173 -> 4118;
4173 -> 4167;
4173 -> 4170;
4173 -> 0;
4174 -> 4114;
4175 -> 4114;
4176 -> 4060;
4176 -> 4167;
4176 -> 4175;
4177 -> 4176;
4177 -> 4167;
4177 -> 4170;
4177 -> 0;
4177 -> 4175;
4178 -> 4177;
4178 -> 4114;
4179 -> 4170;
4180 -> 4170;
4181 -> 4178;
4181 -> 0;
4182 -> 4178;
4183 -> 4178;
4183 -> 4182;
4184 -> 4182;
4185 -> 4183;
4185 -> 4184;
4186 -> 4185;
4186 -> 4170;
4186 -> 4184;
4187 -> 4186;
4187 -> 4182;
4188 -> 4182;
4189 -> 4187;
4189 -> 4188;
4189 -> 4182;
4190 -> 4189;
4190 -> 4182;
4191 -> 4190;
4192 -> 4187;
4192 -> 4191;
4193 -> 4191;
4194 -> 4192;
4194 -> 4193;
4195 -> 4194;
4195 -> 4191;
4196 -> 4191;
4197 -> 4195;
4197 -> 4196;
4198 -> 4197;
4198 -> 4178;
4199 -> 4178;
4200 -> 4178;
4201 -> 4178;
4201 -> 4200;
4202 -> 4200;
4203 -> 4201;
4203 -> 4202;
4204 -> 4203;
4204 -> 4170;
4204 -> 4202;
4205 -> 4202;
4206 -> 4204;
4206 -> 4205;
4207 -> 4205;
4207 -> 4202;
4208 -> 4202;
4209 -> 4204;
4209 -> 4208;
4210 -> 4209;
4210 -> 4202;
4211 -> 4210;
4211 -> 4200;
4212 -> 4211;
4212 -> 4178;
4213 -> 4178;
4214 -> 4212;
4214 -> 4213;
4215 -> 4214;
4215 -> 4170;
4215 -> 4213;
4216 -> 4178;
4217 -> 4178;
4218 -> 4217;
4218 -> 4178;
4219 -> 4178;
4220 -> 4178;
4221 -> 4178;
4221 -> 0;
4222 -> 4178;
4223 -> 4178;
4224 -> 4217;
4224 -> 0;
4225 -> 4217;
4226 -> 4217;
4226 -> 4225;
4227 -> 4225;
4228 -> 4226;
4228 -> 4227;
4229 -> 4228;
4229 -> 4178;
4229 -> 4227;
4230 -> 4229;
4230 -> 4225;
4231 -> 4225;
4232 -> 4230;
4232 -> 4231;
4232 -> 4225;
4233 -> 4232;
4233 -> 4225;
4234 -> 4233;
4235 -> 4230;
4235 -> 4234;
4236 -> 4234;
4237 -> 4235;
4237 -> 4236;
4238 -> 4237;
4238 -> 4234;
4239 -> 4234;
4240 -> 4238;
4240 -> 4239;
4241 -> 4240;
4241 -> 4217;
4242 -> 4217;
4243 -> 4217;
4244 -> 4217;
4244 -> 4243;
4245 -> 4243;
4246 -> 4244;
4246 -> 4245;
4247 -> 4246;
4247 -> 4178;
4247 -> 4245;
4248 -> 4245;
4249 -> 4247;
4249 -> 4248;
4250 -> 4248;
4250 -> 4245;
4251 -> 4245;
4252 -> 4247;
4252 -> 4251;
4253 -> 4252;
4253 -> 4245;
4254 -> 4253;
4254 -> 4243;
4255 -> 4254;
4255 -> 4217;
4256 -> 4217;
4257 -> 4255;
4257 -> 4256;
4258 -> 4257;
4258 -> 4178;
4258 -> 4256;
4259 -> 4217;
4260 -> 4217;
4261 -> 4217;
4262 -> 4217;
4262 -> 0;
4263 -> 4217;
4264 -> 4217;
4265 -> 4228;
4265 -> 4217;
4265 -> 4227;
4266 -> 4265;
4266 -> 4225;
4267 -> 4266;
4267 -> 4231;
4267 -> 4225;
4268 -> 4267;
4268 -> 4225;
4269 -> 4268;
4270 -> 4266;
4270 -> 4269;
4271 -> 4269;
4272 -> 4270;
4272 -> 4271;
4273 -> 4272;
4273 -> 4269;
4274 -> 4269;
4275 -> 4273;
4275 -> 4274;
4276 -> 4275;
4276 -> 4217;
4277 -> 4246;
4277 -> 4217;
4277 -> 4245;
4278 -> 4277;
4278 -> 4248;
4279 -> 4277;
4279 -> 4251;
4280 -> 4279;
4280 -> 4245;
4281 -> 4280;
4281 -> 4243;
4282 -> 4281;
4282 -> 4217;
4283 -> 4282;
4283 -> 4256;
4284 -> 4283;
4284 -> 4217;
4284 -> 4256;
4285 -> 3852;
4286 -> 3849;
4286 -> 4217;
4286 -> 3852;
4287 -> 3852;
4288 -> 3840;
4289 -> 4286;
4290 -> 3840;
4291 -> 4286;
4291 -> 4290;
4291 -> 3840;
4292 -> 4286;
4293 -> 4286;
4294 -> 4286;
4295 -> 4286;
4296 -> 4286;
4296 -> 4295;
4297 -> 4295;
4298 -> 4296;
4298 -> 4297;
4299 -> 4298;
4299 -> 4286;
4299 -> 4297;
4300 -> 4299;
4300 -> 4295;
4301 -> 4295;
4302 -> 4300;
4303 -> 4300;
4304 -> 4302;
4304 -> 4303;
4304 -> 4300;
4305 -> 4302;
4305 -> 4304;
4306 -> 4305;
4306 -> 4286;
4307 -> 4286;
4308 -> 4306;
4308 -> 4307;
4309 -> 4307;
4309 -> 4286;
4310 -> 4286;
4311 -> 4309;
4312 -> 4306;
4312 -> 4311;
4313 -> 4312;
4313 -> 4309;
4314 -> 4309;
4315 -> 4309;
4316 -> 4306;
4316 -> 4315;
4317 -> 4315;
4318 -> 4315;
4319 -> 4316;
4319 -> 4309;
4320 -> 4319;
4320 -> 4307;
4321 -> 4313;
4322 -> 4313;
4323 -> 4313;
4324 -> 4313;
4325 -> 4313;
4326 -> 4313;
4327 -> 4313;
4328 -> 4313;
4329 -> 4313;
4330 -> 4313;
4331 -> 4313;
4332 -> 4313;
4333 -> 4313;
4334 -> 4313;
4335 -> 4334;
4335 -> 4313;
4336 -> 4335;
4336 -> 4313;
4337 -> 4313;
4338 -> 4313;
4339 -> 4313;
4340 -> 4313;
4341 -> 4313;
4342 -> 4313;
4343 -> 4313;
4344 -> 4313;
4345 -> 4313;
4346 -> 4313;
4347 -> 4313;
4348 -> 0;
4348 -> 4313;
4349 -> 4346;
4349 -> 4313;
4350 -> 4313;
4351 -> 4332;
4351 -> 4350;
4351 -> 4313;
4352 -> 4313;
4353 -> 4327;
4353 -> 4352;
4353 -> 4313;
4354 -> 4313;
4355 -> 4313;
4356 -> 4286;
4357 -> 4313;
4358 -> 4286;
4359 -> 4313;
4359 -> 4358;
4359 -> 4286;
4360 -> 3526;
4361 -> 3528;
4361 -> 4313;
4362 -> 4313;
4363 -> 4361;
4363 -> 4362;
4364 -> 4313;
4364 -> 4362;
4365 -> 4363;
4365 -> 3534;
4365 -> 4362;
4366 -> 4364;
4366 -> 4362;
4367 -> 4362;
4368 -> 4366;
4368 -> 4367;
4369 -> 4367;
4369 -> 4362;
4370 -> 4362;
4371 -> 4362;
4372 -> 4371;
4372 -> 4362;
4373 -> 4362;
4374 -> 4366;
4374 -> 4373;
4375 -> 4373;
4376 -> 4374;
4376 -> 4375;
4377 -> 4375;
4377 -> 4373;
4378 -> 4377;
4378 -> 4362;
4379 -> 0;
4379 -> 4362;
4380 -> 4362;
4381 -> 4379;
4381 -> 4380;
4382 -> 4366;
4382 -> 4380;
4383 -> 4380;
4384 -> 4382;
4384 -> 4383;
4385 -> 4384;
4385 -> 4313;
4385 -> 4383;
4386 -> 4384;
4386 -> 4313;
4386 -> 4385;
4387 -> 4385;
4388 -> 4384;
4388 -> 4387;
4389 -> 4388;
4389 -> 4387;
4390 -> 4387;
4391 -> 4387;
4392 -> 4389;
4392 -> 4391;
4393 -> 4390;
4393 -> 4391;
4394 -> 4391;
4395 -> 4393;
4395 -> 4394;
4396 -> 4394;
4397 -> 4395;
4397 -> 4396;
4398 -> 4393;
4398 -> 4391;
4399 -> 4392;
4399 -> 4391;
4400 -> 4392;
4400 -> 4393;
4400 -> 4391;
4401 -> 4390;
4401 -> 4385;
4402 -> 4385;
4403 -> 4386;
4403 -> 4401;
4403 -> 4402;
4403 -> 4400;
4403 -> 4313;
4403 -> 4385;
4404 -> 4384;
4404 -> 4403;
4404 -> 4383;
4405 -> 4404;
4405 -> 4380;
4406 -> 4381;
4406 -> 4380;
4407 -> 4380;
4408 -> 4405;
4408 -> 4407;
4409 -> 4406;
4409 -> 4407;
4410 -> 4408;
4410 -> 4407;
4411 -> 4409;
4411 -> 4407;
4412 -> 4407;
4413 -> 4410;
4413 -> 4412;
4414 -> 4411;
4414 -> 4412;
4415 -> 4414;
4415 -> 4412;
4416 -> 4413;
4416 -> 4412;
4417 -> 4412;
4418 -> 4415;
4418 -> 4412;
4419 -> 4412;
4420 -> 4416;
4420 -> 4419;
4421 -> 4417;
4421 -> 4419;
4422 -> 4417;
4422 -> 4419;
4423 -> 4418;
4423 -> 4419;
4424 -> 4417;
4424 -> 4419;
4425 -> 4419;
4426 -> 4420;
4426 -> 4425;
4426 -> 4419;
4427 -> 4424;
4427 -> 4419;
4428 -> 4427;
4429 -> 4421;
4429 -> 4428;
4429 -> 4427;
4430 -> 4427;
4431 -> 4422;
4431 -> 4430;
4431 -> 4427;
4432 -> 4420;
4432 -> 4419;
4433 -> 4419;
4435 -> 4434;
4437 -> 4436;
4438 -> 4433;
4438 -> 4419;
4439 -> 4423;
4439 -> 4419;
4440 -> 4421;
4440 -> 4419;
4441 -> 4422;
4441 -> 4419;
4442 -> 4419;
4443 -> 4419;
4444 -> 4438;
4444 -> 4443;
4445 -> 4439;
4445 -> 4443;
4446 -> 4440;
4446 -> 4443;
4447 -> 4441;
4447 -> 4443;
4448 -> 4442;
4448 -> 4443;
4449 -> 4444;
4449 -> 4443;
4450 -> 4445;
4450 -> 4443;
4451 -> 4443;
4452 -> 4446;
4452 -> 4443;
4453 -> 4447;
4453 -> 4443;
4454 -> 4443;
4455 -> 4454;
4455 -> 4449;
4455 -> 4450;
4455 -> 4451;
4455 -> 4452;
4455 -> 4453;
4455 -> 4433;
4455 -> 0;
4455 -> 4443;
4456 -> 4454;
4456 -> 4443;
4457 -> 4454;
4457 -> 4443;
4458 -> 4445;
4458 -> 4455;
4458 -> 4443;
4459 -> 0;
4459 -> 4443;
4460 -> 4458;
4460 -> 4454;
4460 -> 4443;
4461 -> 4442;
4461 -> 4419;
4462 -> 4419;
4463 -> 4461;
4463 -> 4462;
4464 -> 4420;
4464 -> 4462;
4465 -> 4463;
4465 -> 4462;
4466 -> 4462;
4467 -> 4465;
4467 -> 4466;
4468 -> 4464;
4468 -> 4466;
4469 -> 4468;
4469 -> 4466;
4470 -> 4466;
4471 -> 4469;
4471 -> 4470;
4472 -> 4467;
4472 -> 4470;
4473 -> 4472;
4473 -> 4455;
4473 -> 4470;
4474 -> 4472;
4474 -> 4455;
4474 -> 4456;
4474 -> 4460;
4474 -> 4457;
4474 -> 4470;
4475 -> 0;
4475 -> 4470;
4476 -> 4472;
4476 -> 4455;
4476 -> 4456;
4476 -> 4460;
4476 -> 4457;
4476 -> 0;
4476 -> 4470;
4477 -> 4476;
4478 -> 4471;
4478 -> 4477;
4479 -> 4477;
4480 -> 4478;
4480 -> 4479;
4481 -> 4480;
4481 -> 4403;
4481 -> 4479;
4482 -> 4477;
4483 -> 4481;
4483 -> 4482;
4485 -> 4484;
4486 -> 4477;
4487 -> 4483;
4487 -> 4486;
4488 -> 4487;
4488 -> 4486;
4489 -> 4486;
4490 -> 4488;
4490 -> 4489;
4491 -> 4489;
4492 -> 4490;
4492 -> 4491;
4493 -> 4492;
4494 -> 4493;
4495 -> 4492;
4496 -> 4492;
4497 -> 4492;
4497 -> 4489;
4498 -> 4497;
4498 -> 4476;
4499 -> 4498;
4499 -> 4476;
4500 -> 4476;
4501 -> 4499;
4501 -> 4500;
4502 -> 4472;
4502 -> 4500;
4503 -> 4501;
4503 -> 4500;
4504 -> 4500;
4505 -> 4503;
4505 -> 4504;
4505 -> 4500;
4506 -> 4502;
4506 -> 4455;
4506 -> 4456;
4506 -> 4460;
4506 -> 4457;
4506 -> 0;
4506 -> 4500;
4507 -> 4500;
4508 -> 4503;
4508 -> 4507;
4509 -> 4507;
4510 -> 4508;
4510 -> 4492;
4510 -> 4509;
4511 -> 4509;
4511 -> 4500;
4512 -> 4511;
4512 -> 4476;
4513 -> 4472;
4513 -> 4455;
4513 -> 4456;
4513 -> 4460;
4513 -> 4457;
4513 -> 4512;
4514 -> 4512;
4515 -> 4513;
4515 -> 4514;
4516 -> 4513;
4516 -> 4514;
4517 -> 4516;
4517 -> 4513;
4517 -> 4514;
4518 -> 4514;
4519 -> 4515;
4519 -> 4514;
4520 -> 4514;
4521 -> 4517;
4521 -> 4520;
4522 -> 4517;
4522 -> 4520;
4523 -> 4517;
4523 -> 4520;
4524 -> 4517;
4524 -> 4520;
4525 -> 4517;
4525 -> 4520;
4526 -> 4517;
4526 -> 4520;
4527 -> 4518;
4527 -> 4520;
4528 -> 4519;
4528 -> 4520;
4529 -> 4518;
4529 -> 4520;
4530 -> 4521;
4530 -> 4520;
4531 -> 4522;
4531 -> 4520;
4532 -> 4527;
4532 -> 4520;
4533 -> 4523;
4533 -> 4520;
4534 -> 4524;
4534 -> 4520;
4535 -> 4528;
4535 -> 4520;
4536 -> 4520;
4537 -> 4536;
4537 -> 4530;
4537 -> 4531;
4537 -> 4532;
4537 -> 4533;
4537 -> 4534;
4537 -> 4535;
4537 -> 4513;
4537 -> 4520;
4538 -> 4525;
4538 -> 4536;
4538 -> 4520;
4539 -> 4526;
4539 -> 4536;
4539 -> 4520;
4540 -> 4518;
4540 -> 4512;
4541 -> 4513;
4541 -> 4540;
4541 -> 4537;
4541 -> 4536;
4541 -> 4538;
4541 -> 4539;
4541 -> 4512;
4542 -> 4512;
4543 -> 4541;
4543 -> 4542;
4544 -> 4498;
4544 -> 4542;
4545 -> 4543;
4545 -> 4541;
4545 -> 4542;
4546 -> 4543;
4546 -> 4541;
4546 -> 4542;
4547 -> 4543;
4548 -> 4544;
4548 -> 4547;
4549 -> 4547;
4550 -> 4547;
4551 -> 4547;
4552 -> 4551;
4553 -> 4552;
4554 -> 4548;
4555 -> 4554;
4556 -> 4548;
4557 -> 4548;
4558 -> 4548;
4558 -> 4543;
4559 -> 4543;
4560 -> 4558;
4560 -> 4543;
4561 -> 4543;
4562 -> 4560;
4562 -> 4561;
4562 -> 4543;
4563 -> 4559;
4563 -> 4541;
4563 -> 0;
4563 -> 4543;
4564 -> 4560;
4564 -> 4543;
4565 -> 4564;
4565 -> 4548;
4565 -> 4543;
4566 -> 4543;
4566 -> 4541;
4567 -> 4543;
4567 -> 4541;
4568 -> 4564;
4568 -> 4548;
4568 -> 4543;
4569 -> 4543;
4570 -> 4548;
4570 -> 4569;
4571 -> 4570;
4571 -> 4548;
4571 -> 4569;
4572 -> 4569;
4572 -> 4543;
4573 -> 0;
4573 -> 4572;
4574 -> 4548;
4574 -> 4572;
4575 -> 4572;
4576 -> 4548;
4576 -> 4575;
4577 -> 4575;
4578 -> 4576;
4578 -> 4577;
4579 -> 4575;
4580 -> 4578;
4580 -> 4579;
4581 -> 4580;
4581 -> 4572;
4582 -> 4572;
4583 -> 4573;
4583 -> 4582;
4584 -> 4574;
4584 -> 4582;
4585 -> 4581;
4585 -> 4582;
4586 -> 4543;
4586 -> 4582;
4587 -> 4582;
4588 -> 4585;
4588 -> 4587;
4588 -> 4582;
4589 -> 4588;
4589 -> 4582;
4590 -> 4586;
4590 -> 4541;
4590 -> 4589;
4591 -> 4590;
4591 -> 4589;
4592 -> 4583;
4592 -> 4582;
4593 -> 4584;
4593 -> 4582;
4594 -> 4591;
4594 -> 4582;
4595 -> 4592;
4595 -> 4593;
4595 -> 4594;
4595 -> 4548;
4595 -> 4582;
4596 -> 4543;
4597 -> 4543;
4598 -> 4548;
4598 -> 4597;
4599 -> 4598;
4599 -> 4595;
4599 -> 4597;
4600 -> 4597;
4600 -> 4543;
4601 -> 4543;
4602 -> 4600;
4602 -> 4601;
4603 -> 4543;
4603 -> 4601;
4604 -> 0;
4604 -> 4601;
4605 -> 4601;
4606 -> 4602;
4606 -> 4601;
4607 -> 4601;
4608 -> 4604;
4608 -> 4607;
4609 -> 4605;
4609 -> 4607;
4610 -> 4606;
4610 -> 4607;
4611 -> 4603;
4611 -> 4607;
4612 -> 4607;
4613 -> 4610;
4613 -> 4612;
4613 -> 4607;
4614 -> 4613;
4614 -> 4607;
4615 -> 4611;
4615 -> 4595;
4615 -> 4614;
4616 -> 4608;
4616 -> 4607;
4617 -> 4609;
4617 -> 4607;
4618 -> 4543;
4619 -> 4542;
4620 -> 4544;
4620 -> 4619;
4621 -> 4620;
4621 -> 4615;
4621 -> 4619;
4622 -> 4619;
4622 -> 4542;
4623 -> 0;
4623 -> 4622;
4624 -> 4544;
4624 -> 4622;
4625 -> 4622;
4626 -> 4544;
4626 -> 4625;
4627 -> 4625;
4628 -> 4626;
4628 -> 4627;
4629 -> 4625;
4630 -> 4622;
4631 -> 4623;
4631 -> 4630;
4632 -> 4624;
4632 -> 4630;
4633 -> 4543;
4633 -> 4630;
4634 -> 4630;
4635 -> 4631;
4635 -> 4630;
4636 -> 4632;
4636 -> 4630;
4637 -> 4542;
4638 -> 4512;
4639 -> 4512;
4640 -> 4498;
4640 -> 4639;
4641 -> 4640;
4641 -> 4615;
4641 -> 4639;
4642 -> 4639;
4642 -> 4512;
4643 -> 4512;
4644 -> 4600;
4644 -> 4643;
4645 -> 4472;
4645 -> 4643;
4646 -> 0;
4646 -> 4643;
4647 -> 4643;
4648 -> 4644;
4648 -> 4643;
4649 -> 4643;
4650 -> 4646;
4650 -> 4649;
4651 -> 4647;
4651 -> 4649;
4652 -> 4648;
4652 -> 4649;
4653 -> 4645;
4653 -> 4649;
4654 -> 4649;
4655 -> 4652;
4655 -> 4654;
4655 -> 4649;
4656 -> 4655;
4656 -> 4649;
4657 -> 4650;
4657 -> 4649;
4658 -> 4651;
4658 -> 4649;
4659 -> 4512;
4660 -> 4470;
4661 -> 4471;
4661 -> 4660;
4662 -> 4660;
4663 -> 4661;
4663 -> 4615;
4663 -> 4662;
4664 -> 4662;
4664 -> 4470;
4665 -> 0;
4665 -> 4664;
4666 -> 4471;
4666 -> 4664;
4667 -> 4664;
4668 -> 4471;
4668 -> 4667;
4669 -> 4667;
4670 -> 4668;
4670 -> 4669;
4671 -> 4667;
4672 -> 4664;
4673 -> 4665;
4673 -> 4672;
4674 -> 4666;
4674 -> 4672;
4675 -> 4472;
4675 -> 4672;
4676 -> 4672;
4677 -> 4673;
4677 -> 4672;
4678 -> 4674;
4678 -> 4672;
4679 -> 4466;
4680 -> 4462;
4681 -> 4419;
4682 -> 4433;
4682 -> 4615;
4682 -> 4419;
4683 -> 4682;
4683 -> 4363;
4683 -> 3534;
4683 -> 4362;
4684 -> 4378;
4684 -> 4683;
4684 -> 4362;
4685 -> 4363;
4685 -> 3534;
4685 -> 4362;
4686 -> 4363;
4686 -> 3534;
4686 -> 4685;
4687 -> 4685;
4688 -> 4363;
4688 -> 3534;
4688 -> 4362;
4689 -> 4363;
4689 -> 3534;
4689 -> 4362;
4690 -> 4689;
4691 -> 4690;
4692 -> 4688;
4692 -> 4691;
4692 -> 4690;
4693 -> 4692;
4694 -> 4363;
4694 -> 3534;
4694 -> 4362;
4695 -> 4362;
4696 -> 4694;
4696 -> 4695;
4697 -> 4366;
4697 -> 4695;
4698 -> 4695;
4699 -> 4697;
4699 -> 4698;
4700 -> 4699;
4700 -> 4682;
4700 -> 4698;
4701 -> 4699;
4701 -> 4682;
4701 -> 4698;
4702 -> 4701;
4703 -> 4701;
4704 -> 4701;
4705 -> 4701;
4706 -> 4705;
4706 -> 4701;
4707 -> 4706;
4707 -> 4701;
4708 -> 4706;
4708 -> 4701;
4709 -> 4706;
4710 -> 4706;
4711 -> 4706;
4712 -> 4706;
4713 -> 4706;
4714 -> 4706;
4715 -> 4706;
4716 -> 4706;
4717 -> 4716;
4717 -> 4706;
4718 -> 4717;
4718 -> 4706;
4719 -> 4706;
4720 -> 4706;
4721 -> 4706;
4722 -> 4706;
4723 -> 4706;
4724 -> 4706;
4725 -> 4706;
4726 -> 4706;
4727 -> 4706;
4728 -> 4706;
4729 -> 4706;
4730 -> 0;
4730 -> 4706;
4731 -> 4728;
4731 -> 4706;
4732 -> 4706;
4733 -> 4714;
4733 -> 4732;
4733 -> 4706;
4734 -> 4706;
4735 -> 4734;
4735 -> 4706;
4736 -> 4735;
4736 -> 4706;
4737 -> 4706;
4738 -> 4706;
4739 -> 4706;
4740 -> 4706;
4741 -> 4706;
4742 -> 4709;
4742 -> 4741;
4742 -> 4706;
4743 -> 4706;
4744 -> 4706;
4745 -> 4706;
4745 -> 0;
4746 -> 4706;
4747 -> 4706;
4747 -> 4746;
4748 -> 4746;
4749 -> 4747;
4749 -> 4748;
4750 -> 4749;
4750 -> 4706;
4750 -> 4748;
4751 -> 4750;
4751 -> 4746;
4752 -> 4746;
4753 -> 4751;
4753 -> 4752;
4753 -> 4746;
4754 -> 4753;
4754 -> 4746;
4755 -> 4754;
4756 -> 4751;
4756 -> 4755;
4757 -> 4755;
4758 -> 4756;
4758 -> 4757;
4759 -> 4758;
4759 -> 4755;
4760 -> 4755;
4761 -> 4759;
4761 -> 4760;
4762 -> 4761;
4762 -> 4706;
4763 -> 4706;
4764 -> 4706;
4765 -> 4706;
4765 -> 4764;
4766 -> 4764;
4767 -> 4765;
4767 -> 4766;
4768 -> 4767;
4768 -> 4706;
4768 -> 4766;
4769 -> 4766;
4770 -> 4768;
4770 -> 4769;
4771 -> 4769;
4771 -> 4766;
4772 -> 4766;
4773 -> 4768;
4773 -> 4772;
4774 -> 4773;
4774 -> 4766;
4775 -> 4774;
4775 -> 4764;
4776 -> 4775;
4776 -> 4706;
4777 -> 4706;
4778 -> 4776;
4778 -> 4777;
4779 -> 4778;
4779 -> 4706;
4779 -> 4777;
4780 -> 4706;
4781 -> 4706;
4782 -> 4706;
4783 -> 4706;
4783 -> 0;
4784 -> 4695;
4785 -> 4695;
4786 -> 4785;
4786 -> 4695;
4787 -> 4696;
4787 -> 4695;
4788 -> 4785;
4788 -> 4695;
4789 -> 4697;
4789 -> 4706;
4789 -> 4787;
4789 -> 4788;
4789 -> 4786;
4789 -> 4695;
4790 -> 4789;
4790 -> 4695;
4791 -> 4790;
4791 -> 4362;
4792 -> 4791;
4793 -> 4791;
4793 -> 4792;
4794 -> 4792;
4795 -> 4794;
4795 -> 4791;
4796 -> 4791;
4797 -> 4693;
4797 -> 4796;
4797 -> 4791;
4798 -> 4791;
4799 -> 4791;
4799 -> 4798;
4800 -> 4798;
4801 -> 4800;
4801 -> 4791;
4802 -> 4693;
4802 -> 4801;
4802 -> 4791;
4803 -> 4795;
4803 -> 4802;
4803 -> 4791;
4804 -> 4803;
4805 -> 4370;
4805 -> 4804;
4805 -> 4803;
4806 -> 4791;
4806 -> 4803;
4807 -> 4362;
4808 -> 4806;
4808 -> 4807;
4808 -> 4362;
4809 -> 4806;
4809 -> 4362;
4810 -> 3526;
4811 -> 4809;
4811 -> 4810;
4811 -> 3526;
4812 -> 4809;
4812 -> 3526;
4813 -> 4812;
4813 -> 3526;
4814 -> 3526;
4814 -> 3535;
4815 -> 3526;
4816 -> 4812;
4816 -> 4815;
4817 -> 4815;
4818 -> 4816;
4818 -> 4817;
4819 -> 4818;
4819 -> 4790;
4819 -> 4817;
4820 -> 4819;
4820 -> 4815;
4821 -> 4815;
4822 -> 4820;
4822 -> 4821;
4822 -> 4815;
4823 -> 4822;
4823 -> 4815;
4824 -> 4823;
4825 -> 4820;
4825 -> 4824;
4826 -> 4824;
4827 -> 4825;
4827 -> 4826;
4828 -> 4827;
4828 -> 4824;
4829 -> 4824;
4830 -> 4828;
4830 -> 4829;
4831 -> 4830;
4831 -> 3526;
4832 -> 4814;
4832 -> 4831;
4832 -> 3526;
4833 -> 4814;
4833 -> 3526;
4834 -> 3526;
4835 -> 4812;
4835 -> 4834;
4835 -> 3526;
4836 -> 3532;
4836 -> 4814;
4836 -> 3526;
4837 -> 4363;
4837 -> 4836;
4838 -> 4812;
4838 -> 4836;
4839 -> 4836;
4840 -> 4837;
4840 -> 4839;
4841 -> 4838;
4841 -> 4839;
4842 -> 3527;
4842 -> 4839;
4843 -> 4839;
4844 -> 4840;
4844 -> 3534;
4844 -> 4790;
4844 -> 4839;
4845 -> 4841;
4845 -> 4839;
4846 -> 4842;
4846 -> 4844;
4846 -> 4845;
4846 -> 4790;
4846 -> 4839;
4847 -> 4846;
4847 -> 4839;
4848 -> 4841;
4848 -> 4839;
4849 -> 0;
4849 -> 4839;
4850 -> 4839;
4851 -> 4847;
4851 -> 4850;
4852 -> 4848;
4852 -> 4850;
4853 -> 4849;
4853 -> 4850;
4854 -> 4851;
4854 -> 4850;
4855 -> 4852;
4855 -> 4850;
4856 -> 4853;
4856 -> 4850;
4857 -> 4850;
4858 -> 4855;
4858 -> 4857;
4859 -> 4856;
4859 -> 4857;
4860 -> 4851;
4860 -> 4857;
4861 -> 4858;
4861 -> 4857;
4862 -> 4861;
4862 -> 4857;
4863 -> 4859;
4863 -> 4862;
4864 -> 4862;
4865 -> 4862;
4865 -> 4864;
4866 -> 4863;
4866 -> 4864;
4867 -> 4860;
4867 -> 4864;
4868 -> 4865;
4868 -> 4867;
4868 -> 4864;
4869 -> 4868;
4870 -> 4836;
4871 -> 4812;
4871 -> 3526;
4872 -> 4871;
4872 -> 3526;
4873 -> 3526;
4874 -> 4872;
4874 -> 4873;
4875 -> 4873;
4876 -> 4874;
4876 -> 4875;
4877 -> 0;
4877 -> 4875;
4878 -> 4877;
4878 -> 4873;
4879 -> 4878;
4879 -> 3526;
4880 -> 3526;
4881 -> 3529;
4881 -> 4880;
4881 -> 3526;
4882 -> 4871;
4882 -> 3526;
4883 -> 4882;
4883 -> 3518;
4884 -> 3518;
4885 -> 4883;
4885 -> 4884;
4886 -> 2887;
4886 -> 4884;
4887 -> 4884;
4888 -> 4885;
4888 -> 4887;
4888 -> 4884;
4889 -> 4884;
4890 -> 4885;
4890 -> 4889;
4891 -> 4890;
4891 -> 4846;
4891 -> 4889;
4892 -> 4891;
4892 -> 0;
4892 -> 4889;
4893 -> 4890;
4893 -> 4846;
4893 -> 4892;
4894 -> 4893;
4895 -> 4893;
4896 -> 4894;
4896 -> 4895;
4897 -> 4890;
4897 -> 4895;
4898 -> 4897;
4898 -> 4846;
4898 -> 4895;
4899 -> 3414;
4899 -> 4895;
4900 -> 4898;
4901 -> 4897;
4901 -> 4900;
4902 -> 4901;
4902 -> 4846;
4902 -> 4900;
4903 -> 4902;
4904 -> 4901;
4904 -> 4903;
4905 -> 4904;
4905 -> 4846;
4905 -> 4903;
4906 -> 4903;
4907 -> 4905;
4907 -> 4906;
4908 -> 4906;
4908 -> 4903;
4909 -> 4903;
4910 -> 4905;
4910 -> 4909;
4911 -> 4910;
4911 -> 4903;
4912 -> 4911;
4912 -> 4902;
4913 -> 4902;
4914 -> 4912;
4914 -> 4913;
4915 -> 4914;
4915 -> 4902;
4916 -> 4901;
4916 -> 4846;
4916 -> 4902;
4917 -> 4915;
4917 -> 4902;
4918 -> 4912;
4918 -> 4917;
4919 -> 4901;
4919 -> 4917;
4920 -> 4917;
4921 -> 4917;
4922 -> 4918;
4922 -> 4921;
4923 -> 4919;
4923 -> 4921;
4924 -> 4920;
4924 -> 4921;
4925 -> 4922;
4925 -> 4921;
4926 -> 4923;
4926 -> 4921;
4927 -> 4921;
4928 -> 4921;
4929 -> 4925;
4929 -> 4928;
4930 -> 4926;
4930 -> 4928;
4931 -> 4927;
4931 -> 4928;
4932 -> 4924;
4932 -> 4928;
4933 -> 4928;
4934 -> 4929;
4934 -> 4933;
4935 -> 4928;
4936 -> 4929;
4936 -> 4935;
4937 -> 4936;
4937 -> 4928;
4938 -> 4937;
4939 -> 4937;
4940 -> 4938;
4940 -> 4939;
4941 -> 4940;
4941 -> 4915;
4941 -> 4939;
4943 -> 4942;
4944 -> 4942;
4945 -> 4944;
4945 -> 4928;
4946 -> 4929;
4946 -> 4928;
4947 -> 4928;
4948 -> 4947;
4948 -> 4934;
4948 -> 4941;
4948 -> 4945;
4948 -> 4946;
4948 -> 4915;
4948 -> 4943;
4948 -> 4928;
4949 -> 4947;
4949 -> 4928;
4950 -> 4947;
4950 -> 4928;
4951 -> 4928;
4952 -> 4929;
4952 -> 4951;
4952 -> 4928;
4953 -> 4930;
4953 -> 4947;
4953 -> 4928;
4954 -> 4931;
4954 -> 4947;
4954 -> 4928;
4955 -> 4915;
4955 -> 4917;
4956 -> 4955;
4956 -> 4920;
4956 -> 4915;
4956 -> 4948;
4956 -> 4949;
4956 -> 4953;
4956 -> 4950;
4956 -> 4954;
4956 -> 4917;
4957 -> 4956;
4957 -> 4920;
4958 -> 4957;
4958 -> 4956;
4958 -> 4920;
4959 -> 4958;
4959 -> 4898;
4960 -> 4959;
4960 -> 4898;
4961 -> 4896;
4961 -> 4960;
4962 -> 4959;
4962 -> 4961;
4963 -> 0;
4963 -> 4893;
4964 -> 4893;
4965 -> 4962;
4965 -> 4964;
4965 -> 4893;
4966 -> 4965;
4967 -> 4966;
4967 -> 4965;
4968 -> 4967;
4968 -> 4965;
4969 -> 4963;
4969 -> 4890;
4969 -> 4892;
4970 -> 4963;
4970 -> 4889;
4971 -> 4970;
4971 -> 4884;
4972 -> 4884;
4973 -> 4885;
4973 -> 4972;
4974 -> 4973;
4974 -> 4958;
4974 -> 4972;
4975 -> 4974;
4975 -> 4884;
4976 -> 4884;
4977 -> 4884;
4978 -> 4885;
4978 -> 4977;
4979 -> 0;
4979 -> 4977;
4980 -> 4978;
4980 -> 4958;
4980 -> 0;
4980 -> 4977;
4981 -> 4980;
4981 -> 4884;
4982 -> 2883;
4982 -> 4981;
4982 -> 3518;
4983 -> 3518;
4984 -> 4882;
4984 -> 4983;
4984 -> 3518;
4985 -> 4882;
4985 -> 3518;
4986 -> 3518;
4987 -> 4985;
4987 -> 4986;
4988 -> 4986;
4989 -> 4987;
4989 -> 4988;
4990 -> 0;
4990 -> 4988;
4991 -> 4990;
4991 -> 4986;
4992 -> 4991;
4992 -> 4986;
4993 -> 4987;
4993 -> 4992;
4994 -> 4986;
4995 -> 4993;
4995 -> 4994;
4995 -> 4986;
4996 -> 4986;
4997 -> 4993;
4997 -> 4996;
4998 -> 4997;
4998 -> 4958;
4998 -> 4996;
4999 -> 4998;
4999 -> 4986;
5000 -> 4986;
5001 -> 4986;
5002 -> 4993;
5002 -> 5001;
5003 -> 5001;
5004 -> 5002;
5004 -> 5003;
5005 -> 5004;
5005 -> 4958;
5005 -> 5003;
5006 -> 5003;
5007 -> 5005;
5007 -> 5006;
5007 -> 5003;
5008 -> 5003;
5009 -> 5004;
5009 -> 5008;
5010 -> 5008;
5011 -> 5009;
5011 -> 5010;
5012 -> 5011;
5012 -> 4958;
5012 -> 5010;
5013 -> 5010;
5014 -> 5012;
5014 -> 5013;
5015 -> 5013;
5015 -> 5010;
5016 -> 5010;
5017 -> 5016;
5018 -> 5012;
5018 -> 5008;
5019 -> 5009;
5019 -> 4958;
5019 -> 5008;
5020 -> 5008;
5021 -> 5019;
5021 -> 5020;
5022 -> 5018;
5022 -> 5020;
5023 -> 5021;
5023 -> 5020;
5024 -> 5022;
5024 -> 4958;
5024 -> 5023;
5024 -> 4969;
5024 -> 5020;
5025 -> 5024;
5026 -> 5025;
5027 -> 5026;
5027 -> 5003;
5028 -> 5027;
5029 -> 5027;
5030 -> 5028;
5030 -> 5029;
5031 -> 5030;
5031 -> 5029;
5032 -> 0;
5032 -> 5030;
5032 -> 5029;
5033 -> 0;
5033 -> 5030;
5033 -> 5029;
5034 -> 5030;
5034 -> 5029;
5035 -> 5030;
5035 -> 5029;
5036 -> 5030;
5036 -> 5029;
5037 -> 5030;
5037 -> 5029;
5038 -> 3414;
5038 -> 5030;
5038 -> 5029;
5039 -> 0;
5039 -> 5030;
5039 -> 5029;
5040 -> 5004;
5040 -> 5024;
5040 -> 5027;
5041 -> 5028;
5041 -> 5027;
5042 -> 5027;
5043 -> 5040;
5043 -> 5041;
5043 -> 5042;
5043 -> 5031;
5043 -> 5032;
5043 -> 5033;
5043 -> 5034;
5043 -> 5035;
5043 -> 5036;
5043 -> 5037;
5043 -> 5038;
5043 -> 5039;
5043 -> 5024;
5043 -> 0;
5043 -> 5027;
5044 -> 5043;
5044 -> 5001;
5045 -> 5044;
5045 -> 3647;
5045 -> 5001;
5046 -> 5044;
5046 -> 5043;
5046 -> 5001;
5047 -> 5046;
5048 -> 5047;
5049 -> 5047;
5049 -> 5048;
5050 -> 5048;
5050 -> 5047;
5051 -> 5047;
5051 -> 5046;
5052 -> 5046;
5053 -> 5051;
5053 -> 5052;
5054 -> 5002;
5054 -> 5043;
5054 -> 5046;
5055 -> 5053;
5055 -> 5044;
5055 -> 5046;
5056 -> 5044;
5056 -> 5053;
5056 -> 5055;
5056 -> 5001;
5057 -> 5056;
5057 -> 4986;
5058 -> 4882;
5058 -> 3518;
5059 -> 3491;
5059 -> 3518;
5060 -> 0;
5060 -> 3518;
5061 -> 3518;
5062 -> 5058;
5062 -> 5061;
5063 -> 5059;
5063 -> 5061;
5064 -> 5060;
5064 -> 5061;
5065 -> 5062;
5065 -> 5061;
5066 -> 5063;
5066 -> 5061;
5067 -> 5064;
5067 -> 5061;
5068 -> 5061;
5069 -> 5066;
5069 -> 5068;
5070 -> 5067;
5070 -> 5068;
5071 -> 5062;
5071 -> 5068;
5072 -> 5069;
5072 -> 5068;
5073 -> 5072;
5073 -> 5068;
5074 -> 5070;
5074 -> 5073;
5075 -> 5073;
5076 -> 5073;
5076 -> 5075;
5077 -> 5074;
5077 -> 5075;
5078 -> 5071;
5078 -> 5075;
5079 -> 5076;
5079 -> 5078;
5079 -> 5075;
5080 -> 5075;
5081 -> 5076;
5081 -> 5080;
5081 -> 5075;
5082 -> 5081;
5083 -> 3518;
5084 -> 3491;
5084 -> 5083;
5084 -> 3518;
5085 -> 4882;
5085 -> 3518;
5086 -> 5055;
5087 -> 5055;
5087 -> 5086;
5088 -> 5086;
5089 -> 5088;
5089 -> 5055;
5090 -> 5055;
5091 -> 5055;
5092 -> 5055;
5093 -> 5055;
5094 -> 5055;
5095 -> 5055;
5096 -> 5055;
5097 -> 5055;
5098 -> 5055;
5099 -> 5055;
5100 -> 5055;
5101 -> 5055;
5102 -> 5055;
5103 -> 5055;
5104 -> 5055;
5105 -> 5055;
5106 -> 5055;
5107 -> 5055;
5108 -> 5055;
5109 -> 5055;
5110 -> 5055;
5111 -> 5110;
5111 -> 5055;
5112 -> 5111;
5112 -> 5055;
5113 -> 5055;
5114 -> 5055;
5115 -> 5055;
5116 -> 5055;
5117 -> 5055;
5118 -> 5055;
5119 -> 5055;
5120 -> 5055;
5121 -> 5055;
5122 -> 5055;
5123 -> 5055;
5124 -> 5122;
5124 -> 5055;
5125 -> 5055;
5126 -> 5108;
5126 -> 5125;
5126 -> 5055;
5127 -> 5055;
5128 -> 5103;
5128 -> 5127;
5128 -> 5055;
5129 -> 5055;
5130 -> 5055;
5131 -> 5055;
5132 -> 5055;
5133 -> 5055;
5134 -> 5055;
5135 -> 5055;
5136 -> 5055;
5137 -> 5055;
5138 -> 5055;
5138 -> 5137;
5139 -> 5137;
5139 -> 5055;
5140 -> 5055;
5141 -> 5055;
5142 -> 5141;
5142 -> 5055;
5143 -> 5055;
5144 -> 5055;
5144 -> 5143;
5145 -> 5143;
5146 -> 5144;
5146 -> 5145;
5147 -> 5145;
5147 -> 5143;
5148 -> 5147;
5148 -> 5055;
5149 -> 5055;
5150 -> 5149;
5151 -> 5055;
5152 -> 5055;
5153 -> 5055;
5154 -> 5055;
5155 -> 5153;
5155 -> 5055;
5156 -> 5155;
5157 -> 5155;
5158 -> 5055;
5159 -> 5055;
5160 -> 5055;
5161 -> 0;
5161 -> 5055;
5162 -> 5055;
5163 -> 5055;
5164 -> 5162;
5164 -> 5055;
5165 -> 5055;
5166 -> 5164;
5166 -> 5165;
5166 -> 5055;
5167 -> 5163;
5167 -> 5055;
5167 -> 0;
5168 -> 5164;
5168 -> 5055;
5169 -> 5168;
5169 -> 5055;
5170 -> 5168;
5170 -> 5055;
5171 -> 5055;
5172 -> 5171;
5172 -> 5055;
5173 -> 5055;
5174 -> 5055;
5174 -> 5173;
5175 -> 5173;
5176 -> 5055;
5177 -> 5055;
5178 -> 5140;
5178 -> 5177;
5178 -> 5055;
5179 -> 5148;
5179 -> 5178;
5180 -> 5179;
5181 -> 5055;
5181 -> 5180;
5182 -> 5180;
5183 -> 5181;
5183 -> 5055;
5183 -> 5182;
5184 -> 5183;
5184 -> 5180;
5185 -> 5184;
5185 -> 5179;
5186 -> 5055;
5186 -> 5179;
5187 -> 5179;
5188 -> 5179;
5189 -> 5185;
5189 -> 5188;
5190 -> 5186;
5190 -> 5188;
5191 -> 5187;
5191 -> 5188;
5192 -> 5187;
5192 -> 5188;
5193 -> 5189;
5193 -> 5188;
5194 -> 5188;
5195 -> 5191;
5195 -> 5188;
5196 -> 5193;
5196 -> 5188;
5197 -> 5194;
5197 -> 5188;
5198 -> 5195;
5198 -> 5188;
5199 -> 5196;
5199 -> 5188;
5200 -> 5198;
5200 -> 5188;
5201 -> 5197;
5201 -> 5188;
5202 -> 5199;
5202 -> 5188;
5203 -> 5200;
5203 -> 5188;
5204 -> 5201;
5204 -> 5188;
5205 -> 5192;
5205 -> 5188;
5206 -> 5202;
5206 -> 5188;
5207 -> 5190;
5207 -> 5055;
5207 -> 5188;
5208 -> 5190;
5208 -> 5188;
5209 -> 5188;
5210 -> 5203;
5210 -> 5188;
5211 -> 5188;
5212 -> 5204;
5212 -> 5188;
5213 -> 5188;
5214 -> 5188;
5215 -> 5206;
5215 -> 5214;
5216 -> 5207;
5216 -> 5214;
5217 -> 5190;
5217 -> 5214;
5218 -> 5190;
5218 -> 5214;
5219 -> 5208;
5219 -> 5214;
5220 -> 5209;
5220 -> 5214;
5221 -> 5210;
5221 -> 5214;
5222 -> 5211;
5222 -> 5214;
5223 -> 5212;
5223 -> 5214;
5224 -> 5213;
5224 -> 5214;
5225 -> 5205;
5225 -> 5214;
5226 -> 5217;
5226 -> 5214;
5227 -> 5218;
5227 -> 5214;
5228 -> 5219;
5228 -> 5214;
5229 -> 5224;
5229 -> 5214;
5230 -> 5214;
5231 -> 5226;
5231 -> 5230;
5232 -> 5227;
5232 -> 5230;
5233 -> 5228;
5233 -> 5230;
5234 -> 5229;
5234 -> 5230;
5235 -> 5225;
5235 -> 5230;
5236 -> 5234;
5236 -> 5230;
5237 -> 5230;
5238 -> 5236;
5238 -> 5237;
5239 -> 5235;
5239 -> 5237;
5240 -> 5238;
5240 -> 5235;
5240 -> 5237;
5241 -> 5235;
5241 -> 5230;
5242 -> 5235;
5242 -> 5230;
5243 -> 5235;
5243 -> 5230;
5244 -> 5230;
5245 -> 5231;
5245 -> 5244;
5245 -> 5230;
5246 -> 5231;
5246 -> 5235;
5246 -> 5230;
5247 -> 5232;
5247 -> 5235;
5247 -> 5230;
5248 -> 5230;
5249 -> 5232;
5249 -> 5248;
5249 -> 5230;
5250 -> 5233;
5250 -> 5249;
5250 -> 5230;
5251 -> 5250;
5251 -> 5235;
5251 -> 5230;
5252 -> 5225;
5252 -> 5214;
5253 -> 5225;
5253 -> 5214;
5254 -> 5225;
5254 -> 5214;
5255 -> 5225;
5255 -> 5214;
5256 -> 5225;
5256 -> 5214;
5257 -> 5225;
5257 -> 5214;
5258 -> 5214;
5259 -> 5215;
5259 -> 5258;
5259 -> 5214;
5260 -> 5214;
5261 -> 5216;
5261 -> 5260;
5261 -> 5214;
5262 -> 5214;
5263 -> 5223;
5263 -> 5262;
5263 -> 5214;
5264 -> 5216;
5264 -> 5225;
5264 -> 5214;
5265 -> 5215;
5265 -> 5225;
5265 -> 5214;
5266 -> 5220;
5266 -> 5225;
5266 -> 5214;
5267 -> 5221;
5267 -> 5225;
5267 -> 5214;
5268 -> 5222;
5268 -> 5225;
5268 -> 5214;
5269 -> 5223;
5269 -> 5225;
5269 -> 5214;
5270 -> 5055;
5271 -> 5187;
5271 -> 5270;
5271 -> 5055;
5272 -> 5187;
5272 -> 5055;
5273 -> 5272;
5274 -> 5273;
5274 -> 5055;
5275 -> 5273;
5275 -> 5055;
5276 -> 5055;
5277 -> 5187;
5277 -> 5276;
5277 -> 5055;
5278 -> 5187;
5278 -> 5055;
5279 -> 5055;
5280 -> 5278;
5280 -> 5279;
5281 -> 5279;
5282 -> 5280;
5282 -> 5281;
5283 -> 0;
5283 -> 5281;
5284 -> 5283;
5284 -> 5279;
5285 -> 5284;
5285 -> 5280;
5285 -> 5279;
5286 -> 5285;
5287 -> 2887;
5287 -> 5055;
5288 -> 5055;
5289 -> 5286;
5289 -> 5288;
5289 -> 5055;
5290 -> 5289;
5291 -> 2883;
5291 -> 5290;
5291 -> 5055;
5292 -> 5291;
5293 -> 5055;
5294 -> 5292;
5294 -> 5293;
5294 -> 5055;
5295 -> 5190;
5296 -> 5190;
5297 -> 5190;
5298 -> 5190;
5299 -> 5190;
5300 -> 5190;
5301 -> 5190;
5302 -> 5190;
5303 -> 5190;
5304 -> 5190;
5305 -> 5190;
5306 -> 5190;
5307 -> 5190;
5308 -> 5190;
5309 -> 5190;
5310 -> 5190;
5311 -> 5190;
5312 -> 5311;
5312 -> 5190;
5313 -> 5312;
5313 -> 5190;
5314 -> 5190;
5315 -> 5190;
5316 -> 5190;
5317 -> 5190;
5318 -> 5190;
5319 -> 5190;
5320 -> 5190;
5321 -> 5190;
5322 -> 5190;
5323 -> 5190;
5324 -> 5190;
5325 -> 5323;
5325 -> 5190;
5326 -> 5190;
5327 -> 5309;
5327 -> 5326;
5327 -> 5190;
5328 -> 5190;
5329 -> 5304;
5329 -> 5328;
5329 -> 5190;
5330 -> 5190;
5331 -> 5190;
5332 -> 5190;
5333 -> 5190;
5334 -> 5190;
5335 -> 5190;
5336 -> 5190;
5337 -> 5190;
5338 -> 5190;
5339 -> 5190;
5339 -> 5338;
5340 -> 5338;
5340 -> 5190;
5341 -> 5190;
5342 -> 5341;
5342 -> 5190;
5343 -> 5190;
5344 -> 5343;
5344 -> 5190;
5345 -> 5190;
5346 -> 5345;
5347 -> 5190;
5348 -> 5190;
5349 -> 5190;
5350 -> 5190;
5351 -> 5349;
5351 -> 5190;
5352 -> 5351;
5353 -> 5351;
5354 -> 5190;
5355 -> 5190;
5356 -> 5190;
5357 -> 0;
5357 -> 5190;
5358 -> 5190;
5359 -> 5190;
5360 -> 5358;
5360 -> 5190;
5361 -> 5190;
5362 -> 5360;
5362 -> 5361;
5362 -> 5190;
5363 -> 5359;
5363 -> 5190;
5363 -> 0;
5364 -> 5360;
5364 -> 5190;
5365 -> 5364;
5365 -> 5190;
5366 -> 5364;
5366 -> 5190;
5367 -> 5190;
5368 -> 5367;
5368 -> 5190;
5369 -> 5190;
5370 -> 5190;
5370 -> 5369;
5371 -> 5369;
5372 -> 5190;
5373 -> 5190;
5374 -> 5190;
5374 -> 5373;
5375 -> 5373;
5376 -> 5374;
5376 -> 5190;
5376 -> 5375;
5377 -> 5376;
5377 -> 5373;
5378 -> 5377;
5378 -> 5190;
5379 -> 5190;
5380 -> 5378;
5380 -> 5190;
5381 -> 5190;
5382 -> 5379;
5382 -> 5190;
5383 -> 5380;
5383 -> 5190;
5384 -> 5381;
5384 -> 5190;
5385 -> 5382;
5385 -> 5190;
5386 -> 5383;
5386 -> 5190;
5387 -> 5385;
5387 -> 5190;
5388 -> 5384;
5388 -> 5190;
5389 -> 5386;
5389 -> 5190;
5390 -> 5387;
5390 -> 5190;
5391 -> 5388;
5391 -> 5190;
5392 -> 5190;
5393 -> 5389;
5393 -> 5190;
5394 -> 5190;
5395 -> 5190;
5396 -> 5190;
5397 -> 5390;
5397 -> 5190;
5398 -> 5190;
5399 -> 5391;
5399 -> 5190;
5400 -> 5190;
5401 -> 5393;
5401 -> 5392;
5402 -> 5394;
5402 -> 5392;
5403 -> 5190;
5403 -> 5392;
5404 -> 5190;
5404 -> 5392;
5405 -> 5395;
5405 -> 5392;
5406 -> 5396;
5406 -> 5392;
5407 -> 5397;
5407 -> 5392;
5408 -> 5398;
5408 -> 5392;
5409 -> 5399;
5409 -> 5392;
5410 -> 5400;
5410 -> 5392;
5411 -> 5392;
5412 -> 5403;
5412 -> 5392;
5413 -> 5404;
5413 -> 5392;
5414 -> 5405;
5414 -> 5392;
5415 -> 5410;
5415 -> 5392;
5416 -> 5412;
5416 -> 5411;
5417 -> 5413;
5417 -> 5411;
5418 -> 5414;
5418 -> 5411;
5419 -> 5415;
5419 -> 5411;
5420 -> 5411;
5421 -> 5419;
5421 -> 5411;
5422 -> 5421;
5422 -> 5420;
5423 -> 5420;
5424 -> 5420;
5424 -> 5411;
5425 -> 5420;
5425 -> 5411;
5426 -> 5420;
5426 -> 5411;
5427 -> 5411;
5428 -> 5416;
5428 -> 5427;
5428 -> 5411;
5429 -> 5416;
5429 -> 5420;
5429 -> 5411;
5430 -> 5417;
5430 -> 5420;
5430 -> 5411;
5431 -> 5411;
5432 -> 5417;
5432 -> 5431;
5432 -> 5411;
5433 -> 5418;
5433 -> 5432;
5433 -> 5411;
5434 -> 5433;
5434 -> 5420;
5434 -> 5411;
5435 -> 5411;
5435 -> 5392;
5436 -> 5411;
5436 -> 5392;
5437 -> 5411;
5437 -> 5392;
5438 -> 5411;
5438 -> 5392;
5439 -> 5411;
5439 -> 5392;
5440 -> 5411;
5440 -> 5392;
5441 -> 5392;
5442 -> 5401;
5442 -> 5441;
5442 -> 5392;
5443 -> 5392;
5444 -> 5402;
5444 -> 5443;
5444 -> 5392;
5445 -> 5392;
5446 -> 5409;
5446 -> 5445;
5446 -> 5392;
5447 -> 5402;
5447 -> 5411;
5447 -> 5392;
5448 -> 5401;
5448 -> 5411;
5448 -> 5392;
5449 -> 5406;
5449 -> 5411;
5449 -> 5392;
5450 -> 5407;
5450 -> 5411;
5450 -> 5392;
5451 -> 5408;
5451 -> 5411;
5451 -> 5392;
5452 -> 5409;
5452 -> 5411;
5452 -> 5392;
5453 -> 5190;
5453 -> 5270;
5453 -> 5055;
5454 -> 5190;
5454 -> 5055;
5455 -> 5454;
5456 -> 5455;
5456 -> 5055;
5457 -> 5455;
5457 -> 5055;
5458 -> 5190;
5458 -> 5276;
5458 -> 5055;
5459 -> 5190;
5459 -> 5055;
5460 -> 5459;
5460 -> 5279;
5461 -> 5460;
5461 -> 5281;
5462 -> 5284;
5462 -> 5460;
5462 -> 5279;
5463 -> 5462;
5464 -> 5463;
5464 -> 5288;
5464 -> 5055;
5465 -> 5464;
5466 -> 2883;
5466 -> 5465;
5466 -> 5055;
5467 -> 5466;
5468 -> 5467;
5468 -> 5293;
5468 -> 5055;
5469 -> 5190;
5470 -> 5190;
5470 -> 5469;
5471 -> 5469;
5472 -> 5471;
5472 -> 5190;
5473 -> 5190;
5474 -> 5190;
5475 -> 5190;
5476 -> 5190;
5477 -> 5359;
5477 -> 5190;
5478 -> 5477;
5478 -> 5190;
5479 -> 5478;
5479 -> 5361;
5479 -> 5190;
5480 -> 5478;
5480 -> 5190;
5481 -> 5480;
5481 -> 5190;
5482 -> 5359;
5483 -> 5359;
5484 -> 5359;
5485 -> 5484;
5486 -> 5359;
5487 -> 5359;
5488 -> 5359;
5489 -> 5488;
5489 -> 5359;
5490 -> 5359;
5491 -> 5489;
5491 -> 5490;
5491 -> 5359;
5492 -> 5359;
5492 -> 0;
5493 -> 5489;
5493 -> 5359;
5494 -> 5493;
5494 -> 5359;
5495 -> 5493;
5495 -> 5359;
5496 -> 5359;
5497 -> 5496;
5497 -> 5359;
5498 -> 5190;
5498 -> 5359;
5499 -> 5498;
5499 -> 5359;
5500 -> 5359;
5501 -> 5359;
5502 -> 5359;
5503 -> 5359;
5504 -> 5359;
5505 -> 5359;
5506 -> 5504;
5506 -> 5505;
5506 -> 5359;
5507 -> 5374;
5507 -> 5359;
5507 -> 5375;
5508 -> 5507;
5508 -> 5373;
5509 -> 5508;
5509 -> 5190;
5510 -> 5509;
5510 -> 5190;
5511 -> 5510;
5511 -> 5190;
5512 -> 5511;
5512 -> 5190;
5513 -> 5512;
5513 -> 5190;
5514 -> 5513;
5514 -> 5190;
5515 -> 5514;
5515 -> 5392;
5516 -> 5515;
5516 -> 5441;
5516 -> 5392;
5517 -> 5515;
5517 -> 5411;
5517 -> 5392;
5518 -> 5190;
5519 -> 5190;
5520 -> 5519;
5521 -> 5520;
5521 -> 5190;
5522 -> 5520;
5522 -> 5190;
5523 -> 5190;
5524 -> 5190;
5525 -> 5190;
5526 -> 5524;
5526 -> 5525;
5527 -> 5525;
5528 -> 5526;
5528 -> 5527;
5529 -> 0;
5529 -> 5527;
5530 -> 5529;
5530 -> 5525;
5531 -> 5530;
5531 -> 5526;
5531 -> 5525;
5532 -> 5531;
5533 -> 2887;
5533 -> 5190;
5534 -> 5190;
5535 -> 5532;
5535 -> 5534;
5535 -> 5190;
5536 -> 5535;
5537 -> 2883;
5537 -> 5536;
5537 -> 5190;
5538 -> 5537;
5539 -> 5190;
5540 -> 5538;
5540 -> 5539;
5540 -> 5190;
5541 -> 5359;
5542 -> 5359;
5542 -> 5541;
5543 -> 5541;
5544 -> 5543;
5544 -> 5359;
5545 -> 5359;
5546 -> 5359;
5547 -> 5359;
5548 -> 5359;
5549 -> 5359;
5550 -> 5359;
5551 -> 5359;
5552 -> 5359;
5553 -> 5359;
5554 -> 5359;
5555 -> 5359;
5556 -> 5359;
5557 -> 5359;
5558 -> 5359;
5559 -> 5359;
5560 -> 5359;
5561 -> 5359;
5562 -> 5359;
5563 -> 5562;
5563 -> 5359;
5564 -> 5563;
5564 -> 5359;
5565 -> 5359;
5566 -> 5359;
5567 -> 5359;
5568 -> 5359;
5569 -> 5359;
5570 -> 5359;
5571 -> 5359;
5572 -> 5359;
5573 -> 5359;
5574 -> 5359;
5575 -> 5359;
5576 -> 5574;
5576 -> 5359;
5577 -> 5359;
5578 -> 5560;
5578 -> 5577;
5578 -> 5359;
5579 -> 5359;
5580 -> 5359;
5581 -> 5359;
5582 -> 5359;
5583 -> 5359;
5584 -> 5359;
5585 -> 5359;
5586 -> 5359;
5586 -> 5585;
5587 -> 5585;
5587 -> 5359;
5588 -> 5359;
5589 -> 5588;
5589 -> 5359;
5590 -> 5359;
5591 -> 5590;
5591 -> 5359;
5592 -> 5359;
5593 -> 5359;
5594 -> 5592;
5594 -> 5359;
5595 -> 5594;
5596 -> 5594;
5597 -> 5359;
5598 -> 0;
5598 -> 5359;
5599 -> 5359;
5600 -> 5359;
5600 -> 5599;
5601 -> 5599;
5602 -> 5359;
5603 -> 5359;
5604 -> 5359;
5604 -> 5603;
5605 -> 5603;
5606 -> 5604;
5606 -> 5359;
5606 -> 5605;
5607 -> 5606;
5607 -> 5603;
5608 -> 5607;
5608 -> 5359;
5609 -> 5359;
5610 -> 5608;
5610 -> 5359;
5611 -> 5359;
5612 -> 5609;
5612 -> 5359;
5613 -> 5610;
5613 -> 5359;
5614 -> 5611;
5614 -> 5359;
5615 -> 5612;
5615 -> 5359;
5616 -> 5613;
5616 -> 5359;
5617 -> 5615;
5617 -> 5359;
5618 -> 5614;
5618 -> 5359;
5619 -> 5616;
5619 -> 5359;
5620 -> 5617;
5620 -> 5359;
5621 -> 5618;
5621 -> 5359;
5622 -> 5359;
5623 -> 5619;
5623 -> 5359;
5624 -> 5359;
5625 -> 5359;
5626 -> 5359;
5627 -> 5620;
5627 -> 5359;
5628 -> 5359;
5629 -> 5621;
5629 -> 5359;
5630 -> 5359;
5631 -> 5623;
5631 -> 5622;
5632 -> 5624;
5632 -> 5622;
5633 -> 5359;
5633 -> 5622;
5634 -> 5359;
5634 -> 5622;
5635 -> 5625;
5635 -> 5622;
5636 -> 5626;
5636 -> 5622;
5637 -> 5627;
5637 -> 5622;
5638 -> 5628;
5638 -> 5622;
5639 -> 5629;
5639 -> 5622;
5640 -> 5630;
5640 -> 5622;
5641 -> 5622;
5642 -> 5633;
5642 -> 5622;
5643 -> 5634;
5643 -> 5622;
5644 -> 5635;
5644 -> 5622;
5645 -> 5640;
5645 -> 5622;
5646 -> 5642;
5646 -> 5641;
5647 -> 5643;
5647 -> 5641;
5648 -> 5644;
5648 -> 5641;
5649 -> 5645;
5649 -> 5641;
5650 -> 5641;
5651 -> 5649;
5651 -> 5641;
5652 -> 5651;
5652 -> 5650;
5653 -> 5650;
5654 -> 5650;
5654 -> 5641;
5655 -> 5650;
5655 -> 5641;
5656 -> 5650;
5656 -> 5641;
5657 -> 5641;
5658 -> 5646;
5658 -> 5657;
5658 -> 5641;
5659 -> 5646;
5659 -> 5650;
5659 -> 5641;
5660 -> 5647;
5660 -> 5650;
5660 -> 5641;
5661 -> 5641;
5662 -> 5647;
5662 -> 5661;
5662 -> 5641;
5663 -> 5648;
5663 -> 5662;
5663 -> 5641;
5664 -> 5663;
5664 -> 5650;
5664 -> 5641;
5665 -> 5641;
5665 -> 5622;
5666 -> 5641;
5666 -> 5622;
5667 -> 5641;
5667 -> 5622;
5668 -> 5641;
5668 -> 5622;
5669 -> 5641;
5669 -> 5622;
5670 -> 5641;
5670 -> 5622;
5671 -> 5622;
5672 -> 5631;
5672 -> 5671;
5672 -> 5622;
5673 -> 5622;
5674 -> 5632;
5674 -> 5673;
5674 -> 5622;
5675 -> 5622;
5676 -> 5639;
5676 -> 5675;
5676 -> 5622;
5677 -> 5632;
5677 -> 5641;
5677 -> 5622;
5678 -> 5631;
5678 -> 5641;
5678 -> 5622;
5679 -> 5636;
5679 -> 5641;
5679 -> 5622;
5680 -> 5637;
5680 -> 5641;
5680 -> 5622;
5681 -> 5638;
5681 -> 5641;
5681 -> 5622;
5682 -> 5639;
5682 -> 5641;
5682 -> 5622;
5683 -> 5359;
5684 -> 5359;
5685 -> 5684;
5686 -> 5685;
5686 -> 5359;
5687 -> 5685;
5687 -> 5359;
5688 -> 5359;
5689 -> 5359;
5690 -> 5359;
5691 -> 5689;
5691 -> 5690;
5692 -> 5690;
5693 -> 5691;
5693 -> 5692;
5694 -> 0;
5694 -> 5692;
5695 -> 5694;
5695 -> 5690;
5696 -> 5695;
5696 -> 5691;
5696 -> 5690;
5697 -> 5696;
5698 -> 2887;
5698 -> 5359;
5699 -> 5359;
5700 -> 5697;
5700 -> 5699;
5700 -> 5359;
5701 -> 5700;
5702 -> 2883;
5702 -> 5701;
5702 -> 5359;
5703 -> 5702;
5704 -> 5359;
5705 -> 5703;
5705 -> 5704;
5705 -> 5359;
5706 -> 5359;
5707 -> 3213;
5707 -> 5359;
5708 -> 5359;
5709 -> 5708;
5709 -> 5359;
5710 -> 5709;
5710 -> 5359;
5711 -> 5710;
5711 -> 5359;
5712 -> 5711;
5712 -> 5359;
5713 -> 5712;
5713 -> 5359;
5714 -> 5713;
5714 -> 5622;
5715 -> 5714;
5715 -> 5671;
5715 -> 5622;
5716 -> 5714;
5716 -> 5641;
5716 -> 5622;
5717 -> 5706;
5718 -> 5706;
5718 -> 5717;
5719 -> 5717;
5720 -> 5719;
5720 -> 5706;
5721 -> 5706;
5722 -> 5706;
5723 -> 5706;
5724 -> 5706;
5725 -> 5706;
5726 -> 5706;
5727 -> 5706;
5728 -> 5706;
5729 -> 5706;
5730 -> 5706;
5731 -> 5706;
5732 -> 5706;
5733 -> 5706;
5734 -> 5706;
5735 -> 5706;
5736 -> 5706;
5737 -> 5706;
5738 -> 5706;
5739 -> 5706;
5740 -> 5706;
5741 -> 5706;
5742 -> 5741;
5742 -> 5706;
5743 -> 5742;
5743 -> 5706;
5744 -> 5706;
5745 -> 5706;
5746 -> 5706;
5747 -> 5706;
5748 -> 5706;
5749 -> 5706;
5750 -> 5706;
5751 -> 5706;
5752 -> 5706;
5753 -> 5706;
5754 -> 5706;
5755 -> 5753;
5755 -> 5706;
5756 -> 5706;
5757 -> 5739;
5757 -> 5756;
5757 -> 5706;
5758 -> 5706;
5759 -> 5734;
5759 -> 5758;
5759 -> 5706;
5760 -> 5706;
5761 -> 5706;
5762 -> 5706;
5763 -> 5706;
5764 -> 5706;
5765 -> 5706;
5766 -> 5706;
5767 -> 3213;
5767 -> 5706;
5768 -> 5706;
5769 -> 5706;
5770 -> 5768;
5770 -> 5706;
5771 -> 5706;
5772 -> 5769;
5772 -> 5706;
5773 -> 5770;
5773 -> 5706;
5774 -> 5771;
5774 -> 5706;
5775 -> 5772;
5775 -> 5706;
5776 -> 5773;
5776 -> 5706;
5777 -> 5775;
5777 -> 5706;
5778 -> 5774;
5778 -> 5706;
5779 -> 5776;
5779 -> 5706;
5780 -> 5777;
5780 -> 5706;
5781 -> 5778;
5781 -> 5706;
5782 -> 5706;
5783 -> 5779;
5783 -> 5706;
5784 -> 5706;
5785 -> 5706;
5786 -> 5706;
5787 -> 5780;
5787 -> 5706;
5788 -> 5706;
5789 -> 5781;
5789 -> 5706;
5790 -> 5706;
5791 -> 5783;
5791 -> 5782;
5792 -> 5784;
5792 -> 5782;
5793 -> 5706;
5793 -> 5782;
5794 -> 5706;
5794 -> 5782;
5795 -> 5785;
5795 -> 5782;
5796 -> 5786;
5796 -> 5782;
5797 -> 5787;
5797 -> 5782;
5798 -> 5788;
5798 -> 5782;
5799 -> 5789;
5799 -> 5782;
5800 -> 5790;
5800 -> 5782;
5801 -> 5782;
5802 -> 5793;
5802 -> 5782;
5803 -> 5794;
5803 -> 5782;
5804 -> 5795;
5804 -> 5782;
5805 -> 5800;
5805 -> 5782;
5806 -> 5802;
5806 -> 5801;
5807 -> 5803;
5807 -> 5801;
5808 -> 5804;
5808 -> 5801;
5809 -> 5805;
5809 -> 5801;
5810 -> 5801;
5811 -> 5809;
5811 -> 5801;
5812 -> 5811;
5812 -> 5810;
5813 -> 5810;
5814 -> 5810;
5814 -> 5801;
5815 -> 5810;
5815 -> 5801;
5816 -> 5810;
5816 -> 5801;
5817 -> 5801;
5818 -> 5806;
5818 -> 5817;
5818 -> 5801;
5819 -> 5806;
5819 -> 5810;
5819 -> 5801;
5820 -> 5807;
5820 -> 5810;
5820 -> 5801;
5821 -> 5801;
5822 -> 5807;
5822 -> 5821;
5822 -> 5801;
5823 -> 5808;
5823 -> 5822;
5823 -> 5801;
5824 -> 5823;
5824 -> 5810;
5824 -> 5801;
5825 -> 5801;
5825 -> 5782;
5826 -> 5801;
5826 -> 5782;
5827 -> 5801;
5827 -> 5782;
5828 -> 5801;
5828 -> 5782;
5829 -> 5801;
5829 -> 5782;
5830 -> 5801;
5830 -> 5782;
5831 -> 5782;
5832 -> 5791;
5832 -> 5831;
5832 -> 5782;
5833 -> 5782;
5834 -> 5792;
5834 -> 5833;
5834 -> 5782;
5835 -> 5782;
5836 -> 5799;
5836 -> 5835;
5836 -> 5782;
5837 -> 5792;
5837 -> 5801;
5837 -> 5782;
5838 -> 5791;
5838 -> 5801;
5838 -> 5782;
5839 -> 5796;
5839 -> 5801;
5839 -> 5782;
5840 -> 5797;
5840 -> 5801;
5840 -> 5782;
5841 -> 5798;
5841 -> 5801;
5841 -> 5782;
5842 -> 5799;
5842 -> 5801;
5842 -> 5782;
5843 -> 5706;
5844 -> 5706;
5845 -> 5844;
5846 -> 5845;
5846 -> 5706;
5847 -> 5845;
5847 -> 5706;
5848 -> 5706;
5849 -> 5706;
5850 -> 5706;
5851 -> 5849;
5851 -> 5850;
5852 -> 5850;
5853 -> 5851;
5853 -> 5852;
5854 -> 0;
5854 -> 5852;
5855 -> 5854;
5855 -> 5850;
5856 -> 5855;
5856 -> 5851;
5856 -> 5850;
5857 -> 5856;
5858 -> 2887;
5858 -> 5706;
5859 -> 5706;
5860 -> 5857;
5860 -> 5859;
5860 -> 5706;
5861 -> 5860;
5862 -> 2883;
5862 -> 5861;
5862 -> 5706;
5863 -> 5862;
5864 -> 5706;
5865 -> 5863;
5865 -> 5864;
5865 -> 5706;
5866 -> 3497;
5866 -> 5706;
5867 -> 5085;
5867 -> 5706;
5868 -> 2855;
5869 -> 5867;
5869 -> 5868;
5869 -> 2855;
5874 -> 5870;
5874 -> 5873;
5875 -> 5871;
5875 -> 5873;
5876 -> 5872;
5876 -> 5873;
5877 -> 5873;
5878 -> 0;
5879 -> 5878;
5880 -> 0;
5881 -> 5880;
5882 -> 0;
5883 -> 5882;
5884 -> 0;
5885 -> 5884;
5886 -> 5867;
5886 -> 2855;
5887 -> 2855;
5888 -> 5886;
5888 -> 5887;
5889 -> 5887;
5890 -> 5888;
5890 -> 5889;
5890 -> 5887;
5891 -> 5887;
5892 -> 5888;
5892 -> 5891;
5893 -> 0;
5893 -> 5891;
5894 -> 5893;
5894 -> 5887;
5895 -> 5894;
5895 -> 2855;
5896 -> 5869;
5896 -> 5895;
5896 -> 2855;
5897 -> 5896;
5897 -> 2855;
5898 -> 5897;
5898 -> 2832;
5899 -> 2820;
5899 -> 5866;
5899 -> 2830;
5899 -> 2832;
5900 -> 5897;
5900 -> 2832;
5901 -> 2832;
5902 -> 5899;
5902 -> 5900;
5902 -> 5901;
5902 -> 5866;
5902 -> 2832;
5903 -> 5902;
5904 -> 2820;
5904 -> 5903;
5905 -> 5904;
5905 -> 5902;
5905 -> 5903;
5906 -> 5905;
5906 -> 5902;
5907 -> 2845;
5907 -> 5902;
5908 -> 5906;
5908 -> 5907;
5908 -> 5902;
5908 -> 2838;
5909 -> 2845;
5909 -> 5908;
5909 -> 2832;
5910 -> 2820;
5910 -> 5909;
5910 -> 2830;
5910 -> 2818;
5911 -> 2816;
5912 -> 5910;
5912 -> 5911;
5912 -> 2816;
5913 -> 5910;
5913 -> 2816;
5915 -> 5914;
5917 -> 5916;
5919 -> 5918;
5922 -> 5921;
5923 -> 0;
5924 -> 0;
5925 -> 0;
5926 -> 5925;
5928 -> 5923;
5928 -> 5924;
5928 -> 5926;
5928 -> 5927;
5929 -> 5928;
5931 -> 5930;
5933 -> 5932;
5935 -> 5934;
5937 -> 5936;
5938 -> 2800;
5938 -> 5913;
5939 -> 0;
5939 -> 5913;
5940 -> 2801;
5940 -> 5913;
5941 -> 5913;
5942 -> 5913;
5943 -> 5938;
5943 -> 5942;
5944 -> 5939;
5944 -> 5942;
5945 -> 5940;
5945 -> 5942;
5946 -> 5939;
5946 -> 5942;
5947 -> 5941;
5947 -> 5942;
5948 -> 5942;
5949 -> 5946;
5949 -> 5948;
5949 -> 5942;
5950 -> 5947;
5950 -> 5948;
5950 -> 5942;
5951 -> 5949;
5951 -> 5950;
5951 -> 5942;
5952 -> 5944;
5952 -> 5942;
5953 -> 5943;
5953 -> 5942;
5954 -> 5944;
5954 -> 5942;
5955 -> 5945;
5955 -> 5942;
5956 -> 5946;
5956 -> 5942;
5957 -> 5947;
5957 -> 5942;
5958 -> 5952;
5958 -> 5942;
5959 -> 5942;
5960 -> 5953;
5960 -> 5959;
5961 -> 5954;
5961 -> 5959;
5962 -> 5955;
5962 -> 5959;
5963 -> 5956;
5963 -> 5959;
5964 -> 5957;
5964 -> 5959;
5965 -> 5958;
5965 -> 5959;
5966 -> 5959;
5967 -> 5964;
5967 -> 5966;
5967 -> 5959;
5968 -> 5963;
5968 -> 5966;
5968 -> 5959;
5969 -> 5967;
5969 -> 5968;
5969 -> 5959;
5970 -> 5959;
5971 -> 5960;
5971 -> 5959;
5972 -> 5961;
5972 -> 5959;
5973 -> 5970;
5973 -> 5959;
5974 -> 5965;
5974 -> 5959;
5975 -> 5959;
5976 -> 5971;
5976 -> 5975;
5977 -> 5972;
5977 -> 5975;
5978 -> 5973;
5978 -> 5975;
5979 -> 5974;
5979 -> 5975;
5980 -> 5977;
5980 -> 5975;
5981 -> 5975;
5982 -> 5980;
5982 -> 5981;
5983 -> 5976;
5983 -> 5981;
5984 -> 5981;
5985 -> 5982;
5985 -> 5984;
5985 -> 5981;
5986 -> 5982;
5986 -> 0;
5986 -> 5981;
5987 -> 5982;
5987 -> 5981;
5988 -> 5983;
5988 -> 5987;
5988 -> 5909;
5988 -> 5981;
5989 -> 5981;
5990 -> 5983;
5990 -> 5988;
5990 -> 5989;
5990 -> 5981;
5991 -> 5990;
5992 -> 0;
5992 -> 5991;
5993 -> 5991;
5994 -> 5993;
5994 -> 5992;
5994 -> 5991;
5995 -> 3414;
5995 -> 5993;
5995 -> 5992;
5995 -> 5994;
5996 -> 5983;
5996 -> 5988;
5996 -> 5991;
5997 -> 5992;
5997 -> 5991;
5998 -> 5991;
5999 -> 5996;
5999 -> 5997;
5999 -> 5998;
5999 -> 5992;
5999 -> 5995;
5999 -> 5988;
5999 -> 5991;
6000 -> 5982;
6000 -> 5990;
6001 -> 6000;
6001 -> 0;
6001 -> 5990;
6002 -> 6001;
6002 -> 5990;
6003 -> 6002;
6004 -> 6003;
6005 -> 6003;
6006 -> 6005;
6006 -> 5999;
6007 -> 6006;
6007 -> 6003;
6008 -> 0;
6008 -> 6003;
6009 -> 6003;
6010 -> 6007;
6010 -> 6009;
6011 -> 6008;
6011 -> 6009;
6012 -> 6010;
6012 -> 6011;
6012 -> 6009;
6013 -> 6003;
6013 -> 5999;
6014 -> 6003;
6014 -> 5999;
6015 -> 5990;
6016 -> 6014;
6016 -> 5990;
6017 -> 5990;
6018 -> 6016;
6018 -> 6017;
6019 -> 6017;
6020 -> 6018;
6020 -> 6019;
6020 -> 6017;
6021 -> 6018;
6021 -> 6017;
6022 -> 6017;
6022 -> 5990;
6023 -> 6014;
6023 -> 6022;
6024 -> 6000;
6024 -> 6022;
6025 -> 5983;
6025 -> 5999;
6025 -> 6022;
6026 -> 6022;
6027 -> 6026;
6028 -> 6027;
6028 -> 5999;
6029 -> 6027;
6029 -> 5999;
6030 -> 6029;
6030 -> 6026;
6031 -> 6026;
6031 -> 5999;
6032 -> 6031;
6032 -> 6022;
6033 -> 6022;
6034 -> 6023;
6034 -> 6033;
6035 -> 6024;
6035 -> 6033;
6036 -> 6025;
6036 -> 6033;
6037 -> 6032;
6037 -> 6033;
6038 -> 6035;
6038 -> 6000;
6038 -> 6033;
6039 -> 6033;
6040 -> 6038;
6040 -> 6039;
6041 -> 6034;
6041 -> 6039;
6042 -> 6039;
6043 -> 6041;
6043 -> 6042;
6044 -> 6042;
6045 -> 6043;
6045 -> 6031;
6045 -> 6044;
6045 -> 6042;
6046 -> 6045;
6047 -> 6043;
6047 -> 6046;
6048 -> 6046;
6049 -> 6047;
6049 -> 6031;
6049 -> 6046;
6050 -> 6049;
6051 -> 6047;
6051 -> 6050;
6052 -> 6050;
6053 -> 6051;
6053 -> 6031;
6053 -> 6052;
6053 -> 6050;
6054 -> 6053;
6055 -> 6053;
6056 -> 6051;
6056 -> 6055;
6057 -> 6055;
6058 -> 6056;
6058 -> 6057;
6059 -> 6057;
6060 -> 6058;
6060 -> 6059;
6061 -> 6059;
6061 -> 6057;
6062 -> 6058;
6062 -> 6055;
6063 -> 6055;
6064 -> 6062;
6064 -> 6063;
6065 -> 6064;
6065 -> 6055;
6066 -> 6055;
6067 -> 6066;
6067 -> 6055;
6068 -> 6056;
6068 -> 6031;
6068 -> 6055;
6069 -> 6065;
6069 -> 6068;
6069 -> 6031;
6069 -> 6055;
6070 -> 6069;
6070 -> 6055;
6071 -> 6055;
6072 -> 6071;
6072 -> 6053;
6073 -> 6054;
6073 -> 6072;
6073 -> 6071;
6073 -> 6053;
6074 -> 6054;
6074 -> 6053;
6075 -> 6053;
6076 -> 6074;
6076 -> 6075;
6077 -> 6075;
6078 -> 6076;
6078 -> 6073;
6078 -> 6077;
6078 -> 6075;
6079 -> 3635;
6079 -> 6078;
6080 -> 6051;
6080 -> 6069;
6080 -> 6053;
6081 -> 6079;
6081 -> 6053;
6082 -> 6053;
6083 -> 6080;
6083 -> 6081;
6083 -> 6082;
6083 -> 3634;
6083 -> 6069;
6083 -> 0;
6083 -> 6053;
6084 -> 6053;
6085 -> 6083;
6085 -> 6084;
6085 -> 6053;
6086 -> 6085;
6087 -> 6086;
6088 -> 6086;
6088 -> 6087;
6089 -> 6087;
6089 -> 6086;
6090 -> 6086;
6090 -> 6085;
6091 -> 6079;
6091 -> 6085;
6092 -> 6085;
6093 -> 6091;
6093 -> 6092;
6094 -> 6090;
6094 -> 6092;
6095 -> 6085;
6096 -> 6054;
6096 -> 6073;
6096 -> 6053;
6097 -> 6049;
6098 -> 6049;
6099 -> 0;
6099 -> 6049;
6100 -> 0;
6100 -> 6049;
6101 -> 0;
6101 -> 6049;
6102 -> 0;
6102 -> 6049;
6103 -> 6049;
6104 -> 6103;
6104 -> 6083;
6105 -> 6104;
6105 -> 6103;
6106 -> 6105;
6106 -> 6049;
6107 -> 6106;
6108 -> 6106;
6109 -> 6107;
6109 -> 6106;
6110 -> 6106;
6111 -> 6109;
6111 -> 6110;
6112 -> 6047;
6112 -> 6110;
6113 -> 6110;
6114 -> 6110;
6115 -> 6112;
6115 -> 6114;
6116 -> 6114;
6117 -> 6115;
6117 -> 6116;
6118 -> 6116;
6118 -> 6114;
6119 -> 6115;
6119 -> 6110;
6120 -> 6110;
6121 -> 6119;
6121 -> 6120;
6122 -> 6121;
6122 -> 6110;
6123 -> 6110;
6124 -> 6110;
6125 -> 6110;
6126 -> 6112;
6126 -> 6125;
6127 -> 6126;
6127 -> 6110;
6128 -> 6112;
6128 -> 6083;
6128 -> 6110;
6129 -> 6122;
6129 -> 6128;
6129 -> 6083;
6129 -> 6110;
6130 -> 6113;
6130 -> 6110;
6131 -> 6130;
6131 -> 6106;
6132 -> 6108;
6132 -> 6106;
6133 -> 6106;
6134 -> 6132;
6134 -> 6133;
6135 -> 6047;
6135 -> 6133;
6136 -> 6133;
6137 -> 6135;
6137 -> 6136;
6138 -> 6137;
6138 -> 6129;
6138 -> 6136;
6139 -> 6136;
6140 -> 6138;
6140 -> 6139;
6141 -> 6139;
6141 -> 6136;
6142 -> 6138;
6142 -> 6133;
6143 -> 6133;
6144 -> 6142;
6144 -> 6143;
6145 -> 6144;
6145 -> 6133;
6146 -> 6133;
6147 -> 6133;
6148 -> 6135;
6148 -> 6147;
6149 -> 6148;
6149 -> 6129;
6149 -> 6147;
6150 -> 6149;
6150 -> 6133;
6151 -> 6135;
6151 -> 6129;
6151 -> 6133;
6152 -> 6145;
6152 -> 6151;
6152 -> 6129;
6152 -> 6133;
6153 -> 6145;
6153 -> 6152;
6154 -> 6152;
6155 -> 6142;
6155 -> 6152;
6156 -> 6150;
6156 -> 6153;
6156 -> 6152;
6157 -> 6142;
6157 -> 6156;
6158 -> 6135;
6158 -> 6156;
6159 -> 6152;
6159 -> 6156;
6160 -> 6156;
6161 -> 6156;
6162 -> 6157;
6162 -> 6161;
6163 -> 6158;
6163 -> 6161;
6164 -> 6159;
6164 -> 6161;
6165 -> 6160;
6165 -> 6161;
6167 -> 6166;
6168 -> 6161;
6169 -> 6165;
6169 -> 6168;
6170 -> 6168;
6171 -> 6169;
6171 -> 6168;
6172 -> 6169;
6172 -> 6168;
6173 -> 6165;
6173 -> 6161;
6174 -> 6165;
6174 -> 6161;
6175 -> 6165;
6175 -> 6161;
6176 -> 6165;
6176 -> 6161;
6177 -> 6165;
6177 -> 6161;
6178 -> 6165;
6178 -> 6161;
6179 -> 6165;
6179 -> 6161;
6180 -> 6161;
6181 -> 6162;
6181 -> 6180;
6181 -> 6161;
6182 -> 6161;
6183 -> 6163;
6183 -> 6182;
6183 -> 6161;
6184 -> 6164;
6184 -> 6152;
6184 -> 6161;
6185 -> 6164;
6185 -> 6165;
6185 -> 6161;
6186 -> 6163;
6186 -> 6165;
6186 -> 6161;
6187 -> 6161;
6188 -> 6161;
6189 -> 6161;
6190 -> 6161;
6191 -> 6162;
6191 -> 6190;
6192 -> 6191;
6192 -> 6161;
6193 -> 6164;
6193 -> 6161;
6194 -> 6165;
6194 -> 6173;
6194 -> 6161;
6195 -> 6189;
6195 -> 6161;
6196 -> 6187;
6196 -> 6161;
6197 -> 6188;
6197 -> 6161;
6198 -> 6192;
6198 -> 6193;
6198 -> 6194;
6198 -> 6195;
6198 -> 6196;
6198 -> 6197;
6198 -> 6153;
6198 -> 6152;
6198 -> 6161;
6199 -> 6198;
6199 -> 0;
6199 -> 6161;
6200 -> 6198;
6200 -> 6165;
6200 -> 6161;
6201 -> 6198;
6201 -> 0;
6201 -> 6161;
6202 -> 6198;
6202 -> 6165;
6202 -> 6161;
6203 -> 6160;
6203 -> 6156;
6204 -> 6134;
6204 -> 6203;
6204 -> 6108;
6204 -> 6169;
6204 -> 6171;
6204 -> 6172;
6204 -> 6198;
6204 -> 6186;
6204 -> 6175;
6204 -> 6202;
6204 -> 6200;
6204 -> 6178;
6204 -> 6179;
6204 -> 6185;
6204 -> 6152;
6204 -> 6156;
6205 -> 6152;
6205 -> 6156;
6206 -> 6160;
6206 -> 6156;
6207 -> 6146;
6207 -> 6205;
6207 -> 6206;
6207 -> 6156;
6208 -> 6204;
6209 -> 6204;
6210 -> 6204;
6211 -> 6204;
6212 -> 6204;
6213 -> 6204;
6214 -> 6204;
6214 -> 0;
6215 -> 6204;
6215 -> 0;
6216 -> 6204;
6217 -> 6146;
6217 -> 6216;
6217 -> 6204;
6218 -> 6146;
6218 -> 6133;
6219 -> 6218;
6219 -> 6106;
6220 -> 6106;
6221 -> 6220;
6221 -> 6204;
6222 -> 6221;
6222 -> 6106;
6223 -> 6219;
6223 -> 6106;
6224 -> 6108;
6224 -> 6106;
6225 -> 6106;
6226 -> 6223;
6226 -> 6225;
6227 -> 6224;
6227 -> 6225;
6228 -> 6047;
6228 -> 6225;
6229 -> 6225;
6230 -> 6228;
6230 -> 6229;
6231 -> 6230;
6231 -> 6204;
6231 -> 6229;
6232 -> 6229;
6233 -> 6231;
6233 -> 6232;
6234 -> 6232;
6234 -> 6229;
6235 -> 6231;
6235 -> 6225;
6236 -> 6225;
6237 -> 6235;
6237 -> 6236;
6238 -> 6237;
6238 -> 6225;
6239 -> 6228;
6239 -> 6204;
6239 -> 6225;
6240 -> 6238;
6240 -> 6239;
6240 -> 6204;
6240 -> 6225;
6241 -> 6240;
6242 -> 6238;
6242 -> 6240;
6243 -> 6226;
6243 -> 6240;
6244 -> 6241;
6244 -> 6240;
6245 -> 6240;
6246 -> 6242;
6246 -> 6245;
6247 -> 6243;
6247 -> 6245;
6248 -> 6244;
6248 -> 6245;
6249 -> 6228;
6249 -> 6245;
6250 -> 6248;
6250 -> 6241;
6250 -> 6245;
6251 -> 6245;
6252 -> 6248;
6252 -> 6245;
6253 -> 6251;
6253 -> 6245;
6254 -> 6247;
6254 -> 6252;
6254 -> 6253;
6254 -> 6146;
6254 -> 6241;
6254 -> 6245;
6255 -> 6254;
6255 -> 6245;
6256 -> 6254;
6256 -> 6245;
6257 -> 6238;
6257 -> 6240;
6258 -> 6226;
6258 -> 6240;
6259 -> 6241;
6259 -> 6240;
6260 -> 6240;
6261 -> 6257;
6261 -> 6260;
6262 -> 6258;
6262 -> 6260;
6263 -> 6259;
6263 -> 6260;
6264 -> 6228;
6264 -> 6260;
6265 -> 6263;
6265 -> 6254;
6265 -> 6260;
6266 -> 6265;
6267 -> 6240;
6268 -> 6256;
6268 -> 6267;
6268 -> 6240;
6270 -> 6269;
6271 -> 6235;
6271 -> 6268;
6272 -> 6228;
6272 -> 6268;
6273 -> 6240;
6273 -> 6268;
6274 -> 6256;
6274 -> 6268;
6275 -> 6266;
6275 -> 6268;
6276 -> 6268;
6277 -> 6271;
6277 -> 6276;
6278 -> 6272;
6278 -> 6276;
6279 -> 6273;
6279 -> 6276;
6280 -> 6274;
6280 -> 6276;
6281 -> 6275;
6281 -> 6276;
6282 -> 6276;
6283 -> 6277;
6283 -> 6282;
6283 -> 6276;
6284 -> 6276;
6285 -> 6278;
6285 -> 6284;
6285 -> 6276;
6286 -> 6279;
6286 -> 6240;
6286 -> 6276;
6287 -> 6277;
6287 -> 6276;
6288 -> 6278;
6288 -> 6276;
6289 -> 6276;
6290 -> 6276;
6291 -> 6287;
6291 -> 6290;
6292 -> 6288;
6292 -> 6290;
6293 -> 6289;
6293 -> 6290;
6294 -> 6290;
6295 -> 6291;
6295 -> 6294;
6295 -> 6290;
6296 -> 6276;
6297 -> 6296;
6297 -> 6276;
6298 -> 6276;
6299 -> 6279;
6299 -> 6276;
6300 -> 6296;
6300 -> 6276;
6301 -> 6298;
6301 -> 6276;
6302 -> 6299;
6302 -> 6300;
6302 -> 6301;
6302 -> 6289;
6302 -> 6240;
6302 -> 6291;
6302 -> 6290;
6302 -> 6292;
6302 -> 6297;
6302 -> 6276;
6303 -> 6276;
6304 -> 6302;
6304 -> 6303;
6305 -> 6302;
6305 -> 6303;
6306 -> 6302;
6306 -> 6303;
6307 -> 6303;
6308 -> 6304;
6308 -> 6307;
6309 -> 6308;
6309 -> 6303;
6310 -> 6305;
6310 -> 6303;
6311 -> 6303;
6312 -> 6310;
6312 -> 6311;
6313 -> 6309;
6313 -> 6311;
6314 -> 6311;
6315 -> 6313;
6315 -> 6314;
6316 -> 6315;
6316 -> 6311;
6317 -> 6312;
6317 -> 6311;
6318 -> 6311;
6319 -> 6317;
6319 -> 6318;
6320 -> 6316;
6320 -> 6318;
6321 -> 6318;
6322 -> 6320;
6322 -> 6321;
6323 -> 6322;
6323 -> 6318;
6324 -> 6323;
6325 -> 6323;
6325 -> 6324;
6326 -> 6324;
6327 -> 6325;
6327 -> 6326;
6328 -> 6326;
6329 -> 6327;
6329 -> 6302;
6329 -> 6328;
6329 -> 6326;
6330 -> 6324;
6331 -> 6325;
6331 -> 6302;
6331 -> 6324;
6332 -> 6331;
6332 -> 6323;
6333 -> 6323;
6334 -> 6318;
6335 -> 6320;
6335 -> 6302;
6335 -> 6334;
6335 -> 6318;
6336 -> 6320;
6336 -> 6302;
6336 -> 6319;
6336 -> 6318;
6337 -> 6320;
6337 -> 6302;
6337 -> 6319;
6337 -> 6318;
6338 -> 6276;
6339 -> 6337;
6339 -> 6338;
6339 -> 6276;
6340 -> 6276;
6341 -> 6337;
6341 -> 6340;
6341 -> 6276;
6342 -> 6341;
6342 -> 6337;
6342 -> 6276;
6343 -> 6342;
6343 -> 6276;
6344 -> 6280;
6344 -> 6343;
6345 -> 6281;
6345 -> 6343;
6346 -> 6343;
6347 -> 6343;
6347 -> 6346;
6348 -> 6343;
6348 -> 6346;
6349 -> 6343;
6349 -> 6346;
6350 -> 6344;
6350 -> 6346;
6351 -> 6345;
6351 -> 6346;
6352 -> 6343;
6352 -> 6346;
6353 -> 6343;
6353 -> 6346;
6354 -> 6343;
6354 -> 6346;
6355 -> 6346;
6356 -> 6354;
6356 -> 6355;
6357 -> 6355;
6358 -> 6356;
6358 -> 6355;
6359 -> 6356;
6359 -> 6355;
6360 -> 6354;
6360 -> 6346;
6361 -> 6354;
6361 -> 6346;
6362 -> 6354;
6362 -> 6346;
6363 -> 6354;
6363 -> 6346;
6364 -> 6354;
6364 -> 6346;
6365 -> 6354;
6365 -> 6346;
6366 -> 0;
6366 -> 6354;
6366 -> 6346;
6367 -> 0;
6367 -> 6354;
6367 -> 6346;
6368 -> 6270;
6368 -> 6354;
6368 -> 6346;
6369 -> 6354;
6369 -> 6346;
6370 -> 6348;
6370 -> 6354;
6370 -> 6346;
6371 -> 6346;
6372 -> 6347;
6372 -> 6371;
6373 -> 6372;
6373 -> 6346;
6374 -> 6346;
6375 -> 6346;
6376 -> 6349;
6376 -> 6346;
6377 -> 6354;
6377 -> 6360;
6377 -> 6346;
6378 -> 6374;
6378 -> 6346;
6379 -> 6373;
6379 -> 6376;
6379 -> 6377;
6379 -> 6378;
6379 -> 6337;
6379 -> 6240;
6379 -> 6346;
6380 -> 6350;
6380 -> 6354;
6380 -> 6346;
6381 -> 6351;
6381 -> 6354;
6381 -> 6346;
6382 -> 6349;
6382 -> 6354;
6382 -> 6346;
6383 -> 6346;
6384 -> 6383;
6384 -> 6346;
6385 -> 6346;
6386 -> 6346;
6387 -> 6350;
6387 -> 6386;
6387 -> 6346;
6388 -> 6387;
6388 -> 6346;
6389 -> 6388;
6390 -> 6350;
6390 -> 6389;
6391 -> 6390;
6391 -> 6379;
6391 -> 6389;
6392 -> 6383;
6392 -> 6388;
6393 -> 6385;
6393 -> 6388;
6394 -> 6391;
6394 -> 6392;
6394 -> 6393;
6394 -> 6388;
6394 -> 6353;
6394 -> 6379;
6394 -> 6384;
6395 -> 6394;
6395 -> 6388;
6396 -> 6388;
6397 -> 6394;
6397 -> 6396;
6398 -> 6397;
6398 -> 6388;
6399 -> 6398;
6400 -> 6398;
6400 -> 6399;
6401 -> 6399;
6402 -> 6400;
6402 -> 6401;
6403 -> 6401;
6404 -> 6402;
6404 -> 6394;
6404 -> 6403;
6404 -> 6401;
6405 -> 6399;
6406 -> 6400;
6406 -> 6394;
6406 -> 6399;
6407 -> 6406;
6407 -> 6398;
6408 -> 6398;
6409 -> 6388;
6410 -> 6394;
6410 -> 6409;
6410 -> 6388;
6411 -> 6394;
6411 -> 6388;
6412 -> 6346;
6413 -> 6346;
6414 -> 6351;
6414 -> 6413;
6414 -> 6346;
6415 -> 6414;
6415 -> 6346;
6416 -> 6346;
6417 -> 6415;
6417 -> 6346;
6418 -> 6417;
6418 -> 6346;
6419 -> 6347;
6419 -> 6418;
6420 -> 6354;
6420 -> 6418;
6421 -> 6350;
6421 -> 6418;
6422 -> 6352;
6422 -> 6418;
6423 -> 6394;
6423 -> 6418;
6424 -> 6416;
6424 -> 6418;
6425 -> 6418;
6426 -> 6419;
6426 -> 6425;
6427 -> 6420;
6427 -> 6425;
6428 -> 6421;
6428 -> 6425;
6429 -> 6422;
6429 -> 6425;
6430 -> 6423;
6430 -> 6425;
6431 -> 6424;
6431 -> 6425;
6432 -> 6425;
6433 -> 6425;
6434 -> 6429;
6434 -> 6394;
6434 -> 6433;
6434 -> 6425;
6435 -> 0;
6435 -> 6434;
6436 -> 6435;
6436 -> 6354;
6436 -> 6346;
6437 -> 6346;
6438 -> 6394;
6438 -> 6437;
6438 -> 6346;
6439 -> 6412;
6439 -> 6437;
6439 -> 6346;
6440 -> 6438;
6440 -> 6439;
6440 -> 6346;
6441 -> 6375;
6441 -> 6437;
6441 -> 6346;
6442 -> 6440;
6442 -> 6441;
6442 -> 6346;
6443 -> 6442;
6443 -> 6432;
6443 -> 6346;
6444 -> 6346;
6445 -> 6352;
6445 -> 6394;
6445 -> 6444;
6445 -> 6346;
6446 -> 6445;
6446 -> 6394;
6446 -> 6346;
6447 -> 6346;
6448 -> 6446;
6448 -> 6447;
6449 -> 6448;
6449 -> 6394;
6449 -> 6447;
6450 -> 0;
6450 -> 6449;
6451 -> 6445;
6451 -> 6394;
6451 -> 6346;
6452 -> 0;
6452 -> 6354;
6452 -> 6451;
6453 -> 6445;
6453 -> 6394;
6453 -> 6346;
6454 -> 6453;
6454 -> 6346;
6455 -> 6450;
6455 -> 0;
6455 -> 6346;
6456 -> 6349;
6456 -> 6346;
6457 -> 6347;
6457 -> 6346;
6458 -> 6354;
6458 -> 6452;
6458 -> 6346;
6459 -> 6346;
6460 -> 6454;
6460 -> 6459;
6461 -> 6455;
6461 -> 6459;
6462 -> 6456;
6462 -> 6459;
6463 -> 6457;
6463 -> 6459;
6464 -> 6458;
6464 -> 6459;
6465 -> 6459;
6466 -> 6460;
6466 -> 6465;
6466 -> 6459;
6467 -> 6459;
6468 -> 6467;
6468 -> 6459;
6469 -> 6459;
6470 -> 6463;
6470 -> 6469;
6471 -> 6470;
6471 -> 6394;
6471 -> 6469;
6472 -> 6471;
6472 -> 6459;
6473 -> 6462;
6473 -> 6459;
6474 -> 6467;
6474 -> 6459;
6475 -> 6472;
6475 -> 6473;
6475 -> 6474;
6475 -> 6394;
6475 -> 6240;
6475 -> 6468;
6475 -> 6459;
6476 -> 6460;
6476 -> 6459;
6477 -> 6476;
6477 -> 6346;
6478 -> 6349;
6478 -> 6346;
6479 -> 6347;
6479 -> 6346;
6480 -> 6346;
6481 -> 6477;
6481 -> 6480;
6482 -> 6478;
6482 -> 6480;
6483 -> 6479;
6483 -> 6480;
6484 -> 6480;
6485 -> 6483;
6485 -> 6484;
6486 -> 6485;
6486 -> 6475;
6486 -> 6484;
6487 -> 6486;
6487 -> 6480;
6488 -> 6482;
6488 -> 6480;
6489 -> 6480;
6490 -> 6487;
6490 -> 6488;
6490 -> 6489;
6490 -> 6475;
6490 -> 6240;
6490 -> 6480;
6491 -> 6490;
6491 -> 6480;
6492 -> 6481;
6492 -> 6491;
6493 -> 6492;
6493 -> 6346;
6494 -> 6354;
6494 -> 6370;
6494 -> 6346;
6495 -> 6346;
6496 -> 6493;
6496 -> 6495;
6497 -> 6494;
6497 -> 6495;
6498 -> 6496;
6498 -> 6495;
6499 -> 6497;
6499 -> 6495;
6500 -> 6495;
6501 -> 6495;
6502 -> 6498;
6502 -> 6501;
6503 -> 6499;
6503 -> 6501;
6504 -> 6500;
6504 -> 6501;
6505 -> 6501;
6506 -> 6502;
6506 -> 6505;
6507 -> 6506;
6507 -> 6501;
6508 -> 6501;
6509 -> 6501;
6510 -> 6509;
6510 -> 6495;
6511 -> 6496;
6511 -> 6510;
6512 -> 0;
6513 -> 0;
6514 -> 0;
6515 -> 6514;
6517 -> 6512;
6517 -> 6513;
6517 -> 6515;
6517 -> 6516;
6518 -> 6517;
6519 -> 0;
6520 -> 0;
6521 -> 0;
6522 -> 6521;
6522 -> 0;
6523 -> 6522;
6525 -> 6519;
6525 -> 6520;
6525 -> 6523;
6525 -> 6524;
6526 -> 6525;
6527 -> 6511;
6527 -> 6346;
6528 -> 6450;
6528 -> 6346;
6529 -> 6346;
6530 -> 6346;
6531 -> 6527;
6531 -> 6530;
6532 -> 6529;
6532 -> 6530;
6533 -> 6528;
6533 -> 6530;
6534 -> 6531;
6534 -> 6530;
6535 -> 6532;
6535 -> 0;
6535 -> 6530;
6536 -> 6532;
6536 -> 6530;
6537 -> 6531;
6537 -> 6536;
6538 -> 6536;
6539 -> 6537;
6539 -> 6538;
6540 -> 6538;
6541 -> 6539;
6541 -> 6540;
6542 -> 6540;
6543 -> 6541;
6543 -> 6542;
6544 -> 6542;
6545 -> 6543;
6545 -> 6544;
6546 -> 6545;
6546 -> 6544;
6547 -> 6546;
6547 -> 6542;
6548 -> 6547;
6548 -> 6540;
6549 -> 6548;
6549 -> 6538;
6550 -> 6538;
6551 -> 6549;
6551 -> 6550;
6552 -> 6531;
6552 -> 6530;
6553 -> 6532;
6553 -> 6530;
6554 -> 6533;
6554 -> 6530;
6555 -> 6530;
6556 -> 6552;
6556 -> 6555;
6557 -> 6553;
6557 -> 6555;
6558 -> 6554;
6558 -> 6555;
6559 -> 0;
6561 -> 6559;
6561 -> 6560;
6562 -> 6560;
6563 -> 6562;
6564 -> 6561;
6564 -> 0;
6564 -> 6560;
6565 -> 6561;
6565 -> 6562;
6565 -> 6560;
6566 -> 6560;
6567 -> 6556;
6567 -> 6555;
6568 -> 6557;
6568 -> 6555;
6569 -> 6558;
6569 -> 6555;
6570 -> 6555;
6571 -> 6569;
6571 -> 6570;
6572 -> 6571;
6572 -> 6554;
6572 -> 6570;
6573 -> 6566;
6573 -> 6572;
6574 -> 6555;
6575 -> 6555;
6576 -> 6567;
6576 -> 6575;
6577 -> 6568;
6577 -> 6575;
6578 -> 6573;
6578 -> 6575;
6579 -> 6574;
6579 -> 6575;
6580 -> 6576;
6580 -> 6575;
6581 -> 6580;
6581 -> 6575;
6582 -> 6576;
6582 -> 6581;
6583 -> 6581;
6584 -> 6582;
6584 -> 6583;
6585 -> 6583;
6586 -> 6584;
6586 -> 6585;
6587 -> 6585;
6588 -> 6586;
6588 -> 6587;
6589 -> 6587;
6590 -> 6588;
6590 -> 6589;
6591 -> 6590;
6591 -> 6589;
6592 -> 6591;
6592 -> 6587;
6593 -> 6592;
6593 -> 6585;
6594 -> 6593;
6594 -> 6583;
6595 -> 6583;
6596 -> 6594;
6596 -> 6595;
6597 -> 6577;
6597 -> 0;
6597 -> 6575;
6598 -> 6575;
6599 -> 6596;
6599 -> 6598;
6599 -> 6575;
6600 -> 6575;
6601 -> 6578;
6601 -> 6600;
6601 -> 6575;
6602 -> 6576;
6602 -> 6579;
6602 -> 6575;
6603 -> 6577;
6603 -> 6579;
6603 -> 6575;
6604 -> 6578;
6604 -> 6579;
6604 -> 6575;
6605 -> 6574;
6605 -> 6530;
6606 -> 6605;
6606 -> 6346;
6607 -> 6606;
6607 -> 6346;
6608 -> 6349;
6608 -> 6346;
6609 -> 6347;
6609 -> 6346;
6610 -> 6354;
6610 -> 6370;
6610 -> 6346;
6611 -> 6346;
6612 -> 6607;
6612 -> 6611;
6613 -> 6608;
6613 -> 6611;
6614 -> 6609;
6614 -> 6611;
6615 -> 6610;
6615 -> 6611;
6616 -> 6610;
6616 -> 6611;
6617 -> 6611;
6618 -> 6612;
6618 -> 6617;
6619 -> 6618;
6619 -> 6602;
6619 -> 6617;
6620 -> 6619;
6620 -> 6617;
6621 -> 6620;
6621 -> 6611;
6622 -> 6611;
6623 -> 6615;
6623 -> 6622;
6624 -> 6622;
6625 -> 6623;
6625 -> 6624;
6626 -> 6624;
6627 -> 6625;
6627 -> 6626;
6628 -> 6626;
6629 -> 6627;
6629 -> 6628;
6630 -> 6628;
6631 -> 6629;
6631 -> 6630;
6632 -> 6631;
6632 -> 6630;
6633 -> 6632;
6633 -> 6628;
6634 -> 6633;
6634 -> 6626;
6635 -> 6634;
6635 -> 6624;
6636 -> 6635;
6636 -> 6622;
6637 -> 6636;
6637 -> 6611;
6638 -> 6611;
6639 -> 6615;
6639 -> 6638;
6640 -> 6638;
6641 -> 6639;
6641 -> 6640;
6642 -> 6641;
6642 -> 6490;
6642 -> 6640;
6643 -> 6640;
6644 -> 6642;
6644 -> 6643;
6645 -> 6643;
6645 -> 6640;
6646 -> 6642;
6646 -> 6638;
6647 -> 6646;
6647 -> 6611;
6648 -> 6647;
6648 -> 6614;
6648 -> 6611;
6649 -> 6611;
6650 -> 6615;
6650 -> 6611;
6651 -> 6611;
6652 -> 6650;
6652 -> 6651;
6653 -> 6649;
6653 -> 6651;
6654 -> 6652;
6654 -> 6651;
6655 -> 6651;
6656 -> 6652;
6656 -> 6655;
6657 -> 6655;
6657 -> 6651;
6658 -> 6651;
6659 -> 6651;
6660 -> 6652;
6660 -> 6659;
6661 -> 0;
6661 -> 6659;
6662 -> 6660;
6662 -> 6490;
6662 -> 0;
6662 -> 6659;
6663 -> 6662;
6663 -> 6651;
6664 -> 6651;
6665 -> 6652;
6665 -> 6664;
6666 -> 6665;
6666 -> 6490;
6666 -> 6664;
6667 -> 6666;
6667 -> 6651;
6668 -> 6667;
6668 -> 6651;
6669 -> 6651;
6670 -> 6669;
6670 -> 6611;
6671 -> 6611;
6672 -> 6611;
6673 -> 6672;
6673 -> 6611;
6674 -> 6611;
6675 -> 6614;
6675 -> 6674;
6676 -> 6675;
6676 -> 6490;
6676 -> 6674;
6677 -> 6676;
6677 -> 6611;
6678 -> 6613;
6678 -> 6611;
6679 -> 6671;
6679 -> 6611;
6680 -> 6672;
6680 -> 6611;
6681 -> 6677;
6681 -> 6678;
6681 -> 6679;
6681 -> 6680;
6681 -> 6490;
6681 -> 6240;
6681 -> 6673;
6681 -> 6611;
6682 -> 6681;
6683 -> 6616;
6683 -> 6682;
6684 -> 6682;
6685 -> 6683;
6685 -> 6681;
6685 -> 6682;
6686 -> 6684;
6686 -> 6682;
6687 -> 6682;
6688 -> 6685;
6688 -> 6687;
6689 -> 6686;
6689 -> 6687;
6690 -> 6688;
6690 -> 6687;
6691 -> 6690;
6692 -> 6690;
6693 -> 6692;
6694 -> 6693;
6695 -> 6693;
6695 -> 6694;
6696 -> 6694;
6696 -> 6693;
6697 -> 6693;
6697 -> 6692;
6698 -> 6692;
6699 -> 6697;
6699 -> 6698;
6700 -> 6683;
6700 -> 6681;
6700 -> 6692;
6701 -> 6692;
6702 -> 6699;
6702 -> 6692;
6703 -> 6702;
6704 -> 6683;
6704 -> 6699;
6704 -> 6703;
6705 -> 6703;
6706 -> 6704;
6706 -> 6705;
6707 -> 6705;
6708 -> 6707;
6708 -> 6703;
6709 -> 6703;
6710 -> 6704;
6710 -> 6709;
6711 -> 6710;
6711 -> 6703;
6712 -> 6703;
6713 -> 6711;
6713 -> 6712;
6714 -> 6712;
6715 -> 6713;
6715 -> 6714;
6716 -> 6714;
6717 -> 6716;
6717 -> 6712;
6718 -> 6712;
6719 -> 6713;
6719 -> 6718;
6720 -> 6719;
6720 -> 6699;
6720 -> 6718;
6721 -> 6720;
6721 -> 6714;
6722 -> 6720;
6722 -> 6718;
6723 -> 6722;
6723 -> 6699;
6723 -> 6718;
6724 -> 6723;
6724 -> 6714;
6725 -> 6723;
6725 -> 6718;
6726 -> 6718;
6727 -> 6726;
6727 -> 6712;
6728 -> 6727;
6728 -> 6717;
6728 -> 6712;
6729 -> 6728;
6729 -> 6692;
6730 -> 6692;
6731 -> 6729;
6731 -> 6730;
6732 -> 6731;
6732 -> 6730;
6733 -> 0;
6733 -> 6732;
6734 -> 6733;
6734 -> 6683;
6734 -> 6692;
6735 -> 6728;
6735 -> 6682;
6736 -> 6735;
6736 -> 6681;
6737 -> 6681;
6738 -> 6736;
6738 -> 6737;
6738 -> 6681;
6739 -> 6612;
6739 -> 6738;
6740 -> 6739;
6740 -> 6346;
6741 -> 6349;
6741 -> 6346;
6742 -> 6347;
6742 -> 6346;
6743 -> 6346;
6744 -> 6740;
6744 -> 6743;
6745 -> 6741;
6745 -> 6743;
6746 -> 6742;
6746 -> 6743;
6747 -> 6743;
6748 -> 6747;
6748 -> 6743;
6749 -> 6743;
6750 -> 6746;
6750 -> 6749;
6751 -> 6750;
6751 -> 6699;
6751 -> 6749;
6752 -> 6751;
6752 -> 6743;
6753 -> 6745;
6753 -> 6743;
6754 -> 6747;
6754 -> 6743;
6755 -> 6752;
6755 -> 6753;
6755 -> 6754;
6755 -> 6699;
6755 -> 6734;
6755 -> 6240;
6755 -> 6748;
6755 -> 6743;
6756 -> 6755;
6756 -> 6743;
6757 -> 6743;
6758 -> 6744;
6758 -> 6757;
6759 -> 6758;
6759 -> 6602;
6759 -> 6757;
6760 -> 6757;
6761 -> 6759;
6761 -> 6760;
6762 -> 6758;
6762 -> 6604;
6762 -> 6760;
6763 -> 6761;
6763 -> 6760;
6764 -> 6763;
6764 -> 6757;
6765 -> 6764;
6765 -> 6743;
6766 -> 6765;
6766 -> 6743;
6767 -> 6755;
6767 -> 6743;
6768 -> 6743;
6769 -> 6766;
6769 -> 6768;
6770 -> 6767;
6770 -> 6768;
6771 -> 6767;
6771 -> 6768;
6772 -> 6769;
6772 -> 6768;
6773 -> 6772;
6773 -> 6755;
6773 -> 6768;
6774 -> 6770;
6774 -> 6768;
6775 -> 6768;
6776 -> 6768;
6777 -> 6774;
6777 -> 6776;
6778 -> 6775;
6778 -> 6776;
6779 -> 6777;
6779 -> 6778;
6779 -> 6776;
6780 -> 6777;
6780 -> 6755;
6780 -> 6776;
6781 -> 6780;
6782 -> 6781;
6782 -> 6778;
6782 -> 6776;
6783 -> 6776;
6784 -> 6783;
6784 -> 6778;
6784 -> 6776;
6785 -> 6776;
6786 -> 6785;
6786 -> 6778;
6786 -> 6776;
6787 -> 6769;
6787 -> 6768;
6788 -> 6768;
6789 -> 6787;
6789 -> 6788;
6790 -> 6775;
6790 -> 6788;
6791 -> 6788;
6792 -> 6789;
6792 -> 6791;
6793 -> 6791;
6793 -> 6788;
6794 -> 6789;
6794 -> 6793;
6795 -> 6793;
6796 -> 6794;
6796 -> 6795;
6797 -> 6790;
6797 -> 6795;
6798 -> 6795;
6799 -> 6796;
6799 -> 6798;
6800 -> 0;
6800 -> 6798;
6801 -> 6800;
6801 -> 6795;
6802 -> 6801;
6802 -> 6795;
6803 -> 6795;
6804 -> 6802;
6804 -> 6803;
6805 -> 6797;
6805 -> 6803;
6806 -> 6804;
6806 -> 0;
6806 -> 6803;
6807 -> 6804;
6807 -> 6806;
6808 -> 6796;
6808 -> 6795;
6809 -> 6795;
6810 -> 6796;
6810 -> 6809;
6811 -> 6810;
6811 -> 6773;
6811 -> 6809;
6812 -> 6811;
6812 -> 6795;
6813 -> 6795;
6814 -> 6812;
6814 -> 6795;
6815 -> 6812;
6815 -> 6814;
6816 -> 6815;
6816 -> 6795;
6817 -> 6812;
6817 -> 6795;
6818 -> 6801;
6818 -> 6807;
6818 -> 6795;
6819 -> 6818;
6819 -> 6816;
6819 -> 6795;
6820 -> 6795;
6821 -> 6808;
6821 -> 6820;
6822 -> 6820;
6823 -> 6822;
6823 -> 6820;
6824 -> 6820;
6825 -> 6823;
6825 -> 6824;
6826 -> 6821;
6826 -> 6824;
6827 -> 6824;
6828 -> 6826;
6828 -> 6827;
6829 -> 6827;
6830 -> 6829;
6830 -> 6824;
6831 -> 6824;
6832 -> 6826;
6832 -> 6831;
6833 -> 6832;
6833 -> 6773;
6833 -> 6831;
6834 -> 6833;
6834 -> 6824;
6835 -> 6824;
6836 -> 6834;
6836 -> 6835;
6837 -> 6835;
6837 -> 6824;
6838 -> 6830;
6838 -> 6837;
6838 -> 6824;
6839 -> 6824;
6840 -> 6826;
6840 -> 6839;
6841 -> 6840;
6841 -> 6839;
6842 -> 6841;
6842 -> 6773;
6842 -> 6839;
6843 -> 6842;
6843 -> 6824;
6844 -> 6824;
6845 -> 6843;
6845 -> 6844;
6846 -> 6824;
6847 -> 6845;
6847 -> 6846;
6848 -> 6846;
6848 -> 6824;
6849 -> 6824;
6850 -> 6838;
6850 -> 6848;
6850 -> 6824;
6851 -> 6824;
6852 -> 6826;
6852 -> 6851;
6853 -> 6852;
6853 -> 6773;
6853 -> 6851;
6854 -> 6853;
6854 -> 6824;
6855 -> 6854;
6855 -> 3303;
6855 -> 6824;
6856 -> 6850;
6856 -> 6855;
6856 -> 6824;
6857 -> 6824;
6858 -> 6824;
6859 -> 6858;
6859 -> 6795;
6860 -> 6808;
6860 -> 6795;
6861 -> 6775;
6861 -> 6784;
6861 -> 6768;
6862 -> 6771;
6862 -> 6861;
6863 -> 6860;
6863 -> 6862;
6864 -> 6863;
6864 -> 6765;
6864 -> 6743;
6865 -> 6864;
6865 -> 6743;
6866 -> 6865;
6866 -> 6354;
6866 -> 6346;
6867 -> 6373;
6867 -> 6346;
6868 -> 6353;
6868 -> 6346;
6869 -> 6352;
6869 -> 6346;
6870 -> 6354;
6870 -> 6380;
6870 -> 6346;
6871 -> 6394;
6871 -> 6346;
6872 -> 6354;
6872 -> 6381;
6872 -> 6346;
6873 -> 6415;
6873 -> 6346;
6874 -> 6346;
6875 -> 6867;
6875 -> 6874;
6876 -> 6868;
6876 -> 6874;
6877 -> 6869;
6877 -> 6874;
6878 -> 6870;
6878 -> 6874;
6879 -> 6871;
6879 -> 6874;
6880 -> 6872;
6880 -> 6874;
6881 -> 6873;
6881 -> 6874;
6882 -> 6874;
6883 -> 6879;
6883 -> 6882;
6883 -> 6874;
6884 -> 6878;
6884 -> 6882;
6884 -> 6874;
6885 -> 6883;
6885 -> 6884;
6885 -> 6874;
6886 -> 6874;
6887 -> 6881;
6887 -> 6886;
6887 -> 6874;
6888 -> 6880;
6888 -> 6886;
6888 -> 6874;
6889 -> 6887;
6889 -> 6888;
6889 -> 6874;
6890 -> 6874;
6891 -> 6879;
6891 -> 6890;
6891 -> 6874;
6892 -> 6874;
6893 -> 6881;
6893 -> 6892;
6893 -> 6874;
6894 -> 6877;
6894 -> 6874;
6895 -> 6879;
6895 -> 6874;
6896 -> 6874;
6897 -> 6894;
6897 -> 6895;
6897 -> 6896;
6897 -> 6876;
6897 -> 6773;
6897 -> 6874;
6898 -> 6897;
6898 -> 6896;
6899 -> 6897;
6899 -> 6896;
6900 -> 6897;
6900 -> 6896;
6901 -> 6898;
6901 -> 6896;
6902 -> 6899;
6902 -> 6896;
6903 -> 6896;
6904 -> 6901;
6904 -> 6903;
6905 -> 6902;
6905 -> 6903;
6906 -> 6900;
6906 -> 6903;
6907 -> 6904;
6907 -> 6903;
6908 -> 6907;
6908 -> 6903;
6909 -> 6907;
6909 -> 6903;
6910 -> 6905;
6910 -> 6903;
6911 -> 6903;
6912 -> 6909;
6912 -> 6911;
6913 -> 6910;
6913 -> 6911;
6914 -> 6906;
6914 -> 6911;
6915 -> 6912;
6915 -> 6911;
6916 -> 6915;
6916 -> 6911;
6917 -> 6913;
6917 -> 6916;
6918 -> 6916;
6919 -> 6916;
6919 -> 6918;
6920 -> 6917;
6920 -> 6918;
6921 -> 6914;
6921 -> 6918;
6922 -> 6919;
6922 -> 6921;
6922 -> 6918;
6923 -> 6922;
6924 -> 6891;
6924 -> 6923;
6924 -> 6874;
6925 -> 6893;
6925 -> 6874;
6926 -> 6891;
6926 -> 6893;
6926 -> 6874;
6927 -> 6874;
6928 -> 6927;
6928 -> 6346;
6929 -> 6346;
6930 -> 6354;
6930 -> 6929;
6931 -> 6929;
6932 -> 6930;
6932 -> 6931;
6933 -> 6932;
6933 -> 6452;
6933 -> 6931;
6934 -> 6933;
6934 -> 6929;
6935 -> 6934;
6936 -> 6930;
6936 -> 6935;
6937 -> 6935;
6938 -> 6936;
6938 -> 6937;
6939 -> 6938;
6939 -> 6436;
6939 -> 6937;
6940 -> 6939;
6940 -> 6935;
6941 -> 6940;
6941 -> 6934;
6942 -> 6934;
6943 -> 6941;
6944 -> 6943;
6944 -> 6346;
6945 -> 6928;
6945 -> 6944;
6945 -> 6346;
6946 -> 6346;
6947 -> 6869;
6947 -> 6946;
6948 -> 6947;
6948 -> 6946;
6949 -> 6946;
6950 -> 6948;
6950 -> 6949;
6950 -> 6923;
6950 -> 6946;
6951 -> 6945;
6951 -> 6950;
6951 -> 6346;
6952 -> 6951;
6952 -> 6346;
6953 -> 6952;
6954 -> 6354;
6954 -> 6380;
6954 -> 6953;
6954 -> 6952;
6955 -> 6354;
6955 -> 6954;
6956 -> 0;
6956 -> 6954;
6957 -> 6954;
6958 -> 6955;
6958 -> 6957;
6959 -> 6956;
6959 -> 6957;
6960 -> 6354;
6960 -> 6380;
6960 -> 6957;
6961 -> 6959;
6961 -> 0;
6961 -> 6957;
6962 -> 6958;
6962 -> 6957;
6963 -> 6959;
6963 -> 6957;
6964 -> 6957;
6965 -> 6962;
6965 -> 6964;
6966 -> 6963;
6966 -> 6964;
6967 -> 6960;
6967 -> 6964;
6968 -> 6964;
6969 -> 6967;
6969 -> 6923;
6969 -> 6968;
6969 -> 6964;
6970 -> 6969;
6971 -> 6965;
6971 -> 6970;
6972 -> 6971;
6972 -> 6370;
6972 -> 6970;
6973 -> 6972;
6973 -> 6969;
6974 -> 6967;
6974 -> 6923;
6974 -> 6969;
6975 -> 0;
6975 -> 6969;
6976 -> 6969;
6977 -> 6973;
6977 -> 6976;
6978 -> 6974;
6978 -> 6976;
6979 -> 6975;
6979 -> 6976;
6980 -> 6977;
6980 -> 6976;
6981 -> 6978;
6981 -> 6976;
6982 -> 6979;
6982 -> 6976;
6983 -> 6976;
6984 -> 6981;
6984 -> 6983;
6985 -> 6982;
6985 -> 6983;
6986 -> 6977;
6986 -> 6983;
6987 -> 6985;
6987 -> 6984;
6988 -> 6987;
6988 -> 6984;
6989 -> 6986;
6989 -> 6984;
6990 -> 6965;
6990 -> 6967;
6990 -> 6969;
6992 -> 6991;
6994 -> 6993;
6997 -> 6995;
6997 -> 6996;
6998 -> 6997;
7001 -> 6999;
7001 -> 7000;
7002 -> 7001;
7005 -> 7003;
7005 -> 7004;
7006 -> 7005;
7009 -> 7007;
7009 -> 7008;
7010 -> 7009;
7013 -> 7011;
7013 -> 7012;
7014 -> 7013;
7017 -> 7015;
7017 -> 7016;
7018 -> 7017;
7021 -> 7019;
7021 -> 7020;
7022 -> 7021;
7025 -> 7023;
7025 -> 7024;
7026 -> 7025;
7029 -> 7027;
7029 -> 7028;
7030 -> 7029;
7033 -> 7031;
7033 -> 7032;
7034 -> 7033;
7037 -> 7035;
7037 -> 7036;
7038 -> 7037;
7041 -> 7039;
7041 -> 7040;
7042 -> 7041;
7045 -> 7043;
7045 -> 7044;
7046 -> 7045;
7048 -> 7047;
7050 -> 7049;
7053 -> 7051;
7053 -> 7052;
7054 -> 7053;
7057 -> 7055;
7057 -> 7056;
7058 -> 7057;
7061 -> 7059;
7061 -> 7060;
7062 -> 7061;
7065 -> 7063;
7065 -> 7064;
7066 -> 7065;
7069 -> 7067;
7069 -> 7068;
7070 -> 7069;
7073 -> 7071;
7073 -> 7072;
7074 -> 7073;
7075 -> 6994;
7076 -> 7050;
7077 -> 6969;
7078 -> 6967;
7078 -> 6923;
7078 -> 7077;
7079 -> 7078;
7079 -> 6923;
7079 -> 6992;
7079 -> 7077;
7080 -> 7079;
7080 -> 6994;
7080 -> 7077;
7081 -> 7080;
7081 -> 6969;
7082 -> 6969;
7083 -> 6969;
7084 -> 6966;
7084 -> 7083;
7085 -> 6967;
7085 -> 6923;
7085 -> 7083;
7086 -> 7084;
7086 -> 6994;
7086 -> 7083;
7087 -> 6994;
7087 -> 6992;
7087 -> 7083;
7088 -> 7085;
7088 -> 6923;
7088 -> 7087;
7088 -> 7083;
7089 -> 7084;
7089 -> 6994;
7089 -> 7083;
7090 -> 7089;
7090 -> 6992;
7090 -> 7083;
7091 -> 7088;
7091 -> 7090;
7091 -> 7083;
7092 -> 7091;
7092 -> 6998;
7092 -> 7083;
7093 -> 7092;
7093 -> 7085;
7093 -> 7083;
7094 -> 6969;
7095 -> 7094;
7095 -> 6957;
7096 -> 7095;
7096 -> 6954;
7097 -> 6952;
7098 -> 6354;
7098 -> 6381;
7098 -> 7097;
7098 -> 6952;
7099 -> 6951;
7099 -> 6346;
7100 -> 6379;
7100 -> 0;
7100 -> 6346;
7101 -> 6346;
7102 -> 6379;
7102 -> 0;
7102 -> 6346;
7103 -> 6346;
7104 -> 6276;
7105 -> 6343;
7105 -> 7104;
7106 -> 7105;
7106 -> 6452;
7106 -> 7104;
7107 -> 7106;
7107 -> 6276;
7108 -> 6276;
7109 -> 6343;
7109 -> 7108;
7110 -> 0;
7110 -> 7108;
7111 -> 7110;
7111 -> 6276;
7112 -> 6276;
7113 -> 7111;
7113 -> 7112;
7114 -> 7113;
7114 -> 7112;
7115 -> 7112;
7116 -> 7107;
7116 -> 7114;
7116 -> 6276;
7117 -> 6276;
7118 -> 6337;
7118 -> 7117;
7118 -> 6276;
7119 -> 7118;
7119 -> 7116;
7119 -> 6276;
7120 -> 6343;
7120 -> 6276;
7121 -> 6227;
7121 -> 7120;
7121 -> 6923;
7121 -> 6990;
7121 -> 7093;
7121 -> 6356;
7121 -> 6358;
7121 -> 6359;
7121 -> 6379;
7121 -> 6370;
7121 -> 6452;
7121 -> 6380;
7121 -> 6381;
7121 -> 6365;
7121 -> 6366;
7121 -> 6367;
7121 -> 6368;
7121 -> 6369;
7121 -> 6382;
7121 -> 6436;
7121 -> 6866;
7121 -> 6240;
7121 -> 0;
7121 -> 6602;
7121 -> 6603;
7121 -> 6604;
7121 -> 6565;
7121 -> 6268;
7122 -> 6106;
7123 -> 6131;
7123 -> 6106;
7124 -> 6219;
7124 -> 6106;
7125 -> 6108;
7125 -> 6106;
7126 -> 6106;
7127 -> 7123;
7127 -> 7126;
7128 -> 7124;
7128 -> 7126;
7129 -> 7125;
7129 -> 7126;
7130 -> 6047;
7130 -> 7126;
7131 -> 7126;
7132 -> 7130;
7132 -> 7131;
7133 -> 7132;
7133 -> 7121;
7133 -> 7131;
7134 -> 7131;
7135 -> 7133;
7135 -> 7134;
7136 -> 7134;
7136 -> 7131;
7137 -> 7133;
7137 -> 7126;
7138 -> 7126;
7139 -> 7137;
7139 -> 7138;
7140 -> 7139;
7140 -> 7126;
7141 -> 7130;
7141 -> 7121;
7141 -> 7126;
7142 -> 7140;
7142 -> 7141;
7142 -> 7121;
7142 -> 7126;
7143 -> 6106;
7144 -> 6107;
7144 -> 6106;
7145 -> 6108;
7145 -> 6106;
7146 -> 6098;
7146 -> 7145;
7146 -> 7142;
7146 -> 6106;
7147 -> 6108;
7147 -> 7146;
7147 -> 6106;
7148 -> 6107;
7148 -> 6106;
7149 -> 6219;
7149 -> 7147;
7149 -> 6106;
7150 -> 6098;
7150 -> 7149;
7150 -> 6049;
7151 -> 6047;
7151 -> 7149;
7151 -> 6049;
7153 -> 7152;
7154 -> 7152;
7155 -> 7150;
7155 -> 6049;
7156 -> 7154;
7156 -> 6049;
7157 -> 6098;
7157 -> 7155;
7157 -> 7156;
7157 -> 7149;
7157 -> 6049;
7158 -> 6049;
7159 -> 6098;
7159 -> 6049;
7160 -> 7159;
7160 -> 7157;
7160 -> 6049;
7161 -> 7160;
7162 -> 7160;
7163 -> 7158;
7163 -> 7162;
7164 -> 7161;
7164 -> 7162;
7165 -> 7164;
7165 -> 7162;
7166 -> 7163;
7166 -> 7165;
7167 -> 7158;
7167 -> 7161;
7167 -> 7160;
7168 -> 7160;
7168 -> 7167;
7169 -> 7168;
7169 -> 7162;
7170 -> 7169;
7170 -> 7165;
7171 -> 7160;
7171 -> 7168;
7172 -> 7168;
7173 -> 7168;
7173 -> 7172;
7174 -> 0;
7174 -> 7172;
7175 -> 7174;
7175 -> 7168;
7176 -> 7168;
7177 -> 7171;
7177 -> 7176;
7178 -> 0;
7178 -> 7176;
7179 -> 7178;
7179 -> 7168;
7180 -> 7175;
7180 -> 7179;
7180 -> 7168;
7181 -> 7171;
7181 -> 7168;
7182 -> 7181;
7182 -> 7162;
7183 -> 7182;
7183 -> 7165;
7184 -> 7181;
7185 -> 7181;
7185 -> 7184;
7186 -> 0;
7186 -> 7184;
7187 -> 7186;
7187 -> 7181;
7188 -> 7181;
7189 -> 7181;
7189 -> 7188;
7190 -> 0;
7190 -> 7188;
7191 -> 7190;
7191 -> 7181;
7192 -> 7187;
7192 -> 7191;
7192 -> 7181;
7193 -> 7181;
7193 -> 7188;
7194 -> 0;
7194 -> 7188;
7195 -> 7194;
7195 -> 7181;
7196 -> 7187;
7196 -> 7195;
7196 -> 7181;
7197 -> 6049;
7198 -> 6047;
7198 -> 7197;
7199 -> 7197;
7200 -> 7199;
7200 -> 7197;
7201 -> 7197;
7202 -> 7200;
7202 -> 7201;
7203 -> 7198;
7203 -> 7201;
7204 -> 7201;
7205 -> 7203;
7205 -> 7204;
7206 -> 7204;
7207 -> 7206;
7207 -> 7201;
7208 -> 7201;
7209 -> 7203;
7209 -> 7208;
7210 -> 7209;
7210 -> 7157;
7210 -> 7208;
7211 -> 7210;
7211 -> 7201;
7212 -> 7201;
7213 -> 7211;
7213 -> 7212;
7214 -> 7212;
7214 -> 7201;
7215 -> 7207;
7215 -> 7214;
7215 -> 7201;
7216 -> 7201;
7217 -> 7203;
7217 -> 7216;
7218 -> 7217;
7218 -> 7216;
7219 -> 7218;
7219 -> 7157;
7219 -> 7216;
7220 -> 7219;
7220 -> 7201;
7221 -> 7201;
7222 -> 7220;
7222 -> 7221;
7223 -> 7201;
7224 -> 7222;
7224 -> 7223;
7225 -> 7223;
7225 -> 7201;
7226 -> 7201;
7227 -> 7215;
7227 -> 7225;
7227 -> 7201;
7228 -> 7201;
7229 -> 7201;
7230 -> 7229;
7230 -> 6049;
7231 -> 6098;
7231 -> 7157;
7231 -> 6049;
7232 -> 6047;
7232 -> 7231;
7232 -> 6049;
7233 -> 7231;
7233 -> 6049;
7234 -> 7150;
7234 -> 7232;
7235 -> 6046;
7236 -> 6047;
7236 -> 7234;
7236 -> 7235;
7236 -> 6046;
7237 -> 7236;
7238 -> 6098;
7238 -> 7236;
7239 -> 7236;
7240 -> 7238;
7240 -> 7239;
7241 -> 7239;
7242 -> 0;
7242 -> 7239;
7243 -> 7241;
7243 -> 7242;
7243 -> 7240;
7243 -> 7234;
7243 -> 7239;
7244 -> 7243;
7244 -> 7241;
7245 -> 7244;
7245 -> 7243;
7245 -> 7241;
7246 -> 7243;
7246 -> 7241;
7247 -> 7241;
7248 -> 7246;
7248 -> 7247;
7249 -> 7247;
7250 -> 7248;
7250 -> 7249;
7251 -> 7250;
7251 -> 7245;
7251 -> 7249;
7252 -> 7251;
7252 -> 7247;
7253 -> 7247;
7254 -> 7247;
7255 -> 7254;
7255 -> 7241;
7256 -> 7246;
7256 -> 7245;
7256 -> 7255;
7257 -> 6047;
7257 -> 7256;
7257 -> 7236;
7258 -> 7256;
7258 -> 7236;
7259 -> 7236;
7260 -> 7236;
7261 -> 7257;
7261 -> 7260;
7261 -> 7236;
7262 -> 7256;
7262 -> 7257;
7262 -> 7261;
7263 -> 6047;
7263 -> 7262;
7263 -> 7261;
7264 -> 7262;
7264 -> 7261;
7265 -> 6046;
7266 -> 6098;
7266 -> 7265;
7266 -> 6046;
7267 -> 6098;
7267 -> 7263;
7267 -> 7266;
7268 -> 6045;
7269 -> 6039;
7270 -> 6039;
7271 -> 7270;
7271 -> 6039;
7272 -> 6040;
7272 -> 6039;
7273 -> 7270;
7273 -> 6039;
7274 -> 6041;
7274 -> 7267;
7274 -> 7272;
7274 -> 7273;
7274 -> 7271;
7274 -> 6039;
7275 -> 6039;
7276 -> 7275;
7276 -> 6039;
7277 -> 6040;
7277 -> 6039;
7278 -> 7275;
7278 -> 6039;
7279 -> 6041;
7279 -> 7274;
7279 -> 7277;
7279 -> 7278;
7279 -> 7276;
7279 -> 6039;
7280 -> 7274;
7280 -> 6039;
7281 -> 7280;
7281 -> 6033;
7282 -> 6035;
7282 -> 6033;
7283 -> 6036;
7283 -> 6033;
7284 -> 6037;
7284 -> 6033;
7285 -> 6033;
7286 -> 7281;
7286 -> 7285;
7287 -> 7282;
7287 -> 7285;
7288 -> 7283;
7288 -> 7285;
7289 -> 7284;
7289 -> 7285;
7290 -> 7285;
7291 -> 0;
7291 -> 7285;
7292 -> 7287;
7292 -> 6000;
7292 -> 0;
7292 -> 7285;
7293 -> 7285;
7294 -> 7285;
7295 -> 7287;
7295 -> 6000;
7295 -> 0;
7295 -> 7285;
7296 -> 0;
7296 -> 7295;
7297 -> 0;
7297 -> 7295;
7298 -> 7292;
7298 -> 7295;
7299 -> 7286;
7299 -> 7285;
7300 -> 7299;
7301 -> 7300;
7301 -> 7274;
7301 -> 7279;
7302 -> 7301;
7302 -> 7299;
7303 -> 7287;
7303 -> 6000;
7303 -> 7299;
7304 -> 7302;
7304 -> 7303;
7304 -> 7299;
7305 -> 7299;
7306 -> 7299;
7306 -> 7305;
7307 -> 0;
7307 -> 7305;
7308 -> 7307;
7308 -> 7299;
7309 -> 7308;
7309 -> 7296;
7309 -> 7299;
7310 -> 7299;
7311 -> 7299;
7311 -> 7310;
7312 -> 0;
7312 -> 7310;
7313 -> 7310;
7314 -> 7312;
7314 -> 7313;
7315 -> 7311;
7315 -> 7313;
7316 -> 7313;
7317 -> 7314;
7317 -> 7316;
7317 -> 7313;
7318 -> 7314;
7318 -> 7315;
7318 -> 7274;
7318 -> 7279;
7318 -> 7313;
7319 -> 7313;
7320 -> 7318;
7320 -> 7299;
7321 -> 7320;
7321 -> 7292;
7321 -> 7299;
7322 -> 7309;
7322 -> 7321;
7322 -> 7299;
7323 -> 7299;
7324 -> 7299;
7324 -> 7323;
7325 -> 7323;
7326 -> 7324;
7326 -> 7325;
7327 -> 7326;
7327 -> 7274;
7327 -> 7279;
7327 -> 7325;
7328 -> 7327;
7328 -> 7323;
7329 -> 0;
7329 -> 7328;
7330 -> 7329;
7330 -> 7299;
7331 -> 7322;
7331 -> 7330;
7331 -> 7299;
7332 -> 7296;
7332 -> 7299;
7333 -> 7299;
7333 -> 7332;
7334 -> 7332;
7335 -> 7333;
7335 -> 7334;
7336 -> 7334;
7337 -> 7335;
7337 -> 7274;
7337 -> 7279;
7337 -> 7336;
7338 -> 7337;
7338 -> 7279;
7338 -> 6998;
7338 -> 7336;
7339 -> 7336;
7340 -> 7338;
7340 -> 7339;
7340 -> 7336;
7341 -> 7340;
7341 -> 7334;
7342 -> 7341;
7343 -> 7335;
7343 -> 7342;
7344 -> 7342;
7345 -> 7343;
7345 -> 7344;
7346 -> 0;
7346 -> 7344;
7347 -> 7344;
7348 -> 7346;
7348 -> 7347;
7349 -> 7345;
7349 -> 7347;
7350 -> 7347;
7351 -> 7348;
7351 -> 7350;
7351 -> 7347;
7352 -> 7348;
7352 -> 7349;
7352 -> 7274;
7352 -> 7279;
7352 -> 7347;
7353 -> 7347;
7354 -> 7352;
7354 -> 7342;
7355 -> 7354;
7356 -> 0;
7356 -> 7354;
7357 -> 7355;
7358 -> 7343;
7358 -> 7357;
7359 -> 7358;
7359 -> 7274;
7359 -> 7279;
7359 -> 7357;
7360 -> 7359;
7360 -> 7355;
7361 -> 0;
7361 -> 7355;
7362 -> 7355;
7363 -> 7343;
7363 -> 7362;
7364 -> 0;
7364 -> 7362;
7365 -> 7362;
7366 -> 7364;
7366 -> 7365;
7367 -> 7363;
7367 -> 7365;
7368 -> 7365;
7369 -> 7366;
7369 -> 7368;
7369 -> 7365;
7370 -> 7366;
7370 -> 7367;
7370 -> 7274;
7370 -> 7279;
7370 -> 7365;
7371 -> 7370;
7371 -> 7355;
7372 -> 7360;
7372 -> 7371;
7372 -> 7355;
7373 -> 7355;
7374 -> 7343;
7374 -> 7373;
7375 -> 7373;
7376 -> 7374;
7376 -> 7375;
7377 -> 7375;
7378 -> 7376;
7378 -> 7377;
7379 -> 7377;
7380 -> 7378;
7380 -> 7379;
7381 -> 7379;
7382 -> 7380;
7382 -> 7381;
7383 -> 7381;
7384 -> 7382;
7384 -> 7274;
7384 -> 7279;
7384 -> 7383;
7385 -> 7383;
7386 -> 7384;
7386 -> 7385;
7387 -> 7385;
7387 -> 7383;
7388 -> 7384;
7388 -> 7381;
7389 -> 7381;
7390 -> 7389;
7390 -> 7381;
7391 -> 7381;
7392 -> 7388;
7392 -> 7381;
7393 -> 7382;
7393 -> 7381;
7394 -> 7381;
7395 -> 7381;
7396 -> 7392;
7396 -> 7395;
7397 -> 7393;
7397 -> 7395;
7398 -> 7394;
7398 -> 7395;
7399 -> 7396;
7399 -> 7395;
7400 -> 7395;
7401 -> 7397;
7401 -> 7400;
7402 -> 7401;
7402 -> 7274;
7402 -> 7279;
7402 -> 7400;
7403 -> 7397;
7403 -> 7395;
7404 -> 7395;
7405 -> 7399;
7405 -> 7404;
7406 -> 7402;
7406 -> 7404;
7407 -> 7403;
7407 -> 7404;
7408 -> 7404;
7409 -> 7405;
7409 -> 7408;
7409 -> 7404;
7410 -> 7389;
7410 -> 7381;
7411 -> 7391;
7411 -> 7381;
7412 -> 7405;
7412 -> 7410;
7412 -> 7411;
7412 -> 7394;
7412 -> 7404;
7412 -> 7406;
7412 -> 7407;
7412 -> 7274;
7412 -> 7390;
7412 -> 7381;
7413 -> 7412;
7413 -> 7394;
7414 -> 7394;
7415 -> 7412;
7415 -> 7414;
7416 -> 7415;
7416 -> 7394;
7417 -> 7416;
7418 -> 7416;
7418 -> 7417;
7419 -> 7417;
7420 -> 7418;
7420 -> 7419;
7421 -> 7419;
7422 -> 7420;
7422 -> 7412;
7422 -> 7421;
7422 -> 7419;
7423 -> 7417;
7424 -> 7418;
7424 -> 7412;
7424 -> 7417;
7425 -> 7424;
7425 -> 7416;
7426 -> 7416;
7427 -> 7394;
7428 -> 7412;
7428 -> 7427;
7428 -> 7394;
7429 -> 7412;
7429 -> 7394;
7430 -> 7381;
7431 -> 7412;
7431 -> 7430;
7431 -> 7381;
7432 -> 7412;
7432 -> 7382;
7432 -> 7381;
7433 -> 7382;
7433 -> 7412;
7433 -> 7432;
7434 -> 0;
7434 -> 7432;
7435 -> 7381;
7436 -> 7412;
7436 -> 7433;
7436 -> 7435;
7436 -> 7381;
7437 -> 7381;
7438 -> 7437;
7438 -> 7381;
7439 -> 7381;
7440 -> 7381;
7441 -> 7436;
7441 -> 7440;
7441 -> 7381;
7442 -> 7436;
7442 -> 7441;
7443 -> 7441;
7444 -> 7388;
7444 -> 7443;
7445 -> 7382;
7445 -> 7443;
7446 -> 7443;
7447 -> 7443;
7448 -> 7446;
7448 -> 7447;
7449 -> 7382;
7449 -> 7447;
7450 -> 0;
7450 -> 7447;
7451 -> 7447;
7452 -> 7450;
7452 -> 7451;
7453 -> 7449;
7453 -> 7451;
7454 -> 7451;
7455 -> 7452;
7455 -> 7454;
7455 -> 7451;
7456 -> 7452;
7456 -> 7453;
7456 -> 7433;
7456 -> 7451;
7457 -> 7456;
7457 -> 7443;
7458 -> 7439;
7458 -> 7443;
7459 -> 7443;
7460 -> 7444;
7460 -> 7459;
7461 -> 7445;
7461 -> 7459;
7462 -> 7457;
7462 -> 7459;
7463 -> 7446;
7463 -> 7459;
7464 -> 7446;
7464 -> 7459;
7465 -> 7445;
7465 -> 7459;
7466 -> 7446;
7466 -> 7459;
7467 -> 7458;
7467 -> 7459;
7468 -> 7460;
7468 -> 7459;
7469 -> 7461;
7469 -> 7459;
7470 -> 7462;
7470 -> 7459;
7471 -> 7463;
7471 -> 7459;
7472 -> 7464;
7472 -> 7433;
7472 -> 7459;
7473 -> 7465;
7473 -> 7459;
7474 -> 7466;
7474 -> 7459;
7475 -> 7467;
7475 -> 7459;
7476 -> 7459;
7477 -> 7468;
7477 -> 7476;
7478 -> 7469;
7478 -> 7476;
7479 -> 7470;
7479 -> 7476;
7480 -> 7471;
7480 -> 7476;
7481 -> 7472;
7481 -> 7476;
7482 -> 7472;
7482 -> 7476;
7483 -> 7472;
7483 -> 7476;
7484 -> 7472;
7484 -> 7476;
7485 -> 7473;
7485 -> 7476;
7486 -> 7472;
7486 -> 7476;
7487 -> 7474;
7487 -> 7476;
7488 -> 7475;
7488 -> 7476;
7489 -> 7483;
7489 -> 7476;
7490 -> 7486;
7490 -> 7476;
7491 -> 7476;
7492 -> 7490;
7492 -> 7491;
7493 -> 7476;
7494 -> 7476;
7495 -> 7489;
7495 -> 7494;
7496 -> 7493;
7496 -> 7494;
7497 -> 7492;
7497 -> 7494;
7498 -> 7495;
7498 -> 7494;
7499 -> 7496;
7499 -> 0;
7499 -> 7494;
7500 -> 7496;
7500 -> 7494;
7501 -> 7495;
7501 -> 7500;
7502 -> 7500;
7503 -> 7501;
7503 -> 7502;
7504 -> 7502;
7505 -> 7503;
7505 -> 7504;
7506 -> 7504;
7507 -> 7505;
7507 -> 7506;
7508 -> 7506;
7509 -> 7507;
7509 -> 7508;
7510 -> 7509;
7510 -> 7508;
7511 -> 7510;
7511 -> 7506;
7512 -> 7511;
7512 -> 7504;
7513 -> 7512;
7513 -> 7502;
7514 -> 7502;
7515 -> 7513;
7515 -> 7514;
7516 -> 7495;
7516 -> 7494;
7517 -> 7516;
7517 -> 7494;
7518 -> 7495;
7518 -> 7517;
7519 -> 7517;
7520 -> 7518;
7520 -> 7519;
7521 -> 7519;
7522 -> 7520;
7522 -> 7521;
7523 -> 7521;
7524 -> 7522;
7524 -> 7523;
7525 -> 7523;
7526 -> 7524;
7526 -> 7525;
7527 -> 7526;
7527 -> 7525;
7528 -> 7527;
7528 -> 7523;
7529 -> 7528;
7529 -> 7521;
7530 -> 7529;
7530 -> 7519;
7531 -> 7519;
7532 -> 7530;
7532 -> 7531;
7533 -> 7496;
7533 -> 0;
7533 -> 7494;
7534 -> 7494;
7535 -> 7532;
7535 -> 7534;
7535 -> 7494;
7536 -> 7494;
7537 -> 7497;
7537 -> 7536;
7537 -> 7494;
7538 -> 7494;
7538 -> 7476;
7539 -> 7486;
7539 -> 7433;
7539 -> 7482;
7539 -> 7476;
7540 -> 7539;
7540 -> 7476;
7541 -> 7477;
7541 -> 7540;
7542 -> 7478;
7542 -> 7540;
7543 -> 7480;
7543 -> 7540;
7544 -> 7481;
7544 -> 7540;
7545 -> 7538;
7545 -> 7540;
7546 -> 7484;
7546 -> 7540;
7547 -> 7485;
7547 -> 7540;
7548 -> 7488;
7548 -> 7540;
7549 -> 7540;
7550 -> 7541;
7550 -> 7549;
7551 -> 7542;
7551 -> 7549;
7552 -> 7543;
7552 -> 7549;
7553 -> 7544;
7553 -> 7549;
7554 -> 7545;
7554 -> 7549;
7555 -> 7546;
7555 -> 7549;
7556 -> 7547;
7556 -> 7549;
7557 -> 7540;
7557 -> 7549;
7558 -> 7548;
7558 -> 7549;
7559 -> 7540;
7559 -> 7549;
7561 -> 7560;
7562 -> 7549;
7563 -> 7559;
7563 -> 7562;
7564 -> 7562;
7565 -> 7563;
7565 -> 7562;
7566 -> 7559;
7566 -> 7549;
7567 -> 7559;
7567 -> 7549;
7568 -> 7559;
7568 -> 7549;
7569 -> 7559;
7569 -> 7549;
7570 -> 0;
7570 -> 7559;
7570 -> 7549;
7571 -> 7559;
7571 -> 7549;
7572 -> 7559;
7572 -> 7549;
7573 -> 7549;
7574 -> 7550;
7574 -> 7573;
7574 -> 7549;
7575 -> 7549;
7576 -> 7551;
7576 -> 7575;
7576 -> 7549;
7577 -> 7549;
7578 -> 7552;
7578 -> 7577;
7578 -> 7549;
7579 -> 7549;
7580 -> 7554;
7580 -> 7579;
7581 -> 7580;
7581 -> 7495;
7581 -> 7579;
7582 -> 7581;
7582 -> 7579;
7583 -> 7582;
7583 -> 7549;
7584 -> 7549;
7585 -> 7550;
7585 -> 7559;
7585 -> 7549;
7586 -> 7551;
7586 -> 7559;
7586 -> 7549;
7587 -> 7552;
7587 -> 7559;
7587 -> 7549;
7588 -> 7555;
7588 -> 7559;
7588 -> 7549;
7589 -> 0;
7589 -> 7549;
7590 -> 7555;
7590 -> 7433;
7590 -> 7549;
7591 -> 7590;
7592 -> 7550;
7592 -> 7591;
7593 -> 7592;
7593 -> 7590;
7594 -> 7555;
7594 -> 7590;
7595 -> 7559;
7595 -> 7567;
7595 -> 7590;
7596 -> 7559;
7596 -> 7568;
7596 -> 7590;
7597 -> 7593;
7597 -> 7594;
7597 -> 7595;
7597 -> 7596;
7597 -> 7433;
7597 -> 7590;
7598 -> 7553;
7598 -> 7590;
7599 -> 7590;
7600 -> 7554;
7600 -> 7599;
7601 -> 7600;
7601 -> 7495;
7601 -> 7599;
7602 -> 7600;
7602 -> 7497;
7602 -> 7599;
7603 -> 7601;
7603 -> 7590;
7604 -> 7557;
7604 -> 7590;
7605 -> 7555;
7605 -> 7590;
7606 -> 7550;
7606 -> 7590;
7607 -> 7589;
7607 -> 7590;
7608 -> 7590;
7609 -> 7603;
7609 -> 7608;
7610 -> 7604;
7610 -> 7608;
7611 -> 7605;
7611 -> 7608;
7612 -> 7606;
7612 -> 7608;
7613 -> 7607;
7613 -> 7608;
7614 -> 7608;
7615 -> 7609;
7615 -> 7614;
7615 -> 7608;
7616 -> 7612;
7616 -> 7597;
7616 -> 7608;
7617 -> 7609;
7617 -> 7590;
7618 -> 7555;
7618 -> 7590;
7619 -> 7550;
7619 -> 7590;
7620 -> 7590;
7621 -> 7617;
7621 -> 7620;
7622 -> 7618;
7622 -> 7620;
7623 -> 7619;
7623 -> 7620;
7624 -> 7623;
7624 -> 7616;
7624 -> 7620;
7625 -> 7621;
7625 -> 7624;
7626 -> 7625;
7626 -> 7590;
7627 -> 7590;
7628 -> 7554;
7628 -> 7627;
7629 -> 7627;
7630 -> 7628;
7630 -> 7497;
7630 -> 7629;
7631 -> 7630;
7631 -> 7624;
7631 -> 7629;
7632 -> 7631;
7632 -> 7590;
7633 -> 7590;
7634 -> 7626;
7634 -> 7633;
7635 -> 7632;
7635 -> 7633;
7636 -> 7554;
7636 -> 7633;
7637 -> 7636;
7637 -> 7633;
7638 -> 7634;
7638 -> 7633;
7639 -> 7635;
7639 -> 7633;
7640 -> 7633;
7641 -> 7637;
7641 -> 7640;
7642 -> 7638;
7642 -> 7640;
7643 -> 7639;
7643 -> 7640;
7644 -> 7636;
7644 -> 7497;
7644 -> 7640;
7645 -> 7642;
7645 -> 7640;
7646 -> 7641;
7646 -> 7496;
7646 -> 7640;
7647 -> 7643;
7647 -> 7640;
7648 -> 7640;
7649 -> 7645;
7649 -> 7648;
7650 -> 7646;
7650 -> 7648;
7651 -> 7647;
7651 -> 7648;
7652 -> 7649;
7652 -> 7648;
7653 -> 7652;
7653 -> 7648;
7654 -> 7649;
7654 -> 7653;
7655 -> 7653;
7656 -> 7654;
7656 -> 7655;
7657 -> 7655;
7658 -> 7656;
7658 -> 7657;
7659 -> 7657;
7660 -> 7658;
7660 -> 7659;
7661 -> 7659;
7662 -> 7660;
7662 -> 7661;
7663 -> 7662;
7663 -> 7661;
7664 -> 7663;
7664 -> 7659;
7665 -> 7664;
7665 -> 7657;
7666 -> 7665;
7666 -> 7655;
7667 -> 7655;
7668 -> 7666;
7668 -> 7667;
7669 -> 7650;
7669 -> 0;
7669 -> 7648;
7670 -> 7648;
7671 -> 7668;
7671 -> 7670;
7671 -> 7648;
7672 -> 7648;
7673 -> 7651;
7673 -> 7672;
7673 -> 7648;
7674 -> 7648;
7674 -> 7640;
7675 -> 7674;
7675 -> 7590;
7676 -> 7590;
7677 -> 7551;
7677 -> 7676;
7678 -> 0;
7678 -> 7676;
7679 -> 7678;
7679 -> 7590;
7680 -> 7679;
7680 -> 7590;
7681 -> 7551;
7681 -> 7680;
7682 -> 7675;
7682 -> 7590;
7683 -> 7555;
7683 -> 7590;
7684 -> 7550;
7684 -> 7590;
7685 -> 7681;
7685 -> 7590;
7686 -> 7556;
7686 -> 7590;
7687 -> 7590;
7688 -> 7682;
7688 -> 7687;
7689 -> 7683;
7689 -> 7687;
7690 -> 7684;
7690 -> 7687;
7691 -> 7685;
7691 -> 7687;
7692 -> 7686;
7692 -> 7687;
7693 -> 7687;
7694 -> 7688;
7694 -> 7693;
7695 -> 7694;
7695 -> 7649;
7695 -> 7693;
7696 -> 7695;
7696 -> 7693;
7697 -> 7696;
7697 -> 7687;
7698 -> 7687;
7699 -> 7691;
7699 -> 7698;
7700 -> 7698;
7701 -> 7699;
7701 -> 7700;
7702 -> 7700;
7703 -> 7701;
7703 -> 7702;
7704 -> 7702;
7705 -> 7703;
7705 -> 7704;
7706 -> 7705;
7706 -> 7704;
7707 -> 7706;
7707 -> 7702;
7708 -> 7707;
7708 -> 7700;
7709 -> 7708;
7709 -> 7698;
7710 -> 7709;
7710 -> 7687;
7711 -> 7687;
7712 -> 7691;
7712 -> 7711;
7713 -> 7711;
7714 -> 7712;
7714 -> 7713;
7715 -> 7714;
7715 -> 7624;
7715 -> 7713;
7716 -> 7715;
7716 -> 7711;
7717 -> 7711;
7718 -> 7716;
7718 -> 7717;
7718 -> 7711;
7719 -> 7718;
7719 -> 7711;
7720 -> 7719;
7721 -> 7716;
7721 -> 7720;
7722 -> 7720;
7723 -> 7721;
7723 -> 7722;
7724 -> 7722;
7725 -> 7723;
7725 -> 7724;
7726 -> 7724;
7726 -> 7722;
7727 -> 7723;
7727 -> 7720;
7728 -> 7727;
7728 -> 7687;
7729 -> 7687;
7730 -> 7691;
7730 -> 7687;
7731 -> 7687;
7732 -> 7730;
7732 -> 7731;
7733 -> 7729;
7733 -> 7731;
7734 -> 7732;
7734 -> 7731;
7735 -> 7731;
7736 -> 7732;
7736 -> 7735;
7737 -> 0;
7737 -> 7735;
7738 -> 7737;
7738 -> 7731;
7739 -> 7731;
7740 -> 7731;
7741 -> 7732;
7741 -> 7740;
7742 -> 7740;
7743 -> 7741;
7743 -> 7742;
7744 -> 7743;
7744 -> 7624;
7744 -> 7742;
7745 -> 7744;
7745 -> 7740;
7746 -> 0;
7746 -> 7745;
7747 -> 7746;
7747 -> 7731;
7748 -> 7731;
7749 -> 7732;
7749 -> 7748;
7750 -> 7749;
7750 -> 7624;
7750 -> 7748;
7751 -> 7750;
7751 -> 7731;
7752 -> 7751;
7752 -> 7731;
7753 -> 7752;
7754 -> 0;
7754 -> 7753;
7755 -> 7753;
7755 -> 7752;
7756 -> 7751;
7756 -> 7752;
7757 -> 7756;
7757 -> 7624;
7757 -> 7752;
7758 -> 7731;
7759 -> 7758;
7759 -> 7687;
7760 -> 7690;
7760 -> 7624;
7760 -> 7687;
7761 -> 7692;
7761 -> 7760;
7762 -> 7760;
7763 -> 7762;
7763 -> 7760;
7764 -> 7760;
7765 -> 7763;
7765 -> 7764;
7766 -> 7761;
7766 -> 7760;
7766 -> 7764;
7767 -> 7766;
7767 -> 7760;
7767 -> 7048;
7767 -> 7764;
7768 -> 7767;
7768 -> 7050;
7768 -> 7764;
7769 -> 7765;
7769 -> 7764;
7770 -> 7764;
7771 -> 7768;
7771 -> 7770;
7772 -> 7769;
7772 -> 7770;
7773 -> 7771;
7774 -> 7771;
7774 -> 7760;
7775 -> 7774;
7776 -> 7775;
7777 -> 7775;
7777 -> 7776;
7778 -> 7776;
7778 -> 7775;
7779 -> 7775;
7779 -> 7774;
7780 -> 7774;
7781 -> 7779;
7781 -> 7780;
7782 -> 7761;
7782 -> 7760;
7782 -> 7774;
7783 -> 7774;
7784 -> 7781;
7784 -> 7774;
7785 -> 7784;
7786 -> 7785;
7787 -> 7786;
7787 -> 7785;
7788 -> 7785;
7789 -> 7785;
7790 -> 7788;
7790 -> 7774;
7791 -> 7774;
7792 -> 7790;
7792 -> 7791;
7793 -> 7761;
7793 -> 7781;
7793 -> 7791;
7794 -> 7793;
7794 -> 7781;
7794 -> 7791;
7795 -> 7792;
7795 -> 7791;
7796 -> 7791;
7797 -> 7795;
7797 -> 7796;
7798 -> 7794;
7798 -> 7797;
7798 -> 7791;
7799 -> 7788;
7799 -> 7760;
7800 -> 7688;
7800 -> 7799;
7801 -> 7800;
7801 -> 7590;
7802 -> 7555;
7802 -> 7590;
7803 -> 7550;
7803 -> 7590;
7804 -> 7590;
7805 -> 7801;
7805 -> 7804;
7806 -> 7802;
7806 -> 7804;
7807 -> 7803;
7807 -> 7804;
7808 -> 7807;
7808 -> 7781;
7808 -> 7804;
7809 -> 7808;
7809 -> 7806;
7809 -> 7804;
7809 -> 7781;
7809 -> 7798;
7809 -> 7433;
7810 -> 7809;
7810 -> 7804;
7811 -> 7805;
7811 -> 7649;
7811 -> 7804;
7812 -> 7805;
7812 -> 7651;
7812 -> 7804;
7813 -> 7809;
7813 -> 7804;
7814 -> 7811;
7814 -> 7809;
7814 -> 7804;
7815 -> 7813;
7815 -> 7804;
7816 -> 7815;
7816 -> 7804;
7817 -> 7815;
7817 -> 7809;
7817 -> 7804;
7818 -> 7817;
7819 -> 7818;
7819 -> 7804;
7820 -> 7804;
7821 -> 7820;
7821 -> 7804;
7822 -> 7804;
7823 -> 7811;
7823 -> 7804;
7824 -> 7822;
7824 -> 7804;
7825 -> 7804;
7826 -> 7811;
7826 -> 7825;
7827 -> 0;
7827 -> 7825;
7828 -> 7827;
7828 -> 7804;
7829 -> 7828;
7829 -> 7804;
7830 -> 7804;
7831 -> 7829;
7831 -> 7830;
7832 -> 7824;
7832 -> 7830;
7833 -> 7831;
7833 -> 0;
7833 -> 7830;
7834 -> 7831;
7834 -> 7833;
7835 -> 7804;
7836 -> 7811;
7836 -> 7835;
7837 -> 7836;
7837 -> 7814;
7837 -> 7835;
7838 -> 7837;
7838 -> 7804;
7839 -> 7804;
7840 -> 7838;
7840 -> 7804;
7841 -> 7838;
7841 -> 7840;
7842 -> 7841;
7842 -> 7804;
7843 -> 7838;
7843 -> 7804;
7844 -> 7828;
7844 -> 7834;
7844 -> 7804;
7845 -> 7844;
7845 -> 7842;
7845 -> 7804;
7846 -> 7804;
7847 -> 7811;
7847 -> 7846;
7848 -> 7846;
7849 -> 7848;
7849 -> 7846;
7850 -> 7846;
7851 -> 7849;
7851 -> 7850;
7852 -> 7847;
7852 -> 7850;
7853 -> 7850;
7854 -> 7852;
7854 -> 7853;
7855 -> 7853;
7856 -> 7855;
7856 -> 7850;
7857 -> 7850;
7858 -> 7852;
7858 -> 7857;
7859 -> 7858;
7859 -> 7814;
7859 -> 7857;
7860 -> 7859;
7860 -> 7850;
7861 -> 7850;
7862 -> 7860;
7862 -> 7861;
7863 -> 7861;
7863 -> 7850;
7864 -> 7856;
7864 -> 7863;
7864 -> 7850;
7865 -> 7850;
7866 -> 7852;
7866 -> 7865;
7867 -> 7866;
7867 -> 7865;
7868 -> 7867;
7868 -> 7814;
7868 -> 7865;
7869 -> 7868;
7869 -> 7850;
7870 -> 7850;
7871 -> 7869;
7871 -> 7870;
7872 -> 7850;
7873 -> 7871;
7873 -> 7872;
7874 -> 7872;
7874 -> 7850;
7875 -> 7850;
7876 -> 7864;
7876 -> 7874;
7876 -> 7850;
7877 -> 7850;
7878 -> 7852;
7878 -> 7877;
7879 -> 7878;
7879 -> 7814;
7879 -> 7877;
7880 -> 7879;
7880 -> 7850;
7881 -> 7880;
7881 -> 3303;
7881 -> 7850;
7882 -> 7876;
7882 -> 7881;
7882 -> 7850;
7883 -> 7850;
7884 -> 7850;
7885 -> 7884;
7885 -> 7804;
7886 -> 7811;
7886 -> 7809;
7887 -> 7886;
7887 -> 7559;
7887 -> 7549;
7888 -> 7559;
7888 -> 7597;
7888 -> 7549;
7889 -> 7888;
7889 -> 7549;
7891 -> 7890;
7893 -> 7892;
7895 -> 7894;
7897 -> 7896;
7899 -> 7898;
7901 -> 7900;
7902 -> 7901;
7904 -> 7903;
7907 -> 7905;
7907 -> 7906;
7908 -> 7907;
7911 -> 7909;
7911 -> 7910;
7912 -> 7911;
7913 -> 7902;
7913 -> 7893;
7914 -> 7913;
7915 -> 7901;
7916 -> 7899;
7917 -> 7904;
7918 -> 7589;
7918 -> 7549;
7919 -> 7555;
7919 -> 7433;
7919 -> 7549;
7920 -> 7888;
7920 -> 7549;
7921 -> 7549;
7922 -> 7549;
7923 -> 7918;
7923 -> 7922;
7924 -> 7919;
7924 -> 7922;
7925 -> 7920;
7925 -> 7922;
7926 -> 7921;
7926 -> 7922;
7927 -> 7923;
7927 -> 7899;
7927 -> 7922;
7928 -> 7927;
7928 -> 7895;
7928 -> 7922;
7929 -> 7924;
7929 -> 7922;
7930 -> 7929;
7931 -> 7925;
7931 -> 7922;
7932 -> 7908;
7932 -> 7931;
7933 -> 7928;
7933 -> 7930;
7933 -> 7922;
7934 -> 7933;
7934 -> 7932;
7934 -> 7922;
7935 -> 7934;
7935 -> 7926;
7935 -> 7922;
7936 -> 7921;
7936 -> 7559;
7936 -> 7549;
7937 -> 7549;
7938 -> 7559;
7938 -> 7937;
7939 -> 7937;
7940 -> 7938;
7940 -> 7936;
7940 -> 7939;
7941 -> 7940;
7941 -> 7935;
7941 -> 7895;
7941 -> 7939;
7942 -> 7941;
7942 -> 7937;
7943 -> 7942;
7943 -> 7549;
7944 -> 7549;
7945 -> 7559;
7945 -> 7944;
7946 -> 7944;
7947 -> 7945;
7947 -> 7936;
7947 -> 7946;
7948 -> 7947;
7948 -> 7935;
7948 -> 7932;
7948 -> 7946;
7949 -> 7946;
7950 -> 7948;
7950 -> 7944;
7951 -> 7950;
7951 -> 7549;
7952 -> 7476;
7953 -> 7540;
7953 -> 7952;
7954 -> 0;
7954 -> 7952;
7955 -> 7954;
7955 -> 7476;
7956 -> 7476;
7957 -> 7955;
7957 -> 7956;
7958 -> 7957;
7958 -> 7956;
7959 -> 7956;
7960 -> 7487;
7960 -> 7476;
7961 -> 7960;
7962 -> 7540;
7962 -> 7961;
7963 -> 7961;
7964 -> 7962;
7964 -> 7936;
7964 -> 7963;
7965 -> 7964;
7965 -> 7935;
7965 -> 7895;
7965 -> 7963;
7966 -> 7965;
7966 -> 7961;
7967 -> 7966;
7967 -> 7960;
7968 -> 7958;
7968 -> 7967;
7969 -> 7540;
7969 -> 7476;
7970 -> 7442;
7970 -> 7969;
7970 -> 7563;
7970 -> 7565;
7970 -> 7586;
7970 -> 7597;
7970 -> 7585;
7970 -> 7570;
7970 -> 7571;
7970 -> 7587;
7970 -> 7588;
7970 -> 7887;
7970 -> 7936;
7970 -> 0;
7970 -> 7814;
7970 -> 7433;
7970 -> 7649;
7970 -> 7650;
7970 -> 7651;
7970 -> 7935;
7970 -> 7443;
7971 -> 7584;
7971 -> 7443;
7972 -> 7442;
7972 -> 7970;
7972 -> 7441;
7973 -> 7381;
7974 -> 7412;
7974 -> 7972;
7974 -> 7973;
7974 -> 7381;
7975 -> 7382;
7975 -> 7972;
7975 -> 7381;
7976 -> 7381;
7977 -> 7974;
7977 -> 7976;
7978 -> 7975;
7978 -> 7976;
7979 -> 7977;
7979 -> 7976;
7980 -> 7978;
7980 -> 7976;
7981 -> 7976;
7982 -> 7976;
7983 -> 7979;
7983 -> 7982;
7984 -> 7983;
7984 -> 7976;
7985 -> 7976;
7986 -> 7381;
7987 -> 7412;
7987 -> 7972;
7987 -> 7986;
7987 -> 7381;
7988 -> 7977;
7988 -> 7987;
7988 -> 7381;
7989 -> 7388;
7989 -> 7381;
7990 -> 7382;
7990 -> 7381;
7991 -> 7381;
7992 -> 7381;
7993 -> 7991;
7993 -> 7992;
7994 -> 7382;
7994 -> 7992;
7995 -> 0;
7995 -> 7992;
7996 -> 7992;
7997 -> 7995;
7997 -> 7996;
7998 -> 7994;
7998 -> 7996;
7999 -> 7996;
8000 -> 7997;
8000 -> 7999;
8000 -> 7996;
8001 -> 7997;
8001 -> 7998;
8001 -> 7972;
8001 -> 7996;
8002 -> 8001;
8002 -> 7381;
8003 -> 7412;
8003 -> 7972;
8003 -> 7991;
8003 -> 7381;
8004 -> 7584;
8004 -> 7381;
8005 -> 7381;
8006 -> 7989;
8006 -> 8005;
8007 -> 7990;
8007 -> 8005;
8008 -> 8002;
8008 -> 8005;
8009 -> 7991;
8009 -> 8005;
8010 -> 8003;
8010 -> 8005;
8011 -> 7990;
8011 -> 8005;
8012 -> 7991;
8012 -> 8005;
8013 -> 8004;
8013 -> 8005;
8014 -> 8006;
8014 -> 8005;
8015 -> 8007;
8015 -> 8005;
8016 -> 8009;
8016 -> 8005;
8017 -> 8011;
8017 -> 8005;
8018 -> 8012;
8018 -> 8005;
8019 -> 8005;
8020 -> 8014;
8020 -> 8019;
8021 -> 8015;
8021 -> 8019;
8022 -> 8008;
8022 -> 8019;
8023 -> 8016;
8023 -> 8019;
8024 -> 8010;
8024 -> 8019;
8025 -> 8017;
8025 -> 8019;
8026 -> 8018;
8026 -> 8019;
8027 -> 8013;
8027 -> 8019;
8028 -> 8019;
8029 -> 8019;
8030 -> 8019;
8031 -> 8029;
8031 -> 8030;
8032 -> 8010;
8032 -> 8030;
8033 -> 8031;
8033 -> 0;
8033 -> 8030;
8034 -> 8031;
8034 -> 8030;
8035 -> 8010;
8035 -> 8034;
8036 -> 8034;
8037 -> 8035;
8037 -> 8036;
8038 -> 8036;
8039 -> 8037;
8039 -> 8038;
8040 -> 8038;
8041 -> 8039;
8041 -> 8040;
8042 -> 8040;
8043 -> 8041;
8043 -> 8042;
8044 -> 8043;
8044 -> 8042;
8045 -> 8044;
8045 -> 8040;
8046 -> 8045;
8046 -> 8038;
8047 -> 8046;
8047 -> 8036;
8048 -> 8036;
8049 -> 8047;
8049 -> 8048;
8050 -> 8010;
8050 -> 8030;
8051 -> 8050;
8051 -> 8030;
8052 -> 8010;
8052 -> 8051;
8053 -> 8051;
8054 -> 8052;
8054 -> 8053;
8055 -> 8053;
8056 -> 8054;
8056 -> 8055;
8057 -> 8055;
8058 -> 8056;
8058 -> 8057;
8059 -> 8057;
8060 -> 8058;
8060 -> 8059;
8061 -> 8060;
8061 -> 8059;
8062 -> 8061;
8062 -> 8057;
8063 -> 8062;
8063 -> 8055;
8064 -> 8063;
8064 -> 8053;
8065 -> 8053;
8066 -> 8064;
8066 -> 8065;
8067 -> 8031;
8067 -> 0;
8067 -> 8030;
8068 -> 8030;
8069 -> 8066;
8069 -> 8068;
8069 -> 8030;
8070 -> 8030;
8071 -> 8010;
8071 -> 8070;
8071 -> 8030;
8072 -> 8030;
8072 -> 8019;
8073 -> 8027;
8073 -> 8010;
8074 -> 8024;
8074 -> 8010;
8075 -> 8010;
8076 -> 8073;
8076 -> 8010;
8077 -> 8010;
8078 -> 8010;
8079 -> 8010;
8080 -> 8010;
8081 -> 8010;
8082 -> 8010;
8083 -> 8010;
8084 -> 8010;
8084 -> 8083;
8085 -> 8084;
8085 -> 8010;
8085 -> 8083;
8086 -> 8085;
8086 -> 8083;
8087 -> 8086;
8087 -> 8010;
8088 -> 8010;
8089 -> 8074;
8089 -> 8010;
8090 -> 0;
8090 -> 8089;
8091 -> 8010;
8092 -> 8091;
8093 -> 8092;
8093 -> 8091;
8094 -> 8093;
8094 -> 8091;
8095 -> 8091;
8096 -> 8091;
8096 -> 8010;
8097 -> 8096;
8097 -> 8010;
8098 -> 0;
8098 -> 8010;
8099 -> 0;
8099 -> 8010;
8100 -> 0;
8100 -> 8010;
8101 -> 0;
8101 -> 8010;
8102 -> 8010;
8103 -> 8102;
8104 -> 8103;
8104 -> 8010;
8104 -> 8102;
8105 -> 7914;
8105 -> 8010;
8106 -> 8090;
8106 -> 8105;
8106 -> 8010;
8107 -> 8010;
8108 -> 8010;
8108 -> 8107;
8109 -> 8107;
8110 -> 8108;
8110 -> 8010;
8110 -> 8109;
8111 -> 8110;
8111 -> 8106;
8111 -> 7895;
8111 -> 8109;
8112 -> 8111;
8112 -> 8107;
8113 -> 8112;
8113 -> 8010;
8114 -> 8010;
8115 -> 8010;
8115 -> 8114;
8116 -> 8114;
8117 -> 8115;
8117 -> 8010;
8117 -> 8116;
8118 -> 8117;
8118 -> 8106;
8118 -> 7932;
8118 -> 8116;
8119 -> 8116;
8120 -> 8118;
8120 -> 8114;
8121 -> 8120;
8121 -> 8010;
8122 -> 8019;
8123 -> 8024;
8123 -> 8122;
8124 -> 0;
8124 -> 8122;
8125 -> 8124;
8125 -> 8019;
8126 -> 8019;
8127 -> 8125;
8127 -> 8126;
8128 -> 8127;
8128 -> 8126;
8129 -> 8126;
8130 -> 8026;
8130 -> 8019;
8131 -> 8130;
8132 -> 8024;
8132 -> 8131;
8133 -> 8131;
8134 -> 8132;
8134 -> 8010;
8134 -> 8133;
8135 -> 8134;
8135 -> 8106;
8135 -> 7895;
8135 -> 8133;
8136 -> 8135;
8136 -> 8131;
8137 -> 8136;
8137 -> 8130;
8138 -> 8137;
8138 -> 8128;
8138 -> 8130;
8139 -> 8088;
8139 -> 8138;
8139 -> 8130;
8140 -> 7431;
8140 -> 8139;
8140 -> 7381;
8141 -> 7412;
8141 -> 7381;
8142 -> 7972;
8142 -> 7381;
8143 -> 8024;
8143 -> 7381;
8144 -> 7381;
8145 -> 7381;
8146 -> 8141;
8146 -> 8145;
8147 -> 8142;
8147 -> 8145;
8148 -> 8143;
8148 -> 8145;
8149 -> 8144;
8149 -> 8145;
8150 -> 8149;
8150 -> 8145;
8151 -> 8146;
8151 -> 8149;
8151 -> 8145;
8152 -> 8147;
8152 -> 8149;
8152 -> 8145;
8153 -> 8148;
8153 -> 8149;
8153 -> 8145;
8154 -> 7382;
8154 -> 7972;
8154 -> 7381;
8155 -> 8144;
8155 -> 7381;
8156 -> 8154;
8156 -> 8155;
8156 -> 8153;
8156 -> 8151;
8156 -> 8152;
8156 -> 7972;
8156 -> 7412;
8156 -> 8010;
8156 -> 8104;
8156 -> 8100;
8156 -> 8101;
8156 -> 8098;
8156 -> 8099;
8156 -> 0;
8156 -> 8031;
8156 -> 8106;
8156 -> 7381;
8157 -> 8156;
8157 -> 7379;
8158 -> 7377;
8159 -> 8157;
8159 -> 8156;
8159 -> 8158;
8160 -> 8159;
8160 -> 8156;
8160 -> 8158;
8161 -> 7375;
8162 -> 8160;
8162 -> 8161;
8163 -> 8162;
8163 -> 8156;
8163 -> 8161;
8164 -> 7373;
8165 -> 8162;
8165 -> 8164;
8166 -> 8164;
8167 -> 8165;
8167 -> 8166;
8168 -> 8167;
8168 -> 8164;
8169 -> 8168;
8169 -> 7355;
8170 -> 7372;
8170 -> 8169;
8170 -> 7355;
8171 -> 7355;
8172 -> 7343;
8172 -> 8171;
8173 -> 8172;
8173 -> 8156;
8173 -> 8171;
8174 -> 8172;
8174 -> 8156;
8174 -> 8173;
8175 -> 8174;
8175 -> 7355;
8176 -> 7355;
8177 -> 8170;
8177 -> 8175;
8177 -> 7355;
8178 -> 8177;
8179 -> 8178;
8180 -> 8178;
8180 -> 8177;
8181 -> 0;
8181 -> 8180;
8182 -> 8181;
8182 -> 7341;
8183 -> 7341;
8184 -> 8182;
8184 -> 8183;
8185 -> 7335;
8185 -> 8156;
8185 -> 8183;
8186 -> 8184;
8186 -> 6994;
8186 -> 8183;
8187 -> 8184;
8187 -> 6994;
8187 -> 8183;
8188 -> 8185;
8188 -> 8156;
8188 -> 8183;
8189 -> 8187;
8189 -> 8183;
8190 -> 8183;
8191 -> 8188;
8191 -> 8190;
8192 -> 8189;
8192 -> 8190;
8193 -> 8191;
8193 -> 8192;
8193 -> 8190;
8194 -> 8190;
8195 -> 8185;
8195 -> 8156;
8195 -> 8183;
8196 -> 8187;
8196 -> 8183;
8197 -> 8195;
8197 -> 8196;
8197 -> 8183;
8198 -> 7341;
8199 -> 7334;
8200 -> 7335;
8200 -> 8156;
8200 -> 8199;
8201 -> 8200;
8201 -> 8156;
8201 -> 8197;
8201 -> 6992;
8201 -> 8199;
8202 -> 8201;
8202 -> 7334;
8203 -> 8202;
8203 -> 7332;
8204 -> 8203;
8204 -> 0;
8204 -> 7332;
8205 -> 7332;
8206 -> 7333;
8206 -> 8205;
8207 -> 8206;
8207 -> 8156;
8207 -> 8197;
8207 -> 8205;
8208 -> 8207;
8208 -> 7332;
8209 -> 8203;
8209 -> 7297;
8209 -> 7332;
8210 -> 8208;
8210 -> 8209;
8210 -> 7332;
8211 -> 7287;
8211 -> 6000;
8211 -> 0;
8211 -> 7332;
8212 -> 7332;
8213 -> 7332;
8214 -> 7333;
8214 -> 8213;
8215 -> 8213;
8216 -> 8215;
8217 -> 8214;
8217 -> 8215;
8218 -> 0;
8218 -> 8215;
8219 -> 8215;
8220 -> 8218;
8220 -> 8219;
8221 -> 8217;
8221 -> 8219;
8222 -> 8219;
8223 -> 8220;
8223 -> 8222;
8223 -> 8219;
8224 -> 8220;
8224 -> 8221;
8224 -> 8156;
8224 -> 8219;
8225 -> 8219;
8226 -> 8224;
8226 -> 8213;
8227 -> 8226;
8227 -> 8213;
8228 -> 8227;
8228 -> 8213;
8229 -> 8228;
8229 -> 8213;
8230 -> 8229;
8230 -> 7332;
8231 -> 7332;
8232 -> 7333;
8232 -> 8231;
8233 -> 8231;
8234 -> 8232;
8234 -> 8156;
8234 -> 8233;
8235 -> 8234;
8235 -> 8156;
8235 -> 8233;
8236 -> 8231;
8237 -> 8236;
8238 -> 8232;
8238 -> 8236;
8239 -> 0;
8239 -> 8236;
8240 -> 8236;
8241 -> 8239;
8241 -> 8240;
8242 -> 8238;
8242 -> 8240;
8243 -> 8240;
8244 -> 8241;
8244 -> 8243;
8244 -> 8240;
8245 -> 8241;
8245 -> 8242;
8245 -> 8156;
8245 -> 8240;
8246 -> 8240;
8247 -> 8235;
8247 -> 8245;
8247 -> 8231;
8248 -> 8247;
8248 -> 8231;
8249 -> 8248;
8249 -> 8231;
8250 -> 8249;
8250 -> 7332;
8251 -> 8230;
8251 -> 8250;
8251 -> 7332;
8252 -> 7332;
8253 -> 7333;
8253 -> 8252;
8254 -> 0;
8254 -> 8252;
8255 -> 8252;
8256 -> 8254;
8256 -> 8255;
8257 -> 8253;
8257 -> 8255;
8258 -> 8255;
8259 -> 8256;
8259 -> 8258;
8259 -> 8255;
8260 -> 8256;
8260 -> 8257;
8260 -> 8156;
8260 -> 8255;
8261 -> 8255;
8262 -> 8260;
8262 -> 7332;
8263 -> 8251;
8263 -> 8262;
8263 -> 7332;
8264 -> 8210;
8264 -> 8263;
8264 -> 7332;
8265 -> 7333;
8265 -> 7332;
8266 -> 7287;
8266 -> 6000;
8266 -> 7332;
8267 -> 8265;
8267 -> 8266;
8267 -> 7288;
8267 -> 8156;
8267 -> 8197;
8267 -> 6000;
8267 -> 7332;
8268 -> 7332;
8269 -> 8267;
8269 -> 8268;
8270 -> 8267;
8270 -> 8268;
8271 -> 8268;
8272 -> 8269;
8272 -> 8271;
8273 -> 8271;
8274 -> 8272;
8274 -> 8273;
8275 -> 8274;
8275 -> 8267;
8275 -> 8271;
8276 -> 8275;
8276 -> 8268;
8277 -> 8267;
8277 -> 8268;
8278 -> 8267;
8278 -> 8268;
8279 -> 8268;
8280 -> 8277;
8280 -> 8279;
8281 -> 8279;
8282 -> 8280;
8282 -> 8281;
8283 -> 8282;
8283 -> 8276;
8283 -> 8281;
8284 -> 8279;
8285 -> 8283;
8285 -> 8276;
8285 -> 8284;
8286 -> 8284;
8287 -> 8285;
8287 -> 8276;
8287 -> 8286;
8288 -> 8287;
8288 -> 8276;
8288 -> 7895;
8288 -> 8286;
8289 -> 8288;
8289 -> 8284;
8290 -> 8289;
8290 -> 8268;
8291 -> 8267;
8291 -> 8268;
8292 -> 8267;
8292 -> 8268;
8293 -> 8268;
8294 -> 8291;
8294 -> 8293;
8295 -> 8293;
8296 -> 8295;
8297 -> 8294;
8297 -> 8290;
8297 -> 8296;
8298 -> 8295;
8299 -> 8293;
8300 -> 8297;
8300 -> 8290;
8300 -> 8299;
8301 -> 8297;
8301 -> 8268;
8302 -> 8267;
8302 -> 8268;
8303 -> 8267;
8303 -> 8268;
8304 -> 8267;
8304 -> 8268;
8305 -> 8303;
8305 -> 8268;
8306 -> 8305;
8306 -> 8268;
8307 -> 8302;
8307 -> 8268;
8308 -> 8303;
8308 -> 8268;
8309 -> 8268;
8310 -> 8307;
8310 -> 8309;
8311 -> 8308;
8311 -> 8309;
8312 -> 8304;
8312 -> 8309;
8313 -> 8309;
8314 -> 8310;
8314 -> 8313;
8315 -> 8313;
8316 -> 8314;
8316 -> 8315;
8317 -> 8315;
8318 -> 8316;
8318 -> 8317;
8319 -> 8318;
8319 -> 8317;
8320 -> 8319;
8320 -> 8315;
8321 -> 8320;
8321 -> 8313;
8322 -> 8321;
8322 -> 8309;
8323 -> 8309;
8324 -> 8322;
8324 -> 8323;
8325 -> 8324;
8325 -> 8301;
8325 -> 8323;
8326 -> 8325;
8326 -> 8311;
8326 -> 8309;
8327 -> 8326;
8328 -> 8310;
8328 -> 8327;
8329 -> 8327;
8330 -> 8328;
8330 -> 8329;
8331 -> 8329;
8332 -> 8330;
8332 -> 8331;
8333 -> 8331;
8334 -> 8332;
8334 -> 8333;
8335 -> 8334;
8335 -> 8331;
8336 -> 8335;
8336 -> 8329;
8337 -> 8336;
8337 -> 8327;
8338 -> 8337;
8338 -> 8326;
8339 -> 8338;
8340 -> 8267;
8340 -> 8268;
8341 -> 8267;
8341 -> 8268;
8342 -> 8268;
8343 -> 8340;
8343 -> 8342;
8344 -> 8342;
8345 -> 8343;
8345 -> 8339;
8345 -> 8344;
8346 -> 8345;
8346 -> 8268;
8347 -> 8267;
8347 -> 8268;
8348 -> 8267;
8348 -> 8268;
8349 -> 8268;
8350 -> 8347;
8350 -> 8349;
8351 -> 8349;
8352 -> 8350;
8352 -> 8351;
8353 -> 8352;
8353 -> 8346;
8353 -> 8351;
8354 -> 8349;
8355 -> 8353;
8355 -> 8354;
8356 -> 8355;
8356 -> 8346;
8356 -> 8354;
8357 -> 8355;
8357 -> 8268;
8358 -> 7294;
8358 -> 7299;
8359 -> 7299;
8360 -> 8357;
8361 -> 8360;
8361 -> 8357;
8362 -> 7287;
8362 -> 6000;
8362 -> 8357;
8363 -> 8357;
8364 -> 8357;
8364 -> 8363;
8365 -> 0;
8365 -> 8363;
8366 -> 8365;
8366 -> 8357;
8367 -> 8357;
8368 -> 8367;
8369 -> 8367;
8369 -> 8357;
8370 -> 8369;
8370 -> 7292;
8370 -> 8357;
8371 -> 8366;
8371 -> 8370;
8371 -> 8357;
8372 -> 8357;
8373 -> 8357;
8373 -> 8372;
8374 -> 8372;
8375 -> 8373;
8375 -> 8374;
8376 -> 8375;
8376 -> 8372;
8377 -> 0;
8377 -> 8376;
8378 -> 8377;
8378 -> 8357;
8379 -> 8371;
8379 -> 8378;
8379 -> 8357;
8380 -> 8357;
8381 -> 8367;
8381 -> 8380;
8381 -> 8357;
8382 -> 8367;
8383 -> 8367;
8383 -> 8382;
8384 -> 8382;
8384 -> 8367;
8385 -> 8367;
8386 -> 8367;
8387 -> 8367;
8388 -> 8387;
8388 -> 8367;
8389 -> 8388;
8390 -> 8388;
8390 -> 8389;
8391 -> 8389;
8392 -> 8390;
8392 -> 8391;
8393 -> 8391;
8394 -> 8392;
8394 -> 8367;
8394 -> 8393;
8394 -> 8391;
8395 -> 8389;
8396 -> 8390;
8396 -> 8367;
8396 -> 8389;
8397 -> 8396;
8397 -> 8388;
8398 -> 8388;
8399 -> 8367;
8400 -> 8367;
8401 -> 8367;
8402 -> 8400;
8402 -> 8401;
8403 -> 8367;
8404 -> 8402;
8404 -> 8403;
8404 -> 8367;
8405 -> 8367;
8406 -> 8405;
8406 -> 8367;
8407 -> 8367;
8408 -> 8402;
8409 -> 8402;
8409 -> 8408;
8410 -> 8367;
8410 -> 8408;
8411 -> 0;
8411 -> 8408;
8412 -> 8408;
8413 -> 8411;
8413 -> 8412;
8414 -> 8410;
8414 -> 8412;
8415 -> 8412;
8416 -> 8413;
8416 -> 8415;
8416 -> 8412;
8417 -> 8413;
8417 -> 8414;
8417 -> 8402;
8417 -> 8412;
8418 -> 8407;
8418 -> 8402;
8419 -> 8417;
8419 -> 8402;
8420 -> 8402;
8421 -> 8418;
8421 -> 8402;
8422 -> 8419;
8422 -> 8402;
8423 -> 8420;
8423 -> 8402;
8424 -> 8421;
8424 -> 8402;
8425 -> 8402;
8426 -> 8402;
8426 -> 0;
8427 -> 8402;
8428 -> 8402;
8428 -> 8427;
8429 -> 8427;
8430 -> 8428;
8430 -> 8429;
8431 -> 8429;
8432 -> 8430;
8432 -> 8431;
8433 -> 8432;
8433 -> 8429;
8434 -> 8429;
8435 -> 8433;
8435 -> 8434;
8436 -> 8402;
8437 -> 8436;
8437 -> 8402;
8438 -> 8402;
8438 -> 8437;
8439 -> 8437;
8440 -> 8438;
8440 -> 8439;
8441 -> 8439;
8442 -> 8440;
8442 -> 8441;
8443 -> 8442;
8443 -> 8439;
8444 -> 8439;
8445 -> 8443;
8445 -> 8444;
8446 -> 8402;
8446 -> 0;
8447 -> 8402;
8448 -> 8445;
8448 -> 8447;
8448 -> 8402;
8449 -> 8402;
8450 -> 8402;
8451 -> 8424;
8451 -> 8402;
8452 -> 8402;
8453 -> 8402;
8454 -> 8402;
8455 -> 8402;
8456 -> 8402;
8457 -> 8402;
8458 -> 8402;
8459 -> 8402;
8459 -> 8458;
8460 -> 8459;
8460 -> 8402;
8460 -> 8458;
8461 -> 8460;
8461 -> 8458;
8462 -> 8461;
8462 -> 8402;
8463 -> 8402;
8464 -> 8402;
8465 -> 8402;
8466 -> 8450;
8466 -> 8402;
8467 -> 8450;
8467 -> 8402;
8468 -> 8402;
8469 -> 8402;
8470 -> 8450;
8470 -> 8402;
8471 -> 8470;
8471 -> 8402;
8472 -> 8450;
8472 -> 8471;
8473 -> 8471;
8474 -> 8472;
8474 -> 8473;
8475 -> 8473;
8476 -> 8474;
8476 -> 8475;
8477 -> 8476;
8477 -> 8473;
8478 -> 8473;
8479 -> 8477;
8479 -> 8478;
8480 -> 8450;
8480 -> 0;
8480 -> 8402;
8481 -> 8479;
8481 -> 8447;
8481 -> 8402;
8482 -> 8450;
8482 -> 8449;
8482 -> 8402;
8483 -> 8402;
8484 -> 8402;
8484 -> 8483;
8485 -> 0;
8485 -> 8483;
8486 -> 8485;
8486 -> 8402;
8487 -> 8486;
8487 -> 8402;
8488 -> 8487;
8488 -> 8402;
8489 -> 8402;
8490 -> 8450;
8490 -> 8489;
8491 -> 8490;
8491 -> 8450;
8491 -> 8489;
8492 -> 8491;
8492 -> 8489;
8493 -> 8492;
8493 -> 8402;
8494 -> 8402;
8495 -> 8488;
8495 -> 8494;
8496 -> 8495;
8496 -> 8494;
8497 -> 8494;
8498 -> 8496;
8498 -> 8497;
8499 -> 8498;
8499 -> 8497;
8500 -> 8499;
8500 -> 8494;
8501 -> 8500;
8501 -> 8402;
8502 -> 8402;
8503 -> 8488;
8503 -> 8502;
8504 -> 8502;
8505 -> 8503;
8505 -> 8504;
8506 -> 8505;
8506 -> 8450;
8506 -> 8504;
8507 -> 8506;
8507 -> 8502;
8508 -> 8502;
8509 -> 8507;
8509 -> 8508;
8509 -> 8502;
8510 -> 8509;
8510 -> 8502;
8511 -> 8510;
8512 -> 8507;
8512 -> 8511;
8513 -> 8511;
8514 -> 8512;
8514 -> 8513;
8515 -> 8513;
8516 -> 8514;
8516 -> 8515;
8517 -> 8515;
8517 -> 8513;
8518 -> 8514;
8518 -> 8511;
8519 -> 8518;
8519 -> 8402;
8520 -> 8402;
8521 -> 8488;
8521 -> 8402;
8522 -> 8402;
8523 -> 8521;
8523 -> 8522;
8524 -> 8520;
8524 -> 8522;
8525 -> 8523;
8525 -> 8522;
8526 -> 8522;
8527 -> 8523;
8527 -> 8526;
8528 -> 0;
8528 -> 8526;
8529 -> 8528;
8529 -> 8522;
8530 -> 8522;
8531 -> 8522;
8532 -> 8523;
8532 -> 8531;
8533 -> 8531;
8534 -> 8532;
8534 -> 8533;
8535 -> 8534;
8535 -> 8450;
8535 -> 8533;
8536 -> 8535;
8536 -> 8531;
8537 -> 0;
8537 -> 8536;
8538 -> 8537;
8538 -> 8522;
8539 -> 8522;
8540 -> 8523;
8540 -> 8539;
8541 -> 8540;
8541 -> 8450;
8541 -> 8539;
8542 -> 8541;
8542 -> 8522;
8543 -> 8542;
8543 -> 8522;
8544 -> 8543;
8545 -> 0;
8545 -> 8544;
8546 -> 8544;
8546 -> 8543;
8547 -> 8542;
8547 -> 8543;
8548 -> 8547;
8548 -> 8450;
8548 -> 8543;
8549 -> 8522;
8550 -> 8549;
8550 -> 8402;
8551 -> 8450;
8552 -> 8551;
8552 -> 8450;
8553 -> 8552;
8553 -> 8450;
8554 -> 8450;
8555 -> 8551;
8556 -> 8551;
8556 -> 8555;
8557 -> 8555;
8557 -> 8551;
8558 -> 8551;
8559 -> 8558;
8559 -> 8551;
8560 -> 8551;
8561 -> 8551;
8561 -> 8402;
8562 -> 8551;
8562 -> 8450;
8562 -> 8402;
8563 -> 8551;
8563 -> 8402;
8564 -> 8563;
8564 -> 8402;
8565 -> 8564;
8565 -> 8402;
8566 -> 8564;
8566 -> 8551;
8566 -> 8402;
8567 -> 8566;
8568 -> 8567;
8568 -> 8402;
8569 -> 8402;
8570 -> 8569;
8570 -> 8402;
8571 -> 8402;
8572 -> 8551;
8572 -> 8402;
8573 -> 8571;
8573 -> 8402;
8574 -> 8402;
8575 -> 8551;
8575 -> 8574;
8576 -> 0;
8576 -> 8574;
8577 -> 8576;
8577 -> 8402;
8578 -> 8577;
8578 -> 8402;
8579 -> 8402;
8580 -> 8578;
8580 -> 8579;
8581 -> 8573;
8581 -> 8579;
8582 -> 8580;
8582 -> 0;
8582 -> 8579;
8583 -> 8580;
8583 -> 8582;
8584 -> 8402;
8585 -> 8551;
8585 -> 8584;
8586 -> 8585;
8586 -> 8551;
8586 -> 8584;
8587 -> 8586;
8587 -> 8402;
8588 -> 8402;
8589 -> 8587;
8589 -> 8402;
8590 -> 8587;
8590 -> 8589;
8591 -> 8590;
8591 -> 8402;
8592 -> 8587;
8592 -> 8402;
8593 -> 8577;
8593 -> 8583;
8593 -> 8402;
8594 -> 8593;
8594 -> 8591;
8594 -> 8402;
8595 -> 8402;
8596 -> 8551;
8596 -> 8595;
8597 -> 8595;
8598 -> 8597;
8598 -> 8595;
8599 -> 8595;
8600 -> 8598;
8600 -> 8599;
8601 -> 8596;
8601 -> 8599;
8602 -> 8599;
8603 -> 8601;
8603 -> 8602;
8604 -> 8602;
8605 -> 8604;
8605 -> 8599;
8606 -> 8599;
8607 -> 8601;
8607 -> 8606;
8608 -> 8607;
8608 -> 8551;
8608 -> 8606;
8609 -> 8608;
8609 -> 8599;
8610 -> 8599;
8611 -> 8609;
8611 -> 8610;
8612 -> 8610;
8612 -> 8599;
8613 -> 8605;
8613 -> 8612;
8613 -> 8599;
8614 -> 8599;
8615 -> 8601;
8615 -> 8614;
8616 -> 8615;
8616 -> 8614;
8617 -> 8616;
8617 -> 8551;
8617 -> 8614;
8618 -> 8617;
8618 -> 8599;
8619 -> 8599;
8620 -> 8618;
8620 -> 8619;
8621 -> 8599;
8622 -> 8620;
8622 -> 8621;
8623 -> 8621;
8623 -> 8599;
8624 -> 8599;
8625 -> 8613;
8625 -> 8623;
8625 -> 8599;
8626 -> 8599;
8627 -> 8599;
8628 -> 8627;
8628 -> 8402;
8629 -> 8402;
8630 -> 8629;
8630 -> 8402;
8631 -> 8402;
8632 -> 8402;
8632 -> 8631;
8633 -> 8631;
8634 -> 8632;
8634 -> 8402;
8634 -> 8633;
8635 -> 8634;
8635 -> 8402;
8635 -> 8633;
8636 -> 8633;
8637 -> 8635;
8637 -> 8631;
8638 -> 8637;
8638 -> 8402;
8639 -> 8402;
8640 -> 8402;
8640 -> 8639;
8641 -> 0;
8641 -> 8639;
8642 -> 8641;
8642 -> 8402;
8643 -> 8402;
8644 -> 8642;
8644 -> 8643;
8645 -> 8644;
8645 -> 8643;
8646 -> 8643;
8647 -> 8423;
8647 -> 8402;
8648 -> 8647;
8649 -> 8648;
8649 -> 8647;
8650 -> 8645;
8650 -> 8649;
8651 -> 8402;
8651 -> 8420;
8651 -> 8551;
8651 -> 8450;
8652 -> 8463;
8652 -> 8402;
8653 -> 8367;
8654 -> 8402;
8654 -> 8651;
8654 -> 8653;
8654 -> 8367;
8655 -> 8367;
8655 -> 8651;
8656 -> 8367;
8657 -> 8654;
8657 -> 8656;
8658 -> 8655;
8658 -> 8656;
8659 -> 8657;
8659 -> 8656;
8660 -> 8658;
8660 -> 8656;
8661 -> 8656;
8662 -> 8656;
8663 -> 8659;
8663 -> 8662;
8664 -> 8663;
8664 -> 8656;
8665 -> 8656;
8666 -> 8367;
8667 -> 8402;
8667 -> 8651;
8667 -> 8666;
8667 -> 8367;
8668 -> 8657;
8668 -> 8667;
8668 -> 8367;
8669 -> 8367;
8670 -> 8367;
8670 -> 8669;
8671 -> 8367;
8671 -> 8669;
8672 -> 0;
8672 -> 8669;
8673 -> 8669;
8674 -> 8672;
8674 -> 8673;
8675 -> 8671;
8675 -> 8673;
8676 -> 8673;
8677 -> 8674;
8677 -> 8676;
8677 -> 8673;
8678 -> 8674;
8678 -> 8675;
8678 -> 8651;
8678 -> 8673;
8679 -> 8678;
8679 -> 8367;
8680 -> 8367;
8681 -> 8463;
8681 -> 8367;
8682 -> 8679;
8682 -> 8367;
8683 -> 8680;
8683 -> 8367;
8684 -> 8681;
8684 -> 8367;
8685 -> 8651;
8685 -> 8367;
8686 -> 8367;
8686 -> 0;
8687 -> 8367;
8688 -> 8651;
8688 -> 8687;
8689 -> 8687;
8690 -> 8688;
8690 -> 8689;
8691 -> 8689;
8692 -> 8690;
8692 -> 8691;
8693 -> 8692;
8693 -> 8689;
8694 -> 8689;
8695 -> 8693;
8695 -> 8694;
8696 -> 8651;
8696 -> 8367;
8697 -> 8696;
8697 -> 8367;
8698 -> 8651;
8698 -> 8697;
8699 -> 8697;
8700 -> 8698;
8700 -> 8699;
8701 -> 8699;
8702 -> 8700;
8702 -> 8701;
8703 -> 8702;
8703 -> 8699;
8704 -> 8699;
8705 -> 8703;
8705 -> 8704;
8706 -> 8367;
8706 -> 0;
8707 -> 8367;
8708 -> 8705;
8708 -> 8707;
8708 -> 8367;
8709 -> 8367;
8710 -> 8651;
8710 -> 8709;
8710 -> 8367;
8711 -> 8684;
8711 -> 8651;
8712 -> 8711;
8712 -> 8651;
8713 -> 8651;
8714 -> 8651;
8715 -> 8651;
8716 -> 8651;
8717 -> 8651;
8718 -> 8651;
8719 -> 8651;
8720 -> 8651;
8720 -> 8719;
8721 -> 8720;
8721 -> 8651;
8721 -> 8719;
8722 -> 8721;
8722 -> 8719;
8723 -> 8722;
8723 -> 8651;
8724 -> 8651;
8725 -> 8651;
8726 -> 8725;
8727 -> 8726;
8727 -> 8725;
8728 -> 8725;
8729 -> 8725;
8729 -> 8651;
8730 -> 8729;
8730 -> 8651;
8731 -> 8651;
8732 -> 8731;
8732 -> 8651;
8733 -> 8651;
8734 -> 8651;
8734 -> 8733;
8735 -> 8733;
8736 -> 8734;
8736 -> 8651;
8736 -> 8735;
8737 -> 8736;
8737 -> 8651;
8737 -> 8402;
8737 -> 8735;
8738 -> 8735;
8739 -> 8737;
8739 -> 8733;
8740 -> 8739;
8740 -> 8651;
8741 -> 8367;
8742 -> 8651;
8742 -> 8741;
8743 -> 0;
8743 -> 8741;
8744 -> 8743;
8744 -> 8367;
8745 -> 8367;
8746 -> 8744;
8746 -> 8745;
8747 -> 8746;
8747 -> 8745;
8748 -> 8745;
8749 -> 8683;
8749 -> 8367;
8750 -> 8749;
8751 -> 8651;
8751 -> 8750;
8752 -> 8751;
8752 -> 8749;
8753 -> 8752;
8753 -> 8747;
8753 -> 8749;
8754 -> 8724;
8754 -> 8753;
8754 -> 8749;
8755 -> 8404;
8755 -> 8754;
8755 -> 8367;
8756 -> 8367;
8757 -> 8651;
8757 -> 8367;
8758 -> 8651;
8759 -> 8651;
8759 -> 6994;
8759 -> 8357;
8760 -> 8651;
8760 -> 8357;
8761 -> 8357;
8762 -> 8760;
8762 -> 8761;
8763 -> 8760;
8763 -> 8761;
8764 -> 8762;
8764 -> 8763;
8764 -> 8761;
8765 -> 8761;
8766 -> 8357;
8767 -> 8357;
8767 -> 8651;
8767 -> 8766;
8768 -> 8767;
8768 -> 8651;
8768 -> 6992;
8768 -> 8766;
8769 -> 8768;
8769 -> 8357;
8770 -> 8769;
8770 -> 8357;
8771 -> 8770;
8771 -> 0;
8771 -> 8357;
8772 -> 8357;
8773 -> 8772;
8773 -> 8651;
8774 -> 8773;
8774 -> 8357;
8775 -> 8770;
8775 -> 7297;
8775 -> 8357;
8776 -> 8774;
8776 -> 8775;
8776 -> 8357;
8777 -> 7287;
8777 -> 6000;
8777 -> 0;
8777 -> 8357;
8778 -> 8357;
8779 -> 8357;
8780 -> 8357;
8780 -> 8779;
8781 -> 8779;
8782 -> 8781;
8783 -> 8780;
8783 -> 8781;
8784 -> 0;
8784 -> 8781;
8785 -> 8781;
8786 -> 8784;
8786 -> 8785;
8787 -> 8783;
8787 -> 8785;
8788 -> 8785;
8789 -> 8786;
8789 -> 8788;
8789 -> 8785;
8790 -> 8786;
8790 -> 8787;
8790 -> 8651;
8790 -> 8785;
8791 -> 8790;
8791 -> 8779;
8792 -> 8791;
8792 -> 8779;
8793 -> 8792;
8793 -> 8779;
8794 -> 8793;
8794 -> 8779;
8795 -> 8794;
8795 -> 8357;
8796 -> 8357;
8797 -> 8357;
8797 -> 8796;
8798 -> 8796;
8799 -> 8797;
8799 -> 8651;
8799 -> 8798;
8800 -> 8799;
8800 -> 8651;
8800 -> 8798;
8801 -> 8796;
8802 -> 8801;
8803 -> 8797;
8803 -> 8801;
8804 -> 0;
8804 -> 8801;
8805 -> 8801;
8806 -> 8804;
8806 -> 8805;
8807 -> 8803;
8807 -> 8805;
8808 -> 8805;
8809 -> 8806;
8809 -> 8808;
8809 -> 8805;
8810 -> 8806;
8810 -> 8807;
8810 -> 8651;
8810 -> 8805;
8811 -> 8800;
8811 -> 8810;
8811 -> 8796;
8812 -> 8811;
8812 -> 8796;
8813 -> 8812;
8813 -> 8796;
8814 -> 8813;
8814 -> 8357;
8815 -> 8795;
8815 -> 8814;
8815 -> 8357;
8816 -> 8357;
8817 -> 8357;
8817 -> 8816;
8818 -> 0;
8818 -> 8816;
8819 -> 8816;
8820 -> 8818;
8820 -> 8819;
8821 -> 8817;
8821 -> 8819;
8822 -> 8819;
8823 -> 8820;
8823 -> 8822;
8823 -> 8819;
8824 -> 8820;
8824 -> 8821;
8824 -> 8651;
8824 -> 8819;
8825 -> 8824;
8825 -> 8357;
8826 -> 8815;
8826 -> 8825;
8826 -> 8357;
8827 -> 8776;
8827 -> 8826;
8827 -> 8357;
8828 -> 8651;
8828 -> 8357;
8829 -> 8651;
8829 -> 8357;
8830 -> 8651;
8830 -> 8357;
8831 -> 8651;
8831 -> 8357;
8832 -> 8651;
8832 -> 8357;
8833 -> 8832;
8833 -> 8357;
8834 -> 8831;
8834 -> 8357;
8835 -> 8651;
8835 -> 8357;
8836 -> 8651;
8836 -> 8357;
8837 -> 8357;
8838 -> 8651;
8838 -> 8837;
8838 -> 8357;
8839 -> 8359;
8839 -> 8357;
8840 -> 5983;
8840 -> 8838;
8840 -> 5982;
8840 -> 5990;
8841 -> 8839;
8841 -> 5990;
8842 -> 3414;
8842 -> 5990;
8843 -> 8840;
8843 -> 8841;
8843 -> 8842;
8843 -> 8838;
8843 -> 5990;
8844 -> 5983;
8844 -> 8843;
8844 -> 5982;
8844 -> 5981;
8845 -> 5975;
8846 -> 8844;
8846 -> 8845;
8846 -> 5975;
8847 -> 8846;
8848 -> 8844;
8848 -> 8847;
8849 -> 8847;
8850 -> 8848;
8850 -> 8849;
8851 -> 8849;
8852 -> 8850;
8852 -> 8843;
8852 -> 8851;
8853 -> 8852;
8853 -> 8843;
8853 -> 7030;
8853 -> 8851;
8854 -> 8851;
8855 -> 8853;
8855 -> 8854;
8855 -> 8851;
8856 -> 8855;
8856 -> 8849;
8857 -> 8856;
8858 -> 8857;
8858 -> 8856;
8859 -> 8856;
8860 -> 8858;
8860 -> 8859;
8861 -> 8850;
8861 -> 8859;
8862 -> 8859;
8863 -> 8861;
8863 -> 8862;
8864 -> 8863;
8864 -> 8862;
8865 -> 8862;
8866 -> 8864;
8866 -> 8865;
8867 -> 8866;
8867 -> 8865;
8868 -> 8867;
8868 -> 8862;
8869 -> 8868;
8869 -> 8859;
8870 -> 8860;
8870 -> 8859;
8871 -> 8859;
8872 -> 8861;
8872 -> 8871;
8873 -> 8872;
8873 -> 8859;
8874 -> 8859;
8875 -> 8861;
8875 -> 8874;
8876 -> 8874;
8877 -> 8875;
8877 -> 8843;
8877 -> 8876;
8878 -> 8877;
8878 -> 8843;
8878 -> 7070;
8878 -> 8876;
8879 -> 8876;
8880 -> 8878;
8880 -> 8879;
8880 -> 8876;
8881 -> 8880;
8881 -> 8874;
8882 -> 8881;
8883 -> 8882;
8884 -> 8882;
8884 -> 8881;
8885 -> 8881;
8886 -> 8885;
8887 -> 8885;
8887 -> 8843;
8887 -> 8886;
8888 -> 8887;
8888 -> 8843;
8888 -> 6992;
8888 -> 8886;
8889 -> 8888;
8889 -> 8885;
8890 -> 8889;
8890 -> 8881;
8891 -> 8884;
8891 -> 8890;
8891 -> 8881;
8892 -> 8891;
8892 -> 8881;
8893 -> 8881;
8894 -> 8892;
8894 -> 8893;
8895 -> 8875;
8895 -> 8843;
8895 -> 8893;
8896 -> 8894;
8896 -> 8893;
8897 -> 8896;
8898 -> 8895;
8898 -> 8843;
8898 -> 8893;
8899 -> 8897;
8899 -> 8893;
8900 -> 8893;
8901 -> 8898;
8901 -> 8900;
8902 -> 8899;
8902 -> 8900;
8903 -> 8901;
8903 -> 8902;
8903 -> 8900;
8904 -> 8900;
8905 -> 8895;
8905 -> 8843;
8905 -> 8893;
8906 -> 8897;
8906 -> 8893;
8907 -> 8905;
8907 -> 8906;
8907 -> 8893;
8908 -> 8881;
8909 -> 8874;
8910 -> 8875;
8910 -> 8843;
8910 -> 8909;
8911 -> 8910;
8911 -> 8843;
8911 -> 8907;
8911 -> 7066;
8911 -> 8909;
8912 -> 8909;
8913 -> 8911;
8913 -> 8912;
8913 -> 8909;
8914 -> 8913;
8914 -> 8874;
8915 -> 8914;
8915 -> 8859;
8916 -> 8859;
8917 -> 8870;
8917 -> 8916;
8918 -> 8873;
8918 -> 8916;
8919 -> 8915;
8919 -> 8916;
8920 -> 8861;
8920 -> 8916;
8921 -> 8917;
8921 -> 8916;
8922 -> 8916;
8923 -> 8918;
8923 -> 8922;
8924 -> 8923;
8924 -> 8843;
8924 -> 8922;
8925 -> 8923;
8925 -> 8916;
8926 -> 8916;
8927 -> 8921;
8927 -> 8926;
8928 -> 8925;
8928 -> 8926;
8929 -> 8920;
8929 -> 8926;
8930 -> 8926;
8931 -> 8928;
8931 -> 8930;
8932 -> 8931;
8932 -> 8843;
8932 -> 8930;
8933 -> 0;
8933 -> 8930;
8934 -> 8932;
8935 -> 8931;
8935 -> 8934;
8936 -> 8934;
8937 -> 8936;
8937 -> 8934;
8938 -> 8934;
8939 -> 8935;
8939 -> 8938;
8940 -> 8938;
8941 -> 8940;
8941 -> 8938;
8942 -> 8938;
8943 -> 8939;
8943 -> 8942;
8944 -> 8942;
8945 -> 8943;
8945 -> 8944;
8946 -> 8945;
8946 -> 8843;
8946 -> 8944;
8947 -> 3414;
8947 -> 8944;
8948 -> 8945;
8948 -> 8843;
8948 -> 8946;
8949 -> 8946;
8950 -> 8945;
8950 -> 8949;
8951 -> 8949;
8952 -> 8949;
8953 -> 8951;
8953 -> 8952;
8954 -> 8950;
8954 -> 8952;
8955 -> 8952;
8956 -> 8952;
8957 -> 8955;
8957 -> 8956;
8958 -> 8954;
8958 -> 8956;
8959 -> 8958;
8960 -> 8958;
8960 -> 8959;
8961 -> 8959;
8961 -> 8958;
8962 -> 8958;
8962 -> 8843;
8962 -> 8907;
8963 -> 8962;
8964 -> 8962;
8964 -> 8958;
8965 -> 8964;
8965 -> 8958;
8966 -> 8957;
8966 -> 8965;
8967 -> 8965;
8968 -> 8967;
8969 -> 8967;
8969 -> 8968;
8970 -> 8968;
8970 -> 8967;
8971 -> 8967;
8971 -> 8965;
8972 -> 8964;
8972 -> 8965;
8973 -> 8965;
8974 -> 8958;
8974 -> 8962;
8974 -> 8965;
8975 -> 8971;
8975 -> 8965;
8976 -> 8965;
8977 -> 8972;
8977 -> 8976;
8978 -> 8973;
8978 -> 8976;
8979 -> 8974;
8979 -> 8976;
8980 -> 8975;
8980 -> 8976;
8981 -> 8973;
8981 -> 8976;
8982 -> 8976;
8983 -> 8977;
8983 -> 8982;
8983 -> 8976;
8984 -> 8977;
8984 -> 8965;
8985 -> 8958;
8985 -> 8980;
8985 -> 8965;
8986 -> 8971;
8986 -> 8965;
8987 -> 8965;
8988 -> 8984;
8988 -> 8987;
8989 -> 8985;
8989 -> 8987;
8990 -> 8986;
8990 -> 8987;
8991 -> 8990;
8991 -> 8980;
8991 -> 8987;
8992 -> 8991;
8992 -> 8965;
8993 -> 8958;
8993 -> 8991;
8993 -> 8965;
8994 -> 8971;
8994 -> 8965;
8995 -> 8965;
8996 -> 8992;
8996 -> 8995;
8997 -> 8993;
8997 -> 8995;
8998 -> 8994;
8998 -> 8995;
8999 -> 8995;
9000 -> 8999;
9000 -> 8995;
9001 -> 8995;
9002 -> 8998;
9002 -> 9001;
9003 -> 9002;
9003 -> 8991;
9003 -> 9001;
9004 -> 9003;
9004 -> 8995;
9005 -> 8997;
9005 -> 8995;
9006 -> 8999;
9006 -> 8995;
9007 -> 9004;
9007 -> 9005;
9007 -> 9006;
9007 -> 8991;
9007 -> 9000;
9007 -> 8995;
9008 -> 9007;
9008 -> 8995;
9009 -> 8996;
9009 -> 8995;
9010 -> 9007;
9010 -> 8995;
9011 -> 8995;
9012 -> 9009;
9012 -> 9011;
9013 -> 9010;
9013 -> 9011;
9014 -> 9010;
9014 -> 9011;
9015 -> 9012;
9015 -> 9007;
9015 -> 9011;
9016 -> 9013;
9016 -> 9011;
9017 -> 9016;
9017 -> 9011;
9018 -> 9016;
9018 -> 9007;
9018 -> 9011;
9019 -> 9018;
9020 -> 9019;
9020 -> 9011;
9021 -> 9011;
9022 -> 9021;
9022 -> 9011;
9023 -> 9011;
9024 -> 9012;
9024 -> 9011;
9025 -> 9023;
9025 -> 9011;
9026 -> 9011;
9027 -> 9012;
9027 -> 9026;
9028 -> 0;
9028 -> 9026;
9029 -> 9028;
9029 -> 9011;
9030 -> 9029;
9030 -> 9011;
9031 -> 9011;
9032 -> 9030;
9032 -> 9031;
9033 -> 9025;
9033 -> 9031;
9034 -> 9032;
9034 -> 0;
9034 -> 9031;
9035 -> 9032;
9035 -> 9034;
9036 -> 9011;
9037 -> 9012;
9037 -> 9036;
9038 -> 9037;
9038 -> 9015;
9038 -> 9036;
9039 -> 9038;
9039 -> 9011;
9040 -> 9011;
9041 -> 9039;
9041 -> 9011;
9042 -> 9039;
9042 -> 9041;
9043 -> 9042;
9043 -> 9011;
9044 -> 9039;
9044 -> 9011;
9045 -> 9029;
9045 -> 9035;
9045 -> 9011;
9046 -> 9045;
9046 -> 9043;
9046 -> 9011;
9047 -> 9011;
9048 -> 9012;
9048 -> 9047;
9049 -> 9047;
9050 -> 9049;
9050 -> 9047;
9051 -> 9047;
9052 -> 9050;
9052 -> 9051;
9053 -> 9048;
9053 -> 9051;
9054 -> 9051;
9055 -> 9053;
9055 -> 9054;
9056 -> 9054;
9057 -> 9056;
9057 -> 9051;
9058 -> 9051;
9059 -> 9053;
9059 -> 9058;
9060 -> 9059;
9060 -> 9015;
9060 -> 9058;
9061 -> 9060;
9061 -> 9051;
9062 -> 9051;
9063 -> 9061;
9063 -> 9062;
9064 -> 9062;
9064 -> 9051;
9065 -> 9057;
9065 -> 9064;
9065 -> 9051;
9066 -> 9051;
9067 -> 9053;
9067 -> 9066;
9068 -> 9067;
9068 -> 9066;
9069 -> 9068;
9069 -> 9015;
9069 -> 9066;
9070 -> 9069;
9070 -> 9051;
9071 -> 9051;
9072 -> 9070;
9072 -> 9071;
9073 -> 9051;
9074 -> 9072;
9074 -> 9073;
9075 -> 9073;
9075 -> 9051;
9076 -> 9051;
9077 -> 9065;
9077 -> 9075;
9077 -> 9051;
9078 -> 9051;
9079 -> 9053;
9079 -> 9078;
9080 -> 9079;
9080 -> 9015;
9080 -> 9078;
9081 -> 9080;
9081 -> 9051;
9082 -> 9081;
9082 -> 3303;
9082 -> 9051;
9083 -> 9077;
9083 -> 9082;
9083 -> 9051;
9084 -> 9051;
9085 -> 9051;
9086 -> 9085;
9086 -> 9011;
9087 -> 9012;
9087 -> 9014;
9088 -> 9087;
9088 -> 8965;
9089 -> 8965;
9090 -> 8965;
9091 -> 9088;
9091 -> 9090;
9092 -> 9089;
9092 -> 9090;
9093 -> 9089;
9093 -> 9090;
9094 -> 9091;
9094 -> 9090;
9095 -> 9092;
9095 -> 0;
9095 -> 9090;
9096 -> 9092;
9096 -> 9090;
9097 -> 9091;
9097 -> 9096;
9098 -> 9096;
9099 -> 9097;
9099 -> 9098;
9100 -> 9098;
9101 -> 9099;
9101 -> 9100;
9102 -> 9101;
9102 -> 9098;
9103 -> 9098;
9104 -> 9102;
9104 -> 9103;
9105 -> 9091;
9105 -> 9090;
9106 -> 9105;
9106 -> 9090;
9107 -> 9091;
9107 -> 9106;
9108 -> 9106;
9109 -> 9107;
9109 -> 9108;
9110 -> 9108;
9111 -> 9109;
9111 -> 9110;
9112 -> 9111;
9112 -> 9108;
9113 -> 9108;
9114 -> 9112;
9114 -> 9113;
9115 -> 9092;
9115 -> 0;
9115 -> 9090;
9116 -> 9090;
9117 -> 9114;
9117 -> 9116;
9117 -> 9090;
9118 -> 9090;
9119 -> 9093;
9119 -> 9118;
9119 -> 9090;
9120 -> 9090;
9120 -> 8965;
9121 -> 8958;
9121 -> 9015;
9121 -> 8965;
9122 -> 8971;
9122 -> 8965;
9123 -> 8958;
9123 -> 8965;
9124 -> 8965;
9125 -> 9120;
9125 -> 9124;
9126 -> 9121;
9126 -> 9124;
9127 -> 9122;
9127 -> 9124;
9128 -> 9123;
9128 -> 9124;
9129 -> 9123;
9129 -> 9124;
9130 -> 9124;
9131 -> 9125;
9131 -> 9130;
9132 -> 9131;
9132 -> 9091;
9132 -> 9130;
9133 -> 9132;
9133 -> 9130;
9134 -> 9133;
9134 -> 9124;
9135 -> 9124;
9136 -> 9128;
9136 -> 9135;
9137 -> 9136;
9137 -> 9124;
9138 -> 9124;
9139 -> 9128;
9139 -> 9138;
9140 -> 9138;
9141 -> 9139;
9141 -> 9140;
9142 -> 9141;
9142 -> 9015;
9142 -> 9140;
9143 -> 9140;
9144 -> 9142;
9144 -> 9143;
9145 -> 9143;
9145 -> 9140;
9146 -> 9142;
9146 -> 9138;
9147 -> 9146;
9147 -> 9124;
9148 -> 9124;
9149 -> 9128;
9149 -> 9124;
9150 -> 9124;
9151 -> 9149;
9151 -> 9150;
9152 -> 9148;
9152 -> 9150;
9153 -> 9151;
9153 -> 9150;
9154 -> 9150;
9155 -> 9151;
9155 -> 9154;
9156 -> 9154;
9156 -> 9150;
9157 -> 9150;
9158 -> 9150;
9159 -> 9151;
9159 -> 9158;
9160 -> 0;
9160 -> 9158;
9161 -> 9159;
9161 -> 9015;
9161 -> 0;
9161 -> 9158;
9162 -> 9161;
9162 -> 9150;
9163 -> 9150;
9164 -> 9151;
9164 -> 9163;
9165 -> 9164;
9165 -> 9015;
9165 -> 9163;
9166 -> 9165;
9166 -> 9150;
9167 -> 9166;
9167 -> 9150;
9168 -> 9150;
9169 -> 9168;
9169 -> 9124;
9170 -> 9127;
9170 -> 9015;
9170 -> 9124;
9171 -> 9170;
9172 -> 9171;
9172 -> 9170;
9173 -> 9170;
9174 -> 9171;
9175 -> 9171;
9175 -> 9174;
9176 -> 9174;
9176 -> 9171;
9177 -> 9170;
9177 -> 9171;
9178 -> 9177;
9178 -> 9171;
9179 -> 9177;
9179 -> 9171;
9180 -> 9179;
9180 -> 9171;
9181 -> 9180;
9181 -> 9171;
9182 -> 9180;
9182 -> 9171;
9183 -> 9182;
9183 -> 9171;
9184 -> 9183;
9184 -> 9171;
9185 -> 9183;
9185 -> 9171;
9186 -> 9125;
9186 -> 9171;
9187 -> 8965;
9188 -> 9186;
9188 -> 9187;
9189 -> 9188;
9189 -> 9093;
9189 -> 9187;
9190 -> 8958;
9190 -> 9171;
9191 -> 9188;
9191 -> 8958;
9192 -> 3414;
9192 -> 8958;
9193 -> 8958;
9193 -> 9191;
9193 -> 8956;
9194 -> 9193;
9194 -> 8952;
9195 -> 9194;
9195 -> 8949;
9196 -> 8949;
9197 -> 9195;
9197 -> 9196;
9197 -> 8949;
9198 -> 9195;
9198 -> 8949;
9199 -> 8950;
9199 -> 8949;
9200 -> 8949;
9201 -> 9198;
9201 -> 9200;
9202 -> 9199;
9202 -> 9200;
9203 -> 9200;
9204 -> 9201;
9204 -> 9203;
9204 -> 9200;
9205 -> 9200;
9206 -> 9202;
9206 -> 9205;
9206 -> 9200;
9207 -> 9200;
9208 -> 9202;
9208 -> 9207;
9209 -> 9208;
9209 -> 9200;
9210 -> 9200;
9211 -> 9201;
9211 -> 9200;
9212 -> 9200;
9213 -> 9201;
9213 -> 9212;
9214 -> 9212;
9215 -> 9214;
9215 -> 9200;
9216 -> 9210;
9216 -> 9200;
9217 -> 9200;
9218 -> 9211;
9218 -> 9217;
9219 -> 9215;
9219 -> 9217;
9220 -> 9216;
9220 -> 9217;
9221 -> 9217;
9222 -> 9218;
9222 -> 9221;
9222 -> 9217;
9223 -> 9217;
9224 -> 9218;
9224 -> 9223;
9225 -> 9224;
9225 -> 9217;
9226 -> 9225;
9226 -> 9217;
9227 -> 9226;
9227 -> 9220;
9227 -> 9191;
9227 -> 9210;
9227 -> 9217;
9228 -> 9217;
9229 -> 9227;
9229 -> 9228;
9230 -> 9228;
9231 -> 9229;
9231 -> 9230;
9232 -> 9231;
9232 -> 9228;
9233 -> 9228;
9234 -> 9229;
9234 -> 9233;
9235 -> 9234;
9235 -> 9228;
9236 -> 9235;
9237 -> 9225;
9237 -> 9236;
9238 -> 9237;
9238 -> 9235;
9238 -> 9236;
9239 -> 9238;
9239 -> 9235;
9240 -> 9239;
9241 -> 9239;
9242 -> 9240;
9242 -> 9241;
9243 -> 9241;
9244 -> 9241;
9245 -> 9241;
9245 -> 9244;
9246 -> 9244;
9246 -> 9241;
9247 -> 9241;
9248 -> 9243;
9248 -> 9241;
9249 -> 9241;
9250 -> 9241;
9251 -> 9241;
9252 -> 9241;
9253 -> 9241;
9254 -> 9253;
9254 -> 9241;
9255 -> 9254;
9255 -> 9253;
9255 -> 9241;
9256 -> 9254;
9256 -> 9241;
9257 -> 9256;
9258 -> 9257;
9258 -> 9253;
9258 -> 9241;
9259 -> 9241;
9260 -> 9259;
9260 -> 9253;
9260 -> 9241;
9261 -> 9253;
9261 -> 9241;
9262 -> 9241;
9263 -> 9261;
9263 -> 9241;
9264 -> 9241;
9265 -> 9241;
9265 -> 9264;
9266 -> 0;
9266 -> 9264;
9267 -> 9266;
9267 -> 9241;
9268 -> 9267;
9268 -> 9241;
9269 -> 9241;
9270 -> 9268;
9270 -> 9269;
9271 -> 9263;
9271 -> 9269;
9272 -> 9270;
9272 -> 0;
9272 -> 9269;
9273 -> 9270;
9273 -> 9272;
9274 -> 9241;
9275 -> 9241;
9275 -> 9274;
9276 -> 9275;
9276 -> 9241;
9276 -> 9274;
9277 -> 9276;
9277 -> 9241;
9278 -> 9241;
9279 -> 9277;
9279 -> 9241;
9280 -> 9277;
9280 -> 9279;
9281 -> 9280;
9281 -> 9241;
9282 -> 9277;
9282 -> 9241;
9283 -> 9267;
9283 -> 9273;
9283 -> 9241;
9284 -> 9283;
9284 -> 9281;
9284 -> 9241;
9285 -> 9241;
9286 -> 9241;
9286 -> 9285;
9287 -> 9285;
9288 -> 9287;
9288 -> 9285;
9289 -> 9285;
9290 -> 9288;
9290 -> 9289;
9291 -> 9286;
9291 -> 9289;
9292 -> 9289;
9293 -> 9291;
9293 -> 9292;
9294 -> 9292;
9295 -> 9294;
9295 -> 9289;
9296 -> 9289;
9297 -> 9291;
9297 -> 9296;
9298 -> 9297;
9298 -> 9241;
9298 -> 9296;
9299 -> 9298;
9299 -> 9289;
9300 -> 9289;
9301 -> 9299;
9301 -> 9300;
9302 -> 9300;
9302 -> 9289;
9303 -> 9295;
9303 -> 9302;
9303 -> 9289;
9304 -> 9289;
9305 -> 9291;
9305 -> 9304;
9306 -> 9305;
9306 -> 9304;
9307 -> 9306;
9307 -> 9241;
9307 -> 9304;
9308 -> 9307;
9308 -> 9289;
9309 -> 9289;
9310 -> 9308;
9310 -> 9309;
9311 -> 9289;
9312 -> 9310;
9312 -> 9311;
9313 -> 9311;
9313 -> 9289;
9314 -> 9289;
9315 -> 9303;
9315 -> 9313;
9315 -> 9289;
9316 -> 9289;
9317 -> 9291;
9317 -> 9316;
9318 -> 9317;
9318 -> 9289;
9319 -> 9318;
9319 -> 3303;
9319 -> 9289;
9320 -> 9315;
9320 -> 9319;
9320 -> 9289;
9321 -> 9289;
9322 -> 9289;
9323 -> 9322;
9323 -> 9241;
9324 -> 9253;
9324 -> 9241;
9325 -> 9253;
9325 -> 0;
9325 -> 9241;
9326 -> 9253;
9326 -> 9241;
9327 -> 9253;
9327 -> 9326;
9328 -> 9326;
9329 -> 9327;
9329 -> 9328;
9330 -> 9328;
9331 -> 9329;
9331 -> 9330;
9332 -> 9331;
9332 -> 9328;
9333 -> 9328;
9334 -> 9332;
9334 -> 9333;
9335 -> 9253;
9335 -> 9241;
9336 -> 9335;
9336 -> 9241;
9337 -> 9253;
9337 -> 9336;
9338 -> 9336;
9339 -> 9337;
9339 -> 9338;
9340 -> 9338;
9341 -> 9339;
9341 -> 9340;
9342 -> 9341;
9342 -> 9338;
9343 -> 9338;
9344 -> 9342;
9344 -> 9343;
9345 -> 9253;
9345 -> 0;
9345 -> 9241;
9346 -> 9241;
9347 -> 9344;
9347 -> 9346;
9347 -> 9241;
9348 -> 9241;
9349 -> 9253;
9349 -> 9348;
9349 -> 9241;
9350 -> 9253;
9350 -> 9241;
9351 -> 9241;
9352 -> 9253;
9352 -> 9351;
9353 -> 9352;
9353 -> 9253;
9353 -> 9351;
9354 -> 9353;
9354 -> 9351;
9355 -> 9354;
9355 -> 9241;
9356 -> 9241;
9357 -> 9350;
9357 -> 9356;
9358 -> 9357;
9358 -> 9241;
9359 -> 9241;
9360 -> 9350;
9360 -> 9359;
9361 -> 9359;
9362 -> 9360;
9362 -> 9361;
9363 -> 9361;
9364 -> 9362;
9364 -> 9363;
9365 -> 9363;
9365 -> 9361;
9366 -> 9362;
9366 -> 9359;
9367 -> 9366;
9367 -> 9241;
9368 -> 9241;
9369 -> 9350;
9369 -> 9241;
9370 -> 9241;
9371 -> 9369;
9371 -> 9370;
9372 -> 9368;
9372 -> 9370;
9373 -> 9371;
9373 -> 9370;
9374 -> 9370;
9375 -> 9371;
9375 -> 9374;
9376 -> 9374;
9376 -> 9370;
9377 -> 9370;
9378 -> 9370;
9379 -> 9371;
9379 -> 9378;
9380 -> 0;
9380 -> 9378;
9381 -> 9379;
9381 -> 9370;
9382 -> 9370;
9383 -> 9371;
9383 -> 9382;
9384 -> 9383;
9384 -> 9241;
9384 -> 9382;
9385 -> 9384;
9385 -> 9370;
9386 -> 9385;
9386 -> 9370;
9387 -> 9370;
9388 -> 9387;
9388 -> 9241;
9389 -> 9253;
9390 -> 9253;
9391 -> 9253;
9392 -> 9253;
9392 -> 9391;
9393 -> 9391;
9393 -> 9253;
9394 -> 9253;
9395 -> 9394;
9395 -> 9253;
9396 -> 9394;
9396 -> 9253;
9397 -> 9396;
9397 -> 9253;
9398 -> 9397;
9398 -> 9253;
9399 -> 9397;
9399 -> 9253;
9400 -> 9399;
9400 -> 9253;
9401 -> 9400;
9401 -> 9253;
9402 -> 9400;
9402 -> 9253;
9403 -> 9394;
9403 -> 9253;
9403 -> 9241;
9404 -> 9394;
9404 -> 9239;
9405 -> 9219;
9405 -> 9239;
9406 -> 9220;
9406 -> 9239;
9407 -> 9239;
9408 -> 9404;
9408 -> 9407;
9409 -> 9405;
9409 -> 9407;
9410 -> 9406;
9410 -> 9407;
9411 -> 9407;
9412 -> 9408;
9412 -> 9411;
9412 -> 9407;
9413 -> 9407;
9414 -> 9408;
9414 -> 9413;
9415 -> 9414;
9415 -> 9407;
9416 -> 0;
9416 -> 9415;
9417 -> 9416;
9418 -> 9416;
9419 -> 9416;
9420 -> 9416;
9420 -> 9419;
9421 -> 9419;
9421 -> 9416;
9422 -> 9416;
9423 -> 9409;
9423 -> 9416;
9424 -> 9416;
9425 -> 9422;
9425 -> 9424;
9425 -> 9416;
9426 -> 9425;
9427 -> 9416;
9428 -> 9409;
9428 -> 9427;
9428 -> 9416;
9429 -> 9235;
9430 -> 9219;
9430 -> 9429;
9430 -> 9235;
9431 -> 9200;
9432 -> 9202;
9432 -> 9200;
9433 -> 9432;
9433 -> 9210;
9433 -> 9422;
9433 -> 9200;
9434 -> 9200;
9435 -> 9434;
9436 -> 9434;
9437 -> 9210;
9437 -> 9433;
9437 -> 9200;
9438 -> 9433;
9438 -> 9200;
9439 -> 8949;
9440 -> 8950;
9440 -> 9439;
9441 -> 9439;
9442 -> 9441;
9442 -> 9440;
9442 -> 9439;
9443 -> 8949;
9444 -> 9195;
9444 -> 8949;
9445 -> 9444;
9445 -> 8946;
9446 -> 3414;
9446 -> 8946;
9447 -> 8948;
9447 -> 9445;
9447 -> 9446;
9447 -> 9437;
9447 -> 9442;
9447 -> 8946;
9448 -> 8945;
9448 -> 9447;
9448 -> 8944;
9449 -> 9448;
9449 -> 8942;
9450 -> 8942;
9451 -> 9449;
9451 -> 9450;
9451 -> 8942;
9452 -> 9449;
9452 -> 9451;
9453 -> 9451;
9454 -> 9452;
9454 -> 9453;
9455 -> 9453;
9456 -> 9454;
9456 -> 9455;
9456 -> 9453;
9457 -> 9454;
9457 -> 9453;
9458 -> 9453;
9458 -> 9451;
9459 -> 9451;
9460 -> 9459;
9461 -> 9459;
9462 -> 9459;
9463 -> 9459;
9464 -> 9459;
9465 -> 9459;
9466 -> 9465;
9466 -> 9459;
9467 -> 9459;
9468 -> 9459;
9468 -> 9467;
9469 -> 9467;
9470 -> 9469;
9470 -> 9459;
9471 -> 9459;
9472 -> 9465;
9473 -> 9465;
9474 -> 9470;
9474 -> 9465;
9475 -> 9465;
9476 -> 9475;
9477 -> 9465;
9478 -> 9470;
9478 -> 9477;
9478 -> 9465;
9479 -> 9465;
9479 -> 9459;
9480 -> 9459;
9481 -> 9465;
9481 -> 9451;
9482 -> 9481;
9483 -> 9481;
9484 -> 9482;
9484 -> 9483;
9485 -> 9483;
9486 -> 9484;
9486 -> 9485;
9486 -> 9483;
9487 -> 9484;
9487 -> 9483;
9488 -> 9483;
9488 -> 9481;
9489 -> 9481;
9490 -> 9481;
9491 -> 9481;
9492 -> 9491;
9493 -> 8942;
9494 -> 9493;
9494 -> 8938;
9495 -> 8938;
9496 -> 8941;
9496 -> 9495;
9497 -> 9494;
9497 -> 9495;
9498 -> 8939;
9498 -> 9495;
9499 -> 9495;
9500 -> 9497;
9500 -> 9499;
9500 -> 9495;
9501 -> 9500;
9502 -> 8938;
9503 -> 8939;
9503 -> 9502;
9504 -> 9502;
9505 -> 9503;
9505 -> 9504;
9506 -> 9505;
9506 -> 9492;
9506 -> 9504;
9507 -> 9504;
9508 -> 9506;
9508 -> 9507;
9509 -> 9507;
9509 -> 9504;
9510 -> 9506;
9510 -> 9502;
9511 -> 9510;
9511 -> 8938;
9512 -> 8938;
9513 -> 9511;
9513 -> 9512;
9514 -> 9512;
9515 -> 9513;
9515 -> 9514;
9516 -> 9514;
9517 -> 9515;
9517 -> 9516;
9518 -> 9516;
9519 -> 9517;
9519 -> 9492;
9519 -> 9518;
9519 -> 9516;
9520 -> 9514;
9521 -> 9515;
9521 -> 9512;
9522 -> 9512;
9523 -> 9496;
9523 -> 8938;
9524 -> 9523;
9524 -> 8934;
9525 -> 8934;
9526 -> 8937;
9526 -> 9525;
9527 -> 9524;
9527 -> 9525;
9528 -> 8935;
9528 -> 9525;
9529 -> 9525;
9530 -> 9527;
9530 -> 9529;
9530 -> 9525;
9531 -> 9530;
9532 -> 9531;
9533 -> 8935;
9533 -> 9532;
9534 -> 9533;
9534 -> 9492;
9534 -> 9532;
9535 -> 9532;
9536 -> 9534;
9536 -> 9535;
9537 -> 9535;
9537 -> 9532;
9538 -> 9534;
9538 -> 9531;
9539 -> 9531;
9540 -> 9538;
9540 -> 9539;
9541 -> 8935;
9541 -> 9492;
9541 -> 9531;
9542 -> 9540;
9543 -> 9542;
9544 -> 9543;
9544 -> 9542;
9545 -> 9542;
9546 -> 9543;
9546 -> 9545;
9546 -> 9542;
9547 -> 9546;
9548 -> 9547;
9548 -> 9546;
9549 -> 9548;
9549 -> 9546;
9550 -> 9549;
9551 -> 9550;
9551 -> 9549;
9552 -> 0;
9552 -> 9551;
9553 -> 9552;
9553 -> 9540;
9554 -> 9526;
9554 -> 8934;
9555 -> 9554;
9555 -> 8932;
9556 -> 9555;
9556 -> 8931;
9556 -> 8932;
9557 -> 8931;
9557 -> 9540;
9557 -> 9556;
9557 -> 8930;
9558 -> 9557;
9558 -> 8926;
9559 -> 8926;
9560 -> 9558;
9560 -> 9559;
9560 -> 8926;
9561 -> 8927;
9561 -> 8926;
9562 -> 9558;
9562 -> 8926;
9563 -> 8926;
9564 -> 9561;
9564 -> 9563;
9565 -> 9562;
9565 -> 9563;
9566 -> 8929;
9566 -> 9563;
9567 -> 9563;
9568 -> 8916;
9569 -> 8918;
9569 -> 9568;
9570 -> 9569;
9570 -> 9540;
9570 -> 9568;
9571 -> 8919;
9571 -> 8916;
9572 -> 8916;
9573 -> 9564;
9573 -> 9572;
9574 -> 9570;
9574 -> 9572;
9575 -> 9571;
9575 -> 9572;
9576 -> 8920;
9576 -> 9572;
9577 -> 8915;
9577 -> 9572;
9578 -> 9572;
9579 -> 9574;
9579 -> 9572;
9580 -> 9579;
9580 -> 9540;
9580 -> 9552;
9580 -> 9556;
9580 -> 9572;
9581 -> 9572;
9582 -> 9581;
9582 -> 8916;
9583 -> 9565;
9583 -> 9582;
9583 -> 8916;
9584 -> 8859;
9585 -> 8861;
9585 -> 9584;
9586 -> 9584;
9587 -> 9585;
9587 -> 9586;
9588 -> 9587;
9588 -> 9540;
9588 -> 9586;
9589 -> 9584;
9590 -> 9588;
9590 -> 9540;
9590 -> 9589;
9591 -> 0;
9591 -> 9589;
9592 -> 9591;
9592 -> 8859;
9593 -> 0;
9593 -> 8859;
9594 -> 8859;
9595 -> 9573;
9595 -> 9594;
9596 -> 9592;
9596 -> 9594;
9597 -> 9593;
9597 -> 9594;
9598 -> 8861;
9598 -> 9594;
9599 -> 8915;
9599 -> 9594;
9600 -> 9594;
9601 -> 9596;
9601 -> 9594;
9602 -> 9594;
9603 -> 9602;
9603 -> 8859;
9604 -> 9583;
9604 -> 9603;
9604 -> 8859;
9605 -> 8859;
9606 -> 8861;
9606 -> 9605;
9607 -> 9606;
9607 -> 9540;
9607 -> 9605;
9608 -> 8859;
9609 -> 9595;
9609 -> 9608;
9610 -> 9607;
9610 -> 9608;
9611 -> 8861;
9611 -> 9608;
9612 -> 9610;
9612 -> 9608;
9613 -> 9612;
9613 -> 9540;
9613 -> 9552;
9613 -> 9556;
9613 -> 9608;
9614 -> 9609;
9614 -> 9613;
9615 -> 9613;
9616 -> 9613;
9617 -> 9614;
9617 -> 9616;
9618 -> 9615;
9618 -> 9616;
9619 -> 9611;
9619 -> 9616;
9620 -> 9617;
9620 -> 9616;
9621 -> 9616;
9622 -> 9618;
9622 -> 9621;
9623 -> 9622;
9623 -> 9616;
9624 -> 8915;
9624 -> 9616;
9625 -> 9616;
9626 -> 9620;
9626 -> 9625;
9627 -> 9623;
9627 -> 9625;
9628 -> 9624;
9628 -> 9625;
9629 -> 9619;
9629 -> 9625;
9630 -> 9627;
9630 -> 9540;
9630 -> 9625;
9631 -> 9629;
9631 -> 9625;
9632 -> 9627;
9633 -> 9627;
9634 -> 9627;
9635 -> 9627;
9635 -> 9634;
9636 -> 9634;
9636 -> 9627;
9637 -> 9627;
9638 -> 9633;
9638 -> 9627;
9639 -> 9627;
9640 -> 9627;
9641 -> 9627;
9642 -> 9627;
9643 -> 9627;
9644 -> 9643;
9644 -> 9627;
9645 -> 9643;
9645 -> 9627;
9646 -> 9645;
9647 -> 9646;
9647 -> 9627;
9648 -> 9627;
9649 -> 9648;
9649 -> 9627;
9650 -> 9627;
9651 -> 9627;
9652 -> 9650;
9652 -> 9627;
9653 -> 9627;
9654 -> 9627;
9654 -> 9653;
9655 -> 0;
9655 -> 9653;
9656 -> 9655;
9656 -> 9627;
9657 -> 9656;
9657 -> 9627;
9658 -> 9627;
9659 -> 9657;
9659 -> 9658;
9660 -> 9652;
9660 -> 9658;
9661 -> 9659;
9661 -> 0;
9661 -> 9658;
9662 -> 9659;
9662 -> 9661;
9663 -> 9627;
9664 -> 9627;
9664 -> 9663;
9665 -> 9664;
9665 -> 9627;
9665 -> 9663;
9666 -> 9665;
9666 -> 9627;
9667 -> 9627;
9668 -> 9666;
9668 -> 9627;
9669 -> 9666;
9669 -> 9668;
9670 -> 9669;
9670 -> 9627;
9671 -> 9666;
9671 -> 9627;
9672 -> 9656;
9672 -> 9662;
9672 -> 9627;
9673 -> 9672;
9673 -> 9670;
9673 -> 9627;
9674 -> 9627;
9675 -> 9627;
9675 -> 9674;
9676 -> 9674;
9677 -> 9676;
9677 -> 9674;
9678 -> 9674;
9679 -> 9677;
9679 -> 9678;
9680 -> 9675;
9680 -> 9678;
9681 -> 9678;
9682 -> 9680;
9682 -> 9681;
9683 -> 9681;
9684 -> 9683;
9684 -> 9678;
9685 -> 9678;
9686 -> 9680;
9686 -> 9685;
9687 -> 9686;
9687 -> 9627;
9687 -> 9685;
9688 -> 9687;
9688 -> 9678;
9689 -> 9678;
9690 -> 9688;
9690 -> 9689;
9691 -> 9689;
9691 -> 9678;
9692 -> 9684;
9692 -> 9691;
9692 -> 9678;
9693 -> 9678;
9694 -> 9680;
9694 -> 9693;
9695 -> 9694;
9695 -> 9693;
9696 -> 9695;
9696 -> 9627;
9696 -> 9693;
9697 -> 9696;
9697 -> 9678;
9698 -> 9678;
9699 -> 9697;
9699 -> 9698;
9700 -> 9678;
9701 -> 9699;
9701 -> 9700;
9702 -> 9700;
9702 -> 9678;
9703 -> 9678;
9704 -> 9692;
9704 -> 9702;
9704 -> 9678;
9705 -> 9678;
9706 -> 9680;
9706 -> 9705;
9707 -> 9706;
9707 -> 9678;
9708 -> 9707;
9708 -> 3303;
9708 -> 9678;
9709 -> 9704;
9709 -> 9708;
9709 -> 9678;
9710 -> 9678;
9711 -> 9678;
9712 -> 9711;
9712 -> 9627;
9713 -> 9627;
9714 -> 9627;
9714 -> 0;
9715 -> 9627;
9716 -> 9627;
9716 -> 9715;
9717 -> 9715;
9718 -> 9716;
9718 -> 9717;
9719 -> 9717;
9720 -> 9718;
9720 -> 9719;
9721 -> 9720;
9721 -> 9717;
9722 -> 9717;
9723 -> 9721;
9723 -> 9722;
9724 -> 9627;
9725 -> 9724;
9725 -> 9627;
9726 -> 9627;
9726 -> 9725;
9727 -> 9725;
9728 -> 9726;
9728 -> 9727;
9729 -> 9727;
9730 -> 9728;
9730 -> 9729;
9731 -> 9730;
9731 -> 9727;
9732 -> 9727;
9733 -> 9731;
9733 -> 9732;
9734 -> 9627;
9734 -> 0;
9735 -> 9627;
9736 -> 9733;
9736 -> 9735;
9736 -> 9627;
9737 -> 9627;
9738 -> 9627;
9739 -> 9627;
9740 -> 9627;
9740 -> 9739;
9741 -> 9740;
9741 -> 9627;
9741 -> 9739;
9742 -> 9741;
9742 -> 9739;
9743 -> 9742;
9743 -> 9627;
9744 -> 9627;
9745 -> 9738;
9745 -> 9744;
9746 -> 9745;
9746 -> 9627;
9747 -> 9627;
9748 -> 9738;
9748 -> 9747;
9749 -> 9747;
9750 -> 9748;
9750 -> 9749;
9751 -> 9749;
9752 -> 9750;
9752 -> 9751;
9753 -> 9751;
9753 -> 9749;
9754 -> 9750;
9754 -> 9747;
9755 -> 9754;
9755 -> 9627;
9756 -> 9627;
9757 -> 9738;
9757 -> 9627;
9758 -> 9627;
9759 -> 9757;
9759 -> 9758;
9760 -> 9756;
9760 -> 9758;
9761 -> 9759;
9761 -> 9758;
9762 -> 9758;
9763 -> 9759;
9763 -> 9762;
9764 -> 9762;
9764 -> 9758;
9765 -> 9758;
9766 -> 9758;
9767 -> 9759;
9767 -> 9766;
9768 -> 0;
9768 -> 9766;
9769 -> 9767;
9769 -> 9758;
9770 -> 9758;
9771 -> 9759;
9771 -> 9770;
9772 -> 9771;
9772 -> 9627;
9772 -> 9770;
9773 -> 9772;
9773 -> 9758;
9774 -> 9773;
9774 -> 9758;
9775 -> 9758;
9776 -> 9775;
9776 -> 9627;
9777 -> 9627;
9778 -> 9627;
9779 -> 9627;
9780 -> 9627;
9781 -> 9780;
9781 -> 9627;
9782 -> 9781;
9782 -> 9627;
9783 -> 9781;
9783 -> 9627;
9784 -> 9783;
9784 -> 9627;
9785 -> 9784;
9785 -> 9627;
9786 -> 9784;
9786 -> 9627;
9787 -> 9627;
9788 -> 9627;
9789 -> 9627;
9790 -> 9744;
9790 -> 9627;
9791 -> 9627;
9792 -> 9627;
9792 -> 9791;
9793 -> 9791;
9794 -> 9793;
9794 -> 9627;
9795 -> 9627;
9796 -> 9744;
9797 -> 9744;
9798 -> 9794;
9798 -> 9744;
9799 -> 9744;
9800 -> 9799;
9801 -> 9744;
9802 -> 9798;
9802 -> 9801;
9802 -> 9744;
9803 -> 9794;
9803 -> 9801;
9803 -> 9744;
9804 -> 9744;
9804 -> 9627;
9805 -> 9627;
9806 -> 9744;
9807 -> 9744;
9808 -> 9806;
9808 -> 9807;
9809 -> 9807;
9810 -> 9808;
9810 -> 9809;
9810 -> 9807;
9811 -> 9808;
9811 -> 9807;
9812 -> 9807;
9812 -> 9744;
9813 -> 9627;
9814 -> 9627;
9815 -> 9627;
9816 -> 9627;
9816 -> 9815;
9817 -> 9815;
9818 -> 9816;
9818 -> 9817;
9819 -> 9818;
9819 -> 9744;
9819 -> 9817;
9820 -> 9817;
9821 -> 9819;
9821 -> 9820;
9822 -> 9820;
9822 -> 9817;
9823 -> 9819;
9823 -> 9815;
9824 -> 9823;
9824 -> 9627;
9825 -> 9627;
9826 -> 9824;
9826 -> 9825;
9827 -> 9825;
9828 -> 9826;
9828 -> 9827;
9829 -> 9827;
9830 -> 9828;
9830 -> 9829;
9831 -> 9829;
9832 -> 9830;
9832 -> 9744;
9832 -> 9831;
9832 -> 9829;
9833 -> 9827;
9834 -> 9828;
9834 -> 9825;
9835 -> 9825;
9836 -> 9813;
9836 -> 9744;
9837 -> 9813;
9838 -> 9836;
9838 -> 9837;
9839 -> 9837;
9839 -> 9813;
9840 -> 9627;
9840 -> 9744;
9840 -> 9813;
9841 -> 9836;
9842 -> 9836;
9843 -> 9627;
9843 -> 9836;
9843 -> 9625;
9844 -> 9843;
9844 -> 9625;
9845 -> 9625;
9846 -> 9844;
9846 -> 9845;
9846 -> 9625;
9847 -> 9844;
9847 -> 9625;
9848 -> 9625;
9849 -> 9847;
9849 -> 9848;
9850 -> 9631;
9850 -> 9848;
9851 -> 9625;
9852 -> 9627;
9852 -> 9851;
9853 -> 9852;
9853 -> 9836;
9853 -> 9851;
9854 -> 9625;
9855 -> 9853;
9855 -> 9854;
9856 -> 9628;
9856 -> 9854;
9857 -> 9629;
9857 -> 9854;
9858 -> 8915;
9858 -> 9854;
9859 -> 9854;
9860 -> 9855;
9860 -> 9854;
9861 -> 9854;
9862 -> 9849;
9862 -> 9861;
9862 -> 9625;
9863 -> 9616;
9864 -> 9618;
9864 -> 9863;
9865 -> 0;
9865 -> 9863;
9866 -> 9865;
9866 -> 9616;
9867 -> 9619;
9867 -> 9616;
9868 -> 9616;
9869 -> 9867;
9869 -> 9868;
9870 -> 9869;
9870 -> 9836;
9870 -> 9868;
9871 -> 9869;
9871 -> 9836;
9871 -> 9868;
9872 -> 9871;
9872 -> 9616;
9873 -> 9616;
9874 -> 9626;
9874 -> 9873;
9875 -> 9866;
9875 -> 9873;
9876 -> 9872;
9876 -> 9873;
9877 -> 9619;
9877 -> 9873;
9878 -> 8915;
9878 -> 9873;
9879 -> 9873;
9880 -> 9875;
9880 -> 9873;
9881 -> 9873;
9882 -> 9881;
9882 -> 9616;
9883 -> 9862;
9883 -> 9882;
9883 -> 9616;
9884 -> 9608;
9885 -> 9884;
9885 -> 8859;
9886 -> 9604;
9886 -> 9885;
9886 -> 8859;
9887 -> 8859;
9888 -> 8861;
9888 -> 9887;
9889 -> 9887;
9890 -> 9888;
9890 -> 9889;
9891 -> 9890;
9891 -> 9836;
9891 -> 9889;
9892 -> 9891;
9892 -> 9887;
9893 -> 9887;
9894 -> 9892;
9894 -> 9893;
9894 -> 9887;
9895 -> 9894;
9895 -> 9887;
9896 -> 9895;
9897 -> 9892;
9897 -> 9896;
9898 -> 9896;
9899 -> 9897;
9899 -> 9898;
9900 -> 9898;
9901 -> 9899;
9901 -> 9900;
9902 -> 9900;
9902 -> 9898;
9903 -> 9899;
9903 -> 9896;
9904 -> 9903;
9904 -> 8859;
9905 -> 8859;
9906 -> 9904;
9906 -> 9905;
9907 -> 9905;
9908 -> 9906;
9908 -> 9907;
9909 -> 9907;
9910 -> 9908;
9910 -> 9909;
9911 -> 9909;
9912 -> 9910;
9912 -> 9836;
9912 -> 9911;
9912 -> 9909;
9913 -> 9907;
9914 -> 9908;
9914 -> 9905;
9915 -> 9905;
9916 -> 8859;
9917 -> 8859;
9918 -> 9917;
9918 -> 8856;
9919 -> 9874;
9919 -> 8856;
9920 -> 8856;
9921 -> 9919;
9921 -> 9920;
9922 -> 8850;
9922 -> 9920;
9923 -> 9922;
9923 -> 9836;
9923 -> 9920;
9924 -> 9923;
9924 -> 9836;
9924 -> 9920;
9925 -> 9923;
9925 -> 9924;
9926 -> 9925;
9926 -> 8856;
9927 -> 8856;
9928 -> 9921;
9928 -> 9927;
9928 -> 8856;
9929 -> 8856;
9930 -> 9927;
9930 -> 9929;
9931 -> 8850;
9931 -> 9929;
9932 -> 9929;
9933 -> 9931;
9933 -> 9836;
9933 -> 9932;
9934 -> 9933;
9934 -> 9836;
9934 -> 7074;
9934 -> 9932;
9935 -> 9932;
9936 -> 9934;
9936 -> 9935;
9936 -> 9932;
9937 -> 9936;
9937 -> 9929;
9938 -> 9937;
9939 -> 9931;
9939 -> 9938;
9940 -> 9938;
9941 -> 9939;
9941 -> 9940;
9942 -> 9941;
9942 -> 9836;
9942 -> 9940;
9943 -> 9942;
9943 -> 9938;
9944 -> 9938;
9945 -> 9943;
9945 -> 9944;
9945 -> 9938;
9946 -> 9945;
9946 -> 9938;
9947 -> 9946;
9948 -> 9943;
9948 -> 9947;
9949 -> 9947;
9950 -> 9948;
9950 -> 9949;
9951 -> 9949;
9952 -> 9950;
9952 -> 9951;
9953 -> 9951;
9953 -> 9949;
9954 -> 9950;
9954 -> 9947;
9955 -> 9954;
9955 -> 9937;
9956 -> 9937;
9957 -> 9955;
9957 -> 9956;
9958 -> 9957;
9958 -> 9937;
9959 -> 9931;
9959 -> 9836;
9959 -> 9937;
9960 -> 9955;
9960 -> 9937;
9961 -> 9937;
9962 -> 9937;
9963 -> 9960;
9963 -> 9962;
9964 -> 9961;
9964 -> 9962;
9965 -> 9963;
9965 -> 9962;
9966 -> 9962;
9967 -> 9962;
9968 -> 9962;
9969 -> 9965;
9969 -> 9968;
9970 -> 9966;
9970 -> 9968;
9971 -> 9967;
9971 -> 9968;
9972 -> 9968;
9973 -> 9969;
9973 -> 9972;
9973 -> 9968;
9974 -> 9958;
9974 -> 9959;
9974 -> 9961;
9974 -> 9969;
9974 -> 9968;
9974 -> 9970;
9974 -> 9971;
9974 -> 9836;
9974 -> 9627;
9974 -> 9937;
9975 -> 9974;
9975 -> 9937;
9976 -> 0;
9976 -> 9937;
9977 -> 9937;
9978 -> 9931;
9978 -> 9977;
9979 -> 9978;
9979 -> 9974;
9979 -> 9977;
9980 -> 9978;
9980 -> 9974;
9980 -> 9977;
9981 -> 9977;
9982 -> 9978;
9982 -> 9981;
9983 -> 9981;
9984 -> 9981;
9985 -> 9983;
9985 -> 9984;
9986 -> 9985;
9986 -> 9984;
9987 -> 9985;
9987 -> 9984;
9988 -> 9985;
9988 -> 9984;
9989 -> 9985;
9989 -> 9984;
9990 -> 9985;
9990 -> 9984;
9991 -> 9985;
9991 -> 9984;
9992 -> 9985;
9992 -> 9984;
9993 -> 9981;
9994 -> 9982;
9994 -> 9974;
9994 -> 9993;
9995 -> 9994;
9995 -> 9974;
9995 -> 7022;
9995 -> 9993;
9996 -> 9993;
9997 -> 9995;
9997 -> 9996;
9997 -> 9993;
9998 -> 9997;
9998 -> 9981;
9999 -> 0;
9999 -> 9983;
9999 -> 9998;
10000 -> 9981;
10001 -> 9982;
10001 -> 9974;
10001 -> 10000;
10002 -> 10001;
10002 -> 9981;
10003 -> 0;
10003 -> 9983;
10003 -> 10002;
10004 -> 9981;
10005 -> 9982;
10005 -> 9974;
10005 -> 10004;
10006 -> 10005;
10006 -> 9974;
10006 -> 7026;
10006 -> 10004;
10007 -> 10004;
10008 -> 10006;
10008 -> 10007;
10008 -> 10004;
10009 -> 10008;
10009 -> 9981;
10010 -> 9981;
10011 -> 9982;
10011 -> 9974;
10011 -> 10010;
10012 -> 10011;
10012 -> 9974;
10012 -> 7034;
10012 -> 10010;
10013 -> 10010;
10014 -> 10012;
10014 -> 10013;
10014 -> 10010;
10015 -> 10014;
10015 -> 9981;
10016 -> 9981;
10017 -> 9982;
10017 -> 9974;
10017 -> 10016;
10018 -> 10017;
10018 -> 9974;
10018 -> 7038;
10018 -> 10016;
10019 -> 10016;
10020 -> 10018;
10020 -> 10019;
10020 -> 10016;
10021 -> 10020;
10021 -> 9981;
10022 -> 9981;
10023 -> 9982;
10023 -> 9974;
10023 -> 10022;
10024 -> 10023;
10024 -> 9974;
10024 -> 7062;
10024 -> 10022;
10025 -> 10022;
10026 -> 10024;
10026 -> 10025;
10026 -> 10022;
10027 -> 10026;
10027 -> 9981;
10028 -> 9981;
10029 -> 9982;
10029 -> 9974;
10029 -> 10028;
10030 -> 10029;
10030 -> 9974;
10030 -> 7018;
10030 -> 10028;
10031 -> 10028;
10032 -> 10030;
10032 -> 10031;
10032 -> 10028;
10033 -> 10032;
10033 -> 9981;
10034 -> 9983;
10034 -> 9981;
10035 -> 10034;
10035 -> 9977;
10036 -> 9980;
10036 -> 10035;
10036 -> 9986;
10036 -> 9987;
10036 -> 9988;
10036 -> 9999;
10036 -> 10003;
10036 -> 9991;
10036 -> 9992;
10036 -> 9974;
10036 -> 0;
10036 -> 9977;
10037 -> 10036;
10037 -> 9979;
10037 -> 9977;
10038 -> 10037;
10038 -> 9937;
10039 -> 9974;
10039 -> 9937;
10040 -> 0;
10040 -> 9937;
10041 -> 9937;
10042 -> 9931;
10042 -> 10038;
10042 -> 10041;
10043 -> 10042;
10043 -> 10038;
10043 -> 10041;
10044 -> 7074;
10044 -> 10041;
10045 -> 9937;
10046 -> 10038;
10046 -> 9937;
10047 -> 10046;
10047 -> 8856;
10048 -> 9928;
10048 -> 10047;
10048 -> 8856;
10049 -> 9921;
10049 -> 8856;
10050 -> 8856;
10051 -> 10049;
10051 -> 10050;
10052 -> 8850;
10052 -> 10050;
10053 -> 10050;
10054 -> 10052;
10054 -> 10038;
10054 -> 10053;
10055 -> 10054;
10055 -> 10038;
10055 -> 10043;
10055 -> 7030;
10055 -> 10053;
10056 -> 10055;
10056 -> 10050;
10057 -> 10050;
10058 -> 10051;
10058 -> 10057;
10058 -> 10050;
10059 -> 10050;
10060 -> 10052;
10060 -> 10038;
10060 -> 10059;
10061 -> 10060;
10061 -> 10038;
10061 -> 10043;
10061 -> 10059;
10062 -> 7030;
10062 -> 10059;
10063 -> 10050;
10064 -> 10051;
10064 -> 10050;
10065 -> 10064;
10065 -> 8847;
10066 -> 8847;
10067 -> 10065;
10067 -> 10066;
10067 -> 8847;
10068 -> 8847;
10069 -> 8848;
10069 -> 10068;
10070 -> 10069;
10070 -> 10038;
10070 -> 10068;
10071 -> 10070;
10071 -> 8847;
10072 -> 8847;
10073 -> 10071;
10073 -> 10072;
10074 -> 0;
10074 -> 10072;
10075 -> 10073;
10076 -> 10073;
10077 -> 10073;
10078 -> 10073;
10078 -> 10077;
10079 -> 10077;
10079 -> 10073;
10080 -> 10073;
10080 -> 10038;
10080 -> 10043;
10080 -> 10061;
10081 -> 10080;
10082 -> 10076;
10082 -> 10080;
10083 -> 10080;
10084 -> 10080;
10084 -> 10083;
10085 -> 10083;
10085 -> 10080;
10086 -> 10080;
10087 -> 10080;
10088 -> 10080;
10089 -> 10080;
10090 -> 10080;
10091 -> 10090;
10091 -> 10080;
10092 -> 10090;
10092 -> 10080;
10093 -> 10092;
10094 -> 10093;
10094 -> 10080;
10095 -> 10080;
10096 -> 10095;
10096 -> 10080;
10097 -> 10080;
10098 -> 10080;
10099 -> 10097;
10099 -> 10080;
10100 -> 10080;
10101 -> 10080;
10101 -> 10100;
10102 -> 0;
10102 -> 10100;
10103 -> 10102;
10103 -> 10080;
10104 -> 10103;
10104 -> 10080;
10105 -> 10080;
10106 -> 10104;
10106 -> 10105;
10107 -> 10099;
10107 -> 10105;
10108 -> 10106;
10108 -> 0;
10108 -> 10105;
10109 -> 10106;
10109 -> 10108;
10110 -> 10080;
10111 -> 10080;
10111 -> 10110;
10112 -> 10111;
10112 -> 10080;
10112 -> 10110;
10113 -> 10112;
10113 -> 10080;
10114 -> 10080;
10115 -> 10113;
10115 -> 10080;
10116 -> 10113;
10116 -> 10115;
10117 -> 10116;
10117 -> 10080;
10118 -> 10113;
10118 -> 10080;
10119 -> 10103;
10119 -> 10109;
10119 -> 10080;
10120 -> 10119;
10120 -> 10117;
10120 -> 10080;
10121 -> 10080;
10122 -> 10080;
10122 -> 10121;
10123 -> 10121;
10124 -> 10123;
10124 -> 10121;
10125 -> 10121;
10126 -> 10124;
10126 -> 10125;
10127 -> 10122;
10127 -> 10125;
10128 -> 10125;
10129 -> 10127;
10129 -> 10128;
10130 -> 10128;
10131 -> 10130;
10131 -> 10125;
10132 -> 10125;
10133 -> 10127;
10133 -> 10132;
10134 -> 10133;
10134 -> 10080;
10134 -> 10132;
10135 -> 10134;
10135 -> 10125;
10136 -> 10125;
10137 -> 10135;
10137 -> 10136;
10138 -> 10136;
10138 -> 10125;
10139 -> 10131;
10139 -> 10138;
10139 -> 10125;
10140 -> 10125;
10141 -> 10127;
10141 -> 10140;
10142 -> 10141;
10142 -> 10140;
10143 -> 10142;
10143 -> 10080;
10143 -> 10140;
10144 -> 10143;
10144 -> 10125;
10145 -> 10125;
10146 -> 10144;
10146 -> 10145;
10147 -> 10125;
10148 -> 10146;
10148 -> 10147;
10149 -> 10147;
10149 -> 10125;
10150 -> 10125;
10151 -> 10139;
10151 -> 10149;
10151 -> 10125;
10152 -> 10125;
10153 -> 10127;
10153 -> 10152;
10154 -> 10153;
10154 -> 10125;
10155 -> 10154;
10155 -> 3303;
10155 -> 10125;
10156 -> 10151;
10156 -> 10155;
10156 -> 10125;
10157 -> 10125;
10158 -> 10125;
10159 -> 10158;
10159 -> 10080;
10160 -> 10080;
10161 -> 10080;
10161 -> 0;
10162 -> 10080;
10163 -> 10080;
10163 -> 10162;
10164 -> 10162;
10165 -> 10163;
10165 -> 10164;
10166 -> 10164;
10167 -> 10165;
10167 -> 10166;
10168 -> 10167;
10168 -> 10164;
10169 -> 10164;
10170 -> 10168;
10170 -> 10169;
10171 -> 10080;
10172 -> 10171;
10172 -> 10080;
10173 -> 10080;
10173 -> 10172;
10174 -> 10172;
10175 -> 10173;
10175 -> 10174;
10176 -> 10174;
10177 -> 10175;
10177 -> 10176;
10178 -> 10177;
10178 -> 10174;
10179 -> 10174;
10180 -> 10178;
10180 -> 10179;
10181 -> 10080;
10181 -> 0;
10182 -> 10080;
10183 -> 10180;
10183 -> 10182;
10183 -> 10080;
10184 -> 10080;
10185 -> 10080;
10186 -> 10080;
10187 -> 10080;
10187 -> 10186;
10188 -> 10187;
10188 -> 10080;
10188 -> 10186;
10189 -> 10188;
10189 -> 10186;
10190 -> 10189;
10190 -> 10080;
10191 -> 10185;
10191 -> 10080;
10192 -> 10080;
10193 -> 10185;
10193 -> 10192;
10194 -> 10192;
10195 -> 10193;
10195 -> 10194;
10196 -> 10194;
10196 -> 10192;
10197 -> 10193;
10197 -> 10080;
10198 -> 10080;
10199 -> 10185;
10199 -> 10080;
10200 -> 10080;
10201 -> 10199;
10201 -> 10200;
10202 -> 10198;
10202 -> 10200;
10203 -> 10201;
10203 -> 10200;
10204 -> 10200;
10205 -> 10201;
10205 -> 10204;
10206 -> 10204;
10206 -> 10200;
10207 -> 10200;
10208 -> 10200;
10209 -> 10201;
10209 -> 10208;
10210 -> 0;
10210 -> 10208;
10211 -> 10209;
10211 -> 10200;
10212 -> 10200;
10213 -> 10201;
10213 -> 10212;
10214 -> 10213;
10214 -> 10080;
10214 -> 10212;
10215 -> 10214;
10215 -> 10200;
10216 -> 10215;
10216 -> 10200;
10217 -> 10200;
10218 -> 10217;
10218 -> 10080;
10219 -> 10080;
10220 -> 10080;
10221 -> 10080;
10222 -> 10073;
10223 -> 10080;
10223 -> 10222;
10223 -> 10073;
10224 -> 10073;
10225 -> 10073;
10226 -> 10073;
10227 -> 10080;
10227 -> 10226;
10228 -> 10226;
10229 -> 10228;
10229 -> 10073;
10230 -> 10073;
10231 -> 10080;
10231 -> 10230;
10231 -> 10073;
10232 -> 10080;
10233 -> 10080;
10234 -> 10192;
10235 -> 10233;
10235 -> 10192;
10236 -> 10192;
10236 -> 10194;
10237 -> 10192;
10238 -> 10192;
10239 -> 10192;
10240 -> 10192;
10241 -> 10192;
10242 -> 10241;
10242 -> 10192;
10243 -> 10241;
10243 -> 10192;
10244 -> 10243;
10245 -> 10244;
10245 -> 10192;
10246 -> 10192;
10247 -> 10246;
10247 -> 10192;
10248 -> 10192;
10249 -> 10192;
10250 -> 10248;
10250 -> 10192;
10251 -> 10192;
10252 -> 10192;
10252 -> 10251;
10253 -> 0;
10253 -> 10251;
10254 -> 10253;
10254 -> 10192;
10255 -> 10254;
10255 -> 10192;
10256 -> 10192;
10257 -> 10255;
10257 -> 10256;
10258 -> 10250;
10258 -> 10256;
10259 -> 10257;
10259 -> 0;
10259 -> 10256;
10260 -> 10257;
10260 -> 10259;
10261 -> 10192;
10262 -> 10192;
10262 -> 10261;
10263 -> 10262;
10263 -> 10192;
10263 -> 10261;
10264 -> 10263;
10264 -> 10192;
10265 -> 10192;
10266 -> 10264;
10266 -> 10192;
10267 -> 10264;
10267 -> 10266;
10268 -> 10267;
10268 -> 10192;
10269 -> 10264;
10269 -> 10192;
10270 -> 10254;
10270 -> 10260;
10270 -> 10192;
10271 -> 10270;
10271 -> 10268;
10271 -> 10192;
10272 -> 10192;
10273 -> 10192;
10273 -> 10272;
10274 -> 10272;
10275 -> 10274;
10275 -> 10272;
10276 -> 10272;
10277 -> 10275;
10277 -> 10276;
10278 -> 10273;
10278 -> 10276;
10279 -> 10276;
10280 -> 10278;
10280 -> 10279;
10281 -> 10279;
10282 -> 10281;
10282 -> 10276;
10283 -> 10276;
10284 -> 10278;
10284 -> 10283;
10285 -> 10284;
10285 -> 10192;
10285 -> 10283;
10286 -> 10285;
10286 -> 10276;
10287 -> 10276;
10288 -> 10286;
10288 -> 10287;
10289 -> 10287;
10289 -> 10276;
10290 -> 10282;
10290 -> 10289;
10290 -> 10276;
10291 -> 10276;
10292 -> 10278;
10292 -> 10291;
10293 -> 10292;
10293 -> 10291;
10294 -> 10293;
10294 -> 10192;
10294 -> 10291;
10295 -> 10294;
10295 -> 10276;
10296 -> 10276;
10297 -> 10295;
10297 -> 10296;
10298 -> 10276;
10299 -> 10297;
10299 -> 10298;
10300 -> 10298;
10300 -> 10276;
10301 -> 10276;
10302 -> 10290;
10302 -> 10300;
10302 -> 10276;
10303 -> 10276;
10304 -> 10278;
10304 -> 10303;
10305 -> 10304;
10305 -> 10276;
10306 -> 10305;
10306 -> 3303;
10306 -> 10276;
10307 -> 10302;
10307 -> 10306;
10307 -> 10276;
10308 -> 10276;
10309 -> 10276;
10310 -> 10309;
10310 -> 10192;
10311 -> 10192;
10312 -> 10192;
10312 -> 0;
10313 -> 10192;
10314 -> 10192;
10314 -> 10313;
10315 -> 10313;
10316 -> 10314;
10316 -> 10315;
10317 -> 10315;
10318 -> 10316;
10318 -> 10317;
10319 -> 10318;
10319 -> 10315;
10320 -> 10315;
10321 -> 10319;
10321 -> 10320;
10322 -> 10192;
10323 -> 10322;
10323 -> 10192;
10324 -> 10192;
10324 -> 10323;
10325 -> 10323;
10326 -> 10324;
10326 -> 10325;
10327 -> 10325;
10328 -> 10326;
10328 -> 10327;
10329 -> 10328;
10329 -> 10325;
10330 -> 10325;
10331 -> 10329;
10331 -> 10330;
10332 -> 10192;
10332 -> 0;
10333 -> 10192;
10334 -> 10331;
10334 -> 10333;
10334 -> 10192;
10335 -> 10192;
10336 -> 10192;
10337 -> 10192;
10338 -> 10192;
10338 -> 10337;
10339 -> 10338;
10339 -> 10192;
10339 -> 10337;
10340 -> 10339;
10340 -> 10337;
10341 -> 10340;
10341 -> 10192;
10342 -> 10336;
10342 -> 10192;
10343 -> 10336;
10343 -> 10194;
10344 -> 10336;
10344 -> 10192;
10345 -> 10192;
10346 -> 10336;
10346 -> 10192;
10347 -> 10192;
10348 -> 10346;
10348 -> 10347;
10349 -> 10345;
10349 -> 10347;
10350 -> 10348;
10350 -> 10347;
10351 -> 10347;
10352 -> 10348;
10352 -> 10351;
10353 -> 10351;
10353 -> 10347;
10354 -> 10347;
10355 -> 10347;
10356 -> 10348;
10356 -> 10355;
10357 -> 0;
10357 -> 10355;
10358 -> 10356;
10358 -> 10347;
10359 -> 10347;
10360 -> 10348;
10360 -> 10359;
10361 -> 10360;
10361 -> 10192;
10361 -> 10359;
10362 -> 10361;
10362 -> 10347;
10363 -> 10362;
10363 -> 10347;
10364 -> 10347;
10365 -> 10364;
10365 -> 10192;
10366 -> 10192;
10367 -> 10192;
10368 -> 10336;
10369 -> 10336;
10370 -> 10369;
10370 -> 10336;
10371 -> 10370;
10371 -> 10336;
10372 -> 10370;
10372 -> 10336;
10373 -> 10372;
10373 -> 10336;
10374 -> 10373;
10374 -> 10336;
10375 -> 10373;
10375 -> 10336;
10376 -> 10336;
10376 -> 10192;
10377 -> 10229;
10377 -> 10080;
10378 -> 10080;
10379 -> 10336;
10379 -> 10378;
10379 -> 10080;
10380 -> 10336;
10381 -> 10336;
10382 -> 10377;
10382 -> 10336;
10383 -> 10336;
10384 -> 10383;
10385 -> 10336;
10386 -> 10377;
10386 -> 10385;
10386 -> 10336;
10387 -> 10080;
10388 -> 10229;
10388 -> 10387;
10388 -> 10080;
10389 -> 10336;
10389 -> 10073;
10390 -> 10073;
10391 -> 10336;
10392 -> 10336;
10393 -> 10391;
10393 -> 10392;
10394 -> 10392;
10395 -> 10393;
10395 -> 10394;
10395 -> 10392;
10396 -> 10393;
10396 -> 10392;
10397 -> 10392;
10397 -> 10336;
10398 -> 10336;
10399 -> 10336;
10400 -> 10336;
10401 -> 10336;
10402 -> 10336;
10402 -> 10401;
10403 -> 10401;
10404 -> 10403;
10404 -> 10336;
10405 -> 10404;
10405 -> 10385;
10405 -> 10336;
10406 -> 10336;
10407 -> 10336;
10408 -> 10073;
10409 -> 10073;
10410 -> 10409;
10410 -> 10336;
10411 -> 10409;
10412 -> 10410;
10412 -> 10411;
10413 -> 10411;
10413 -> 10409;
10414 -> 10410;
10414 -> 10073;
10415 -> 10073;
10416 -> 10414;
10416 -> 10415;
10417 -> 10415;
10418 -> 10416;
10418 -> 10417;
10419 -> 10417;
10420 -> 10418;
10420 -> 10419;
10421 -> 10419;
10422 -> 10420;
10422 -> 10336;
10422 -> 10421;
10422 -> 10419;
10423 -> 10417;
10424 -> 10418;
10424 -> 10415;
10425 -> 10415;
10426 -> 10409;
10426 -> 10336;
10426 -> 10073;
10427 -> 10426;
10427 -> 10077;
10428 -> 10426;
10429 -> 10426;
10430 -> 10429;
10430 -> 10426;
10431 -> 10430;
10432 -> 10430;
10433 -> 10431;
10433 -> 10432;
10434 -> 10432;
10435 -> 10432;
10435 -> 10430;
10436 -> 10430;
10437 -> 10435;
10437 -> 10436;
10438 -> 10437;
10438 -> 10430;
10439 -> 10430;
10440 -> 10435;
10440 -> 10439;
10441 -> 10439;
10442 -> 10440;
10442 -> 10441;
10443 -> 10442;
10443 -> 10426;
10443 -> 10441;
10444 -> 10443;
10444 -> 10439;
10445 -> 10439;
10446 -> 10444;
10446 -> 10445;
10446 -> 10439;
10447 -> 10446;
10447 -> 10439;
10448 -> 10447;
10449 -> 10444;
10449 -> 10448;
10450 -> 10448;
10451 -> 10449;
10451 -> 10450;
10452 -> 10451;
10452 -> 10448;
10453 -> 10448;
10454 -> 10452;
10454 -> 10453;
10455 -> 10454;
10455 -> 10430;
10456 -> 10430;
10457 -> 10455;
10457 -> 10456;
10458 -> 10456;
10459 -> 10458;
10459 -> 10430;
10460 -> 10430;
10461 -> 10438;
10461 -> 10459;
10461 -> 10430;
10462 -> 10073;
10462 -> 10426;
10462 -> 10072;
10463 -> 10065;
10463 -> 8847;
10464 -> 10463;
10464 -> 10462;
10464 -> 8847;
10465 -> 10464;
10465 -> 8846;
10466 -> 8846;
10467 -> 10465;
10467 -> 10466;
10467 -> 8846;
10468 -> 8844;
10468 -> 5975;
10469 -> 5959;
10470 -> 10465;
10470 -> 10469;
10470 -> 5959;
10471 -> 10468;
10471 -> 5959;
10472 -> 0;
10472 -> 2816;
10473 -> 2816;
10474 -> 10472;
10474 -> 10473;
10475 -> 2800;
10475 -> 10473;
10476 -> 10474;
10476 -> 10473;
10477 -> 10473;
10478 -> 10475;
10478 -> 10477;
10479 -> 10478;
10479 -> 10426;
10479 -> 10477;
10480 -> 10479;
10480 -> 10473;
10481 -> 0;
10481 -> 10473;
10482 -> 10473;
10483 -> 10480;
10483 -> 10482;
10484 -> 10481;
10484 -> 10482;
10485 -> 10483;
10485 -> 10484;
10485 -> 10482;
10486 -> 10474;
10486 -> 0;
10486 -> 10473;
10487 -> 10473;
10488 -> 10475;
10488 -> 10426;
10488 -> 10487;
10488 -> 10473;
10489 -> 10475;
10489 -> 10426;
10489 -> 10073;
10489 -> 10486;
10489 -> 10473;
10490 -> 10489;
10491 -> 10489;
10492 -> 10489;
10493 -> 10492;
10493 -> 10489;
10494 -> 10485;
10494 -> 10489;
10495 -> 10489;
10496 -> 10489;
10497 -> 10491;
10497 -> 10489;
10498 -> 10491;
10498 -> 10489;
10499 -> 10494;
10499 -> 10489;
10500 -> 10489;
10501 -> 10489;
10502 -> 10501;
10502 -> 10489;
10503 -> 10495;
10503 -> 10489;
10504 -> 10496;
10504 -> 10489;
10505 -> 10497;
10505 -> 10489;
10506 -> 10498;
10506 -> 10489;
10507 -> 10499;
10507 -> 10489;
10508 -> 10489;
10509 -> 10489;
10510 -> 10489;
10511 -> 10489;
10512 -> 10489;
10513 -> 10489;
10514 -> 10489;
10515 -> 10489;
10516 -> 10489;
10517 -> 10489;
10518 -> 10516;
10518 -> 10489;
10519 -> 10489;
10520 -> 10517;
10520 -> 10489;
10521 -> 10518;
10521 -> 10489;
10522 -> 10519;
10522 -> 10489;
10523 -> 10520;
10523 -> 10489;
10524 -> 10521;
10524 -> 10489;
10525 -> 10523;
10525 -> 10489;
10526 -> 10522;
10526 -> 10489;
10527 -> 10524;
10527 -> 10489;
10528 -> 10525;
10528 -> 10489;
10529 -> 10526;
10529 -> 10489;
10530 -> 10489;
10531 -> 10527;
10531 -> 10489;
10532 -> 10489;
10533 -> 10489;
10534 -> 10489;
10535 -> 10528;
10535 -> 10489;
10536 -> 10489;
10537 -> 10529;
10537 -> 10489;
10538 -> 10489;
10539 -> 10531;
10539 -> 10530;
10540 -> 10532;
10540 -> 10530;
10541 -> 10489;
10541 -> 10530;
10542 -> 10489;
10542 -> 10530;
10543 -> 10533;
10543 -> 10530;
10544 -> 10534;
10544 -> 10530;
10545 -> 10535;
10545 -> 10530;
10546 -> 10536;
10546 -> 10530;
10547 -> 10537;
10547 -> 10530;
10548 -> 10538;
10548 -> 10530;
10549 -> 10530;
10550 -> 10541;
10550 -> 10530;
10551 -> 10542;
10551 -> 10530;
10552 -> 10543;
10552 -> 10530;
10553 -> 10548;
10553 -> 10530;
10554 -> 10550;
10554 -> 10549;
10555 -> 10551;
10555 -> 10549;
10556 -> 10552;
10556 -> 10549;
10557 -> 10553;
10557 -> 10549;
10558 -> 10549;
10559 -> 10557;
10559 -> 10549;
10560 -> 10559;
10560 -> 10558;
10561 -> 10558;
10562 -> 10558;
10562 -> 10549;
10563 -> 10558;
10563 -> 10549;
10564 -> 10558;
10564 -> 10549;
10565 -> 10549;
10566 -> 10554;
10566 -> 10565;
10566 -> 10549;
10567 -> 10554;
10567 -> 10558;
10567 -> 10549;
10568 -> 10555;
10568 -> 10558;
10568 -> 10549;
10569 -> 10549;
10570 -> 10555;
10570 -> 10569;
10570 -> 10549;
10571 -> 10556;
10571 -> 10570;
10571 -> 10549;
10572 -> 10571;
10572 -> 10558;
10572 -> 10549;
10573 -> 10549;
10573 -> 10530;
10574 -> 10549;
10574 -> 10530;
10575 -> 10549;
10575 -> 10530;
10576 -> 10549;
10576 -> 10530;
10577 -> 10549;
10577 -> 10530;
10578 -> 10549;
10578 -> 10530;
10579 -> 10530;
10580 -> 10539;
10580 -> 10579;
10580 -> 10530;
10581 -> 10530;
10582 -> 10540;
10582 -> 10581;
10582 -> 10530;
10583 -> 10530;
10584 -> 10547;
10584 -> 10583;
10584 -> 10530;
10585 -> 10540;
10585 -> 10549;
10585 -> 10530;
10586 -> 10539;
10586 -> 10549;
10586 -> 10530;
10587 -> 10544;
10587 -> 10549;
10587 -> 10530;
10588 -> 10545;
10588 -> 10549;
10588 -> 10530;
10589 -> 10546;
10589 -> 10549;
10589 -> 10530;
10590 -> 10547;
10590 -> 10549;
10590 -> 10530;
10591 -> 10489;
10592 -> 10489;
10593 -> 10592;
10594 -> 10593;
10594 -> 10489;
10595 -> 10593;
10595 -> 10489;
10596 -> 10489;
10597 -> 10489;
10598 -> 10489;
10599 -> 10597;
10599 -> 10598;
10600 -> 10598;
10601 -> 10599;
10601 -> 10600;
10602 -> 0;
10602 -> 10600;
10603 -> 10602;
10603 -> 10598;
10604 -> 10603;
10604 -> 10599;
10604 -> 10598;
10605 -> 10604;
10606 -> 10605;
10606 -> 10489;
10607 -> 10489;
10608 -> 10606;
10608 -> 10607;
10609 -> 10489;
10609 -> 10607;
10610 -> 10607;
10611 -> 10608;
10611 -> 10610;
10611 -> 10607;
10612 -> 10611;
10613 -> 10504;
10613 -> 10612;
10613 -> 10489;
10614 -> 10613;
10615 -> 10489;
10616 -> 10614;
10616 -> 10615;
10616 -> 10489;
10617 -> 10616;
10617 -> 10503;
10617 -> 10489;
10618 -> 10489;
10619 -> 10492;
10620 -> 10492;
10620 -> 10619;
10621 -> 10619;
10622 -> 10621;
10622 -> 10492;
10623 -> 10492;
10624 -> 10492;
10625 -> 10492;
10626 -> 10492;
10627 -> 10492;
10628 -> 10492;
10629 -> 10492;
10630 -> 10492;
10631 -> 10492;
10632 -> 10492;
10632 -> 10631;
10633 -> 10631;
10633 -> 10492;
10634 -> 10492;
10635 -> 10634;
10635 -> 10492;
10636 -> 10492;
10637 -> 10636;
10637 -> 10492;
10638 -> 10492;
10639 -> 10492;
10640 -> 10638;
10640 -> 10492;
10641 -> 10640;
10642 -> 10640;
10643 -> 10492;
10644 -> 10492;
10645 -> 10492;
10646 -> 0;
10646 -> 10492;
10647 -> 10492;
10648 -> 10647;
10648 -> 10492;
10649 -> 10492;
10650 -> 10648;
10650 -> 10649;
10650 -> 10492;
10651 -> 10492;
10651 -> 0;
10652 -> 10648;
10652 -> 10492;
10653 -> 10652;
10653 -> 10492;
10654 -> 10652;
10654 -> 10492;
10655 -> 10492;
10656 -> 10655;
10656 -> 10492;
10657 -> 10492;
10658 -> 10492;
10658 -> 10657;
10659 -> 10657;
10660 -> 10492;
10661 -> 10492;
10662 -> 10492;
10663 -> 10492;
10664 -> 10492;
10665 -> 10492;
10666 -> 10492;
10667 -> 10492;
10667 -> 10666;
10668 -> 10666;
10669 -> 10667;
10669 -> 10668;
10670 -> 10669;
10670 -> 10492;
10670 -> 10668;
10671 -> 10670;
10671 -> 10666;
10672 -> 10666;
10673 -> 10671;
10673 -> 10672;
10673 -> 10666;
10674 -> 10673;
10674 -> 10666;
10675 -> 10674;
10676 -> 10671;
10676 -> 10675;
10677 -> 10675;
10678 -> 10676;
10678 -> 10677;
10679 -> 10678;
10679 -> 10675;
10680 -> 10675;
10681 -> 10679;
10681 -> 10680;
10682 -> 10681;
10682 -> 10492;
10683 -> 10492;
10684 -> 10492;
10685 -> 10492;
10686 -> 10492;
10687 -> 0;
10687 -> 10492;
10688 -> 10492;
10689 -> 10686;
10689 -> 10688;
10690 -> 10686;
10690 -> 10688;
10691 -> 10687;
10691 -> 10688;
10692 -> 10689;
10692 -> 10688;
10693 -> 10690;
10693 -> 10688;
10694 -> 10691;
10694 -> 10688;
10695 -> 10688;
10696 -> 10693;
10696 -> 10695;
10697 -> 10694;
10697 -> 10695;
10698 -> 10689;
10698 -> 10695;
10699 -> 10697;
10699 -> 10696;
10700 -> 10699;
10700 -> 10696;
10701 -> 10698;
10701 -> 10696;
10702 -> 10492;
10703 -> 10492;
10704 -> 10702;
10704 -> 10703;
10705 -> 10703;
10706 -> 10704;
10706 -> 10705;
10707 -> 10705;
10707 -> 10703;
10708 -> 10707;
10708 -> 10492;
10709 -> 10492;
10710 -> 10623;
10710 -> 10709;
10710 -> 10492;
10711 -> 10489;
10711 -> 10492;
10712 -> 10492;
10713 -> 10492;
10714 -> 10492;
10715 -> 10492;
10715 -> 10714;
10716 -> 10714;
10716 -> 10492;
10717 -> 10492;
10718 -> 10713;
10718 -> 10492;
10719 -> 10492;
10719 -> 10718;
10720 -> 10492;
10721 -> 10492;
10721 -> 10720;
10722 -> 10721;
10722 -> 10492;
10722 -> 10720;
10723 -> 10722;
10723 -> 10492;
10724 -> 10492;
10725 -> 10492;
10726 -> 0;
10726 -> 10725;
10727 -> 10725;
10727 -> 10492;
10728 -> 10504;
10728 -> 10727;
10728 -> 10492;
10729 -> 10492;
10730 -> 10492;
10731 -> 10492;
10732 -> 10492;
10733 -> 10492;
10733 -> 10732;
10734 -> 10733;
10734 -> 10492;
10734 -> 10732;
10735 -> 10734;
10735 -> 10492;
10736 -> 10492;
10737 -> 10492;
10738 -> 10492;
10739 -> 10737;
10739 -> 10738;
10739 -> 10492;
10740 -> 10492;
10740 -> 3647;
10741 -> 10492;
10742 -> 10741;
10742 -> 10492;
10743 -> 10492;
10744 -> 10614;
10744 -> 10492;
10745 -> 0;
10745 -> 10492;
10746 -> 10492;
10747 -> 10743;
10747 -> 10746;
10748 -> 10744;
10748 -> 10746;
10749 -> 10745;
10749 -> 10746;
10750 -> 10747;
10750 -> 10746;
10751 -> 10748;
10751 -> 10746;
10752 -> 10749;
10752 -> 10746;
10753 -> 10746;
10754 -> 10751;
10754 -> 10753;
10755 -> 10752;
10755 -> 10753;
10756 -> 10747;
10756 -> 10753;
10757 -> 10755;
10757 -> 10754;
10758 -> 10757;
10758 -> 10754;
10759 -> 10756;
10759 -> 10754;
10760 -> 10754;
10761 -> 10760;
10762 -> 10492;
10763 -> 10614;
10763 -> 10762;
10763 -> 10492;
10764 -> 10492;
10765 -> 10492;
10765 -> 10764;
10766 -> 10764;
10767 -> 10765;
10767 -> 10492;
10767 -> 10766;
10768 -> 10767;
10768 -> 10764;
10769 -> 10768;
10769 -> 10492;
10770 -> 10492;
10771 -> 10769;
10771 -> 10492;
10772 -> 10492;
10773 -> 10770;
10773 -> 10492;
10774 -> 10771;
10774 -> 10492;
10775 -> 10772;
10775 -> 10492;
10776 -> 10773;
10776 -> 10492;
10777 -> 10774;
10777 -> 10492;
10778 -> 10776;
10778 -> 10492;
10779 -> 10775;
10779 -> 10492;
10780 -> 10777;
10780 -> 10492;
10781 -> 10778;
10781 -> 10492;
10782 -> 10779;
10782 -> 10492;
10783 -> 10492;
10784 -> 10780;
10784 -> 10492;
10785 -> 10492;
10786 -> 10492;
10787 -> 10492;
10788 -> 10781;
10788 -> 10492;
10789 -> 10492;
10790 -> 10782;
10790 -> 10492;
10791 -> 10492;
10792 -> 10784;
10792 -> 10783;
10793 -> 10785;
10793 -> 10783;
10794 -> 10492;
10794 -> 10783;
10795 -> 10492;
10795 -> 10783;
10796 -> 10786;
10796 -> 10783;
10797 -> 10787;
10797 -> 10783;
10798 -> 10788;
10798 -> 10783;
10799 -> 10789;
10799 -> 10783;
10800 -> 10790;
10800 -> 10783;
10801 -> 10791;
10801 -> 10783;
10802 -> 10783;
10803 -> 10794;
10803 -> 10783;
10804 -> 10795;
10804 -> 10783;
10805 -> 10796;
10805 -> 10783;
10806 -> 10801;
10806 -> 10783;
10807 -> 10803;
10807 -> 10802;
10808 -> 10804;
10808 -> 10802;
10809 -> 10805;
10809 -> 10802;
10810 -> 10806;
10810 -> 10802;
10811 -> 10802;
10812 -> 10810;
10812 -> 10802;
10813 -> 10812;
10813 -> 10811;
10814 -> 10811;
10815 -> 10811;
10815 -> 10802;
10816 -> 10811;
10816 -> 10802;
10817 -> 10811;
10817 -> 10802;
10818 -> 10802;
10819 -> 10807;
10819 -> 10818;
10819 -> 10802;
10820 -> 10807;
10820 -> 10811;
10820 -> 10802;
10821 -> 10808;
10821 -> 10811;
10821 -> 10802;
10822 -> 10802;
10823 -> 10808;
10823 -> 10822;
10823 -> 10802;
10824 -> 10809;
10824 -> 10823;
10824 -> 10802;
10825 -> 10824;
10825 -> 10811;
10825 -> 10802;
10826 -> 10802;
10826 -> 10783;
10827 -> 10802;
10827 -> 10783;
10828 -> 10802;
10828 -> 10783;
10829 -> 10802;
10829 -> 10783;
10830 -> 10802;
10830 -> 10783;
10831 -> 10802;
10831 -> 10783;
10832 -> 10783;
10833 -> 10792;
10833 -> 10832;
10833 -> 10783;
10834 -> 10783;
10835 -> 10793;
10835 -> 10834;
10835 -> 10783;
10836 -> 10783;
10837 -> 10800;
10837 -> 10836;
10837 -> 10783;
10838 -> 10793;
10838 -> 10802;
10838 -> 10783;
10839 -> 10792;
10839 -> 10802;
10839 -> 10783;
10840 -> 10797;
10840 -> 10802;
10840 -> 10783;
10841 -> 10798;
10841 -> 10802;
10841 -> 10783;
10842 -> 10799;
10842 -> 10802;
10842 -> 10783;
10843 -> 10800;
10843 -> 10802;
10843 -> 10783;
10844 -> 10665;
10845 -> 10844;
10845 -> 10492;
10846 -> 10844;
10846 -> 10492;
10847 -> 10704;
10847 -> 10705;
10848 -> 0;
10848 -> 10705;
10849 -> 10848;
10849 -> 10703;
10850 -> 10849;
10850 -> 10704;
10850 -> 10703;
10851 -> 10850;
10852 -> 10851;
10852 -> 10712;
10852 -> 10492;
10853 -> 10852;
10854 -> 10504;
10854 -> 10853;
10854 -> 10492;
10855 -> 10854;
10856 -> 10855;
10856 -> 10729;
10856 -> 10492;
10857 -> 10514;
10857 -> 10492;
10858 -> 10492;
10859 -> 10858;
10859 -> 10492;
10860 -> 10859;
10860 -> 10492;
10861 -> 10860;
10861 -> 10492;
10862 -> 10861;
10862 -> 10492;
10863 -> 10862;
10863 -> 10492;
10864 -> 10863;
10864 -> 10783;
10865 -> 10864;
10865 -> 10832;
10865 -> 10783;
10866 -> 10864;
10866 -> 10802;
10866 -> 10783;
10867 -> 10492;
10867 -> 10489;
10868 -> 10489;
10869 -> 10867;
10869 -> 10868;
10869 -> 10489;
10870 -> 10867;
10870 -> 10489;
10871 -> 10492;
10871 -> 10489;
10872 -> 2816;
10873 -> 10492;
10873 -> 10872;
10873 -> 2816;
10874 -> 10492;
10874 -> 2816;
10875 -> 2800;
10875 -> 10874;
10876 -> 0;
10876 -> 10874;
10877 -> 2801;
10877 -> 10874;
10878 -> 10874;
10879 -> 10874;
10880 -> 10875;
10880 -> 10879;
10881 -> 10876;
10881 -> 10879;
10882 -> 10877;
10882 -> 10879;
10883 -> 10876;
10883 -> 10879;
10884 -> 10878;
10884 -> 10879;
10885 -> 10879;
10886 -> 10883;
10886 -> 10885;
10886 -> 10879;
10887 -> 10884;
10887 -> 10885;
10887 -> 10879;
10888 -> 10886;
10888 -> 10887;
10888 -> 10879;
10889 -> 10881;
10889 -> 10879;
10890 -> 10882;
10890 -> 10879;
10891 -> 10883;
10891 -> 10879;
10892 -> 10884;
10892 -> 10879;
10893 -> 10889;
10893 -> 10879;
10894 -> 10879;
10895 -> 10892;
10895 -> 10894;
10895 -> 10879;
10896 -> 10891;
10896 -> 10894;
10896 -> 10879;
10897 -> 10895;
10897 -> 10896;
10897 -> 10879;
10898 -> 10879;
10899 -> 10898;
10899 -> 10879;
10900 -> 10893;
10900 -> 10879;
10901 -> 10879;
10902 -> 10881;
10902 -> 10901;
10902 -> 10879;
10903 -> 10881;
10903 -> 0;
10903 -> 10879;
10904 -> 10881;
10905 -> 10881;
10906 -> 10905;
10906 -> 10881;
10907 -> 0;
10907 -> 10881;
10908 -> 10881;
10909 -> 10906;
10909 -> 10908;
10910 -> 10907;
10910 -> 10908;
10911 -> 10909;
10911 -> 10910;
10911 -> 10908;
10912 -> 10880;
10913 -> 10880;
10914 -> 10880;
10915 -> 10913;
10915 -> 10914;
10915 -> 10880;
10916 -> 10913;
10916 -> 10880;
10917 -> 10880;
10918 -> 10880;
10919 -> 10880;
10920 -> 10880;
10921 -> 10880;
10921 -> 10920;
10922 -> 10920;
10922 -> 10880;
10923 -> 10880;
10924 -> 10923;
10924 -> 10880;
10925 -> 10880;
10926 -> 10880;
10927 -> 10926;
10928 -> 10927;
10929 -> 10927;
10929 -> 10928;
10930 -> 10928;
10930 -> 10927;
10931 -> 10927;
10931 -> 10926;
10932 -> 10880;
10932 -> 10926;
10933 -> 10926;
10934 -> 10932;
10934 -> 10933;
10935 -> 10931;
10935 -> 10933;
10936 -> 10926;
10937 -> 10880;
10938 -> 10880;
10939 -> 0;
10939 -> 10880;
10940 -> 0;
10940 -> 10880;
10941 -> 0;
10941 -> 10880;
10942 -> 0;
10942 -> 10880;
10943 -> 10880;
10944 -> 10943;
10944 -> 10880;
10945 -> 10944;
10945 -> 10880;
10946 -> 10880;
10947 -> 10880;
10948 -> 10880;
10949 -> 10880;
10950 -> 10949;
10950 -> 10880;
10951 -> 10946;
10951 -> 10880;
10952 -> 10951;
10952 -> 10880;
10953 -> 10949;
10954 -> 10949;
10955 -> 10949;
10956 -> 10949;
10957 -> 10949;
10958 -> 10949;
10958 -> 10880;
10959 -> 10949;
10959 -> 0;
10960 -> 10949;
10960 -> 0;
10961 -> 10880;
10961 -> 10949;
10962 -> 10949;
10963 -> 10949;
10964 -> 10880;
10965 -> 10964;
10965 -> 10949;
10966 -> 10965;
10966 -> 10880;
10967 -> 10949;
10967 -> 10920;
10968 -> 10949;
10969 -> 10880;
10969 -> 10949;
10970 -> 10949;
10971 -> 10949;
10972 -> 10949;
10973 -> 10949;
10974 -> 10949;
10975 -> 10949;
10976 -> 10949;
10977 -> 10976;
10977 -> 10949;
10978 -> 10977;
10979 -> 10977;
10979 -> 10978;
10980 -> 10978;
10981 -> 10979;
10981 -> 10980;
10982 -> 10980;
10983 -> 10981;
10983 -> 10949;
10983 -> 10982;
10983 -> 10980;
10984 -> 10978;
10985 -> 10979;
10985 -> 10949;
10985 -> 10978;
10986 -> 10985;
10986 -> 10977;
10987 -> 10977;
10988 -> 10949;
10989 -> 10949;
10990 -> 10949;
10991 -> 10949;
10992 -> 10949;
10993 -> 10949;
10994 -> 10949;
10995 -> 10949;
10996 -> 10949;
10997 -> 10996;
10997 -> 10995;
10997 -> 10949;
10998 -> 10997;
10998 -> 10996;
10999 -> 10996;
11000 -> 10997;
11000 -> 10999;
11001 -> 11000;
11001 -> 10996;
11002 -> 11001;
11003 -> 11001;
11003 -> 11002;
11004 -> 11002;
11005 -> 11003;
11005 -> 11004;
11006 -> 11004;
11007 -> 11005;
11007 -> 10997;
11007 -> 11006;
11007 -> 11004;
11008 -> 11002;
11009 -> 11003;
11009 -> 10997;
11009 -> 11002;
11010 -> 11009;
11010 -> 11001;
11011 -> 11001;
11012 -> 10996;
11013 -> 10997;
11013 -> 11012;
11013 -> 10996;
11014 -> 10997;
11014 -> 10996;
11015 -> 10949;
11016 -> 11015;
11016 -> 10997;
11017 -> 10997;
11018 -> 10997;
11018 -> 11017;
11019 -> 10997;
11019 -> 11017;
11020 -> 10997;
11020 -> 11017;
11021 -> 10997;
11021 -> 11017;
11022 -> 11016;
11022 -> 11017;
11023 -> 11017;
11024 -> 10949;
11025 -> 10997;
11025 -> 11024;
11025 -> 10949;
11026 -> 10994;
11026 -> 11024;
11026 -> 10949;
11027 -> 11025;
11027 -> 11026;
11027 -> 10949;
11028 -> 11027;
11028 -> 11023;
11028 -> 10949;
11029 -> 10997;
11029 -> 10949;
11030 -> 10997;
11030 -> 10949;
11031 -> 10949;
11032 -> 10997;
11032 -> 11031;
11032 -> 10949;
11033 -> 10949;
11034 -> 10997;
11034 -> 10949;
11035 -> 11033;
11035 -> 10949;
11036 -> 11033;
11036 -> 10949;
11037 -> 10949;
11038 -> 11034;
11038 -> 11037;
11039 -> 11038;
11039 -> 10949;
11040 -> 10949;
11041 -> 10997;
11041 -> 11033;
11042 -> 11041;
11042 -> 10949;
11043 -> 10949;
11043 -> 0;
11044 -> 10949;
11045 -> 11041;
11045 -> 11044;
11046 -> 11044;
11047 -> 11045;
11047 -> 11046;
11048 -> 11046;
11049 -> 11047;
11049 -> 11048;
11050 -> 11049;
11050 -> 11046;
11051 -> 11046;
11052 -> 11050;
11052 -> 11051;
11053 -> 11041;
11053 -> 10949;
11054 -> 11053;
11054 -> 10949;
11055 -> 11041;
11055 -> 11054;
11056 -> 11054;
11057 -> 11055;
11057 -> 11056;
11058 -> 11056;
11059 -> 11057;
11059 -> 11058;
11060 -> 11059;
11060 -> 11056;
11061 -> 11056;
11062 -> 11060;
11062 -> 11061;
11063 -> 10949;
11063 -> 0;
11064 -> 10949;
11065 -> 11062;
11065 -> 11064;
11065 -> 10949;
11066 -> 10949;
11067 -> 10997;
11067 -> 11066;
11067 -> 10949;
11068 -> 10949;
11069 -> 10949;
11069 -> 11068;
11070 -> 11069;
11070 -> 11041;
11070 -> 11068;
11071 -> 11070;
11071 -> 11068;
11072 -> 11071;
11072 -> 10949;
11073 -> 10949;
11074 -> 10949;
11075 -> 10997;
11075 -> 11074;
11076 -> 11074;
11076 -> 10949;
11077 -> 10997;
11077 -> 10949;
11078 -> 10949;
11079 -> 10949;
11080 -> 11078;
11080 -> 11079;
11081 -> 11078;
11081 -> 11079;
11082 -> 11080;
11082 -> 11079;
11083 -> 11079;
11084 -> 11080;
11084 -> 11083;
11085 -> 11083;
11085 -> 11079;
11086 -> 11079;
11087 -> 11079;
11088 -> 11080;
11088 -> 11087;
11089 -> 0;
11089 -> 11087;
11090 -> 11088;
11090 -> 10997;
11090 -> 0;
11090 -> 11087;
11091 -> 11090;
11091 -> 11079;
11092 -> 11079;
11093 -> 11080;
11093 -> 11092;
11094 -> 11093;
11094 -> 10997;
11094 -> 11092;
11095 -> 11094;
11095 -> 11079;
11096 -> 11095;
11096 -> 11079;
11097 -> 11079;
11098 -> 11097;
11098 -> 10949;
11099 -> 10997;
11100 -> 10997;
11101 -> 10997;
11102 -> 10997;
11102 -> 11101;
11103 -> 11101;
11103 -> 10997;
11104 -> 10997;
11105 -> 10997;
11106 -> 11105;
11106 -> 10997;
11107 -> 11106;
11107 -> 10997;
11108 -> 11106;
11108 -> 10997;
11109 -> 11108;
11109 -> 10997;
11110 -> 11109;
11110 -> 10997;
11111 -> 11109;
11111 -> 10997;
11112 -> 10997;
11112 -> 10949;
11113 -> 10997;
11113 -> 10949;
11114 -> 10997;
11114 -> 10949;
11115 -> 11114;
11115 -> 10949;
11116 -> 11114;
11116 -> 10997;
11116 -> 10949;
11117 -> 11116;
11118 -> 11117;
11118 -> 10949;
11119 -> 10949;
11120 -> 11119;
11120 -> 10949;
11121 -> 10949;
11122 -> 11041;
11122 -> 10949;
11123 -> 11121;
11123 -> 10949;
11124 -> 10949;
11125 -> 11041;
11125 -> 11124;
11126 -> 0;
11126 -> 11124;
11127 -> 11126;
11127 -> 10949;
11128 -> 11127;
11128 -> 10949;
11129 -> 10949;
11130 -> 11128;
11130 -> 11129;
11131 -> 11123;
11131 -> 11129;
11132 -> 11130;
11132 -> 0;
11132 -> 11129;
11133 -> 11130;
11133 -> 11132;
11134 -> 10949;
11135 -> 11041;
11135 -> 11134;
11136 -> 11135;
11136 -> 11041;
11136 -> 11134;
11137 -> 11136;
11137 -> 10949;
11138 -> 10949;
11139 -> 11137;
11139 -> 10949;
11140 -> 11137;
11140 -> 11139;
11141 -> 11140;
11141 -> 10949;
11142 -> 11137;
11142 -> 10949;
11143 -> 11127;
11143 -> 11133;
11143 -> 10949;
11144 -> 11143;
11144 -> 11141;
11144 -> 10949;
11145 -> 10949;
11146 -> 11041;
11146 -> 11145;
11147 -> 11145;
11148 -> 11147;
11148 -> 11145;
11149 -> 11145;
11150 -> 11148;
11150 -> 11149;
11151 -> 11146;
11151 -> 11149;
11152 -> 11149;
11153 -> 11151;
11153 -> 11152;
11154 -> 11152;
11155 -> 11154;
11155 -> 11149;
11156 -> 11149;
11157 -> 11151;
11157 -> 11156;
11158 -> 11157;
11158 -> 11041;
11158 -> 11156;
11159 -> 11158;
11159 -> 11149;
11160 -> 11149;
11161 -> 11159;
11161 -> 11160;
11162 -> 11160;
11162 -> 11149;
11163 -> 11155;
11163 -> 11162;
11163 -> 11149;
11164 -> 11149;
11165 -> 11151;
11165 -> 11164;
11166 -> 11165;
11166 -> 11164;
11167 -> 11166;
11167 -> 11041;
11167 -> 11164;
11168 -> 11167;
11168 -> 11149;
11169 -> 11149;
11170 -> 11168;
11170 -> 11169;
11171 -> 11149;
11172 -> 11170;
11172 -> 11171;
11173 -> 11171;
11173 -> 11149;
11174 -> 11149;
11175 -> 11163;
11175 -> 11173;
11175 -> 11149;
11176 -> 11149;
11177 -> 11151;
11177 -> 11176;
11178 -> 11177;
11178 -> 11149;
11179 -> 11178;
11179 -> 3303;
11179 -> 11149;
11180 -> 11175;
11180 -> 11179;
11180 -> 11149;
11181 -> 11149;
11182 -> 11149;
11183 -> 11182;
11183 -> 10949;
11184 -> 10949;
11185 -> 10949;
11186 -> 10949;
11187 -> 10997;
11187 -> 10949;
11188 -> 10949;
11189 -> 11185;
11189 -> 11188;
11189 -> 10949;
11190 -> 10949;
11191 -> 11187;
11191 -> 11190;
11191 -> 10949;
11192 -> 11186;
11192 -> 11190;
11192 -> 10949;
11193 -> 11191;
11193 -> 11192;
11193 -> 10949;
11194 -> 10949;
11195 -> 10949;
11196 -> 11187;
11196 -> 11195;
11196 -> 10949;
11197 -> 11041;
11197 -> 10949;
11198 -> 11197;
11198 -> 10949;
11199 -> 11041;
11199 -> 10949;
11200 -> 11198;
11200 -> 10949;
11201 -> 11200;
11201 -> 11041;
11202 -> 11194;
11202 -> 11197;
11202 -> 10949;
11203 -> 10949;
11204 -> 11187;
11204 -> 10949;
11205 -> 11203;
11205 -> 11204;
11205 -> 10949;
11205 -> 11197;
11206 -> 11205;
11206 -> 11203;
11207 -> 11205;
11207 -> 11203;
11208 -> 11205;
11208 -> 11203;
11209 -> 11203;
11210 -> 11207;
11210 -> 11209;
11211 -> 11209;
11212 -> 11210;
11212 -> 11211;
11213 -> 11212;
11213 -> 11209;
11214 -> 11213;
11215 -> 11214;
11215 -> 11213;
11216 -> 11215;
11216 -> 11203;
11217 -> 11205;
11217 -> 11203;
11218 -> 11205;
11218 -> 11203;
11219 -> 11217;
11219 -> 11203;
11220 -> 11219;
11220 -> 11205;
11221 -> 11205;
11221 -> 11217;
11221 -> 11216;
11221 -> 10949;
11222 -> 11196;
11222 -> 11221;
11222 -> 10949;
11223 -> 11194;
11223 -> 11196;
11223 -> 10949;
11224 -> 11223;
11225 -> 10949;
11225 -> 11221;
11225 -> 11224;
11225 -> 11223;
11226 -> 10949;
11226 -> 11221;
11226 -> 11225;
11226 -> 11223;
11227 -> 11187;
11227 -> 11221;
11227 -> 11225;
11227 -> 11223;
11228 -> 11226;
11228 -> 11221;
11228 -> 11223;
11229 -> 11227;
11229 -> 11221;
11229 -> 11223;
11230 -> 11228;
11230 -> 11229;
11230 -> 11223;
11231 -> 11223;
11232 -> 11185;
11232 -> 11231;
11233 -> 0;
11233 -> 11231;
11234 -> 11231;
11235 -> 11233;
11235 -> 11234;
11236 -> 11232;
11236 -> 11234;
11237 -> 11234;
11238 -> 11235;
11238 -> 11237;
11238 -> 11234;
11239 -> 11235;
11239 -> 11236;
11239 -> 11221;
11239 -> 11234;
11240 -> 11239;
11240 -> 11223;
11241 -> 11223;
11242 -> 11186;
11242 -> 11241;
11243 -> 0;
11243 -> 11241;
11244 -> 11241;
11245 -> 11243;
11245 -> 11244;
11246 -> 11242;
11246 -> 11244;
11247 -> 11244;
11248 -> 11245;
11248 -> 11247;
11248 -> 11244;
11249 -> 11245;
11249 -> 11246;
11249 -> 11221;
11249 -> 11244;
11250 -> 11249;
11250 -> 11223;
11251 -> 11240;
11251 -> 11250;
11251 -> 11223;
11252 -> 11223;
11253 -> 11185;
11253 -> 11252;
11254 -> 11252;
11255 -> 11253;
11255 -> 11254;
11256 -> 0;
11256 -> 11254;
11257 -> 11254;
11258 -> 11256;
11258 -> 11257;
11259 -> 11255;
11259 -> 11257;
11260 -> 11257;
11261 -> 11258;
11261 -> 11260;
11261 -> 11257;
11262 -> 11258;
11262 -> 11259;
11262 -> 11221;
11262 -> 11257;
11263 -> 11262;
11263 -> 11252;
11264 -> 11263;
11264 -> 11223;
11265 -> 11223;
11266 -> 11186;
11266 -> 11265;
11267 -> 11265;
11268 -> 11266;
11268 -> 11267;
11269 -> 0;
11269 -> 11267;
11270 -> 11267;
11271 -> 11269;
11271 -> 11270;
11272 -> 11268;
11272 -> 11270;
11273 -> 11270;
11274 -> 11271;
11274 -> 11273;
11274 -> 11270;
11275 -> 11271;
11275 -> 11272;
11275 -> 11221;
11275 -> 11270;
11276 -> 11275;
11276 -> 11265;
11277 -> 11276;
11277 -> 11223;
11278 -> 11264;
11278 -> 11277;
11278 -> 11223;
11279 -> 11251;
11279 -> 11278;
11279 -> 11223;
11280 -> 11223;
11281 -> 11185;
11281 -> 11280;
11282 -> 11280;
11283 -> 11281;
11283 -> 11221;
11283 -> 11282;
11284 -> 11280;
11285 -> 11284;
11286 -> 11281;
11286 -> 11284;
11287 -> 0;
11287 -> 11284;
11288 -> 11284;
11289 -> 11287;
11289 -> 11288;
11290 -> 11286;
11290 -> 11288;
11291 -> 11288;
11292 -> 11289;
11292 -> 11291;
11292 -> 11288;
11293 -> 11289;
11293 -> 11290;
11293 -> 11221;
11293 -> 11288;
11294 -> 11283;
11294 -> 11293;
11294 -> 11280;
11295 -> 11294;
11295 -> 11280;
11296 -> 11295;
11296 -> 11280;
11297 -> 11296;
11297 -> 11223;
11298 -> 11223;
11299 -> 11186;
11299 -> 11298;
11300 -> 11298;
11301 -> 11299;
11301 -> 11221;
11301 -> 11300;
11302 -> 11298;
11303 -> 11302;
11304 -> 11299;
11304 -> 11302;
11305 -> 0;
11305 -> 11302;
11306 -> 11302;
11307 -> 11305;
11307 -> 11306;
11308 -> 11304;
11308 -> 11306;
11309 -> 11306;
11310 -> 11307;
11310 -> 11309;
11310 -> 11306;
11311 -> 11307;
11311 -> 11308;
11311 -> 11221;
11311 -> 11306;
11312 -> 11301;
11312 -> 11311;
11312 -> 11298;
11313 -> 11312;
11313 -> 11298;
11314 -> 11313;
11314 -> 11298;
11315 -> 11314;
11315 -> 11223;
11316 -> 11297;
11316 -> 11315;
11316 -> 11223;
11317 -> 11279;
11317 -> 11316;
11317 -> 11223;
11318 -> 11223;
11319 -> 11185;
11319 -> 11318;
11320 -> 11318;
11321 -> 11318;
11321 -> 11319;
11321 -> 11221;
11322 -> 11321;
11322 -> 11223;
11323 -> 11223;
11324 -> 11186;
11324 -> 11323;
11325 -> 11323;
11326 -> 11323;
11326 -> 11324;
11326 -> 11221;
11327 -> 11326;
11327 -> 11223;
11328 -> 11322;
11328 -> 11327;
11328 -> 11223;
11329 -> 11317;
11329 -> 11328;
11329 -> 11223;
11330 -> 11017;
11330 -> 11221;
11330 -> 10949;
11331 -> 11330;
11331 -> 0;
11332 -> 11330;
11333 -> 11330;
11333 -> 11332;
11334 -> 11333;
11334 -> 10949;
11334 -> 11332;
11335 -> 11334;
11335 -> 11330;
11336 -> 11330;
11336 -> 11221;
11337 -> 0;
11337 -> 11330;
11338 -> 11330;
11339 -> 11335;
11339 -> 11338;
11340 -> 11336;
11340 -> 11338;
11341 -> 11337;
11341 -> 11338;
11342 -> 11339;
11342 -> 11338;
11343 -> 11340;
11343 -> 11338;
11344 -> 11341;
11344 -> 11338;
11345 -> 11338;
11346 -> 11343;
11346 -> 11345;
11347 -> 11344;
11347 -> 11345;
11348 -> 11339;
11348 -> 11345;
11349 -> 11347;
11349 -> 11346;
11350 -> 11349;
11350 -> 11346;
11351 -> 11348;
11351 -> 11346;
11352 -> 11330;
11353 -> 11352;
11353 -> 11330;
11354 -> 11330;
11355 -> 11330;
11355 -> 6994;
11356 -> 11330;
11357 -> 11330;
11358 -> 10949;
11358 -> 11357;
11359 -> 0;
11359 -> 11357;
11360 -> 11357;
11361 -> 11358;
11361 -> 11360;
11362 -> 11359;
11362 -> 11360;
11363 -> 11362;
11363 -> 0;
11363 -> 11360;
11364 -> 11360;
11365 -> 11361;
11365 -> 11364;
11366 -> 11365;
11366 -> 10949;
11366 -> 11364;
11367 -> 11366;
11367 -> 11360;
11368 -> 11360;
11368 -> 11221;
11369 -> 0;
11369 -> 11360;
11370 -> 11360;
11371 -> 11367;
11371 -> 11370;
11372 -> 11368;
11372 -> 11370;
11373 -> 11369;
11373 -> 11370;
11374 -> 11371;
11374 -> 11370;
11375 -> 11372;
11375 -> 11370;
11376 -> 11373;
11376 -> 11370;
11377 -> 11370;
11378 -> 11375;
11378 -> 11377;
11379 -> 11376;
11379 -> 11377;
11380 -> 11371;
11380 -> 11377;
11381 -> 11379;
11381 -> 11378;
11382 -> 11381;
11382 -> 11378;
11383 -> 11380;
11383 -> 11378;
11384 -> 11360;
11385 -> 11384;
11385 -> 11360;
11386 -> 11360;
11387 -> 11362;
11387 -> 6994;
11387 -> 11360;
11388 -> 11360;
11389 -> 11388;
11389 -> 11357;
11390 -> 11330;
11390 -> 10949;
11391 -> 10949;
11391 -> 0;
11392 -> 10949;
11393 -> 10949;
11393 -> 0;
11394 -> 10949;
11395 -> 10949;
11396 -> 11395;
11396 -> 10997;
11397 -> 11396;
11397 -> 10949;
11398 -> 10949;
11399 -> 10949;
11399 -> 11398;
11400 -> 0;
11400 -> 11398;
11401 -> 11400;
11401 -> 10949;
11402 -> 10949;
11403 -> 11401;
11403 -> 11402;
11404 -> 11403;
11404 -> 11402;
11405 -> 11402;
11406 -> 11397;
11406 -> 11404;
11406 -> 10949;
11407 -> 10949;
11408 -> 11407;
11408 -> 11406;
11408 -> 10949;
11409 -> 10952;
11409 -> 10880;
11410 -> 10880;
11411 -> 11409;
11411 -> 10880;
11412 -> 11410;
11412 -> 10880;
11413 -> 11410;
11413 -> 10880;
11414 -> 11361;
11414 -> 10920;
11415 -> 10943;
11415 -> 10880;
11416 -> 10943;
11416 -> 10880;
11417 -> 10880;
11417 -> 11361;
11418 -> 10880;
11419 -> 10880;
11420 -> 11419;
11420 -> 11361;
11420 -> 10880;
11421 -> 11420;
11422 -> 11420;
11423 -> 11418;
11423 -> 11422;
11424 -> 11421;
11424 -> 11422;
11425 -> 11424;
11425 -> 11422;
11426 -> 11423;
11426 -> 11425;
11427 -> 11418;
11427 -> 11421;
11427 -> 11420;
11428 -> 11420;
11428 -> 11427;
11429 -> 11428;
11429 -> 11422;
11430 -> 11429;
11430 -> 11425;
11431 -> 11420;
11431 -> 11428;
11432 -> 11428;
11433 -> 11428;
11433 -> 11432;
11434 -> 0;
11434 -> 11432;
11435 -> 11434;
11435 -> 11428;
11436 -> 11428;
11437 -> 11431;
11437 -> 11436;
11438 -> 0;
11438 -> 11436;
11439 -> 11438;
11439 -> 11428;
11440 -> 11435;
11440 -> 11439;
11440 -> 11428;
11441 -> 11431;
11441 -> 11428;
11442 -> 11441;
11442 -> 11422;
11443 -> 11442;
11443 -> 11425;
11444 -> 11441;
11445 -> 11441;
11445 -> 11444;
11446 -> 0;
11446 -> 11444;
11447 -> 11446;
11447 -> 11441;
11448 -> 11441;
11449 -> 11441;
11449 -> 11448;
11450 -> 0;
11450 -> 11448;
11451 -> 11450;
11451 -> 11441;
11452 -> 11447;
11452 -> 11451;
11452 -> 11441;
11453 -> 11441;
11453 -> 11448;
11454 -> 0;
11454 -> 11448;
11455 -> 11454;
11455 -> 11441;
11456 -> 11447;
11456 -> 11455;
11456 -> 11441;
11457 -> 10880;
11458 -> 10880;
11458 -> 11457;
11459 -> 11457;
11460 -> 11459;
11460 -> 11457;
11461 -> 11457;
11462 -> 11460;
11462 -> 11461;
11463 -> 11458;
11463 -> 11461;
11464 -> 11461;
11465 -> 11463;
11465 -> 11464;
11466 -> 11464;
11467 -> 11466;
11467 -> 11461;
11468 -> 11461;
11469 -> 11463;
11469 -> 11468;
11470 -> 11469;
11470 -> 11361;
11470 -> 11468;
11471 -> 11470;
11471 -> 11461;
11472 -> 11461;
11473 -> 11471;
11473 -> 11472;
11474 -> 11472;
11474 -> 11461;
11475 -> 11467;
11475 -> 11474;
11475 -> 11461;
11476 -> 11461;
11477 -> 11463;
11477 -> 11476;
11478 -> 11477;
11478 -> 11476;
11479 -> 11478;
11479 -> 11361;
11479 -> 11476;
11480 -> 11479;
11480 -> 11461;
11481 -> 11461;
11482 -> 11480;
11482 -> 11481;
11483 -> 11461;
11484 -> 11482;
11484 -> 11483;
11485 -> 11483;
11485 -> 11461;
11486 -> 11461;
11487 -> 11475;
11487 -> 11485;
11487 -> 11461;
11488 -> 11461;
11489 -> 11461;
11490 -> 11489;
11490 -> 10880;
11491 -> 11361;
11492 -> 11361;
11493 -> 11361;
11494 -> 11492;
11494 -> 11493;
11495 -> 11494;
11495 -> 11361;
11496 -> 11361;
11497 -> 10880;
11498 -> 10880;
11499 -> 10918;
11499 -> 10880;
11500 -> 10880;
11501 -> 0;
11501 -> 10880;
11502 -> 10881;
11502 -> 0;
11502 -> 10880;
11503 -> 10880;
11504 -> 10880;
11505 -> 0;
11505 -> 10881;
11506 -> 11502;
11506 -> 10881;
11507 -> 11361;
11508 -> 11507;
11508 -> 11361;
11509 -> 10881;
11509 -> 11361;
11510 -> 11361;
11511 -> 11361;
11511 -> 11510;
11512 -> 0;
11512 -> 11510;
11513 -> 11512;
11513 -> 11361;
11514 -> 11361;
11515 -> 11361;
11516 -> 11515;
11516 -> 11502;
11516 -> 11361;
11517 -> 11513;
11517 -> 11516;
11517 -> 11361;
11518 -> 11361;
11519 -> 11361;
11519 -> 11518;
11520 -> 11518;
11521 -> 11519;
11521 -> 11520;
11522 -> 11521;
11522 -> 11518;
11523 -> 0;
11523 -> 11522;
11524 -> 11523;
11524 -> 11361;
11525 -> 11517;
11525 -> 11524;
11525 -> 11361;
11526 -> 11361;
11527 -> 11361;
11527 -> 11526;
11528 -> 11526;
11528 -> 11361;
11529 -> 11361;
11530 -> 11361;
11531 -> 11361;
11532 -> 11531;
11532 -> 11361;
11533 -> 11532;
11534 -> 11532;
11534 -> 11533;
11535 -> 11533;
11536 -> 11534;
11536 -> 11535;
11537 -> 11535;
11538 -> 11536;
11538 -> 11361;
11538 -> 11537;
11538 -> 11535;
11539 -> 11533;
11540 -> 11534;
11540 -> 11361;
11540 -> 11533;
11541 -> 11540;
11541 -> 11532;
11542 -> 11532;
11543 -> 11361;
11544 -> 11361;
11545 -> 11361;
11546 -> 11545;
11546 -> 11361;
11547 -> 11361;
11548 -> 0;
11548 -> 11361;
11549 -> 11361;
11550 -> 11361;
11551 -> 11549;
11551 -> 11550;
11552 -> 11549;
11552 -> 11550;
11553 -> 11551;
11553 -> 11550;
11554 -> 11552;
11554 -> 11550;
11555 -> 11550;
11556 -> 11550;
11557 -> 11553;
11557 -> 11556;
11558 -> 11557;
11558 -> 11550;
11559 -> 11550;
11560 -> 11361;
11561 -> 11551;
11561 -> 11560;
11561 -> 11361;
11562 -> 11361;
11563 -> 11361;
11563 -> 11562;
11564 -> 11361;
11564 -> 11562;
11565 -> 0;
11565 -> 11562;
11566 -> 11562;
11567 -> 11565;
11567 -> 11566;
11568 -> 11564;
11568 -> 11566;
11569 -> 11566;
11570 -> 11567;
11570 -> 11569;
11570 -> 11566;
11571 -> 11567;
11571 -> 11568;
11571 -> 11361;
11571 -> 11566;
11572 -> 11571;
11572 -> 11361;
11573 -> 11547;
11573 -> 11361;
11574 -> 11572;
11574 -> 11361;
11575 -> 11361;
11576 -> 11573;
11576 -> 11361;
11577 -> 11361;
11578 -> 11361;
11578 -> 0;
11579 -> 11361;
11580 -> 11361;
11580 -> 11579;
11581 -> 11579;
11582 -> 11580;
11582 -> 11581;
11583 -> 11581;
11584 -> 11582;
11584 -> 11583;
11585 -> 11584;
11585 -> 11581;
11586 -> 11581;
11587 -> 11585;
11587 -> 11586;
11588 -> 11361;
11589 -> 11588;
11589 -> 11361;
11590 -> 11361;
11590 -> 11589;
11591 -> 11589;
11592 -> 11590;
11592 -> 11591;
11593 -> 11591;
11594 -> 11592;
11594 -> 11593;
11595 -> 11594;
11595 -> 11591;
11596 -> 11591;
11597 -> 11595;
11597 -> 11596;
11598 -> 11361;
11598 -> 0;
11599 -> 11361;
11600 -> 11597;
11600 -> 11599;
11600 -> 11361;
11601 -> 11361;
11602 -> 11576;
11602 -> 11361;
11603 -> 11361;
11604 -> 11361;
11605 -> 11361;
11606 -> 11361;
11607 -> 11361;
11608 -> 11361;
11609 -> 11361;
11610 -> 11361;
11610 -> 11609;
11611 -> 11610;
11611 -> 11361;
11611 -> 11609;
11612 -> 11611;
11612 -> 11609;
11613 -> 11612;
11613 -> 11361;
11614 -> 11361;
11615 -> 11361;
11616 -> 11615;
11617 -> 11616;
11617 -> 11615;
11618 -> 11615;
11619 -> 11616;
11620 -> 11616;
11620 -> 11619;
11621 -> 11619;
11621 -> 11616;
11622 -> 11616;
11623 -> 11616;
11624 -> 11616;
11624 -> 11361;
11625 -> 11624;
11625 -> 11361;
11626 -> 11361;
11627 -> 11626;
11627 -> 11361;
11628 -> 11361;
11629 -> 11361;
11629 -> 11628;
11630 -> 11628;
11631 -> 11629;
11631 -> 11361;
11631 -> 11630;
11632 -> 11631;
11632 -> 11361;
11632 -> 8402;
11632 -> 11630;
11633 -> 11630;
11634 -> 11632;
11634 -> 11628;
11635 -> 11634;
11635 -> 11361;
11636 -> 11361;
11637 -> 11361;
11637 -> 11636;
11638 -> 0;
11638 -> 11636;
11639 -> 11638;
11639 -> 11361;
11640 -> 11361;
11641 -> 11639;
11641 -> 11640;
11642 -> 11641;
11642 -> 11640;
11643 -> 11640;
11644 -> 11575;
11644 -> 11361;
11645 -> 11644;
11646 -> 11645;
11646 -> 11644;
11647 -> 11646;
11647 -> 11642;
11647 -> 11644;
11648 -> 11614;
11648 -> 11647;
11648 -> 11644;
11649 -> 11544;
11649 -> 11648;
11649 -> 11361;
11650 -> 11547;
11650 -> 11361;
11651 -> 11548;
11651 -> 11547;
11651 -> 11361;
11652 -> 11616;
11652 -> 11547;
11652 -> 11651;
11652 -> 11361;
11652 -> 0;
11653 -> 11652;
11653 -> 11361;
11654 -> 11652;
11655 -> 11652;
11655 -> 6994;
11655 -> 11361;
11656 -> 11652;
11656 -> 11361;
11657 -> 11361;
11658 -> 11656;
11658 -> 11657;
11659 -> 11656;
11659 -> 11657;
11660 -> 11658;
11660 -> 11659;
11660 -> 11657;
11661 -> 11657;
11662 -> 11652;
11662 -> 11361;
11663 -> 11662;
11663 -> 0;
11663 -> 11361;
11664 -> 11361;
11665 -> 11664;
11665 -> 11652;
11666 -> 11665;
11666 -> 11361;
11667 -> 11662;
11667 -> 11505;
11667 -> 11361;
11668 -> 11666;
11668 -> 11667;
11668 -> 11361;
11669 -> 10881;
11669 -> 0;
11669 -> 11361;
11670 -> 11361;
11671 -> 11361;
11672 -> 11361;
11672 -> 11671;
11673 -> 11671;
11674 -> 11673;
11675 -> 11672;
11675 -> 11673;
11676 -> 0;
11676 -> 11673;
11677 -> 11673;
11678 -> 11676;
11678 -> 11677;
11679 -> 11675;
11679 -> 11677;
11680 -> 11677;
11681 -> 11678;
11681 -> 11680;
11681 -> 11677;
11682 -> 11678;
11682 -> 11679;
11682 -> 11652;
11682 -> 11677;
11683 -> 11682;
11683 -> 11671;
11684 -> 11683;
11684 -> 11671;
11685 -> 11684;
11685 -> 11671;
11686 -> 11685;
11686 -> 11671;
11687 -> 11686;
11687 -> 11361;
11688 -> 11361;
11689 -> 11361;
11689 -> 11688;
11690 -> 11688;
11691 -> 11689;
11691 -> 11652;
11691 -> 11690;
11692 -> 11688;
11693 -> 11692;
11694 -> 11689;
11694 -> 11692;
11695 -> 0;
11695 -> 11692;
11696 -> 11692;
11697 -> 11695;
11697 -> 11696;
11698 -> 11694;
11698 -> 11696;
11699 -> 11696;
11700 -> 11697;
11700 -> 11699;
11700 -> 11696;
11701 -> 11697;
11701 -> 11698;
11701 -> 11652;
11701 -> 11696;
11702 -> 11691;
11702 -> 11701;
11702 -> 11688;
11703 -> 11702;
11703 -> 11688;
11704 -> 11703;
11704 -> 11688;
11705 -> 11704;
11705 -> 11361;
11706 -> 11687;
11706 -> 11705;
11706 -> 11361;
11707 -> 11361;
11708 -> 11361;
11708 -> 11707;
11709 -> 0;
11709 -> 11707;
11710 -> 11707;
11711 -> 11709;
11711 -> 11710;
11712 -> 11708;
11712 -> 11710;
11713 -> 11710;
11714 -> 11711;
11714 -> 11713;
11714 -> 11710;
11715 -> 11711;
11715 -> 11712;
11715 -> 11652;
11715 -> 11710;
11716 -> 11715;
11716 -> 11361;
11717 -> 11706;
11717 -> 11716;
11717 -> 11361;
11718 -> 11668;
11718 -> 11717;
11718 -> 11361;
11719 -> 11652;
11719 -> 11361;
11720 -> 11652;
11720 -> 11361;
11721 -> 11652;
11721 -> 11626;
11722 -> 11652;
11722 -> 11361;
11723 -> 11721;
11723 -> 11361;
11724 -> 11652;
11724 -> 11361;
11725 -> 11652;
11725 -> 11361;
11726 -> 11725;
11726 -> 11361;
11727 -> 11724;
11727 -> 11361;
11728 -> 11504;
11728 -> 11361;
11729 -> 11721;
11730 -> 11729;
11730 -> 11721;
11731 -> 11730;
11731 -> 11721;
11732 -> 11721;
11733 -> 11732;
11734 -> 11732;
11735 -> 11733;
11735 -> 11734;
11736 -> 11735;
11736 -> 11734;
11737 -> 11736;
11737 -> 11732;
11738 -> 11737;
11738 -> 11721;
11739 -> 11721;
11740 -> 11721;
11741 -> 11721;
11742 -> 11740;
11742 -> 11741;
11743 -> 11740;
11743 -> 11741;
11744 -> 11742;
11744 -> 11743;
11744 -> 11741;
11745 -> 11741;
11746 -> 11721;
11747 -> 11721;
11747 -> 11746;
11748 -> 11747;
11748 -> 11721;
11748 -> 7066;
11748 -> 11746;
11749 -> 11746;
11750 -> 11748;
11750 -> 11749;
11750 -> 11746;
11751 -> 11750;
11751 -> 11721;
11752 -> 11731;
11752 -> 11721;
11753 -> 11751;
11753 -> 11721;
11754 -> 11721;
11755 -> 11721;
11756 -> 11752;
11756 -> 11721;
11757 -> 11754;
11757 -> 11721;
11758 -> 11721;
11759 -> 11758;
11759 -> 11721;
11760 -> 11721;
11761 -> 11759;
11761 -> 11760;
11761 -> 11721;
11762 -> 11756;
11762 -> 11721;
11763 -> 11759;
11763 -> 11721;
11764 -> 11721;
11765 -> 11762;
11765 -> 11764;
11766 -> 11763;
11766 -> 11764;
11767 -> 11757;
11767 -> 11764;
11768 -> 11721;
11769 -> 11721;
11770 -> 11765;
11770 -> 11769;
11771 -> 11768;
11771 -> 11769;
11772 -> 11753;
11772 -> 11769;
11773 -> 11754;
11773 -> 11769;
11774 -> 11751;
11774 -> 11769;
11775 -> 11769;
11776 -> 11771;
11776 -> 11769;
11777 -> 11769;
11778 -> 11766;
11778 -> 11777;
11778 -> 11721;
11779 -> 11721;
11780 -> 11721;
11780 -> 11779;
11781 -> 11779;
11782 -> 11780;
11782 -> 11781;
11783 -> 11779;
11784 -> 11782;
11784 -> 11721;
11784 -> 11783;
11785 -> 0;
11785 -> 11783;
11786 -> 9872;
11786 -> 11721;
11787 -> 11721;
11788 -> 11770;
11788 -> 11787;
11789 -> 11785;
11789 -> 11787;
11790 -> 11786;
11790 -> 11787;
11791 -> 11721;
11791 -> 11787;
11792 -> 11751;
11792 -> 11787;
11793 -> 11787;
11794 -> 11789;
11794 -> 11787;
11795 -> 11787;
11796 -> 11778;
11796 -> 11795;
11796 -> 11721;
11797 -> 11788;
11797 -> 11721;
11798 -> 11721;
11799 -> 11721;
11800 -> 11796;
11800 -> 11799;
11800 -> 11721;
11801 -> 11721;
11802 -> 11801;
11803 -> 11801;
11803 -> 11802;
11804 -> 11802;
11804 -> 11801;
11805 -> 11801;
11805 -> 11721;
11806 -> 11721;
11807 -> 11805;
11807 -> 11806;
11808 -> 11806;
11809 -> 11807;
11809 -> 11808;
11810 -> 11808;
11811 -> 11809;
11811 -> 11810;
11812 -> 11810;
11813 -> 11811;
11813 -> 11721;
11813 -> 11812;
11813 -> 11810;
11814 -> 11808;
11815 -> 11809;
11815 -> 11806;
11816 -> 11806;
11817 -> 11721;
11818 -> 11721;
11819 -> 11818;
11819 -> 11721;
11820 -> 11797;
11820 -> 11721;
11821 -> 11721;
11822 -> 11820;
11822 -> 11821;
11823 -> 11721;
11823 -> 11821;
11824 -> 11823;
11824 -> 11721;
11824 -> 11821;
11825 -> 11824;
11825 -> 11721;
11825 -> 11821;
11826 -> 11824;
11826 -> 11825;
11827 -> 11826;
11827 -> 11721;
11828 -> 11721;
11829 -> 11822;
11829 -> 11828;
11829 -> 11721;
11830 -> 11828;
11830 -> 11721;
11831 -> 11801;
11832 -> 11801;
11832 -> 11721;
11833 -> 0;
11833 -> 11721;
11834 -> 11721;
11835 -> 11721;
11836 -> 11721;
11837 -> 11721;
11837 -> 11801;
11837 -> 11836;
11838 -> 11837;
11838 -> 11801;
11838 -> 7026;
11838 -> 11836;
11839 -> 11836;
11840 -> 11838;
11840 -> 11839;
11840 -> 11836;
11841 -> 11840;
11841 -> 11721;
11842 -> 11721;
11843 -> 11721;
11843 -> 11801;
11843 -> 11842;
11844 -> 11843;
11844 -> 11801;
11844 -> 7034;
11844 -> 11842;
11845 -> 11842;
11846 -> 11844;
11846 -> 11845;
11846 -> 11842;
11847 -> 11846;
11847 -> 11721;
11848 -> 11721;
11849 -> 11721;
11849 -> 11801;
11849 -> 11848;
11850 -> 11849;
11850 -> 11801;
11850 -> 7038;
11850 -> 11848;
11851 -> 11848;
11852 -> 11850;
11852 -> 11851;
11852 -> 11848;
11853 -> 11852;
11853 -> 11721;
11854 -> 11721;
11855 -> 11721;
11855 -> 11801;
11855 -> 11854;
11856 -> 11855;
11856 -> 11801;
11856 -> 7062;
11856 -> 11854;
11857 -> 11854;
11858 -> 11856;
11858 -> 11857;
11858 -> 11854;
11859 -> 11858;
11859 -> 11721;
11860 -> 11721;
11861 -> 11721;
11861 -> 11801;
11861 -> 11860;
11862 -> 11861;
11862 -> 11801;
11862 -> 7018;
11862 -> 11860;
11863 -> 11860;
11864 -> 11862;
11864 -> 11863;
11864 -> 11860;
11865 -> 11864;
11865 -> 11721;
11866 -> 11721;
11867 -> 11801;
11867 -> 11721;
11868 -> 11867;
11868 -> 11721;
11869 -> 11829;
11869 -> 11868;
11869 -> 11721;
11870 -> 11822;
11870 -> 11721;
11871 -> 11870;
11871 -> 11721;
11872 -> 11721;
11873 -> 11721;
11873 -> 11801;
11873 -> 11872;
11874 -> 11873;
11874 -> 11721;
11875 -> 11721;
11876 -> 11871;
11876 -> 11875;
11876 -> 11721;
11877 -> 11721;
11878 -> 11871;
11878 -> 11721;
11879 -> 11878;
11879 -> 11721;
11880 -> 11721;
11881 -> 11879;
11881 -> 11880;
11881 -> 11721;
11882 -> 11801;
11883 -> 11801;
11884 -> 11883;
11884 -> 11801;
11885 -> 11801;
11886 -> 11801;
11887 -> 11801;
11888 -> 11801;
11889 -> 11801;
11890 -> 11889;
11890 -> 11801;
11891 -> 11889;
11891 -> 11801;
11892 -> 11891;
11893 -> 11892;
11893 -> 11801;
11894 -> 11801;
11895 -> 11894;
11895 -> 11801;
11896 -> 11801;
11897 -> 11801;
11898 -> 11896;
11898 -> 11801;
11899 -> 11801;
11900 -> 11801;
11900 -> 11899;
11901 -> 0;
11901 -> 11899;
11902 -> 11901;
11902 -> 11801;
11903 -> 11902;
11903 -> 11801;
11904 -> 11801;
11905 -> 11903;
11905 -> 11904;
11906 -> 11898;
11906 -> 11904;
11907 -> 11905;
11907 -> 0;
11907 -> 11904;
11908 -> 11905;
11908 -> 11907;
11909 -> 11801;
11910 -> 11801;
11910 -> 11909;
11911 -> 11910;
11911 -> 11801;
11911 -> 11909;
11912 -> 11911;
11912 -> 11801;
11913 -> 11801;
11914 -> 11912;
11914 -> 11801;
11915 -> 11912;
11915 -> 11914;
11916 -> 11915;
11916 -> 11801;
11917 -> 11912;
11917 -> 11801;
11918 -> 11902;
11918 -> 11908;
11918 -> 11801;
11919 -> 11918;
11919 -> 11916;
11919 -> 11801;
11920 -> 11801;
11921 -> 11801;
11921 -> 11920;
11922 -> 11920;
11923 -> 11922;
11923 -> 11920;
11924 -> 11920;
11925 -> 11923;
11925 -> 11924;
11926 -> 11921;
11926 -> 11924;
11927 -> 11924;
11928 -> 11926;
11928 -> 11927;
11929 -> 11927;
11930 -> 11929;
11930 -> 11924;
11931 -> 11924;
11932 -> 11926;
11932 -> 11931;
11933 -> 11932;
11933 -> 11801;
11933 -> 11931;
11934 -> 11933;
11934 -> 11924;
11935 -> 11924;
11936 -> 11934;
11936 -> 11935;
11937 -> 11935;
11937 -> 11924;
11938 -> 11930;
11938 -> 11937;
11938 -> 11924;
11939 -> 11924;
11940 -> 11926;
11940 -> 11939;
11941 -> 11940;
11941 -> 11939;
11942 -> 11941;
11942 -> 11801;
11942 -> 11939;
11943 -> 11942;
11943 -> 11924;
11944 -> 11924;
11945 -> 11943;
11945 -> 11944;
11946 -> 11924;
11947 -> 11945;
11947 -> 11946;
11948 -> 11946;
11948 -> 11924;
11949 -> 11924;
11950 -> 11938;
11950 -> 11948;
11950 -> 11924;
11951 -> 11924;
11952 -> 11926;
11952 -> 11951;
11953 -> 11952;
11953 -> 11924;
11954 -> 11953;
11954 -> 3303;
11954 -> 11924;
11955 -> 11950;
11955 -> 11954;
11955 -> 11924;
11956 -> 11924;
11957 -> 11924;
11958 -> 11957;
11958 -> 11801;
11959 -> 11801;
11960 -> 11801;
11960 -> 0;
11961 -> 11801;
11962 -> 11801;
11962 -> 11961;
11963 -> 11961;
11964 -> 11962;
11964 -> 11963;
11965 -> 11963;
11966 -> 11964;
11966 -> 11965;
11967 -> 11966;
11967 -> 11963;
11968 -> 11963;
11969 -> 11967;
11969 -> 11968;
11970 -> 11801;
11971 -> 11970;
11971 -> 11801;
11972 -> 11801;
11972 -> 11971;
11973 -> 11971;
11974 -> 11972;
11974 -> 11973;
11975 -> 11973;
11976 -> 11974;
11976 -> 11975;
11977 -> 11976;
11977 -> 11973;
11978 -> 11973;
11979 -> 11977;
11979 -> 11978;
11980 -> 11801;
11980 -> 0;
11981 -> 11801;
11982 -> 11979;
11982 -> 11981;
11982 -> 11801;
11983 -> 11801;
11984 -> 11801;
11985 -> 11801;
11985 -> 11984;
11986 -> 11985;
11986 -> 11801;
11986 -> 11984;
11987 -> 11986;
11987 -> 11984;
11988 -> 11987;
11988 -> 11801;
11989 -> 11801;
11990 -> 11801;
11991 -> 11801;
11992 -> 11801;
11993 -> 11991;
11993 -> 11992;
11994 -> 11991;
11994 -> 11992;
11995 -> 11993;
11995 -> 11992;
11996 -> 11992;
11997 -> 11993;
11997 -> 11996;
11998 -> 11996;
11998 -> 11992;
11999 -> 11992;
12000 -> 11992;
12001 -> 11993;
12001 -> 12000;
12002 -> 0;
12002 -> 12000;
12003 -> 12001;
12003 -> 11992;
12004 -> 11992;
12005 -> 11993;
12005 -> 12004;
12006 -> 12005;
12006 -> 11801;
12006 -> 12004;
12007 -> 12006;
12007 -> 11992;
12008 -> 12007;
12008 -> 11992;
12009 -> 11992;
12010 -> 12009;
12010 -> 11801;
12011 -> 11801;
12012 -> 11801;
12013 -> 11801;
12014 -> 11801;
12015 -> 11801;
12016 -> 11801;
12017 -> 11801;
12018 -> 11801;
12018 -> 12017;
12019 -> 12017;
12020 -> 12019;
12020 -> 11801;
12021 -> 11801;
12022 -> 12021;
12023 -> 11801;
12024 -> 12020;
12024 -> 12023;
12024 -> 11801;
12025 -> 11801;
12026 -> 11801;
12027 -> 11801;
12028 -> 11801;
12029 -> 12027;
12029 -> 12028;
12030 -> 12028;
12031 -> 12029;
12031 -> 12030;
12031 -> 12028;
12032 -> 12029;
12032 -> 12028;
12033 -> 12028;
12033 -> 11801;
12034 -> 11801;
12035 -> 11801;
12036 -> 11801;
12037 -> 12035;
12037 -> 12036;
12038 -> 12036;
12039 -> 12037;
12039 -> 12038;
12040 -> 12038;
12041 -> 12039;
12041 -> 12040;
12042 -> 12040;
12043 -> 12041;
12043 -> 11801;
12043 -> 12042;
12043 -> 12040;
12044 -> 12038;
12045 -> 12039;
12045 -> 12036;
12046 -> 12036;
12047 -> 11801;
12048 -> 11801;
12049 -> 12048;
12049 -> 11801;
12050 -> 12049;
12051 -> 12049;
12052 -> 12050;
12052 -> 12051;
12053 -> 12051;
12054 -> 12051;
12054 -> 12049;
12055 -> 12049;
12056 -> 12054;
12056 -> 12055;
12057 -> 12056;
12057 -> 12049;
12058 -> 12049;
12059 -> 12054;
12059 -> 12058;
12060 -> 12058;
12061 -> 12059;
12061 -> 12060;
12062 -> 12061;
12062 -> 11801;
12062 -> 12060;
12063 -> 12062;
12063 -> 12058;
12064 -> 12058;
12065 -> 12063;
12065 -> 12064;
12065 -> 12058;
12066 -> 12065;
12066 -> 12058;
12067 -> 12066;
12068 -> 12063;
12068 -> 12067;
12069 -> 12067;
12070 -> 12068;
12070 -> 12069;
12071 -> 12070;
12071 -> 12067;
12072 -> 12067;
12073 -> 12071;
12073 -> 12072;
12074 -> 12073;
12074 -> 12049;
12075 -> 12049;
12076 -> 12074;
12076 -> 12075;
12077 -> 12075;
12078 -> 12077;
12078 -> 12049;
12079 -> 12049;
12080 -> 12057;
12080 -> 12078;
12080 -> 12049;
12081 -> 11801;
12081 -> 11721;
12082 -> 11879;
12082 -> 12081;
12082 -> 11721;
12083 -> 12082;
12083 -> 11721;
12084 -> 11721;
12085 -> 12083;
12085 -> 12084;
12085 -> 11721;
12086 -> 11721;
12086 -> 10879;
12087 -> 10879;
12088 -> 12083;
12088 -> 12087;
12088 -> 10879;
12089 -> 12086;
12089 -> 10879;
12090 -> 2800;
12090 -> 10874;
12091 -> 0;
12091 -> 10874;
12092 -> 2801;
12092 -> 10874;
12093 -> 10874;
12094 -> 10874;
12095 -> 12090;
12095 -> 12094;
12096 -> 12091;
12096 -> 12094;
12097 -> 12092;
12097 -> 12094;
12098 -> 12091;
12098 -> 12094;
12099 -> 12093;
12099 -> 12094;
12100 -> 12094;
12101 -> 12098;
12101 -> 12100;
12101 -> 12094;
12102 -> 12099;
12102 -> 12100;
12102 -> 12094;
12103 -> 12101;
12103 -> 12102;
12103 -> 12094;
12104 -> 12096;
12104 -> 12094;
12105 -> 12097;
12105 -> 12094;
12106 -> 12098;
12106 -> 12094;
12107 -> 12099;
12107 -> 12094;
12108 -> 12104;
12108 -> 12094;
12109 -> 12094;
12110 -> 12107;
12110 -> 12109;
12110 -> 12094;
12111 -> 12106;
12111 -> 12109;
12111 -> 12094;
12112 -> 12110;
12112 -> 12111;
12112 -> 12094;
12113 -> 12094;
12114 -> 12113;
12114 -> 12094;
12115 -> 12108;
12115 -> 12094;
12116 -> 12094;
12117 -> 12096;
12117 -> 12116;
12117 -> 12094;
12118 -> 12096;
12118 -> 0;
12118 -> 12094;
12119 -> 12095;
12119 -> 12096;
12119 -> 11801;
12119 -> 12094;
12120 -> 12119;
12121 -> 12119;
12122 -> 12121;
12122 -> 12119;
12123 -> 0;
12123 -> 12119;
12124 -> 12119;
12125 -> 12122;
12125 -> 12124;
12126 -> 12123;
12126 -> 12124;
12127 -> 12125;
12127 -> 12126;
12127 -> 12124;
12128 -> 12119;
12129 -> 12119;
12130 -> 12119;
12131 -> 12129;
12131 -> 12130;
12131 -> 12119;
12132 -> 12129;
12132 -> 12119;
12133 -> 12119;
12134 -> 12119;
12135 -> 12119;
12136 -> 12134;
12136 -> 12119;
12137 -> 12119;
12138 -> 0;
12138 -> 12119;
12139 -> 12119;
12139 -> 0;
12140 -> 12119;
12141 -> 12119;
12142 -> 0;
12142 -> 12119;
12143 -> 12119;
12144 -> 12143;
12145 -> 12143;
12146 -> 12144;
12146 -> 12145;
12147 -> 12146;
12147 -> 12143;
12148 -> 12143;
12149 -> 12143;
12149 -> 12119;
12150 -> 12119;
12151 -> 12119;
12152 -> 12119;
12152 -> 12151;
12153 -> 0;
12153 -> 12151;
12154 -> 12153;
12154 -> 12119;
12155 -> 12154;
12155 -> 12142;
12155 -> 12119;
12156 -> 12119;
12157 -> 12119;
12158 -> 12156;
12158 -> 12119;
12158 -> 12157;
12159 -> 12119;
12160 -> 12156;
12160 -> 12119;
12160 -> 12159;
12161 -> 12159;
12162 -> 12160;
12162 -> 12119;
12163 -> 12162;
12163 -> 12119;
12164 -> 12163;
12164 -> 12139;
12164 -> 12119;
12165 -> 12155;
12165 -> 12164;
12165 -> 12119;
12166 -> 12119;
12167 -> 12119;
12167 -> 12166;
12168 -> 12167;
12168 -> 12119;
12168 -> 6270;
12168 -> 12166;
12169 -> 12168;
12170 -> 12168;
12171 -> 12167;
12171 -> 12170;
12172 -> 12170;
12173 -> 12171;
12173 -> 12119;
12173 -> 12172;
12173 -> 12170;
12174 -> 12170;
12175 -> 12171;
12175 -> 12119;
12175 -> 12174;
12176 -> 12174;
12177 -> 12175;
12177 -> 12119;
12177 -> 12176;
12178 -> 12174;
12179 -> 12178;
12180 -> 12175;
12180 -> 12178;
12181 -> 0;
12181 -> 12178;
12182 -> 12178;
12183 -> 12181;
12183 -> 12182;
12184 -> 12180;
12184 -> 12182;
12185 -> 12182;
12186 -> 12183;
12186 -> 12185;
12186 -> 12182;
12187 -> 12183;
12187 -> 12184;
12187 -> 12119;
12187 -> 12182;
12188 -> 12177;
12188 -> 12187;
12188 -> 12174;
12189 -> 12188;
12189 -> 12174;
12190 -> 12189;
12190 -> 12174;
12191 -> 12190;
12191 -> 12170;
12192 -> 12170;
12193 -> 12171;
12193 -> 12119;
12193 -> 12192;
12194 -> 12192;
12195 -> 12193;
12195 -> 12119;
12195 -> 12194;
12196 -> 12192;
12197 -> 12196;
12198 -> 12193;
12198 -> 12196;
12199 -> 0;
12199 -> 12196;
12200 -> 12196;
12201 -> 12199;
12201 -> 12200;
12202 -> 12198;
12202 -> 12200;
12203 -> 12200;
12204 -> 12201;
12204 -> 12203;
12204 -> 12200;
12205 -> 12201;
12205 -> 12202;
12205 -> 12119;
12205 -> 12200;
12206 -> 12195;
12206 -> 12205;
12206 -> 12192;
12207 -> 12206;
12207 -> 12192;
12208 -> 12207;
12208 -> 12192;
12209 -> 12208;
12209 -> 12170;
12210 -> 12191;
12210 -> 12209;
12210 -> 12170;
12211 -> 12210;
12211 -> 12168;
12212 -> 12211;
12213 -> 12167;
12213 -> 12212;
12214 -> 12213;
12214 -> 12119;
12214 -> 12212;
12215 -> 12214;
12215 -> 12211;
12216 -> 12211;
12217 -> 12167;
12217 -> 12216;
12218 -> 12217;
12218 -> 12119;
12218 -> 12216;
12219 -> 12218;
12219 -> 12211;
12220 -> 12211;
12221 -> 12215;
12221 -> 12220;
12222 -> 12219;
12222 -> 12220;
12223 -> 12220;
12224 -> 12221;
12224 -> 12223;
12224 -> 12220;
12225 -> 12224;
12226 -> 12222;
12226 -> 12225;
12226 -> 12224;
12227 -> 12220;
12228 -> 12221;
12228 -> 12227;
12229 -> 12227;
12230 -> 12228;
12230 -> 12229;
12231 -> 12230;
12231 -> 12227;
12232 -> 0;
12232 -> 12231;
12233 -> 12232;
12233 -> 12220;
12234 -> 12220;
12235 -> 12222;
12235 -> 12234;
12236 -> 12234;
12237 -> 12235;
12237 -> 12236;
12238 -> 12237;
12238 -> 12234;
12239 -> 0;
12239 -> 12238;
12240 -> 12239;
12240 -> 12220;
12241 -> 12220;
12242 -> 12233;
12242 -> 12241;
12243 -> 12240;
12243 -> 12241;
12244 -> 12242;
12244 -> 12243;
12244 -> 12241;
12245 -> 12244;
12245 -> 12241;
12246 -> 12245;
12246 -> 12243;
12246 -> 12241;
12247 -> 12246;
12247 -> 12241;
12248 -> 12245;
12248 -> 0;
12248 -> 12241;
12249 -> 12248;
12249 -> 12241;
12250 -> 12247;
12250 -> 12249;
12251 -> 12167;
12251 -> 12119;
12251 -> 12168;
12252 -> 12250;
12252 -> 12168;
12253 -> 6270;
12253 -> 12168;
12254 -> 12167;
12254 -> 12119;
12254 -> 12252;
12254 -> 12166;
12255 -> 12254;
12255 -> 12119;
12256 -> 12165;
12256 -> 12255;
12256 -> 12119;
12257 -> 12119;
12257 -> 12142;
12258 -> 12119;
12258 -> 0;
12258 -> 12142;
12259 -> 12142;
12260 -> 12142;
12261 -> 12257;
12261 -> 12260;
12262 -> 12260;
12263 -> 12261;
12263 -> 12262;
12264 -> 12262;
12265 -> 12263;
12265 -> 12119;
12265 -> 12264;
12265 -> 12262;
12266 -> 12262;
12267 -> 12263;
12267 -> 12119;
12267 -> 12266;
12268 -> 12266;
12269 -> 12267;
12269 -> 12119;
12269 -> 12268;
12270 -> 12266;
12271 -> 12270;
12272 -> 12267;
12272 -> 12270;
12273 -> 0;
12273 -> 12270;
12274 -> 12270;
12275 -> 12273;
12275 -> 12274;
12276 -> 12272;
12276 -> 12274;
12277 -> 12274;
12278 -> 12275;
12278 -> 12277;
12278 -> 12274;
12279 -> 12275;
12279 -> 12276;
12279 -> 12119;
12279 -> 12274;
12280 -> 12269;
12280 -> 12279;
12280 -> 12266;
12281 -> 12280;
12281 -> 12266;
12282 -> 12281;
12282 -> 12266;
12283 -> 12282;
12283 -> 12262;
12284 -> 12262;
12285 -> 12263;
12285 -> 12119;
12285 -> 12284;
12286 -> 12284;
12287 -> 12285;
12287 -> 12119;
12287 -> 12286;
12288 -> 12284;
12289 -> 12288;
12290 -> 12285;
12290 -> 12288;
12291 -> 0;
12291 -> 12288;
12292 -> 12288;
12293 -> 12291;
12293 -> 12292;
12294 -> 12290;
12294 -> 12292;
12295 -> 12292;
12296 -> 12293;
12296 -> 12295;
12296 -> 12292;
12297 -> 12293;
12297 -> 12294;
12297 -> 12119;
12297 -> 12292;
12298 -> 12287;
12298 -> 12297;
12298 -> 12284;
12299 -> 12298;
12299 -> 12284;
12300 -> 12299;
12300 -> 12284;
12301 -> 12300;
12301 -> 12262;
12302 -> 12283;
12302 -> 12301;
12302 -> 12262;
12303 -> 12302;
12303 -> 12260;
12304 -> 12260;
12305 -> 12261;
12305 -> 12304;
12306 -> 12304;
12307 -> 12305;
12307 -> 12119;
12307 -> 12306;
12307 -> 12304;
12308 -> 12304;
12309 -> 12305;
12309 -> 12119;
12309 -> 12308;
12310 -> 0;
12310 -> 12308;
12311 -> 12308;
12312 -> 12310;
12312 -> 12311;
12313 -> 12309;
12313 -> 12311;
12314 -> 12311;
12315 -> 12312;
12315 -> 12314;
12315 -> 12311;
12316 -> 12312;
12316 -> 12313;
12316 -> 12119;
12316 -> 12311;
12317 -> 12316;
12317 -> 12304;
12318 -> 12304;
12319 -> 12305;
12319 -> 12119;
12319 -> 12318;
12320 -> 0;
12320 -> 12318;
12321 -> 12318;
12322 -> 12320;
12322 -> 12321;
12323 -> 12319;
12323 -> 12321;
12324 -> 12321;
12325 -> 12322;
12325 -> 12324;
12325 -> 12321;
12326 -> 12322;
12326 -> 12323;
12326 -> 12119;
12326 -> 12321;
12327 -> 12326;
12327 -> 12304;
12328 -> 12317;
12328 -> 12327;
12328 -> 12304;
12329 -> 12328;
12329 -> 12260;
12330 -> 12303;
12330 -> 12329;
12330 -> 12260;
12331 -> 12260;
12332 -> 12261;
12332 -> 12119;
12332 -> 12331;
12332 -> 12260;
12333 -> 12260;
12334 -> 12261;
12334 -> 12119;
12334 -> 12333;
12335 -> 12333;
12336 -> 12335;
12337 -> 12334;
12337 -> 12335;
12338 -> 0;
12338 -> 12335;
12339 -> 12335;
12340 -> 12338;
12340 -> 12339;
12341 -> 12337;
12341 -> 12339;
12342 -> 12339;
12343 -> 12340;
12343 -> 12342;
12343 -> 12339;
12344 -> 12340;
12344 -> 12341;
12344 -> 12119;
12344 -> 12339;
12345 -> 12344;
12345 -> 12333;
12346 -> 12345;
12346 -> 12333;
12347 -> 12346;
12347 -> 12333;
12348 -> 12347;
12348 -> 12333;
12349 -> 12348;
12349 -> 12260;
12350 -> 12260;
12351 -> 12261;
12351 -> 12119;
12351 -> 12350;
12352 -> 12350;
12353 -> 12352;
12354 -> 12351;
12354 -> 12352;
12355 -> 0;
12355 -> 12352;
12356 -> 12352;
12357 -> 12355;
12357 -> 12356;
12358 -> 12354;
12358 -> 12356;
12359 -> 12356;
12360 -> 12357;
12360 -> 12359;
12360 -> 12356;
12361 -> 12357;
12361 -> 12358;
12361 -> 12119;
12361 -> 12356;
12362 -> 12361;
12362 -> 12350;
12363 -> 12362;
12363 -> 12350;
12364 -> 12363;
12364 -> 12350;
12365 -> 12364;
12365 -> 12350;
12366 -> 12365;
12366 -> 12260;
12367 -> 12349;
12367 -> 12366;
12367 -> 12260;
12368 -> 12330;
12368 -> 12367;
12368 -> 12260;
12369 -> 12368;
12369 -> 12142;
12370 -> 12142;
12371 -> 12257;
12371 -> 12370;
12372 -> 12370;
12373 -> 12371;
12373 -> 12119;
12373 -> 12372;
12373 -> 12370;
12374 -> 12370;
12375 -> 12371;
12375 -> 12119;
12375 -> 12374;
12376 -> 12374;
12377 -> 12375;
12377 -> 12119;
12377 -> 12376;
12378 -> 12374;
12379 -> 12378;
12380 -> 12375;
12380 -> 12378;
12381 -> 0;
12381 -> 12378;
12382 -> 12378;
12383 -> 12381;
12383 -> 12382;
12384 -> 12380;
12384 -> 12382;
12385 -> 12382;
12386 -> 12383;
12386 -> 12385;
12386 -> 12382;
12387 -> 12383;
12387 -> 12384;
12387 -> 12119;
12387 -> 12382;
12388 -> 12377;
12388 -> 12387;
12388 -> 12374;
12389 -> 12388;
12389 -> 12374;
12390 -> 12389;
12390 -> 12374;
12391 -> 12390;
12391 -> 12370;
12392 -> 12370;
12393 -> 12371;
12393 -> 12119;
12393 -> 12392;
12394 -> 12392;
12395 -> 12393;
12395 -> 12119;
12395 -> 12394;
12396 -> 12392;
12397 -> 12396;
12398 -> 12393;
12398 -> 12396;
12399 -> 0;
12399 -> 12396;
12400 -> 12396;
12401 -> 12399;
12401 -> 12400;
12402 -> 12398;
12402 -> 12400;
12403 -> 12400;
12404 -> 12401;
12404 -> 12403;
12404 -> 12400;
12405 -> 12401;
12405 -> 12402;
12405 -> 12119;
12405 -> 12400;
12406 -> 12395;
12406 -> 12405;
12406 -> 12392;
12407 -> 12406;
12407 -> 12392;
12408 -> 12407;
12408 -> 12392;
12409 -> 12408;
12409 -> 12370;
12410 -> 12391;
12410 -> 12409;
12410 -> 12370;
12411 -> 12410;
12411 -> 12142;
12412 -> 12369;
12412 -> 12411;
12412 -> 12142;
12413 -> 12142;
12414 -> 12257;
12414 -> 12413;
12415 -> 12413;
12416 -> 12414;
12416 -> 12119;
12416 -> 12415;
12416 -> 12413;
12417 -> 12413;
12418 -> 12414;
12418 -> 12119;
12418 -> 12417;
12419 -> 0;
12419 -> 12417;
12420 -> 12417;
12421 -> 12419;
12421 -> 12420;
12422 -> 12418;
12422 -> 12420;
12423 -> 12420;
12424 -> 12421;
12424 -> 12423;
12424 -> 12420;
12425 -> 12421;
12425 -> 12422;
12425 -> 12119;
12425 -> 12420;
12426 -> 12425;
12426 -> 12413;
12427 -> 12413;
12428 -> 12414;
12428 -> 12119;
12428 -> 12427;
12429 -> 0;
12429 -> 12427;
12430 -> 12427;
12431 -> 12429;
12431 -> 12430;
12432 -> 12428;
12432 -> 12430;
12433 -> 12430;
12434 -> 12431;
12434 -> 12433;
12434 -> 12430;
12435 -> 12431;
12435 -> 12432;
12435 -> 12119;
12435 -> 12430;
12436 -> 12435;
12436 -> 12413;
12437 -> 12426;
12437 -> 12436;
12437 -> 12413;
12438 -> 12437;
12438 -> 12142;
12439 -> 12412;
12439 -> 12438;
12439 -> 12142;
12440 -> 12257;
12440 -> 12142;
12441 -> 12119;
12441 -> 12142;
12442 -> 12440;
12442 -> 12441;
12442 -> 12119;
12442 -> 12143;
12442 -> 12252;
12442 -> 12142;
12443 -> 12142;
12444 -> 12442;
12444 -> 12443;
12445 -> 12442;
12445 -> 12443;
12446 -> 12443;
12447 -> 12444;
12447 -> 12446;
12448 -> 12447;
12448 -> 12443;
12449 -> 12442;
12449 -> 12443;
12450 -> 12442;
12450 -> 12443;
12451 -> 12443;
12452 -> 12449;
12452 -> 12451;
12453 -> 12452;
12453 -> 12448;
12453 -> 12451;
12454 -> 12453;
12454 -> 12443;
12455 -> 12442;
12455 -> 12443;
12456 -> 12442;
12456 -> 12443;
12457 -> 12443;
12458 -> 12455;
12458 -> 12457;
12459 -> 12457;
12460 -> 12458;
12460 -> 12459;
12461 -> 12460;
12461 -> 12454;
12461 -> 12459;
12462 -> 12457;
12463 -> 12461;
12463 -> 12462;
12464 -> 12463;
12464 -> 12454;
12464 -> 12462;
12465 -> 12463;
12465 -> 12443;
12466 -> 12442;
12466 -> 12443;
12467 -> 12442;
12467 -> 12443;
12468 -> 12467;
12468 -> 12443;
12469 -> 12466;
12469 -> 12443;
12470 -> 12141;
12470 -> 12119;
12471 -> 12465;
12471 -> 12134;
12471 -> 12119;
12472 -> 12471;
12473 -> 12472;
12473 -> 12471;
12474 -> 0;
12474 -> 12471;
12475 -> 12473;
12476 -> 12475;
12476 -> 12473;
12477 -> 12473;
12478 -> 12476;
12478 -> 12477;
12479 -> 12472;
12479 -> 12477;
12480 -> 12477;
12481 -> 12479;
12481 -> 12480;
12482 -> 12481;
12482 -> 12480;
12483 -> 12480;
12484 -> 12482;
12484 -> 12483;
12485 -> 12484;
12485 -> 12483;
12486 -> 12485;
12486 -> 12480;
12487 -> 12486;
12487 -> 12477;
12488 -> 12478;
12488 -> 12477;
12489 -> 12477;
12490 -> 12479;
12490 -> 12489;
12491 -> 12490;
12491 -> 12477;
12492 -> 11751;
12492 -> 12477;
12493 -> 12477;
12494 -> 12488;
12494 -> 12493;
12495 -> 12491;
12495 -> 12493;
12496 -> 12492;
12496 -> 12493;
12497 -> 12479;
12497 -> 12493;
12498 -> 12495;
12498 -> 12471;
12498 -> 12493;
12499 -> 12494;
12499 -> 12493;
12500 -> 12497;
12500 -> 12493;
12501 -> 12495;
12502 -> 12495;
12503 -> 12495;
12504 -> 12495;
12504 -> 12503;
12505 -> 12503;
12505 -> 12495;
12506 -> 12495;
12507 -> 12502;
12507 -> 12495;
12508 -> 12495;
12509 -> 12495;
12510 -> 12495;
12511 -> 12495;
12512 -> 12495;
12513 -> 12512;
12513 -> 12495;
12514 -> 12512;
12514 -> 12495;
12515 -> 12514;
12516 -> 12515;
12516 -> 12495;
12517 -> 12495;
12518 -> 12517;
12518 -> 12495;
12519 -> 12495;
12520 -> 12495;
12521 -> 12519;
12521 -> 12495;
12522 -> 12495;
12523 -> 12495;
12523 -> 12522;
12524 -> 0;
12524 -> 12522;
12525 -> 12524;
12525 -> 12495;
12526 -> 12525;
12526 -> 12495;
12527 -> 12495;
12528 -> 12526;
12528 -> 12527;
12529 -> 12521;
12529 -> 12527;
12530 -> 12528;
12530 -> 0;
12530 -> 12527;
12531 -> 12528;
12531 -> 12530;
12532 -> 12495;
12533 -> 12495;
12533 -> 12532;
12534 -> 12533;
12534 -> 12495;
12534 -> 12532;
12535 -> 12534;
12535 -> 12495;
12536 -> 12495;
12537 -> 12535;
12537 -> 12495;
12538 -> 12535;
12538 -> 12537;
12539 -> 12538;
12539 -> 12495;
12540 -> 12535;
12540 -> 12495;
12541 -> 12525;
12541 -> 12531;
12541 -> 12495;
12542 -> 12541;
12542 -> 12539;
12542 -> 12495;
12543 -> 12495;
12544 -> 12495;
12544 -> 12543;
12545 -> 12543;
12546 -> 12545;
12546 -> 12543;
12547 -> 12543;
12548 -> 12546;
12548 -> 12547;
12549 -> 12544;
12549 -> 12547;
12550 -> 12547;
12551 -> 12549;
12551 -> 12550;
12552 -> 12550;
12553 -> 12552;
12553 -> 12547;
12554 -> 12547;
12555 -> 12549;
12555 -> 12554;
12556 -> 12555;
12556 -> 12495;
12556 -> 12554;
12557 -> 12556;
12557 -> 12547;
12558 -> 12547;
12559 -> 12557;
12559 -> 12558;
12560 -> 12558;
12560 -> 12547;
12561 -> 12553;
12561 -> 12560;
12561 -> 12547;
12562 -> 12547;
12563 -> 12549;
12563 -> 12562;
12564 -> 12563;
12564 -> 12562;
12565 -> 12564;
12565 -> 12495;
12565 -> 12562;
12566 -> 12565;
12566 -> 12547;
12567 -> 12547;
12568 -> 12566;
12568 -> 12567;
12569 -> 12547;
12570 -> 12568;
12570 -> 12569;
12571 -> 12569;
12571 -> 12547;
12572 -> 12547;
12573 -> 12561;
12573 -> 12571;
12573 -> 12547;
12574 -> 12547;
12575 -> 12549;
12575 -> 12574;
12576 -> 12575;
12576 -> 12547;
12577 -> 12576;
12577 -> 3303;
12577 -> 12547;
12578 -> 12573;
12578 -> 12577;
12578 -> 12547;
12579 -> 12547;
12580 -> 12547;
12581 -> 12580;
12581 -> 12495;
12582 -> 12495;
12583 -> 12495;
12583 -> 0;
12584 -> 12495;
12585 -> 12495;
12585 -> 12584;
12586 -> 12584;
12587 -> 12585;
12587 -> 12586;
12588 -> 12586;
12589 -> 12587;
12589 -> 12588;
12590 -> 12589;
12590 -> 12586;
12591 -> 12586;
12592 -> 12590;
12592 -> 12591;
12593 -> 12495;
12594 -> 12593;
12594 -> 12495;
12595 -> 12495;
12595 -> 12594;
12596 -> 12594;
12597 -> 12595;
12597 -> 12596;
12598 -> 12596;
12599 -> 12597;
12599 -> 12598;
12600 -> 12599;
12600 -> 12596;
12601 -> 12596;
12602 -> 12600;
12602 -> 12601;
12603 -> 12495;
12603 -> 0;
12604 -> 12495;
12605 -> 12602;
12605 -> 12604;
12605 -> 12495;
12606 -> 12495;
12607 -> 12495;
12608 -> 12495;
12608 -> 12607;
12609 -> 12608;
12609 -> 12495;
12609 -> 12607;
12610 -> 12609;
12610 -> 12607;
12611 -> 12610;
12611 -> 12495;
12612 -> 12495;
12613 -> 12495;
12614 -> 12495;
12615 -> 12495;
12616 -> 12614;
12616 -> 12615;
12617 -> 12614;
12617 -> 12615;
12618 -> 12616;
12618 -> 12615;
12619 -> 12615;
12620 -> 12616;
12620 -> 12619;
12621 -> 12619;
12621 -> 12615;
12622 -> 12615;
12623 -> 12615;
12624 -> 12616;
12624 -> 12623;
12625 -> 0;
12625 -> 12623;
12626 -> 12624;
12626 -> 12615;
12627 -> 12615;
12628 -> 12616;
12628 -> 12627;
12629 -> 12628;
12629 -> 12495;
12629 -> 12627;
12630 -> 12629;
12630 -> 12615;
12631 -> 12630;
12631 -> 12615;
12632 -> 12615;
12633 -> 12632;
12633 -> 12495;
12634 -> 12495;
12635 -> 12495;
12636 -> 12495;
12637 -> 12495;
12638 -> 12637;
12638 -> 12495;
12639 -> 12638;
12639 -> 12495;
12640 -> 12638;
12640 -> 12495;
12641 -> 12640;
12641 -> 12495;
12642 -> 12641;
12642 -> 12495;
12643 -> 12641;
12643 -> 12495;
12644 -> 12495;
12645 -> 12495;
12646 -> 12495;
12647 -> 12495;
12648 -> 12495;
12649 -> 12495;
12649 -> 12648;
12650 -> 12648;
12651 -> 12650;
12651 -> 12495;
12652 -> 12495;
12653 -> 12652;
12654 -> 12495;
12655 -> 12651;
12655 -> 12654;
12655 -> 12495;
12656 -> 12495;
12657 -> 12495;
12658 -> 12495;
12659 -> 12495;
12660 -> 12658;
12660 -> 12659;
12661 -> 12659;
12662 -> 12660;
12662 -> 12661;
12662 -> 12659;
12663 -> 12660;
12663 -> 12659;
12664 -> 12659;
12664 -> 12495;
12665 -> 12495;
12666 -> 12495;
12667 -> 12495;
12668 -> 12666;
12668 -> 12667;
12669 -> 12667;
12670 -> 12668;
12670 -> 12669;
12671 -> 12669;
12672 -> 12670;
12672 -> 12671;
12673 -> 12671;
12674 -> 12672;
12674 -> 12495;
12674 -> 12673;
12674 -> 12671;
12675 -> 12669;
12676 -> 12670;
12676 -> 12667;
12677 -> 12667;
12678 -> 12495;
12679 -> 12495;
12679 -> 12493;
12680 -> 12679;
12680 -> 12493;
12681 -> 12493;
12682 -> 12680;
12682 -> 12681;
12682 -> 12493;
12683 -> 12499;
12683 -> 12493;
12684 -> 12680;
12684 -> 12493;
12685 -> 12493;
12686 -> 12683;
12686 -> 12685;
12687 -> 12684;
12687 -> 12685;
12688 -> 12500;
12688 -> 12685;
12689 -> 12493;
12690 -> 12495;
12690 -> 12689;
12691 -> 12493;
12692 -> 12686;
12692 -> 12691;
12693 -> 12690;
12693 -> 12691;
12694 -> 12496;
12694 -> 12691;
12695 -> 12497;
12695 -> 12691;
12696 -> 11751;
12696 -> 12691;
12697 -> 12691;
12698 -> 12693;
12698 -> 12691;
12699 -> 12691;
12700 -> 12687;
12700 -> 12699;
12700 -> 12493;
12701 -> 12477;
12702 -> 12479;
12702 -> 12701;
12703 -> 0;
12703 -> 12701;
12704 -> 12703;
12704 -> 12477;
12705 -> 9872;
12705 -> 12477;
12706 -> 12477;
12707 -> 12692;
12707 -> 12706;
12708 -> 12704;
12708 -> 12706;
12709 -> 12705;
12709 -> 12706;
12710 -> 12479;
12710 -> 12706;
12711 -> 11751;
12711 -> 12706;
12712 -> 12706;
12713 -> 12708;
12713 -> 12706;
12714 -> 12706;
12715 -> 12714;
12715 -> 12477;
12716 -> 12700;
12716 -> 12715;
12716 -> 12477;
12717 -> 12477;
12718 -> 12479;
12718 -> 12717;
12719 -> 12718;
12719 -> 12495;
12719 -> 12717;
12720 -> 12477;
12721 -> 12707;
12721 -> 12720;
12722 -> 12719;
12722 -> 12720;
12723 -> 12479;
12723 -> 12720;
12724 -> 12720;
12725 -> 12724;
12725 -> 12477;
12726 -> 12716;
12726 -> 12725;
12726 -> 12477;
12727 -> 12477;
12728 -> 12479;
12728 -> 12727;
12729 -> 12728;
12729 -> 12727;
12730 -> 12729;
12730 -> 12495;
12730 -> 12727;
12731 -> 12730;
12732 -> 12730;
12732 -> 12731;
12733 -> 12731;
12733 -> 12730;
12734 -> 12730;
12734 -> 12477;
12735 -> 12477;
12736 -> 12734;
12736 -> 12735;
12737 -> 12735;
12738 -> 12736;
12738 -> 12737;
12739 -> 12737;
12740 -> 12738;
12740 -> 12739;
12741 -> 12739;
12742 -> 12740;
12742 -> 12495;
12742 -> 12741;
12742 -> 12739;
12743 -> 12737;
12744 -> 12738;
12744 -> 12735;
12745 -> 12735;
12746 -> 12477;
12747 -> 12746;
12747 -> 12473;
12748 -> 12721;
12748 -> 12472;
12748 -> 12473;
12749 -> 12472;
12749 -> 12495;
12749 -> 12748;
12749 -> 12471;
12750 -> 12749;
12750 -> 12471;
12751 -> 12471;
12752 -> 12750;
12752 -> 12751;
12752 -> 12471;
12753 -> 12471;
12754 -> 12753;
12754 -> 12495;
12754 -> 12471;
12755 -> 12754;
12755 -> 12495;
12755 -> 12748;
12755 -> 12471;
12756 -> 12754;
12756 -> 12495;
12756 -> 12748;
12756 -> 12471;
12757 -> 12750;
12757 -> 12756;
12757 -> 12471;
12758 -> 12757;
12758 -> 12471;
12759 -> 12471;
12760 -> 12758;
12760 -> 12759;
12760 -> 12471;
12761 -> 12471;
12761 -> 12094;
12762 -> 12094;
12763 -> 12758;
12763 -> 12762;
12763 -> 12094;
12764 -> 12761;
12764 -> 12094;
12765 -> 2215;
12766 -> 2214;
12766 -> 2215;
12767 -> 2214;
12767 -> 2215;
12768 -> 2215;
12769 -> 12767;
12769 -> 12768;
12770 -> 12768;
12771 -> 12770;
12771 -> 2215;
12772 -> 12766;
12772 -> 12495;
12772 -> 2215;
12773 -> 2214;
12773 -> 12495;
12773 -> 12748;
12773 -> 2074;
12774 -> 2349;
12774 -> 12773;
12774 -> 2348;
12774 -> 2347;
12775 -> 12774;
12776 -> 12773;
12776 -> 2215;
12777 -> 12776;
12777 -> 2219;
12778 -> 12777;
12778 -> 2221;
12778 -> 2219;
12779 -> 2215;
12780 -> 2215;
12781 -> 2214;
12781 -> 2215;
12782 -> 2215;
12783 -> 12781;
12783 -> 12782;
12784 -> 12782;
12785 -> 12783;
12785 -> 12773;
12785 -> 12784;
12785 -> 12782;
12786 -> 12785;
12787 -> 12783;
12787 -> 12786;
12788 -> 12787;
12788 -> 12773;
12788 -> 12786;
12789 -> 12788;
12789 -> 12785;
12790 -> 12785;
12791 -> 12789;
12791 -> 12790;
12792 -> 12790;
12793 -> 12791;
12793 -> 12790;
12794 -> 12793;
12794 -> 12791;
12795 -> 12792;
12795 -> 12790;
12796 -> 12795;
12796 -> 12785;
12797 -> 12796;
12797 -> 12785;
12798 -> 12783;
12798 -> 12791;
12798 -> 12785;
12799 -> 12785;
12800 -> 12785;
12801 -> 12797;
12801 -> 12800;
12802 -> 12798;
12802 -> 12800;
12803 -> 12799;
12803 -> 12800;
12804 -> 12799;
12804 -> 12800;
12805 -> 12799;
12805 -> 12800;
12806 -> 12799;
12806 -> 12800;
12807 -> 12783;
12807 -> 12800;
12808 -> 12800;
12809 -> 12800;
12810 -> 12807;
12810 -> 12809;
12811 -> 12810;
12811 -> 12791;
12811 -> 12809;
12812 -> 12811;
12812 -> 12800;
12813 -> 12800;
12814 -> 12813;
12814 -> 12800;
12815 -> 12801;
12815 -> 12800;
12816 -> 12803;
12816 -> 12800;
12817 -> 12808;
12817 -> 12800;
12818 -> 12812;
12818 -> 12800;
12819 -> 12806;
12819 -> 12800;
12820 -> 12805;
12820 -> 12800;
12821 -> 12813;
12821 -> 12800;
12822 -> 12807;
12822 -> 12800;
12823 -> 12822;
12823 -> 12800;
12824 -> 12800;
12825 -> 12800;
12826 -> 12800;
12827 -> 12826;
12827 -> 12815;
12827 -> 12797;
12827 -> 12800;
12828 -> 0;
12828 -> 12800;
12829 -> 12808;
12829 -> 0;
12829 -> 12800;
12830 -> 12800;
12831 -> 12830;
12831 -> 12800;
12832 -> 12800;
12833 -> 12804;
12833 -> 12808;
12834 -> 12833;
12835 -> 12802;
12835 -> 12833;
12836 -> 12833;
12837 -> 12807;
12837 -> 12836;
12838 -> 12833;
12839 -> 12833;
12839 -> 12800;
12840 -> 12808;
12840 -> 12800;
12841 -> 12803;
12841 -> 12800;
12842 -> 12834;
12842 -> 12800;
12843 -> 12800;
12844 -> 12839;
12844 -> 12843;
12845 -> 12840;
12845 -> 12843;
12846 -> 12840;
12846 -> 12843;
12847 -> 12841;
12847 -> 12843;
12848 -> 12842;
12848 -> 12843;
12849 -> 12807;
12849 -> 12843;
12850 -> 12800;
12851 -> 12800;
12852 -> 12806;
12852 -> 12835;
12853 -> 12833;
12853 -> 12852;
12854 -> 12852;
12855 -> 12853;
12855 -> 12854;
12856 -> 12807;
12856 -> 12854;
12857 -> 12855;
12857 -> 12854;
12858 -> 12852;
12859 -> 12808;
12859 -> 12852;
12860 -> 12852;
12861 -> 12859;
12861 -> 12860;
12862 -> 12807;
12862 -> 12860;
12863 -> 12860;
12864 -> 12862;
12864 -> 12863;
12865 -> 12864;
12865 -> 12835;
12865 -> 12863;
12866 -> 12865;
12866 -> 12860;
12867 -> 12861;
12867 -> 12808;
12867 -> 12860;
12868 -> 12852;
12869 -> 12835;
12869 -> 12800;
12870 -> 12808;
12870 -> 12800;
12871 -> 0;
12871 -> 12835;
12872 -> 12835;
12873 -> 12871;
12873 -> 12872;
12874 -> 12873;
12874 -> 12835;
12875 -> 12783;
12875 -> 12835;
12875 -> 12782;
12876 -> 12875;
12876 -> 2215;
12877 -> 2214;
12877 -> 12876;
12877 -> 12835;
12877 -> 12873;
12877 -> 2074;
12878 -> 2349;
12878 -> 12877;
12878 -> 2348;
12878 -> 2347;
12879 -> 12878;
12880 -> 12877;
12880 -> 2215;
12881 -> 12880;
12881 -> 2219;
12882 -> 12881;
12882 -> 2221;
12882 -> 2219;
12883 -> 2214;
12883 -> 2215;
12884 -> 2215;
12885 -> 12883;
12885 -> 12884;
12886 -> 12885;
12886 -> 12877;
12886 -> 12884;
12887 -> 12886;
12888 -> 12885;
12888 -> 12887;
12889 -> 12887;
12890 -> 12888;
12890 -> 12877;
12890 -> 12889;
12890 -> 12887;
12891 -> 12886;
12892 -> 12886;
12893 -> 12886;
12894 -> 12893;
12895 -> 12893;
12895 -> 12894;
12896 -> 12894;
12897 -> 12895;
12897 -> 12877;
12897 -> 12896;
12897 -> 12894;
12898 -> 12893;
12899 -> 12893;
12899 -> 12886;
12900 -> 12899;
12901 -> 12899;
12901 -> 12900;
12902 -> 12901;
12902 -> 12877;
12902 -> 12900;
12903 -> 12902;
12903 -> 12899;
12904 -> 12885;
12904 -> 12877;
12904 -> 12886;
12905 -> 12892;
12905 -> 12886;
12906 -> 12886;
12907 -> 12885;
12907 -> 12905;
12907 -> 12884;
12908 -> 12885;
12908 -> 12905;
12908 -> 12884;
12909 -> 12908;
12909 -> 2215;
12910 -> 2215;
12911 -> 2349;
12911 -> 12909;
12911 -> 2348;
12911 -> 2347;
12912 -> 12911;
12913 -> 12909;
12913 -> 2215;
12914 -> 12913;
12914 -> 2219;
12915 -> 12914;
12915 -> 2221;
12915 -> 2219;
12916 -> 2214;
12916 -> 2215;
12917 -> 2215;
12918 -> 2214;
12918 -> 2215;
12919 -> 12918;
12919 -> 12909;
12919 -> 2951;
12919 -> 2215;
12920 -> 2215;
12921 -> 12919;
12922 -> 12918;
12922 -> 12921;
12923 -> 12922;
12923 -> 12909;
12923 -> 12921;
12924 -> 12923;
12924 -> 12909;
12924 -> 12921;
12925 -> 12924;
12926 -> 12925;
12926 -> 12924;
12927 -> 12924;
12928 -> 12922;
12928 -> 12926;
12928 -> 12924;
12929 -> 12926;
12929 -> 12924;
12930 -> 12922;
12930 -> 12928;
12930 -> 12924;
12931 -> 12930;
12931 -> 12921;
12932 -> 12931;
12932 -> 12919;
12933 -> 12919;
12934 -> 12932;
12934 -> 12931;
12934 -> 12933;
12934 -> 12919;
12935 -> 12918;
12935 -> 12931;
12935 -> 12919;
12936 -> 2951;
12936 -> 12919;
12937 -> 12932;
12937 -> 12919;
12938 -> 2214;
12938 -> 12937;
12938 -> 12931;
12938 -> 12935;
12938 -> 2074;
12939 -> 2214;
12939 -> 2215;
12940 -> 2215;
12941 -> 12939;
12941 -> 12940;
12942 -> 0;
12942 -> 12940;
12943 -> 12942;
12943 -> 2215;
12944 -> 2215;
12945 -> 12939;
12945 -> 12944;
12946 -> 2215;
12947 -> 2214;
12947 -> 2215;
12948 -> 2214;
12948 -> 2215;
12949 -> 2214;
12949 -> 2215;
12950 -> 2215;
12951 -> 12947;
12951 -> 12950;
12951 -> 2215;
12952 -> 12949;
12952 -> 12938;
12952 -> 12951;
12953 -> 12947;
12953 -> 12951;
12954 -> 12949;
12954 -> 12951;
12955 -> 12953;
12955 -> 12954;
12955 -> 12948;
12955 -> 12952;
12955 -> 12951;
12956 -> 12951;
12957 -> 12955;
12957 -> 12956;
12958 -> 12956;
12959 -> 12957;
12959 -> 12958;
12960 -> 12958;
12961 -> 12959;
12961 -> 12960;
12961 -> 12958;
12962 -> 12956;
12963 -> 12955;
12963 -> 12956;
12964 -> 12955;
12964 -> 12956;
12965 -> 12955;
12965 -> 12956;
12966 -> 12963;
12966 -> 12956;
12967 -> 12956;
12968 -> 12966;
12968 -> 12967;
12969 -> 12965;
12969 -> 12967;
12970 -> 12969;
12970 -> 12955;
12970 -> 12968;
12970 -> 12967;
12971 -> 12970;
12972 -> 12956;
12973 -> 12955;
12974 -> 12973;
12974 -> 12955;
12975 -> 12955;
12976 -> 12955;
12977 -> 12974;
12977 -> 12976;
12978 -> 12975;
12978 -> 12976;
12979 -> 12975;
12979 -> 12976;
12980 -> 12975;
12980 -> 12976;
12981 -> 12975;
12981 -> 12976;
12983 -> 12982;
12985 -> 12984;
12987 -> 12986;
12989 -> 12988;
12991 -> 12990;
12993 -> 12992;
12994 -> 0;
12996 -> 12983;
12996 -> 12995;
12997 -> 12985;
12997 -> 12995;
12998 -> 12987;
12998 -> 12995;
12999 -> 12989;
12999 -> 12995;
13000 -> 12991;
13000 -> 12995;
13001 -> 12993;
13001 -> 12995;
13002 -> 12994;
13002 -> 12995;
13003 -> 12995;
13004 -> 13003;
13004 -> 12995;
13005 -> 13003;
13005 -> 12995;
13006 -> 13003;
13006 -> 12995;
13007 -> 13003;
13007 -> 12995;
13008 -> 13003;
13008 -> 12995;
13009 -> 13003;
13009 -> 12995;
13010 -> 13003;
13010 -> 12995;
13011 -> 12997;
13011 -> 12995;
13012 -> 12995;
13013 -> 12996;
13013 -> 13003;
13013 -> 12995;
13014 -> 12997;
13014 -> 13003;
13014 -> 12995;
13015 -> 12998;
13015 -> 13003;
13015 -> 12995;
13016 -> 12999;
13016 -> 13003;
13016 -> 12995;
13017 -> 13000;
13017 -> 13003;
13017 -> 12995;
13018 -> 13001;
13018 -> 13003;
13018 -> 12995;
13019 -> 13002;
13019 -> 13003;
13019 -> 12995;
13020 -> 13003;
13020 -> 13019;
13020 -> 0;
13020 -> 12995;
13021 -> 12995;
13022 -> 13001;
13022 -> 12995;
13023 -> 12995;
13025 -> 13024;
13027 -> 13026;
13029 -> 13028;
13031 -> 13030;
13033 -> 13032;
13035 -> 13034;
13036 -> 0;
13038 -> 13025;
13038 -> 13037;
13039 -> 13027;
13039 -> 13037;
13040 -> 13029;
13040 -> 13037;
13041 -> 13031;
13041 -> 13037;
13042 -> 13033;
13042 -> 13037;
13043 -> 13035;
13043 -> 13037;
13044 -> 13036;
13044 -> 13037;
13045 -> 13037;
13046 -> 13045;
13046 -> 13037;
13047 -> 13045;
13047 -> 13037;
13048 -> 13045;
13048 -> 13037;
13049 -> 13045;
13049 -> 13037;
13050 -> 13045;
13050 -> 13037;
13051 -> 13045;
13051 -> 13037;
13052 -> 13045;
13052 -> 13037;
13053 -> 13039;
13053 -> 13038;
13053 -> 13037;
13054 -> 13037;
13055 -> 13038;
13055 -> 13045;
13055 -> 13037;
13056 -> 13039;
13056 -> 13045;
13056 -> 13037;
13057 -> 13040;
13057 -> 13045;
13057 -> 13037;
13058 -> 13041;
13058 -> 13045;
13058 -> 13037;
13059 -> 13042;
13059 -> 13045;
13059 -> 13037;
13060 -> 13043;
13060 -> 13045;
13060 -> 13037;
13061 -> 13044;
13061 -> 13045;
13061 -> 13037;
13062 -> 13045;
13062 -> 13061;
13062 -> 0;
13062 -> 13037;
13063 -> 13037;
13064 -> 13043;
13064 -> 13037;
13065 -> 13037;
13067 -> 13066;
13069 -> 13068;
13071 -> 13070;
13073 -> 13072;
13075 -> 13074;
13077 -> 13076;
13078 -> 0;
13080 -> 13067;
13080 -> 13079;
13081 -> 13069;
13081 -> 13079;
13082 -> 13071;
13082 -> 13079;
13083 -> 13073;
13083 -> 13079;
13084 -> 13075;
13084 -> 13079;
13085 -> 13077;
13085 -> 13079;
13086 -> 13078;
13086 -> 13079;
13087 -> 13079;
13088 -> 13087;
13088 -> 13079;
13089 -> 13087;
13089 -> 13079;
13090 -> 13087;
13090 -> 13079;
13091 -> 13087;
13091 -> 13079;
13092 -> 13087;
13092 -> 13079;
13093 -> 13087;
13093 -> 13079;
13094 -> 13087;
13094 -> 13079;
13095 -> 13081;
13095 -> 13080;
13095 -> 13079;
13096 -> 13079;
13097 -> 13080;
13097 -> 13087;
13097 -> 13079;
13098 -> 13081;
13098 -> 13087;
13098 -> 13079;
13099 -> 13082;
13099 -> 13087;
13099 -> 13079;
13100 -> 13083;
13100 -> 13087;
13100 -> 13079;
13101 -> 13084;
13101 -> 13087;
13101 -> 13079;
13102 -> 13085;
13102 -> 13087;
13102 -> 13079;
13103 -> 13086;
13103 -> 13087;
13103 -> 13079;
13104 -> 13087;
13104 -> 13103;
13104 -> 0;
13104 -> 13079;
13105 -> 13079;
13106 -> 13085;
13106 -> 13079;
13107 -> 13079;
13109 -> 13108;
13111 -> 13110;
13113 -> 13112;
13115 -> 13114;
13117 -> 13116;
13119 -> 13118;
13120 -> 0;
13122 -> 13109;
13122 -> 13121;
13123 -> 13111;
13123 -> 13121;
13124 -> 13113;
13124 -> 13121;
13125 -> 13115;
13125 -> 13121;
13126 -> 13117;
13126 -> 13121;
13127 -> 13119;
13127 -> 13121;
13128 -> 13120;
13128 -> 13121;
13129 -> 13121;
13130 -> 13129;
13130 -> 13121;
13131 -> 13129;
13131 -> 13121;
13132 -> 13129;
13132 -> 13121;
13133 -> 13129;
13133 -> 13121;
13134 -> 13129;
13134 -> 13121;
13135 -> 13129;
13135 -> 13121;
13136 -> 13129;
13136 -> 13121;
13137 -> 13123;
13137 -> 13122;
13137 -> 13121;
13138 -> 13121;
13139 -> 13122;
13139 -> 13129;
13139 -> 13121;
13140 -> 13123;
13140 -> 13129;
13140 -> 13121;
13141 -> 13124;
13141 -> 13129;
13141 -> 13121;
13142 -> 13125;
13142 -> 13129;
13142 -> 13121;
13143 -> 13126;
13143 -> 13129;
13143 -> 13121;
13144 -> 13127;
13144 -> 13129;
13144 -> 13121;
13145 -> 13128;
13145 -> 13129;
13145 -> 13121;
13146 -> 13129;
13146 -> 13145;
13146 -> 0;
13146 -> 13121;
13147 -> 13121;
13148 -> 13127;
13148 -> 13121;
13149 -> 13129;
13149 -> 13145;
13149 -> 0;
13149 -> 13148;
13150 -> 13149;
13150 -> 13129;
13150 -> 13148;
13151 -> 13121;
13153 -> 13152;
13155 -> 13154;
13157 -> 13156;
13159 -> 13158;
13161 -> 13160;
13163 -> 13162;
13164 -> 0;
13166 -> 13153;
13166 -> 13165;
13167 -> 13155;
13167 -> 13165;
13168 -> 13157;
13168 -> 13165;
13169 -> 13159;
13169 -> 13165;
13170 -> 13161;
13170 -> 13165;
13171 -> 13163;
13171 -> 13165;
13172 -> 13164;
13172 -> 13165;
13173 -> 13165;
13174 -> 13173;
13174 -> 13165;
13175 -> 13173;
13175 -> 13165;
13176 -> 13173;
13176 -> 13165;
13177 -> 13173;
13177 -> 13165;
13178 -> 13173;
13178 -> 13165;
13179 -> 13173;
13179 -> 13165;
13180 -> 13173;
13180 -> 13165;
13181 -> 13167;
13181 -> 13166;
13181 -> 13165;
13182 -> 13165;
13183 -> 13166;
13183 -> 13173;
13183 -> 13165;
13184 -> 13167;
13184 -> 13173;
13184 -> 13165;
13185 -> 13168;
13185 -> 13173;
13185 -> 13165;
13186 -> 13169;
13186 -> 13173;
13186 -> 13165;
13187 -> 13170;
13187 -> 13173;
13187 -> 13165;
13188 -> 13171;
13188 -> 13173;
13188 -> 13165;
13189 -> 13172;
13189 -> 13173;
13189 -> 13165;
13190 -> 13173;
13190 -> 13189;
13190 -> 0;
13190 -> 13165;
13191 -> 13165;
13192 -> 13171;
13192 -> 13165;
13193 -> 13165;
13195 -> 13194;
13197 -> 13196;
13199 -> 13198;
13201 -> 13200;
13203 -> 13202;
13205 -> 13204;
13206 -> 0;
13208 -> 13195;
13208 -> 13207;
13209 -> 13197;
13209 -> 13207;
13210 -> 13199;
13210 -> 13207;
13211 -> 13201;
13211 -> 13207;
13212 -> 13203;
13212 -> 13207;
13213 -> 13205;
13213 -> 13207;
13214 -> 13206;
13214 -> 13207;
13215 -> 13207;
13216 -> 13215;
13216 -> 13207;
13217 -> 13215;
13217 -> 13207;
13218 -> 13215;
13218 -> 13207;
13219 -> 13215;
13219 -> 13207;
13220 -> 13215;
13220 -> 13207;
13221 -> 13215;
13221 -> 13207;
13222 -> 13215;
13222 -> 13207;
13223 -> 13209;
13223 -> 13208;
13223 -> 13207;
13224 -> 13207;
13225 -> 13208;
13225 -> 13215;
13225 -> 13207;
13226 -> 13209;
13226 -> 13215;
13226 -> 13207;
13227 -> 13210;
13227 -> 13215;
13227 -> 13207;
13228 -> 13211;
13228 -> 13215;
13228 -> 13207;
13229 -> 13212;
13229 -> 13215;
13229 -> 13207;
13230 -> 13213;
13230 -> 13215;
13230 -> 13207;
13231 -> 13214;
13231 -> 13215;
13231 -> 13207;
13232 -> 13215;
13232 -> 13231;
13232 -> 0;
13232 -> 13207;
13233 -> 13207;
13234 -> 13213;
13234 -> 13207;
13235 -> 13207;
13237 -> 13236;
13239 -> 13238;
13241 -> 13240;
13243 -> 13242;
13245 -> 13244;
13247 -> 13246;
13248 -> 0;
13250 -> 13237;
13250 -> 13249;
13251 -> 13239;
13251 -> 13249;
13252 -> 13241;
13252 -> 13249;
13253 -> 13243;
13253 -> 13249;
13254 -> 13245;
13254 -> 13249;
13255 -> 13247;
13255 -> 13249;
13256 -> 13248;
13256 -> 13249;
13257 -> 13249;
13258 -> 13257;
13258 -> 13249;
13259 -> 13257;
13259 -> 13249;
13260 -> 13257;
13260 -> 13249;
13261 -> 13257;
13261 -> 13249;
13262 -> 13257;
13262 -> 13249;
13263 -> 13257;
13263 -> 13249;
13264 -> 13257;
13264 -> 13249;
13265 -> 13251;
13265 -> 13249;
13266 -> 13249;
13267 -> 13250;
13267 -> 13257;
13267 -> 13249;
13268 -> 13251;
13268 -> 13257;
13268 -> 13249;
13269 -> 13252;
13269 -> 13257;
13269 -> 13249;
13270 -> 13253;
13270 -> 13257;
13270 -> 13249;
13271 -> 13254;
13271 -> 13257;
13271 -> 13249;
13272 -> 13255;
13272 -> 13257;
13272 -> 13249;
13273 -> 13256;
13273 -> 13257;
13273 -> 13249;
13274 -> 13257;
13274 -> 13273;
13274 -> 0;
13274 -> 13249;
13275 -> 13249;
13276 -> 13255;
13276 -> 13249;
13277 -> 13249;
13279 -> 13278;
13281 -> 13280;
13283 -> 13282;
13285 -> 13284;
13287 -> 13286;
13289 -> 13288;
13290 -> 0;
13291 -> 13290;
13293 -> 13279;
13293 -> 13292;
13294 -> 13281;
13294 -> 13292;
13295 -> 13283;
13295 -> 13292;
13296 -> 13285;
13296 -> 13292;
13297 -> 13287;
13297 -> 13292;
13298 -> 13289;
13298 -> 13292;
13299 -> 13291;
13299 -> 13292;
13300 -> 13292;
13301 -> 13300;
13301 -> 13292;
13302 -> 13300;
13302 -> 13292;
13303 -> 13300;
13303 -> 13292;
13304 -> 13300;
13304 -> 13292;
13305 -> 13300;
13305 -> 13292;
13306 -> 13300;
13306 -> 13292;
13307 -> 13300;
13307 -> 13292;
13308 -> 13294;
13308 -> 13292;
13309 -> 13292;
13310 -> 13293;
13310 -> 13300;
13310 -> 13292;
13311 -> 13294;
13311 -> 13300;
13311 -> 13292;
13312 -> 13295;
13312 -> 13300;
13312 -> 13292;
13313 -> 13296;
13313 -> 13300;
13313 -> 13292;
13314 -> 13297;
13314 -> 13300;
13314 -> 13292;
13315 -> 13298;
13315 -> 13300;
13315 -> 13292;
13316 -> 13299;
13316 -> 13300;
13316 -> 13292;
13317 -> 13300;
13317 -> 13316;
13317 -> 0;
13317 -> 13292;
13318 -> 13292;
13319 -> 13298;
13319 -> 13292;
13320 -> 13300;
13320 -> 13316;
13320 -> 0;
13320 -> 13319;
13321 -> 13320;
13321 -> 13300;
13321 -> 13319;
13322 -> 13292;
13324 -> 13323;
13326 -> 13325;
13328 -> 13327;
13330 -> 13329;
13332 -> 13331;
13334 -> 13333;
13335 -> 0;
13337 -> 13324;
13337 -> 13336;
13338 -> 13326;
13338 -> 13336;
13339 -> 13328;
13339 -> 13336;
13340 -> 13330;
13340 -> 13336;
13341 -> 13332;
13341 -> 13336;
13342 -> 13334;
13342 -> 13336;
13343 -> 13335;
13343 -> 13336;
13344 -> 13336;
13345 -> 13344;
13345 -> 13336;
13346 -> 13344;
13346 -> 13336;
13347 -> 13344;
13347 -> 13336;
13348 -> 13344;
13348 -> 13336;
13349 -> 13344;
13349 -> 13336;
13350 -> 13344;
13350 -> 13336;
13351 -> 13344;
13351 -> 13336;
13352 -> 13338;
13352 -> 13336;
13353 -> 13336;
13354 -> 13337;
13354 -> 13344;
13354 -> 13336;
13355 -> 13338;
13355 -> 13344;
13355 -> 13336;
13356 -> 13339;
13356 -> 13344;
13356 -> 13336;
13357 -> 13340;
13357 -> 13344;
13357 -> 13336;
13358 -> 13341;
13358 -> 13344;
13358 -> 13336;
13359 -> 13342;
13359 -> 13344;
13359 -> 13336;
13360 -> 13343;
13360 -> 13344;
13360 -> 13336;
13361 -> 13344;
13361 -> 13360;
13361 -> 0;
13361 -> 13336;
13362 -> 13336;
13363 -> 13342;
13363 -> 13336;
13364 -> 13344;
13364 -> 13360;
13364 -> 0;
13364 -> 13363;
13365 -> 13364;
13365 -> 13344;
13365 -> 13363;
13366 -> 13336;
13368 -> 13367;
13370 -> 13369;
13372 -> 13371;
13374 -> 13373;
13376 -> 13375;
13378 -> 13377;
13379 -> 0;
13381 -> 13368;
13381 -> 13380;
13382 -> 13370;
13382 -> 13380;
13383 -> 13372;
13383 -> 13380;
13384 -> 13374;
13384 -> 13380;
13385 -> 13376;
13385 -> 13380;
13386 -> 13378;
13386 -> 13380;
13387 -> 13379;
13387 -> 13380;
13388 -> 13380;
13389 -> 13388;
13389 -> 13380;
13390 -> 13388;
13390 -> 13380;
13391 -> 13388;
13391 -> 13380;
13392 -> 13388;
13392 -> 13380;
13393 -> 13388;
13393 -> 13380;
13394 -> 13388;
13394 -> 13380;
13395 -> 13388;
13395 -> 13380;
13396 -> 13382;
13396 -> 13380;
13397 -> 13380;
13398 -> 13381;
13398 -> 13388;
13398 -> 13380;
13399 -> 13382;
13399 -> 13388;
13399 -> 13380;
13400 -> 13383;
13400 -> 13388;
13400 -> 13380;
13401 -> 13384;
13401 -> 13388;
13401 -> 13380;
13402 -> 13385;
13402 -> 13388;
13402 -> 13380;
13403 -> 13386;
13403 -> 13388;
13403 -> 13380;
13404 -> 13387;
13404 -> 13388;
13404 -> 13380;
13405 -> 13388;
13405 -> 13404;
13405 -> 0;
13405 -> 13380;
13406 -> 13380;
13407 -> 13386;
13407 -> 13380;
13408 -> 13380;
13410 -> 13409;
13412 -> 13411;
13414 -> 13413;
13416 -> 13415;
13418 -> 13417;
13420 -> 13419;
13421 -> 0;
13422 -> 13421;
13422 -> 0;
13423 -> 13422;
13425 -> 13410;
13425 -> 13424;
13426 -> 13412;
13426 -> 13424;
13427 -> 13414;
13427 -> 13424;
13428 -> 13416;
13428 -> 13424;
13429 -> 13418;
13429 -> 13424;
13430 -> 13420;
13430 -> 13424;
13431 -> 13423;
13431 -> 13424;
13432 -> 13424;
13433 -> 13432;
13433 -> 13424;
13434 -> 13432;
13434 -> 13424;
13435 -> 13432;
13435 -> 13424;
13436 -> 13432;
13436 -> 13424;
13437 -> 13432;
13437 -> 13424;
13438 -> 13432;
13438 -> 13424;
13439 -> 13432;
13439 -> 13424;
13440 -> 13426;
13440 -> 13424;
13441 -> 13424;
13442 -> 13425;
13442 -> 13432;
13442 -> 13424;
13443 -> 13426;
13443 -> 13432;
13443 -> 13424;
13444 -> 13427;
13444 -> 13432;
13444 -> 13424;
13445 -> 13428;
13445 -> 13432;
13445 -> 13424;
13446 -> 13429;
13446 -> 13432;
13446 -> 13424;
13447 -> 13430;
13447 -> 13432;
13447 -> 13424;
13448 -> 13431;
13448 -> 13432;
13448 -> 13424;
13449 -> 13432;
13449 -> 13448;
13449 -> 0;
13449 -> 13424;
13450 -> 13424;
13451 -> 13430;
13451 -> 13424;
13452 -> 13424;
13454 -> 13453;
13456 -> 13455;
13458 -> 13457;
13460 -> 13459;
13462 -> 13461;
13464 -> 13463;
13465 -> 0;
13466 -> 13465;
13466 -> 0;
13467 -> 13466;
13469 -> 13454;
13469 -> 13468;
13470 -> 13456;
13470 -> 13468;
13471 -> 13458;
13471 -> 13468;
13472 -> 13460;
13472 -> 13468;
13473 -> 13462;
13473 -> 13468;
13474 -> 13464;
13474 -> 13468;
13475 -> 13467;
13475 -> 13468;
13476 -> 13468;
13477 -> 13476;
13477 -> 13468;
13478 -> 13476;
13478 -> 13468;
13479 -> 13476;
13479 -> 13468;
13480 -> 13476;
13480 -> 13468;
13481 -> 13476;
13481 -> 13468;
13482 -> 13476;
13482 -> 13468;
13483 -> 13476;
13483 -> 13468;
13484 -> 13470;
13484 -> 13468;
13485 -> 13468;
13486 -> 13469;
13486 -> 13476;
13486 -> 13468;
13487 -> 13470;
13487 -> 13476;
13487 -> 13468;
13488 -> 13471;
13488 -> 13476;
13488 -> 13468;
13489 -> 13472;
13489 -> 13476;
13489 -> 13468;
13490 -> 13473;
13490 -> 13476;
13490 -> 13468;
13491 -> 13474;
13491 -> 13476;
13491 -> 13468;
13492 -> 13475;
13492 -> 13476;
13492 -> 13468;
13493 -> 13476;
13493 -> 13492;
13493 -> 0;
13493 -> 13468;
13494 -> 13468;
13495 -> 13474;
13495 -> 13468;
13496 -> 13476;
13496 -> 13492;
13496 -> 0;
13496 -> 13495;
13497 -> 13496;
13497 -> 13476;
13497 -> 13495;
13498 -> 13468;
13500 -> 13499;
13502 -> 13501;
13504 -> 13503;
13506 -> 13505;
13508 -> 13507;
13510 -> 13509;
13511 -> 0;
13512 -> 13511;
13512 -> 0;
13513 -> 13512;
13515 -> 13500;
13515 -> 13514;
13516 -> 13502;
13516 -> 13514;
13517 -> 13504;
13517 -> 13514;
13518 -> 13506;
13518 -> 13514;
13519 -> 13508;
13519 -> 13514;
13520 -> 13510;
13520 -> 13514;
13521 -> 13513;
13521 -> 13514;
13522 -> 13514;
13523 -> 13522;
13523 -> 13514;
13524 -> 13522;
13524 -> 13514;
13525 -> 13522;
13525 -> 13514;
13526 -> 13522;
13526 -> 13514;
13527 -> 13522;
13527 -> 13514;
13528 -> 13522;
13528 -> 13514;
13529 -> 13522;
13529 -> 13514;
13530 -> 13516;
13530 -> 13514;
13531 -> 13514;
13532 -> 13515;
13532 -> 13522;
13532 -> 13514;
13533 -> 13516;
13533 -> 13522;
13533 -> 13514;
13534 -> 13517;
13534 -> 13522;
13534 -> 13514;
13535 -> 13518;
13535 -> 13522;
13535 -> 13514;
13536 -> 13519;
13536 -> 13522;
13536 -> 13514;
13537 -> 13520;
13537 -> 13522;
13537 -> 13514;
13538 -> 13521;
13538 -> 13522;
13538 -> 13514;
13539 -> 13522;
13539 -> 13538;
13539 -> 0;
13539 -> 13514;
13540 -> 13514;
13541 -> 13520;
13541 -> 13514;
13542 -> 13522;
13542 -> 13538;
13542 -> 0;
13542 -> 13541;
13543 -> 13542;
13543 -> 13522;
13543 -> 13541;
13544 -> 13514;
13546 -> 13545;
13548 -> 13547;
13550 -> 13549;
13552 -> 13551;
13554 -> 13553;
13556 -> 13555;
13557 -> 0;
13558 -> 13557;
13558 -> 0;
13559 -> 13558;
13561 -> 13546;
13561 -> 13560;
13562 -> 13548;
13562 -> 13560;
13563 -> 13550;
13563 -> 13560;
13564 -> 13552;
13564 -> 13560;
13565 -> 13554;
13565 -> 13560;
13566 -> 13556;
13566 -> 13560;
13567 -> 13559;
13567 -> 13560;
13568 -> 13560;
13569 -> 13568;
13569 -> 13560;
13570 -> 13568;
13570 -> 13560;
13571 -> 13568;
13571 -> 13560;
13572 -> 13568;
13572 -> 13560;
13573 -> 13568;
13573 -> 13560;
13574 -> 13568;
13574 -> 13560;
13575 -> 13568;
13575 -> 13560;
13576 -> 13562;
13576 -> 13560;
13577 -> 13560;
13578 -> 13561;
13578 -> 13568;
13578 -> 13560;
13579 -> 13562;
13579 -> 13568;
13579 -> 13560;
13580 -> 13563;
13580 -> 13568;
13580 -> 13560;
13581 -> 13564;
13581 -> 13568;
13581 -> 13560;
13582 -> 13565;
13582 -> 13568;
13582 -> 13560;
13583 -> 13566;
13583 -> 13568;
13583 -> 13560;
13584 -> 13567;
13584 -> 13568;
13584 -> 13560;
13585 -> 13568;
13585 -> 13584;
13585 -> 0;
13585 -> 13560;
13586 -> 13560;
13587 -> 13566;
13587 -> 13560;
13588 -> 13560;
13590 -> 13589;
13592 -> 13591;
13594 -> 13593;
13596 -> 13595;
13598 -> 13597;
13600 -> 13599;
13601 -> 0;
13602 -> 13601;
13602 -> 0;
13603 -> 13602;
13605 -> 13590;
13605 -> 13604;
13606 -> 13592;
13606 -> 13604;
13607 -> 13594;
13607 -> 13604;
13608 -> 13596;
13608 -> 13604;
13609 -> 13598;
13609 -> 13604;
13610 -> 13600;
13610 -> 13604;
13611 -> 13603;
13611 -> 13604;
13612 -> 13604;
13613 -> 13612;
13613 -> 13604;
13614 -> 13612;
13614 -> 13604;
13615 -> 13612;
13615 -> 13604;
13616 -> 13612;
13616 -> 13604;
13617 -> 13612;
13617 -> 13604;
13618 -> 13612;
13618 -> 13604;
13619 -> 13612;
13619 -> 13604;
13620 -> 13606;
13620 -> 13605;
13620 -> 13604;
13621 -> 13604;
13622 -> 13605;
13622 -> 13612;
13622 -> 13604;
13623 -> 13606;
13623 -> 13612;
13623 -> 13604;
13624 -> 13607;
13624 -> 13612;
13624 -> 13604;
13625 -> 13608;
13625 -> 13612;
13625 -> 13604;
13626 -> 13609;
13626 -> 13612;
13626 -> 13604;
13627 -> 13610;
13627 -> 13612;
13627 -> 13604;
13628 -> 13611;
13628 -> 13612;
13628 -> 13604;
13629 -> 13612;
13629 -> 13628;
13629 -> 0;
13629 -> 13604;
13630 -> 13604;
13631 -> 13610;
13631 -> 13604;
13632 -> 13612;
13632 -> 13628;
13632 -> 0;
13632 -> 13631;
13633 -> 13632;
13633 -> 13612;
13633 -> 13631;
13634 -> 13604;
13636 -> 13635;
13638 -> 13637;
13640 -> 13639;
13642 -> 13641;
13644 -> 13643;
13646 -> 13645;
13647 -> 0;
13648 -> 13647;
13648 -> 0;
13649 -> 13648;
13651 -> 13636;
13651 -> 13650;
13652 -> 13638;
13652 -> 13650;
13653 -> 13640;
13653 -> 13650;
13654 -> 13642;
13654 -> 13650;
13655 -> 13644;
13655 -> 13650;
13656 -> 13646;
13656 -> 13650;
13657 -> 13649;
13657 -> 13650;
13658 -> 13650;
13659 -> 13658;
13659 -> 13650;
13660 -> 13658;
13660 -> 13650;
13661 -> 13658;
13661 -> 13650;
13662 -> 13658;
13662 -> 13650;
13663 -> 13658;
13663 -> 13650;
13664 -> 13658;
13664 -> 13650;
13665 -> 13658;
13665 -> 13650;
13666 -> 13652;
13666 -> 13651;
13666 -> 13650;
13667 -> 13650;
13668 -> 13651;
13668 -> 13658;
13668 -> 13650;
13669 -> 13652;
13669 -> 13658;
13669 -> 13650;
13670 -> 13653;
13670 -> 13658;
13670 -> 13650;
13671 -> 13654;
13671 -> 13658;
13671 -> 13650;
13672 -> 13655;
13672 -> 13658;
13672 -> 13650;
13673 -> 13656;
13673 -> 13658;
13673 -> 13650;
13674 -> 13657;
13674 -> 13658;
13674 -> 13650;
13675 -> 13658;
13675 -> 13674;
13675 -> 0;
13675 -> 13650;
13676 -> 13650;
13677 -> 13656;
13677 -> 13650;
13678 -> 13650;
13680 -> 13679;
13682 -> 13681;
13684 -> 13683;
13686 -> 13685;
13688 -> 13687;
13690 -> 13689;
13691 -> 0;
13692 -> 13691;
13692 -> 0;
13693 -> 13692;
13695 -> 13680;
13695 -> 13694;
13696 -> 13682;
13696 -> 13694;
13697 -> 13684;
13697 -> 13694;
13698 -> 13686;
13698 -> 13694;
13699 -> 13688;
13699 -> 13694;
13700 -> 13690;
13700 -> 13694;
13701 -> 13693;
13701 -> 13694;
13702 -> 13694;
13703 -> 13702;
13703 -> 13694;
13704 -> 13702;
13704 -> 13694;
13705 -> 13702;
13705 -> 13694;
13706 -> 13702;
13706 -> 13694;
13707 -> 13702;
13707 -> 13694;
13708 -> 13702;
13708 -> 13694;
13709 -> 13702;
13709 -> 13694;
13710 -> 13696;
13710 -> 13694;
13711 -> 13694;
13712 -> 13695;
13712 -> 13702;
13712 -> 13694;
13713 -> 13696;
13713 -> 13702;
13713 -> 13694;
13714 -> 13697;
13714 -> 13702;
13714 -> 13694;
13715 -> 13698;
13715 -> 13702;
13715 -> 13694;
13716 -> 13699;
13716 -> 13702;
13716 -> 13694;
13717 -> 13700;
13717 -> 13702;
13717 -> 13694;
13718 -> 13701;
13718 -> 13702;
13718 -> 13694;
13719 -> 13702;
13719 -> 13718;
13719 -> 0;
13719 -> 13694;
13720 -> 13694;
13721 -> 13700;
13721 -> 13694;
13722 -> 13694;
13724 -> 13723;
13726 -> 13725;
13728 -> 13727;
13730 -> 13729;
13732 -> 13731;
13734 -> 13733;
13735 -> 0;
13736 -> 13735;
13736 -> 0;
13737 -> 13736;
13739 -> 13724;
13739 -> 13738;
13740 -> 13726;
13740 -> 13738;
13741 -> 13728;
13741 -> 13738;
13742 -> 13730;
13742 -> 13738;
13743 -> 13732;
13743 -> 13738;
13744 -> 13734;
13744 -> 13738;
13745 -> 13737;
13745 -> 13738;
13746 -> 13738;
13747 -> 13746;
13747 -> 13738;
13748 -> 13746;
13748 -> 13738;
13749 -> 13746;
13749 -> 13738;
13750 -> 13746;
13750 -> 13738;
13751 -> 13746;
13751 -> 13738;
13752 -> 13746;
13752 -> 13738;
13753 -> 13746;
13753 -> 13738;
13754 -> 13740;
13754 -> 13738;
13755 -> 13738;
13756 -> 13739;
13756 -> 13746;
13756 -> 13738;
13757 -> 13740;
13757 -> 13746;
13757 -> 13738;
13758 -> 13741;
13758 -> 13746;
13758 -> 13738;
13759 -> 13742;
13759 -> 13746;
13759 -> 13738;
13760 -> 13743;
13760 -> 13746;
13760 -> 13738;
13761 -> 13744;
13761 -> 13746;
13761 -> 13738;
13762 -> 13745;
13762 -> 13746;
13762 -> 13738;
13763 -> 13746;
13763 -> 13762;
13763 -> 0;
13763 -> 13738;
13764 -> 13738;
13765 -> 13744;
13765 -> 13738;
13766 -> 13738;
13767 -> 13193;
13768 -> 13767;
13768 -> 13183;
13768 -> 13184;
13768 -> 13185;
13768 -> 13186;
13768 -> 13187;
13768 -> 13188;
13768 -> 13189;
13769 -> 13768;
13770 -> 0;
13771 -> 13770;
13772 -> 13771;
13773 -> 0;
13774 -> 13773;
13775 -> 0;
13776 -> 13775;
13777 -> 12977;
13777 -> 12976;
13778 -> 12978;
13778 -> 12976;
13779 -> 12979;
13779 -> 12976;
13780 -> 12980;
13780 -> 12976;
13781 -> 12976;
13782 -> 13777;
13782 -> 13781;
13783 -> 13778;
13783 -> 13781;
13784 -> 13779;
13784 -> 13781;
13785 -> 13780;
13785 -> 13781;
13786 -> 12981;
13786 -> 13781;
13787 -> 13785;
13787 -> 13781;
13788 -> 13781;
13789 -> 13787;
13789 -> 13788;
13790 -> 13786;
13790 -> 13788;
13791 -> 13786;
13791 -> 13781;
13792 -> 13786;
13792 -> 13781;
13793 -> 13786;
13793 -> 13781;
13795 -> 13794;
13796 -> 13795;
13796 -> 13794;
13797 -> 13795;
13797 -> 13794;
13798 -> 13795;
13798 -> 13794;
13799 -> 13795;
13799 -> 13794;
13800 -> 13795;
13800 -> 13794;
13801 -> 13795;
13801 -> 13794;
13802 -> 13794;
13803 -> 13802;
13803 -> 13786;
13803 -> 13781;
13804 -> 13786;
13804 -> 13781;
13805 -> 13786;
13805 -> 13781;
13806 -> 13786;
13806 -> 13781;
13807 -> 13786;
13807 -> 13781;
13808 -> 13786;
13808 -> 13781;
13809 -> 2980;
13809 -> 13786;
13809 -> 13781;
13810 -> 13786;
13810 -> 13781;
13811 -> 13786;
13811 -> 13781;
13812 -> 13782;
13812 -> 13786;
13812 -> 13781;
13813 -> 13783;
13813 -> 13786;
13813 -> 13781;
13814 -> 13783;
13814 -> 12955;
13814 -> 13781;
13815 -> 13781;
13816 -> 13814;
13816 -> 13815;
13817 -> 13816;
13817 -> 13815;
13818 -> 0;
13818 -> 13817;
13819 -> 13818;
13819 -> 13781;
13820 -> 13784;
13820 -> 13781;
13821 -> 13781;
13822 -> 13819;
13822 -> 13821;
13823 -> 13820;
13823 -> 13821;
13824 -> 13786;
13824 -> 13821;
13825 -> 13821;
13826 -> 13824;
13826 -> 13825;
13827 -> 13826;
13827 -> 13812;
13827 -> 13825;
13828 -> 13827;
13828 -> 13821;
13829 -> 13821;
13830 -> 0;
13830 -> 13821;
13831 -> 13821;
13832 -> 13828;
13832 -> 13831;
13833 -> 13831;
13833 -> 13821;
13834 -> 0;
13834 -> 13833;
13835 -> 13822;
13835 -> 13821;
13836 -> 0;
13836 -> 13835;
13837 -> 13830;
13837 -> 13836;
13837 -> 13835;
13838 -> 13821;
13839 -> 13834;
13839 -> 13821;
13840 -> 13837;
13840 -> 13821;
13841 -> 13823;
13841 -> 13821;
13842 -> 13838;
13842 -> 13821;
13843 -> 13821;
13844 -> 13839;
13844 -> 13843;
13845 -> 13840;
13845 -> 13843;
13846 -> 13841;
13846 -> 13843;
13847 -> 13842;
13847 -> 13843;
13848 -> 13824;
13848 -> 13843;
13849 -> 13843;
13850 -> 0;
13850 -> 13843;
13851 -> 13848;
13851 -> 13813;
13851 -> 12955;
13851 -> 13843;
13852 -> 13843;
13853 -> 13843;
13854 -> 13853;
13854 -> 13851;
13854 -> 13843;
13855 -> 13848;
13855 -> 13813;
13855 -> 12955;
13855 -> 13853;
13855 -> 13854;
13856 -> 13855;
13856 -> 13854;
13857 -> 13854;
13858 -> 13849;
13858 -> 13854;
13859 -> 13856;
13859 -> 13858;
13860 -> 13845;
13860 -> 13858;
13861 -> 13848;
13861 -> 13813;
13861 -> 13855;
13861 -> 13853;
13861 -> 13858;
13862 -> 13846;
13862 -> 13858;
13863 -> 13858;
13864 -> 13849;
13864 -> 13858;
13865 -> 13858;
13866 -> 13859;
13866 -> 13865;
13867 -> 13860;
13867 -> 13865;
13868 -> 13861;
13868 -> 13865;
13869 -> 13862;
13869 -> 13865;
13870 -> 13863;
13870 -> 13865;
13871 -> 13864;
13871 -> 13865;
13872 -> 13865;
13873 -> 13866;
13873 -> 13867;
13873 -> 13865;
13874 -> 13866;
13874 -> 13867;
13874 -> 13865;
13875 -> 13873;
13875 -> 0;
13875 -> 13865;
13876 -> 13874;
13876 -> 0;
13876 -> 13865;
13877 -> 13865;
13878 -> 13874;
13878 -> 13865;
13879 -> 13872;
13879 -> 13858;
13880 -> 13878;
13880 -> 13879;
13881 -> 13848;
13881 -> 13879;
13882 -> 13879;
13883 -> 13879;
13884 -> 13880;
13884 -> 13883;
13885 -> 13881;
13885 -> 13883;
13886 -> 13882;
13886 -> 13883;
13887 -> 13884;
13887 -> 13883;
13888 -> 13883;
13889 -> 13887;
13889 -> 13888;
13890 -> 13889;
13890 -> 0;
13890 -> 13888;
13891 -> 13890;
13892 -> 13883;
13893 -> 13885;
13893 -> 13892;
13894 -> 13892;
13894 -> 13883;
13895 -> 13886;
13895 -> 13894;
13895 -> 13883;
13896 -> 13884;
13896 -> 0;
13896 -> 13883;
13897 -> 13883;
13898 -> 13895;
13898 -> 13896;
13898 -> 13883;
13899 -> 13884;
13899 -> 0;
13899 -> 13898;
13900 -> 13883;
13901 -> 13900;
13901 -> 13879;
13902 -> 13879;
13903 -> 13901;
13903 -> 13902;
13903 -> 13879;
13904 -> 13850;
13904 -> 0;
13904 -> 13854;
13905 -> 13878;
13905 -> 13904;
13906 -> 13905;
13906 -> 0;
13906 -> 13843;
13907 -> 13843;
13908 -> 13852;
13908 -> 13843;
13909 -> 13843;
13910 -> 13848;
13910 -> 13909;
13911 -> 13910;
13911 -> 13813;
13911 -> 13861;
13911 -> 13909;
13912 -> 13911;
13912 -> 13843;
13913 -> 0;
13913 -> 13843;
13914 -> 13905;
13914 -> 13843;
13915 -> 13824;
13915 -> 13821;
13916 -> 13914;
13916 -> 13821;
13917 -> 13823;
13917 -> 13821;
13918 -> 13821;
13919 -> 13915;
13919 -> 13918;
13920 -> 13916;
13920 -> 13918;
13921 -> 13917;
13921 -> 13918;
13922 -> 13919;
13922 -> 13918;
13923 -> 13920;
13923 -> 13918;
13924 -> 13918;
13925 -> 13919;
13925 -> 13924;
13926 -> 13925;
13926 -> 13813;
13926 -> 13861;
13926 -> 13924;
13927 -> 13926;
13927 -> 13918;
13928 -> 13918;
13929 -> 13921;
13929 -> 13918;
13930 -> 13918;
13931 -> 13922;
13931 -> 13930;
13932 -> 13923;
13932 -> 13930;
13933 -> 13927;
13933 -> 13930;
13934 -> 13929;
13934 -> 13930;
13935 -> 13932;
13935 -> 0;
13935 -> 13930;
13936 -> 13821;
13937 -> 13914;
13937 -> 0;
13937 -> 13821;
13938 -> 13821;
13939 -> 13872;
13939 -> 13937;
13939 -> 13821;
13940 -> 0;
13940 -> 13821;
13941 -> 13914;
13941 -> 13940;
13941 -> 13821;
13942 -> 13872;
13942 -> 13941;
13942 -> 13821;
13943 -> 13822;
13943 -> 13821;
13944 -> 13914;
13944 -> 0;
13944 -> 13943;
13945 -> 13944;
13945 -> 13821;
13946 -> 13783;
13946 -> 13927;
13946 -> 13781;
13947 -> 13946;
13947 -> 13927;
13948 -> 13784;
13948 -> 13947;
13948 -> 12955;
13948 -> 13927;
13948 -> 13946;
13949 -> 13945;
13949 -> 0;
13949 -> 13781;
13950 -> 13781;
13951 -> 13949;
13951 -> 13950;
13951 -> 13781;
13952 -> 13945;
13952 -> 13786;
13952 -> 13781;
13953 -> 13949;
13953 -> 0;
13953 -> 13781;
13954 -> 13953;
13954 -> 13781;
13955 -> 13954;
13956 -> 13786;
13956 -> 13955;
13957 -> 13955;
13958 -> 13956;
13958 -> 13957;
13959 -> 13958;
13959 -> 13812;
13959 -> 13957;
13960 -> 13959;
13960 -> 13955;
13961 -> 13955;
13962 -> 13960;
13962 -> 13961;
13963 -> 13961;
13963 -> 13955;
13964 -> 13955;
13965 -> 13956;
13965 -> 13964;
13966 -> 13965;
13966 -> 13812;
13966 -> 13964;
13967 -> 13966;
13967 -> 13955;
13968 -> 13955;
13969 -> 13967;
13969 -> 13968;
13970 -> 13968;
13971 -> 13969;
13971 -> 13948;
13971 -> 13970;
13972 -> 13955;
13973 -> 13971;
13973 -> 13972;
13974 -> 13963;
13974 -> 13973;
13974 -> 13955;
13975 -> 0;
13975 -> 13974;
13977 -> 13976;
13979 -> 13978;
13980 -> 13977;
13980 -> 13979;
13981 -> 13980;
13983 -> 13982;
13984 -> 13981;
13984 -> 13983;
13985 -> 13984;
13987 -> 13986;
13988 -> 13985;
13988 -> 13987;
13989 -> 13988;
13991 -> 13990;
13992 -> 13989;
13992 -> 13991;
13993 -> 13992;
13995 -> 13994;
13996 -> 13993;
13996 -> 13995;
13997 -> 13996;
13999 -> 13998;
14001 -> 14000;
14001 -> 13979;
14003 -> 14001;
14003 -> 14002;
14004 -> 14003;
14006 -> 14005;
14006 -> 13983;
14008 -> 14006;
14008 -> 14007;
14009 -> 14008;
14011 -> 14010;
14011 -> 13995;
14013 -> 14011;
14013 -> 14012;
14014 -> 14013;
14016 -> 14015;
14016 -> 13999;
14018 -> 14016;
14018 -> 14017;
14019 -> 14018;
14021 -> 14020;
14021 -> 13985;
14022 -> 14021;
14024 -> 14023;
14024 -> 13989;
14025 -> 14024;
14026 -> 14004;
14027 -> 14019;
14028 -> 13975;
14028 -> 13781;
14029 -> 13818;
14029 -> 13781;
14030 -> 13781;
14031 -> 13781;
14032 -> 14028;
14032 -> 14031;
14033 -> 14029;
14033 -> 14031;
14034 -> 14030;
14034 -> 14031;
14035 -> 14032;
14035 -> 14004;
14035 -> 14031;
14036 -> 14035;
14036 -> 13977;
14036 -> 14031;
14037 -> 14033;
14037 -> 14014;
14037 -> 14031;
14038 -> 14037;
14038 -> 13993;
14038 -> 14031;
14039 -> 14036;
14039 -> 14038;
14039 -> 14031;
14040 -> 14039;
14040 -> 14034;
14040 -> 14031;
14041 -> 14030;
14041 -> 13786;
14041 -> 13781;
14042 -> 13781;
14043 -> 13786;
14043 -> 14042;
14044 -> 14043;
14044 -> 13812;
14044 -> 14042;
14045 -> 14044;
14045 -> 13781;
14046 -> 14045;
14046 -> 13781;
14047 -> 13781;
14048 -> 0;
14048 -> 13781;
14049 -> 13781;
14050 -> 14048;
14050 -> 14049;
14051 -> 13786;
14051 -> 14049;
14052 -> 14051;
14052 -> 14050;
14052 -> 14049;
14053 -> 12981;
14053 -> 12976;
14054 -> 12981;
14054 -> 12976;
14055 -> 12981;
14055 -> 12976;
14056 -> 0;
14056 -> 12981;
14056 -> 12976;
14057 -> 12981;
14057 -> 12976;
14058 -> 3414;
14058 -> 12981;
14058 -> 12976;
14059 -> 12981;
14059 -> 12976;
14060 -> 3414;
14060 -> 12981;
14060 -> 12976;
14061 -> 12978;
14061 -> 13948;
14061 -> 12976;
14062 -> 12976;
14063 -> 12977;
14063 -> 14062;
14064 -> 14062;
14064 -> 12976;
14065 -> 12975;
14065 -> 12955;
14066 -> 14065;
14066 -> 13813;
14066 -> 13948;
14066 -> 12955;
14067 -> 12955;
14067 -> 13948;
14068 -> 14067;
14068 -> 13948;
14069 -> 13948;
14070 -> 14068;
14070 -> 13948;
14071 -> 14069;
14071 -> 13948;
14072 -> 14070;
14072 -> 13948;
14073 -> 14071;
14073 -> 13948;
14074 -> 14073;
14074 -> 13948;
14075 -> 13948;
14076 -> 13948;
14077 -> 13948;
14078 -> 13948;
14079 -> 13802;
14079 -> 13948;
14080 -> 13948;
14081 -> 13948;
14082 -> 13948;
14083 -> 13948;
14084 -> 13948;
14085 -> 2980;
14085 -> 13948;
14086 -> 13948;
14087 -> 13948;
14088 -> 14072;
14088 -> 13948;
14089 -> 13948;
14090 -> 13948;
14091 -> 14089;
14091 -> 14090;
14092 -> 14091;
14092 -> 14090;
14093 -> 0;
14093 -> 14092;
14094 -> 14093;
14094 -> 13948;
14095 -> 13948;
14096 -> 14094;
14096 -> 13948;
14097 -> 14095;
14097 -> 13948;
14098 -> 13948;
14099 -> 13948;
14099 -> 14098;
14100 -> 14099;
14100 -> 14088;
14100 -> 14098;
14101 -> 14100;
14101 -> 13948;
14102 -> 13948;
14103 -> 0;
14103 -> 13948;
14104 -> 13948;
14105 -> 14101;
14105 -> 14104;
14106 -> 14104;
14106 -> 13948;
14107 -> 0;
14107 -> 14106;
14108 -> 14096;
14108 -> 13948;
14109 -> 0;
14109 -> 14108;
14110 -> 14103;
14110 -> 14109;
14110 -> 14108;
14111 -> 13948;
14112 -> 14107;
14112 -> 13948;
14113 -> 14110;
14113 -> 13948;
14114 -> 14097;
14114 -> 13948;
14115 -> 14111;
14115 -> 13948;
14116 -> 14112;
14116 -> 13948;
14117 -> 14113;
14117 -> 13948;
14118 -> 14114;
14118 -> 13948;
14119 -> 14115;
14119 -> 13948;
14120 -> 0;
14120 -> 13948;
14121 -> 13948;
14122 -> 13948;
14123 -> 13948;
14124 -> 13948;
14125 -> 14122;
14125 -> 14124;
14126 -> 14117;
14126 -> 14124;
14127 -> 14122;
14127 -> 14124;
14128 -> 14118;
14128 -> 14124;
14129 -> 14122;
14129 -> 14124;
14130 -> 14122;
14130 -> 14124;
14131 -> 14124;
14132 -> 14125;
14132 -> 14126;
14132 -> 14124;
14133 -> 14125;
14133 -> 14126;
14133 -> 14124;
14134 -> 14132;
14134 -> 0;
14134 -> 14124;
14135 -> 14133;
14135 -> 0;
14135 -> 14124;
14136 -> 14124;
14137 -> 14133;
14137 -> 14124;
14138 -> 14131;
14138 -> 13948;
14139 -> 14137;
14139 -> 14138;
14140 -> 13948;
14140 -> 14138;
14141 -> 14138;
14142 -> 14138;
14143 -> 14139;
14143 -> 14142;
14144 -> 14140;
14144 -> 14142;
14145 -> 14141;
14145 -> 14142;
14146 -> 14143;
14146 -> 14142;
14147 -> 14142;
14148 -> 14146;
14148 -> 14147;
14149 -> 14148;
14149 -> 0;
14149 -> 14147;
14150 -> 14149;
14151 -> 14142;
14152 -> 14144;
14152 -> 14151;
14153 -> 14151;
14153 -> 14142;
14154 -> 14145;
14154 -> 14153;
14154 -> 14142;
14155 -> 14143;
14155 -> 0;
14155 -> 14142;
14156 -> 14142;
14157 -> 14154;
14157 -> 14155;
14157 -> 14142;
14158 -> 14143;
14158 -> 0;
14158 -> 14157;
14159 -> 14142;
14160 -> 14159;
14160 -> 14138;
14161 -> 14138;
14162 -> 14160;
14162 -> 14161;
14162 -> 14138;
14163 -> 14120;
14163 -> 0;
14163 -> 13948;
14164 -> 14137;
14164 -> 14163;
14165 -> 14164;
14165 -> 0;
14165 -> 13948;
14166 -> 13948;
14167 -> 14121;
14167 -> 13948;
14168 -> 13948;
14169 -> 13948;
14169 -> 14168;
14170 -> 14169;
14170 -> 13948;
14170 -> 14122;
14170 -> 14168;
14171 -> 14170;
14171 -> 13948;
14172 -> 0;
14172 -> 13948;
14173 -> 14164;
14173 -> 13948;
14174 -> 14173;
14174 -> 13948;
14175 -> 14097;
14175 -> 13948;
14176 -> 13948;
14177 -> 13948;
14177 -> 14176;
14178 -> 14174;
14178 -> 14176;
14179 -> 14122;
14179 -> 14176;
14180 -> 14175;
14180 -> 14176;
14181 -> 14178;
14181 -> 0;
14181 -> 14176;
14182 -> 14173;
14182 -> 0;
14182 -> 13948;
14183 -> 13948;
14184 -> 14131;
14184 -> 14182;
14184 -> 13948;
14185 -> 0;
14185 -> 13948;
14186 -> 14173;
14186 -> 14185;
14186 -> 13948;
14187 -> 14131;
14187 -> 14186;
14187 -> 13948;
14188 -> 14096;
14188 -> 13948;
14189 -> 14173;
14189 -> 0;
14189 -> 14188;
14190 -> 14189;
14190 -> 13948;
14191 -> 14190;
14191 -> 0;
14191 -> 13948;
14192 -> 13948;
14193 -> 14191;
14193 -> 14192;
14193 -> 13948;
14194 -> 14190;
14194 -> 13948;
14195 -> 14191;
14195 -> 0;
14195 -> 13948;
14196 -> 14195;
14196 -> 13948;
14197 -> 14196;
14198 -> 13948;
14198 -> 14197;
14199 -> 14197;
14200 -> 14198;
14200 -> 14199;
14201 -> 14200;
14201 -> 14088;
14201 -> 14199;
14202 -> 14201;
14202 -> 14197;
14203 -> 14197;
14204 -> 14202;
14204 -> 14203;
14205 -> 14203;
14205 -> 14197;
14206 -> 14197;
14207 -> 14198;
14207 -> 14206;
14208 -> 14207;
14208 -> 14088;
14208 -> 14206;
14209 -> 14208;
14209 -> 14197;
14210 -> 14197;
14211 -> 14209;
14211 -> 14210;
14212 -> 14210;
14213 -> 14211;
14213 -> 14122;
14213 -> 14212;
14214 -> 14197;
14215 -> 14213;
14215 -> 14214;
14216 -> 14205;
14216 -> 14215;
14216 -> 14197;
14217 -> 0;
14217 -> 14216;
14218 -> 14217;
14218 -> 13948;
14219 -> 14093;
14219 -> 13948;
14220 -> 13948;
14221 -> 13948;
14222 -> 14218;
14222 -> 14221;
14223 -> 14219;
14223 -> 14221;
14224 -> 14220;
14224 -> 14221;
14225 -> 14222;
14225 -> 14004;
14225 -> 14221;
14226 -> 14225;
14226 -> 13977;
14226 -> 14221;
14227 -> 14223;
14227 -> 14014;
14227 -> 14221;
14228 -> 14227;
14228 -> 13993;
14228 -> 14221;
14229 -> 14226;
14229 -> 14228;
14229 -> 14221;
14230 -> 14229;
14230 -> 14224;
14230 -> 14221;
14231 -> 14220;
14231 -> 13948;
14232 -> 13948;
14233 -> 13948;
14233 -> 14232;
14234 -> 14233;
14234 -> 14088;
14234 -> 14232;
14235 -> 14234;
14235 -> 13948;
14236 -> 14235;
14236 -> 13948;
14237 -> 13948;
14238 -> 0;
14238 -> 13948;
14239 -> 13948;
14240 -> 14238;
14240 -> 14239;
14241 -> 13948;
14242 -> 13948;
14243 -> 13948;
14244 -> 0;
14244 -> 13948;
14245 -> 13948;
14246 -> 3414;
14246 -> 13948;
14247 -> 13948;
14248 -> 3414;
14248 -> 13948;
14249 -> 13948;
14249 -> 14122;
14250 -> 13948;
14251 -> 14068;
14251 -> 14250;
14252 -> 14250;
14252 -> 13948;
14253 -> 13948;
14254 -> 14253;
14254 -> 13948;
14254 -> 14122;
14255 -> 12955;
14255 -> 14122;
14256 -> 14255;
14256 -> 14122;
14257 -> 14122;
14258 -> 14256;
14258 -> 14122;
14259 -> 14257;
14259 -> 14122;
14260 -> 14258;
14260 -> 14122;
14261 -> 14259;
14261 -> 14122;
14262 -> 14261;
14262 -> 14122;
14263 -> 14122;
14264 -> 14122;
14265 -> 14122;
14266 -> 14122;
14267 -> 13802;
14267 -> 14122;
14268 -> 14122;
14269 -> 14122;
14270 -> 14122;
14271 -> 14122;
14272 -> 14122;
14273 -> 2980;
14273 -> 14122;
14274 -> 14122;
14275 -> 14122;
14276 -> 14260;
14276 -> 14122;
14277 -> 14122;
14278 -> 14122;
14279 -> 14277;
14279 -> 14278;
14280 -> 14279;
14280 -> 14278;
14281 -> 0;
14281 -> 14280;
14282 -> 14281;
14282 -> 14122;
14283 -> 14122;
14284 -> 14282;
14284 -> 14122;
14285 -> 14283;
14285 -> 14122;
14286 -> 14122;
14287 -> 14122;
14287 -> 14286;
14288 -> 14287;
14288 -> 14276;
14288 -> 14286;
14289 -> 14288;
14289 -> 14122;
14290 -> 14122;
14291 -> 0;
14291 -> 14122;
14292 -> 14122;
14293 -> 14289;
14293 -> 14292;
14294 -> 14292;
14294 -> 14122;
14295 -> 0;
14295 -> 14294;
14296 -> 14284;
14296 -> 14122;
14297 -> 0;
14297 -> 14296;
14298 -> 14291;
14298 -> 14297;
14298 -> 14296;
14299 -> 14296;
14300 -> 14122;
14300 -> 14299;
14301 -> 14299;
14302 -> 14300;
14302 -> 14122;
14302 -> 14301;
14302 -> 14299;
14303 -> 14302;
14303 -> 14296;
14304 -> 14298;
14304 -> 0;
14304 -> 14303;
14305 -> 14122;
14306 -> 14295;
14306 -> 14122;
14307 -> 14304;
14307 -> 14122;
14308 -> 14285;
14308 -> 14122;
14309 -> 14305;
14309 -> 14122;
14310 -> 14306;
14310 -> 14122;
14311 -> 14307;
14311 -> 14122;
14312 -> 14308;
14312 -> 14122;
14313 -> 14309;
14313 -> 14122;
14314 -> 0;
14314 -> 14122;
14315 -> 14122;
14316 -> 14302;
14317 -> 14312;
14317 -> 14302;
14318 -> 14302;
14319 -> 14302;
14319 -> 14318;
14320 -> 14311;
14320 -> 14318;
14321 -> 14302;
14321 -> 14318;
14322 -> 14317;
14322 -> 14318;
14323 -> 14302;
14323 -> 14318;
14324 -> 14302;
14324 -> 14318;
14325 -> 14318;
14326 -> 14319;
14326 -> 14320;
14326 -> 14318;
14327 -> 14319;
14327 -> 14320;
14327 -> 14318;
14328 -> 14326;
14328 -> 0;
14328 -> 14318;
14329 -> 14327;
14329 -> 0;
14329 -> 14318;
14330 -> 14318;
14331 -> 14327;
14331 -> 14318;
14332 -> 14325;
14332 -> 14302;
14333 -> 14331;
14333 -> 14332;
14334 -> 14122;
14334 -> 14332;
14335 -> 14332;
14336 -> 14332;
14337 -> 14333;
14337 -> 14336;
14338 -> 14334;
14338 -> 14336;
14339 -> 14335;
14339 -> 14336;
14340 -> 14337;
14340 -> 14336;
14341 -> 14336;
14342 -> 14340;
14342 -> 14341;
14343 -> 14342;
14343 -> 0;
14343 -> 14341;
14344 -> 14343;
14345 -> 14336;
14346 -> 14338;
14346 -> 14345;
14347 -> 14345;
14347 -> 14336;
14348 -> 14339;
14348 -> 14347;
14348 -> 14336;
14349 -> 14337;
14349 -> 0;
14349 -> 14336;
14350 -> 14336;
14351 -> 14348;
14351 -> 14349;
14351 -> 14336;
14352 -> 14337;
14352 -> 0;
14352 -> 14351;
14353 -> 14336;
14354 -> 14353;
14354 -> 14332;
14355 -> 14332;
14356 -> 14354;
14356 -> 14355;
14356 -> 14332;
14357 -> 14314;
14357 -> 0;
14357 -> 14302;
14358 -> 14331;
14358 -> 14357;
14359 -> 14358;
14359 -> 0;
14359 -> 14122;
14360 -> 14122;
14361 -> 14315;
14361 -> 14122;
14362 -> 14122;
14363 -> 14122;
14363 -> 14362;
14364 -> 14363;
14364 -> 14122;
14364 -> 14302;
14364 -> 14362;
14365 -> 14364;
14365 -> 14122;
14366 -> 0;
14366 -> 14122;
14367 -> 14358;
14367 -> 14122;
14368 -> 14367;
14368 -> 14122;
14369 -> 14285;
14369 -> 14122;
14370 -> 14122;
14371 -> 14122;
14371 -> 14370;
14372 -> 14368;
14372 -> 14370;
14373 -> 14302;
14373 -> 14370;
14374 -> 14369;
14374 -> 14370;
14375 -> 14372;
14375 -> 0;
14375 -> 14370;
14376 -> 14367;
14376 -> 0;
14376 -> 14122;
14377 -> 14122;
14378 -> 14325;
14378 -> 14376;
14378 -> 14122;
14379 -> 0;
14379 -> 14122;
14380 -> 14367;
14380 -> 14379;
14380 -> 14122;
14381 -> 14325;
14381 -> 14380;
14381 -> 14122;
14382 -> 14284;
14382 -> 14122;
14383 -> 14367;
14383 -> 14122;
14384 -> 14383;
14384 -> 0;
14384 -> 14122;
14385 -> 14122;
14386 -> 14384;
14386 -> 14385;
14386 -> 14122;
14387 -> 14383;
14387 -> 14122;
14388 -> 14384;
14388 -> 0;
14388 -> 14122;
14389 -> 14388;
14389 -> 14122;
14390 -> 14389;
14391 -> 14122;
14391 -> 14390;
14392 -> 14390;
14393 -> 14391;
14393 -> 14392;
14394 -> 14393;
14394 -> 14276;
14394 -> 14392;
14395 -> 14394;
14395 -> 14390;
14396 -> 14390;
14397 -> 14395;
14397 -> 14396;
14398 -> 14396;
14398 -> 14390;
14399 -> 14390;
14400 -> 14391;
14400 -> 14399;
14401 -> 14400;
14401 -> 14276;
14401 -> 14399;
14402 -> 14401;
14402 -> 14390;
14403 -> 14390;
14404 -> 14402;
14404 -> 14403;
14405 -> 14403;
14406 -> 14404;
14406 -> 14302;
14406 -> 14405;
14407 -> 14390;
14408 -> 14406;
14408 -> 14407;
14409 -> 14398;
14409 -> 14408;
14409 -> 14390;
14410 -> 0;
14410 -> 14409;
14411 -> 14410;
14411 -> 14122;
14412 -> 14281;
14412 -> 14122;
14413 -> 14122;
14414 -> 14122;
14415 -> 14411;
14415 -> 14414;
14416 -> 14412;
14416 -> 14414;
14417 -> 14413;
14417 -> 14414;
14418 -> 14415;
14418 -> 14004;
14418 -> 14414;
14419 -> 14418;
14419 -> 13977;
14419 -> 14414;
14420 -> 14416;
14420 -> 14014;
14420 -> 14414;
14421 -> 14420;
14421 -> 13993;
14421 -> 14414;
14422 -> 14419;
14422 -> 14421;
14422 -> 14414;
14423 -> 14422;
14423 -> 14417;
14423 -> 14414;
14424 -> 14413;
14424 -> 14122;
14425 -> 14122;
14426 -> 14122;
14426 -> 14425;
14427 -> 14426;
14427 -> 14276;
14427 -> 14425;
14428 -> 14427;
14428 -> 14122;
14429 -> 14428;
14429 -> 14122;
14430 -> 14122;
14431 -> 0;
14431 -> 14122;
14432 -> 14122;
14433 -> 14431;
14433 -> 14432;
14434 -> 14122;
14435 -> 14122;
14436 -> 14122;
14437 -> 0;
14437 -> 14122;
14438 -> 14122;
14439 -> 3414;
14439 -> 14122;
14440 -> 14122;
14441 -> 3414;
14441 -> 14122;
14442 -> 14122;
14442 -> 14302;
14443 -> 14122;
14444 -> 14256;
14444 -> 14443;
14445 -> 14443;
14445 -> 14122;
14446 -> 14122;
14447 -> 14446;
14447 -> 14122;
14447 -> 14302;
14448 -> 12955;
14448 -> 14302;
14449 -> 14448;
14449 -> 14302;
14450 -> 14302;
14451 -> 14449;
14451 -> 14302;
14452 -> 14450;
14452 -> 14302;
14453 -> 14451;
14453 -> 14302;
14454 -> 14452;
14454 -> 14302;
14455 -> 14454;
14455 -> 14302;
14456 -> 14302;
14457 -> 14302;
14458 -> 14302;
14459 -> 14302;
14460 -> 13802;
14460 -> 14302;
14461 -> 14302;
14462 -> 14302;
14463 -> 14302;
14464 -> 14302;
14465 -> 14302;
14466 -> 2980;
14466 -> 14302;
14467 -> 14302;
14468 -> 14302;
14469 -> 14453;
14469 -> 14302;
14470 -> 14302;
14471 -> 14302;
14472 -> 14302;
14472 -> 14471;
14473 -> 14472;
14473 -> 14469;
14473 -> 14471;
14474 -> 14473;
14474 -> 14302;
14475 -> 14302;
14476 -> 0;
14476 -> 14302;
14477 -> 14302;
14478 -> 14474;
14478 -> 14477;
14479 -> 14477;
14479 -> 14302;
14480 -> 0;
14480 -> 14479;
14481 -> 0;
14481 -> 14302;
14482 -> 14476;
14482 -> 14481;
14482 -> 14302;
14483 -> 14302;
14484 -> 14482;
14484 -> 0;
14484 -> 14483;
14485 -> 14302;
14486 -> 14480;
14486 -> 14302;
14487 -> 14484;
14487 -> 14302;
14488 -> 14470;
14488 -> 14302;
14489 -> 14485;
14489 -> 14302;
14490 -> 14486;
14490 -> 14302;
14491 -> 14487;
14491 -> 14302;
14492 -> 14488;
14492 -> 14302;
14493 -> 14489;
14493 -> 14302;
14494 -> 0;
14494 -> 14302;
14495 -> 14302;
14496 -> 14491;
14496 -> 14318;
14497 -> 14492;
14497 -> 14318;
14498 -> 14319;
14498 -> 14496;
14498 -> 14318;
14499 -> 14319;
14499 -> 14496;
14499 -> 14318;
14500 -> 14498;
14500 -> 0;
14500 -> 14318;
14501 -> 14499;
14501 -> 0;
14501 -> 14318;
14502 -> 14499;
14502 -> 14318;
14503 -> 14502;
14503 -> 14332;
14504 -> 14302;
14504 -> 14332;
14505 -> 14503;
14505 -> 14336;
14506 -> 14504;
14506 -> 14336;
14507 -> 14505;
14507 -> 14336;
14508 -> 14507;
14508 -> 14341;
14509 -> 14508;
14509 -> 0;
14509 -> 14341;
14510 -> 14509;
14511 -> 14506;
14511 -> 14345;
14512 -> 14505;
14512 -> 0;
14512 -> 14336;
14513 -> 14348;
14513 -> 14512;
14513 -> 14336;
14514 -> 14505;
14514 -> 0;
14514 -> 14513;
14515 -> 14494;
14515 -> 0;
14515 -> 14302;
14516 -> 14502;
14516 -> 14515;
14517 -> 14516;
14517 -> 0;
14517 -> 14302;
14518 -> 14302;
14519 -> 14495;
14519 -> 14302;
14520 -> 14302;
14521 -> 14302;
14521 -> 14520;
14522 -> 14521;
14522 -> 14302;
14522 -> 14520;
14523 -> 14522;
14523 -> 14302;
14524 -> 0;
14524 -> 14302;
14525 -> 14516;
14525 -> 14302;
14526 -> 14525;
14526 -> 14302;
14527 -> 14470;
14527 -> 14302;
14528 -> 14302;
14529 -> 14302;
14529 -> 14528;
14530 -> 14526;
14530 -> 14528;
14531 -> 14302;
14531 -> 14528;
14532 -> 14527;
14532 -> 14528;
14533 -> 14530;
14533 -> 0;
14533 -> 14528;
14534 -> 14525;
14534 -> 0;
14534 -> 14302;
14535 -> 14302;
14536 -> 14325;
14536 -> 14534;
14536 -> 14302;
14537 -> 0;
14537 -> 14302;
14538 -> 14525;
14538 -> 14537;
14538 -> 14302;
14539 -> 14325;
14539 -> 14538;
14539 -> 14302;
14540 -> 14302;
14541 -> 14525;
14541 -> 14302;
14542 -> 14541;
14542 -> 0;
14542 -> 14302;
14543 -> 14302;
14544 -> 14542;
14544 -> 14543;
14544 -> 14302;
14545 -> 14541;
14545 -> 14302;
14546 -> 14542;
14546 -> 0;
14546 -> 14302;
14547 -> 14546;
14547 -> 14302;
14548 -> 14547;
14549 -> 14302;
14549 -> 14548;
14550 -> 14548;
14551 -> 14549;
14551 -> 14550;
14552 -> 14551;
14552 -> 14469;
14552 -> 14550;
14553 -> 14552;
14553 -> 14548;
14554 -> 14548;
14555 -> 14553;
14555 -> 14554;
14556 -> 14554;
14556 -> 14548;
14557 -> 14548;
14558 -> 14549;
14558 -> 14557;
14559 -> 14558;
14559 -> 14469;
14559 -> 14557;
14560 -> 14559;
14560 -> 14548;
14561 -> 14548;
14562 -> 14560;
14562 -> 14561;
14563 -> 14561;
14564 -> 14562;
14564 -> 14302;
14564 -> 14563;
14565 -> 14548;
14566 -> 14564;
14566 -> 14565;
14567 -> 14556;
14567 -> 14566;
14567 -> 14548;
14568 -> 0;
14568 -> 14567;
14569 -> 14568;
14569 -> 14302;
14570 -> 14302;
14571 -> 14302;
14572 -> 14569;
14572 -> 14571;
14573 -> 14570;
14573 -> 14571;
14574 -> 14570;
14574 -> 14571;
14575 -> 14572;
14575 -> 14004;
14575 -> 14571;
14576 -> 14575;
14576 -> 13977;
14576 -> 14571;
14577 -> 14573;
14577 -> 14014;
14577 -> 14571;
14578 -> 14577;
14578 -> 13993;
14578 -> 14571;
14579 -> 14576;
14579 -> 14578;
14579 -> 14571;
14580 -> 14579;
14580 -> 14574;
14580 -> 14571;
14581 -> 14570;
14581 -> 14302;
14582 -> 14302;
14583 -> 14302;
14583 -> 14582;
14584 -> 14583;
14584 -> 14469;
14584 -> 14582;
14585 -> 14584;
14585 -> 14302;
14586 -> 14585;
14586 -> 14302;
14587 -> 14302;
14588 -> 0;
14588 -> 14302;
14589 -> 14302;
14590 -> 14588;
14590 -> 14589;
14591 -> 14302;
14592 -> 14302;
14593 -> 14302;
14594 -> 0;
14594 -> 14302;
14595 -> 14302;
14596 -> 3414;
14596 -> 14302;
14597 -> 14302;
14598 -> 3414;
14598 -> 14302;
14599 -> 14302;
14600 -> 14302;
14601 -> 14449;
14601 -> 14600;
14602 -> 14600;
14602 -> 14302;
14603 -> 14302;
14604 -> 14603;
14604 -> 14302;
14605 -> 14447;
14606 -> 14605;
14606 -> 14447;
14607 -> 14447;
14608 -> 12955;
14609 -> 12955;
14610 -> 12955;
14611 -> 12955;
14612 -> 12955;
14613 -> 14608;
14613 -> 14612;
14614 -> 14612;
14615 -> 14613;
14615 -> 14302;
14615 -> 14614;
14616 -> 14615;
14616 -> 12955;
14617 -> 12955;
14618 -> 14616;
14618 -> 14617;
14619 -> 12955;
14620 -> 14610;
14620 -> 14447;
14621 -> 14447;
14622 -> 14447;
14623 -> 14447;
14624 -> 14622;
14624 -> 14623;
14624 -> 14447;
14625 -> 14624;
14625 -> 14447;
14626 -> 14625;
14627 -> 14622;
14627 -> 14626;
14628 -> 14627;
14628 -> 14447;
14628 -> 14626;
14629 -> 14628;
14629 -> 14610;
14629 -> 14620;
14629 -> 14447;
14630 -> 14610;
14630 -> 14620;
14630 -> 14628;
14630 -> 14447;
14631 -> 14447;
14632 -> 14630;
14632 -> 14631;
14632 -> 14447;
14633 -> 14611;
14633 -> 14631;
14633 -> 14447;
14634 -> 14632;
14634 -> 14633;
14634 -> 14447;
14635 -> 14447;
14636 -> 14630;
14636 -> 14635;
14636 -> 14447;
14637 -> 14447;
14637 -> 14628;
14637 -> 14610;
14638 -> 14447;
14639 -> 14622;
14639 -> 14638;
14639 -> 14447;
14640 -> 14639;
14641 -> 14622;
14641 -> 14640;
14642 -> 14641;
14642 -> 14447;
14642 -> 14640;
14643 -> 14640;
14644 -> 14642;
14644 -> 14643;
14645 -> 14644;
14645 -> 0;
14645 -> 14643;
14646 -> 0;
14646 -> 14645;
14647 -> 14646;
14647 -> 14639;
14648 -> 14647;
14648 -> 0;
14648 -> 14639;
14649 -> 14610;
14649 -> 14620;
14649 -> 14637;
14649 -> 14447;
14650 -> 14649;
14650 -> 14610;
14651 -> 14610;
14651 -> 14649;
14652 -> 14649;
14653 -> 14651;
14653 -> 14652;
14653 -> 14649;
14654 -> 14611;
14654 -> 14652;
14654 -> 14649;
14655 -> 14653;
14655 -> 14654;
14655 -> 14649;
14656 -> 14649;
14657 -> 14651;
14657 -> 14656;
14657 -> 14649;
14658 -> 14649;
14659 -> 14658;
14660 -> 14649;
14660 -> 14659;
14661 -> 14660;
14661 -> 14649;
14661 -> 14659;
14662 -> 14659;
14663 -> 14661;
14663 -> 14662;
14664 -> 14663;
14664 -> 0;
14664 -> 14662;
14665 -> 0;
14665 -> 14664;
14666 -> 14665;
14666 -> 14658;
14667 -> 14666;
14667 -> 0;
14667 -> 14658;
14668 -> 14649;
14669 -> 14649;
14669 -> 14668;
14670 -> 14668;
14670 -> 14649;
14671 -> 14649;
14672 -> 14649;
14673 -> 12955;
14673 -> 14672;
14674 -> 14672;
14675 -> 14673;
14675 -> 14674;
14676 -> 14674;
14677 -> 14675;
14677 -> 14649;
14677 -> 14676;
14678 -> 14677;
14678 -> 14672;
14679 -> 14672;
14680 -> 14678;
14680 -> 14679;
14681 -> 14680;
14681 -> 14672;
14682 -> 14649;
14683 -> 14649;
14684 -> 12969;
14684 -> 14649;
14684 -> 12968;
14684 -> 12967;
14685 -> 14684;
14686 -> 14649;
14686 -> 12956;
14687 -> 14686;
14687 -> 12958;
14688 -> 14687;
14688 -> 12960;
14688 -> 12958;
14689 -> 12956;
14690 -> 14649;
14691 -> 0;
14691 -> 14690;
14692 -> 14690;
14693 -> 14691;
14693 -> 14692;
14694 -> 14691;
14694 -> 14692;
14695 -> 14694;
14695 -> 14692;
14696 -> 14693;
14696 -> 14694;
14696 -> 14692;
14697 -> 14693;
14697 -> 14692;
14698 -> 14692;
14699 -> 14697;
14699 -> 14698;
14700 -> 14694;
14700 -> 14698;
14701 -> 14699;
14701 -> 14698;
14702 -> 14698;
14703 -> 14698;
14704 -> 14701;
14704 -> 14703;
14705 -> 14702;
14705 -> 14703;
14706 -> 14700;
14706 -> 14703;
14707 -> 14704;
14707 -> 14703;
14708 -> 14704;
14708 -> 14703;
14709 -> 14705;
14709 -> 14703;
14710 -> 14706;
14710 -> 14703;
14711 -> 14708;
14711 -> 14703;
14712 -> 14708;
14712 -> 14711;
14713 -> 14709;
14713 -> 14711;
14714 -> 14711;
14715 -> 14712;
14715 -> 14714;
14716 -> 14713;
14716 -> 14714;
14717 -> 14710;
14717 -> 14714;
14718 -> 14715;
14718 -> 14717;
14718 -> 14714;
14719 -> 14714;
14720 -> 14715;
14720 -> 14719;
14720 -> 14714;
14721 -> 14716;
14721 -> 0;
14721 -> 14714;
14722 -> 14714;
14723 -> 14715;
14723 -> 14714;
14724 -> 14714;
14725 -> 14723;
14725 -> 14724;
14725 -> 14714;
14726 -> 14714;
14727 -> 14717;
14727 -> 14726;
14728 -> 14727;
14728 -> 14714;
14729 -> 14714;
14730 -> 14723;
14730 -> 14729;
14731 -> 14730;
14731 -> 14714;
14732 -> 14717;
14732 -> 14728;
14732 -> 14714;
14733 -> 14723;
14733 -> 14731;
14733 -> 14714;
14734 -> 14732;
14734 -> 14733;
14734 -> 14714;
14735 -> 14734;
14736 -> 14691;
14736 -> 14692;
14737 -> 14692;
14738 -> 14736;
14738 -> 14735;
14738 -> 14737;
14739 -> 14738;
14739 -> 14735;
14739 -> 14737;
14740 -> 14737;
14741 -> 14739;
14741 -> 14692;
14742 -> 14741;
14743 -> 14742;
14744 -> 14742;
14744 -> 14743;
14745 -> 14743;
14745 -> 14742;
14746 -> 14742;
14747 -> 14746;
14747 -> 14735;
14747 -> 14742;
14748 -> 14747;
14748 -> 14741;
14749 -> 14741;
14750 -> 14748;
14750 -> 14749;
14751 -> 14748;
14751 -> 14749;
14752 -> 14748;
14752 -> 14749;
14753 -> 14750;
14753 -> 14748;
14753 -> 14749;
14754 -> 14750;
14754 -> 14748;
14754 -> 14749;
14755 -> 14751;
14755 -> 14749;
14756 -> 14749;
14757 -> 14753;
14757 -> 14756;
14758 -> 14754;
14758 -> 14756;
14759 -> 14755;
14759 -> 14756;
14760 -> 14752;
14760 -> 14756;
14761 -> 14756;
14762 -> 14757;
14762 -> 14761;
14762 -> 14756;
14763 -> 14757;
14763 -> 14762;
14764 -> 14762;
14765 -> 14763;
14765 -> 14764;
14766 -> 14759;
14766 -> 14764;
14767 -> 14765;
14767 -> 14764;
14768 -> 14764;
14769 -> 14767;
14769 -> 14768;
14770 -> 14766;
14770 -> 14768;
14771 -> 14768;
14772 -> 14769;
14772 -> 14771;
14772 -> 14768;
14773 -> 14770;
14773 -> 14748;
14773 -> 14768;
14774 -> 14769;
14774 -> 14768;
14775 -> 14773;
14775 -> 14774;
14775 -> 14768;
14776 -> 14766;
14776 -> 14775;
14776 -> 14764;
14777 -> 14758;
14777 -> 14756;
14778 -> 14776;
14778 -> 14756;
14779 -> 14777;
14779 -> 14756;
14780 -> 14760;
14780 -> 14756;
14781 -> 14756;
14782 -> 14779;
14782 -> 14781;
14782 -> 14756;
14783 -> 14756;
14784 -> 14778;
14784 -> 14783;
14784 -> 14756;
14785 -> 14778;
14785 -> 14780;
14785 -> 14756;
14786 -> 14779;
14786 -> 14780;
14786 -> 14756;
14787 -> 14748;
14787 -> 14776;
14787 -> 14785;
14787 -> 14786;
14787 -> 14741;
14788 -> 14741;
14789 -> 14787;
14789 -> 14788;
14790 -> 14736;
14790 -> 14787;
14790 -> 14788;
14791 -> 14788;
14792 -> 14789;
14792 -> 14791;
14793 -> 14792;
14793 -> 14788;
14794 -> 14789;
14794 -> 14787;
14794 -> 14790;
14794 -> 14788;
14795 -> 14790;
14795 -> 14787;
14795 -> 14788;
14796 -> 14789;
14796 -> 14787;
14796 -> 14792;
14796 -> 14788;
14797 -> 14795;
14797 -> 14796;
14797 -> 14788;
14798 -> 14736;
14798 -> 14787;
14798 -> 14692;
14799 -> 14691;
14799 -> 14798;
14799 -> 14787;
14799 -> 14794;
14799 -> 14797;
14799 -> 14690;
14800 -> 14799;
14801 -> 14799;
14801 -> 14800;
14802 -> 14800;
14802 -> 14799;
14803 -> 14799;
14804 -> 14799;
14805 -> 14799;
14806 -> 14692;
14807 -> 14691;
14807 -> 14806;
14808 -> 14806;
14808 -> 14692;
14809 -> 14691;
14809 -> 14692;
14810 -> 14691;
14810 -> 14692;
14811 -> 14691;
14811 -> 14692;
14812 -> 14692;
14813 -> 14692;
14814 -> 14810;
14814 -> 14813;
14815 -> 14814;
14815 -> 14799;
14815 -> 14813;
14816 -> 14815;
14816 -> 14692;
14817 -> 14692;
14818 -> 14811;
14818 -> 14817;
14819 -> 14818;
14819 -> 14799;
14819 -> 14817;
14820 -> 14819;
14820 -> 14692;
14821 -> 14816;
14821 -> 14820;
14821 -> 14692;
14822 -> 14692;
14823 -> 14810;
14823 -> 14822;
14824 -> 14823;
14824 -> 14799;
14824 -> 14822;
14825 -> 14824;
14825 -> 14692;
14826 -> 14692;
14827 -> 14811;
14827 -> 14826;
14828 -> 14827;
14828 -> 14799;
14828 -> 14826;
14829 -> 14828;
14829 -> 14692;
14830 -> 14825;
14830 -> 14829;
14830 -> 14692;
14831 -> 14814;
14831 -> 14830;
14831 -> 14813;
14832 -> 14831;
14832 -> 14692;
14833 -> 14818;
14833 -> 14830;
14833 -> 14817;
14834 -> 14833;
14834 -> 14692;
14835 -> 14832;
14835 -> 14834;
14835 -> 14692;
14836 -> 14830;
14837 -> 14830;
14837 -> 14836;
14838 -> 14836;
14838 -> 14830;
14839 -> 14830;
14840 -> 14830;
14841 -> 14830;
14842 -> 12955;
14842 -> 14830;
14842 -> 14690;
14843 -> 14830;
14843 -> 14690;
14844 -> 12956;
14845 -> 12955;
14845 -> 14844;
14846 -> 0;
14846 -> 14844;
14847 -> 14846;
14847 -> 12956;
14848 -> 12956;
14849 -> 12956;
14850 -> 12955;
14851 -> 12955;
14851 -> 14850;
14852 -> 12955;
14852 -> 14850;
14853 -> 12955;
14853 -> 14850;
14854 -> 14850;
14855 -> 14852;
14855 -> 14842;
14855 -> 14854;
14856 -> 14854;
14857 -> 14853;
14857 -> 14855;
14857 -> 14856;
14858 -> 14857;
14858 -> 14856;
14859 -> 14856;
14860 -> 14858;
14860 -> 14859;
14861 -> 14859;
14862 -> 14860;
14862 -> 14861;
14862 -> 14859;
14863 -> 14856;
14864 -> 14857;
14864 -> 14854;
14865 -> 14864;
14865 -> 14854;
14866 -> 14865;
14867 -> 14853;
14867 -> 14866;
14868 -> 14866;
14869 -> 14867;
14869 -> 14868;
14870 -> 14869;
14870 -> 14855;
14870 -> 14868;
14871 -> 14868;
14872 -> 14870;
14872 -> 14871;
14872 -> 14868;
14873 -> 14868;
14874 -> 14869;
14874 -> 14873;
14875 -> 14874;
14875 -> 14855;
14875 -> 14873;
14876 -> 14875;
14876 -> 14868;
14877 -> 14868;
14878 -> 14868;
14879 -> 14876;
14879 -> 14878;
14880 -> 14876;
14880 -> 14878;
14881 -> 14877;
14881 -> 14878;
14882 -> 14877;
14882 -> 14878;
14883 -> 14877;
14883 -> 14878;
14884 -> 14877;
14884 -> 14878;
14885 -> 14869;
14885 -> 14878;
14886 -> 14878;
14887 -> 14885;
14887 -> 14886;
14888 -> 14886;
14889 -> 14887;
14889 -> 14888;
14890 -> 14888;
14890 -> 14886;
14891 -> 14887;
14891 -> 14876;
14891 -> 14886;
14892 -> 14891;
14892 -> 14878;
14893 -> 14878;
14894 -> 14893;
14894 -> 14878;
14895 -> 14879;
14895 -> 14878;
14896 -> 14881;
14896 -> 14878;
14897 -> 14878;
14898 -> 14892;
14898 -> 14878;
14899 -> 14884;
14899 -> 14878;
14900 -> 14883;
14900 -> 14878;
14901 -> 14893;
14901 -> 14878;
14902 -> 14885;
14902 -> 14878;
14903 -> 14902;
14903 -> 14878;
14904 -> 14878;
14905 -> 14878;
14906 -> 14878;
14907 -> 14906;
14907 -> 14895;
14907 -> 14876;
14907 -> 14878;
14908 -> 0;
14908 -> 14878;
14909 -> 14893;
14909 -> 0;
14909 -> 14878;
14910 -> 14878;
14911 -> 14910;
14911 -> 14878;
14912 -> 14878;
14913 -> 14882;
14913 -> 14893;
14914 -> 14913;
14915 -> 14880;
14915 -> 14913;
14916 -> 14913;
14917 -> 14885;
14917 -> 14916;
14918 -> 14913;
14919 -> 14913;
14919 -> 14878;
14920 -> 14893;
14920 -> 14878;
14921 -> 14878;
14922 -> 14881;
14922 -> 14878;
14923 -> 14914;
14923 -> 14878;
14924 -> 14878;
14925 -> 14919;
14925 -> 14924;
14926 -> 14920;
14926 -> 14924;
14927 -> 14921;
14927 -> 14924;
14928 -> 14922;
14928 -> 14924;
14929 -> 14923;
14929 -> 14924;
14930 -> 14885;
14930 -> 14924;
14931 -> 14925;
14931 -> 0;
14931 -> 14924;
14932 -> 14926;
14932 -> 0;
14932 -> 14924;
14933 -> 14925;
14933 -> 0;
14933 -> 14926;
14933 -> 14924;
14934 -> 14924;
14935 -> 14930;
14935 -> 14915;
14935 -> 14934;
14935 -> 14924;
14936 -> 14930;
14936 -> 14915;
14936 -> 14924;
14937 -> 14928;
14937 -> 0;
14937 -> 14924;
14938 -> 14929;
14938 -> 14924;
14939 -> 14924;
14940 -> 14930;
14940 -> 14939;
14941 -> 14939;
14942 -> 14940;
14942 -> 14941;
14943 -> 14942;
14943 -> 14915;
14943 -> 14941;
14944 -> 14941;
14945 -> 14943;
14945 -> 14944;
14945 -> 14941;
14946 -> 14943;
14946 -> 14915;
14946 -> 14941;
14947 -> 14946;
14947 -> 14939;
14948 -> 14939;
14949 -> 14947;
14949 -> 14948;
14949 -> 14939;
14950 -> 14949;
14950 -> 14924;
14951 -> 14950;
14952 -> 14930;
14952 -> 14951;
14953 -> 14951;
14954 -> 14952;
14954 -> 14953;
14955 -> 14954;
14955 -> 14915;
14955 -> 14953;
14956 -> 14953;
14957 -> 14955;
14957 -> 14956;
14957 -> 14953;
14958 -> 14955;
14958 -> 14915;
14958 -> 14953;
14959 -> 14958;
14959 -> 14951;
14960 -> 14951;
14961 -> 14959;
14961 -> 14960;
14961 -> 14951;
14962 -> 14961;
14962 -> 14951;
14963 -> 14962;
14963 -> 14950;
14964 -> 14950;
14965 -> 14924;
14966 -> 14938;
14966 -> 14965;
14966 -> 14924;
14967 -> 14925;
14967 -> 14924;
14968 -> 14926;
14968 -> 14924;
14969 -> 14927;
14969 -> 14924;
14970 -> 14928;
14970 -> 14924;
14971 -> 14929;
14971 -> 14924;
14972 -> 14924;
14973 -> 14967;
14973 -> 14972;
14974 -> 14968;
14974 -> 14972;
14975 -> 14969;
14975 -> 14972;
14976 -> 14970;
14976 -> 14972;
14977 -> 14971;
14977 -> 14972;
14978 -> 14930;
14978 -> 14972;
14979 -> 14924;
14980 -> 14878;
14981 -> 14884;
14981 -> 14915;
14982 -> 14913;
14982 -> 14981;
14983 -> 14981;
14984 -> 14982;
14984 -> 14983;
14985 -> 14885;
14985 -> 14983;
14986 -> 14984;
14986 -> 14983;
14987 -> 14981;
14988 -> 14878;
14988 -> 14981;
14989 -> 14981;
14990 -> 14988;
14990 -> 14989;
14991 -> 14885;
14991 -> 14989;
14992 -> 14989;
14993 -> 14991;
14993 -> 14992;
14994 -> 14993;
14994 -> 14989;
14995 -> 14990;
14995 -> 14878;
14995 -> 14989;
14996 -> 14981;
14997 -> 14915;
14997 -> 14878;
14998 -> 14878;
14999 -> 0;
14999 -> 14915;
15000 -> 14915;
15001 -> 14999;
15001 -> 15000;
15002 -> 15001;
15002 -> 14915;
15003 -> 14869;
15003 -> 14915;
15003 -> 15001;
15003 -> 14868;
15004 -> 14869;
15004 -> 14915;
15004 -> 14868;
15005 -> 15004;
15005 -> 14866;
15006 -> 15005;
15006 -> 14865;
15007 -> 14864;
15007 -> 14854;
15008 -> 14852;
15008 -> 14854;
15009 -> 14854;
15010 -> 15007;
15010 -> 15009;
15011 -> 15008;
15011 -> 15009;
15012 -> 14853;
15012 -> 14915;
15012 -> 15009;
15013 -> 15010;
15013 -> 15009;
15014 -> 15009;
15015 -> 15013;
15015 -> 15014;
15016 -> 15012;
15016 -> 15014;
15017 -> 15016;
15017 -> 14915;
15017 -> 15001;
15017 -> 15015;
15017 -> 15014;
15018 -> 15017;
15019 -> 14854;
15020 -> 15001;
15020 -> 14856;
15021 -> 15020;
15021 -> 14859;
15022 -> 15021;
15022 -> 14861;
15022 -> 14859;
15023 -> 15001;
15023 -> 0;
15024 -> 15001;
15025 -> 0;
15025 -> 15001;
15026 -> 15001;
15027 -> 15025;
15027 -> 15026;
15028 -> 15001;
15028 -> 14854;
15029 -> 15028;
15029 -> 15009;
15030 -> 14853;
15030 -> 15001;
15030 -> 15009;
15031 -> 15029;
15031 -> 15009;
15032 -> 15031;
15032 -> 15014;
15033 -> 15030;
15033 -> 15014;
15034 -> 15033;
15034 -> 15001;
15034 -> 15027;
15034 -> 15032;
15034 -> 15014;
15035 -> 15034;
15036 -> 15027;
15036 -> 14856;
15037 -> 15036;
15037 -> 14859;
15038 -> 15037;
15038 -> 14861;
15038 -> 14859;
15039 -> 0;
15039 -> 15027;
15040 -> 15027;
15041 -> 15039;
15041 -> 15040;
15042 -> 15041;
15043 -> 15042;
15043 -> 15041;
15044 -> 15041;
15045 -> 15043;
15045 -> 15044;
15046 -> 14853;
15046 -> 15044;
15047 -> 15044;
15048 -> 15046;
15048 -> 15047;
15049 -> 15048;
15049 -> 15027;
15049 -> 15047;
15050 -> 3414;
15050 -> 15047;
15051 -> 15049;
15052 -> 15048;
15052 -> 15051;
15053 -> 15052;
15053 -> 15027;
15053 -> 15051;
15054 -> 15053;
15054 -> 15049;
15055 -> 15049;
15056 -> 15049;
15057 -> 15056;
15057 -> 15049;
15058 -> 15049;
15059 -> 15057;
15059 -> 15058;
15060 -> 15048;
15060 -> 15058;
15061 -> 15058;
15062 -> 15060;
15062 -> 15061;
15063 -> 15061;
15064 -> 15062;
15064 -> 15027;
15064 -> 15063;
15065 -> 15064;
15065 -> 15027;
15065 -> 13993;
15065 -> 15063;
15066 -> 15065;
15066 -> 14014;
15066 -> 15063;
15067 -> 15066;
15067 -> 15061;
15068 -> 15067;
15068 -> 15058;
15069 -> 15058;
15070 -> 15060;
15070 -> 15069;
15071 -> 15069;
15072 -> 15070;
15072 -> 15071;
15073 -> 15071;
15073 -> 15069;
15074 -> 15070;
15074 -> 15058;
15075 -> 15058;
15076 -> 15068;
15076 -> 0;
15076 -> 15058;
15077 -> 15076;
15078 -> 15076;
15079 -> 15077;
15079 -> 15078;
15080 -> 15060;
15080 -> 15078;
15081 -> 15079;
15081 -> 15078;
15082 -> 15078;
15083 -> 15081;
15083 -> 15082;
15084 -> 15080;
15084 -> 15082;
15085 -> 15084;
15085 -> 15027;
15085 -> 15082;
15086 -> 15082;
15087 -> 15085;
15088 -> 15084;
15088 -> 15027;
15088 -> 15085;
15089 -> 15083;
15089 -> 15085;
15090 -> 15087;
15090 -> 15085;
15091 -> 15085;
15092 -> 15089;
15092 -> 15091;
15093 -> 15090;
15093 -> 15091;
15094 -> 15084;
15094 -> 15091;
15095 -> 15091;
15096 -> 15094;
15096 -> 15095;
15097 -> 15096;
15097 -> 15091;
15098 -> 15091;
15099 -> 15091;
15100 -> 15092;
15100 -> 15099;
15100 -> 15091;
15101 -> 15092;
15101 -> 15091;
15102 -> 15091;
15103 -> 15094;
15103 -> 15102;
15104 -> 15103;
15104 -> 15091;
15105 -> 15101;
15105 -> 15104;
15105 -> 15027;
15105 -> 15041;
15105 -> 15091;
15106 -> 15091;
15107 -> 15091;
15108 -> 15091;
15109 -> 15091;
15110 -> 0;
15110 -> 15109;
15111 -> 15109;
15112 -> 15110;
15112 -> 15111;
15112 -> 15109;
15113 -> 15110;
15113 -> 15109;
15114 -> 15113;
15114 -> 15091;
15115 -> 15094;
15115 -> 15105;
15115 -> 15091;
15116 -> 15105;
15116 -> 15115;
15117 -> 15115;
15118 -> 15093;
15118 -> 15115;
15119 -> 15115;
15120 -> 15116;
15120 -> 15119;
15121 -> 15117;
15121 -> 15119;
15122 -> 15118;
15122 -> 15119;
15123 -> 15094;
15123 -> 15119;
15124 -> 15121;
15124 -> 15119;
15125 -> 15119;
15126 -> 15124;
15126 -> 15125;
15127 -> 15126;
15127 -> 15105;
15127 -> 15125;
15128 -> 15125;
15129 -> 15128;
15129 -> 15119;
15130 -> 15119;
15131 -> 15129;
15131 -> 15130;
15131 -> 15119;
15132 -> 15131;
15133 -> 15132;
15133 -> 15115;
15134 -> 15115;
15135 -> 15133;
15135 -> 15134;
15135 -> 15115;
15136 -> 15115;
15137 -> 15094;
15137 -> 15105;
15137 -> 0;
15137 -> 15115;
15138 -> 15115;
15139 -> 15107;
15139 -> 15138;
15139 -> 15115;
15140 -> 15106;
15140 -> 15115;
15141 -> 15115;
15142 -> 15094;
15142 -> 15141;
15143 -> 15142;
15143 -> 15105;
15143 -> 15141;
15144 -> 15141;
15145 -> 15143;
15145 -> 15144;
15146 -> 15145;
15146 -> 0;
15146 -> 15144;
15147 -> 0;
15147 -> 15146;
15148 -> 15147;
15148 -> 15115;
15149 -> 15115;
15150 -> 15094;
15150 -> 15149;
15151 -> 15149;
15152 -> 15150;
15152 -> 15151;
15153 -> 15152;
15153 -> 15149;
15154 -> 15153;
15154 -> 15115;
15155 -> 15148;
15155 -> 15154;
15155 -> 15115;
15156 -> 15140;
15156 -> 15155;
15157 -> 15114;
15157 -> 15110;
15157 -> 15115;
15158 -> 15093;
15158 -> 15115;
15159 -> 15115;
15160 -> 15159;
15160 -> 15115;
15161 -> 15115;
15162 -> 15136;
15162 -> 15115;
15163 -> 15158;
15163 -> 15160;
15163 -> 15162;
15163 -> 15087;
15163 -> 15115;
15164 -> 15107;
15164 -> 15115;
15165 -> 15140;
15165 -> 15115;
15166 -> 15164;
15166 -> 15165;
15166 -> 15140;
15166 -> 15106;
15166 -> 15115;
15167 -> 15085;
15168 -> 15088;
15168 -> 15166;
15168 -> 15167;
15168 -> 15163;
15168 -> 15085;
15169 -> 15087;
15169 -> 15168;
15170 -> 15168;
15171 -> 15169;
15171 -> 15170;
15172 -> 15084;
15172 -> 15170;
15173 -> 15170;
15174 -> 15172;
15174 -> 15173;
15175 -> 15174;
15175 -> 15170;
15176 -> 15171;
15176 -> 15168;
15176 -> 15170;
15177 -> 15168;
15178 -> 15087;
15178 -> 15168;
15178 -> 15085;
15179 -> 15084;
15179 -> 15178;
15179 -> 15082;
15180 -> 15058;
15181 -> 15179;
15181 -> 15180;
15181 -> 15058;
15182 -> 15068;
15182 -> 15181;
15183 -> 15182;
15184 -> 15183;
15184 -> 15049;
15185 -> 15048;
15185 -> 15178;
15185 -> 15049;
15186 -> 15184;
15186 -> 15049;
15187 -> 3414;
15187 -> 15049;
15188 -> 15056;
15188 -> 15186;
15189 -> 15186;
15190 -> 15188;
15190 -> 15189;
15191 -> 15048;
15191 -> 15189;
15192 -> 15189;
15193 -> 15191;
15193 -> 15192;
15194 -> 15193;
15194 -> 15189;
15195 -> 15190;
15195 -> 15056;
15195 -> 15189;
15196 -> 15186;
15197 -> 15056;
15197 -> 15049;
15198 -> 15048;
15198 -> 15186;
15198 -> 15047;
15199 -> 15198;
15199 -> 15044;
15200 -> 15044;
15201 -> 15199;
15201 -> 15200;
15201 -> 15044;
15202 -> 15201;
15203 -> 15041;
15204 -> 15042;
15204 -> 15041;
15205 -> 15041;
15206 -> 15204;
15206 -> 15205;
15207 -> 14853;
15207 -> 15205;
15208 -> 15205;
15209 -> 15207;
15209 -> 15208;
15210 -> 15209;
15210 -> 15186;
15210 -> 15208;
15211 -> 15210;
15211 -> 15205;
15212 -> 15206;
15212 -> 15042;
15212 -> 15205;
15213 -> 15041;
15214 -> 0;
15214 -> 15041;
15215 -> 15041;
15216 -> 15214;
15216 -> 15215;
15217 -> 14853;
15217 -> 15186;
15217 -> 15215;
15218 -> 15217;
15218 -> 15216;
15218 -> 15215;
15219 -> 15042;
15219 -> 15041;
15220 -> 15027;
15220 -> 14854;
15221 -> 15220;
15221 -> 15009;
15222 -> 14853;
15222 -> 15186;
15222 -> 15009;
15223 -> 15221;
15223 -> 15009;
15224 -> 15223;
15224 -> 15014;
15225 -> 15222;
15225 -> 15014;
15226 -> 15225;
15226 -> 15186;
15226 -> 15218;
15226 -> 15224;
15226 -> 15014;
15227 -> 15226;
15228 -> 15218;
15228 -> 14856;
15229 -> 15228;
15229 -> 14859;
15230 -> 15229;
15230 -> 14861;
15230 -> 14859;
15231 -> 0;
15231 -> 15218;
15232 -> 15218;
15233 -> 15231;
15233 -> 15232;
15234 -> 15233;
15235 -> 15234;
15235 -> 15233;
15236 -> 15233;
15237 -> 15235;
15237 -> 15236;
15238 -> 14853;
15238 -> 15236;
15239 -> 15236;
15240 -> 15238;
15240 -> 15239;
15241 -> 15239;
15242 -> 15240;
15242 -> 15241;
15243 -> 15242;
15243 -> 15218;
15243 -> 15241;
15244 -> 15241;
15245 -> 15243;
15245 -> 15244;
15245 -> 15241;
15246 -> 15242;
15246 -> 15241;
15247 -> 15241;
15248 -> 15246;
15249 -> 15248;
15249 -> 15246;
15250 -> 15249;
15250 -> 15246;
15251 -> 15250;
15252 -> 15250;
15252 -> 15251;
15253 -> 15246;
15253 -> 15251;
15254 -> 15253;
15254 -> 15218;
15254 -> 15233;
15254 -> 15251;
15255 -> 15254;
15256 -> 15252;
15256 -> 15255;
15256 -> 15254;
15257 -> 15254;
15258 -> 15252;
15258 -> 15254;
15259 -> 15257;
15259 -> 15254;
15260 -> 15254;
15261 -> 15258;
15261 -> 15260;
15262 -> 15259;
15262 -> 15260;
15263 -> 15253;
15263 -> 15260;
15264 -> 15260;
15265 -> 15263;
15265 -> 15264;
15266 -> 15265;
15266 -> 15260;
15267 -> 15266;
15267 -> 0;
15267 -> 15260;
15268 -> 15261;
15268 -> 15260;
15269 -> 15260;
15270 -> 15268;
15270 -> 15269;
15271 -> 15263;
15271 -> 15269;
15272 -> 15270;
15272 -> 15269;
15273 -> 15269;
15274 -> 15272;
15274 -> 15273;
15275 -> 15271;
15275 -> 15273;
15276 -> 15275;
15276 -> 15269;
15277 -> 15276;
15277 -> 15260;
15278 -> 15266;
15278 -> 0;
15278 -> 15260;
15279 -> 15278;
15279 -> 15260;
15280 -> 15279;
15281 -> 15277;
15281 -> 15260;
15282 -> 15278;
15282 -> 15260;
15283 -> 15280;
15283 -> 15282;
15284 -> 15283;
15284 -> 15254;
15285 -> 15253;
15285 -> 15218;
15285 -> 15254;
15286 -> 15284;
15286 -> 15254;
15287 -> 15254;
15288 -> 15257;
15288 -> 15286;
15289 -> 15286;
15290 -> 15288;
15290 -> 15289;
15291 -> 15253;
15291 -> 15289;
15292 -> 15289;
15293 -> 15291;
15293 -> 15292;
15294 -> 15293;
15294 -> 15289;
15295 -> 15290;
15295 -> 15257;
15295 -> 15289;
15296 -> 15286;
15297 -> 15257;
15297 -> 15254;
15298 -> 15253;
15298 -> 15286;
15298 -> 15251;
15299 -> 15298;
15299 -> 15286;
15299 -> 15246;
15300 -> 15246;
15301 -> 15300;
15301 -> 15286;
15302 -> 15300;
15302 -> 15286;
15303 -> 3399;
15303 -> 15241;
15304 -> 3399;
15304 -> 15242;
15304 -> 15241;
15305 -> 15303;
15305 -> 15241;
15306 -> 15305;
15306 -> 15239;
15307 -> 15306;
15307 -> 3399;
15307 -> 15239;
15308 -> 3393;
15308 -> 3392;
15308 -> 15307;
15309 -> 3393;
15309 -> 15307;
15310 -> 15309;
15310 -> 15236;
15311 -> 15310;
15311 -> 3392;
15311 -> 15236;
15312 -> 15311;
15313 -> 15233;
15314 -> 15234;
15314 -> 15233;
15315 -> 15233;
15316 -> 15314;
15316 -> 15315;
15317 -> 14853;
15317 -> 15315;
15318 -> 15315;
15319 -> 15317;
15319 -> 15318;
15320 -> 15319;
15320 -> 15286;
15320 -> 15318;
15321 -> 15320;
15321 -> 15315;
15322 -> 15316;
15322 -> 15234;
15322 -> 15315;
15323 -> 15233;
15324 -> 0;
15324 -> 15233;
15325 -> 15233;
15326 -> 15324;
15326 -> 15325;
15327 -> 14853;
15327 -> 15286;
15327 -> 15325;
15328 -> 15327;
15328 -> 15326;
15328 -> 15325;
15329 -> 15234;
15329 -> 15233;
15330 -> 15218;
15330 -> 14854;
15331 -> 15330;
15331 -> 15009;
15332 -> 14853;
15332 -> 15286;
15332 -> 15009;
15333 -> 15331;
15333 -> 15009;
15334 -> 15333;
15334 -> 15014;
15335 -> 15332;
15335 -> 15014;
15336 -> 15335;
15336 -> 15286;
15336 -> 15328;
15336 -> 15334;
15336 -> 15014;
15337 -> 15336;
15338 -> 14852;
15338 -> 15286;
15338 -> 15304;
15338 -> 15328;
15338 -> 3396;
15338 -> 3397;
15338 -> 3398;
15338 -> 14854;
15339 -> 15338;
15339 -> 14856;
15340 -> 15339;
15340 -> 14859;
15341 -> 15340;
15341 -> 14861;
15341 -> 14859;
15342 -> 15338;
15343 -> 14853;
15343 -> 15342;
15344 -> 15343;
15344 -> 15338;
15344 -> 15342;
15345 -> 3414;
15345 -> 15342;
15346 -> 15344;
15347 -> 15343;
15347 -> 15338;
15347 -> 15344;
15348 -> 15346;
15348 -> 15344;
15349 -> 15344;
15350 -> 15348;
15350 -> 15349;
15351 -> 15343;
15351 -> 15349;
15352 -> 15349;
15353 -> 15351;
15353 -> 15352;
15354 -> 15353;
15354 -> 15349;
15355 -> 15354;
15356 -> 15355;
15356 -> 15344;
15357 -> 3414;
15357 -> 15344;
15358 -> 15346;
15358 -> 15356;
15359 -> 15356;
15360 -> 15358;
15360 -> 15359;
15361 -> 15343;
15361 -> 15359;
15362 -> 15359;
15363 -> 15361;
15363 -> 15362;
15364 -> 15363;
15364 -> 15359;
15365 -> 15360;
15365 -> 15346;
15365 -> 15359;
15366 -> 15356;
15367 -> 0;
15367 -> 15356;
15368 -> 15356;
15369 -> 15367;
15369 -> 15368;
15370 -> 15346;
15370 -> 15344;
15371 -> 15343;
15371 -> 15356;
15371 -> 15342;
15372 -> 15371;
15372 -> 15338;
15373 -> 15338;
15373 -> 14854;
15374 -> 15373;
15374 -> 15009;
15375 -> 14853;
15375 -> 15356;
15375 -> 15009;
15376 -> 15374;
15376 -> 15009;
15377 -> 15376;
15377 -> 15014;
15378 -> 15375;
15378 -> 15014;
15379 -> 15378;
15379 -> 15356;
15379 -> 15369;
15379 -> 15377;
15379 -> 15014;
15380 -> 15379;
15381 -> 15369;
15381 -> 14856;
15382 -> 15381;
15382 -> 14859;
15383 -> 15382;
15383 -> 14861;
15383 -> 14859;
15384 -> 15369;
15385 -> 14853;
15385 -> 15384;
15386 -> 15385;
15386 -> 15369;
15386 -> 15384;
15387 -> 15386;
15388 -> 15385;
15388 -> 15369;
15388 -> 15386;
15389 -> 15387;
15389 -> 15386;
15390 -> 15386;
15391 -> 15389;
15391 -> 15390;
15392 -> 15391;
15392 -> 15389;
15392 -> 15390;
15393 -> 15390;
15394 -> 15389;
15394 -> 15393;
15395 -> 15393;
15395 -> 15390;
15396 -> 15389;
15396 -> 15390;
15397 -> 15389;
15397 -> 15390;
15398 -> 15389;
15398 -> 15390;
15399 -> 15389;
15399 -> 15390;
15400 -> 0;
15400 -> 15390;
15401 -> 15396;
15401 -> 15400;
15401 -> 15390;
15402 -> 15389;
15402 -> 15390;
15403 -> 15402;
15403 -> 15392;
15403 -> 15390;
15404 -> 15389;
15404 -> 15390;
15405 -> 15389;
15405 -> 15390;
15406 -> 15389;
15406 -> 15390;
15407 -> 15389;
15407 -> 15390;
15408 -> 15407;
15408 -> 15390;
15409 -> 15407;
15409 -> 15390;
15410 -> 15407;
15410 -> 15390;
15411 -> 15404;
15411 -> 15407;
15411 -> 15390;
15412 -> 15390;
15413 -> 15404;
15413 -> 15412;
15413 -> 15403;
15413 -> 15390;
15414 -> 0;
15414 -> 15390;
15415 -> 15405;
15415 -> 15407;
15415 -> 15390;
15416 -> 15406;
15416 -> 15407;
15416 -> 15390;
15417 -> 15389;
15417 -> 15413;
15417 -> 15411;
15417 -> 15415;
15417 -> 15416;
15417 -> 15386;
15418 -> 15389;
15418 -> 15390;
15419 -> 15389;
15419 -> 15390;
15420 -> 15389;
15420 -> 15390;
15421 -> 15389;
15421 -> 15390;
15422 -> 15390;
15423 -> 15421;
15423 -> 15417;
15423 -> 15422;
15423 -> 15390;
15424 -> 15421;
15424 -> 15423;
15424 -> 15390;
15425 -> 15423;
15425 -> 15390;
15426 -> 15390;
15427 -> 15425;
15427 -> 15426;
15428 -> 15427;
15428 -> 15425;
15428 -> 15426;
15429 -> 15427;
15429 -> 15426;
15430 -> 15429;
15430 -> 15425;
15431 -> 15428;
15431 -> 15430;
15431 -> 15425;
15431 -> 15429;
15432 -> 15428;
15432 -> 15431;
15432 -> 15426;
15433 -> 15418;
15433 -> 15390;
15434 -> 15419;
15434 -> 15390;
15435 -> 15434;
15435 -> 15432;
15435 -> 15390;
15436 -> 15390;
15437 -> 15434;
15437 -> 15436;
15438 -> 15437;
15438 -> 15435;
15438 -> 15436;
15439 -> 15437;
15439 -> 15436;
15440 -> 15439;
15440 -> 15435;
15440 -> 15436;
15441 -> 15440;
15441 -> 15435;
15442 -> 15438;
15442 -> 15441;
15442 -> 15435;
15442 -> 15440;
15443 -> 15438;
15443 -> 15442;
15443 -> 15436;
15444 -> 15390;
15445 -> 15390;
15446 -> 15424;
15446 -> 15445;
15447 -> 15432;
15447 -> 15445;
15448 -> 15433;
15448 -> 15445;
15449 -> 15432;
15449 -> 15445;
15450 -> 15435;
15450 -> 15445;
15451 -> 15443;
15451 -> 15445;
15452 -> 15444;
15452 -> 15445;
15453 -> 15447;
15453 -> 15445;
15454 -> 15448;
15454 -> 15445;
15455 -> 15450;
15455 -> 15445;
15456 -> 15451;
15456 -> 15445;
15457 -> 15445;
15458 -> 15453;
15458 -> 15457;
15459 -> 15454;
15459 -> 15457;
15460 -> 15455;
15460 -> 15457;
15461 -> 15456;
15461 -> 15457;
15462 -> 15452;
15462 -> 15457;
15463 -> 15457;
15464 -> 15462;
15464 -> 15463;
15465 -> 15463;
15466 -> 15464;
15466 -> 15463;
15467 -> 15462;
15467 -> 15457;
15468 -> 15462;
15468 -> 15457;
15469 -> 15462;
15469 -> 15457;
15471 -> 15470;
15472 -> 15471;
15472 -> 15470;
15473 -> 15471;
15473 -> 15470;
15474 -> 15470;
15475 -> 15474;
15475 -> 15471;
15475 -> 15470;
15476 -> 15470;
15477 -> 15476;
15477 -> 15471;
15477 -> 15470;
15478 -> 15470;
15479 -> 15478;
15479 -> 15462;
15479 -> 15457;
15480 -> 15461;
15480 -> 15443;
15480 -> 15457;
15481 -> 15458;
15481 -> 15462;
15481 -> 15457;
15482 -> 15459;
15482 -> 15462;
15482 -> 15457;
15483 -> 15460;
15483 -> 15462;
15483 -> 15457;
15484 -> 15461;
15484 -> 15462;
15484 -> 15457;
15485 -> 15452;
15485 -> 15445;
15486 -> 15452;
15486 -> 15445;
15487 -> 15446;
15487 -> 15452;
15487 -> 15445;
15488 -> 15449;
15488 -> 15452;
15488 -> 15445;
15489 -> 15390;
15490 -> 15444;
15490 -> 15489;
15491 -> 15490;
15491 -> 15481;
15491 -> 15489;
15492 -> 15491;
15492 -> 15390;
15493 -> 15390;
15494 -> 15444;
15494 -> 15493;
15495 -> 15494;
15495 -> 15487;
15495 -> 15493;
15496 -> 15495;
15496 -> 15390;
15497 -> 15390;
15498 -> 15496;
15498 -> 15497;
15499 -> 15498;
15499 -> 15442;
15499 -> 15497;
15500 -> 15492;
15500 -> 15499;
15500 -> 15390;
15501 -> 15444;
15501 -> 15390;
15502 -> 15389;
15502 -> 15501;
15502 -> 15442;
15502 -> 15464;
15502 -> 15466;
15502 -> 15481;
15502 -> 15482;
15502 -> 15469;
15502 -> 15479;
15502 -> 15483;
15502 -> 15484;
15502 -> 15487;
15502 -> 15488;
15502 -> 15475;
15502 -> 15477;
15502 -> 15435;
15502 -> 15443;
15502 -> 15386;
15503 -> 15502;
15503 -> 15457;
15504 -> 15490;
15504 -> 15502;
15504 -> 15489;
15505 -> 15504;
15505 -> 15390;
15506 -> 15494;
15506 -> 15502;
15506 -> 15493;
15507 -> 15506;
15507 -> 15390;
15508 -> 15507;
15508 -> 15497;
15509 -> 15505;
15509 -> 15508;
15509 -> 15390;
15510 -> 15387;
15510 -> 15502;
15511 -> 15502;
15512 -> 15510;
15512 -> 15511;
15513 -> 15385;
15513 -> 15511;
15514 -> 15511;
15515 -> 15513;
15515 -> 15514;
15516 -> 15515;
15516 -> 15511;
15517 -> 15512;
15517 -> 15502;
15517 -> 15511;
15518 -> 15502;
15519 -> 15387;
15519 -> 15502;
15519 -> 15386;
15520 -> 15385;
15520 -> 15519;
15520 -> 15384;
15521 -> 15520;
15521 -> 15369;
15522 -> 14851;
15522 -> 15521;
15523 -> 14852;
15523 -> 15521;
15524 -> 15521;
15525 -> 15522;
15525 -> 15524;
15526 -> 15524;
15527 -> 15525;
15527 -> 15526;
15528 -> 15526;
15529 -> 15527;
15529 -> 15528;
15529 -> 15526;
15530 -> 15524;
15531 -> 15522;
15531 -> 15524;
15532 -> 15524;
15533 -> 15531;
15533 -> 15532;
15534 -> 15532;
15535 -> 15533;
15535 -> 15522;
15535 -> 15534;
15535 -> 15532;
15536 -> 15535;
15537 -> 15535;
15538 -> 15533;
15538 -> 15537;
15539 -> 15538;
15539 -> 15522;
15539 -> 15537;
15540 -> 15539;
15540 -> 15535;
15541 -> 15535;
15542 -> 15540;
15542 -> 15541;
15542 -> 15535;
15543 -> 15542;
15544 -> 15533;
15544 -> 15543;
15545 -> 15543;
15546 -> 15544;
15546 -> 15522;
15546 -> 15543;
15547 -> 15546;
15548 -> 15547;
15548 -> 15546;
15549 -> 15545;
15549 -> 15548;
15549 -> 15547;
15549 -> 15546;
15550 -> 15543;
15551 -> 15544;
15551 -> 15550;
15552 -> 15551;
15552 -> 15549;
15552 -> 15550;
15553 -> 15552;
15553 -> 15543;
15554 -> 15543;
15555 -> 15553;
15555 -> 15554;
15555 -> 15543;
15556 -> 15545;
15556 -> 15549;
15556 -> 15543;
15557 -> 15556;
15557 -> 15542;
15558 -> 15542;
15559 -> 15558;
15559 -> 15557;
15560 -> 15559;
15560 -> 15542;
15561 -> 15542;
15562 -> 15542;
15563 -> 15557;
15563 -> 15562;
15564 -> 15557;
15564 -> 15562;
15565 -> 15561;
15565 -> 15562;
15566 -> 15561;
15566 -> 15562;
15567 -> 15560;
15567 -> 15562;
15568 -> 15561;
15568 -> 15562;
15569 -> 15533;
15569 -> 15562;
15570 -> 15562;
15571 -> 15569;
15571 -> 15570;
15572 -> 15570;
15573 -> 15571;
15573 -> 15572;
15574 -> 0;
15574 -> 15572;
15575 -> 15574;
15575 -> 15570;
15576 -> 15571;
15576 -> 15557;
15576 -> 15570;
15577 -> 15576;
15577 -> 15562;
15578 -> 15562;
15579 -> 15563;
15579 -> 15562;
15580 -> 15565;
15580 -> 15562;
15581 -> 15562;
15582 -> 15577;
15582 -> 15562;
15583 -> 15568;
15583 -> 15562;
15584 -> 15567;
15584 -> 15562;
15585 -> 15562;
15586 -> 15569;
15586 -> 15562;
15587 -> 15586;
15587 -> 15562;
15588 -> 15562;
15589 -> 15562;
15590 -> 15562;
15591 -> 15590;
15591 -> 15579;
15591 -> 15557;
15591 -> 15562;
15592 -> 15579;
15592 -> 15590;
15592 -> 15557;
15592 -> 15591;
15593 -> 15592;
15593 -> 15591;
15594 -> 0;
15594 -> 15562;
15595 -> 15562;
15595 -> 0;
15596 -> 15562;
15597 -> 15596;
15597 -> 15562;
15598 -> 15562;
15599 -> 15566;
15600 -> 15566;
15601 -> 15569;
15601 -> 15600;
15602 -> 15566;
15603 -> 15566;
15603 -> 15562;
15604 -> 15562;
15605 -> 15565;
15605 -> 15562;
15606 -> 15599;
15606 -> 15562;
15607 -> 15562;
15608 -> 15603;
15608 -> 15607;
15609 -> 15604;
15609 -> 15607;
15610 -> 15604;
15610 -> 15607;
15611 -> 15605;
15611 -> 15607;
15612 -> 15606;
15612 -> 15607;
15613 -> 15569;
15613 -> 15607;
15614 -> 15562;
15615 -> 15568;
15615 -> 15593;
15616 -> 15566;
15616 -> 15615;
15617 -> 15615;
15618 -> 15616;
15618 -> 15617;
15619 -> 15569;
15619 -> 15617;
15620 -> 15618;
15620 -> 15617;
15621 -> 15615;
15622 -> 15562;
15622 -> 15615;
15623 -> 15615;
15624 -> 15622;
15624 -> 15623;
15625 -> 15569;
15625 -> 15623;
15626 -> 15623;
15627 -> 15625;
15627 -> 15626;
15628 -> 15627;
15628 -> 15623;
15629 -> 15625;
15629 -> 15628;
15630 -> 15628;
15631 -> 15628;
15632 -> 15629;
15632 -> 15631;
15633 -> 15630;
15633 -> 15631;
15634 -> 15628;
15634 -> 15631;
15635 -> 15632;
15635 -> 15631;
15636 -> 15632;
15636 -> 15635;
15637 -> 15633;
15637 -> 15636;
15638 -> 15636;
15639 -> 15624;
15639 -> 15562;
15639 -> 15623;
15640 -> 15615;
15641 -> 15593;
15641 -> 15562;
15642 -> 15562;
15643 -> 15593;
15643 -> 15535;
15644 -> 0;
15644 -> 15643;
15645 -> 15643;
15646 -> 15644;
15646 -> 15645;
15647 -> 15533;
15647 -> 15593;
15647 -> 15532;
15648 -> 15647;
15648 -> 15524;
15649 -> 15522;
15649 -> 15648;
15649 -> 15593;
15649 -> 15646;
15649 -> 15521;
15650 -> 15522;
15650 -> 15524;
15651 -> 15522;
15651 -> 15524;
15652 -> 15522;
15652 -> 15524;
15653 -> 15650;
15653 -> 15524;
15654 -> 15524;
15655 -> 15653;
15655 -> 15654;
15656 -> 15652;
15656 -> 15654;
15657 -> 15656;
15657 -> 15649;
15657 -> 15655;
15657 -> 15654;
15658 -> 15657;
15659 -> 15649;
15659 -> 15524;
15660 -> 15659;
15660 -> 15526;
15661 -> 15660;
15661 -> 15528;
15661 -> 15526;
15662 -> 15522;
15662 -> 15524;
15663 -> 15524;
15664 -> 15662;
15664 -> 15663;
15665 -> 15664;
15665 -> 15649;
15665 -> 15663;
15666 -> 15663;
15667 -> 15665;
15667 -> 15666;
15668 -> 15667;
15668 -> 15478;
15668 -> 15666;
15669 -> 15668;
15670 -> 15664;
15670 -> 15669;
15671 -> 15669;
15672 -> 15670;
15672 -> 15649;
15672 -> 15671;
15673 -> 15672;
15673 -> 15669;
15674 -> 15673;
15674 -> 15668;
15675 -> 15668;
15676 -> 15674;
15676 -> 15675;
15677 -> 15676;
15677 -> 15675;
15678 -> 0;
15678 -> 15677;
15679 -> 15677;
15680 -> 15678;
15680 -> 15679;
15681 -> 15677;
15681 -> 15679;
15682 -> 15680;
15682 -> 15679;
15683 -> 15679;
15684 -> 15682;
15684 -> 15683;
15685 -> 15681;
15685 -> 15683;
15686 -> 15684;
15686 -> 15683;
15687 -> 15685;
15687 -> 15683;
15688 -> 15686;
15688 -> 15687;
15688 -> 0;
15688 -> 15649;
15688 -> 15683;
15689 -> 15684;
15689 -> 15688;
15689 -> 15683;
15690 -> 15685;
15690 -> 15689;
15690 -> 15683;
15691 -> 15683;
15692 -> 15690;
15692 -> 15691;
15693 -> 15692;
15694 -> 15684;
15694 -> 15692;
15695 -> 15693;
15695 -> 15692;
15696 -> 15692;
15697 -> 15694;
15697 -> 15696;
15698 -> 15695;
15698 -> 15696;
15699 -> 15685;
15699 -> 15696;
15700 -> 15696;
15701 -> 15699;
15701 -> 15700;
15702 -> 15701;
15702 -> 15689;
15702 -> 15700;
15703 -> 15702;
15703 -> 15696;
15704 -> 15696;
15705 -> 15703;
15705 -> 15704;
15706 -> 15699;
15706 -> 15689;
15706 -> 15704;
15707 -> 15704;
15708 -> 15706;
15708 -> 15707;
15709 -> 15708;
15709 -> 15689;
15709 -> 15707;
15710 -> 15709;
15710 -> 15689;
15710 -> 15707;
15711 -> 15710;
15712 -> 15708;
15712 -> 15711;
15713 -> 15712;
15713 -> 15689;
15713 -> 15711;
15714 -> 15713;
15714 -> 15689;
15714 -> 15711;
15715 -> 15712;
15715 -> 15689;
15715 -> 15714;
15716 -> 15714;
15717 -> 15712;
15717 -> 15716;
15718 -> 15716;
15719 -> 15717;
15719 -> 15718;
15720 -> 15719;
15720 -> 15716;
15721 -> 0;
15721 -> 15716;
15722 -> 15720;
15722 -> 15689;
15722 -> 15716;
15723 -> 15716;
15724 -> 15722;
15724 -> 15723;
15724 -> 15716;
15725 -> 15724;
15726 -> 15717;
15726 -> 15725;
15727 -> 15726;
15727 -> 15689;
15727 -> 15725;
15728 -> 15727;
15729 -> 15727;
15730 -> 15728;
15730 -> 15729;
15731 -> 15728;
15731 -> 15729;
15732 -> 15730;
15732 -> 15728;
15732 -> 15729;
15733 -> 15730;
15733 -> 15732;
15734 -> 15733;
15734 -> 15732;
15735 -> 15733;
15735 -> 15732;
15736 -> 15725;
15737 -> 15736;
15737 -> 15724;
15738 -> 15724;
15739 -> 15717;
15739 -> 15732;
15739 -> 15724;
15740 -> 15739;
15740 -> 15732;
15741 -> 15739;
15742 -> 15740;
15742 -> 15741;
15742 -> 15732;
15742 -> 15739;
15743 -> 15739;
15744 -> 15742;
15744 -> 15743;
15745 -> 15741;
15745 -> 15743;
15746 -> 15744;
15747 -> 15746;
15747 -> 15744;
15748 -> 15746;
15748 -> 15744;
15749 -> 15737;
15749 -> 15739;
15750 -> 15739;
15751 -> 15750;
15752 -> 15750;
15752 -> 15751;
15753 -> 15751;
15753 -> 15750;
15754 -> 15750;
15754 -> 15744;
15755 -> 15754;
15755 -> 15739;
15756 -> 15740;
15756 -> 15744;
15756 -> 15739;
15757 -> 15739;
15758 -> 15739;
15759 -> 15756;
15759 -> 15758;
15760 -> 15757;
15760 -> 15758;
15761 -> 15755;
15761 -> 15758;
15762 -> 15760;
15762 -> 15758;
15763 -> 15759;
15763 -> 15758;
15764 -> 15758;
15765 -> 15761;
15765 -> 15744;
15765 -> 15758;
15766 -> 15758;
15767 -> 15763;
15767 -> 15766;
15768 -> 15764;
15768 -> 15766;
15769 -> 15765;
15769 -> 15766;
15770 -> 15761;
15770 -> 15766;
15771 -> 15769;
15771 -> 15766;
15772 -> 15768;
15772 -> 15766;
15773 -> 15770;
15773 -> 15744;
15773 -> 15772;
15774 -> 15770;
15774 -> 15744;
15774 -> 15773;
15774 -> 15766;
15775 -> 15771;
15775 -> 15774;
15775 -> 15744;
15775 -> 15773;
15775 -> 15766;
15776 -> 15767;
15776 -> 15766;
15777 -> 15766;
15778 -> 15776;
15778 -> 15777;
15779 -> 15770;
15779 -> 15777;
15780 -> 15779;
15780 -> 15775;
15780 -> 15777;
15781 -> 15780;
15781 -> 15778;
15781 -> 15777;
15782 -> 15775;
15782 -> 15766;
15783 -> 15766;
15784 -> 15782;
15784 -> 15783;
15784 -> 15766;
15785 -> 15766;
15786 -> 15782;
15786 -> 15781;
15786 -> 15766;
15787 -> 15766;
15788 -> 15786;
15788 -> 15787;
15788 -> 15766;
15789 -> 15785;
15789 -> 15766;
15790 -> 15786;
15790 -> 15789;
15790 -> 15781;
15790 -> 15766;
15791 -> 15790;
15792 -> 15739;
15793 -> 15739;
15794 -> 15793;
15794 -> 15739;
15795 -> 15739;
15796 -> 15748;
15796 -> 15744;
15796 -> 15795;
15796 -> 15739;
15797 -> 15796;
15798 -> 15747;
15798 -> 15790;
15798 -> 15797;
15798 -> 15775;
15798 -> 15796;
15799 -> 15796;
15800 -> 15798;
15800 -> 15799;
15801 -> 15797;
15801 -> 15799;
15802 -> 15797;
15802 -> 15799;
15803 -> 15791;
15803 -> 15799;
15804 -> 15800;
15804 -> 15798;
15804 -> 15799;
15805 -> 15799;
15806 -> 15803;
15806 -> 15805;
15807 -> 15806;
15807 -> 15798;
15807 -> 0;
15807 -> 15805;
15808 -> 15807;
15808 -> 15799;
15809 -> 15799;
15810 -> 15800;
15810 -> 15798;
15810 -> 15809;
15810 -> 15799;
15811 -> 15808;
15811 -> 15810;
15811 -> 15799;
15812 -> 15800;
15812 -> 15798;
15812 -> 15811;
15813 -> 15812;
15813 -> 15799;
15814 -> 15804;
15814 -> 15799;
15815 -> 15801;
15815 -> 15799;
15816 -> 15802;
15816 -> 15799;
15817 -> 15799;
15818 -> 15813;
15818 -> 15817;
15819 -> 15814;
15819 -> 15817;
15820 -> 15815;
15820 -> 15817;
15821 -> 15816;
15821 -> 15817;
15822 -> 15803;
15822 -> 15817;
15823 -> 15817;
15824 -> 15818;
15824 -> 15823;
15824 -> 15817;
15825 -> 15821;
15825 -> 15817;
15826 -> 15822;
15826 -> 15798;
15826 -> 15817;
15827 -> 15817;
15828 -> 15826;
15828 -> 15827;
15829 -> 15826;
15829 -> 15827;
15830 -> 15827;
15831 -> 15830;
15831 -> 15827;
15832 -> 15830;
15832 -> 15827;
15833 -> 15830;
15833 -> 15827;
15834 -> 15830;
15834 -> 15827;
15835 -> 15828;
15835 -> 15830;
15835 -> 15827;
15836 -> 15826;
15836 -> 15830;
15836 -> 15831;
15836 -> 15832;
15836 -> 15833;
15836 -> 15834;
15836 -> 15835;
15836 -> 15817;
15837 -> 15819;
15837 -> 15817;
15838 -> 15820;
15838 -> 15817;
15839 -> 15821;
15839 -> 15817;
15840 -> 15817;
15841 -> 15837;
15841 -> 15840;
15842 -> 15838;
15842 -> 15840;
15843 -> 15839;
15843 -> 15840;
15844 -> 15836;
15844 -> 15840;
15845 -> 15840;
15846 -> 15840;
15847 -> 15842;
15847 -> 15846;
15848 -> 15845;
15848 -> 15846;
15849 -> 15848;
15849 -> 15846;
15850 -> 15847;
15850 -> 15849;
15851 -> 15842;
15851 -> 15845;
15851 -> 15840;
15852 -> 15843;
15852 -> 15845;
15852 -> 15840;
15853 -> 15851;
15853 -> 15852;
15853 -> 15840;
15854 -> 15841;
15854 -> 15844;
15854 -> 15840;
15855 -> 15842;
15855 -> 15844;
15855 -> 15840;
15856 -> 15843;
15856 -> 15844;
15856 -> 15840;
15857 -> 15817;
15858 -> 15818;
15858 -> 15817;
15859 -> 15817;
15860 -> 15858;
15860 -> 15859;
15861 -> 15836;
15861 -> 15859;
15862 -> 15860;
15862 -> 15859;
15863 -> 15859;
15864 -> 15862;
15864 -> 15863;
15865 -> 15861;
15865 -> 15863;
15866 -> 15865;
15866 -> 15863;
15867 -> 15866;
15867 -> 15864;
15867 -> 15836;
15867 -> 15854;
15867 -> 15855;
15867 -> 15856;
15867 -> 15863;
15868 -> 15863;
15869 -> 15867;
15869 -> 15868;
15870 -> 15867;
15870 -> 15868;
15871 -> 15869;
15871 -> 15867;
15871 -> 15868;
15872 -> 15868;
15873 -> 15871;
15873 -> 15872;
15874 -> 15870;
15874 -> 15872;
15875 -> 15874;
15875 -> 15873;
15875 -> 15867;
15875 -> 15872;
15876 -> 15875;
15876 -> 15872;
15877 -> 15875;
15877 -> 15872;
15878 -> 15876;
15878 -> 15872;
15879 -> 15872;
15880 -> 15878;
15880 -> 15879;
15881 -> 15877;
15881 -> 15879;
15882 -> 15881;
15882 -> 15875;
15882 -> 15879;
15883 -> 15880;
15883 -> 15879;
15884 -> 15882;
15884 -> 15883;
15884 -> 15875;
15884 -> 15879;
15885 -> 0;
15885 -> 15879;
15886 -> 15879;
15887 -> 15880;
15887 -> 15884;
15887 -> 15886;
15887 -> 15879;
15888 -> 15881;
15888 -> 15884;
15888 -> 15879;
15889 -> 15880;
15889 -> 15884;
15889 -> 15879;
15890 -> 15881;
15890 -> 15888;
15890 -> 15887;
15891 -> 15880;
15891 -> 15887;
15892 -> 0;
15892 -> 15890;
15893 -> 15880;
15893 -> 15879;
15894 -> 15892;
15894 -> 15879;
15895 -> 15879;
15896 -> 15893;
15896 -> 15895;
15897 -> 15894;
15897 -> 15895;
15898 -> 15881;
15898 -> 15895;
15899 -> 15896;
15899 -> 15895;
15900 -> 15897;
15900 -> 15895;
15901 -> 15895;
15902 -> 15899;
15902 -> 15901;
15903 -> 15900;
15903 -> 15901;
15904 -> 15903;
15904 -> 15901;
15905 -> 15901;
15906 -> 15902;
15906 -> 15901;
15907 -> 15903;
15907 -> 15901;
15908 -> 15901;
15909 -> 15901;
15910 -> 15906;
15910 -> 15909;
15911 -> 15907;
15911 -> 15909;
15912 -> 15908;
15912 -> 15909;
15913 -> 15910;
15913 -> 15912;
15913 -> 15909;
15914 -> 15911;
15914 -> 15912;
15914 -> 15909;
15915 -> 15908;
15915 -> 15895;
15916 -> 15895;
15917 -> 15895;
15918 -> 15898;
15918 -> 15917;
15919 -> 15918;
15919 -> 15890;
15919 -> 15917;
15920 -> 15919;
15920 -> 15895;
15921 -> 15915;
15921 -> 15895;
15922 -> 15916;
15922 -> 15895;
15923 -> 15921;
15923 -> 15922;
15923 -> 15920;
15923 -> 15913;
15923 -> 15914;
15923 -> 15890;
15923 -> 15895;
15924 -> 15895;
15925 -> 15923;
15925 -> 15924;
15926 -> 15925;
15926 -> 15923;
15926 -> 15924;
15927 -> 15896;
15927 -> 15926;
15928 -> 15926;
15929 -> 15927;
15929 -> 15928;
15930 -> 15929;
15930 -> 15928;
15931 -> 15929;
15931 -> 15928;
15932 -> 15931;
15932 -> 15929;
15932 -> 15928;
15933 -> 15930;
15933 -> 15928;
15934 -> 15932;
15934 -> 15933;
15934 -> 15929;
15934 -> 15928;
15935 -> 15931;
15935 -> 15934;
15935 -> 15928;
15936 -> 15930;
15936 -> 15934;
15936 -> 15928;
15937 -> 15930;
15937 -> 15928;
15938 -> 15928;
15939 -> 15937;
15939 -> 15938;
15940 -> 15931;
15940 -> 15938;
15941 -> 15939;
15941 -> 15935;
15941 -> 15938;
15942 -> 15938;
15943 -> 15942;
15943 -> 15938;
15944 -> 15939;
15944 -> 15935;
15944 -> 15938;
15945 -> 15940;
15945 -> 15944;
15945 -> 15941;
15945 -> 15935;
15945 -> 15938;
15946 -> 15940;
15946 -> 15944;
15946 -> 15941;
15946 -> 15935;
15946 -> 15945;
15947 -> 15940;
15947 -> 15944;
15947 -> 15946;
15948 -> 15946;
15949 -> 15947;
15949 -> 15938;
15950 -> 15938;
15951 -> 15949;
15951 -> 15950;
15951 -> 15938;
15952 -> 15949;
15952 -> 15939;
15952 -> 15938;
15953 -> 15949;
15953 -> 15951;
15954 -> 0;
15954 -> 15951;
15955 -> 15949;
15955 -> 15953;
15955 -> 15951;
15956 -> 15938;
15957 -> 15956;
15957 -> 15928;
15958 -> 15930;
15958 -> 15928;
15959 -> 15931;
15959 -> 15955;
15959 -> 15928;
15960 -> 15935;
15960 -> 15928;
15961 -> 15957;
15961 -> 15928;
15962 -> 15928;
15963 -> 15958;
15963 -> 15962;
15964 -> 15959;
15964 -> 15962;
15965 -> 15960;
15965 -> 15962;
15966 -> 15961;
15966 -> 15962;
15967 -> 15931;
15967 -> 15962;
15968 -> 15966;
15968 -> 15962;
15969 -> 15962;
15970 -> 15966;
15970 -> 15962;
15971 -> 15965;
15971 -> 15970;
15972 -> 0;
15972 -> 15971;
15973 -> 15963;
15973 -> 15962;
15974 -> 15972;
15974 -> 15962;
15975 -> 15962;
15976 -> 15973;
15976 -> 15975;
15977 -> 15974;
15977 -> 15975;
15978 -> 15977;
15978 -> 15975;
15979 -> 15975;
15980 -> 15975;
15980 -> 15962;
15981 -> 15962;
15982 -> 15962;
15983 -> 15967;
15983 -> 15982;
15984 -> 15983;
15984 -> 15955;
15984 -> 15982;
15985 -> 15984;
15985 -> 15962;
15986 -> 15980;
15986 -> 15962;
15987 -> 15981;
15987 -> 15962;
15988 -> 15986;
15988 -> 15987;
15988 -> 15985;
15988 -> 15976;
15988 -> 15977;
15988 -> 15955;
15988 -> 15962;
15989 -> 15962;
15990 -> 15988;
15991 -> 15963;
15991 -> 15988;
15992 -> 15988;
15993 -> 15967;
15993 -> 15992;
15994 -> 15992;
15995 -> 15993;
15995 -> 15988;
15995 -> 15994;
15996 -> 15995;
15996 -> 15992;
15997 -> 15996;
15997 -> 15988;
15998 -> 15963;
15998 -> 15988;
15998 -> 15997;
15999 -> 15964;
15999 -> 15997;
16000 -> 15997;
16001 -> 15997;
16002 -> 15998;
16002 -> 16001;
16003 -> 15999;
16003 -> 16001;
16004 -> 16000;
16004 -> 16001;
16005 -> 16000;
16005 -> 16001;
16006 -> 16001;
16007 -> 16002;
16007 -> 16006;
16007 -> 16001;
16008 -> 16005;
16008 -> 16001;
16009 -> 16001;
16010 -> 16001;
16011 -> 16004;
16011 -> 16010;
16012 -> 16009;
16012 -> 16010;
16013 -> 16012;
16013 -> 16010;
16014 -> 16011;
16014 -> 16013;
16015 -> 16004;
16015 -> 16009;
16015 -> 16001;
16016 -> 16005;
16016 -> 16009;
16016 -> 16001;
16017 -> 16003;
16017 -> 16001;
16018 -> 16003;
16018 -> 16001;
16019 -> 16017;
16019 -> 16001;
16020 -> 16001;
16021 -> 16019;
16021 -> 16020;
16022 -> 16018;
16022 -> 16020;
16023 -> 16020;
16024 -> 16023;
16024 -> 16020;
16025 -> 16022;
16025 -> 16021;
16025 -> 16003;
16026 -> 16020;
16026 -> 16001;
16027 -> 16001;
16028 -> 16018;
16028 -> 16027;
16029 -> 16028;
16029 -> 16025;
16029 -> 16027;
16030 -> 16001;
16031 -> 16019;
16031 -> 16030;
16032 -> 16026;
16032 -> 16030;
16033 -> 16029;
16033 -> 16030;
16034 -> 16018;
16034 -> 16030;
16035 -> 16030;
16036 -> 16034;
16036 -> 16035;
16037 -> 16036;
16037 -> 16025;
16037 -> 16035;
16038 -> 16037;
16038 -> 16030;
16039 -> 16030;
16040 -> 16031;
16040 -> 16038;
16040 -> 16030;
16041 -> 16032;
16041 -> 16030;
16042 -> 16033;
16042 -> 16041;
16043 -> 0;
16043 -> 16042;
16044 -> 16031;
16044 -> 16030;
16045 -> 16043;
16045 -> 16030;
16046 -> 16030;
16047 -> 16044;
16047 -> 16046;
16048 -> 16045;
16048 -> 16046;
16049 -> 16048;
16049 -> 16046;
16050 -> 16046;
16051 -> 16046;
16051 -> 16030;
16052 -> 16030;
16053 -> 16030;
16054 -> 16034;
16054 -> 16053;
16055 -> 16054;
16055 -> 16025;
16055 -> 16053;
16056 -> 16055;
16056 -> 16030;
16057 -> 16051;
16057 -> 16030;
16058 -> 16052;
16058 -> 16030;
16059 -> 16057;
16059 -> 16058;
16059 -> 16056;
16059 -> 16047;
16059 -> 16048;
16059 -> 16025;
16059 -> 16030;
16060 -> 16030;
16061 -> 16059;
16061 -> 16060;
16062 -> 16059;
16062 -> 16060;
16063 -> 16062;
16063 -> 16059;
16063 -> 16061;
16063 -> 16060;
16064 -> 16063;
16064 -> 16030;
16065 -> 16001;
16066 -> 16001;
16066 -> 16064;
16066 -> 16065;
16067 -> 16064;
16067 -> 16001;
16068 -> 15965;
16068 -> 15988;
16069 -> 15963;
16069 -> 16068;
16070 -> 15963;
16070 -> 16066;
16070 -> 16068;
16071 -> 16067;
16071 -> 16068;
16072 -> 15966;
16072 -> 16068;
16073 -> 16068;
16074 -> 16069;
16074 -> 16073;
16075 -> 16070;
16075 -> 16073;
16076 -> 16071;
16076 -> 16073;
16077 -> 16072;
16077 -> 16073;
16078 -> 15967;
16078 -> 16073;
16079 -> 16073;
16080 -> 16075;
16080 -> 16073;
16081 -> 16073;
16082 -> 16075;
16082 -> 16081;
16082 -> 16073;
16083 -> 16073;
16084 -> 16076;
16084 -> 16073;
16085 -> 16084;
16086 -> 16084;
16086 -> 16085;
16087 -> 16086;
16087 -> 16066;
16087 -> 16085;
16088 -> 16087;
16088 -> 16084;
16089 -> 16075;
16089 -> 16073;
16090 -> 16073;
16091 -> 16089;
16091 -> 16090;
16092 -> 16088;
16092 -> 16090;
16093 -> 16091;
16093 -> 16066;
16093 -> 16090;
16094 -> 16091;
16094 -> 16093;
16095 -> 16093;
16096 -> 16094;
16096 -> 16095;
16097 -> 16094;
16097 -> 16095;
16098 -> 16096;
16098 -> 16095;
16099 -> 16095;
16100 -> 16098;
16100 -> 16099;
16101 -> 16097;
16101 -> 16099;
16102 -> 16101;
16102 -> 16094;
16102 -> 16100;
16102 -> 16099;
16103 -> 16099;
16104 -> 16102;
16104 -> 16103;
16105 -> 16102;
16105 -> 16103;
16106 -> 16103;
16107 -> 16103;
16108 -> 16105;
16108 -> 16102;
16108 -> 16103;
16109 -> 16104;
16109 -> 16108;
16110 -> 16108;
16111 -> 16109;
16111 -> 16110;
16112 -> 16111;
16112 -> 16110;
16113 -> 16112;
16114 -> 16112;
16114 -> 16113;
16115 -> 16113;
16115 -> 16112;
16116 -> 16115;
16117 -> 16116;
16117 -> 16106;
16117 -> 16115;
16118 -> 16112;
16118 -> 16115;
16119 -> 16117;
16119 -> 16118;
16119 -> 16116;
16119 -> 16112;
16119 -> 16115;
16120 -> 16119;
16121 -> 10514;
16121 -> 16119;
16122 -> 16103;
16123 -> 16117;
16123 -> 16122;
16123 -> 16103;
16124 -> 16105;
16124 -> 16119;
16124 -> 16123;
16125 -> 16105;
16125 -> 16123;
16126 -> 16117;
16126 -> 16119;
16126 -> 16123;
16127 -> 16123;
16128 -> 16123;
16129 -> 16124;
16129 -> 16128;
16130 -> 16125;
16130 -> 16128;
16131 -> 16126;
16131 -> 16128;
16132 -> 16127;
16132 -> 16128;
16133 -> 16128;
16134 -> 16131;
16134 -> 16126;
16134 -> 16133;
16134 -> 16128;
16135 -> 16128;
16136 -> 16131;
16136 -> 16126;
16136 -> 16135;
16136 -> 16128;
16137 -> 16132;
16137 -> 16135;
16137 -> 16128;
16138 -> 16136;
16138 -> 16137;
16138 -> 16128;
16139 -> 16138;
16139 -> 16128;
16140 -> 16107;
16140 -> 16139;
16140 -> 16123;
16141 -> 16107;
16141 -> 16140;
16141 -> 16103;
16142 -> 16141;
16143 -> 16141;
16143 -> 16142;
16144 -> 16142;
16144 -> 16141;
16145 -> 16141;
16145 -> 16144;
16146 -> 16092;
16146 -> 16145;
16146 -> 16093;
16147 -> 16073;
16148 -> 16146;
16148 -> 16147;
16148 -> 16073;
16149 -> 16146;
16149 -> 16073;
16150 -> 16076;
16150 -> 16073;
16151 -> 16074;
16151 -> 16073;
16152 -> 16077;
16152 -> 16073;
16153 -> 16073;
16154 -> 16073;
16155 -> 16149;
16155 -> 16154;
16156 -> 16150;
16156 -> 16154;
16157 -> 16151;
16157 -> 16154;
16158 -> 16152;
16158 -> 16154;
16159 -> 16153;
16159 -> 16154;
16160 -> 16156;
16160 -> 16154;
16161 -> 16154;
16162 -> 16160;
16162 -> 16161;
16163 -> 16159;
16163 -> 16161;
16164 -> 16161;
16165 -> 16163;
16165 -> 16161;
16166 -> 16163;
16166 -> 16161;
16167 -> 16163;
16167 -> 16161;
16168 -> 16163;
16168 -> 16161;
16169 -> 16163;
16169 -> 16161;
16170 -> 16161;
16171 -> 16162;
16171 -> 16170;
16171 -> 16161;
16172 -> 16162;
16172 -> 16163;
16172 -> 16161;
16173 -> 16162;
16173 -> 16146;
16173 -> 16163;
16173 -> 16161;
16174 -> 16162;
16174 -> 16146;
16174 -> 16163;
16174 -> 16161;
16175 -> 16164;
16175 -> 16163;
16175 -> 16161;
16176 -> 16159;
16176 -> 16154;
16177 -> 16159;
16177 -> 16154;
16178 -> 16159;
16178 -> 16154;
16179 -> 16159;
16179 -> 16154;
16180 -> 16159;
16180 -> 16154;
16181 -> 16154;
16182 -> 16155;
16182 -> 16181;
16182 -> 16154;
16183 -> 16154;
16184 -> 16157;
16184 -> 16183;
16184 -> 16154;
16185 -> 16155;
16185 -> 16159;
16185 -> 16154;
16186 -> 16157;
16186 -> 16159;
16186 -> 16158;
16186 -> 16154;
16187 -> 16186;
16187 -> 16159;
16187 -> 16154;
16188 -> 16158;
16188 -> 16154;
16189 -> 16157;
16189 -> 16146;
16189 -> 16188;
16190 -> 16157;
16190 -> 16189;
16191 -> 16157;
16191 -> 16190;
16192 -> 16191;
16192 -> 16190;
16192 -> 16159;
16193 -> 16153;
16193 -> 16068;
16194 -> 15988;
16195 -> 16194;
16195 -> 16190;
16196 -> 16195;
16196 -> 15988;
16197 -> 15980;
16197 -> 15988;
16198 -> 16193;
16198 -> 15988;
16199 -> 16197;
16199 -> 16198;
16199 -> 16196;
16199 -> 15976;
16199 -> 15977;
16199 -> 16174;
16199 -> 16173;
16199 -> 16172;
16199 -> 16175;
16199 -> 16169;
16199 -> 16185;
16199 -> 16187;
16199 -> 16178;
16199 -> 16179;
16199 -> 16180;
16199 -> 16192;
16199 -> 16190;
16199 -> 16186;
16199 -> 15988;
16200 -> 15988;
16201 -> 16193;
16201 -> 15962;
16202 -> 15929;
16202 -> 16201;
16202 -> 16199;
16202 -> 15928;
16203 -> 15897;
16203 -> 16043;
16203 -> 15926;
16204 -> 16203;
16205 -> 16202;
16205 -> 16204;
16206 -> 16205;
16206 -> 16202;
16206 -> 16204;
16207 -> 16204;
16208 -> 16206;
16208 -> 16207;
16208 -> 16204;
16209 -> 16208;
16209 -> 16204;
16210 -> 16205;
16210 -> 16202;
16210 -> 16209;
16211 -> 16210;
16211 -> 16203;
16212 -> 15896;
16212 -> 16203;
16213 -> 16203;
16214 -> 16212;
16214 -> 16213;
16215 -> 16211;
16215 -> 16213;
16216 -> 16214;
16216 -> 16202;
16216 -> 16210;
16216 -> 16213;
16217 -> 16214;
16217 -> 16202;
16217 -> 16213;
16218 -> 16214;
16218 -> 16213;
16219 -> 16213;
16220 -> 16216;
16220 -> 16219;
16221 -> 16217;
16221 -> 16219;
16222 -> 16216;
16222 -> 16219;
16223 -> 16218;
16223 -> 16219;
16224 -> 16215;
16224 -> 16219;
16225 -> 16222;
16225 -> 16219;
16226 -> 16219;
16227 -> 16225;
16227 -> 16226;
16228 -> 0;
16228 -> 16227;
16229 -> 16220;
16229 -> 16219;
16230 -> 16221;
16230 -> 16219;
16231 -> 16219;
16232 -> 16229;
16232 -> 16231;
16233 -> 16230;
16233 -> 16231;
16234 -> 16224;
16234 -> 16231;
16235 -> 16232;
16235 -> 16231;
16236 -> 16231;
16237 -> 16235;
16237 -> 16236;
16238 -> 16234;
16238 -> 16236;
16239 -> 16236;
16240 -> 16239;
16240 -> 16236;
16241 -> 16236;
16242 -> 16238;
16242 -> 16241;
16243 -> 16241;
16244 -> 16242;
16244 -> 16216;
16244 -> 16243;
16244 -> 16241;
16245 -> 16242;
16245 -> 16216;
16245 -> 16244;
16246 -> 16244;
16247 -> 16246;
16247 -> 16244;
16248 -> 16244;
16249 -> 16247;
16249 -> 16248;
16250 -> 0;
16250 -> 16248;
16251 -> 16249;
16251 -> 16248;
16252 -> 16251;
16252 -> 16216;
16253 -> 16251;
16254 -> 16251;
16255 -> 16252;
16255 -> 16251;
16256 -> 16255;
16257 -> 16255;
16257 -> 16256;
16258 -> 16256;
16258 -> 16255;
16259 -> 16258;
16260 -> 16254;
16260 -> 16258;
16261 -> 16259;
16261 -> 16251;
16262 -> 16254;
16262 -> 16261;
16263 -> 16251;
16263 -> 16216;
16263 -> 16262;
16264 -> 16252;
16264 -> 16216;
16264 -> 16262;
16265 -> 16250;
16265 -> 16263;
16265 -> 16264;
16265 -> 16262;
16266 -> 16264;
16267 -> 16264;
16268 -> 16264;
16269 -> 16250;
16269 -> 16248;
16270 -> 16269;
16270 -> 16244;
16271 -> 16244;
16272 -> 16245;
16272 -> 16270;
16272 -> 16271;
16272 -> 16250;
16272 -> 16264;
16272 -> 16265;
16272 -> 16244;
16273 -> 16242;
16273 -> 16272;
16273 -> 16241;
16274 -> 16273;
16274 -> 16236;
16275 -> 16237;
16275 -> 16236;
16276 -> 16239;
16276 -> 16236;
16277 -> 16274;
16277 -> 16275;
16277 -> 16276;
16277 -> 16272;
16277 -> 16240;
16277 -> 16236;
16278 -> 16277;
16278 -> 16236;
16279 -> 16231;
16280 -> 16233;
16280 -> 16231;
16281 -> 16278;
16281 -> 16279;
16281 -> 16280;
16281 -> 16277;
16281 -> 16231;
16282 -> 16281;
16283 -> 16281;
16284 -> 16282;
16284 -> 16283;
16284 -> 16281;
16285 -> 16281;
16286 -> 16282;
16286 -> 16285;
16287 -> 16286;
16287 -> 16281;
16288 -> 16287;
16288 -> 16228;
16288 -> 16281;
16289 -> 16288;
16290 -> 16223;
16290 -> 16289;
16290 -> 16288;
16291 -> 16290;
16292 -> 16291;
16292 -> 16290;
16293 -> 16292;
16293 -> 16291;
16293 -> 16223;
16294 -> 16292;
16294 -> 16291;
16295 -> 16282;
16295 -> 16293;
16296 -> 15897;
16296 -> 0;
16296 -> 16203;
16297 -> 16295;
16297 -> 16296;
16298 -> 16202;
16298 -> 16296;
16299 -> 16296;
16300 -> 16296;
16301 -> 16297;
16301 -> 16300;
16302 -> 16298;
16302 -> 16300;
16303 -> 16299;
16303 -> 16300;
16304 -> 16299;
16304 -> 16300;
16305 -> 16302;
16305 -> 16300;
16306 -> 16300;
16307 -> 16305;
16307 -> 16306;
16308 -> 16304;
16308 -> 16306;
16309 -> 16306;
16310 -> 16308;
16310 -> 16306;
16311 -> 16308;
16311 -> 16306;
16312 -> 16308;
16312 -> 16306;
16313 -> 16308;
16313 -> 16306;
16314 -> 16308;
16314 -> 16306;
16315 -> 16306;
16316 -> 16307;
16316 -> 16315;
16316 -> 16306;
16317 -> 16307;
16317 -> 16294;
16317 -> 16308;
16317 -> 16306;
16318 -> 16307;
16318 -> 16294;
16318 -> 16308;
16318 -> 16306;
16319 -> 16309;
16319 -> 16308;
16319 -> 16306;
16320 -> 16304;
16320 -> 16300;
16321 -> 16304;
16321 -> 16300;
16322 -> 16304;
16322 -> 16300;
16323 -> 16304;
16323 -> 16300;
16324 -> 16304;
16324 -> 16300;
16325 -> 16300;
16326 -> 16301;
16326 -> 16325;
16326 -> 16300;
16327 -> 16301;
16327 -> 16304;
16327 -> 16300;
16328 -> 2109;
16328 -> 16300;
16329 -> 16328;
16329 -> 16303;
16329 -> 16300;
16330 -> 16329;
16330 -> 16304;
16330 -> 16300;
16331 -> 16296;
16332 -> 15896;
16332 -> 16294;
16332 -> 16331;
16332 -> 16296;
16333 -> 16295;
16333 -> 16332;
16334 -> 16299;
16334 -> 16332;
16335 -> 16332;
16336 -> 16332;
16337 -> 16333;
16337 -> 16336;
16338 -> 16334;
16338 -> 16336;
16339 -> 16335;
16339 -> 16336;
16340 -> 16338;
16340 -> 16336;
16341 -> 16336;
16342 -> 16340;
16342 -> 16341;
16343 -> 16339;
16343 -> 16341;
16344 -> 16342;
16344 -> 16341;
16345 -> 16341;
16346 -> 16344;
16346 -> 16345;
16347 -> 16343;
16347 -> 16345;
16348 -> 16343;
16348 -> 16345;
16349 -> 16343;
16349 -> 16345;
16350 -> 16343;
16350 -> 16345;
16351 -> 16345;
16352 -> 16346;
16352 -> 16351;
16352 -> 16345;
16353 -> 16346;
16353 -> 16317;
16353 -> 16343;
16353 -> 16345;
16354 -> 16346;
16354 -> 16318;
16354 -> 16343;
16354 -> 16345;
16355 -> 16339;
16355 -> 16336;
16356 -> 16339;
16356 -> 16336;
16357 -> 16336;
16358 -> 16337;
16358 -> 16357;
16358 -> 16336;
16359 -> 16337;
16359 -> 16339;
16359 -> 16336;
16360 -> 15896;
16360 -> 16294;
16360 -> 15926;
16361 -> 15926;
16362 -> 16360;
16362 -> 16361;
16363 -> 16335;
16363 -> 16361;
16364 -> 16363;
16364 -> 16353;
16364 -> 16361;
16365 -> 0;
16365 -> 16361;
16366 -> 16361;
16367 -> 16364;
16367 -> 16366;
16368 -> 16365;
16368 -> 16366;
16369 -> 16367;
16369 -> 16368;
16369 -> 16366;
16370 -> 16362;
16370 -> 16361;
16371 -> 16369;
16371 -> 16370;
16371 -> 16361;
16372 -> 16371;
16372 -> 16361;
16373 -> 15926;
16374 -> 16373;
16374 -> 16370;
16375 -> 16374;
16375 -> 15926;
16376 -> 15915;
16376 -> 15926;
16377 -> 16372;
16377 -> 15926;
16378 -> 16376;
16378 -> 16377;
16378 -> 16375;
16378 -> 15913;
16378 -> 15914;
16378 -> 16354;
16378 -> 16353;
16378 -> 16346;
16378 -> 16343;
16378 -> 16359;
16378 -> 16356;
16378 -> 16370;
16378 -> 16318;
16378 -> 16317;
16378 -> 16307;
16378 -> 16319;
16378 -> 16314;
16378 -> 16327;
16378 -> 16321;
16378 -> 16330;
16378 -> 16323;
16378 -> 16324;
16378 -> 16281;
16378 -> 15926;
16379 -> 15926;
16380 -> 16372;
16380 -> 15895;
16381 -> 15875;
16381 -> 16380;
16381 -> 16378;
16381 -> 15872;
16382 -> 15836;
16382 -> 15817;
16383 -> 15747;
16383 -> 15796;
16384 -> 15796;
16385 -> 16383;
16385 -> 16384;
16386 -> 16381;
16386 -> 16384;
16387 -> 16385;
16387 -> 16381;
16387 -> 16384;
16388 -> 16385;
16388 -> 16381;
16388 -> 16384;
16389 -> 16388;
16390 -> 16388;
16391 -> 16389;
16391 -> 16390;
16392 -> 16389;
16392 -> 16390;
16393 -> 16386;
16393 -> 16390;
16394 -> 16391;
16394 -> 16381;
16394 -> 16390;
16395 -> 16390;
16396 -> 16394;
16396 -> 16395;
16397 -> 16393;
16397 -> 16395;
16398 -> 16396;
16398 -> 16381;
16398 -> 16395;
16399 -> 16396;
16399 -> 16381;
16399 -> 16395;
16400 -> 16395;
16401 -> 16399;
16401 -> 16400;
16402 -> 16399;
16402 -> 16400;
16403 -> 16397;
16403 -> 16400;
16404 -> 16401;
16404 -> 16400;
16405 -> 16402;
16405 -> 16400;
16406 -> 16404;
16406 -> 16405;
16406 -> 16398;
16406 -> 16400;
16407 -> 16406;
16407 -> 16400;
16408 -> 16407;
16409 -> 16403;
16409 -> 16406;
16409 -> 16408;
16410 -> 16409;
16410 -> 16407;
16411 -> 0;
16411 -> 16407;
16412 -> 16407;
16413 -> 16403;
16413 -> 16412;
16414 -> 16413;
16414 -> 16410;
16414 -> 16412;
16415 -> 16412;
16416 -> 16413;
16416 -> 16414;
16416 -> 16415;
16417 -> 16416;
16417 -> 16415;
16418 -> 16415;
16419 -> 16417;
16419 -> 16418;
16420 -> 16418;
16421 -> 16419;
16421 -> 16416;
16421 -> 16420;
16422 -> 16421;
16422 -> 16418;
16423 -> 16422;
16424 -> 16423;
16424 -> 16415;
16425 -> 16424;
16425 -> 16415;
16426 -> 16392;
16426 -> 16425;
16426 -> 16390;
16427 -> 16426;
16427 -> 16390;
16428 -> 0;
16429 -> 0;
16431 -> 16428;
16431 -> 16430;
16432 -> 16429;
16432 -> 16430;
16433 -> 16430;
16434 -> 16433;
16434 -> 16430;
16435 -> 16431;
16435 -> 0;
16435 -> 16430;
16436 -> 16431;
16436 -> 0;
16436 -> 16430;
16437 -> 16430;
16438 -> 16431;
16438 -> 16433;
16438 -> 16430;
16439 -> 16432;
16439 -> 16433;
16439 -> 16430;
16440 -> 16430;
16441 -> 0;
16442 -> 0;
16444 -> 16441;
16444 -> 16443;
16445 -> 16442;
16445 -> 16443;
16446 -> 16443;
16447 -> 16446;
16447 -> 16443;
16448 -> 16444;
16448 -> 0;
16448 -> 16443;
16449 -> 16444;
16449 -> 0;
16449 -> 16443;
16450 -> 16443;
16451 -> 0;
16451 -> 16443;
16452 -> 16444;
16452 -> 16451;
16452 -> 16443;
16453 -> 16444;
16453 -> 16446;
16453 -> 16443;
16454 -> 16445;
16454 -> 16446;
16454 -> 16443;
16455 -> 16443;
16456 -> 16455;
16456 -> 16427;
16457 -> 16387;
16457 -> 16456;
16457 -> 16453;
16457 -> 16454;
16457 -> 0;
16457 -> 16388;
16458 -> 16416;
16459 -> 16416;
16460 -> 16416;
16461 -> 16459;
16461 -> 16460;
16462 -> 16460;
16463 -> 16461;
16463 -> 16416;
16463 -> 16462;
16464 -> 16463;
16464 -> 16460;
16465 -> 16464;
16466 -> 16465;
16466 -> 16416;
16467 -> 16466;
16467 -> 16416;
16468 -> 16458;
16468 -> 16467;
16468 -> 16416;
16469 -> 16468;
16469 -> 16416;
16470 -> 16387;
16470 -> 16457;
16470 -> 16384;
16471 -> 16470;
16471 -> 15722;
16471 -> 15739;
16472 -> 15739;
16473 -> 15721;
16473 -> 0;
16473 -> 16472;
16473 -> 15739;
16474 -> 16470;
16474 -> 16473;
16475 -> 16474;
16475 -> 15724;
16476 -> 15738;
16476 -> 15724;
16477 -> 15724;
16478 -> 16475;
16478 -> 16477;
16479 -> 16476;
16479 -> 16477;
16480 -> 15717;
16480 -> 16477;
16481 -> 16477;
16482 -> 16479;
16482 -> 16481;
16482 -> 16477;
16483 -> 16478;
16483 -> 16482;
16484 -> 15717;
16484 -> 15724;
16485 -> 15720;
16485 -> 15724;
16486 -> 16483;
16486 -> 15724;
16487 -> 15724;
16488 -> 16484;
16488 -> 16487;
16489 -> 16485;
16489 -> 16487;
16490 -> 16486;
16490 -> 16487;
16491 -> 16489;
16491 -> 15689;
16491 -> 16487;
16492 -> 16490;
16492 -> 16470;
16492 -> 16491;
16492 -> 16487;
16493 -> 16488;
16493 -> 16487;
16494 -> 16489;
16494 -> 16487;
16495 -> 16490;
16495 -> 16487;
16496 -> 16487;
16497 -> 16493;
16497 -> 16496;
16498 -> 16494;
16498 -> 16496;
16499 -> 16495;
16499 -> 16496;
16500 -> 16499;
16500 -> 16470;
16500 -> 16498;
16500 -> 15689;
16500 -> 16496;
16501 -> 0;
16501 -> 16496;
16502 -> 16498;
16502 -> 16496;
16503 -> 16502;
16504 -> 16499;
16504 -> 16502;
16505 -> 16501;
16505 -> 16502;
16506 -> 0;
16506 -> 16502;
16507 -> 16502;
16508 -> 16503;
16508 -> 16507;
16509 -> 16504;
16509 -> 16507;
16510 -> 16505;
16510 -> 16507;
16511 -> 16506;
16511 -> 16507;
16512 -> 16511;
16512 -> 16507;
16513 -> 16508;
16513 -> 16507;
16514 -> 16512;
16514 -> 16513;
16514 -> 16416;
16514 -> 15689;
16514 -> 16507;
16515 -> 16508;
16515 -> 16507;
16516 -> 16507;
16517 -> 16510;
16517 -> 16515;
16517 -> 16516;
16517 -> 16501;
16517 -> 16514;
16517 -> 16507;
16518 -> 16507;
16519 -> 16508;
16519 -> 16518;
16520 -> 16519;
16520 -> 16517;
16520 -> 16518;
16521 -> 16520;
16521 -> 16507;
16522 -> 16509;
16522 -> 16521;
16522 -> 16470;
16522 -> 16457;
16522 -> 16507;
16523 -> 16507;
16524 -> 16522;
16524 -> 0;
16524 -> 16507;
16525 -> 16507;
16526 -> 16524;
16527 -> 16526;
16527 -> 16524;
16528 -> 16511;
16528 -> 16524;
16529 -> 16508;
16529 -> 16524;
16530 -> 16522;
16530 -> 16524;
16531 -> 16508;
16531 -> 16507;
16532 -> 16523;
16532 -> 16507;
16533 -> 16510;
16533 -> 16531;
16533 -> 16532;
16533 -> 16528;
16533 -> 16507;
16534 -> 16523;
16534 -> 16507;
16535 -> 16534;
16535 -> 16502;
16536 -> 16533;
16537 -> 16536;
16537 -> 16533;
16538 -> 16533;
16539 -> 16533;
16540 -> 16539;
16541 -> 16540;
16541 -> 16539;
16542 -> 16539;
16543 -> 16501;
16543 -> 16496;
16544 -> 16543;
16544 -> 16487;
16545 -> 16488;
16545 -> 16487;
16546 -> 16489;
16546 -> 16487;
16547 -> 16490;
16547 -> 16487;
16548 -> 16487;
16549 -> 16545;
16549 -> 16548;
16550 -> 16546;
16550 -> 16548;
16551 -> 16547;
16551 -> 16548;
16552 -> 16551;
16552 -> 16470;
16552 -> 16550;
16552 -> 15689;
16552 -> 16548;
16553 -> 0;
16553 -> 16548;
16554 -> 16553;
16554 -> 16539;
16554 -> 16548;
16555 -> 16550;
16555 -> 16548;
16556 -> 16555;
16557 -> 16551;
16557 -> 16555;
16558 -> 16554;
16558 -> 16555;
16559 -> 0;
16559 -> 16555;
16560 -> 16555;
16561 -> 16556;
16561 -> 16560;
16562 -> 16557;
16562 -> 16560;
16563 -> 16558;
16563 -> 16560;
16564 -> 16559;
16564 -> 16560;
16565 -> 16564;
16565 -> 16560;
16566 -> 16561;
16566 -> 16560;
16567 -> 16565;
16567 -> 16566;
16567 -> 16554;
16567 -> 15689;
16567 -> 16560;
16568 -> 16561;
16568 -> 16560;
16569 -> 16560;
16570 -> 16563;
16570 -> 16568;
16570 -> 16569;
16570 -> 16567;
16570 -> 16560;
16571 -> 16560;
16572 -> 16561;
16572 -> 16571;
16573 -> 16572;
16573 -> 16570;
16573 -> 16571;
16574 -> 16573;
16574 -> 16560;
16575 -> 16562;
16575 -> 16574;
16575 -> 16470;
16575 -> 16539;
16575 -> 16560;
16576 -> 16560;
16577 -> 16560;
16578 -> 16561;
16578 -> 16577;
16579 -> 16578;
16579 -> 16570;
16579 -> 16577;
16580 -> 16579;
16580 -> 16560;
16581 -> 16564;
16581 -> 16560;
16582 -> 16561;
16582 -> 16560;
16583 -> 16581;
16583 -> 16582;
16583 -> 16570;
16583 -> 16560;
16584 -> 16575;
16584 -> 16560;
16585 -> 16561;
16585 -> 16560;
16586 -> 16576;
16586 -> 16560;
16587 -> 16563;
16587 -> 16585;
16587 -> 16586;
16587 -> 16583;
16587 -> 16560;
16588 -> 16576;
16588 -> 16560;
16589 -> 16588;
16589 -> 16555;
16590 -> 16551;
16590 -> 16587;
16591 -> 16587;
16592 -> 16591;
16592 -> 16587;
16593 -> 16590;
16593 -> 16592;
16593 -> 16470;
16593 -> 16575;
16593 -> 16587;
16594 -> 16587;
16595 -> 16594;
16595 -> 16587;
16596 -> 16593;
16596 -> 16587;
16597 -> 16587;
16598 -> 16597;
16598 -> 16591;
16599 -> 16598;
16599 -> 16587;
16600 -> 16590;
16600 -> 16599;
16600 -> 16470;
16600 -> 16593;
16600 -> 16587;
16601 -> 16597;
16601 -> 16594;
16602 -> 16601;
16602 -> 16587;
16603 -> 16600;
16603 -> 16587;
16604 -> 16554;
16604 -> 16548;
16605 -> 16604;
16605 -> 16487;
16606 -> 16487;
16607 -> 16487;
16608 -> 16607;
16608 -> 16491;
16608 -> 16487;
16609 -> 16490;
16609 -> 16607;
16609 -> 16470;
16609 -> 16600;
16609 -> 16608;
16610 -> 16489;
16610 -> 16607;
16610 -> 15689;
16610 -> 16597;
16610 -> 16608;
16611 -> 16609;
16611 -> 16608;
16612 -> 0;
16612 -> 16608;
16613 -> 16611;
16613 -> 16612;
16613 -> 16608;
16614 -> 16608;
16615 -> 16611;
16615 -> 0;
16615 -> 16608;
16616 -> 16608;
16617 -> 16544;
16617 -> 16610;
16617 -> 16608;
16618 -> 16615;
16618 -> 16617;
16618 -> 16608;
16619 -> 16605;
16619 -> 16610;
16619 -> 16617;
16619 -> 16608;
16620 -> 16609;
16620 -> 16611;
16620 -> 16608;
16621 -> 16615;
16621 -> 16619;
16621 -> 16608;
16622 -> 16487;
16623 -> 16606;
16623 -> 16622;
16623 -> 16487;
16624 -> 16490;
16624 -> 16487;
16625 -> 16624;
16625 -> 15724;
16626 -> 0;
16626 -> 15724;
16627 -> 16625;
16627 -> 16626;
16627 -> 16609;
16627 -> 15724;
16628 -> 15738;
16628 -> 15724;
16629 -> 16624;
16629 -> 15716;
16630 -> 15716;
16631 -> 16629;
16631 -> 16630;
16631 -> 16609;
16631 -> 16627;
16631 -> 15716;
16632 -> 16631;
16632 -> 15714;
16633 -> 15715;
16633 -> 16632;
16633 -> 16631;
16633 -> 16619;
16633 -> 15689;
16633 -> 15714;
16634 -> 15712;
16634 -> 16633;
16634 -> 15714;
16635 -> 16634;
16635 -> 15711;
16636 -> 16635;
16636 -> 15710;
16637 -> 15710;
16638 -> 15708;
16638 -> 16633;
16638 -> 15710;
16639 -> 16637;
16639 -> 15710;
16640 -> 15710;
16641 -> 16639;
16641 -> 16640;
16642 -> 15708;
16642 -> 16640;
16643 -> 16640;
16644 -> 16642;
16644 -> 16643;
16645 -> 16644;
16645 -> 16633;
16645 -> 16643;
16646 -> 16644;
16646 -> 16633;
16646 -> 16643;
16647 -> 16646;
16647 -> 16640;
16648 -> 0;
16648 -> 16640;
16649 -> 16647;
16649 -> 16633;
16649 -> 16640;
16650 -> 16640;
16651 -> 16649;
16651 -> 16650;
16651 -> 16640;
16652 -> 16651;
16653 -> 16652;
16654 -> 16652;
16655 -> 16654;
16655 -> 16651;
16656 -> 16651;
16657 -> 16642;
16657 -> 16652;
16657 -> 16651;
16658 -> 16657;
16658 -> 16652;
16659 -> 16657;
16660 -> 16658;
16660 -> 16659;
16660 -> 16652;
16660 -> 16657;
16661 -> 16657;
16662 -> 16660;
16662 -> 16661;
16663 -> 16659;
16663 -> 16661;
16664 -> 16655;
16664 -> 16657;
16665 -> 16657;
16666 -> 16665;
16667 -> 16665;
16667 -> 16666;
16668 -> 16666;
16668 -> 16665;
16669 -> 16665;
16669 -> 16662;
16670 -> 16669;
16670 -> 16657;
16671 -> 16658;
16671 -> 16662;
16671 -> 16657;
16672 -> 16657;
16673 -> 16657;
16674 -> 16671;
16674 -> 16673;
16675 -> 16672;
16675 -> 16673;
16676 -> 16670;
16676 -> 16673;
16677 -> 16675;
16677 -> 16673;
16678 -> 16673;
16679 -> 16676;
16679 -> 16678;
16679 -> 16673;
16680 -> 16657;
16681 -> 16657;
16682 -> 16681;
16682 -> 16657;
16683 -> 16657;
16684 -> 16662;
16684 -> 16683;
16684 -> 16657;
16685 -> 16684;
16686 -> 16662;
16686 -> 16676;
16686 -> 16685;
16686 -> 16684;
16687 -> 16684;
16688 -> 16686;
16688 -> 16687;
16689 -> 16685;
16689 -> 16687;
16690 -> 16685;
16690 -> 16687;
16691 -> 16676;
16691 -> 16687;
16692 -> 16691;
16692 -> 16686;
16692 -> 0;
16692 -> 16687;
16693 -> 16687;
16694 -> 16688;
16694 -> 16693;
16694 -> 16687;
16695 -> 16690;
16695 -> 16687;
16696 -> 16691;
16696 -> 16686;
16696 -> 16687;
16697 -> 16687;
16698 -> 16687;
16699 -> 16689;
16699 -> 16698;
16700 -> 16697;
16700 -> 16698;
16701 -> 16700;
16701 -> 16698;
16702 -> 16699;
16702 -> 16701;
16703 -> 16689;
16703 -> 16697;
16703 -> 16687;
16704 -> 16690;
16704 -> 16697;
16704 -> 16687;
16705 -> 16043;
16705 -> 16687;
16706 -> 16696;
16706 -> 16687;
16707 -> 16687;
16708 -> 16662;
16708 -> 16684;
16709 -> 16684;
16710 -> 16708;
16710 -> 16709;
16711 -> 16688;
16711 -> 16709;
16712 -> 16710;
16712 -> 16688;
16712 -> 16709;
16713 -> 16710;
16713 -> 16688;
16713 -> 16709;
16714 -> 16712;
16714 -> 16649;
16714 -> 16657;
16715 -> 16657;
16716 -> 16648;
16716 -> 0;
16716 -> 16715;
16716 -> 16657;
16717 -> 16712;
16717 -> 16716;
16718 -> 16717;
16718 -> 16651;
16719 -> 16656;
16719 -> 16651;
16720 -> 16641;
16720 -> 16651;
16721 -> 16651;
16722 -> 16718;
16722 -> 16721;
16723 -> 16719;
16723 -> 16721;
16724 -> 16720;
16724 -> 16721;
16725 -> 16642;
16725 -> 16721;
16726 -> 16721;
16727 -> 16723;
16727 -> 16726;
16727 -> 16721;
16728 -> 16722;
16728 -> 16727;
16729 -> 16728;
16729 -> 16651;
16730 -> 16651;
16731 -> 0;
16731 -> 16729;
16732 -> 16656;
16732 -> 16651;
16733 -> 16731;
16733 -> 16640;
16734 -> 16640;
16735 -> 16733;
16735 -> 15710;
16736 -> 16637;
16736 -> 16735;
16737 -> 16735;
16738 -> 16736;
16738 -> 16737;
16739 -> 15708;
16739 -> 16737;
16740 -> 16737;
16741 -> 16739;
16741 -> 16740;
16742 -> 16741;
16742 -> 16737;
16743 -> 16738;
16743 -> 16637;
16743 -> 16737;
16744 -> 16735;
16745 -> 16637;
16745 -> 15710;
16746 -> 15708;
16746 -> 16735;
16746 -> 15710;
16747 -> 16746;
16747 -> 15707;
16748 -> 16747;
16748 -> 15704;
16749 -> 15704;
16750 -> 16748;
16750 -> 16735;
16750 -> 16749;
16750 -> 15704;
16751 -> 16750;
16751 -> 15704;
16752 -> 16751;
16752 -> 15696;
16753 -> 15696;
16754 -> 15699;
16754 -> 16753;
16755 -> 16753;
16756 -> 16754;
16756 -> 16755;
16757 -> 16756;
16757 -> 16735;
16757 -> 16755;
16758 -> 16757;
16758 -> 16753;
16759 -> 16753;
16760 -> 16758;
16760 -> 16759;
16761 -> 16754;
16761 -> 16735;
16761 -> 16759;
16762 -> 16759;
16763 -> 16761;
16763 -> 16762;
16764 -> 16763;
16764 -> 16762;
16765 -> 16764;
16765 -> 16759;
16766 -> 16759;
16767 -> 16765;
16767 -> 16735;
16767 -> 16766;
16767 -> 16759;
16768 -> 16767;
16768 -> 16759;
16769 -> 16765;
16769 -> 16760;
16769 -> 16735;
16769 -> 16768;
16770 -> 16769;
16770 -> 15696;
16771 -> 16752;
16771 -> 0;
16771 -> 16770;
16771 -> 15696;
16772 -> 15699;
16772 -> 15696;
16773 -> 15696;
16774 -> 15699;
16774 -> 16773;
16775 -> 16773;
16776 -> 16774;
16776 -> 16775;
16777 -> 16776;
16777 -> 16769;
16777 -> 16775;
16778 -> 16777;
16778 -> 16773;
16779 -> 16773;
16780 -> 16778;
16780 -> 16779;
16780 -> 16773;
16781 -> 16780;
16781 -> 16773;
16782 -> 16781;
16783 -> 16782;
16784 -> 16782;
16785 -> 16783;
16785 -> 16769;
16785 -> 16784;
16786 -> 16785;
16786 -> 15696;
16787 -> 15696;
16788 -> 16786;
16788 -> 16787;
16789 -> 15697;
16789 -> 15696;
16790 -> 16789;
16790 -> 16772;
16790 -> 16769;
16790 -> 15696;
16791 -> 16752;
16791 -> 15696;
16792 -> 15696;
16793 -> 15696;
16794 -> 15699;
16794 -> 16793;
16795 -> 16793;
16796 -> 16794;
16796 -> 16795;
16797 -> 0;
16797 -> 16795;
16798 -> 16797;
16798 -> 16793;
16799 -> 16794;
16799 -> 16790;
16799 -> 16793;
16800 -> 15698;
16800 -> 15696;
16801 -> 15696;
16802 -> 16772;
16802 -> 16801;
16803 -> 16788;
16803 -> 16801;
16804 -> 16790;
16804 -> 16801;
16805 -> 16791;
16805 -> 16801;
16806 -> 16792;
16806 -> 16801;
16807 -> 16799;
16807 -> 16801;
16808 -> 16800;
16808 -> 16801;
16809 -> 16801;
16810 -> 16801;
16811 -> 16802;
16811 -> 16801;
16812 -> 16803;
16812 -> 16801;
16813 -> 16804;
16813 -> 16801;
16814 -> 16805;
16814 -> 16801;
16815 -> 16806;
16815 -> 16801;
16816 -> 16807;
16816 -> 16801;
16817 -> 16809;
16817 -> 16801;
16818 -> 16810;
16818 -> 16801;
16819 -> 16801;
16820 -> 16811;
16820 -> 16819;
16821 -> 16812;
16821 -> 16819;
16822 -> 16813;
16822 -> 16819;
16823 -> 16814;
16823 -> 16819;
16824 -> 16815;
16824 -> 16819;
16825 -> 16816;
16825 -> 16819;
16826 -> 16817;
16826 -> 16819;
16827 -> 16818;
16827 -> 16819;
16828 -> 16819;
16829 -> 16825;
16829 -> 16828;
16829 -> 16819;
16830 -> 16825;
16830 -> 16819;
16831 -> 16819;
16832 -> 16830;
16832 -> 16831;
16833 -> 16820;
16833 -> 16831;
16834 -> 16831;
16835 -> 16832;
16835 -> 16834;
16835 -> 16831;
16836 -> 16831;
16837 -> 16833;
16837 -> 16836;
16838 -> 16836;
16839 -> 16837;
16839 -> 16838;
16840 -> 0;
16840 -> 16838;
16841 -> 16840;
16841 -> 16836;
16842 -> 16837;
16842 -> 16790;
16842 -> 16836;
16843 -> 16842;
16843 -> 16831;
16844 -> 16832;
16844 -> 16843;
16844 -> 16831;
16845 -> 16819;
16846 -> 16845;
16846 -> 16819;
16847 -> 16819;
16848 -> 16820;
16848 -> 16847;
16849 -> 16847;
16850 -> 16848;
16850 -> 16849;
16851 -> 16849;
16852 -> 16850;
16852 -> 16851;
16853 -> 16852;
16853 -> 16790;
16853 -> 16851;
16854 -> 16849;
16855 -> 16850;
16855 -> 16790;
16855 -> 16854;
16856 -> 16854;
16857 -> 16854;
16858 -> 16855;
16858 -> 16847;
16859 -> 16858;
16859 -> 0;
16859 -> 16847;
16860 -> 16847;
16861 -> 16859;
16861 -> 16819;
16862 -> 16819;
16863 -> 16861;
16863 -> 16862;
16864 -> 16821;
16864 -> 16862;
16865 -> 16864;
16865 -> 16855;
16865 -> 16862;
16866 -> 16862;
16867 -> 16865;
16867 -> 16866;
16868 -> 16867;
16868 -> 16862;
16869 -> 16868;
16870 -> 16868;
16870 -> 16869;
16871 -> 16869;
16872 -> 16870;
16872 -> 16871;
16873 -> 16871;
16874 -> 16872;
16874 -> 16855;
16874 -> 16873;
16874 -> 16871;
16875 -> 16869;
16876 -> 16870;
16876 -> 16855;
16876 -> 16869;
16877 -> 16876;
16877 -> 16868;
16878 -> 16868;
16879 -> 16862;
16880 -> 16865;
16880 -> 16855;
16880 -> 16879;
16880 -> 16862;
16881 -> 16865;
16881 -> 16855;
16881 -> 16863;
16881 -> 16862;
16882 -> 16865;
16882 -> 16855;
16882 -> 16863;
16882 -> 16862;
16883 -> 16882;
16883 -> 16819;
16884 -> 16819;
16885 -> 16823;
16885 -> 0;
16885 -> 16884;
16885 -> 16819;
16886 -> 10492;
16886 -> 16885;
16887 -> 16819;
16888 -> 16882;
16888 -> 16887;
16889 -> 16888;
16889 -> 16819;
16890 -> 16819;
16891 -> 16823;
16891 -> 0;
16891 -> 16890;
16891 -> 16819;
16892 -> 16819;
16893 -> 16883;
16893 -> 16892;
16894 -> 16893;
16894 -> 16819;
16895 -> 16891;
16895 -> 16894;
16895 -> 16819;
16896 -> 16895;
16897 -> 16896;
16897 -> 16895;
16898 -> 16895;
16899 -> 16886;
16899 -> 0;
16899 -> 16898;
16899 -> 16895;
16900 -> 16895;
16901 -> 16801;
16902 -> 16827;
16902 -> 16901;
16902 -> 16801;
16903 -> 16809;
16903 -> 16801;
16904 -> 16809;
16904 -> 16801;
16905 -> 16900;
16905 -> 16801;
16906 -> 15685;
16906 -> 16855;
16906 -> 15692;
16907 -> 16905;
16907 -> 15692;
16908 -> 15478;
16908 -> 15692;
16909 -> 15693;
16909 -> 16907;
16910 -> 16907;
16911 -> 16909;
16911 -> 16910;
16912 -> 15685;
16912 -> 16910;
16913 -> 16910;
16914 -> 16912;
16914 -> 16913;
16915 -> 16913;
16916 -> 0;
16916 -> 16913;
16917 -> 16913;
16918 -> 16916;
16918 -> 16917;
16919 -> 16914;
16919 -> 16917;
16920 -> 16918;
16920 -> 16919;
16920 -> 16907;
16920 -> 16917;
16921 -> 16919;
16921 -> 16920;
16921 -> 16917;
16922 -> 16917;
16923 -> 16921;
16923 -> 16922;
16923 -> 16917;
16924 -> 16923;
16924 -> 16917;
16925 -> 16924;
16925 -> 16910;
16926 -> 16910;
16927 -> 16925;
16927 -> 0;
16927 -> 16926;
16927 -> 16910;
16928 -> 16927;
16929 -> 16907;
16930 -> 15693;
16930 -> 16907;
16931 -> 16907;
16932 -> 16930;
16932 -> 16931;
16933 -> 15685;
16933 -> 16931;
16934 -> 16931;
16935 -> 16933;
16935 -> 16934;
16936 -> 16934;
16937 -> 16935;
16937 -> 16936;
16938 -> 16937;
16938 -> 16920;
16938 -> 16936;
16939 -> 16937;
16939 -> 16920;
16939 -> 16936;
16940 -> 16939;
16940 -> 16934;
16941 -> 16940;
16941 -> 0;
16941 -> 16934;
16942 -> 16934;
16943 -> 16941;
16943 -> 16931;
16944 -> 16907;
16945 -> 15693;
16945 -> 16907;
16946 -> 16907;
16947 -> 16945;
16947 -> 16946;
16948 -> 15685;
16948 -> 16946;
16949 -> 16946;
16950 -> 16948;
16950 -> 16949;
16951 -> 16950;
16951 -> 16939;
16951 -> 16949;
16952 -> 16949;
16953 -> 0;
16953 -> 16949;
16954 -> 16949;
16955 -> 16953;
16955 -> 16954;
16956 -> 16950;
16956 -> 16954;
16957 -> 16955;
16957 -> 16956;
16957 -> 16939;
16957 -> 16954;
16958 -> 16956;
16958 -> 16957;
16958 -> 16954;
16959 -> 16954;
16960 -> 16958;
16960 -> 16959;
16960 -> 16954;
16961 -> 16960;
16961 -> 16954;
16962 -> 16961;
16962 -> 16946;
16963 -> 16946;
16964 -> 16946;
16965 -> 16948;
16965 -> 16964;
16966 -> 16964;
16967 -> 16965;
16967 -> 16966;
16968 -> 16966;
16969 -> 16967;
16969 -> 16968;
16970 -> 0;
16970 -> 16968;
16971 -> 16970;
16971 -> 16966;
16972 -> 16967;
16972 -> 16957;
16972 -> 16966;
16973 -> 16972;
16973 -> 16964;
16974 -> 16965;
16974 -> 16964;
16975 -> 16964;
16976 -> 16974;
16976 -> 16975;
16977 -> 16973;
16977 -> 16975;
16978 -> 16976;
16978 -> 16975;
16979 -> 16978;
16979 -> 16957;
16979 -> 16975;
16980 -> 16975;
16981 -> 16976;
16981 -> 16980;
16982 -> 16981;
16982 -> 16980;
16983 -> 16980;
16984 -> 16982;
16984 -> 16983;
16985 -> 16984;
16985 -> 16983;
16986 -> 16985;
16986 -> 16980;
16987 -> 16986;
16987 -> 16975;
16988 -> 16975;
16989 -> 16976;
16989 -> 16988;
16990 -> 16989;
16990 -> 16979;
16990 -> 16988;
16991 -> 16990;
16991 -> 16975;
16992 -> 16975;
16993 -> 16977;
16993 -> 16992;
16994 -> 16992;
16995 -> 16993;
16995 -> 16994;
16996 -> 16995;
16996 -> 16979;
16996 -> 16994;
16997 -> 16995;
16997 -> 16979;
16997 -> 16994;
16998 -> 16997;
16998 -> 16994;
16999 -> 16995;
16999 -> 16979;
16999 -> 16994;
17000 -> 16999;
17000 -> 16992;
17001 -> 16992;
17002 -> 17000;
17002 -> 17001;
17003 -> 16992;
17004 -> 17002;
17004 -> 16975;
17005 -> 16975;
17006 -> 16991;
17006 -> 17005;
17007 -> 17004;
17007 -> 17005;
17008 -> 17007;
17008 -> 17005;
17009 -> 17006;
17009 -> 17007;
17009 -> 17005;
17010 -> 16991;
17010 -> 17004;
17010 -> 16975;
17011 -> 16975;
17012 -> 16977;
17012 -> 17011;
17013 -> 17012;
17013 -> 17002;
17013 -> 17011;
17014 -> 17013;
17015 -> 17014;
17015 -> 17013;
17016 -> 17013;
17017 -> 17015;
17017 -> 17016;
17017 -> 17013;
17018 -> 17017;
17018 -> 17013;
17019 -> 17018;
17019 -> 17012;
17019 -> 17013;
17020 -> 17012;
17020 -> 17017;
17020 -> 17019;
17020 -> 17011;
17021 -> 17020;
17021 -> 16975;
17022 -> 17021;
17023 -> 16964;
17024 -> 16965;
17024 -> 17023;
17025 -> 17023;
17026 -> 17024;
17026 -> 17025;
17027 -> 17026;
17027 -> 17017;
17027 -> 17025;
17028 -> 17026;
17028 -> 17017;
17028 -> 17025;
17029 -> 17028;
17029 -> 17027;
17029 -> 17017;
17029 -> 17019;
17030 -> 17029;
17030 -> 17023;
17031 -> 17030;
17031 -> 0;
17031 -> 17023;
17032 -> 17023;
17033 -> 17031;
17033 -> 16964;
17034 -> 16964;
17035 -> 16965;
17035 -> 17034;
17036 -> 17035;
17036 -> 17029;
17036 -> 17034;
17037 -> 17034;
17038 -> 0;
17038 -> 17034;
17039 -> 17034;
17040 -> 17038;
17040 -> 17039;
17041 -> 17035;
17041 -> 17039;
17042 -> 17040;
17042 -> 17041;
17042 -> 17029;
17042 -> 17039;
17043 -> 17041;
17043 -> 17042;
17043 -> 17039;
17044 -> 17039;
17045 -> 17043;
17045 -> 17044;
17045 -> 17039;
17046 -> 17045;
17046 -> 17039;
17047 -> 17046;
17047 -> 16964;
17048 -> 16964;
17049 -> 16964;
17050 -> 16965;
17050 -> 17049;
17051 -> 17049;
17052 -> 17050;
17052 -> 17051;
17053 -> 17052;
17053 -> 17042;
17053 -> 17051;
17054 -> 17052;
17054 -> 17042;
17054 -> 17051;
17055 -> 17054;
17055 -> 17049;
17056 -> 17055;
17056 -> 0;
17056 -> 17049;
17057 -> 17049;
17058 -> 17056;
17058 -> 16964;
17059 -> 16964;
17060 -> 16965;
17060 -> 17059;
17061 -> 17059;
17062 -> 17060;
17062 -> 17061;
17063 -> 17062;
17063 -> 17054;
17063 -> 17061;
17064 -> 17062;
17064 -> 17054;
17064 -> 17061;
17065 -> 17064;
17065 -> 17059;
17066 -> 17065;
17066 -> 0;
17066 -> 17059;
17067 -> 17059;
17068 -> 17066;
17068 -> 16964;
17069 -> 16964;
17070 -> 16965;
17070 -> 17069;
17071 -> 17070;
17071 -> 17064;
17071 -> 17069;
17072 -> 17070;
17072 -> 17064;
17072 -> 17069;
17073 -> 17072;
17073 -> 16964;
17074 -> 17068;
17074 -> 17073;
17074 -> 16964;
17075 -> 16964;
17076 -> 16965;
17076 -> 17075;
17077 -> 17076;
17077 -> 17072;
17077 -> 17075;
17078 -> 17075;
17079 -> 0;
17079 -> 17075;
17080 -> 17075;
17081 -> 17079;
17081 -> 17080;
17082 -> 17076;
17082 -> 17080;
17083 -> 17081;
17083 -> 17082;
17083 -> 17072;
17083 -> 17080;
17084 -> 17082;
17084 -> 17083;
17084 -> 17080;
17085 -> 17080;
17086 -> 17084;
17086 -> 17085;
17086 -> 17080;
17087 -> 17086;
17087 -> 17080;
17088 -> 17087;
17088 -> 16964;
17089 -> 17074;
17089 -> 17088;
17089 -> 0;
17089 -> 16964;
17090 -> 16964;
17091 -> 16965;
17091 -> 17090;
17092 -> 17090;
17093 -> 17091;
17093 -> 17092;
17094 -> 17093;
17094 -> 17083;
17094 -> 17092;
17095 -> 17093;
17095 -> 17083;
17095 -> 17092;
17096 -> 17095;
17096 -> 17090;
17097 -> 17090;
17098 -> 17096;
17099 -> 17098;
17099 -> 16964;
17100 -> 16964;
17101 -> 17089;
17101 -> 17099;
17101 -> 16964;
17102 -> 17101;
17102 -> 16946;
17103 -> 16907;
17104 -> 15693;
17104 -> 16907;
17105 -> 16907;
17106 -> 17104;
17106 -> 17105;
17107 -> 15685;
17107 -> 17105;
17108 -> 17105;
17109 -> 17107;
17109 -> 17108;
17110 -> 17109;
17110 -> 17095;
17110 -> 17108;
17111 -> 17110;
17111 -> 17105;
17112 -> 17107;
17112 -> 17111;
17113 -> 17111;
17114 -> 17111;
17115 -> 17112;
17115 -> 17114;
17116 -> 17113;
17116 -> 17114;
17117 -> 17111;
17117 -> 17114;
17118 -> 17115;
17118 -> 17114;
17119 -> 17115;
17119 -> 17118;
17120 -> 17116;
17120 -> 17119;
17121 -> 17119;
17122 -> 17106;
17122 -> 15693;
17122 -> 17105;
17123 -> 16907;
17124 -> 0;
17124 -> 16907;
17125 -> 16907;
17126 -> 17124;
17126 -> 17125;
17127 -> 15685;
17127 -> 17095;
17127 -> 17125;
17128 -> 17127;
17128 -> 17126;
17128 -> 17125;
17129 -> 15693;
17129 -> 15692;
17130 -> 15685;
17130 -> 17095;
17130 -> 15683;
17131 -> 15679;
17132 -> 17130;
17132 -> 17131;
17132 -> 15679;
17133 -> 17132;
17133 -> 15679;
17134 -> 17128;
17135 -> 17134;
17135 -> 17128;
17136 -> 17128;
17137 -> 17136;
17137 -> 17128;
17138 -> 17133;
17138 -> 17128;
17139 -> 17136;
17139 -> 17128;
17140 -> 17138;
17140 -> 0;
17140 -> 17139;
17140 -> 17128;
17141 -> 17128;
17142 -> 17141;
17143 -> 17141;
17143 -> 17142;
17144 -> 0;
17144 -> 17142;
17145 -> 17144;
17145 -> 17141;
17146 -> 17141;
17146 -> 17136;
17147 -> 17136;
17147 -> 17128;
17148 -> 17136;
17148 -> 17128;
17149 -> 17146;
17149 -> 17128;
17150 -> 17135;
17150 -> 17128;
17151 -> 17128;
17152 -> 17128;
17153 -> 17147;
17153 -> 17128;
17154 -> 17148;
17154 -> 17128;
17155 -> 17149;
17155 -> 17128;
17156 -> 17151;
17156 -> 17128;
17157 -> 17152;
17157 -> 17128;
17158 -> 17128;
17159 -> 17155;
17159 -> 17158;
17159 -> 17128;
17160 -> 17155;
17160 -> 17128;
17161 -> 17128;
17162 -> 17160;
17162 -> 17161;
17163 -> 17128;
17163 -> 17161;
17164 -> 17161;
17165 -> 17162;
17165 -> 17164;
17165 -> 17161;
17166 -> 17161;
17167 -> 17163;
17167 -> 17166;
17168 -> 17166;
17169 -> 17167;
17169 -> 17168;
17170 -> 0;
17170 -> 17168;
17171 -> 17170;
17171 -> 17166;
17172 -> 17167;
17172 -> 17136;
17172 -> 17166;
17173 -> 17172;
17173 -> 17161;
17174 -> 17162;
17174 -> 17173;
17174 -> 17161;
17175 -> 17128;
17176 -> 17175;
17176 -> 17128;
17177 -> 17128;
17178 -> 17136;
17178 -> 17177;
17179 -> 17178;
17179 -> 17128;
17180 -> 17179;
17181 -> 17179;
17181 -> 17180;
17182 -> 17180;
17183 -> 17181;
17183 -> 17182;
17184 -> 17182;
17185 -> 17183;
17185 -> 17136;
17185 -> 17184;
17185 -> 17182;
17186 -> 17180;
17187 -> 17181;
17187 -> 17136;
17187 -> 17180;
17188 -> 17187;
17188 -> 17179;
17189 -> 17179;
17190 -> 17128;
17191 -> 17136;
17191 -> 17190;
17191 -> 17128;
17192 -> 17136;
17192 -> 17128;
17193 -> 17128;
17194 -> 17138;
17194 -> 0;
17194 -> 17193;
17194 -> 17128;
17195 -> 10492;
17195 -> 17194;
17196 -> 17128;
17197 -> 17136;
17197 -> 17196;
17198 -> 17197;
17198 -> 17128;
17199 -> 17138;
17199 -> 17136;
17199 -> 17128;
17200 -> 17199;
17201 -> 17200;
17201 -> 17199;
17202 -> 17199;
17203 -> 17195;
17203 -> 0;
17203 -> 17202;
17203 -> 17199;
17204 -> 17128;
17205 -> 17157;
17205 -> 17204;
17205 -> 17128;
17206 -> 17151;
17206 -> 17128;
17207 -> 17151;
17207 -> 17128;
17208 -> 17134;
17208 -> 17199;
17209 -> 17208;
17209 -> 17199;
17210 -> 17199;
17211 -> 17199;
17212 -> 17199;
17213 -> 17211;
17213 -> 0;
17213 -> 17212;
17213 -> 17199;
17214 -> 17213;
17215 -> 17199;
17216 -> 17134;
17216 -> 17199;
17217 -> 17216;
17217 -> 17199;
17218 -> 17199;
17219 -> 17218;
17219 -> 0;
17219 -> 17199;
17220 -> 17199;
17221 -> 17219;
17221 -> 17199;
17222 -> 17199;
17223 -> 17134;
17223 -> 17199;
17224 -> 17223;
17224 -> 17199;
17225 -> 17199;
17226 -> 17199;
17227 -> 17199;
17227 -> 17226;
17228 -> 0;
17228 -> 17226;
17229 -> 17228;
17229 -> 17199;
17230 -> 17199;
17231 -> 17230;
17232 -> 17230;
17233 -> 17231;
17233 -> 17232;
17234 -> 17233;
17234 -> 17232;
17235 -> 17234;
17235 -> 17230;
17236 -> 17235;
17236 -> 17199;
17237 -> 17199;
17238 -> 17237;
17238 -> 17199;
17239 -> 17199;
17240 -> 17199;
17241 -> 17199;
17242 -> 17238;
17242 -> 17241;
17243 -> 17240;
17243 -> 17241;
17244 -> 17243;
17244 -> 17241;
17245 -> 17242;
17245 -> 17243;
17245 -> 17241;
17246 -> 17199;
17247 -> 17246;
17247 -> 17199;
17248 -> 17247;
17249 -> 17199;
17250 -> 17249;
17250 -> 0;
17250 -> 17199;
17251 -> 17199;
17252 -> 17250;
17252 -> 17199;
17253 -> 17199;
17254 -> 17199;
17255 -> 17254;
17255 -> 0;
17255 -> 17199;
17256 -> 17199;
17257 -> 17255;
17257 -> 17199;
17258 -> 17250;
17258 -> 17199;
17259 -> 17199;
17260 -> 17199;
17261 -> 17260;
17262 -> 17261;
17262 -> 17199;
17263 -> 17258;
17263 -> 17262;
17263 -> 17199;
17264 -> 17263;
17264 -> 17199;
17265 -> 17199;
17266 -> 17134;
17266 -> 17199;
17267 -> 17199;
17268 -> 17266;
17268 -> 17267;
17269 -> 17128;
17269 -> 17267;
17270 -> 17267;
17271 -> 17269;
17271 -> 17270;
17272 -> 17271;
17272 -> 17267;
17273 -> 17269;
17273 -> 17272;
17274 -> 17272;
17275 -> 17272;
17276 -> 17273;
17276 -> 17275;
17277 -> 17274;
17277 -> 17275;
17278 -> 17272;
17278 -> 17275;
17279 -> 17276;
17279 -> 17275;
17280 -> 17276;
17280 -> 17279;
17281 -> 17277;
17281 -> 17280;
17282 -> 17280;
17283 -> 17268;
17283 -> 17134;
17283 -> 17267;
17284 -> 17199;
17285 -> 17134;
17285 -> 17128;
17286 -> 17128;
17287 -> 17199;
17288 -> 17287;
17288 -> 17199;
17289 -> 17199;
17290 -> 17199;
17291 -> 17199;
17292 -> 17291;
17293 -> 17291;
17293 -> 17292;
17294 -> 0;
17294 -> 17292;
17295 -> 17294;
17295 -> 17291;
17296 -> 17291;
17296 -> 17237;
17297 -> 17237;
17297 -> 17199;
17298 -> 17237;
17298 -> 17199;
17299 -> 17296;
17299 -> 17199;
17300 -> 17288;
17300 -> 17199;
17301 -> 17199;
17302 -> 17199;
17303 -> 17297;
17303 -> 17199;
17304 -> 17298;
17304 -> 17199;
17305 -> 17299;
17305 -> 17199;
17306 -> 17301;
17306 -> 17199;
17307 -> 17302;
17307 -> 17199;
17308 -> 17199;
17309 -> 17305;
17309 -> 17308;
17309 -> 17199;
17310 -> 17305;
17310 -> 17199;
17311 -> 17199;
17312 -> 17310;
17312 -> 17311;
17313 -> 17199;
17313 -> 17311;
17314 -> 17311;
17315 -> 17312;
17315 -> 17314;
17315 -> 17311;
17316 -> 17311;
17317 -> 17313;
17317 -> 17316;
17318 -> 17316;
17319 -> 17317;
17319 -> 17318;
17320 -> 0;
17320 -> 17318;
17321 -> 17320;
17321 -> 17316;
17322 -> 17317;
17322 -> 17237;
17322 -> 17316;
17323 -> 17322;
17323 -> 17311;
17324 -> 17312;
17324 -> 17323;
17324 -> 17311;
17325 -> 17199;
17326 -> 17325;
17326 -> 17199;
17327 -> 17199;
17328 -> 17237;
17328 -> 17327;
17329 -> 17328;
17329 -> 17199;
17330 -> 17329;
17331 -> 17329;
17331 -> 17330;
17332 -> 17330;
17333 -> 17331;
17333 -> 17332;
17334 -> 17332;
17335 -> 17333;
17335 -> 17237;
17335 -> 17334;
17335 -> 17332;
17336 -> 17330;
17337 -> 17331;
17337 -> 17237;
17337 -> 17330;
17338 -> 17337;
17338 -> 17329;
17339 -> 17329;
17340 -> 17199;
17341 -> 17237;
17341 -> 17340;
17341 -> 17199;
17342 -> 17237;
17342 -> 17199;
17343 -> 17199;
17344 -> 17237;
17344 -> 0;
17344 -> 17343;
17344 -> 17199;
17345 -> 10492;
17345 -> 17344;
17346 -> 17199;
17347 -> 17237;
17347 -> 17346;
17348 -> 17347;
17348 -> 17199;
17349 -> 17237;
17350 -> 17349;
17350 -> 17237;
17351 -> 17237;
17352 -> 17345;
17352 -> 0;
17352 -> 17351;
17352 -> 17237;
17353 -> 17199;
17354 -> 17307;
17354 -> 17353;
17354 -> 17199;
17355 -> 17301;
17355 -> 17199;
17356 -> 17301;
17356 -> 17199;
17357 -> 17287;
17357 -> 17237;
17358 -> 17357;
17358 -> 17237;
17359 -> 17237;
17360 -> 17237;
17361 -> 17237;
17362 -> 17360;
17362 -> 0;
17362 -> 17361;
17362 -> 17237;
17363 -> 17362;
17364 -> 17237;
17365 -> 17287;
17365 -> 17237;
17366 -> 17365;
17366 -> 17237;
17367 -> 17237;
17368 -> 17367;
17368 -> 0;
17368 -> 17237;
17369 -> 17237;
17370 -> 17368;
17370 -> 17237;
17371 -> 17237;
17372 -> 17287;
17372 -> 17237;
17373 -> 17372;
17373 -> 17237;
17374 -> 17237;
17375 -> 17237;
17376 -> 17237;
17376 -> 17375;
17377 -> 0;
17377 -> 17375;
17378 -> 17377;
17378 -> 17237;
17379 -> 17237;
17380 -> 17379;
17381 -> 17379;
17382 -> 17380;
17382 -> 17381;
17383 -> 17382;
17383 -> 17381;
17384 -> 17383;
17384 -> 17379;
17385 -> 17384;
17385 -> 17237;
17386 -> 17237;
17387 -> 17237;
17388 -> 17237;
17389 -> 17386;
17389 -> 17388;
17390 -> 17386;
17390 -> 17388;
17391 -> 17390;
17391 -> 17388;
17392 -> 17389;
17392 -> 17390;
17392 -> 17388;
17393 -> 17237;
17394 -> 17393;
17394 -> 17237;
17395 -> 17394;
17396 -> 17237;
17397 -> 17396;
17397 -> 0;
17397 -> 17237;
17398 -> 17237;
17399 -> 17397;
17399 -> 17237;
17400 -> 17237;
17401 -> 17237;
17402 -> 17401;
17402 -> 0;
17402 -> 17237;
17403 -> 17237;
17404 -> 17402;
17404 -> 17237;
17405 -> 17397;
17405 -> 17237;
17406 -> 17237;
17407 -> 17237;
17408 -> 17407;
17409 -> 17408;
17409 -> 17237;
17410 -> 17405;
17410 -> 17409;
17410 -> 17237;
17411 -> 17410;
17411 -> 17237;
17412 -> 17237;
17413 -> 17287;
17413 -> 17237;
17414 -> 17237;
17415 -> 17413;
17415 -> 17414;
17416 -> 17199;
17416 -> 17414;
17417 -> 17414;
17418 -> 17416;
17418 -> 17417;
17419 -> 17418;
17419 -> 17414;
17420 -> 17416;
17420 -> 17419;
17421 -> 17419;
17422 -> 17419;
17423 -> 17420;
17423 -> 17422;
17424 -> 17421;
17424 -> 17422;
17425 -> 17419;
17425 -> 17422;
17426 -> 17423;
17426 -> 17422;
17427 -> 17423;
17427 -> 17426;
17428 -> 17424;
17428 -> 17427;
17429 -> 17427;
17430 -> 17415;
17430 -> 17287;
17430 -> 17414;
17431 -> 17237;
17432 -> 17287;
17432 -> 17199;
17433 -> 15668;
17434 -> 15524;
17435 -> 0;
17435 -> 15524;
17436 -> 15524;
17437 -> 17435;
17437 -> 17436;
17438 -> 15662;
17438 -> 17436;
17439 -> 17437;
17439 -> 17436;
17440 -> 17436;
17441 -> 17439;
17441 -> 17440;
17442 -> 17438;
17442 -> 17440;
17443 -> 17441;
17443 -> 17440;
17444 -> 17442;
17444 -> 17440;
17445 -> 17440;
17446 -> 17436;
17447 -> 15522;
17447 -> 15524;
17448 -> 15522;
17448 -> 15524;
17449 -> 15524;
17450 -> 17448;
17450 -> 17449;
17451 -> 17450;
17451 -> 17237;
17451 -> 17449;
17452 -> 17449;
17453 -> 15524;
17454 -> 0;
17454 -> 15524;
17455 -> 15524;
17456 -> 17454;
17456 -> 17455;
17457 -> 17448;
17457 -> 17455;
17458 -> 17456;
17458 -> 17455;
17459 -> 17455;
17460 -> 17458;
17460 -> 17459;
17461 -> 17457;
17461 -> 17459;
17462 -> 17460;
17462 -> 17459;
17463 -> 17461;
17463 -> 17459;
17464 -> 17462;
17464 -> 17463;
17464 -> 17237;
17464 -> 17459;
17465 -> 17459;
17466 -> 17455;
17467 -> 17464;
17467 -> 17466;
17467 -> 17455;
17468 -> 17467;
17468 -> 17455;
17469 -> 17468;
17470 -> 17457;
17470 -> 17469;
17471 -> 17469;
17472 -> 17470;
17472 -> 17471;
17473 -> 17472;
17473 -> 17469;
17474 -> 17237;
17474 -> 17469;
17475 -> 17469;
17476 -> 17474;
17476 -> 17475;
17477 -> 17473;
17477 -> 17475;
17478 -> 17475;
17479 -> 17477;
17479 -> 17478;
17480 -> 17479;
17480 -> 17475;
17481 -> 17480;
17482 -> 17480;
17482 -> 17481;
17483 -> 17481;
17484 -> 17482;
17484 -> 17483;
17485 -> 17483;
17486 -> 17484;
17486 -> 17464;
17486 -> 17485;
17486 -> 17483;
17487 -> 17481;
17488 -> 17482;
17488 -> 17464;
17488 -> 17481;
17489 -> 17488;
17489 -> 17480;
17490 -> 17480;
17491 -> 17475;
17492 -> 17477;
17492 -> 17464;
17492 -> 17491;
17492 -> 17475;
17493 -> 17477;
17493 -> 17464;
17493 -> 17476;
17493 -> 17475;
17494 -> 15522;
17494 -> 15524;
17495 -> 15522;
17495 -> 15524;
17496 -> 17495;
17496 -> 15524;
17497 -> 4485;
17497 -> 15524;
17498 -> 17494;
17498 -> 15524;
17499 -> 15524;
17500 -> 15524;
17501 -> 17496;
17501 -> 17500;
17502 -> 17497;
17502 -> 17500;
17503 -> 17498;
17503 -> 17500;
17504 -> 17499;
17504 -> 17500;
17505 -> 17500;
17506 -> 17501;
17506 -> 17500;
17507 -> 17502;
17507 -> 17500;
17508 -> 17503;
17508 -> 17500;
17509 -> 17504;
17509 -> 17500;
17510 -> 17500;
17511 -> 17505;
17511 -> 17510;
17512 -> 17506;
17512 -> 17510;
17513 -> 17505;
17513 -> 17510;
17514 -> 17507;
17514 -> 17510;
17515 -> 17508;
17515 -> 17510;
17516 -> 17509;
17516 -> 17510;
17517 -> 17505;
17517 -> 17510;
17518 -> 17510;
17519 -> 17511;
17519 -> 17518;
17520 -> 17519;
17520 -> 17505;
17520 -> 17518;
17521 -> 17520;
17521 -> 17518;
17522 -> 17521;
17522 -> 17510;
17523 -> 17512;
17523 -> 17510;
17524 -> 17522;
17524 -> 17523;
17524 -> 17510;
17525 -> 17510;
17526 -> 17516;
17526 -> 17525;
17526 -> 17510;
17527 -> 17510;
17528 -> 17512;
17528 -> 17527;
17529 -> 17527;
17530 -> 17527;
17531 -> 17528;
17531 -> 17530;
17532 -> 17531;
17532 -> 17477;
17532 -> 17530;
17533 -> 17532;
17533 -> 17527;
17534 -> 17533;
17535 -> 17528;
17535 -> 17534;
17536 -> 17535;
17536 -> 17477;
17536 -> 17534;
17537 -> 17536;
17537 -> 17533;
17538 -> 17533;
17539 -> 17537;
17539 -> 17538;
17539 -> 17533;
17540 -> 17527;
17541 -> 17511;
17541 -> 17540;
17542 -> 17541;
17542 -> 17505;
17542 -> 17540;
17543 -> 17542;
17543 -> 17540;
17544 -> 17543;
17544 -> 17527;
17545 -> 17544;
17546 -> 17514;
17546 -> 17545;
17546 -> 17544;
17547 -> 17528;
17547 -> 17546;
17548 -> 17515;
17548 -> 17546;
17549 -> 17529;
17549 -> 17546;
17550 -> 17547;
17550 -> 17548;
17550 -> 17549;
17550 -> 17514;
17550 -> 17477;
17550 -> 4484;
17550 -> 17546;
17551 -> 17546;
17552 -> 17550;
17552 -> 17551;
17553 -> 17550;
17553 -> 17551;
17554 -> 17551;
17555 -> 17552;
17555 -> 17554;
17556 -> 17555;
17556 -> 17551;
17557 -> 17551;
17558 -> 17550;
17558 -> 17557;
17558 -> 17546;
17559 -> 17527;
17560 -> 17559;
17560 -> 17527;
17561 -> 17527;
17562 -> 17528;
17562 -> 17561;
17563 -> 17562;
17563 -> 17558;
17563 -> 17561;
17564 -> 17563;
17564 -> 17527;
17565 -> 17564;
17566 -> 17528;
17566 -> 17565;
17567 -> 17237;
17567 -> 17565;
17568 -> 17567;
17568 -> 17564;
17569 -> 17568;
17569 -> 0;
17569 -> 17564;
17570 -> 17569;
17571 -> 15522;
17571 -> 15524;
17572 -> 15524;
17573 -> 17571;
17573 -> 17572;
17574 -> 17573;
17574 -> 17570;
17574 -> 17572;
17575 -> 17572;
17576 -> 15524;
17577 -> 0;
17577 -> 15524;
17578 -> 15524;
17579 -> 17577;
17579 -> 17578;
17580 -> 17571;
17580 -> 17578;
17581 -> 17579;
17581 -> 17578;
17582 -> 17578;
17583 -> 17581;
17583 -> 17582;
17584 -> 17580;
17584 -> 17582;
17585 -> 17583;
17585 -> 17582;
17586 -> 17584;
17586 -> 17582;
17587 -> 17585;
17587 -> 17586;
17587 -> 17570;
17587 -> 17582;
17588 -> 17582;
17589 -> 17578;
17590 -> 17587;
17590 -> 17589;
17590 -> 17578;
17591 -> 17590;
17591 -> 17578;
17592 -> 17591;
17593 -> 17592;
17594 -> 17593;
17594 -> 17592;
17595 -> 17594;
17596 -> 17594;
17596 -> 17595;
17597 -> 17595;
17598 -> 17596;
17598 -> 17597;
17599 -> 17597;
17600 -> 17598;
17600 -> 17587;
17600 -> 17599;
17600 -> 17597;
17601 -> 17595;
17602 -> 17596;
17602 -> 17587;
17602 -> 17595;
17603 -> 17602;
17603 -> 17594;
17604 -> 17594;
17605 -> 17592;
17606 -> 17592;
17606 -> 17587;
17607 -> 17531;
17607 -> 17592;
17607 -> 17530;
17608 -> 17607;
17608 -> 17527;
17609 -> 17608;
17610 -> 17528;
17610 -> 17609;
17611 -> 17610;
17611 -> 17592;
17611 -> 17609;
17612 -> 17611;
17612 -> 17608;
17613 -> 17608;
17614 -> 17612;
17614 -> 17613;
17614 -> 17608;
17615 -> 17592;
17615 -> 17551;
17616 -> 17592;
17616 -> 17551;
17617 -> 17615;
17617 -> 17554;
17618 -> 17617;
17618 -> 17551;
17619 -> 17528;
17619 -> 17592;
17620 -> 15656;
17620 -> 17592;
17620 -> 15655;
17620 -> 15654;
17621 -> 17620;
17622 -> 17592;
17622 -> 15524;
17623 -> 17622;
17623 -> 15526;
17624 -> 17623;
17624 -> 15528;
17624 -> 15526;
17625 -> 17592;
17626 -> 17592;
17627 -> 17625;
17627 -> 17626;
17628 -> 17626;
17629 -> 17627;
17629 -> 17628;
17629 -> 17626;
17630 -> 17592;
17631 -> 17592;
17632 -> 17631;
17632 -> 17592;
17633 -> 17592;
17634 -> 17632;
17634 -> 17633;
17634 -> 17592;
17635 -> 17592;
17636 -> 17635;
17636 -> 17592;
17637 -> 17635;
17637 -> 17592;
17638 -> 17636;
17638 -> 17592;
17639 -> 17635;
17639 -> 17592;
17640 -> 17592;
17641 -> 17592;
17642 -> 17640;
17642 -> 17641;
17643 -> 17641;
17644 -> 17642;
17644 -> 17643;
17645 -> 0;
17645 -> 17643;
17646 -> 17645;
17646 -> 17641;
17647 -> 17642;
17647 -> 17592;
17648 -> 17592;
17649 -> 17637;
17649 -> 17592;
17650 -> 17592;
17651 -> 17647;
17651 -> 17592;
17652 -> 17639;
17652 -> 17592;
17653 -> 17638;
17653 -> 17592;
17654 -> 17592;
17655 -> 17640;
17655 -> 17592;
17656 -> 17655;
17656 -> 17592;
17657 -> 17592;
17658 -> 17592;
17659 -> 0;
17659 -> 17592;
17660 -> 17592;
17660 -> 0;
17661 -> 17592;
17662 -> 17661;
17662 -> 17592;
17663 -> 17592;
17664 -> 17635;
17665 -> 17635;
17666 -> 17640;
17666 -> 17665;
17667 -> 17635;
17668 -> 17635;
17668 -> 17592;
17669 -> 17592;
17670 -> 17637;
17670 -> 17592;
17671 -> 17664;
17671 -> 17592;
17672 -> 17592;
17673 -> 17668;
17673 -> 17672;
17674 -> 17669;
17674 -> 17672;
17675 -> 17669;
17675 -> 17672;
17676 -> 17670;
17676 -> 17672;
17677 -> 17671;
17677 -> 17672;
17678 -> 17640;
17678 -> 17672;
17679 -> 17592;
17680 -> 17639;
17680 -> 17635;
17681 -> 17635;
17681 -> 17680;
17682 -> 17680;
17683 -> 17681;
17683 -> 17682;
17684 -> 17640;
17684 -> 17682;
17685 -> 17683;
17685 -> 17682;
17686 -> 17680;
17687 -> 17592;
17687 -> 17680;
17688 -> 17680;
17689 -> 17687;
17689 -> 17688;
17690 -> 17640;
17690 -> 17688;
17691 -> 17688;
17692 -> 17690;
17692 -> 17691;
17693 -> 17692;
17693 -> 17688;
17694 -> 17690;
17694 -> 17693;
17695 -> 17693;
17696 -> 17693;
17697 -> 17694;
17697 -> 17696;
17698 -> 17695;
17698 -> 17696;
17699 -> 17693;
17699 -> 17696;
17700 -> 17697;
17700 -> 17696;
17701 -> 17697;
17701 -> 17700;
17702 -> 17698;
17702 -> 17701;
17703 -> 17701;
17704 -> 17689;
17704 -> 17592;
17704 -> 17688;
17705 -> 17680;
17706 -> 17635;
17706 -> 17592;
17707 -> 17592;
17708 -> 17592;
17708 -> 17635;
17709 -> 17592;
17709 -> 17635;
17710 -> 17592;
17710 -> 17635;
17711 -> 17708;
17711 -> 17635;
17712 -> 17635;
17713 -> 17711;
17713 -> 17712;
17714 -> 17710;
17714 -> 17712;
17715 -> 17714;
17715 -> 17635;
17715 -> 17713;
17715 -> 17712;
17716 -> 17715;
17717 -> 17635;
17718 -> 17635;
17719 -> 17717;
17719 -> 17718;
17720 -> 17718;
17721 -> 17719;
17721 -> 17720;
17721 -> 17718;
17722 -> 17635;
17723 -> 17635;
17724 -> 17723;
17724 -> 17635;
17725 -> 17635;
17726 -> 17724;
17726 -> 17725;
17726 -> 17635;
17727 -> 17723;
17727 -> 17635;
17728 -> 17723;
17728 -> 17635;
17729 -> 17727;
17729 -> 17635;
17730 -> 17723;
17730 -> 17635;
17731 -> 17635;
17732 -> 17635;
17733 -> 17731;
17733 -> 17732;
17734 -> 17732;
17735 -> 17733;
17735 -> 17734;
17736 -> 0;
17736 -> 17734;
17737 -> 17736;
17737 -> 17732;
17738 -> 17733;
17738 -> 17635;
17739 -> 17635;
17740 -> 17728;
17740 -> 17635;
17741 -> 17635;
17742 -> 17738;
17742 -> 17635;
17743 -> 17730;
17743 -> 17635;
17744 -> 17729;
17744 -> 17635;
17745 -> 17635;
17746 -> 17731;
17746 -> 17635;
17747 -> 17746;
17747 -> 17635;
17748 -> 17635;
17749 -> 17635;
17750 -> 0;
17750 -> 17635;
17751 -> 17635;
17751 -> 0;
17752 -> 17635;
17753 -> 17752;
17753 -> 17635;
17754 -> 17635;
17755 -> 17723;
17756 -> 17723;
17757 -> 17731;
17757 -> 17756;
17758 -> 17723;
17759 -> 17723;
17759 -> 17635;
17760 -> 17635;
17761 -> 17728;
17761 -> 17635;
17762 -> 17755;
17762 -> 17635;
17763 -> 17635;
17764 -> 17759;
17764 -> 17763;
17765 -> 17760;
17765 -> 17763;
17766 -> 17760;
17766 -> 17763;
17767 -> 17761;
17767 -> 17763;
17768 -> 17762;
17768 -> 17763;
17769 -> 17731;
17769 -> 17763;
17770 -> 17635;
17771 -> 17730;
17771 -> 17723;
17772 -> 17723;
17772 -> 17771;
17773 -> 17771;
17774 -> 17772;
17774 -> 17773;
17775 -> 17731;
17775 -> 17773;
17776 -> 17774;
17776 -> 17773;
17777 -> 17771;
17778 -> 17635;
17778 -> 17771;
17779 -> 17771;
17780 -> 17778;
17780 -> 17779;
17781 -> 17731;
17781 -> 17779;
17782 -> 17779;
17783 -> 17781;
17783 -> 17782;
17784 -> 17783;
17784 -> 17779;
17785 -> 17781;
17785 -> 17784;
17786 -> 17784;
17787 -> 17784;
17788 -> 17785;
17788 -> 17787;
17789 -> 17786;
17789 -> 17787;
17790 -> 17784;
17790 -> 17787;
17791 -> 17788;
17791 -> 17787;
17792 -> 17788;
17792 -> 17791;
17793 -> 17789;
17793 -> 17792;
17794 -> 17792;
17795 -> 17780;
17795 -> 17635;
17795 -> 17779;
17796 -> 17771;
17797 -> 17723;
17797 -> 17635;
17798 -> 17635;
17799 -> 17635;
17799 -> 17723;
17800 -> 17635;
17800 -> 17723;
17801 -> 17635;
17801 -> 17723;
17802 -> 17799;
17802 -> 17723;
17803 -> 17723;
17804 -> 17802;
17804 -> 17803;
17805 -> 17801;
17805 -> 17803;
17806 -> 17805;
17806 -> 17723;
17806 -> 17804;
17806 -> 17803;
17807 -> 17806;
17808 -> 17723;
17809 -> 17723;
17810 -> 17808;
17810 -> 17809;
17811 -> 17809;
17812 -> 17810;
17812 -> 17811;
17812 -> 17809;
17813 -> 0;
17813 -> 15369;
17814 -> 15369;
17815 -> 17813;
17815 -> 17814;
17816 -> 14853;
17816 -> 17723;
17816 -> 17814;
17817 -> 17816;
17817 -> 17815;
17817 -> 17814;
17818 -> 15369;
17818 -> 14854;
17819 -> 17818;
17819 -> 15009;
17820 -> 14853;
17820 -> 17723;
17820 -> 15009;
17821 -> 17819;
17821 -> 15009;
17822 -> 17821;
17822 -> 15014;
17823 -> 17820;
17823 -> 15014;
17824 -> 17823;
17824 -> 17723;
17824 -> 17817;
17824 -> 17822;
17824 -> 15014;
17825 -> 17824;
17826 -> 17817;
17826 -> 14856;
17827 -> 17826;
17827 -> 14859;
17828 -> 17827;
17828 -> 14861;
17828 -> 14859;
17829 -> 17817;
17830 -> 14853;
17830 -> 17829;
17831 -> 0;
17831 -> 17829;
17832 -> 17829;
17833 -> 17831;
17833 -> 17832;
17834 -> 17830;
17834 -> 17817;
17834 -> 17832;
17835 -> 17834;
17835 -> 17817;
17835 -> 17833;
17835 -> 17832;
17836 -> 17829;
17837 -> 17830;
17837 -> 17836;
17838 -> 17836;
17839 -> 17837;
17839 -> 17817;
17839 -> 17838;
17839 -> 17836;
17840 -> 17839;
17841 -> 17840;
17841 -> 17839;
17842 -> 17839;
17843 -> 17841;
17843 -> 17842;
17844 -> 17837;
17844 -> 17842;
17845 -> 17842;
17846 -> 17842;
17847 -> 17844;
17847 -> 17846;
17848 -> 17847;
17848 -> 17817;
17848 -> 17846;
17849 -> 17846;
17850 -> 17848;
17850 -> 17849;
17850 -> 17846;
17851 -> 17846;
17852 -> 17851;
17852 -> 17846;
17853 -> 17846;
17854 -> 17852;
17854 -> 17853;
17855 -> 17847;
17855 -> 17853;
17856 -> 17853;
17857 -> 17855;
17857 -> 17856;
17858 -> 17857;
17858 -> 17817;
17858 -> 17856;
17859 -> 17858;
17859 -> 13802;
17859 -> 17856;
17860 -> 17857;
17860 -> 17817;
17860 -> 17856;
17861 -> 17856;
17862 -> 17861;
17862 -> 17856;
17863 -> 17856;
17864 -> 17862;
17864 -> 17863;
17865 -> 17857;
17865 -> 17863;
17866 -> 17863;
17867 -> 17863;
17868 -> 17866;
17868 -> 17867;
17869 -> 17867;
17870 -> 17869;
17870 -> 17868;
17870 -> 17867;
17871 -> 17867;
17872 -> 17871;
17872 -> 17868;
17872 -> 17867;
17873 -> 17867;
17874 -> 17873;
17874 -> 17868;
17874 -> 17867;
17875 -> 17868;
17875 -> 17867;
17876 -> 17868;
17876 -> 17867;
17877 -> 17868;
17877 -> 17867;
17878 -> 17867;
17879 -> 17878;
17879 -> 17868;
17879 -> 17867;
17880 -> 17868;
17880 -> 17867;
17881 -> 17868;
17881 -> 17867;
17882 -> 17866;
17882 -> 17863;
17883 -> 17864;
17883 -> 17863;
17884 -> 17863;
17885 -> 17882;
17885 -> 17884;
17886 -> 17883;
17886 -> 17884;
17887 -> 17865;
17887 -> 17884;
17888 -> 17887;
17888 -> 17860;
17888 -> 17884;
17889 -> 17888;
17889 -> 17860;
17890 -> 17863;
17891 -> 17863;
17892 -> 17865;
17892 -> 17891;
17893 -> 17892;
17893 -> 17860;
17893 -> 17891;
17894 -> 17893;
17894 -> 17863;
17895 -> 17863;
17896 -> 17865;
17896 -> 17895;
17897 -> 17895;
17898 -> 17897;
17898 -> 17895;
17899 -> 17895;
17900 -> 17898;
17900 -> 17899;
17901 -> 17896;
17901 -> 17899;
17902 -> 17899;
17903 -> 17901;
17903 -> 17902;
17904 -> 17902;
17905 -> 17904;
17905 -> 17899;
17906 -> 17899;
17907 -> 17901;
17907 -> 17906;
17908 -> 17907;
17908 -> 17860;
17908 -> 17906;
17909 -> 17908;
17909 -> 17899;
17910 -> 17899;
17911 -> 17909;
17911 -> 17910;
17912 -> 17910;
17912 -> 17899;
17913 -> 17905;
17913 -> 17912;
17913 -> 17899;
17914 -> 17899;
17915 -> 17901;
17915 -> 17914;
17916 -> 17915;
17916 -> 17860;
17916 -> 17914;
17917 -> 17916;
17917 -> 17899;
17918 -> 17899;
17919 -> 17917;
17919 -> 17918;
17920 -> 17919;
17920 -> 17918;
17921 -> 17920;
17921 -> 17860;
17921 -> 17918;
17922 -> 17899;
17923 -> 17921;
17923 -> 17922;
17924 -> 17922;
17925 -> 17923;
17925 -> 17924;
17926 -> 17925;
17927 -> 17925;
17927 -> 17926;
17928 -> 17927;
17928 -> 17860;
17928 -> 17926;
17929 -> 17928;
17930 -> 17924;
17931 -> 17930;
17931 -> 17922;
17932 -> 17922;
17933 -> 17931;
17933 -> 17899;
17934 -> 17899;
17935 -> 17913;
17935 -> 17933;
17935 -> 17899;
17936 -> 17899;
17937 -> 17901;
17937 -> 17936;
17938 -> 17937;
17938 -> 17860;
17938 -> 17936;
17939 -> 17938;
17939 -> 17899;
17940 -> 17939;
17940 -> 3303;
17940 -> 17899;
17941 -> 17935;
17941 -> 17940;
17941 -> 17899;
17942 -> 17899;
17943 -> 17899;
17944 -> 17943;
17944 -> 17863;
17945 -> 17865;
17945 -> 17860;
17945 -> 17863;
17946 -> 17945;
17946 -> 13802;
17946 -> 17863;
17947 -> 17863;
17948 -> 17866;
17948 -> 17947;
17949 -> 17948;
17949 -> 17870;
17949 -> 17869;
17949 -> 17947;
17950 -> 17948;
17950 -> 17872;
17950 -> 17947;
17951 -> 17947;
17952 -> 17950;
17952 -> 17951;
17953 -> 17951;
17954 -> 17952;
17954 -> 17871;
17954 -> 17953;
17954 -> 17951;
17955 -> 17952;
17955 -> 17871;
17955 -> 17954;
17956 -> 0;
17956 -> 17954;
17957 -> 17948;
17957 -> 17874;
17957 -> 17947;
17958 -> 17947;
17959 -> 17957;
17959 -> 17958;
17960 -> 17958;
17961 -> 17959;
17961 -> 17873;
17961 -> 17960;
17961 -> 17958;
17962 -> 17959;
17962 -> 17873;
17962 -> 17961;
17963 -> 0;
17963 -> 17961;
17964 -> 17948;
17964 -> 17875;
17964 -> 17947;
17965 -> 17948;
17965 -> 17876;
17965 -> 17947;
17966 -> 17948;
17966 -> 17877;
17966 -> 17947;
17967 -> 17948;
17967 -> 17879;
17967 -> 17947;
17968 -> 17948;
17968 -> 17880;
17968 -> 17947;
17969 -> 17948;
17969 -> 17881;
17969 -> 17947;
17970 -> 17947;
17971 -> 17947;
17972 -> 17949;
17972 -> 17971;
17973 -> 17956;
17973 -> 17971;
17974 -> 17963;
17974 -> 17971;
17975 -> 17964;
17975 -> 17971;
17976 -> 17965;
17976 -> 17971;
17977 -> 17966;
17977 -> 17971;
17978 -> 17967;
17978 -> 17971;
17979 -> 17968;
17979 -> 17971;
17980 -> 17969;
17980 -> 17971;
17981 -> 17970;
17981 -> 17971;
17982 -> 17981;
17982 -> 17971;
17983 -> 17981;
17983 -> 17971;
17984 -> 17981;
17984 -> 17971;
17985 -> 17981;
17985 -> 17971;
17986 -> 17981;
17986 -> 17971;
17987 -> 17981;
17987 -> 17971;
17988 -> 17972;
17988 -> 17949;
17988 -> 17971;
17989 -> 17973;
17989 -> 0;
17989 -> 17971;
17990 -> 17974;
17990 -> 0;
17990 -> 17971;
17991 -> 17972;
17991 -> 17971;
17992 -> 17971;
17993 -> 17976;
17993 -> 17977;
17993 -> 17971;
17994 -> 17972;
17994 -> 17981;
17994 -> 17971;
17995 -> 17973;
17995 -> 17981;
17995 -> 17971;
17996 -> 17974;
17996 -> 17981;
17996 -> 17971;
17997 -> 17975;
17997 -> 17981;
17997 -> 17971;
17998 -> 17976;
17998 -> 17981;
17998 -> 17971;
17999 -> 17977;
17999 -> 17981;
17999 -> 17971;
18000 -> 17978;
18000 -> 17981;
18000 -> 17971;
18001 -> 17979;
18001 -> 17981;
18001 -> 17971;
18002 -> 17980;
18002 -> 17981;
18002 -> 17971;
18003 -> 17970;
18003 -> 17863;
18004 -> 18003;
18004 -> 17856;
18005 -> 17857;
18005 -> 17945;
18005 -> 17856;
18006 -> 18004;
18006 -> 17856;
18007 -> 13802;
18007 -> 17856;
18008 -> 18005;
18008 -> 18006;
18008 -> 18007;
18008 -> 17997;
18008 -> 17998;
18008 -> 17999;
18008 -> 18000;
18008 -> 18001;
18008 -> 18002;
18008 -> 17994;
18008 -> 17995;
18008 -> 17996;
18008 -> 13796;
18008 -> 13797;
18008 -> 13798;
18008 -> 13799;
18008 -> 13800;
18008 -> 13801;
18008 -> 17945;
18008 -> 17949;
18008 -> 17991;
18008 -> 0;
18008 -> 17856;
18009 -> 18008;
18009 -> 13802;
18009 -> 17856;
18010 -> 17861;
18010 -> 17856;
18011 -> 17856;
18012 -> 18010;
18012 -> 18011;
18013 -> 17857;
18013 -> 18011;
18014 -> 18011;
18015 -> 18013;
18015 -> 18014;
18016 -> 18015;
18016 -> 18008;
18016 -> 18014;
18017 -> 18016;
18017 -> 18011;
18018 -> 18012;
18018 -> 17861;
18018 -> 18011;
18019 -> 17856;
18020 -> 17861;
18020 -> 17856;
18021 -> 18004;
18021 -> 17856;
18022 -> 18021;
18022 -> 17853;
18023 -> 18022;
18023 -> 17853;
18024 -> 18022;
18024 -> 17853;
18025 -> 17853;
18026 -> 17853;
18027 -> 18024;
18027 -> 18026;
18028 -> 18025;
18028 -> 18026;
18029 -> 18028;
18029 -> 18026;
18030 -> 18028;
18030 -> 18026;
18031 -> 18028;
18031 -> 18026;
18032 -> 18028;
18032 -> 18026;
18033 -> 18027;
18033 -> 13802;
18033 -> 18026;
18034 -> 18027;
18034 -> 18008;
18034 -> 18028;
18034 -> 18026;
18035 -> 18027;
18035 -> 18008;
18035 -> 18028;
18035 -> 18026;
18036 -> 18025;
18036 -> 17853;
18037 -> 18022;
18037 -> 17853;
18038 -> 17854;
18038 -> 17853;
18039 -> 17853;
18040 -> 18036;
18040 -> 18039;
18041 -> 18037;
18041 -> 18039;
18042 -> 18038;
18042 -> 18039;
18043 -> 17855;
18043 -> 18039;
18044 -> 18039;
18045 -> 18043;
18045 -> 18044;
18046 -> 18045;
18046 -> 18008;
18046 -> 18044;
18047 -> 18046;
18047 -> 18039;
18048 -> 18040;
18048 -> 18047;
18049 -> 18041;
18049 -> 18047;
18050 -> 18042;
18050 -> 18047;
18051 -> 18047;
18052 -> 18048;
18052 -> 18051;
18053 -> 18049;
18053 -> 18051;
18054 -> 18050;
18054 -> 18051;
18055 -> 18043;
18055 -> 18051;
18056 -> 18055;
18056 -> 18008;
18056 -> 0;
18056 -> 18051;
18057 -> 18056;
18058 -> 18047;
18059 -> 18040;
18059 -> 18047;
18060 -> 18041;
18060 -> 18047;
18061 -> 18042;
18061 -> 18047;
18062 -> 18047;
18063 -> 18059;
18063 -> 18062;
18064 -> 18060;
18064 -> 18062;
18065 -> 18061;
18065 -> 18062;
18066 -> 18043;
18066 -> 18062;
18067 -> 18062;
18068 -> 18062;
18069 -> 18062;
18070 -> 18064;
18070 -> 18062;
18071 -> 18062;
18072 -> 18070;
18072 -> 18071;
18073 -> 18063;
18073 -> 18071;
18074 -> 18072;
18074 -> 18008;
18074 -> 18071;
18075 -> 18074;
18075 -> 18073;
18075 -> 18029;
18075 -> 18071;
18076 -> 18075;
18076 -> 18062;
18077 -> 18066;
18077 -> 18062;
18078 -> 18062;
18079 -> 18077;
18079 -> 18078;
18080 -> 18078;
18081 -> 18079;
18081 -> 18080;
18081 -> 18078;
18082 -> 18078;
18083 -> 18079;
18083 -> 18082;
18084 -> 18083;
18084 -> 18078;
18085 -> 18068;
18085 -> 18084;
18085 -> 18062;
18086 -> 18062;
18087 -> 18066;
18087 -> 18086;
18088 -> 0;
18088 -> 18086;
18089 -> 18086;
18090 -> 18088;
18090 -> 18089;
18091 -> 18087;
18091 -> 18089;
18092 -> 18091;
18092 -> 18008;
18092 -> 18090;
18092 -> 18089;
18093 -> 18089;
18094 -> 18092;
18094 -> 18093;
18094 -> 18089;
18095 -> 18094;
18095 -> 18062;
18096 -> 18067;
18096 -> 18095;
18096 -> 18062;
18097 -> 18062;
18098 -> 18066;
18098 -> 18097;
18099 -> 18097;
18100 -> 18098;
18100 -> 18099;
18101 -> 18100;
18101 -> 18097;
18102 -> 18101;
18102 -> 18062;
18103 -> 18096;
18103 -> 18102;
18103 -> 18062;
18104 -> 18085;
18104 -> 18103;
18104 -> 18062;
18105 -> 18064;
18105 -> 18008;
18105 -> 18062;
18106 -> 18062;
18107 -> 18105;
18107 -> 18106;
18108 -> 18107;
18108 -> 18106;
18109 -> 18106;
18110 -> 18069;
18110 -> 18108;
18110 -> 18062;
18111 -> 18062;
18112 -> 18066;
18112 -> 18111;
18113 -> 18111;
18114 -> 18112;
18114 -> 18108;
18114 -> 18113;
18114 -> 18111;
18115 -> 18114;
18115 -> 0;
18115 -> 18111;
18116 -> 18115;
18116 -> 18062;
18117 -> 18047;
18118 -> 17853;
18119 -> 17855;
18119 -> 18114;
18119 -> 17853;
18120 -> 17853;
18121 -> 18022;
18121 -> 17853;
18122 -> 17853;
18123 -> 18121;
18123 -> 18122;
18124 -> 18025;
18124 -> 18122;
18125 -> 18124;
18125 -> 18029;
18125 -> 18122;
18126 -> 18123;
18126 -> 18119;
18126 -> 18122;
18127 -> 18126;
18127 -> 18125;
18127 -> 18122;
18128 -> 18124;
18128 -> 18030;
18128 -> 18122;
18129 -> 18128;
18129 -> 18122;
18130 -> 18123;
18130 -> 18119;
18130 -> 18129;
18131 -> 18127;
18131 -> 18122;
18132 -> 18123;
18132 -> 18119;
18132 -> 18122;
18133 -> 18130;
18133 -> 18122;
18134 -> 18124;
18134 -> 18034;
18134 -> 18122;
18135 -> 18124;
18135 -> 18035;
18135 -> 18122;
18136 -> 18122;
18137 -> 18122;
18138 -> 18131;
18138 -> 18137;
18139 -> 18132;
18139 -> 18137;
18140 -> 18133;
18140 -> 18137;
18141 -> 18132;
18141 -> 18137;
18142 -> 18134;
18142 -> 18137;
18143 -> 18135;
18143 -> 18137;
18144 -> 18136;
18144 -> 18137;
18145 -> 18144;
18145 -> 18137;
18146 -> 18144;
18146 -> 18137;
18147 -> 18144;
18147 -> 18137;
18148 -> 18138;
18148 -> 18119;
18148 -> 18137;
18149 -> 18139;
18149 -> 18119;
18149 -> 18137;
18150 -> 18139;
18150 -> 18137;
18151 -> 18137;
18152 -> 18150;
18152 -> 18151;
18152 -> 18119;
18152 -> 18130;
18152 -> 18137;
18153 -> 18140;
18153 -> 18119;
18153 -> 18137;
18154 -> 18140;
18154 -> 18137;
18155 -> 18137;
18156 -> 18154;
18156 -> 18155;
18156 -> 18119;
18156 -> 18130;
18156 -> 18152;
18156 -> 18137;
18157 -> 18138;
18157 -> 18137;
18158 -> 18137;
18159 -> 18157;
18159 -> 18158;
18159 -> 18119;
18159 -> 18156;
18159 -> 18137;
18160 -> 18138;
18160 -> 18137;
18161 -> 18137;
18162 -> 18160;
18162 -> 18161;
18162 -> 18119;
18162 -> 18159;
18162 -> 18137;
18163 -> 18141;
18163 -> 18162;
18163 -> 18137;
18164 -> 18138;
18164 -> 18144;
18164 -> 18137;
18165 -> 18139;
18165 -> 18144;
18165 -> 18137;
18166 -> 18140;
18166 -> 18144;
18166 -> 18137;
18167 -> 18141;
18167 -> 18144;
18167 -> 18137;
18168 -> 18142;
18168 -> 18144;
18168 -> 18137;
18169 -> 18143;
18169 -> 18144;
18169 -> 18137;
18170 -> 18136;
18170 -> 17853;
18171 -> 18170;
18171 -> 17846;
18172 -> 17847;
18172 -> 18162;
18172 -> 17846;
18173 -> 18171;
18173 -> 17846;
18174 -> 17846;
18175 -> 18172;
18175 -> 18173;
18175 -> 18174;
18175 -> 18167;
18175 -> 18168;
18175 -> 18169;
18175 -> 18164;
18175 -> 18165;
18175 -> 18166;
18175 -> 18162;
18175 -> 18119;
18175 -> 18130;
18175 -> 17846;
18176 -> 17846;
18177 -> 18175;
18177 -> 18176;
18177 -> 17846;
18178 -> 17851;
18178 -> 17846;
18179 -> 17846;
18180 -> 18178;
18180 -> 18179;
18181 -> 17847;
18181 -> 18179;
18182 -> 18179;
18183 -> 18181;
18183 -> 18182;
18184 -> 18183;
18184 -> 18175;
18184 -> 18182;
18185 -> 18184;
18185 -> 18179;
18186 -> 18180;
18186 -> 17851;
18186 -> 18179;
18187 -> 17846;
18188 -> 17851;
18188 -> 17846;
18189 -> 17846;
18190 -> 18189;
18190 -> 17847;
18190 -> 17846;
18191 -> 18171;
18191 -> 17846;
18192 -> 18191;
18192 -> 17842;
18193 -> 17842;
18194 -> 17844;
18194 -> 18193;
18195 -> 18193;
18196 -> 18195;
18196 -> 18193;
18197 -> 18193;
18198 -> 18196;
18198 -> 18197;
18199 -> 18194;
18199 -> 18197;
18200 -> 18197;
18201 -> 18199;
18201 -> 18200;
18202 -> 18200;
18203 -> 18202;
18203 -> 18197;
18204 -> 18197;
18205 -> 18199;
18205 -> 18204;
18206 -> 18205;
18206 -> 18175;
18206 -> 18204;
18207 -> 18206;
18207 -> 18197;
18208 -> 18197;
18209 -> 18207;
18209 -> 18208;
18210 -> 18208;
18210 -> 18197;
18211 -> 18203;
18211 -> 18210;
18211 -> 18197;
18212 -> 18197;
18213 -> 18199;
18213 -> 18212;
18214 -> 18213;
18214 -> 18175;
18214 -> 18212;
18215 -> 18214;
18215 -> 18197;
18216 -> 18197;
18217 -> 18215;
18217 -> 18216;
18218 -> 18217;
18218 -> 18216;
18219 -> 18218;
18219 -> 18175;
18219 -> 18216;
18220 -> 18197;
18221 -> 18219;
18221 -> 18220;
18222 -> 18220;
18223 -> 18221;
18223 -> 18222;
18224 -> 18223;
18225 -> 18223;
18225 -> 18224;
18226 -> 18225;
18226 -> 18175;
18226 -> 18224;
18227 -> 18226;
18228 -> 18222;
18229 -> 18228;
18229 -> 18220;
18230 -> 18220;
18231 -> 18229;
18231 -> 18197;
18232 -> 18197;
18233 -> 18211;
18233 -> 18231;
18233 -> 18197;
18234 -> 18197;
18235 -> 18199;
18235 -> 18234;
18236 -> 18235;
18236 -> 18175;
18236 -> 18190;
18236 -> 18234;
18237 -> 18236;
18237 -> 18197;
18238 -> 18237;
18238 -> 3303;
18238 -> 18197;
18239 -> 18233;
18239 -> 18238;
18239 -> 18197;
18240 -> 18197;
18241 -> 18197;
18242 -> 18241;
18242 -> 17842;
18243 -> 18192;
18243 -> 18175;
18243 -> 18242;
18243 -> 17842;
18244 -> 18192;
18244 -> 18175;
18244 -> 18243;
18245 -> 18243;
18246 -> 0;
18246 -> 18243;
18247 -> 18244;
18247 -> 18245;
18247 -> 18246;
18247 -> 18175;
18247 -> 18190;
18247 -> 18243;
18248 -> 18247;
18248 -> 18243;
18249 -> 18243;
18250 -> 17844;
18250 -> 18249;
18251 -> 18249;
18252 -> 18250;
18252 -> 18247;
18252 -> 18251;
18252 -> 18249;
18253 -> 18252;
18254 -> 18250;
18254 -> 18247;
18254 -> 18252;
18255 -> 18253;
18255 -> 18252;
18256 -> 18252;
18257 -> 18255;
18257 -> 18256;
18258 -> 18250;
18258 -> 18256;
18259 -> 18256;
18260 -> 18256;
18261 -> 18258;
18261 -> 18247;
18261 -> 18256;
18262 -> 18256;
18263 -> 18258;
18263 -> 18262;
18264 -> 18262;
18265 -> 18263;
18265 -> 18264;
18266 -> 18265;
18266 -> 18262;
18267 -> 18266;
18267 -> 18256;
18268 -> 18259;
18268 -> 18267;
18269 -> 18256;
18270 -> 13772;
18270 -> 13771;
18270 -> 18269;
18270 -> 18256;
18271 -> 18256;
18272 -> 18259;
18272 -> 18271;
18272 -> 18256;
18273 -> 18272;
18273 -> 18256;
18274 -> 13772;
18274 -> 18273;
18275 -> 18259;
18275 -> 18256;
18276 -> 18274;
18276 -> 18252;
18277 -> 18252;
18278 -> 18253;
18278 -> 18276;
18279 -> 18276;
18280 -> 18278;
18280 -> 18279;
18281 -> 18250;
18281 -> 18279;
18282 -> 18279;
18283 -> 18281;
18283 -> 18282;
18284 -> 18283;
18284 -> 18279;
18285 -> 18280;
18285 -> 18253;
18285 -> 18279;
18286 -> 18276;
18287 -> 0;
18287 -> 18276;
18288 -> 18276;
18289 -> 18287;
18289 -> 18288;
18290 -> 18253;
18290 -> 18252;
18291 -> 18250;
18291 -> 18276;
18291 -> 18249;
18292 -> 18291;
18292 -> 18243;
18293 -> 18243;
18294 -> 18248;
18294 -> 18293;
18295 -> 18292;
18295 -> 18293;
18296 -> 18295;
18296 -> 18293;
18297 -> 18296;
18297 -> 18276;
18297 -> 18289;
18297 -> 18293;
18298 -> 18243;
18299 -> 18247;
18299 -> 17842;
18300 -> 17843;
18300 -> 17842;
18301 -> 17842;
18302 -> 18299;
18302 -> 18301;
18303 -> 18300;
18303 -> 18301;
18304 -> 17844;
18304 -> 18301;
18305 -> 18302;
18305 -> 18276;
18305 -> 18301;
18306 -> 18302;
18306 -> 18276;
18306 -> 18301;
18307 -> 18305;
18307 -> 18306;
18307 -> 18276;
18307 -> 18289;
18307 -> 18301;
18308 -> 13235;
18308 -> 18301;
18309 -> 18305;
18309 -> 18301;
18310 -> 18309;
18310 -> 18307;
18310 -> 18301;
18311 -> 18305;
18311 -> 18307;
18311 -> 18301;
18312 -> 17842;
18313 -> 18302;
18313 -> 17842;
18314 -> 18313;
18314 -> 17839;
18315 -> 17837;
18315 -> 18311;
18315 -> 17839;
18316 -> 18314;
18316 -> 17839;
18317 -> 17839;
18318 -> 18315;
18318 -> 18316;
18318 -> 18317;
18318 -> 18311;
18318 -> 17839;
18319 -> 17840;
18319 -> 18318;
18320 -> 18318;
18321 -> 18319;
18321 -> 18320;
18322 -> 17837;
18322 -> 18320;
18323 -> 18320;
18324 -> 18322;
18324 -> 18323;
18325 -> 18324;
18325 -> 18320;
18326 -> 18321;
18326 -> 17840;
18326 -> 18320;
18327 -> 18318;
18328 -> 0;
18328 -> 18318;
18329 -> 18318;
18330 -> 18328;
18330 -> 18329;
18331 -> 17840;
18331 -> 17839;
18332 -> 0;
18332 -> 17836;
18333 -> 17836;
18334 -> 17836;
18335 -> 18332;
18335 -> 18334;
18336 -> 18333;
18336 -> 18334;
18337 -> 17837;
18337 -> 18318;
18337 -> 18334;
18338 -> 18335;
18338 -> 18334;
18339 -> 18334;
18340 -> 18338;
18340 -> 18339;
18341 -> 18337;
18341 -> 18339;
18342 -> 18341;
18342 -> 18318;
18342 -> 18330;
18342 -> 18340;
18342 -> 18339;
18343 -> 18342;
18344 -> 17837;
18344 -> 18318;
18344 -> 17836;
18345 -> 18344;
18345 -> 17829;
18346 -> 18345;
18346 -> 17817;
18347 -> 17817;
18347 -> 14854;
18348 -> 18347;
18348 -> 15009;
18349 -> 14853;
18349 -> 18318;
18349 -> 15009;
18350 -> 18348;
18350 -> 15009;
18351 -> 18350;
18351 -> 15014;
18352 -> 18349;
18352 -> 15014;
18353 -> 18352;
18353 -> 18318;
18353 -> 18330;
18353 -> 18351;
18353 -> 15014;
18354 -> 18353;
18355 -> 18330;
18355 -> 14856;
18356 -> 18355;
18356 -> 14859;
18357 -> 18356;
18357 -> 14861;
18357 -> 14859;
18358 -> 14852;
18358 -> 18330;
18359 -> 18330;
18360 -> 18358;
18360 -> 18359;
18361 -> 14853;
18361 -> 18359;
18362 -> 18361;
18362 -> 18330;
18362 -> 18359;
18363 -> 18362;
18364 -> 18360;
18364 -> 18330;
18364 -> 18362;
18365 -> 18363;
18365 -> 18362;
18366 -> 18360;
18366 -> 18362;
18367 -> 18362;
18368 -> 18365;
18368 -> 18367;
18369 -> 18366;
18369 -> 18367;
18370 -> 18361;
18370 -> 18367;
18371 -> 18367;
18372 -> 18370;
18372 -> 18371;
18373 -> 18372;
18373 -> 18364;
18373 -> 18371;
18374 -> 18373;
18374 -> 18367;
18375 -> 18367;
18376 -> 18370;
18376 -> 18375;
18377 -> 18376;
18377 -> 18364;
18377 -> 18375;
18378 -> 18377;
18378 -> 18364;
18378 -> 18375;
18379 -> 18378;
18380 -> 0;
18380 -> 18379;
18381 -> 18379;
18382 -> 18380;
18382 -> 18381;
18383 -> 18379;
18383 -> 18364;
18383 -> 18381;
18384 -> 18383;
18384 -> 18364;
18384 -> 18382;
18384 -> 18381;
18385 -> 18379;
18385 -> 18364;
18385 -> 18384;
18386 -> 18385;
18386 -> 18378;
18387 -> 18378;
18388 -> 18376;
18388 -> 18386;
18388 -> 18378;
18389 -> 18386;
18389 -> 18378;
18390 -> 18376;
18390 -> 18388;
18390 -> 18378;
18391 -> 18390;
18391 -> 18375;
18392 -> 18391;
18392 -> 18367;
18393 -> 18362;
18394 -> 18360;
18394 -> 18391;
18394 -> 18362;
18395 -> 18363;
18395 -> 18362;
18396 -> 18362;
18397 -> 18395;
18397 -> 18396;
18398 -> 18361;
18398 -> 18396;
18399 -> 18396;
18400 -> 18398;
18400 -> 18399;
18401 -> 18400;
18401 -> 18394;
18401 -> 18399;
18402 -> 18400;
18402 -> 18394;
18402 -> 18399;
18403 -> 18402;
18403 -> 18396;
18404 -> 18396;
18405 -> 18398;
18405 -> 18404;
18406 -> 0;
18406 -> 18404;
18407 -> 18404;
18408 -> 18406;
18408 -> 18407;
18409 -> 18405;
18409 -> 18407;
18410 -> 18409;
18410 -> 18394;
18410 -> 18408;
18410 -> 18407;
18411 -> 18407;
18412 -> 18410;
18412 -> 18411;
18412 -> 18407;
18413 -> 18412;
18413 -> 18396;
18414 -> 18413;
18415 -> 18362;
18416 -> 18360;
18416 -> 18394;
18416 -> 18362;
18417 -> 18363;
18417 -> 18362;
18418 -> 18362;
18419 -> 18417;
18419 -> 18418;
18420 -> 18361;
18420 -> 18418;
18421 -> 18418;
18422 -> 18420;
18422 -> 18421;
18423 -> 18422;
18423 -> 18421;
18424 -> 18421;
18425 -> 18423;
18426 -> 18423;
18426 -> 18425;
18427 -> 18425;
18428 -> 18426;
18428 -> 18427;
18429 -> 18427;
18430 -> 18428;
18430 -> 18429;
18431 -> 18430;
18431 -> 18416;
18431 -> 18429;
18432 -> 18430;
18432 -> 18416;
18432 -> 18429;
18433 -> 18432;
18433 -> 18427;
18434 -> 18427;
18435 -> 18433;
18435 -> 18434;
18436 -> 18435;
18436 -> 18434;
18437 -> 18434;
18438 -> 18436;
18438 -> 18437;
18439 -> 18436;
18439 -> 0;
18439 -> 18437;
18440 -> 18436;
18440 -> 18437;
18441 -> 18436;
18441 -> 18440;
18442 -> 18440;
18443 -> 18441;
18443 -> 18442;
18444 -> 18442;
18445 -> 18443;
18445 -> 18444;
18446 -> 18445;
18446 -> 18444;
18447 -> 18444;
18448 -> 18446;
18448 -> 18447;
18449 -> 18448;
18449 -> 18447;
18450 -> 18449;
18450 -> 18444;
18451 -> 18450;
18451 -> 18442;
18452 -> 18442;
18453 -> 18451;
18453 -> 18452;
18454 -> 0;
18454 -> 18452;
18455 -> 18454;
18455 -> 18442;
18456 -> 18455;
18456 -> 18440;
18457 -> 18436;
18457 -> 18437;
18458 -> 18457;
18458 -> 18437;
18459 -> 18436;
18459 -> 18458;
18460 -> 18458;
18461 -> 18459;
18461 -> 18460;
18462 -> 18460;
18463 -> 18461;
18463 -> 18462;
18464 -> 18463;
18464 -> 18462;
18465 -> 18462;
18466 -> 18464;
18466 -> 18465;
18467 -> 18466;
18467 -> 18465;
18468 -> 18467;
18468 -> 18462;
18469 -> 18468;
18469 -> 18460;
18470 -> 18460;
18471 -> 18469;
18471 -> 18470;
18472 -> 0;
18472 -> 18470;
18473 -> 18472;
18473 -> 18460;
18474 -> 18473;
18474 -> 18458;
18475 -> 18436;
18475 -> 0;
18475 -> 18437;
18476 -> 18437;
18477 -> 18474;
18477 -> 18476;
18477 -> 18437;
18478 -> 18437;
18479 -> 18436;
18479 -> 18478;
18479 -> 18437;
18480 -> 18436;
18480 -> 18425;
18481 -> 18480;
18481 -> 18423;
18482 -> 18423;
18483 -> 18481;
18484 -> 18483;
18484 -> 18418;
18485 -> 18418;
18486 -> 18420;
18486 -> 18485;
18487 -> 18486;
18487 -> 18436;
18487 -> 18485;
18488 -> 18485;
18489 -> 18487;
18489 -> 18488;
18489 -> 18485;
18490 -> 18487;
18490 -> 3399;
18490 -> 18489;
18491 -> 18489;
18492 -> 18487;
18492 -> 18491;
18493 -> 18491;
18494 -> 18492;
18494 -> 18436;
18494 -> 18493;
18494 -> 18491;
18495 -> 18494;
18495 -> 18489;
18496 -> 18489;
18497 -> 18487;
18497 -> 18489;
18498 -> 18497;
18498 -> 18485;
18499 -> 18498;
18499 -> 3399;
18499 -> 18485;
18500 -> 3393;
18500 -> 3392;
18500 -> 18499;
18501 -> 3393;
18501 -> 18499;
18502 -> 18501;
18502 -> 18418;
18503 -> 18418;
18504 -> 18502;
18504 -> 18503;
18504 -> 18418;
18505 -> 18504;
18506 -> 18362;
18507 -> 18362;
18508 -> 18361;
18508 -> 18507;
18509 -> 18507;
18510 -> 18508;
18510 -> 18509;
18511 -> 18510;
18511 -> 18436;
18511 -> 18509;
18512 -> 18511;
18512 -> 18507;
18513 -> 18512;
18513 -> 18362;
18514 -> 18360;
18514 -> 18436;
18514 -> 18513;
18515 -> 18361;
18515 -> 18513;
18516 -> 18363;
18516 -> 18513;
18517 -> 18513;
18518 -> 18515;
18518 -> 18517;
18519 -> 18516;
18519 -> 18517;
18520 -> 18517;
18521 -> 18518;
18521 -> 18520;
18521 -> 18517;
18522 -> 18517;
18523 -> 18518;
18523 -> 18522;
18524 -> 18523;
18524 -> 18514;
18524 -> 18522;
18525 -> 18524;
18525 -> 18517;
18526 -> 18517;
18527 -> 18517;
18528 -> 18526;
18528 -> 18527;
18529 -> 18518;
18529 -> 18527;
18530 -> 18529;
18530 -> 18514;
18530 -> 18527;
18531 -> 18529;
18531 -> 18514;
18531 -> 18527;
18532 -> 18531;
18532 -> 18517;
18533 -> 18517;
18534 -> 18518;
18534 -> 18533;
18535 -> 18534;
18535 -> 18514;
18535 -> 18533;
18536 -> 18535;
18536 -> 18517;
18537 -> 18513;
18538 -> 18361;
18538 -> 18535;
18538 -> 18362;
18539 -> 18363;
18539 -> 18362;
18540 -> 18360;
18540 -> 18362;
18541 -> 18362;
18542 -> 18539;
18542 -> 18541;
18543 -> 18540;
18543 -> 18541;
18544 -> 18361;
18544 -> 18541;
18545 -> 18541;
18546 -> 18541;
18547 -> 18544;
18547 -> 18546;
18548 -> 18547;
18548 -> 18535;
18548 -> 18546;
18549 -> 18546;
18550 -> 18548;
18550 -> 18549;
18550 -> 18546;
18551 -> 18548;
18551 -> 3399;
18551 -> 18550;
18552 -> 18550;
18553 -> 18548;
18553 -> 18552;
18554 -> 18552;
18555 -> 18553;
18555 -> 18535;
18555 -> 18554;
18555 -> 18552;
18556 -> 18555;
18556 -> 18550;
18557 -> 18550;
18558 -> 18548;
18558 -> 18550;
18559 -> 18558;
18559 -> 18546;
18560 -> 18559;
18560 -> 3399;
18560 -> 18546;
18561 -> 3393;
18561 -> 3392;
18561 -> 18560;
18562 -> 3393;
18562 -> 18560;
18563 -> 18562;
18563 -> 18541;
18564 -> 18541;
18565 -> 18544;
18565 -> 18564;
18566 -> 18564;
18567 -> 18565;
18567 -> 18566;
18568 -> 18566;
18569 -> 18567;
18569 -> 18568;
18570 -> 18569;
18570 -> 18535;
18570 -> 18568;
18571 -> 18568;
18572 -> 18570;
18572 -> 18571;
18572 -> 18568;
18573 -> 18570;
18573 -> 3399;
18573 -> 18572;
18574 -> 18572;
18575 -> 18570;
18575 -> 18574;
18576 -> 18574;
18577 -> 18575;
18577 -> 18535;
18577 -> 18576;
18577 -> 18574;
18578 -> 18577;
18578 -> 18572;
18579 -> 18572;
18580 -> 18570;
18580 -> 18572;
18581 -> 18580;
18581 -> 18566;
18582 -> 18581;
18582 -> 3399;
18582 -> 18566;
18583 -> 10492;
18583 -> 18582;
18584 -> 18583;
18584 -> 18564;
18585 -> 18584;
18585 -> 18541;
18586 -> 18545;
18586 -> 18541;
18587 -> 18586;
18587 -> 18362;
18588 -> 18362;
18589 -> 18538;
18589 -> 18587;
18589 -> 18588;
18589 -> 18586;
18589 -> 18535;
18589 -> 18545;
18589 -> 18362;
18590 -> 18363;
18590 -> 18589;
18591 -> 18589;
18592 -> 18590;
18592 -> 18591;
18593 -> 18361;
18593 -> 18591;
18594 -> 18591;
18595 -> 18593;
18595 -> 18594;
18596 -> 18595;
18596 -> 18591;
18597 -> 18592;
18597 -> 18363;
18597 -> 18591;
18598 -> 18589;
18599 -> 0;
18599 -> 18589;
18600 -> 18589;
18601 -> 18599;
18601 -> 18600;
18602 -> 18363;
18602 -> 18362;
18603 -> 18361;
18603 -> 18589;
18603 -> 18359;
18604 -> 18330;
18604 -> 14854;
18605 -> 18604;
18605 -> 15009;
18606 -> 14853;
18606 -> 18589;
18606 -> 15009;
18607 -> 18605;
18607 -> 15009;
18608 -> 18607;
18608 -> 15014;
18609 -> 18606;
18609 -> 15014;
18610 -> 18609;
18610 -> 18589;
18610 -> 18601;
18610 -> 18608;
18610 -> 15014;
18611 -> 18610;
18612 -> 18601;
18612 -> 14856;
18613 -> 18612;
18613 -> 14859;
18614 -> 18613;
18614 -> 14861;
18614 -> 14859;
18615 -> 0;
18615 -> 18601;
18616 -> 18601;
18617 -> 18615;
18617 -> 18616;
18618 -> 18617;
18619 -> 18618;
18619 -> 18617;
18620 -> 18617;
18621 -> 18619;
18621 -> 18620;
18622 -> 14853;
18622 -> 18620;
18623 -> 18620;
18624 -> 18622;
18624 -> 18623;
18625 -> 18624;
18625 -> 18620;
18626 -> 18625;
18627 -> 18626;
18627 -> 18601;
18628 -> 18626;
18629 -> 18627;
18629 -> 18628;
18629 -> 18626;
18630 -> 18627;
18630 -> 18629;
18631 -> 18630;
18631 -> 18625;
18632 -> 18621;
18632 -> 18625;
18633 -> 18625;
18634 -> 18631;
18634 -> 18633;
18635 -> 18632;
18635 -> 18633;
18636 -> 18634;
18636 -> 18633;
18637 -> 18625;
18638 -> 18621;
18638 -> 18620;
18639 -> 18620;
18640 -> 18638;
18640 -> 18639;
18641 -> 18622;
18641 -> 18639;
18642 -> 18639;
18643 -> 18641;
18643 -> 18642;
18644 -> 18643;
18644 -> 18601;
18644 -> 18642;
18645 -> 18642;
18646 -> 18644;
18646 -> 18645;
18646 -> 18642;
18647 -> 18644;
18647 -> 18646;
18648 -> 18647;
18648 -> 18639;
18649 -> 18620;
18650 -> 18621;
18650 -> 18620;
18651 -> 18620;
18652 -> 18650;
18652 -> 18651;
18653 -> 18622;
18653 -> 18651;
18654 -> 18651;
18655 -> 18653;
18655 -> 18654;
18656 -> 18655;
18656 -> 18651;
18657 -> 18652;
18657 -> 18651;
18658 -> 18656;
18658 -> 18651;
18659 -> 18651;
18660 -> 18657;
18660 -> 18659;
18661 -> 18658;
18661 -> 18659;
18662 -> 18653;
18662 -> 18659;
18663 -> 18659;
18664 -> 18659;
18665 -> 18662;
18665 -> 18664;
18666 -> 18665;
18666 -> 18659;
18667 -> 18659;
18668 -> 18666;
18669 -> 18666;
18670 -> 18669;
18670 -> 18666;
18671 -> 18670;
18672 -> 18670;
18672 -> 18671;
18673 -> 18672;
18673 -> 18601;
18673 -> 18671;
18674 -> 18673;
18674 -> 18670;
18675 -> 18668;
18675 -> 18674;
18675 -> 18670;
18676 -> 13151;
18676 -> 18659;
18677 -> 18661;
18677 -> 18601;
18677 -> 18659;
18678 -> 18668;
18678 -> 18675;
18678 -> 18659;
18679 -> 18651;
18680 -> 13151;
18680 -> 18651;
18681 -> 13151;
18681 -> 18651;
18683 -> 18682;
18684 -> 18682;
18685 -> 18651;
18686 -> 18684;
18686 -> 18685;
18687 -> 18686;
18687 -> 18651;
18688 -> 18656;
18688 -> 18651;
18689 -> 18620;
18690 -> 18621;
18690 -> 18620;
18691 -> 18620;
18692 -> 18690;
18692 -> 18691;
18693 -> 18622;
18693 -> 18691;
18694 -> 18693;
18694 -> 18601;
18694 -> 18617;
18694 -> 0;
18694 -> 18691;
18695 -> 18694;
18696 -> 18620;
18697 -> 18621;
18697 -> 18620;
18698 -> 18620;
18699 -> 18697;
18699 -> 18698;
18700 -> 18622;
18700 -> 18698;
18701 -> 18698;
18702 -> 18700;
18702 -> 18701;
18703 -> 18702;
18703 -> 18698;
18704 -> 18698;
18705 -> 18703;
18705 -> 18704;
18706 -> 18698;
18707 -> 18698;
18708 -> 18705;
18708 -> 18707;
18709 -> 18706;
18709 -> 18707;
18710 -> 18706;
18710 -> 18707;
18711 -> 18708;
18711 -> 18707;
18712 -> 18707;
18713 -> 18709;
18713 -> 18707;
18714 -> 18707;
18715 -> 18707;
18716 -> 18711;
18716 -> 18715;
18717 -> 18712;
18717 -> 18715;
18718 -> 18713;
18718 -> 18715;
18719 -> 18714;
18719 -> 18715;
18720 -> 18710;
18720 -> 18715;
18721 -> 18716;
18721 -> 18715;
18722 -> 18717;
18722 -> 18715;
18723 -> 18718;
18723 -> 18715;
18724 -> 18719;
18724 -> 18715;
18725 -> 18715;
18726 -> 18721;
18726 -> 18725;
18727 -> 18722;
18727 -> 18725;
18728 -> 18723;
18728 -> 18725;
18729 -> 18724;
18729 -> 18725;
18730 -> 18720;
18730 -> 18725;
18731 -> 18730;
18731 -> 18725;
18732 -> 18730;
18732 -> 18725;
18733 -> 18730;
18733 -> 18725;
18734 -> 18730;
18734 -> 18725;
18735 -> 18725;
18736 -> 18726;
18736 -> 18735;
18736 -> 18725;
18737 -> 18725;
18738 -> 18729;
18738 -> 18737;
18738 -> 18725;
18739 -> 18725;
18740 -> 18729;
18740 -> 18739;
18740 -> 18725;
18741 -> 18726;
18741 -> 18730;
18741 -> 18725;
18742 -> 18727;
18742 -> 18730;
18742 -> 18725;
18743 -> 18728;
18743 -> 18730;
18743 -> 18725;
18744 -> 18729;
18744 -> 18730;
18744 -> 18725;
18745 -> 18698;
18746 -> 18700;
18746 -> 18745;
18747 -> 18746;
18747 -> 18698;
18748 -> 18620;
18749 -> 18621;
18749 -> 18620;
18750 -> 18620;
18751 -> 18749;
18751 -> 18750;
18752 -> 18622;
18752 -> 18750;
18753 -> 18750;
18754 -> 18752;
18754 -> 18753;
18755 -> 18754;
18755 -> 18746;
18755 -> 18753;
18756 -> 18755;
18756 -> 18750;
18757 -> 18750;
18758 -> 18752;
18758 -> 18757;
18759 -> 18758;
18759 -> 18746;
18759 -> 18757;
18760 -> 18759;
18760 -> 18750;
18761 -> 18750;
18762 -> 18760;
18763 -> 18762;
18763 -> 18760;
18764 -> 18763;
18765 -> 18763;
18765 -> 18764;
18766 -> 18765;
18766 -> 18759;
18766 -> 18764;
18767 -> 18766;
18767 -> 18763;
18768 -> 18763;
18769 -> 18767;
18769 -> 18768;
18770 -> 18752;
18770 -> 18768;
18771 -> 18768;
18772 -> 18771;
18772 -> 18768;
18773 -> 18768;
18774 -> 18770;
18774 -> 18773;
18775 -> 18774;
18775 -> 18768;
18776 -> 18769;
18776 -> 18768;
18777 -> 18771;
18777 -> 18768;
18778 -> 18775;
18778 -> 18776;
18778 -> 18777;
18778 -> 18759;
18778 -> 18772;
18778 -> 18768;
18779 -> 10514;
18779 -> 18768;
18780 -> 18779;
18780 -> 18763;
18781 -> 10514;
18781 -> 18778;
18782 -> 18620;
18783 -> 18621;
18783 -> 18620;
18784 -> 18620;
18785 -> 18783;
18785 -> 18784;
18786 -> 18622;
18786 -> 18784;
18787 -> 18784;
18788 -> 18786;
18788 -> 18787;
18789 -> 18788;
18789 -> 18778;
18789 -> 18787;
18790 -> 18789;
18790 -> 18784;
18791 -> 18620;
18792 -> 18620;
18793 -> 18622;
18793 -> 18792;
18794 -> 18793;
18794 -> 18789;
18794 -> 0;
18794 -> 18792;
18795 -> 18794;
18796 -> 18795;
18796 -> 18794;
18797 -> 18793;
18797 -> 18789;
18797 -> 18796;
18798 -> 0;
18798 -> 18796;
18799 -> 18793;
18799 -> 18789;
18799 -> 18797;
18799 -> 0;
18799 -> 18792;
18800 -> 18799;
18800 -> 18620;
18801 -> 18621;
18801 -> 18620;
18802 -> 18620;
18803 -> 18801;
18803 -> 18802;
18804 -> 18622;
18804 -> 18802;
18805 -> 18802;
18806 -> 18804;
18806 -> 18805;
18807 -> 0;
18807 -> 18805;
18808 -> 18805;
18809 -> 18807;
18809 -> 18808;
18810 -> 18806;
18810 -> 18808;
18811 -> 18810;
18811 -> 18789;
18811 -> 18809;
18811 -> 18808;
18812 -> 18808;
18813 -> 18811;
18813 -> 18812;
18813 -> 18808;
18814 -> 18813;
18814 -> 18802;
18815 -> 18814;
18816 -> 18620;
18817 -> 18621;
18817 -> 18620;
18818 -> 18620;
18819 -> 18817;
18819 -> 18818;
18820 -> 18622;
18820 -> 18818;
18821 -> 18818;
18822 -> 18820;
18822 -> 18821;
18823 -> 0;
18823 -> 18821;
18824 -> 18821;
18825 -> 18823;
18825 -> 18824;
18826 -> 18822;
18826 -> 18824;
18827 -> 18826;
18827 -> 18789;
18827 -> 18825;
18827 -> 18824;
18828 -> 18824;
18829 -> 18827;
18829 -> 18828;
18829 -> 18824;
18830 -> 18829;
18830 -> 18818;
18831 -> 18830;
18832 -> 18620;
18833 -> 18621;
18833 -> 18620;
18834 -> 18620;
18835 -> 18833;
18835 -> 18834;
18836 -> 18622;
18836 -> 18834;
18837 -> 18835;
18837 -> 18834;
18838 -> 0;
18838 -> 18834;
18839 -> 18834;
18840 -> 18837;
18840 -> 18839;
18841 -> 18838;
18841 -> 18839;
18842 -> 18838;
18842 -> 18839;
18843 -> 18836;
18843 -> 18839;
18844 -> 18841;
18844 -> 18839;
18845 -> 18839;
18846 -> 18844;
18846 -> 18845;
18847 -> 18843;
18847 -> 18845;
18848 -> 18846;
18848 -> 18845;
18849 -> 18845;
18850 -> 18848;
18850 -> 18849;
18851 -> 18847;
18851 -> 18849;
18852 -> 18849;
18853 -> 18851;
18853 -> 18789;
18853 -> 18852;
18853 -> 18849;
18854 -> 18850;
18854 -> 18853;
18855 -> 18853;
18856 -> 18854;
18856 -> 18855;
18857 -> 18855;
18857 -> 18856;
18857 -> 18789;
18857 -> 18797;
18858 -> 10514;
18858 -> 18855;
18859 -> 18858;
18859 -> 18853;
18860 -> 18859;
18860 -> 18845;
18861 -> 18860;
18861 -> 0;
18861 -> 18845;
18862 -> 0;
18862 -> 18861;
18863 -> 18862;
18863 -> 18839;
18864 -> 18842;
18864 -> 18839;
18865 -> 18839;
18866 -> 18864;
18866 -> 18865;
18867 -> 18843;
18867 -> 18865;
18868 -> 18866;
18868 -> 18865;
18869 -> 18865;
18870 -> 18868;
18870 -> 18869;
18871 -> 18867;
18871 -> 18869;
18872 -> 18869;
18873 -> 18871;
18873 -> 18857;
18873 -> 18872;
18873 -> 18869;
18874 -> 18870;
18874 -> 18873;
18875 -> 10514;
18875 -> 18873;
18876 -> 18875;
18876 -> 0;
18876 -> 18865;
18877 -> 0;
18877 -> 18876;
18878 -> 18877;
18878 -> 18839;
18879 -> 18840;
18879 -> 18839;
18880 -> 18863;
18880 -> 18839;
18881 -> 18878;
18881 -> 18839;
18882 -> 18842;
18882 -> 18839;
18883 -> 18839;
18884 -> 18879;
18884 -> 18883;
18885 -> 18880;
18885 -> 18883;
18886 -> 18881;
18886 -> 18883;
18887 -> 18882;
18887 -> 18883;
18888 -> 18885;
18888 -> 18883;
18889 -> 18839;
18890 -> 18840;
18890 -> 18839;
18891 -> 18878;
18891 -> 18839;
18892 -> 18863;
18892 -> 18839;
18893 -> 18841;
18893 -> 18839;
18894 -> 18839;
18895 -> 18890;
18895 -> 18894;
18896 -> 18891;
18896 -> 18894;
18897 -> 18892;
18897 -> 18894;
18898 -> 18893;
18898 -> 18894;
18899 -> 18896;
18899 -> 18894;
18900 -> 18839;
18901 -> 18834;
18902 -> 18835;
18902 -> 18834;
18903 -> 0;
18903 -> 18834;
18904 -> 18834;
18905 -> 18902;
18905 -> 18904;
18906 -> 18903;
18906 -> 18904;
18907 -> 18903;
18907 -> 18904;
18908 -> 18836;
18908 -> 18904;
18909 -> 18906;
18909 -> 18904;
18910 -> 18904;
18911 -> 18909;
18911 -> 18910;
18912 -> 18908;
18912 -> 18910;
18913 -> 18911;
18913 -> 18910;
18914 -> 18910;
18915 -> 18913;
18915 -> 18914;
18916 -> 18912;
18916 -> 18914;
18917 -> 18914;
18918 -> 18916;
18918 -> 18874;
18918 -> 18917;
18918 -> 18914;
18919 -> 18915;
18919 -> 18918;
18920 -> 10514;
18920 -> 18918;
18921 -> 18920;
18921 -> 0;
18921 -> 18910;
18922 -> 0;
18922 -> 18921;
18923 -> 18907;
18923 -> 18904;
18924 -> 18904;
18925 -> 18923;
18925 -> 18924;
18926 -> 18908;
18926 -> 18924;
18927 -> 18925;
18927 -> 18924;
18928 -> 18924;
18929 -> 18927;
18929 -> 18928;
18930 -> 18926;
18930 -> 18928;
18931 -> 18928;
18932 -> 10514;
18932 -> 18919;
18933 -> 18932;
18933 -> 0;
18933 -> 18924;
18934 -> 0;
18934 -> 18933;
18935 -> 18905;
18935 -> 18904;
18936 -> 18922;
18936 -> 18904;
18937 -> 18934;
18937 -> 18904;
18938 -> 18907;
18938 -> 18904;
18939 -> 18904;
18940 -> 18935;
18940 -> 18939;
18941 -> 18936;
18941 -> 18939;
18942 -> 18937;
18942 -> 18939;
18943 -> 18938;
18943 -> 18939;
18944 -> 18941;
18944 -> 18939;
18945 -> 18904;
18946 -> 18905;
18946 -> 18904;
18947 -> 18934;
18947 -> 18904;
18948 -> 18922;
18948 -> 18904;
18949 -> 18906;
18949 -> 18904;
18950 -> 18904;
18951 -> 18946;
18951 -> 18950;
18952 -> 18947;
18952 -> 18950;
18953 -> 18948;
18953 -> 18950;
18954 -> 18949;
18954 -> 18950;
18955 -> 18952;
18955 -> 18950;
18956 -> 18904;
18957 -> 18834;
18958 -> 18835;
18958 -> 18834;
18959 -> 0;
18959 -> 18834;
18960 -> 18834;
18961 -> 18958;
18961 -> 18960;
18962 -> 18959;
18962 -> 18960;
18963 -> 18959;
18963 -> 18960;
18964 -> 18836;
18964 -> 18960;
18965 -> 18962;
18965 -> 18960;
18966 -> 18960;
18967 -> 18965;
18967 -> 18966;
18968 -> 18964;
18968 -> 18966;
18969 -> 18967;
18969 -> 18966;
18970 -> 18966;
18971 -> 18969;
18971 -> 18970;
18972 -> 18968;
18972 -> 18970;
18973 -> 18970;
18974 -> 18972;
18974 -> 18919;
18974 -> 18973;
18974 -> 18970;
18975 -> 18971;
18975 -> 18974;
18976 -> 10514;
18976 -> 18974;
18977 -> 18976;
18977 -> 0;
18977 -> 18966;
18978 -> 0;
18978 -> 18977;
18979 -> 18963;
18979 -> 18960;
18980 -> 18960;
18981 -> 18979;
18981 -> 18980;
18982 -> 18964;
18982 -> 18980;
18983 -> 18981;
18983 -> 18980;
18984 -> 18980;
18985 -> 18983;
18985 -> 18984;
18986 -> 18982;
18986 -> 18984;
18987 -> 18984;
18988 -> 10514;
18988 -> 18975;
18989 -> 18988;
18989 -> 0;
18989 -> 18980;
18990 -> 0;
18990 -> 18989;
18991 -> 18961;
18991 -> 18960;
18992 -> 18978;
18992 -> 18960;
18993 -> 18990;
18993 -> 18960;
18994 -> 18963;
18994 -> 18960;
18995 -> 18960;
18996 -> 18991;
18996 -> 18995;
18997 -> 18992;
18997 -> 18995;
18998 -> 18993;
18998 -> 18995;
18999 -> 18994;
18999 -> 18995;
19000 -> 18997;
19000 -> 18995;
19001 -> 18960;
19002 -> 18961;
19002 -> 18960;
19003 -> 18990;
19003 -> 18960;
19004 -> 18978;
19004 -> 18960;
19005 -> 18962;
19005 -> 18960;
19006 -> 18960;
19007 -> 19002;
19007 -> 19006;
19008 -> 19003;
19008 -> 19006;
19009 -> 19004;
19009 -> 19006;
19010 -> 19005;
19010 -> 19006;
19011 -> 19008;
19011 -> 19006;
19012 -> 18960;
19013 -> 18834;
19014 -> 18835;
19014 -> 18834;
19015 -> 0;
19015 -> 18834;
19016 -> 18834;
19017 -> 19014;
19017 -> 19016;
19018 -> 19015;
19018 -> 19016;
19019 -> 19015;
19019 -> 19016;
19020 -> 18836;
19020 -> 19016;
19021 -> 19018;
19021 -> 19016;
19022 -> 19016;
19023 -> 19021;
19023 -> 19022;
19024 -> 19020;
19024 -> 19022;
19025 -> 19023;
19025 -> 19022;
19026 -> 19022;
19027 -> 19025;
19027 -> 19026;
19028 -> 19024;
19028 -> 19026;
19029 -> 19026;
19030 -> 19028;
19030 -> 18975;
19030 -> 19029;
19030 -> 19026;
19031 -> 19027;
19031 -> 19030;
19032 -> 10514;
19032 -> 19030;
19033 -> 19032;
19033 -> 0;
19033 -> 19022;
19034 -> 0;
19034 -> 19033;
19035 -> 19019;
19035 -> 19016;
19036 -> 19016;
19037 -> 19035;
19037 -> 19036;
19038 -> 19020;
19038 -> 19036;
19039 -> 19037;
19039 -> 19036;
19040 -> 19036;
19041 -> 19039;
19041 -> 19040;
19042 -> 19038;
19042 -> 19040;
19043 -> 19040;
19044 -> 10514;
19044 -> 19031;
19045 -> 19044;
19045 -> 0;
19045 -> 19036;
19046 -> 0;
19046 -> 19045;
19047 -> 19017;
19047 -> 19016;
19048 -> 19034;
19048 -> 19016;
19049 -> 19046;
19049 -> 19016;
19050 -> 19019;
19050 -> 19016;
19051 -> 19016;
19052 -> 19047;
19052 -> 19051;
19053 -> 19048;
19053 -> 19051;
19054 -> 19049;
19054 -> 19051;
19055 -> 19050;
19055 -> 19051;
19056 -> 19053;
19056 -> 19051;
19057 -> 19016;
19058 -> 19017;
19058 -> 19016;
19059 -> 19046;
19059 -> 19016;
19060 -> 19034;
19060 -> 19016;
19061 -> 19018;
19061 -> 19016;
19062 -> 19016;
19063 -> 19058;
19063 -> 19062;
19064 -> 19059;
19064 -> 19062;
19065 -> 19060;
19065 -> 19062;
19066 -> 19061;
19066 -> 19062;
19067 -> 19064;
19067 -> 19062;
19068 -> 19016;
19069 -> 18834;
19070 -> 18835;
19070 -> 18834;
19071 -> 18834;
19072 -> 19070;
19072 -> 19071;
19073 -> 18836;
19073 -> 19071;
19074 -> 19073;
19074 -> 19071;
19075 -> 19071;
19076 -> 19074;
19076 -> 19075;
19077 -> 19075;
19078 -> 19076;
19078 -> 19077;
19078 -> 19075;
19079 -> 19075;
19080 -> 19076;
19080 -> 19079;
19081 -> 19079;
19081 -> 19075;
19082 -> 19075;
19083 -> 19076;
19083 -> 19082;
19084 -> 19083;
19084 -> 19031;
19084 -> 19082;
19085 -> 19084;
19085 -> 19075;
19086 -> 19081;
19086 -> 19085;
19086 -> 19075;
19087 -> 19086;
19088 -> 18834;
19089 -> 18620;
19090 -> 18620;
19091 -> 18622;
19091 -> 19090;
19092 -> 19091;
19092 -> 19031;
19092 -> 19090;
19093 -> 19092;
19093 -> 18620;
19094 -> 18620;
19095 -> 18620;
19096 -> 18622;
19096 -> 19095;
19097 -> 19095;
19098 -> 19096;
19098 -> 19097;
19099 -> 19097;
19099 -> 19095;
19100 -> 19096;
19100 -> 19093;
19100 -> 19095;
19101 -> 19100;
19101 -> 18620;
19102 -> 18620;
19103 -> 18622;
19103 -> 19102;
19104 -> 0;
19104 -> 19102;
19105 -> 19102;
19106 -> 19104;
19106 -> 19105;
19107 -> 19103;
19107 -> 19105;
19108 -> 19107;
19108 -> 19093;
19108 -> 19106;
19108 -> 19105;
19109 -> 19105;
19110 -> 19108;
19110 -> 19109;
19110 -> 19105;
19111 -> 19110;
19111 -> 18620;
19112 -> 18620;
19113 -> 18622;
19113 -> 19112;
19114 -> 0;
19114 -> 19112;
19115 -> 19112;
19116 -> 19114;
19116 -> 19115;
19117 -> 19113;
19117 -> 19115;
19118 -> 19117;
19118 -> 19093;
19118 -> 19116;
19118 -> 19115;
19119 -> 19115;
19120 -> 19118;
19120 -> 19119;
19120 -> 19115;
19121 -> 19120;
19121 -> 18620;
19122 -> 18620;
19123 -> 18622;
19123 -> 19122;
19124 -> 19123;
19124 -> 19093;
19124 -> 19122;
19125 -> 19123;
19125 -> 19093;
19125 -> 19122;
19126 -> 19125;
19126 -> 18620;
19127 -> 18620;
19128 -> 18622;
19128 -> 19127;
19129 -> 19127;
19130 -> 19128;
19130 -> 19129;
19131 -> 19129;
19132 -> 19130;
19132 -> 19131;
19133 -> 19132;
19133 -> 19129;
19134 -> 19129;
19135 -> 19130;
19135 -> 19134;
19136 -> 19135;
19136 -> 19093;
19136 -> 19134;
19137 -> 19136;
19137 -> 19129;
19138 -> 19129;
19139 -> 19129;
19140 -> 19130;
19140 -> 19129;
19141 -> 19138;
19141 -> 19129;
19142 -> 19139;
19142 -> 19129;
19143 -> 19129;
19144 -> 19140;
19144 -> 19143;
19145 -> 19141;
19145 -> 19143;
19146 -> 19142;
19146 -> 19143;
19147 -> 19143;
19148 -> 19143;
19149 -> 19147;
19149 -> 19148;
19150 -> 19144;
19150 -> 19148;
19151 -> 19150;
19151 -> 19093;
19151 -> 19148;
19152 -> 19150;
19152 -> 19093;
19152 -> 19148;
19153 -> 19152;
19153 -> 19143;
19154 -> 19129;
19155 -> 19138;
19155 -> 19129;
19156 -> 19155;
19156 -> 19127;
19157 -> 19156;
19157 -> 18620;
19158 -> 18620;
19159 -> 19126;
19159 -> 18620;
19160 -> 19157;
19160 -> 18620;
19161 -> 18620;
19162 -> 19158;
19162 -> 19161;
19163 -> 19159;
19163 -> 19161;
19164 -> 19160;
19164 -> 19161;
19165 -> 18622;
19165 -> 19161;
19166 -> 19161;
19167 -> 19163;
19167 -> 19166;
19167 -> 19161;
19168 -> 19164;
19168 -> 19161;
19169 -> 19162;
19169 -> 19161;
19170 -> 19167;
19170 -> 19168;
19170 -> 19161;
19171 -> 18622;
19171 -> 18620;
19172 -> 18620;
19173 -> 19171;
19173 -> 19172;
19174 -> 19101;
19174 -> 19172;
19175 -> 19173;
19175 -> 19093;
19175 -> 19172;
19176 -> 19172;
19177 -> 19173;
19177 -> 19176;
19178 -> 19177;
19178 -> 19172;
19179 -> 19175;
19179 -> 19172;
19180 -> 19174;
19180 -> 19175;
19180 -> 19172;
19181 -> 19174;
19181 -> 19175;
19181 -> 19172;
19182 -> 19181;
19182 -> 19172;
19183 -> 19174;
19183 -> 19175;
19183 -> 19172;
19184 -> 19183;
19184 -> 19172;
19185 -> 19172;
19186 -> 19179;
19186 -> 19185;
19187 -> 19184;
19187 -> 19185;
19188 -> 19187;
19188 -> 19185;
19189 -> 19186;
19189 -> 19187;
19189 -> 19185;
19190 -> 19174;
19190 -> 19183;
19190 -> 19172;
19191 -> 19190;
19191 -> 19172;
19192 -> 19191;
19193 -> 19192;
19194 -> 19192;
19195 -> 19193;
19195 -> 19194;
19196 -> 18622;
19196 -> 19194;
19197 -> 19194;
19198 -> 19196;
19198 -> 19197;
19199 -> 19197;
19200 -> 19199;
19200 -> 19197;
19201 -> 19197;
19202 -> 19200;
19202 -> 19201;
19203 -> 19198;
19203 -> 19183;
19203 -> 19201;
19204 -> 19203;
19204 -> 19183;
19204 -> 13997;
19204 -> 19201;
19205 -> 19204;
19205 -> 14019;
19205 -> 19201;
19206 -> 19202;
19206 -> 19201;
19207 -> 19201;
19208 -> 19205;
19208 -> 19207;
19209 -> 19206;
19209 -> 19207;
19210 -> 19208;
19211 -> 19208;
19211 -> 19197;
19212 -> 19211;
19213 -> 19198;
19213 -> 19212;
19214 -> 19212;
19215 -> 19213;
19215 -> 19214;
19216 -> 19214;
19217 -> 19215;
19217 -> 19216;
19218 -> 19216;
19218 -> 19214;
19219 -> 19215;
19219 -> 19212;
19220 -> 19213;
19220 -> 19212;
19221 -> 19212;
19222 -> 19220;
19222 -> 19221;
19223 -> 19219;
19223 -> 19221;
19224 -> 19221;
19225 -> 19222;
19225 -> 19224;
19226 -> 19225;
19226 -> 19221;
19227 -> 19222;
19227 -> 19221;
19228 -> 19223;
19228 -> 19222;
19228 -> 19221;
19229 -> 19223;
19229 -> 19222;
19229 -> 19221;
19230 -> 19229;
19230 -> 19221;
19231 -> 19223;
19231 -> 19222;
19231 -> 19221;
19232 -> 19231;
19232 -> 19221;
19233 -> 19221;
19234 -> 19227;
19234 -> 19233;
19235 -> 19232;
19235 -> 19233;
19236 -> 19235;
19236 -> 19233;
19237 -> 19234;
19237 -> 19235;
19237 -> 19233;
19238 -> 19212;
19239 -> 19238;
19239 -> 19212;
19240 -> 19212;
19241 -> 19213;
19241 -> 19240;
19242 -> 19241;
19242 -> 19231;
19242 -> 19240;
19243 -> 19241;
19243 -> 19231;
19243 -> 19240;
19244 -> 19243;
19244 -> 19212;
19245 -> 19244;
19245 -> 19212;
19246 -> 19212;
19247 -> 19213;
19247 -> 19246;
19248 -> 19246;
19249 -> 19247;
19249 -> 19248;
19250 -> 19248;
19251 -> 19249;
19251 -> 19250;
19252 -> 19251;
19252 -> 19248;
19253 -> 19248;
19254 -> 19249;
19254 -> 19253;
19255 -> 19254;
19255 -> 19231;
19255 -> 19253;
19256 -> 19255;
19256 -> 19248;
19257 -> 19248;
19258 -> 19248;
19259 -> 19249;
19259 -> 19248;
19260 -> 19257;
19260 -> 19248;
19261 -> 19258;
19261 -> 19248;
19262 -> 19248;
19263 -> 19259;
19263 -> 19262;
19264 -> 19260;
19264 -> 19262;
19265 -> 19261;
19265 -> 19262;
19266 -> 19262;
19267 -> 19262;
19268 -> 19266;
19268 -> 19267;
19269 -> 19263;
19269 -> 19267;
19270 -> 19269;
19270 -> 19231;
19270 -> 19267;
19271 -> 19269;
19271 -> 19231;
19271 -> 19267;
19272 -> 19271;
19272 -> 19262;
19273 -> 19248;
19274 -> 19257;
19274 -> 19248;
19275 -> 19274;
19275 -> 19246;
19276 -> 19275;
19276 -> 19212;
19277 -> 19212;
19278 -> 19213;
19278 -> 19277;
19279 -> 19278;
19279 -> 19231;
19279 -> 19277;
19280 -> 19278;
19280 -> 19231;
19280 -> 19277;
19281 -> 19280;
19281 -> 19212;
19282 -> 19219;
19282 -> 19281;
19283 -> 19238;
19283 -> 19281;
19284 -> 19281;
19285 -> 19282;
19285 -> 19284;
19286 -> 19283;
19286 -> 19284;
19287 -> 19281;
19287 -> 19284;
19288 -> 19284;
19289 -> 19287;
19289 -> 19288;
19290 -> 0;
19290 -> 19288;
19291 -> 19290;
19291 -> 19284;
19292 -> 19287;
19292 -> 19291;
19293 -> 19292;
19294 -> 19292;
19294 -> 19293;
19295 -> 19293;
19296 -> 19294;
19296 -> 19295;
19297 -> 19296;
19297 -> 19295;
19298 -> 19297;
19298 -> 0;
19298 -> 19295;
19299 -> 19295;
19300 -> 19298;
19300 -> 19293;
19301 -> 19300;
19302 -> 19301;
19303 -> 19302;
19303 -> 0;
19303 -> 19301;
19304 -> 19301;
19305 -> 19303;
19305 -> 19300;
19306 -> 19305;
19307 -> 19306;
19307 -> 19305;
19308 -> 19305;
19309 -> 19308;
19309 -> 19231;
19309 -> 19306;
19310 -> 19308;
19311 -> 19308;
19311 -> 19306;
19311 -> 19231;
19312 -> 19311;
19312 -> 19305;
19313 -> 19305;
19314 -> 19313;
19314 -> 19311;
19315 -> 19313;
19315 -> 19311;
19316 -> 19315;
19316 -> 19313;
19317 -> 19313;
19318 -> 19316;
19319 -> 19318;
19319 -> 19305;
19320 -> 19305;
19321 -> 0;
19321 -> 19293;
19322 -> 19321;
19322 -> 19292;
19323 -> 19286;
19323 -> 19322;
19323 -> 19239;
19323 -> 19292;
19324 -> 19292;
19325 -> 19324;
19325 -> 19315;
19326 -> 19324;
19327 -> 19324;
19327 -> 19315;
19328 -> 19327;
19328 -> 19292;
19329 -> 19281;
19330 -> 19219;
19330 -> 19327;
19331 -> 19286;
19331 -> 19327;
19332 -> 19330;
19332 -> 19327;
19333 -> 19327;
19334 -> 19327;
19335 -> 19327;
19336 -> 19327;
19337 -> 19336;
19338 -> 19337;
19338 -> 19327;
19339 -> 0;
19339 -> 19327;
19340 -> 19339;
19340 -> 19327;
19341 -> 19331;
19341 -> 19340;
19341 -> 19323;
19341 -> 19327;
19342 -> 19327;
19343 -> 19327;
19344 -> 19212;
19345 -> 19213;
19345 -> 19344;
19346 -> 19345;
19346 -> 19327;
19346 -> 19344;
19347 -> 19346;
19347 -> 19212;
19348 -> 19331;
19348 -> 19341;
19348 -> 19212;
19349 -> 19348;
19349 -> 19211;
19350 -> 19349;
19350 -> 19211;
19351 -> 19211;
19352 -> 19350;
19352 -> 19351;
19353 -> 19198;
19353 -> 19346;
19353 -> 19351;
19354 -> 19353;
19354 -> 19346;
19354 -> 19351;
19355 -> 19352;
19355 -> 19351;
19356 -> 19351;
19357 -> 19355;
19357 -> 19356;
19358 -> 0;
19358 -> 19357;
19359 -> 19354;
19359 -> 19358;
19359 -> 19351;
19360 -> 19349;
19360 -> 19197;
19361 -> 19360;
19361 -> 19194;
19362 -> 19194;
19363 -> 19361;
19363 -> 19362;
19363 -> 19194;
19364 -> 19361;
19364 -> 19194;
19365 -> 19194;
19366 -> 19196;
19366 -> 19365;
19367 -> 19366;
19367 -> 19346;
19367 -> 19365;
19368 -> 19367;
19368 -> 19194;
19369 -> 19194;
19370 -> 19368;
19370 -> 19369;
19371 -> 19370;
19371 -> 19369;
19372 -> 19370;
19372 -> 19369;
19373 -> 19372;
19373 -> 19346;
19373 -> 19369;
19374 -> 19373;
19374 -> 19369;
19375 -> 19373;
19375 -> 19369;
19376 -> 19375;
19376 -> 19346;
19376 -> 19369;
19377 -> 19376;
19377 -> 19369;
19378 -> 19376;
19378 -> 19369;
19379 -> 19369;
19379 -> 19194;
19380 -> 19194;
19381 -> 19364;
19381 -> 19379;
19381 -> 19194;
19382 -> 19381;
19382 -> 19192;
19383 -> 19192;
19384 -> 19126;
19384 -> 19192;
19385 -> 19157;
19385 -> 19192;
19386 -> 19192;
19387 -> 19383;
19387 -> 19386;
19388 -> 19384;
19388 -> 19386;
19389 -> 19385;
19389 -> 19386;
19390 -> 18622;
19390 -> 19386;
19391 -> 19386;
19392 -> 19388;
19392 -> 19391;
19392 -> 19386;
19393 -> 19389;
19393 -> 19386;
19394 -> 19387;
19394 -> 19386;
19395 -> 19393;
19395 -> 19394;
19395 -> 19155;
19395 -> 19383;
19395 -> 19168;
19395 -> 19386;
19396 -> 19392;
19396 -> 19395;
19396 -> 19386;
19397 -> 19157;
19397 -> 18620;
19398 -> 18620;
19399 -> 19397;
19399 -> 19398;
19399 -> 19155;
19399 -> 19395;
19399 -> 18620;
19400 -> 18617;
19401 -> 18618;
19401 -> 18617;
19402 -> 18617;
19403 -> 19401;
19403 -> 19402;
19404 -> 14853;
19404 -> 19402;
19405 -> 19402;
19406 -> 19404;
19406 -> 19405;
19407 -> 19406;
19407 -> 19346;
19407 -> 19405;
19408 -> 19407;
19408 -> 19402;
19409 -> 19403;
19409 -> 18618;
19409 -> 19402;
19410 -> 18617;
19411 -> 18617;
19412 -> 19411;
19413 -> 19411;
19413 -> 19412;
19414 -> 19412;
19414 -> 19411;
19415 -> 19411;
19415 -> 19346;
19416 -> 19415;
19416 -> 18617;
19417 -> 14853;
19417 -> 18617;
19418 -> 18617;
19419 -> 19417;
19419 -> 19418;
19420 -> 19416;
19420 -> 19418;
19421 -> 19419;
19421 -> 19346;
19421 -> 19359;
19421 -> 19418;
19422 -> 19420;
19422 -> 19421;
19422 -> 19418;
19423 -> 18617;
19424 -> 0;
19424 -> 18617;
19425 -> 18617;
19426 -> 19424;
19426 -> 19425;
19427 -> 14853;
19427 -> 19422;
19427 -> 19425;
19428 -> 19427;
19428 -> 19426;
19428 -> 19425;
19429 -> 19428;
19429 -> 18617;
19430 -> 18618;
19430 -> 18617;
19431 -> 18601;
19431 -> 14854;
19432 -> 19431;
19432 -> 15009;
19433 -> 14853;
19433 -> 19422;
19433 -> 15009;
19434 -> 19432;
19434 -> 15009;
19435 -> 19434;
19435 -> 15014;
19436 -> 19433;
19436 -> 15014;
19437 -> 19436;
19437 -> 19422;
19437 -> 19428;
19437 -> 19435;
19437 -> 15014;
19438 -> 19437;
19439 -> 19428;
19439 -> 14856;
19440 -> 19439;
19440 -> 14859;
19441 -> 19440;
19441 -> 14861;
19441 -> 14859;
19442 -> 19428;
19443 -> 19442;
19443 -> 19428;
19444 -> 19428;
19445 -> 19428;
19446 -> 19443;
19446 -> 19445;
19447 -> 19444;
19447 -> 19428;
19448 -> 19428;
19449 -> 14853;
19449 -> 19448;
19450 -> 19448;
19451 -> 19449;
19451 -> 19442;
19451 -> 19450;
19452 -> 19451;
19452 -> 19442;
19452 -> 14022;
19452 -> 19450;
19453 -> 19450;
19454 -> 19452;
19454 -> 19448;
19455 -> 19448;
19456 -> 19449;
19456 -> 19455;
19457 -> 19455;
19458 -> 19456;
19458 -> 19457;
19459 -> 19458;
19459 -> 19442;
19459 -> 19457;
19460 -> 19457;
19461 -> 19459;
19461 -> 19460;
19461 -> 19457;
19462 -> 19459;
19462 -> 19461;
19463 -> 19462;
19463 -> 19455;
19464 -> 19455;
19465 -> 19456;
19465 -> 19442;
19465 -> 19464;
19466 -> 19465;
19466 -> 19442;
19466 -> 14022;
19466 -> 19464;
19467 -> 19464;
19468 -> 19466;
19468 -> 19455;
19469 -> 19468;
19470 -> 19469;
19470 -> 19468;
19471 -> 19468;
19472 -> 19456;
19472 -> 19471;
19473 -> 19471;
19474 -> 19472;
19474 -> 19473;
19475 -> 19474;
19475 -> 19442;
19475 -> 19473;
19476 -> 19473;
19477 -> 19475;
19477 -> 19476;
19478 -> 19477;
19478 -> 0;
19478 -> 19476;
19479 -> 0;
19479 -> 19478;
19480 -> 19479;
19480 -> 19471;
19481 -> 19480;
19481 -> 0;
19481 -> 19471;
19482 -> 19471;
19483 -> 19472;
19483 -> 19482;
19484 -> 19483;
19484 -> 19471;
19485 -> 19480;
19485 -> 19471;
19486 -> 19485;
19486 -> 19468;
19487 -> 19463;
19487 -> 19442;
19487 -> 19468;
19488 -> 19468;
19489 -> 19456;
19489 -> 19442;
19489 -> 19488;
19490 -> 19489;
19490 -> 19442;
19490 -> 19488;
19491 -> 14022;
19491 -> 19488;
19492 -> 19468;
19493 -> 19448;
19494 -> 19428;
19495 -> 0;
19495 -> 19428;
19496 -> 19428;
19497 -> 19495;
19497 -> 19496;
19498 -> 14853;
19498 -> 19442;
19498 -> 19496;
19499 -> 19498;
19499 -> 19497;
19499 -> 19496;
19500 -> 19428;
19500 -> 14854;
19501 -> 19500;
19501 -> 15009;
19502 -> 14853;
19502 -> 19442;
19502 -> 15009;
19503 -> 19501;
19503 -> 15009;
19504 -> 19503;
19504 -> 15014;
19505 -> 19502;
19505 -> 15014;
19506 -> 19505;
19506 -> 19442;
19506 -> 19499;
19506 -> 19504;
19506 -> 15014;
19507 -> 19506;
19508 -> 14852;
19508 -> 19442;
19508 -> 19490;
19508 -> 19499;
19508 -> 14854;
19509 -> 19508;
19509 -> 14856;
19510 -> 19509;
19510 -> 14859;
19511 -> 19510;
19511 -> 14861;
19511 -> 14859;
19512 -> 19508;
19513 -> 12955;
19513 -> 12956;
19514 -> 12955;
19514 -> 12956;
19515 -> 19513;
19515 -> 12956;
19516 -> 12956;
19517 -> 19515;
19517 -> 19516;
19518 -> 19514;
19518 -> 19508;
19518 -> 19516;
19519 -> 19518;
19519 -> 19508;
19519 -> 19517;
19519 -> 19516;
19520 -> 12969;
19520 -> 19519;
19520 -> 12968;
19520 -> 12967;
19521 -> 19520;
19522 -> 19519;
19522 -> 12956;
19523 -> 19522;
19523 -> 12958;
19524 -> 19523;
19524 -> 12960;
19524 -> 12958;
19525 -> 2214;
19525 -> 2215;
19526 -> 2214;
19526 -> 2215;
19527 -> 19525;
19527 -> 2215;
19528 -> 2215;
19529 -> 19527;
19529 -> 19528;
19530 -> 19526;
19530 -> 19519;
19530 -> 19528;
19531 -> 19530;
19531 -> 19519;
19531 -> 19529;
19531 -> 19528;
19532 -> 2349;
19532 -> 19531;
19532 -> 2348;
19532 -> 2347;
19533 -> 19532;
19534 -> 19531;
19534 -> 2215;
19535 -> 19534;
19535 -> 2219;
19536 -> 19535;
19536 -> 2221;
19536 -> 2219;
19537 -> 2214;
19537 -> 2215;
19538 -> 2214;
19538 -> 2215;
19539 -> 19537;
19539 -> 2215;
19540 -> 2215;
19541 -> 19539;
19541 -> 19540;
19542 -> 19538;
19542 -> 19531;
19542 -> 19540;
19543 -> 19542;
19543 -> 19531;
19543 -> 19541;
19543 -> 19540;
19544 -> 2349;
19544 -> 19543;
19544 -> 2348;
19544 -> 2347;
19545 -> 19544;
19546 -> 19543;
19546 -> 2215;
19547 -> 19546;
19547 -> 2219;
19548 -> 19547;
19548 -> 2221;
19548 -> 2219;
19549 -> 2214;
19549 -> 2215;
19550 -> 2215;
19551 -> 2215;
19552 -> 19549;
19552 -> 19543;
19552 -> 19551;
19553 -> 19552;
19553 -> 2215;
19554 -> 2215;
19555 -> 19549;
19555 -> 19543;
19555 -> 19554;
19555 -> 2215;
19556 -> 2215;
19557 -> 19549;
19557 -> 19556;
19558 -> 19556;
19559 -> 19557;
19559 -> 19543;
19559 -> 19558;
19559 -> 19556;
19560 -> 19557;
19560 -> 19543;
19560 -> 19556;
19561 -> 19560;
19561 -> 2215;
19562 -> 19550;
19562 -> 2215;
19563 -> 2215;
19564 -> 19561;
19564 -> 19563;
19565 -> 19562;
19565 -> 19563;
19566 -> 19549;
19566 -> 19563;
19567 -> 19564;
19567 -> 19563;
19568 -> 19563;
19569 -> 19567;
19569 -> 19568;
19569 -> 19563;
19570 -> 19569;
19571 -> 2215;
19572 -> 2215;
19573 -> 19549;
19573 -> 19543;
19573 -> 19572;
19574 -> 19573;
19574 -> 19543;
19574 -> 19572;
19575 -> 19572;
19576 -> 19573;
19576 -> 2215;
19577 -> 19550;
19577 -> 2215;
19578 -> 19576;
19578 -> 19577;
19578 -> 19543;
19578 -> 19550;
19578 -> 2215;
19579 -> 19550;
19579 -> 19578;
19579 -> 2215;
19580 -> 2349;
19580 -> 19579;
19580 -> 2348;
19580 -> 2347;
19581 -> 19580;
19582 -> 19579;
19582 -> 2215;
19583 -> 19582;
19583 -> 2219;
19584 -> 19583;
19584 -> 2221;
19584 -> 2219;
19585 -> 2075;
19585 -> 2074;
19586 -> 19585;
19587 -> 19586;
19587 -> 2079;
19587 -> 19585;
19588 -> 19585;
19589 -> 19588;
19589 -> 2079;
19589 -> 19585;
19590 -> 2079;
19590 -> 19579;
19590 -> 19587;
19590 -> 19589;
19590 -> 2074;
19591 -> 2074;
19592 -> 2077;
19592 -> 19591;
19592 -> 2074;
19593 -> 2075;
19593 -> 2074;
19594 -> 2076;
19594 -> 2074;
19595 -> 2078;
19595 -> 2074;
19596 -> 2074;
19597 -> 19593;
19597 -> 19596;
19598 -> 19594;
19598 -> 19596;
19599 -> 19595;
19599 -> 19596;
19600 -> 2079;
19600 -> 19596;
19601 -> 19596;
19602 -> 19597;
19602 -> 19601;
19602 -> 19596;
19603 -> 19600;
19603 -> 19590;
19603 -> 19596;
19604 -> 19603;
19605 -> 19600;
19605 -> 19603;
19606 -> 19604;
19606 -> 19603;
19607 -> 19599;
19607 -> 19603;
19608 -> 19603;
19609 -> 19605;
19609 -> 19606;
19609 -> 19607;
19609 -> 19608;
19609 -> 19603;
19610 -> 19609;
19610 -> 19608;
19611 -> 19609;
19611 -> 19608;
19612 -> 19609;
19612 -> 19608;
19613 -> 19609;
19613 -> 19608;
19614 -> 19608;
19615 -> 19612;
19615 -> 19614;
19615 -> 19608;
19616 -> 19613;
19616 -> 19615;
19617 -> 19615;
19618 -> 19616;
19618 -> 19617;
19619 -> 19612;
19619 -> 19617;
19620 -> 19619;
19620 -> 19617;
19621 -> 19620;
19621 -> 19618;
19621 -> 19609;
19621 -> 19617;
19622 -> 19617;
19623 -> 19621;
19623 -> 19622;
19624 -> 0;
19624 -> 19622;
19625 -> 19621;
19625 -> 19624;
19625 -> 19617;
19626 -> 19621;
19626 -> 19622;
19627 -> 19621;
19627 -> 19622;
19628 -> 19626;
19628 -> 19622;
19629 -> 19628;
19629 -> 19622;
19630 -> 19629;
19631 -> 19626;
19631 -> 19630;
19632 -> 19631;
19632 -> 19630;
19633 -> 19632;
19633 -> 19625;
19633 -> 19630;
19634 -> 19621;
19634 -> 19622;
19635 -> 19622;
19636 -> 19634;
19636 -> 19635;
19637 -> 19635;
19638 -> 19636;
19638 -> 19637;
19639 -> 19638;
19639 -> 19633;
19639 -> 19637;
19640 -> 19635;
19641 -> 19636;
19641 -> 19633;
19641 -> 19635;
19642 -> 19641;
19642 -> 19622;
19643 -> 19622;
19644 -> 19634;
19644 -> 19643;
19645 -> 19644;
19645 -> 19633;
19645 -> 19643;
19646 -> 19643;
19647 -> 19644;
19647 -> 19633;
19647 -> 19643;
19648 -> 19647;
19648 -> 19622;
19649 -> 19642;
19649 -> 19633;
19649 -> 19622;
19650 -> 19648;
19650 -> 19633;
19650 -> 19622;
19651 -> 19622;
19652 -> 19642;
19652 -> 19633;
19652 -> 19651;
19652 -> 19622;
19653 -> 19648;
19653 -> 19652;
19654 -> 19653;
19654 -> 19633;
19654 -> 19622;
19655 -> 19653;
19655 -> 19622;
19656 -> 19621;
19656 -> 19622;
19657 -> 0;
19657 -> 19622;
19658 -> 19621;
19658 -> 19657;
19658 -> 19655;
19658 -> 19617;
19659 -> 19621;
19659 -> 19622;
19660 -> 19622;
19661 -> 19659;
19661 -> 19660;
19662 -> 19661;
19662 -> 19658;
19662 -> 19660;
19663 -> 19662;
19663 -> 19622;
19664 -> 19663;
19664 -> 19622;
19665 -> 19664;
19665 -> 19663;
19665 -> 19622;
19666 -> 19622;
19667 -> 19663;
19667 -> 19666;
19668 -> 19666;
19669 -> 19667;
19669 -> 19668;
19670 -> 19668;
19670 -> 19666;
19671 -> 19670;
19671 -> 19666;
19672 -> 19671;
19672 -> 19670;
19672 -> 19666;
19673 -> 19671;
19673 -> 19672;
19674 -> 19673;
19674 -> 19622;
19675 -> 19621;
19675 -> 19674;
19675 -> 19658;
19675 -> 19617;
19676 -> 19621;
19676 -> 19622;
19677 -> 19621;
19677 -> 19622;
19678 -> 19621;
19678 -> 19622;
19679 -> 19676;
19679 -> 19622;
19680 -> 19679;
19680 -> 19622;
19681 -> 19677;
19681 -> 19680;
19682 -> 19678;
19682 -> 19675;
19682 -> 19680;
19683 -> 19680;
19684 -> 19681;
19684 -> 19683;
19685 -> 19682;
19685 -> 19683;
19686 -> 19676;
19686 -> 19683;
19687 -> 19686;
19687 -> 19684;
19687 -> 19683;
19688 -> 19621;
19688 -> 19687;
19688 -> 19675;
19688 -> 19617;
19689 -> 19621;
19689 -> 19622;
19690 -> 19622;
19691 -> 19689;
19691 -> 19688;
19691 -> 19690;
19691 -> 19622;
19692 -> 19689;
19692 -> 19688;
19692 -> 19622;
19693 -> 19621;
19694 -> 19621;
19695 -> 19694;
19695 -> 19621;
19696 -> 19695;
19696 -> 19693;
19696 -> 19692;
19696 -> 19621;
19697 -> 19621;
19698 -> 19696;
19698 -> 19697;
19699 -> 19696;
19699 -> 19697;
19700 -> 0;
19700 -> 19697;
19701 -> 19696;
19701 -> 19697;
19702 -> 19696;
19702 -> 19697;
19703 -> 19702;
19703 -> 19696;
19704 -> 19615;
19705 -> 19600;
19705 -> 19702;
19705 -> 19603;
19706 -> 19604;
19706 -> 19702;
19706 -> 19603;
19707 -> 19600;
19707 -> 19705;
19707 -> 19596;
19708 -> 19600;
19708 -> 19705;
19708 -> 19596;
19709 -> 19590;
19709 -> 2074;
19710 -> 19709;
19710 -> 19705;
19710 -> 2074;
19711 -> 19708;
19711 -> 2074;
19712 -> 1004;
19713 -> 973;
19713 -> 19711;
19713 -> 19712;
19713 -> 1004;
19714 -> 972;
19714 -> 19711;
19714 -> 968;
19715 -> 969;
19715 -> 0;
19715 -> 968;
19716 -> 19715;
19717 -> 19716;
19717 -> 19715;
19718 -> 972;
19718 -> 19715;
19719 -> 19715;
19720 -> 19717;
19720 -> 19719;
19721 -> 19718;
19721 -> 19719;
19722 -> 973;
19722 -> 19719;
19723 -> 19722;
19723 -> 19719;
19724 -> 19719;
19725 -> 19720;
19725 -> 19719;
19726 -> 19721;
19726 -> 19719;
19727 -> 19723;
19727 -> 19724;
19727 -> 19725;
19727 -> 19726;
19727 -> 19714;
19727 -> 19716;
19727 -> 19719;
19728 -> 19727;
19728 -> 19724;
19729 -> 19727;
19729 -> 19724;
19730 -> 19724;
19731 -> 19729;
19731 -> 19727;
19731 -> 19730;
19731 -> 19724;
19732 -> 19731;
19733 -> 19729;
19733 -> 19731;
19734 -> 19731;
19735 -> 19733;
19735 -> 19734;
19736 -> 19735;
19736 -> 19734;
19737 -> 19734;
19738 -> 19736;
19738 -> 19737;
19739 -> 19737;
19740 -> 19738;
19740 -> 19739;
19741 -> 19740;
19741 -> 19739;
19742 -> 19740;
19742 -> 19737;
19743 -> 19737;
19744 -> 19742;
19744 -> 19743;
19745 -> 0;
19745 -> 19737;
19746 -> 19737;
19747 -> 19745;
19747 -> 19746;
19748 -> 19744;
19748 -> 19746;
19749 -> 19748;
19749 -> 19734;
19750 -> 19734;
19751 -> 19749;
19751 -> 19750;
19751 -> 19734;
19752 -> 19751;
19752 -> 19734;
19753 -> 19752;
19753 -> 19734;
19754 -> 19731;
19755 -> 19754;
19755 -> 19748;
19756 -> 19755;
19756 -> 19731;
19757 -> 19731;
19758 -> 19729;
19758 -> 19757;
19759 -> 19758;
19759 -> 19748;
19759 -> 19757;
19760 -> 19757;
19761 -> 19759;
19761 -> 19760;
19762 -> 19761;
19762 -> 19759;
19762 -> 19760;
19763 -> 19760;
19764 -> 19762;
19764 -> 19763;
19765 -> 19763;
19766 -> 19764;
19766 -> 19765;
19767 -> 19766;
19767 -> 19765;
19768 -> 19766;
19768 -> 19763;
19769 -> 19763;
19770 -> 19768;
19770 -> 19769;
19771 -> 19770;
19771 -> 19769;
19772 -> 19769;
19773 -> 19771;
19773 -> 19772;
19774 -> 19773;
19775 -> 19774;
19775 -> 19773;
19776 -> 19773;
19777 -> 19773;
19778 -> 19775;
19778 -> 19777;
19779 -> 19776;
19779 -> 19777;
19780 -> 19777;
19781 -> 19779;
19781 -> 19780;
19782 -> 19779;
19782 -> 19777;
19783 -> 19778;
19783 -> 19777;
19784 -> 19778;
19784 -> 19779;
19784 -> 19777;
19785 -> 19762;
19785 -> 19763;
19786 -> 19763;
19787 -> 19785;
19787 -> 19784;
19787 -> 19786;
19788 -> 19787;
19788 -> 19763;
19789 -> 19763;
19790 -> 19788;
19790 -> 19789;
19791 -> 19790;
19792 -> 19791;
19793 -> 19790;
19794 -> 19790;
19795 -> 19762;
19795 -> 19763;
19796 -> 19762;
19796 -> 19763;
19797 -> 19763;
19798 -> 19796;
19798 -> 19797;
19799 -> 19798;
19799 -> 19790;
19799 -> 19797;
19800 -> 19799;
19800 -> 19763;
19801 -> 19795;
19801 -> 19763;
19802 -> 19763;
19803 -> 19801;
19803 -> 19802;
19804 -> 19800;
19804 -> 19802;
19805 -> 19804;
19805 -> 19803;
19805 -> 19802;
19805 -> 19790;
19806 -> 19763;
19807 -> 19805;
19807 -> 19806;
19808 -> 19807;
19808 -> 19806;
19809 -> 19806;
19810 -> 19808;
19810 -> 19809;
19811 -> 19810;
19811 -> 19808;
19811 -> 19809;
19812 -> 19810;
19812 -> 19809;
19813 -> 19809;
19814 -> 19762;
19814 -> 19763;
19815 -> 19763;
19816 -> 19814;
19816 -> 19815;
19817 -> 19816;
19817 -> 19812;
19817 -> 19815;
19818 -> 19817;
19818 -> 19763;
19819 -> 19760;
19820 -> 19818;
19820 -> 19819;
19821 -> 19820;
19821 -> 19819;
19822 -> 19819;
19823 -> 19821;
19823 -> 19822;
19824 -> 19823;
19824 -> 19822;
19825 -> 19824;
19825 -> 19731;
19826 -> 19756;
19826 -> 19825;
19826 -> 19731;
19827 -> 19753;
19827 -> 19826;
19829 -> 0;
19831 -> 19828;
19831 -> 19830;
19832 -> 19829;
19832 -> 19830;
19833 -> 19830;
19834 -> 19833;
19834 -> 19830;
19835 -> 19831;
19835 -> 19833;
19835 -> 19830;
19836 -> 19832;
19836 -> 19833;
19836 -> 19830;
19837 -> 19830;
19838 -> 19837;
19838 -> 19827;
19839 -> 19729;
19839 -> 19824;
19839 -> 19731;
19840 -> 19838;
19840 -> 19731;
19841 -> 19731;
19842 -> 19839;
19842 -> 19840;
19842 -> 19841;
19842 -> 19835;
19842 -> 19836;
19842 -> 19824;
19842 -> 0;
19842 -> 19731;
19843 -> 19729;
19843 -> 19842;
19843 -> 19724;
19844 -> 19727;
19844 -> 19724;
19845 -> 19724;
19846 -> 19845;
19847 -> 19846;
19848 -> 19843;
19848 -> 19846;
19849 -> 19724;
19850 -> 19724;
19851 -> 19724;
19852 -> 19727;
19852 -> 19724;
19853 -> 19727;
19853 -> 19724;
19854 -> 19727;
19854 -> 19724;
19855 -> 19854;
19855 -> 19724;
19856 -> 19853;
19856 -> 19724;
19857 -> 19855;
19857 -> 19856;
19857 -> 19852;
19857 -> 19843;
19857 -> 19724;
19858 -> 19724;
19859 -> 19724;
19860 -> 19859;
19861 -> 19857;
19861 -> 19859;
19862 -> 19727;
19862 -> 19724;
19863 -> 19727;
19863 -> 19724;
19864 -> 19863;
19864 -> 19857;
19864 -> 19724;
19865 -> 19864;
19866 -> 19862;
19866 -> 19864;
19867 -> 19866;
19867 -> 19865;
19868 -> 19865;
19869 -> 19867;
19869 -> 19868;
19870 -> 19868;
19871 -> 19869;
19871 -> 19870;
19871 -> 19868;
19872 -> 19865;
19873 -> 0;
19873 -> 19864;
19874 -> 19864;
19875 -> 19873;
19875 -> 19874;
19876 -> 19863;
19876 -> 19874;
19877 -> 19875;
19877 -> 19874;
19878 -> 19874;
19879 -> 19877;
19879 -> 19878;
19880 -> 19876;
19880 -> 19866;
19880 -> 19878;
19881 -> 19880;
19881 -> 19866;
19881 -> 19879;
19881 -> 19878;
19882 -> 19864;
19883 -> 19864;
19884 -> 19864;
19885 -> 19863;
19885 -> 19884;
19886 -> 19884;
19887 -> 19885;
19887 -> 19886;
19888 -> 19887;
19888 -> 19866;
19888 -> 19886;
19889 -> 19884;
19890 -> 19884;
19891 -> 19885;
19891 -> 19866;
19891 -> 19890;
19891 -> 19884;
19892 -> 19891;
19892 -> 19864;
19893 -> 19864;
19894 -> 19863;
19894 -> 19893;
19895 -> 19893;
19896 -> 19894;
19896 -> 19866;
19896 -> 19895;
19897 -> 19896;
19897 -> 19866;
19897 -> 19893;
19898 -> 19897;
19898 -> 19893;
19899 -> 19898;
19899 -> 19864;
19900 -> 19892;
19900 -> 19899;
19900 -> 19864;
19901 -> 19864;
19902 -> 19863;
19902 -> 19866;
19902 -> 19864;
19903 -> 19863;
19903 -> 19866;
19903 -> 19864;
19904 -> 19863;
19904 -> 19866;
19904 -> 19864;
19905 -> 19883;
19905 -> 19864;
19906 -> 19904;
19906 -> 19905;
19906 -> 19866;
19906 -> 19864;
19907 -> 19863;
19907 -> 19906;
19907 -> 19724;
19908 -> 19863;
19908 -> 19906;
19908 -> 19724;
19909 -> 19722;
19909 -> 19719;
19910 -> 19719;
19911 -> 19720;
19911 -> 19719;
19912 -> 19721;
19912 -> 19719;
19913 -> 19909;
19913 -> 19910;
19913 -> 19911;
19913 -> 19912;
19913 -> 19908;
19913 -> 19714;
19913 -> 19719;
19914 -> 19910;
19915 -> 19913;
19915 -> 19910;
19916 -> 19913;
19916 -> 19910;
19917 -> 19916;
19917 -> 19913;
19917 -> 19910;
19918 -> 19913;
19918 -> 19910;
19919 -> 19917;
19919 -> 19910;
19920 -> 19910;
19921 -> 19913;
19921 -> 19917;
19921 -> 19920;
19921 -> 19910;
19922 -> 19910;
19923 -> 19917;
19923 -> 19913;
19924 -> 19913;
19925 -> 19923;
19925 -> 19924;
19926 -> 19925;
19926 -> 19924;
19927 -> 19926;
19927 -> 19917;
19927 -> 19924;
19928 -> 19927;
19929 -> 19927;
19929 -> 19928;
19930 -> 19929;
19930 -> 19917;
19930 -> 19928;
19931 -> 19930;
19932 -> 19924;
19933 -> 19932;
19933 -> 19913;
19934 -> 19913;
19935 -> 19917;
19935 -> 19933;
19935 -> 19913;
19936 -> 19917;
19936 -> 19935;
19937 -> 19936;
19937 -> 19913;
19938 -> 19937;
19938 -> 19924;
19939 -> 19938;
19939 -> 19936;
19939 -> 19924;
19940 -> 19936;
19940 -> 19913;
19941 -> 19936;
19941 -> 19913;
19942 -> 19941;
19942 -> 19913;
19943 -> 19942;
19943 -> 19940;
19943 -> 19939;
19943 -> 19913;
19944 -> 19913;
19945 -> 19943;
19945 -> 19944;
19946 -> 19944;
19947 -> 19945;
19947 -> 19946;
19948 -> 19946;
19949 -> 19947;
19949 -> 19943;
19949 -> 19948;
19949 -> 19946;
19950 -> 19949;
19950 -> 19944;
19951 -> 19944;
19952 -> 19945;
19952 -> 19951;
19953 -> 19952;
19953 -> 19949;
19953 -> 19951;
19954 -> 19953;
19954 -> 0;
19954 -> 19951;
19955 -> 19954;
19955 -> 19944;
19956 -> 19943;
19956 -> 19944;
19957 -> 19944;
19958 -> 19956;
19958 -> 19957;
19959 -> 19957;
19959 -> 19944;
19960 -> 19943;
19960 -> 19959;
19960 -> 19955;
19960 -> 19913;
19961 -> 19943;
19961 -> 19944;
19962 -> 19961;
19962 -> 19944;
19963 -> 19962;
19963 -> 19944;
19964 -> 19944;
19965 -> 19943;
19965 -> 19963;
19965 -> 19960;
19965 -> 19913;
19966 -> 19943;
19966 -> 19944;
19967 -> 19944;
19968 -> 19966;
19968 -> 19967;
19969 -> 19968;
19969 -> 19965;
19969 -> 19967;
19970 -> 19969;
19970 -> 19944;
19971 -> 19943;
19971 -> 19944;
19972 -> 19944;
19973 -> 19971;
19973 -> 19970;
19973 -> 19972;
19974 -> 19973;
19974 -> 19970;
19974 -> 14025;
19974 -> 19972;
19975 -> 19972;
19976 -> 19974;
19976 -> 19944;
19977 -> 19971;
19977 -> 19970;
19977 -> 19976;
19978 -> 19977;
19978 -> 19944;
19979 -> 19978;
19979 -> 19957;
19980 -> 19977;
19980 -> 19944;
19981 -> 19977;
19981 -> 19944;
19982 -> 19981;
19982 -> 19944;
19983 -> 19944;
19984 -> 19982;
19984 -> 19983;
19985 -> 19980;
19985 -> 19983;
19986 -> 19984;
19986 -> 19983;
19987 -> 19986;
19987 -> 19985;
19987 -> 19977;
19987 -> 19983;
19988 -> 19983;
19989 -> 19987;
19989 -> 19988;
19990 -> 19988;
19991 -> 19987;
19991 -> 19990;
19991 -> 19983;
19992 -> 19944;
19993 -> 19991;
19993 -> 19944;
19994 -> 19993;
19994 -> 19957;
19995 -> 19991;
19995 -> 19988;
19996 -> 19991;
19997 -> 19991;
19997 -> 19996;
19998 -> 19997;
19998 -> 19991;
19998 -> 19996;
19999 -> 19998;
20000 -> 19719;
20001 -> 19720;
20001 -> 19719;
20002 -> 19721;
20002 -> 19719;
20003 -> 19719;
20004 -> 20000;
20004 -> 20003;
20005 -> 20001;
20005 -> 20003;
20006 -> 20002;
20006 -> 20003;
20007 -> 19722;
20007 -> 20003;
20008 -> 20003;
20009 -> 20007;
20009 -> 19991;
20009 -> 20008;
20009 -> 20003;
20010 -> 20004;
20010 -> 20003;
20011 -> 20003;
20012 -> 20010;
20012 -> 20011;
20013 -> 20007;
20013 -> 20011;
20014 -> 20011;
20015 -> 20013;
20015 -> 19991;
20015 -> 20014;
20015 -> 20011;
20016 -> 20003;
20017 -> 19715;
20018 -> 19716;
20018 -> 19715;
20019 -> 974;
20019 -> 20018;
20019 -> 19991;
20019 -> 19715;
20020 -> 971;
20020 -> 968;
20021 -> 974;
20021 -> 968;
20022 -> 972;
20022 -> 968;
20023 -> 20020;
20023 -> 20021;
20023 -> 20022;
20023 -> 973;
20023 -> 963;
20023 -> 20019;
20023 -> 968;
20024 -> 968;
20025 -> 958;
20026 -> 963;
20026 -> 20023;
20026 -> 958;
20027 -> 1;
20028 -> 950;
20028 -> 20027;
20029 -> 20027;
20030 -> 20028;
20030 -> 20029;
20031 -> 20029;
20032 -> 20030;
20032 -> 20031;
20033 -> 20031;
20034 -> 20032;
20034 -> 20033;
20035 -> 20034;
20035 -> 20026;
20035 -> 20033;
20036 -> 20034;
20036 -> 20026;
20036 -> 20033;
20037 -> 20036;
20037 -> 20031;
20038 -> 20032;
20038 -> 20026;
20038 -> 20031;
20039 -> 20027;
20040 -> 20027;
20041 -> 20038;
20041 -> 1;
20042 -> 1;
20043 -> 20041;
20043 -> 20042;
20044 -> 20042;
20045 -> 20043;
20045 -> 1;
20046 -> 1;
20047 -> 1;
20048 -> 20045;
20048 -> 20047;
20049 -> 20046;
20049 -> 20047;
20050 -> 20048;
20050 -> 20047;
20051 -> 20049;
20051 -> 20047;
20052 -> 20047;
20053 -> 20050;
20053 -> 20052;
20054 -> 20051;
20054 -> 20052;
20055 -> 20052;
20056 -> 20053;
20056 -> 20052;
20057 -> 20054;
20057 -> 20052;
20058 -> 20055;
20058 -> 20052;
20059 -> 20052;
20060 -> 20056;
20060 -> 20059;
20061 -> 20057;
20061 -> 20059;
20062 -> 20058;
20062 -> 20059;
20063 -> 20061;
20063 -> 20059;
20064 -> 20059;
20065 -> 20063;
20065 -> 20064;
20066 -> 20064;
20067 -> 0;
20067 -> 20064;
20068 -> 20065;
20068 -> 20066;
20068 -> 20067;
20068 -> 20064;
20069 -> 20064;
20070 -> 20065;
20070 -> 20064;
20071 -> 20064;
20072 -> 20070;
20072 -> 20071;
20072 -> 20064;
20073 -> 20070;
20073 -> 20072;
20074 -> 20069;
20074 -> 20073;
20074 -> 20072;
20075 -> 20069;
20075 -> 20074;
20075 -> 20064;
20076 -> 20069;
20076 -> 20075;
20076 -> 20064;
20077 -> 20060;
20077 -> 20059;
20078 -> 20059;
20079 -> 20076;
20079 -> 20078;
20079 -> 20059;
20080 -> 20059;
20081 -> 20076;
20081 -> 20080;
20081 -> 20059;
20082 -> 20059;
20083 -> 20081;
20083 -> 20082;
20084 -> 20077;
20084 -> 20082;
20085 -> 20082;
20086 -> 20085;
20086 -> 20082;
20087 -> 20082;
20088 -> 20087;
20089 -> 20083;
20089 -> 20082;
20090 -> 20085;
20090 -> 20082;
20091 -> 20084;
20091 -> 20089;
20091 -> 20090;
20091 -> 20038;
20091 -> 20086;
20091 -> 20082;
20092 -> 20052;
20093 -> 20091;
20093 -> 20092;
20093 -> 20052;
20094 -> 20093;
20095 -> 20091;
20095 -> 20052;
20096 -> 20095;
20096 -> 1;
20097 -> 1;
20098 -> 1;
20099 -> 20096;
20099 -> 20098;
20100 -> 20097;
20100 -> 20098;
20101 -> 20100;
20101 -> 20098;
20102 -> 20098;
20103 -> 20101;
20103 -> 20102;
20104 -> 20102;
20105 -> 20103;
20105 -> 20102;
20106 -> 20104;
20106 -> 20102;
20107 -> 20102;
20108 -> 20105;
20108 -> 20107;
20109 -> 20106;
20109 -> 20107;
20110 -> 20108;
20110 -> 20107;
20111 -> 20107;
20112 -> 20110;
20112 -> 20111;
20113 -> 20111;
20114 -> 0;
20114 -> 20111;
20115 -> 20112;
20115 -> 20113;
20115 -> 20114;
20115 -> 20111;
20116 -> 20111;
20117 -> 20112;
20117 -> 20111;
20118 -> 20111;
20119 -> 20117;
20119 -> 20118;
20119 -> 20111;
20120 -> 20117;
20120 -> 20119;
20121 -> 20116;
20121 -> 20120;
20121 -> 20119;
20122 -> 20116;
20122 -> 20121;
20122 -> 20111;
20123 -> 20116;
20123 -> 20122;
20123 -> 20111;
20124 -> 20107;
20125 -> 20123;
20125 -> 20124;
20125 -> 20107;
20126 -> 20107;
20127 -> 20123;
20127 -> 20126;
20127 -> 20107;
20128 -> 20107;
20129 -> 20127;
20129 -> 20128;
20130 -> 20128;
20131 -> 20130;
20131 -> 20128;
20132 -> 20128;
20133 -> 20132;
20134 -> 20129;
20134 -> 20128;
20135 -> 20130;
20135 -> 20128;
20136 -> 20102;
20137 -> 20099;
20137 -> 20136;
20137 -> 20102;
20138 -> 20137;
20139 -> 20099;
20139 -> 1;
20140 -> 1;
20141 -> 20139;
20141 -> 20140;
20142 -> 20140;
20143 -> 20141;
20143 -> 20142;
20144 -> 3414;
20144 -> 20142;
20145 -> 20143;
20145 -> 20099;
20145 -> 20142;
20146 -> 20145;
20146 -> 20140;
20147 -> 0;
20147 -> 1;
20148 -> 1;
20149 -> 20146;
20149 -> 20148;
20150 -> 0;
20150 -> 20148;
20151 -> 20150;
20151 -> 1;
20152 -> 1;
20153 -> 1;
20154 -> 20146;
20154 -> 20153;
20155 -> 20153;
20156 -> 20154;
20156 -> 20099;
20156 -> 20155;
20157 -> 20156;
20157 -> 20099;
20157 -> 20155;
20158 -> 20157;
20158 -> 20153;
20159 -> 20158;
20159 -> 1;
20160 -> 20099;
20160 -> 1;
20161 -> 1;
20162 -> 1;
20163 -> 20160;
20163 -> 20162;
20164 -> 20161;
20164 -> 20162;
20165 -> 20164;
20165 -> 20162;
20166 -> 20162;
20167 -> 20165;
20167 -> 20166;
20168 -> 20166;
20169 -> 20167;
20169 -> 20166;
20170 -> 20168;
20170 -> 20166;
20171 -> 20166;
20172 -> 20169;
20172 -> 20171;
20173 -> 20170;
20173 -> 20171;
20174 -> 20172;
20174 -> 20171;
20175 -> 20171;
20176 -> 20174;
20176 -> 20175;
20177 -> 20175;
20178 -> 0;
20178 -> 20175;
20179 -> 20176;
20179 -> 20177;
20179 -> 20178;
20179 -> 20175;
20180 -> 20175;
20181 -> 20176;
20181 -> 20175;
20182 -> 20175;
20183 -> 20181;
20183 -> 20182;
20183 -> 20175;
20184 -> 20181;
20184 -> 20183;
20185 -> 20180;
20185 -> 20184;
20185 -> 20183;
20186 -> 20180;
20186 -> 20185;
20186 -> 20175;
20187 -> 20180;
20187 -> 20186;
20187 -> 20175;
20188 -> 20171;
20189 -> 20187;
20189 -> 20188;
20189 -> 20171;
20190 -> 20171;
20191 -> 20187;
20191 -> 20190;
20191 -> 20171;
20192 -> 20171;
20193 -> 20191;
20193 -> 20192;
20194 -> 20192;
20195 -> 20194;
20195 -> 20192;
20196 -> 20192;
20197 -> 0;
20197 -> 20196;
20198 -> 20196;
20199 -> 20197;
20199 -> 20198;
20200 -> 20193;
20200 -> 20192;
20201 -> 20194;
20201 -> 20192;
20202 -> 20163;
20203 -> 20166;
20204 -> 20202;
20204 -> 20163;
20204 -> 20203;
20204 -> 20166;
20205 -> 20204;
20206 -> 1;
20207 -> 20202;
20207 -> 1;
20208 -> 1;
20209 -> 20207;
20209 -> 20208;
20210 -> 20208;
20211 -> 20209;
20211 -> 20210;
20212 -> 3414;
20212 -> 20210;
20213 -> 20211;
20213 -> 20163;
20213 -> 20202;
20213 -> 20210;
20214 -> 20213;
20214 -> 20208;
20215 -> 1;
20216 -> 20214;
20216 -> 20215;
20217 -> 20202;
20217 -> 1;
20218 -> 1;
20219 -> 20217;
20219 -> 20218;
20220 -> 20218;
20221 -> 20218;
20222 -> 20220;
20222 -> 20221;
20223 -> 20219;
20223 -> 20221;
20224 -> 20223;
20224 -> 20163;
20224 -> 20202;
20224 -> 20221;
20225 -> 20224;
20225 -> 20218;
20226 -> 1;
20227 -> 1;
20228 -> 20225;
20228 -> 20227;
20229 -> 20227;
20230 -> 20228;
20230 -> 20163;
20230 -> 20202;
20230 -> 20225;
20230 -> 20229;
20231 -> 20230;
20231 -> 20163;
20231 -> 20202;
20231 -> 20225;
20231 -> 20229;
20232 -> 20231;
20232 -> 20227;
20233 -> 20232;
20233 -> 1;
20234 -> 0;
20234 -> 1;
20235 -> 1;
20236 -> 20225;
20236 -> 20235;
20237 -> 0;
20237 -> 20235;
20238 -> 20237;
20238 -> 1;
20239 -> 1;
20240 -> 1;
20241 -> 20225;
20241 -> 20240;
20242 -> 20240;
20243 -> 20241;
20243 -> 20163;
20243 -> 20202;
20243 -> 20225;
20243 -> 20242;
20244 -> 20243;
20244 -> 20163;
20244 -> 20202;
20244 -> 20225;
20244 -> 20242;
20245 -> 20244;
20245 -> 20240;
20246 -> 20245;
20246 -> 1;
20247 -> 20095;
20247 -> 1;
20248 -> 1;
20249 -> 1;
20250 -> 20247;
20250 -> 20249;
20251 -> 20248;
20251 -> 20249;
20252 -> 20251;
20252 -> 20249;
20253 -> 20249;
20254 -> 20252;
20254 -> 20253;
20255 -> 20253;
20256 -> 20254;
20256 -> 20253;
20257 -> 20255;
20257 -> 20253;
20258 -> 20253;
20259 -> 20256;
20259 -> 20258;
20260 -> 20257;
20260 -> 20258;
20261 -> 20259;
20261 -> 20258;
20262 -> 20258;
20263 -> 20261;
20263 -> 20262;
20264 -> 20262;
20265 -> 0;
20265 -> 20262;
20266 -> 20263;
20266 -> 20264;
20266 -> 20265;
20266 -> 20262;
20267 -> 20262;
20268 -> 20263;
20268 -> 20262;
20269 -> 20262;
20270 -> 20268;
20270 -> 20269;
20270 -> 20262;
20271 -> 20268;
20271 -> 20270;
20272 -> 20267;
20272 -> 20271;
20272 -> 20270;
20273 -> 20267;
20273 -> 20272;
20273 -> 20262;
20274 -> 20267;
20274 -> 20273;
20274 -> 20262;
20275 -> 20258;
20276 -> 20274;
20276 -> 20275;
20276 -> 20258;
20277 -> 20258;
20278 -> 20274;
20278 -> 20277;
20278 -> 20258;
20279 -> 20258;
20280 -> 20278;
20280 -> 20279;
20281 -> 20279;
20282 -> 20281;
20282 -> 20279;
20283 -> 20279;
20284 -> 20283;
20285 -> 20250;
20285 -> 20163;
20285 -> 20284;
20285 -> 20283;
20286 -> 20250;
20286 -> 20163;
20286 -> 20283;
20287 -> 20280;
20287 -> 20279;
20288 -> 20281;
20288 -> 20279;
20289 -> 20253;
20290 -> 20286;
20290 -> 20289;
20290 -> 20253;
20291 -> 20290;
20292 -> 17237;
20292 -> 1;
20293 -> 20286;
20293 -> 1;
20294 -> 1;
20295 -> 20293;
20295 -> 20294;
20296 -> 20294;
20297 -> 20295;
20297 -> 20296;
20298 -> 3414;
20298 -> 20296;
20299 -> 20297;
20299 -> 20286;
20299 -> 20296;
20300 -> 20299;
20300 -> 20294;
20301 -> 1;
20302 -> 20300;
20302 -> 20301;
20303 -> 20286;
20303 -> 1;
20304 -> 1;
20305 -> 20303;
20305 -> 20304;
20306 -> 20304;
20307 -> 20304;
20308 -> 20306;
20308 -> 20307;
20309 -> 20305;
20309 -> 20307;
20310 -> 20309;
20310 -> 20286;
20310 -> 20307;
20311 -> 20310;
20311 -> 20304;
20312 -> 1;
20313 -> 1;
20314 -> 20311;
20314 -> 20313;
20315 -> 20313;
20316 -> 20314;
20316 -> 20286;
20316 -> 20311;
20316 -> 20315;
20317 -> 20316;
20317 -> 20286;
20317 -> 20311;
20317 -> 20315;
20318 -> 20317;
20318 -> 20313;
20319 -> 20318;
20319 -> 1;
20320 -> 0;
20320 -> 1;
20321 -> 1;
20322 -> 20311;
20322 -> 20321;
20323 -> 0;
20323 -> 20321;
20324 -> 20323;
20324 -> 1;
20325 -> 1;
20326 -> 1;
20327 -> 20311;
20327 -> 20326;
20328 -> 20326;
20329 -> 20327;
20329 -> 20286;
20329 -> 20311;
20329 -> 20328;
20330 -> 20329;
20330 -> 20286;
20330 -> 20311;
20330 -> 20328;
20331 -> 20330;
20331 -> 20326;
20332 -> 20331;
20332 -> 1;
20333 -> 20286;
20333 -> 1;
20334 -> 1;
20335 -> 1;
20336 -> 20333;
20336 -> 20335;
20337 -> 20334;
20337 -> 20335;
20338 -> 20337;
20338 -> 20335;
20339 -> 20335;
20340 -> 20338;
20340 -> 20339;
20341 -> 20339;
20342 -> 20340;
20342 -> 20339;
20343 -> 20341;
20343 -> 20339;
20344 -> 20339;
20345 -> 20342;
20345 -> 20344;
20346 -> 20343;
20346 -> 20344;
20347 -> 20345;
20347 -> 20344;
20348 -> 20344;
20349 -> 20347;
20349 -> 20348;
20350 -> 20348;
20351 -> 0;
20351 -> 20348;
20352 -> 20349;
20352 -> 20350;
20352 -> 20351;
20352 -> 20348;
20353 -> 20348;
20354 -> 20349;
20354 -> 20348;
20355 -> 20348;
20356 -> 20354;
20356 -> 20355;
20356 -> 20348;
20357 -> 20354;
20357 -> 20356;
20358 -> 20353;
20358 -> 20357;
20358 -> 20356;
20359 -> 20353;
20359 -> 20358;
20359 -> 20348;
20360 -> 20353;
20360 -> 20359;
20360 -> 20348;
20361 -> 20344;
20362 -> 20360;
20362 -> 20361;
20362 -> 20344;
20363 -> 20344;
20364 -> 20360;
20364 -> 20363;
20364 -> 20344;
20365 -> 20344;
20366 -> 20364;
20366 -> 20365;
20367 -> 20365;
20368 -> 20367;
20368 -> 20365;
20369 -> 20365;
20370 -> 0;
20370 -> 20369;
20371 -> 20369;
20372 -> 20370;
20372 -> 20371;
20373 -> 20366;
20373 -> 20365;
20374 -> 20367;
20374 -> 20365;
20375 -> 20336;
20376 -> 20339;
20377 -> 20375;
20377 -> 20336;
20377 -> 20376;
20377 -> 20339;
20378 -> 20377;
20379 -> 20375;
20379 -> 1;
20380 -> 1;
20381 -> 20379;
20381 -> 20380;
20382 -> 20380;
20383 -> 20380;
20384 -> 20382;
20384 -> 20383;
20385 -> 20381;
20385 -> 20383;
20386 -> 20385;
20386 -> 20336;
20386 -> 20375;
20386 -> 20383;
20387 -> 20386;
20387 -> 20380;
20388 -> 1;
20389 -> 1;
20390 -> 20387;
20390 -> 20389;
20391 -> 20389;
20392 -> 20390;
20392 -> 20336;
20392 -> 20375;
20392 -> 20387;
20392 -> 20391;
20393 -> 20392;
20393 -> 20389;
20394 -> 20393;
20394 -> 1;
20395 -> 1;
20396 -> 1;
20397 -> 20387;
20397 -> 20396;
20398 -> 20396;
20399 -> 20397;
20399 -> 20398;
20400 -> 20399;
20400 -> 20336;
20400 -> 20375;
20400 -> 20387;
20400 -> 20398;
20401 -> 20400;
20402 -> 20396;
20403 -> 20397;
20403 -> 20336;
20403 -> 20375;
20403 -> 20387;
20403 -> 20396;
20404 -> 20403;
20404 -> 1;
20405 -> 0;
20405 -> 1;
20406 -> 20387;
20406 -> 1;
20407 -> 1;
20408 -> 20406;
20408 -> 20407;
20409 -> 20407;
20410 -> 20408;
20410 -> 20409;
20411 -> 20410;
20411 -> 20336;
20411 -> 20375;
20411 -> 20387;
20411 -> 20409;
20412 -> 20411;
20412 -> 20407;
20413 -> 20407;
20414 -> 20412;
20414 -> 20413;
20415 -> 20414;
20415 -> 20336;
20415 -> 20375;
20415 -> 20387;
20415 -> 20413;
20416 -> 20414;
20416 -> 20415;
20417 -> 0;
20417 -> 20415;
20418 -> 20415;
20419 -> 20416;
20419 -> 20418;
20420 -> 1;
20421 -> 1;
20422 -> 20416;
20422 -> 20421;
20423 -> 0;
20423 -> 20421;
20424 -> 20423;
20424 -> 1;
}